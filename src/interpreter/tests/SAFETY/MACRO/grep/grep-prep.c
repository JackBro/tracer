/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __off_t;
typedef long __off64_t;
typedef long __time_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __ssize_t;
typedef char *__caddr_t;
struct _IO_FILE;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
struct _IO_FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef __off_t off_t;
typedef __ssize_t ssize_t;
typedef __caddr_t caddr_t;
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
struct matcher {
   char *name ;
   void (*compile)(char * , size_t  ) ;
   char *(*execute)(char * , size_t  , char ** ) ;
};
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   long __unused[3] ;
};
typedef unsigned int reg_syntax_t;
enum __anonenum_reg_errcode_t_25 {
    REG_NOERROR = 0,
    REG_NOMATCH = 1,
    REG_BADPAT = 2,
    REG_ECOLLATE = 3,
    REG_ECTYPE = 4,
    REG_EESCAPE = 5,
    REG_ESUBREG = 6,
    REG_EBRACK = 7,
    REG_EPAREN = 8,
    REG_EBRACE = 9,
    REG_BADBR = 10,
    REG_ERANGE = 11,
    REG_ESPACE = 12,
    REG_BADRPT = 13,
    REG_EEND = 14,
    REG_ESIZE = 15,
    REG_ERPAREN = 16
} ;
typedef enum __anonenum_reg_errcode_t_25 reg_errcode_t;
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
typedef struct re_pattern_buffer regex_t;
typedef int regoff_t;
struct re_registers {
   unsigned int num_regs ;
   regoff_t *start ;
   regoff_t *end ;
};
struct __anonstruct_regmatch_t_26 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
typedef struct __anonstruct_regmatch_t_26 regmatch_t;
typedef char boolean;
enum __anonenum_re_opcode_t_28 {
    no_op = 0,
    exactn = 1,
    anychar = 2,
    charset = 3,
    charset_not = 4,
    start_memory = 5,
    stop_memory = 6,
    duplicate = 7,
    begline = 8,
    endline = 9,
    begbuf = 10,
    endbuf = 11,
    jump = 12,
    jump_past_alt = 13,
    on_failure_jump = 14,
    on_failure_keep_string_jump = 15,
    pop_failure_jump = 16,
    maybe_pop_jump = 17,
    dummy_failure_jump = 18,
    push_dummy_failure = 19,
    succeed_n = 20,
    jump_n = 21,
    set_number_at = 22,
    wordchar = 23,
    notwordchar = 24,
    wordbeg = 25,
    wordend = 26,
    wordbound = 27,
    notwordbound = 28
} ;
typedef enum __anonenum_re_opcode_t_28 re_opcode_t;
typedef unsigned int regnum_t;
typedef int pattern_offset_t;
struct __anonstruct_compile_stack_elt_t_29 {
   pattern_offset_t begalt_offset ;
   pattern_offset_t fixup_alt_jump ;
   pattern_offset_t inner_group_offset ;
   pattern_offset_t laststart_offset ;
   regnum_t regnum ;
};
typedef struct __anonstruct_compile_stack_elt_t_29 compile_stack_elt_t;
struct __anonstruct_compile_stack_type_30 {
   compile_stack_elt_t *stack ;
   unsigned int size ;
   unsigned int avail ;
};
typedef struct __anonstruct_compile_stack_type_30 compile_stack_type;
typedef unsigned char *fail_stack_elt_t;
struct __anonstruct_fail_stack_type_31 {
   fail_stack_elt_t *stack ;
   unsigned int size ;
   unsigned int avail ;
};
typedef struct __anonstruct_fail_stack_type_31 fail_stack_type;
struct __anonstruct_bits_33 {
   unsigned int match_null_string_p : 2 ;
   unsigned int is_active : 1 ;
   unsigned int matched_something : 1 ;
   unsigned int ever_matched_something : 1 ;
};
union __anonunion_register_info_type_32 {
   fail_stack_elt_t word ;
   struct __anonstruct_bits_33 bits ;
};
typedef union __anonunion_register_info_type_32 register_info_type;
typedef int charclass[(((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))];
enum __anonenum_token_34 {
    END = -1,
    EMPTY = 256,
    BACKREF = 257,
    BEGLINE = 258,
    ENDLINE = 259,
    BEGWORD = 260,
    ENDWORD = 261,
    LIMWORD = 262,
    NOTLIMWORD = 263,
    QMARK = 264,
    STAR = 265,
    PLUS = 266,
    REPMN = 267,
    CAT = 268,
    OR = 269,
    ORTOP = 270,
    LPAREN = 271,
    RPAREN = 272,
    CSET = 273
} ;
typedef enum __anonenum_token_34 token;
struct __anonstruct_position_35 {
   unsigned int strchr ;
   unsigned int constraint ;
};
typedef struct __anonstruct_position_35 position;
struct __anonstruct_position_set_36 {
   position *elems ;
   int nelem ;
};
typedef struct __anonstruct_position_set_36 position_set;
struct __anonstruct_dfa_state_37 {
   int hash ;
   position_set elems ;
   char newline ;
   char letter ;
   char backref ;
   unsigned char constraint ;
   int first_end ;
};
typedef struct __anonstruct_dfa_state_37 dfa_state;
struct dfamust {
   int exact ;
   char *must ;
   struct dfamust *next ;
};
struct dfa {
   charclass *charclasses ;
   int cindex ;
   int calloc ;
   token *tokens ;
   int tindex ;
   int talloc ;
   int depth ;
   int nleaves ;
   int nregexps ;
   dfa_state *states ;
   int sindex ;
   int salloc ;
   position_set *follows ;
   int searchflag ;
   int tralloc ;
   int trcount ;
   int **trans ;
   int **realtrans ;
   int **fails ;
   int *success ;
   int *newlines ;
   struct dfamust *musts ;
};
typedef void *ptr_t;
struct __anonstruct_prednames_38 {
   char *name ;
   int (*pred)() ;
};
struct __anonstruct_must_39 {
   char **in ;
   char *left ;
   char *right ;
   char *is ;
};
typedef struct __anonstruct_must_39 must;
struct kwsmatch {
   int strchr ;
   char *beg[1] ;
   size_t size[1] ;
};
typedef void *kwset_t;
typedef long ptrdiff_t;
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   ptrdiff_t temp ;
   int alignment_mask ;
   struct _obstack_chunk *(*chunkfun)() ;
   void (*freefun)() ;
   char *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
};
struct trie;
struct tree {
   struct tree *llink ;
   struct tree *rlink ;
   struct trie *trie ;
   unsigned char label ;
   char balance ;
};
struct trie {
   unsigned int accepting ;
   struct tree *links ;
   struct trie *parent ;
   struct trie *next ;
   struct trie *fail ;
   int depth ;
   int shift ;
   int maxshift ;
};
struct kwset {
   struct obstack obstack ;
   int words ;
   struct trie *trie ;
   int mind ;
   int maxd ;
   unsigned char delta[256] ;
   struct trie *next[256] ;
   char *target ;
   int mind2 ;
   char *trans ;
};
enum __anonenum_dirs_40 {
    L = 0,
    R = 1
} ;
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
extern int *__errno_location(void) ;
extern struct _IO_FILE *stdin ;
extern struct _IO_FILE *stdout ;
extern int fclose(FILE *__stream ) ;
extern FILE *fopen(char *__filename , char *__modes ) ;
extern int fprintf(FILE *__stream , char *__format  , ...) ;
extern int printf(char *__format  , ...) ;
extern int puts(char *__s ) ;
extern size_t fread(void *__ptr , size_t __size , size_t __n , FILE *__stream ) ;
extern size_t fwrite(void *__ptr , size_t __size , size_t __n , FILE *__s ) ;
extern int feof(FILE *__stream ) ;
extern int ferror(FILE *__stream ) ;
extern int atoi(char *__nptr ) ;
extern void *malloc(size_t __size ) ;
extern void *calloc(size_t __nmemb , size_t __size ) ;
extern void *realloc(void *__ptr , size_t __size ) ;
extern void *valloc(size_t __size ) ;
extern void abort(void) ;
extern void exit(int __status ) ;
extern void *memcpy(void *__dest , void *__src , size_t __n ) ;
extern void *memset(void *__s , int __c , size_t __n ) ;
extern int memcmp(void *__s1 , void *__s2 , size_t __n ) ;
extern void *memchr(void *__s , int __c , size_t __n ) ;
extern char *strcpy(char *__dest , char *__src ) ;
extern char *strncpy(char *__dest , char *__src , size_t __n ) ;
extern int strcmp(char *__s1 , char *__s2 ) ;
extern int strncmp(char *__s1 , char *__s2 , size_t __n ) ;
extern char *strchr(char *__s , int __c ) ;
extern char *strrchr(char *__s , int __c ) ;
extern size_t strlen(char *__s ) ;
extern char *strerror(int __errnum ) ;
extern int open(char *__file , int __oflag  , ...) ;
extern __off_t lseek(int __fd , __off_t __offset , int __whence ) ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern char *optarg ;
extern int optind ;
extern int getopt(int ___argc , char **___argv , char *__shortopts ) ;
extern int getpagesize(void) ;
void fatal(char *mesg , int errnum ) ;
struct matcher matchers[9] ;
char *matcher  ;
int match_icase  ;
int match_words  ;
int match_lines  ;
static void (*compile)()  ;
static char *(*execute)()  ;
static char *prog  ;
static char *filename  ;
static int errseen  ;
static void error(char *mesg , int errnum ) 
{ char *myCIL___tmp ;

  {
  if (errnum) {
    myCIL___tmp = strerror(errnum);
    fprintf((FILE *)stdout, (char *)"%s: %s: %s\n", prog, mesg, myCIL___tmp);
  } else {
    fprintf((FILE *)stdout, (char *)"%s: %s\n", prog, mesg);
  }
  errseen = 1;
  return;
}
}
void fatal(char *mesg , int errnum ) 
{ 

  {
  error(mesg, errnum);
  exit(2);
}
}
char *xmalloc(size_t size ) 
{ char *result ;
  void *myCIL___tmp ;

  {
  myCIL___tmp = malloc(size);
  result = (char *)myCIL___tmp;
  if (size) {
    if (! result) {
      fatal("memory exhausted", 0);
    }
  }
  return (result);
}
}
char *xrealloc(char *ptr , size_t size ) 
{ char *result ;
  void *myCIL___tmp ;
  void *myCIL___tmp___0 ;

  {
  if (ptr) {
    myCIL___tmp = realloc((void *)ptr, size);
    result = (char *)myCIL___tmp;
  } else {
    myCIL___tmp___0 = malloc(size);
    result = (char *)myCIL___tmp___0;
  }
  if (size) {
    if (! result) {
      fatal("memory exhausted", 0);
    }
  }
  return (result);
}
}
static char *buffer  ;
static size_t bufsalloc  ;
static size_t bufalloc  ;
static int bufdesc  ;
static char *bufbeg  ;
static char *buflim  ;
extern int fstat(int __fd , struct stat *__buf ) ;
extern void *mmap(void *__addr , size_t __len , int __prot , int __flags , int __fd , __off_t __offset ) ;
static int bufmapped  ;
static struct stat bufstat  ;
static off_t bufoffset  ;
static int initialized  ;
void reset(int fd ) 
{ int myCIL___tmp___0 ;
  int myCIL___tmp___1 ;
  void *myCIL___tmp___2 ;
  int myCIL___tmp___3 ;

  {
  if (! initialized) {
    initialized = 1;
    myCIL___tmp___1 = getpagesize();
    if (8192 > myCIL___tmp___1) {
      bufsalloc = 8192UL;
    } else {
      myCIL___tmp___0 = getpagesize();
      bufsalloc = (unsigned long )myCIL___tmp___0;
    }
    bufalloc = 5UL * bufsalloc;
    myCIL___tmp___2 = valloc(bufalloc + 1UL);
    buffer = (char *)myCIL___tmp___2;
    if (! buffer) {
      fatal("memory exhausted", 0);
    }
    bufbeg = buffer;
    buflim = buffer;
  }
  bufdesc = fd;
  myCIL___tmp___3 = fstat(fd, & bufstat);
  if (myCIL___tmp___3 < 0) {
    bufmapped = 0;
  } else {
    if (! ((bufstat.st_mode & 61440U) == 32768U)) {
      bufmapped = 0;
    } else {
      bufmapped = 1;
      bufoffset = lseek(fd, 0L, 1);
    }
  }
  return;
}
}
static int pagesize  ;
static int fillbuf(size_t save ) 
{ char *nbuffer ;
  char *dp ;
  char *sp ;
  int cc ;
  caddr_t maddr ;
  void *myCIL___tmp ;
  char *myCIL___tmp___0 ;
  char *myCIL___tmp___1 ;
  size_t myCIL___tmp___2 ;
  void *myCIL___tmp___3 ;
  int *myCIL___tmp___4 ;
  char *myCIL___tmp___5 ;
  ssize_t myCIL___tmp___6 ;

  {
  if (pagesize == 0) {
    pagesize = getpagesize();
    if (pagesize == 0) {
      abort();
    }
  }
  if (save > bufsalloc) {
    while (save > bufsalloc) {
      bufsalloc = bufsalloc * 2UL;
    }
    bufalloc = 5UL * bufsalloc;
    myCIL___tmp = valloc(bufalloc + 1UL);
    nbuffer = (char *)myCIL___tmp;
    if (! nbuffer) {
      fatal("memory exhausted", 0);
    }
  } else {
    nbuffer = buffer;
  }
  sp = buflim - save;
  dp = (nbuffer + bufsalloc) - save;
  bufbeg = dp;
  while (1) {
    myCIL___tmp___2 = save;
    save = save - 1UL;
    if (! myCIL___tmp___2) {
      break;
    }
    myCIL___tmp___0 = dp;
    dp = dp + 1;
    myCIL___tmp___1 = sp;
    sp = sp + 1;
    *myCIL___tmp___0 = *myCIL___tmp___1;
  }
  buffer = nbuffer;
  if (bufmapped) {
    if (bufoffset % (long )pagesize == 0L) {
      if ((size_t )(bufstat.st_size - bufoffset) >= bufalloc - bufsalloc) {
        maddr = buffer + bufsalloc;
        myCIL___tmp___3 = mmap((void *)maddr, bufalloc - bufsalloc, 3, 18, bufdesc, bufoffset);
        maddr = (char *)myCIL___tmp___3;
        if ((unsigned long )maddr == (unsigned long )((char *)-1)) {
          myCIL___tmp___4 = __errno_location();
          myCIL___tmp___5 = strerror(*myCIL___tmp___4);
          fprintf((FILE *)stdout, (char *)"%s: warning: %s: %s\n", filename, myCIL___tmp___5);
          goto tryread;
        }
        cc = (int )(bufalloc - bufsalloc);
        bufoffset = bufoffset + (off_t )cc;
      } else {
        goto tryread;
      }
    } else {
      goto tryread;
    }
  } else {
    tryread: 
    if (bufmapped) {
      bufmapped = 0;
      lseek(bufdesc, bufoffset, 0);
    }
    myCIL___tmp___6 = read(bufdesc, (void *)(buffer + bufsalloc), bufalloc - bufsalloc);
    cc = (int )myCIL___tmp___6;
  }
  if (cc > 0) {
    buflim = (buffer + bufsalloc) + cc;
  } else {
    buflim = buffer + bufsalloc;
  }
  return (cc);
}
}
static int out_quiet  ;
static int out_invert  ;
static int out_file  ;
static int out_line  ;
static int out_byte  ;
static int out_before  ;
static int out_after  ;
static size_t totalcc  ;
static char *lastnl  ;
static char *lastout  ;
static size_t totalnl  ;
static int pending  ;
static void nlscan(char *lim ) 
{ char *beg ;

  {
  beg = lastnl;
  while ((unsigned long )beg < (unsigned long )lim) {
    if ((int )*beg == 10) {
      totalnl = totalnl + 1UL;
    }
    beg = beg + 1;
  }
  lastnl = beg;
  return;
}
}
static void prline(char *beg , char *lim , char sep ) 
{ int *myCIL___tmp ;
  int myCIL___tmp___0 ;

  {
  if (out_file) {
    printf((char *)"%s%c", filename, sep);
  }
  if (out_line) {
    nlscan(beg);
    totalnl = totalnl + 1UL;
    printf((char *)"%d%c", totalnl, sep);
    lastnl = lim;
  }
  if (out_byte) {
    printf((char *)"%lu%c", totalcc + (size_t )(beg - bufbeg), sep);
  }
  fwrite((void *)beg, 1UL, (unsigned long )(lim - beg), (FILE *)stdout);
  myCIL___tmp___0 = ferror(stdout);
  if (myCIL___tmp___0) {
    myCIL___tmp = __errno_location();
    error("writing output", *myCIL___tmp);
  }
  lastout = lim;
  return;
}
}
static void prpending(char *lim ) 
{ char *nl ;
  void *myCIL___tmp ;

  {
  if (! lastout) {
    lastout = bufbeg;
  }
  while (1) {
    if (pending > 0) {
      if (! ((unsigned long )lastout < (unsigned long )lim)) {
        break;
      }
    } else {
      break;
    }
    pending = pending - 1;
    myCIL___tmp = memchr((void *)lastout, '\n', (unsigned long )(lim - lastout));
    nl = (char *)myCIL___tmp;
    if ((unsigned long )nl != (unsigned long )((char *)0)) {
      nl = nl + 1;
    } else {
      nl = lim;
    }
    prline(lastout, nl, (char )'-');
  }
  return;
}
}
static int used  ;
static void prtext(char *beg , char *lim , int *nlinesp ) 
{ char *bp ;
  char *p ;
  char *nl ;
  int i ;
  int n ;
  void *myCIL___tmp ;
  void *myCIL___tmp___0 ;

  {
  if (! out_quiet) {
    if (pending > 0) {
      prpending(beg);
    }
  }
  p = beg;
  if (! out_quiet) {
    if (lastout) {
      bp = lastout;
    } else {
      bp = bufbeg;
    }
    i = 0;
    while (i < out_before) {
      if ((unsigned long )p > (unsigned long )bp) {
        while (1) {
          p = p - 1;
          if ((unsigned long )p > (unsigned long )bp) {
            if (! ((int )*(p + -1) != 10)) {
              break;
            }
          } else {
            break;
          }
        }
      }
      i = i + 1;
    }
    if (out_before) {
      goto _L;
    } else {
      if (out_after) {
        _L: /* CIL Label */ 
        if (used) {
          if ((unsigned long )p != (unsigned long )lastout) {
            puts("--");
          }
        }
      }
    }
    while ((unsigned long )p < (unsigned long )beg) {
      myCIL___tmp = memchr((void *)p, '\n', (unsigned long )(beg - p));
      nl = (char *)myCIL___tmp;
      prline(p, nl + 1, (char )'-');
      p = nl + 1;
    }
  }
  if (nlinesp) {
    n = 0;
    while ((unsigned long )p < (unsigned long )lim) {
      myCIL___tmp___0 = memchr((void *)p, '\n', (unsigned long )(lim - p));
      nl = (char *)myCIL___tmp___0;
      if ((unsigned long )nl != (unsigned long )((char *)0)) {
        nl = nl + 1;
      } else {
        nl = lim;
      }
      if (! out_quiet) {
        prline(p, nl, (char )':');
      }
      p = nl;
      n = n + 1;
    }
    *nlinesp = n;
  } else {
    if (! out_quiet) {
      prline(beg, lim, (char )':');
    }
  }
  pending = out_after;
  used = 1;
  return;
}
}
static int grepbuf(char *beg , char *lim ) 
{ int nlines ;
  int n ;
  register char *p ;
  register char *b ;
  char *endp ;

  {
  nlines = 0;
  p = beg;
  while (1) {
    b = (*execute)(p, lim - p, & endp);
    if (! ((unsigned long )b != (unsigned long )((char *)0))) {
      break;
    }
    if ((unsigned long )b == (unsigned long )lim) {
      if ((unsigned long )b > (unsigned long )beg) {
        if ((int )*(b + -1) == 10) {
          break;
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        if ((unsigned long )b == (unsigned long )beg) {
          break;
        }
      }
    }
    if (! out_invert) {
      prtext(b, endp, (int *)0);
      nlines = nlines + 1;
    } else {
      if ((unsigned long )p < (unsigned long )b) {
        prtext(p, b, & n);
        nlines = nlines + n;
      }
    }
    p = endp;
  }
  if (out_invert) {
    if ((unsigned long )p < (unsigned long )lim) {
      prtext(p, lim, & n);
      nlines = nlines + n;
    }
  }
  return (nlines);
}
}
static int grep(int fd ) 
{ int nlines ;
  int i ;
  size_t residue ;
  size_t save ;
  char *beg ;
  char *lim ;
  int *myCIL___tmp ;
  int myCIL___tmp___0 ;
  int myCIL___tmp___1 ;
  int myCIL___tmp___2 ;

  {
  reset(fd);
  totalcc = 0UL;
  lastout = (char *)0;
  totalnl = 0UL;
  pending = 0;
  nlines = 0;
  residue = 0UL;
  save = 0UL;
  while (1) {
    myCIL___tmp___0 = fillbuf(save);
    if (myCIL___tmp___0 < 0) {
      myCIL___tmp = __errno_location();
      error((char *)filename, *myCIL___tmp);
      return (nlines);
    }
    lastnl = bufbeg;
    if (lastout) {
      lastout = bufbeg;
    }
    if ((size_t )(buflim - bufbeg) == save) {
      break;
    }
    beg = (bufbeg + save) - residue;
    lim = buflim;
    while (1) {
      if ((unsigned long )lim > (unsigned long )beg) {
        if (! ((int )*(lim + -1) != 10)) {
          break;
        }
      } else {
        break;
      }
      lim = lim - 1;
    }
    residue = (unsigned long )(buflim - lim);
    if ((unsigned long )beg < (unsigned long )lim) {
      myCIL___tmp___1 = grepbuf(beg, lim);
      nlines = nlines + myCIL___tmp___1;
      if (pending) {
        prpending(lim);
      }
    }
    i = 0;
    beg = lim;
    while (1) {
      if (i < out_before) {
        if ((unsigned long )beg > (unsigned long )bufbeg) {
          if (! ((unsigned long )beg != (unsigned long )lastout)) {
            break;
          }
        } else {
          break;
        }
      } else {
        break;
      }
      i = i + 1;
      while (1) {
        beg = beg - 1;
        if ((unsigned long )beg > (unsigned long )bufbeg) {
          if (! ((int )*(beg + -1) != 10)) {
            break;
          }
        } else {
          break;
        }
      }
    }
    if ((unsigned long )beg != (unsigned long )lastout) {
      lastout = (char *)0;
    }
    save = (unsigned long )((lim + residue) - beg);
    totalcc = totalcc + ((size_t )(buflim - bufbeg) - save);
    if (out_line) {
      nlscan(beg);
    }
  }
  if (residue) {
    myCIL___tmp___2 = grepbuf((bufbeg + save) - residue, buflim);
    nlines = nlines + myCIL___tmp___2;
    if (pending) {
      prpending(buflim);
    }
  }
  return (nlines);
}
}
static char version[21]  ; //= 
//  {      (char )'G',      (char )'N',      (char )'U',      (char )' ', 
//        (char )'g',      (char )'r',      (char )'e',      (char )'p', 
//        (char )' ',      (char )'v',      (char )'e',      (char )'r', 
//        (char )'s',      (char )'i',      (char )'o',      (char )'n', 
//        (char )' ',      (char )'2',      (char )'.',      (char )'0', 
//        (char )'\000'};
static void usage(void) 
{ 

  {
  fprintf((FILE *)stdout, (char *)"usage: %s [-[[AB] ]<num>] [-[CEFGVchilnqsvwx]] [-[ef]] <expr> [<files...>]\n", prog);
  exit(2);
}
}
int setmatcher(char *name ) 
{ int i ;
  int myCIL___tmp ;

  {
  i = 0;
  while (matchers[i].name) {
    myCIL___tmp = strcmp((char *)name, (char *)matchers[i].name);
    if (myCIL___tmp == 0) {
      compile = (void (*)())matchers[i].compile;
      execute = (char *(*)())matchers[i].execute;
      return (1);
    }
    i = i + 1;
  }
  return (0);
}
}
int main(int argc , char **argv ) 
{ char *keys ;
  size_t keycc ;
  size_t oldcc ;
  size_t keyalloc ;
  int keyfound ;
  int count_matches ;
  int no_filenames ;
  int list_files ;
  int suppress_errors ;
  int opt ;
  int cc ;
  int desc ;
  int count ;
  int status ;
  FILE *fp ;
  char *myCIL___tmp ;
  char *myCIL___tmp___0 ;
  int myCIL___tmp___1 ;
  int myCIL___tmp___2 ;
  int myCIL___tmp___3 ;
  size_t myCIL___tmp___4 ;
  size_t myCIL___tmp___5 ;
  FILE *myCIL___tmp___7 ;
  int myCIL___tmp___8 ;
  int *myCIL___tmp___9 ;
  size_t myCIL___tmp___10 ;
  int myCIL___tmp___11 ;
  size_t myCIL___tmp___12 ;
  int myCIL___tmp___13 ;
  int myCIL___tmp___14 ;
  int myCIL___tmp___15 ;
  int myCIL___tmp___17 ;
  int myCIL___tmp___18 ;
  int *myCIL___tmp___19 ;
  int myCIL___tmp___20 ;

  {
  *(argv + 0) = (char *)"target";
  prog = *(argv + 0);
  if (prog) {
    myCIL___tmp___0 = strrchr((char *)prog, '/');
    if (myCIL___tmp___0) {
      myCIL___tmp = strrchr((char *)prog, '/');
      prog = myCIL___tmp + 1;
    }
  }
  keys = (char *)((void *)0);
  keycc = 0UL;
  keyfound = 0;
  count_matches = 0;
  no_filenames = 0;
  list_files = 0;
  suppress_errors = 0;
  matcher = (char *)((void *)0);
  while (1) {
    opt = getopt(argc, (char **)argv, "0123456789A:B:CEFGVX:bce:f:hiLlnqsvwxy");
    if (! (opt != -1)) {
      break;
    }
    switch (opt) {
    case 48: 
    case 49: 
    case 50: 
    case 51: 
    case 52: 
    case 53: 
    case 54: 
    case 55: 
    case 56: 
    case 57: 
    out_before = (10 * out_before + opt) - 48;
    out_after = (10 * out_after + opt) - 48;
    break;
    case 65: 
    out_after = atoi((char *)optarg);
    if (out_after < 0) {
      usage();
    }
    break;
    case 66: 
    out_before = atoi((char *)optarg);
    if (out_before < 0) {
      usage();
    }
    break;
    case 67: 
    out_after = 2;
    out_before = out_after;
    break;
    case 69: 
    if (matcher) {
      myCIL___tmp___1 = strcmp((char *)matcher, "egrep");
      if (myCIL___tmp___1 != 0) {
        fatal("you may specify only one of -E, -F, or -G", 0);
      }
    }
    matcher = (char *)"posix-egrep";
    break;
    case 70: 
    if (matcher) {
      myCIL___tmp___2 = strcmp((char *)matcher, "fgrep");
      if (myCIL___tmp___2 != 0) {
        fatal("you may specify only one of -E, -F, or -G", 0);
      }
    }
    matcher = (char *)"fgrep";
    break;
    case 71: 
    if (matcher) {
      myCIL___tmp___3 = strcmp((char *)matcher, "grep");
      if (myCIL___tmp___3 != 0) {
        fatal("you may specify only one of -E, -F, or -G", 0);
      }
    }
    matcher = (char *)"grep";
    break;
    case 86: 
    fprintf((FILE *)stdout, (char *)"%s\n", version);
    break;
    case 88: 
    if (matcher) {
      fatal("matcher already specified", 0);
    }
    matcher = optarg;
    break;
    case 98: 
    out_byte = 1;
    break;
    case 99: 
    out_quiet = 1;
    count_matches = 1;
    break;
    case 101: 
    myCIL___tmp___4 = strlen((char *)optarg);
    cc = (int )myCIL___tmp___4;
    keys = xrealloc(keys, (keycc + (size_t )cc) + 1UL);
    if (keyfound) {
      myCIL___tmp___5 = keycc;
      keycc = keycc + 1UL;
      *(keys + myCIL___tmp___5) = (char )'\n';
    }
    strcpy((char *)(keys + keycc), (char *)optarg);
    keycc = keycc + (size_t )cc;
    keyfound = 1;
    break;
    case 102: 
    myCIL___tmp___8 = strcmp((char *)optarg, "-");
    if (myCIL___tmp___8 != 0) {
      myCIL___tmp___7 = fopen((char *)optarg, (char *)"r");
      fp = myCIL___tmp___7;
    } else {
      fp = stdin;
    }
    if (! fp) {
      myCIL___tmp___9 = __errno_location();
      fatal((char *)optarg, *myCIL___tmp___9);
    }
    keyalloc = 1UL;
    while (keyalloc <= keycc) {
      keyalloc = keyalloc * 2UL;
    }
    keys = xrealloc(keys, keyalloc);
    oldcc = keycc;
    if (keyfound) {
      myCIL___tmp___10 = keycc;
      keycc = keycc + 1UL;
      *(keys + myCIL___tmp___10) = (char )'\n';
    }
    while (1) {
      myCIL___tmp___11 = feof(fp);
      if (myCIL___tmp___11) {
        break;
      } else {
        myCIL___tmp___12 = fread((void *)(keys + keycc), 1UL, keyalloc - keycc, (FILE *)fp);
        cc = (int )myCIL___tmp___12;
        if (! (cc > 0)) {
          break;
        }
      }
      keycc = keycc + (size_t )cc;
      if (keycc == keyalloc) {
        keyalloc = keyalloc * 2UL;
        keys = xrealloc(keys, keyalloc);
      }
    }
    if ((unsigned long )fp != (unsigned long )stdin) {
      fclose(fp);
    }
    if (keycc - oldcc > 0UL) {
      if ((int )*(keys + (keycc - 1UL)) == 10) {
        keycc = keycc - 1UL;
      }
    }
    keyfound = 1;
    break;
    case 104: 
    no_filenames = 1;
    break;
    case 105: 
    case 121: 
    match_icase = 1;
    break;
    case 76: 
    out_quiet = 1;
    list_files = -1;
    break;
    case 108: 
    out_quiet = 1;
    list_files = 1;
    break;
    case 110: 
    out_line = 1;
    break;
    case 113: 
    out_quiet = 1;
    break;
    case 115: 
    suppress_errors = 1;
    break;
    case 118: 
    out_invert = 1;
    break;
    case 119: 
    match_words = 1;
    break;
    case 120: 
    match_lines = 1;
    break;
    default: 
    usage();
    break;
    }
  }
  if (! keyfound) {
    if (optind < argc) {
      myCIL___tmp___13 = optind;
      optind = optind + 1;
      keys = *(argv + myCIL___tmp___13);
      keycc = strlen((char *)keys);
    } else {
      usage();
    }
  }
  if (! matcher) {
    matcher = prog;
  }
  myCIL___tmp___14 = setmatcher(matcher);
  if (! myCIL___tmp___14) {
    myCIL___tmp___15 = setmatcher((char *)"default");
    if (! myCIL___tmp___15) {
      abort();
    }
  }
  (*compile)(keys, keycc);
  if (argc - optind > 1) {
    if (! no_filenames) {
      out_file = 1;
    }
  }
  status = 1;
  if (optind < argc) {
    while (optind < argc) {
      myCIL___tmp___18 = strcmp((char *)*(argv + optind), "-");
      if (myCIL___tmp___18) {
        myCIL___tmp___17 = open((char *)*(argv + optind), 0);
        desc = myCIL___tmp___17;
      } else {
        desc = 0;
      }
      if (desc < 0) {
        if (! suppress_errors) {
          myCIL___tmp___19 = __errno_location();
          error((char *)*(argv + optind), *myCIL___tmp___19);
        }
      } else {
        if (desc == 0) {
          filename = (char *)"(standard input)";
        } else {
          filename = *(argv + optind);
        }
        count = grep(desc);
        if (count_matches) {
          if (out_file) {
            printf((char *)"%s:", filename);
          }
          printf((char *)"%d\n", count);
        }
        if (count) {
          status = 0;
          if (list_files == 1) {
            printf((char *)"%s\n", filename);
          }
        } else {
          if (list_files == -1) {
            printf((char *)"%s\n", filename);
          }
        }
      }
      if (desc != 0) {
        close(desc);
      }
      optind = optind + 1;
    }
  } else {
    filename = (char *)"(standard input)";
    count = grep(0);
    if (count_matches) {
      printf((char *)"%d\n", count);
    }
    if (count) {
      status = 0;
      if (list_files == 1) {
        printf((char *)"(standard input)\n");
      }
    } else {
      if (list_files == -1) {
        printf((char *)"(standard input)\n");
      }
    }
  }
  if (errseen) {
    myCIL___tmp___20 = 2;
  } else {
    myCIL___tmp___20 = status;
  }
  exit(myCIL___tmp___20);
}
}
static char re_syntax_table[256]  ;
static void init_syntax_once(void) ;
static int done  =    0;
static void init_syntax_once(void) 
{ register int c ;

  {
  if (done) {
    return;
  }
  memset((void *)(re_syntax_table), 0, sizeof(re_syntax_table));
  c = 'a';
  while (c <= 122) {
    re_syntax_table[c] = (char)1;
    c = c + 1;
  }
  c = 'A';
  while (c <= 90) {
    re_syntax_table[c] = (char)1;
    c = c + 1;
  }
  c = '0';
  while (c <= 57) {
    re_syntax_table[c] = (char)1;
    c = c + 1;
  }
  re_syntax_table['_'] = (char)1;
  done = 1;
  return;
}
}
reg_syntax_t re_set_syntax(reg_syntax_t syntax ) ;
char *re_compile_pattern(char *pattern , int length , struct re_pattern_buffer *bufp ) ;
int re_compile_fastmap(struct re_pattern_buffer *bufp ) ;
int re_search(struct re_pattern_buffer *bufp , char *string , int size , int startpos , int range , struct re_registers *regs ) ;
int re_search_2(struct re_pattern_buffer *bufp , char *string1 , int size1 , char *string2 , int size2 , int startpos , int range , struct re_registers *regs , int stop ) ;
int re_match(struct re_pattern_buffer *bufp , char *string , int size , int pos , struct re_registers *regs ) ;
int re_match_2(struct re_pattern_buffer *bufp , char *string1 , int size1 , char *string2 , int size2 , int pos , struct re_registers *regs , int stop ) ;
void re_set_registers(struct re_pattern_buffer *bufp , struct re_registers *regs , unsigned int num_regs , regoff_t *starts , regoff_t *ends ) ;
int regcomp(regex_t *preg , char *pattern , int cflags ) ;
int regexec(regex_t *preg , char *string , size_t nmatch , regmatch_t *pmatch , int eflags ) ;
size_t regerror(int errcode , regex_t *preg , char *errbuf , size_t errbuf_size ) ;
void regfree(regex_t *preg ) ;
extern unsigned short **__ctype_b_loc(void) ;
extern int tolower(int __c ) ;
extern int toupper(int __c ) ;
reg_syntax_t re_syntax_options  =    (reg_syntax_t )0;
reg_syntax_t re_set_syntax(reg_syntax_t syntax ) 
{ reg_syntax_t ret ;

  {
  ret = re_syntax_options;
  re_syntax_options = syntax;
  return (ret);
}
}
static char *re_error_msg[17]  ; //= 
//  {      (char *)((void *)0),      "No match",      "Invalid regular expression",      "Invalid collation character", 
//        "Invalid character class name",      "Trailing backslash",      "Invalid back reference",      "Unmatched [ or [^", 
//        "Unmatched ( or \\(",      "Unmatched \\{",      "Invalid content of \\{\\}",      "Invalid range end", 
//        "Memory exhausted",      "Invalid preceding regular expression",      "Premature end of regular expression",      "Regular expression too big", 
//        "Unmatched ) or \\)"};
static void store_op1(re_opcode_t op , unsigned char *loc , int arg ) ;
static void store_op2(re_opcode_t op , unsigned char *loc , int arg1 , int arg2 ) ;
static void insert_op1(re_opcode_t op , unsigned char *loc , int arg , unsigned char *end ) ;
static void insert_op2(re_opcode_t op , unsigned char *loc , int arg1 , int arg2 , unsigned char *end ) ;
static boolean at_begline_loc_p(char *pattern , char *p , reg_syntax_t syntax ) ;
static boolean at_endline_loc_p(char *p , char *pend , int syntax ) ;
static boolean group_in_compile_stack(compile_stack_type compile_stack , regnum_t regnum ) ;
static reg_errcode_t compile_range(char **p_ptr , char *pend , char *translate , reg_syntax_t syntax , unsigned char *b ) ;
static reg_errcode_t regex_compile(char *pattern , int size , reg_syntax_t syntax , struct re_pattern_buffer *bufp ) 
{ register unsigned char c ;
  register unsigned char c1 ;
  char *p1 ;
  register unsigned char *b ;
  compile_stack_type compile_stack ;
  char *p ;
  char *pend ;
  char *translate ;
  unsigned char *pending_exact ;
  unsigned char *laststart ;
  unsigned char *begalt ;
  char *beg_interval ;
  unsigned char *fixup_alt_jump ;
  regnum_t regnum ;
  void *myCIL___tmp ;
  unsigned int myCIL___tmp___0 ;
  void *myCIL___tmp___1 ;
  void *myCIL___tmp___2 ;
  char *myCIL___tmp___3 ;
  unsigned char *old_buffer ;
  void *myCIL___tmp___4 ;
  unsigned char *myCIL___tmp___5 ;
  boolean myCIL___tmp___6 ;
  unsigned char *old_buffer___0 ;
  void *myCIL___tmp___7 ;
  unsigned char *myCIL___tmp___8 ;
  boolean myCIL___tmp___9 ;
  boolean keep_string_p ;
  char zero_times_ok ;
  char many_times_ok ;
  char *myCIL___tmp___10 ;
  char *myCIL___tmp___11 ;
  unsigned char *old_buffer___1 ;
  void *myCIL___tmp___12 ;
  int myCIL___tmp___13 ;
  int myCIL___tmp___14 ;
  int myCIL___tmp___15 ;
  int myCIL___tmp___16 ;
  unsigned char *old_buffer___2 ;
  void *myCIL___tmp___17 ;
  int myCIL___tmp___18 ;
  unsigned char *old_buffer___3 ;
  void *myCIL___tmp___19 ;
  unsigned char *old_buffer___4 ;
  void *myCIL___tmp___20 ;
  unsigned char *myCIL___tmp___21 ;
  boolean had_char_class ;
  unsigned char *old_buffer___5 ;
  void *myCIL___tmp___22 ;
  unsigned char *old_buffer___6 ;
  void *myCIL___tmp___23 ;
  unsigned char *myCIL___tmp___24 ;
  int myCIL___tmp___25 ;
  unsigned char *old_buffer___7 ;
  void *myCIL___tmp___26 ;
  unsigned char *myCIL___tmp___27 ;
  char *myCIL___tmp___28 ;
  char *myCIL___tmp___29 ;
  reg_errcode_t ret ;
  reg_errcode_t myCIL___tmp___30 ;
  reg_errcode_t ret___0 ;
  char *myCIL___tmp___31 ;
  char str[7] ;
  char *myCIL___tmp___32 ;
  char *myCIL___tmp___33 ;
  unsigned char myCIL___tmp___34 ;
  int ch ;
  boolean is_alnum ;
  int myCIL___tmp___35 ;
  boolean is_alpha ;
  int myCIL___tmp___36 ;
  boolean is_blank ;
  int myCIL___tmp___37 ;
  boolean is_cntrl ;
  int myCIL___tmp___38 ;
  boolean is_digit ;
  int myCIL___tmp___39 ;
  boolean is_graph ;
  int myCIL___tmp___40 ;
  boolean is_lower ;
  int myCIL___tmp___41 ;
  boolean is_print ;
  int myCIL___tmp___42 ;
  boolean is_punct ;
  int myCIL___tmp___43 ;
  boolean is_space ;
  int myCIL___tmp___44 ;
  boolean is_upper ;
  int myCIL___tmp___45 ;
  boolean is_xdigit ;
  int myCIL___tmp___46 ;
  int myCIL___tmp___47 ;
  int myCIL___tmp___48 ;
  int myCIL___tmp___49 ;
  int myCIL___tmp___50 ;
  int myCIL___tmp___51 ;
  int myCIL___tmp___52 ;
  int myCIL___tmp___53 ;
  int myCIL___tmp___54 ;
  int myCIL___tmp___55 ;
  int myCIL___tmp___56 ;
  int myCIL___tmp___57 ;
  int myCIL___tmp___58 ;
  char *myCIL___tmp___59 ;
  unsigned short **myCIL___tmp___60 ;
  unsigned short **myCIL___tmp___61 ;
  unsigned short **myCIL___tmp___62 ;
  unsigned short **myCIL___tmp___63 ;
  unsigned short **myCIL___tmp___64 ;
  unsigned short **myCIL___tmp___65 ;
  unsigned short **myCIL___tmp___66 ;
  unsigned short **myCIL___tmp___67 ;
  unsigned short **myCIL___tmp___68 ;
  unsigned short **myCIL___tmp___69 ;
  unsigned short **myCIL___tmp___70 ;
  unsigned short **myCIL___tmp___71 ;
  unsigned char myCIL___tmp___72 ;
  char *myCIL___tmp___73 ;
  void *myCIL___tmp___74 ;
  unsigned char *old_buffer___8 ;
  void *myCIL___tmp___75 ;
  unsigned char *myCIL___tmp___76 ;
  unsigned char *myCIL___tmp___77 ;
  unsigned char *myCIL___tmp___78 ;
  unsigned char *old_buffer___9 ;
  void *myCIL___tmp___79 ;
  unsigned char *myCIL___tmp___80 ;
  regnum_t this_group_regnum ;
  unsigned char *inner_group_loc ;
  unsigned char *old_buffer___10 ;
  void *myCIL___tmp___81 ;
  unsigned char *myCIL___tmp___82 ;
  unsigned char *myCIL___tmp___83 ;
  unsigned char *myCIL___tmp___84 ;
  unsigned char *old_buffer___11 ;
  void *myCIL___tmp___85 ;
  unsigned char *old_buffer___12 ;
  void *myCIL___tmp___86 ;
  int lower_bound ;
  int upper_bound ;
  char *myCIL___tmp___87 ;
  char *myCIL___tmp___88 ;
  unsigned short **myCIL___tmp___89 ;
  char *myCIL___tmp___90 ;
  char *myCIL___tmp___91 ;
  unsigned short **myCIL___tmp___92 ;
  char *myCIL___tmp___93 ;
  unsigned char *old_buffer___13 ;
  void *myCIL___tmp___94 ;
  unsigned int nbytes ;
  unsigned char *old_buffer___14 ;
  void *myCIL___tmp___95 ;
  char *myCIL___tmp___96 ;
  unsigned char *old_buffer___15 ;
  void *myCIL___tmp___97 ;
  unsigned char *myCIL___tmp___98 ;
  unsigned char *old_buffer___16 ;
  void *myCIL___tmp___99 ;
  unsigned char *myCIL___tmp___100 ;
  unsigned char *old_buffer___17 ;
  void *myCIL___tmp___101 ;
  unsigned char *myCIL___tmp___102 ;
  unsigned char *old_buffer___18 ;
  void *myCIL___tmp___103 ;
  unsigned char *myCIL___tmp___104 ;
  unsigned char *old_buffer___19 ;
  void *myCIL___tmp___105 ;
  unsigned char *myCIL___tmp___106 ;
  unsigned char *old_buffer___20 ;
  void *myCIL___tmp___107 ;
  unsigned char *myCIL___tmp___108 ;
  unsigned char *old_buffer___21 ;
  void *myCIL___tmp___109 ;
  unsigned char *myCIL___tmp___110 ;
  unsigned char *old_buffer___22 ;
  void *myCIL___tmp___111 ;
  unsigned char *myCIL___tmp___112 ;
  boolean myCIL___tmp___113 ;
  unsigned char *old_buffer___23 ;
  void *myCIL___tmp___114 ;
  unsigned char *myCIL___tmp___115 ;
  unsigned char *myCIL___tmp___116 ;
  unsigned char *old_buffer___24 ;
  void *myCIL___tmp___117 ;
  unsigned char *myCIL___tmp___118 ;
  unsigned char *myCIL___tmp___119 ;
  int myCIL___tmp___120 ;
  int myCIL___tmp___121 ;
  int myCIL___tmp___122 ;
  int myCIL___tmp___123 ;
  int myCIL___tmp___124 ;
  unsigned char *old_buffer___25 ;
  void *myCIL___tmp___125 ;
  unsigned char *myCIL___tmp___126 ;

  {
  p = pattern;
  pend = pattern + size;
  translate = bufp->translate;
  pending_exact = (unsigned char *)0;
  laststart = (unsigned char *)0;
  fixup_alt_jump = (unsigned char *)0;
  regnum = (regnum_t )0;
  myCIL___tmp = malloc(32UL * sizeof(compile_stack_elt_t ));
  compile_stack.stack = (compile_stack_elt_t *)myCIL___tmp;
  if ((unsigned long )compile_stack.stack == (unsigned long )((void *)0)) {
    return ((enum __anonenum_reg_errcode_t_25 )12);
  }
  compile_stack.size = 32U;
  compile_stack.avail = 0U;
  bufp->syntax = syntax;
  bufp->fastmap_accurate = 0U;
  myCIL___tmp___0 = 0U;
  bufp->not_eol = myCIL___tmp___0;
  bufp->not_bol = myCIL___tmp___0;
  bufp->used = 0UL;
  bufp->re_nsub = 0UL;
  init_syntax_once();
  if (bufp->allocated == 0UL) {
    if (bufp->buffer) {
      myCIL___tmp___1 = realloc((void *)bufp->buffer, 32UL * sizeof(unsigned char ));
      bufp->buffer = (unsigned char *)myCIL___tmp___1;
    } else {
      myCIL___tmp___2 = malloc(32UL * sizeof(unsigned char ));
      bufp->buffer = (unsigned char *)myCIL___tmp___2;
    }
    if (! bufp->buffer) {
      return ((enum __anonenum_reg_errcode_t_25 )12);
    }
    bufp->allocated = 32UL;
  }
  b = bufp->buffer;
  begalt = b;
  while ((unsigned long )p != (unsigned long )pend) {
    while (1) {
      if ((unsigned long )p == (unsigned long )pend) {
        return ((enum __anonenum_reg_errcode_t_25 )14);
      }
      myCIL___tmp___3 = p;
      p = p + 1;
      c = (unsigned char )*myCIL___tmp___3;
      if (translate) {
        c = (unsigned char )*(translate + c);
      }
      break;
    }
    switch ((int )c) {
    case 94: 
    if ((unsigned long )p == (unsigned long )(pattern + 1)) {
      goto _L;
    } else {
      if (syntax & (unsigned int )(((1 << 1) << 1) << 1)) {
        goto _L;
      } else {
        myCIL___tmp___6 = at_begline_loc_p(pattern, p, syntax);
        if (myCIL___tmp___6) {
          _L: /* CIL Label */ 
          while (1) {
            while ((unsigned long )((b - bufp->buffer) + 1) > bufp->allocated) {
              while (1) {
                old_buffer = bufp->buffer;
                if (bufp->allocated == (unsigned long )(1L << 16)) {
                  return ((enum __anonenum_reg_errcode_t_25 )15);
                }
                bufp->allocated = bufp->allocated << 1;
                if (bufp->allocated > (unsigned long )(1L << 16)) {
                  bufp->allocated = (unsigned long )(1L << 16);
                }
                myCIL___tmp___4 = realloc((void *)bufp->buffer, bufp->allocated);
                bufp->buffer = (unsigned char *)myCIL___tmp___4;
                if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
                  return ((enum __anonenum_reg_errcode_t_25 )12);
                }
                if ((unsigned long )old_buffer != (unsigned long )bufp->buffer) {
                  b = bufp->buffer + (b - old_buffer);
                  begalt = bufp->buffer + (begalt - old_buffer);
                  if (fixup_alt_jump) {
                    fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer);
                  }
                  if (laststart) {
                    laststart = bufp->buffer + (laststart - old_buffer);
                  }
                  if (pending_exact) {
                    pending_exact = bufp->buffer + (pending_exact - old_buffer);
                  }
                }
                break;
              }
            }
            myCIL___tmp___5 = b;
            b = b + 1;
            *myCIL___tmp___5 = (unsigned char)8;
            break;
          }
        } else {
          goto normal_char;
        }
      }
    }
    break;
    case 36: 
    if ((unsigned long )p == (unsigned long )pend) {
      goto _L___0;
    } else {
      if (syntax & (unsigned int )(((1 << 1) << 1) << 1)) {
        goto _L___0;
      } else {
        myCIL___tmp___9 = at_endline_loc_p(p, pend, syntax);
        if (myCIL___tmp___9) {
          _L___0: /* CIL Label */ 
          while (1) {
            while ((unsigned long )((b - bufp->buffer) + 1) > bufp->allocated) {
              while (1) {
                old_buffer___0 = bufp->buffer;
                if (bufp->allocated == (unsigned long )(1L << 16)) {
                  return ((enum __anonenum_reg_errcode_t_25 )15);
                }
                bufp->allocated = bufp->allocated << 1;
                if (bufp->allocated > (unsigned long )(1L << 16)) {
                  bufp->allocated = (unsigned long )(1L << 16);
                }
                myCIL___tmp___7 = realloc((void *)bufp->buffer, bufp->allocated);
                bufp->buffer = (unsigned char *)myCIL___tmp___7;
                if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
                  return ((enum __anonenum_reg_errcode_t_25 )12);
                }
                if ((unsigned long )old_buffer___0 != (unsigned long )bufp->buffer) {
                  b = bufp->buffer + (b - old_buffer___0);
                  begalt = bufp->buffer + (begalt - old_buffer___0);
                  if (fixup_alt_jump) {
                    fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___0);
                  }
                  if (laststart) {
                    laststart = bufp->buffer + (laststart - old_buffer___0);
                  }
                  if (pending_exact) {
                    pending_exact = bufp->buffer + (pending_exact - old_buffer___0);
                  }
                }
                break;
              }
            }
            myCIL___tmp___8 = b;
            b = b + 1;
            *myCIL___tmp___8 = (unsigned char)9;
            break;
          }
        } else {
          goto normal_char;
        }
      }
    }
    break;
    case 43: 
    case 63: 
    if (syntax & (unsigned int )(1 << 1)) {
      goto normal_char;
    } else {
      if (syntax & (unsigned int )((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        goto normal_char;
      }
    }
    handle_plus: 
    case 42: 
    if (! laststart) {
      if (syntax & (unsigned int )(((((1 << 1) << 1) << 1) << 1) << 1)) {
        return ((enum __anonenum_reg_errcode_t_25 )13);
      } else {
        if (! (syntax & (unsigned int )((((1 << 1) << 1) << 1) << 1))) {
          goto normal_char;
        }
      }
    }
    keep_string_p = (boolean )0;
    zero_times_ok = (char)0;
    many_times_ok = (char)0;
    while (1) {
      if ((int )c != 43) {
        zero_times_ok = (char )((int )zero_times_ok | 1);
      }
      else {
        zero_times_ok = (char )((int )zero_times_ok | 0);
      }
      if ((int )c != 63) {
        many_times_ok = (char )((int )many_times_ok | 1);
      }
      else {
        many_times_ok = (char )((int )many_times_ok | 0);
      }
      if ((unsigned long )p == (unsigned long )pend) {
        break;
      }
      while (1) {
        if ((unsigned long )p == (unsigned long )pend) {
          return ((enum __anonenum_reg_errcode_t_25 )14);
        }
        myCIL___tmp___10 = p;
        p = p + 1;
        c = (unsigned char )*myCIL___tmp___10;
        if (translate) {
          c = (unsigned char )*(translate + c);
        }
        break;
      }
      if (! ((int )c == 42)) {
        if (! (syntax & (unsigned int )(1 << 1))) {
          if (! ((int )c == 43)) {
            if (! ((int )c == 63)) {
              goto _L___1;
            }
          }
        } else {
          _L___1: /* CIL Label */ 
          if (syntax & (unsigned int )(1 << 1)) {
            if ((int )c == 92) {
              if ((unsigned long )p == (unsigned long )pend) {
                return ((enum __anonenum_reg_errcode_t_25 )5);
              }
              while (1) {
                if ((unsigned long )p == (unsigned long )pend) {
                  return ((enum __anonenum_reg_errcode_t_25 )14);
                }
                myCIL___tmp___11 = p;
                p = p + 1;
                c1 = (unsigned char )*myCIL___tmp___11;
                if (translate) {
                  c1 = (unsigned char )*(translate + c1);
                }
                break;
              }
              if (! ((int )c1 == 43)) {
                if (! ((int )c1 == 63)) {
                  p = p - 1;
                  p = p - 1;
                  break;
                }
              }
              c = c1;
            } else {
              p = p - 1;
              break;
            }
          } else {
            p = p - 1;
            break;
          }
        }
      }
    }
    if (! laststart) {
      break;
    }
    if (many_times_ok) {
      while ((unsigned long )((b - bufp->buffer) + 3) > bufp->allocated) {
        while (1) {
          old_buffer___1 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((enum __anonenum_reg_errcode_t_25 )15);
          }
          bufp->allocated = bufp->allocated << 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          myCIL___tmp___12 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)myCIL___tmp___12;
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((enum __anonenum_reg_errcode_t_25 )12);
          }
          if ((unsigned long )old_buffer___1 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___1);
            begalt = bufp->buffer + (begalt - old_buffer___1);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___1);
            }
            if (laststart) {
              laststart = bufp->buffer + (laststart - old_buffer___1);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___1);
            }
          }
          break;
        }
      }
      if (translate) {
        myCIL___tmp___13 = (int )*(translate + (unsigned char )*(p - 2));
      } else {
        myCIL___tmp___13 = (int )*(p - 2);
      }
      if (translate) {
        myCIL___tmp___14 = (int )*(translate + (unsigned char )'.');
      } else {
        myCIL___tmp___14 = '.';
      }
      if (myCIL___tmp___13 == myCIL___tmp___14) {
        if (zero_times_ok) {
          if ((unsigned long )p < (unsigned long )pend) {
            if (translate) {
              myCIL___tmp___15 = (int )*(translate + (unsigned char )*p);
            } else {
              myCIL___tmp___15 = (int )*p;
            }
            if (translate) {
              myCIL___tmp___16 = (int )*(translate + (unsigned char )'\n');
            } else {
              myCIL___tmp___16 = '\n';
            }
            if (myCIL___tmp___15 == myCIL___tmp___16) {
              if (! (syntax & (unsigned int )((((((1 << 1) << 1) << 1) << 1) << 1) << 1))) {
                store_op1(12, b, (laststart - b) - 3);
                keep_string_p = (char)1;
              } else {
                store_op1(17, b, ((laststart - 3) - b) - 3);
              }
            } else {
              store_op1(17, b, ((laststart - 3) - b) - 3);
            }
          } else {
            store_op1(17, b, ((laststart - 3) - b) - 3);
          }
        } else {
          store_op1(17, b, ((laststart - 3) - b) - 3);
        }
      } else {
        store_op1(17, b, ((laststart - 3) - b) - 3);
      }
      b = b + 3;
    }
    while ((unsigned long )((b - bufp->buffer) + 3) > bufp->allocated) {
      while (1) {
        old_buffer___2 = bufp->buffer;
        if (bufp->allocated == (unsigned long )(1L << 16)) {
          return ((enum __anonenum_reg_errcode_t_25 )15);
        }
        bufp->allocated = bufp->allocated << 1;
        if (bufp->allocated > (unsigned long )(1L << 16)) {
          bufp->allocated = (unsigned long )(1L << 16);
        }
        myCIL___tmp___17 = realloc((void *)bufp->buffer, bufp->allocated);
        bufp->buffer = (unsigned char *)myCIL___tmp___17;
        if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
          return ((enum __anonenum_reg_errcode_t_25 )12);
        }
        if ((unsigned long )old_buffer___2 != (unsigned long )bufp->buffer) {
          b = bufp->buffer + (b - old_buffer___2);
          begalt = bufp->buffer + (begalt - old_buffer___2);
          if (fixup_alt_jump) {
            fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___2);
          }
          if (laststart) {
            laststart = bufp->buffer + (laststart - old_buffer___2);
          }
          if (pending_exact) {
            pending_exact = bufp->buffer + (pending_exact - old_buffer___2);
          }
        }
        break;
      }
    }
    if (keep_string_p) {
      myCIL___tmp___18 = 15;
    } else {
      myCIL___tmp___18 = 14;
    }
    insert_op1(myCIL___tmp___18, laststart, ((b + 3) - laststart) - 3, b);
    pending_exact = (unsigned char *)0;
    b = b + 3;
    if (! zero_times_ok) {
      while ((unsigned long )((b - bufp->buffer) + 3) > bufp->allocated) {
        while (1) {
          old_buffer___3 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((enum __anonenum_reg_errcode_t_25 )15);
          }
          bufp->allocated = bufp->allocated << 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          myCIL___tmp___19 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)myCIL___tmp___19;
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((enum __anonenum_reg_errcode_t_25 )12);
          }
          if ((unsigned long )old_buffer___3 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___3);
            begalt = bufp->buffer + (begalt - old_buffer___3);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___3);
            }
            if (laststart) {
              laststart = bufp->buffer + (laststart - old_buffer___3);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___3);
            }
          }
          break;
        }
      }
      insert_op1(18, laststart, ((laststart + 6) - laststart) - 3, b);
      b = b + 3;
    }
    break;
    case 46: 
    laststart = b;
    while (1) {
      while ((unsigned long )((b - bufp->buffer) + 1) > bufp->allocated) {
        while (1) {
          old_buffer___4 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((enum __anonenum_reg_errcode_t_25 )15);
          }
          bufp->allocated = bufp->allocated << 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          myCIL___tmp___20 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)myCIL___tmp___20;
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((enum __anonenum_reg_errcode_t_25 )12);
          }
          if ((unsigned long )old_buffer___4 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___4);
            begalt = bufp->buffer + (begalt - old_buffer___4);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___4);
            }
            if (laststart) {
              laststart = bufp->buffer + (laststart - old_buffer___4);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___4);
            }
          }
          break;
        }
      }
      myCIL___tmp___21 = b;
      b = b + 1;
      *myCIL___tmp___21 = (unsigned char)2;
      break;
    }
    break;
    case 91: 
    had_char_class = (boolean )0;
    if ((unsigned long )p == (unsigned long )pend) {
      return ((enum __anonenum_reg_errcode_t_25 )7);
    }
    while ((unsigned long )((b - bufp->buffer) + 34) > bufp->allocated) {
      while (1) {
        old_buffer___5 = bufp->buffer;
        if (bufp->allocated == (unsigned long )(1L << 16)) {
          return ((enum __anonenum_reg_errcode_t_25 )15);
        }
        bufp->allocated = bufp->allocated << 1;
        if (bufp->allocated > (unsigned long )(1L << 16)) {
          bufp->allocated = (unsigned long )(1L << 16);
        }
        myCIL___tmp___22 = realloc((void *)bufp->buffer, bufp->allocated);
        bufp->buffer = (unsigned char *)myCIL___tmp___22;
        if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
          return ((enum __anonenum_reg_errcode_t_25 )12);
        }
        if ((unsigned long )old_buffer___5 != (unsigned long )bufp->buffer) {
          b = bufp->buffer + (b - old_buffer___5);
          begalt = bufp->buffer + (begalt - old_buffer___5);
          if (fixup_alt_jump) {
            fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___5);
          }
          if (laststart) {
            laststart = bufp->buffer + (laststart - old_buffer___5);
          }
          if (pending_exact) {
            pending_exact = bufp->buffer + (pending_exact - old_buffer___5);
          }
        }
        break;
      }
    }
    laststart = b;
    while (1) {
      while ((unsigned long )((b - bufp->buffer) + 1) > bufp->allocated) {
        while (1) {
          old_buffer___6 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((enum __anonenum_reg_errcode_t_25 )15);
          }
          bufp->allocated = bufp->allocated << 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          myCIL___tmp___23 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)myCIL___tmp___23;
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((enum __anonenum_reg_errcode_t_25 )12);
          }
          if ((unsigned long )old_buffer___6 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___6);
            begalt = bufp->buffer + (begalt - old_buffer___6);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___6);
            }
            if (laststart) {
              laststart = bufp->buffer + (laststart - old_buffer___6);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___6);
            }
          }
          break;
        }
      }
      myCIL___tmp___24 = b;
      b = b + 1;
      if ((int )*p == 94) {
        myCIL___tmp___25 = 4;
      } else {
        myCIL___tmp___25 = 3;
      }
      *myCIL___tmp___24 = (unsigned char )myCIL___tmp___25;
      break;
    }
    if ((int )*p == 94) {
      p = p + 1;
    }
    p1 = p;
    while (1) {
      while ((unsigned long )((b - bufp->buffer) + 1) > bufp->allocated) {
        while (1) {
          old_buffer___7 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((enum __anonenum_reg_errcode_t_25 )15);
          }
          bufp->allocated = bufp->allocated << 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          myCIL___tmp___26 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)myCIL___tmp___26;
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((enum __anonenum_reg_errcode_t_25 )12);
          }
          if ((unsigned long )old_buffer___7 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___7);
            begalt = bufp->buffer + (begalt - old_buffer___7);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___7);
            }
            if (laststart) {
              laststart = bufp->buffer + (laststart - old_buffer___7);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___7);
            }
          }
          break;
        }
      }
      myCIL___tmp___27 = b;
      b = b + 1;
      *myCIL___tmp___27 = (unsigned char )((1 << 8) / 8);
      break;
    }
    memset((void *)b, 0, (unsigned long )((1 << 8) / 8));
    if ((unsigned int )((enum __anonenum_re_opcode_t_28 )*(b + -2)) == 4U) {
      if (syntax & (unsigned int )((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        *(b + 1) = (unsigned char )((int )*(b + 1) | (1 << 2));
      }
    }
    while (1) {
      if ((unsigned long )p == (unsigned long )pend) {
        return ((enum __anonenum_reg_errcode_t_25 )7);
      }
      while (1) {
        if ((unsigned long )p == (unsigned long )pend) {
          return ((enum __anonenum_reg_errcode_t_25 )14);
        }
        myCIL___tmp___28 = p;
        p = p + 1;
        c = (unsigned char )*myCIL___tmp___28;
        if (translate) {
          c = (unsigned char )*(translate + c);
        }
        break;
      }
      if (syntax & 1U) {
        if ((int )c == 92) {
          if ((unsigned long )p == (unsigned long )pend) {
            return ((enum __anonenum_reg_errcode_t_25 )5);
          }
          while (1) {
            if ((unsigned long )p == (unsigned long )pend) {
              return ((enum __anonenum_reg_errcode_t_25 )14);
            }
            myCIL___tmp___29 = p;
            p = p + 1;
            c1 = (unsigned char )*myCIL___tmp___29;
            if (translate) {
              c1 = (unsigned char )*(translate + c1);
            }
            break;
          }
          *(b + (int )c1 / 8) = (unsigned char )((int )*(b + (int )c1 / 8) | (1 << (int )c1 % 8));
          goto __Cont;
        }
      }
      if ((int )c == 93) {
        if ((unsigned long )p != (unsigned long )(p1 + 1)) {
          break;
        }
      }
      if (had_char_class) {
        if ((int )c == 45) {
          if ((int )*p != 93) {
            return ((enum __anonenum_reg_errcode_t_25 )11);
          }
        }
      }
      if ((int )c == 45) {
        if ((unsigned long )(p - 2) >= (unsigned long )pattern) {
          if ((int )*(p + -2) == 91) {
            goto _L___19;
          } else {
            goto _L___20;
          }
        } else {
          _L___20: /* CIL Label */ 
          if ((unsigned long )(p - 3) >= (unsigned long )pattern) {
            if ((int )*(p + -3) == 91) {
              if ((int )*(p + -2) == 94) {
                goto _L___19;
              } else {
                goto _L___18;
              }
            } else {
              goto _L___18;
            }
          } else {
            _L___18: /* CIL Label */ 
            if ((int )*p != 93) {
              myCIL___tmp___30 = compile_range(& p, pend, translate, syntax, b);
              ret = myCIL___tmp___30;
              if ((unsigned int )ret != 0U) {
                return (ret);
              }
            } else {
              goto _L___19;
            }
          }
        }
      } else {
        _L___19: /* CIL Label */ 
        if ((int )*(p + 0) == 45) {
          if ((int )*(p + 1) != 93) {
            while (1) {
              if ((unsigned long )p == (unsigned long )pend) {
                return ((enum __anonenum_reg_errcode_t_25 )14);
              }
              myCIL___tmp___31 = p;
              p = p + 1;
              c1 = (unsigned char )*myCIL___tmp___31;
              if (translate) {
                c1 = (unsigned char )*(translate + c1);
              }
              break;
            }
            ret___0 = compile_range(& p, pend, translate, syntax, b);
            if ((unsigned int )ret___0 != 0U) {
              return (ret___0);
            }
          } else {
            goto _L___14;
          }
        } else {
          _L___14: /* CIL Label */ 
          if (syntax & (unsigned int )((1 << 1) << 1)) {
            if ((int )c == 91) {
              if ((int )*p == 58) {
                while (1) {
                  if ((unsigned long )p == (unsigned long )pend) {
                    return ((enum __anonenum_reg_errcode_t_25 )14);
                  }
                  myCIL___tmp___32 = p;
                  p = p + 1;
                  c = (unsigned char )*myCIL___tmp___32;
                  if (translate) {
                    c = (unsigned char )*(translate + c);
                  }
                  break;
                }
                c1 = (unsigned char)0;
                if ((unsigned long )p == (unsigned long )pend) {
                  return ((enum __anonenum_reg_errcode_t_25 )7);
                }
                while (1) {
                  while (1) {
                    if ((unsigned long )p == (unsigned long )pend) {
                      return ((enum __anonenum_reg_errcode_t_25 )14);
                    }
                    myCIL___tmp___33 = p;
                    p = p + 1;
                    c = (unsigned char )*myCIL___tmp___33;
                    if (translate) {
                      c = (unsigned char )*(translate + c);
                    }
                    break;
                  }
                  if ((int )c == 58) {
                    break;
                  } else {
                    if ((int )c == 93) {
                      break;
                    } else {
                      if ((unsigned long )p == (unsigned long )pend) {
                        break;
                      } else {
                        if ((int )c1 == 6) {
                          break;
                        }
                      }
                    }
                  }
                  myCIL___tmp___34 = c1;
                  c1 = (unsigned char )((int )c1 + 1);
                  str[myCIL___tmp___34] = (char )c;
                }
                str[c1] = (char )'\000';
                if ((int )c == 58) {
                  if ((int )*p == 93) {
                    myCIL___tmp___35 = strcmp((char *)(str), "alnum");
                    if ((myCIL___tmp___35 == 0)) {
                        is_alnum = 1;
                    }
                    else {
                        is_alnum = 0;
                    }
                    myCIL___tmp___36 = strcmp((char *)(str), "alpha");
                    if ((myCIL___tmp___36 == 0)) {
                        is_alpha = 1;
                    }
                    else {
                        is_alpha = 0;
                    }
                    myCIL___tmp___37 = strcmp((char *)(str), "blank");
                    if ((myCIL___tmp___37 == 0)) {
                        is_blank = 1;
                    }
                    else {
                        is_blank = 0;
                    }
                    myCIL___tmp___38 = strcmp((char *)(str), "cntrl");
                    if ((myCIL___tmp___38 == 0)) {
                        is_cntrl = 1;
                    }
                    else {
                        is_cntrl = 0;
                    }
                    myCIL___tmp___39 = strcmp((char *)(str), "digit");
                    if ((myCIL___tmp___39 == 0)) {
                        is_digit = 1;
                    }
                    else {
                        is_digit = 0;
                    }
                    myCIL___tmp___40 = strcmp((char *)(str), "graph");
                    if ((myCIL___tmp___40 == 0)) {
                        is_graph = 1;
                    }
                    else {
                        is_graph = 0;
                    }
                    myCIL___tmp___41 = strcmp((char *)(str), "lower");
                    if ((myCIL___tmp___41 == 0)) {
                        is_lower = 1;
                    }
                    else {
                        is_lower = 0;
                    }
                    myCIL___tmp___42 = strcmp((char *)(str), "print");
                    if ((myCIL___tmp___42 == 0)) {
                        is_print = 1;
                    }
                    else {
                        is_print = 0;
                    }
                    myCIL___tmp___43 = strcmp((char *)(str), "punct");
                    if ((myCIL___tmp___43 == 0)) {
                        is_punct = 1;
                    }
                    else {
                        is_punct = 0;
                    }
                    myCIL___tmp___44 = strcmp((char *)(str), "space");
                    if ((myCIL___tmp___44 == 0)) {
                        is_space = 1;
                    }
                    else {
                        is_space = 0;
                    }
                    myCIL___tmp___45 = strcmp((char *)(str), "upper");
                    if ((myCIL___tmp___45 == 0)) {
                        is_upper = 1;
                    }
                    else {
                        is_upper = 0;
                    }
                    myCIL___tmp___46 = strcmp((char *)(str), "xdigit");
                    if ((myCIL___tmp___46 == 0)) {
                        is_xdigit = 1;
                    }
                    else {
                        is_xdigit = 0;
                    }
                    myCIL___tmp___47 = strcmp((char *)(str), "alpha");
                    if (! (myCIL___tmp___47 == 0)) {
                      myCIL___tmp___48 = strcmp((char *)(str), "upper");
                      if (! (myCIL___tmp___48 == 0)) {
                        myCIL___tmp___49 = strcmp((char *)(str), "lower");
                        if (! (myCIL___tmp___49 == 0)) {
                          myCIL___tmp___50 = strcmp((char *)(str), "digit");
                          if (! (myCIL___tmp___50 == 0)) {
                            myCIL___tmp___51 = strcmp((char *)(str), "alnum");
                            if (! (myCIL___tmp___51 == 0)) {
                              myCIL___tmp___52 = strcmp((char *)(str), "xdigit");
                              if (! (myCIL___tmp___52 == 0)) {
                                myCIL___tmp___53 = strcmp((char *)(str), "space");
                                if (! (myCIL___tmp___53 == 0)) {
                                  myCIL___tmp___54 = strcmp((char *)(str), "print");
                                  if (! (myCIL___tmp___54 == 0)) {
                                    myCIL___tmp___55 = strcmp((char *)(str), "punct");
                                    if (! (myCIL___tmp___55 == 0)) {
                                      myCIL___tmp___56 = strcmp((char *)(str), "graph");
                                      if (! (myCIL___tmp___56 == 0)) {
                                        myCIL___tmp___57 = strcmp((char *)(str), "cntrl");
                                        if (! (myCIL___tmp___57 == 0)) {
                                          myCIL___tmp___58 = strcmp((char *)(str), "blank");
                                          if (! (myCIL___tmp___58 == 0)) {
                                            return ((enum __anonenum_reg_errcode_t_25 )4);
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                    while (1) {
                      if ((unsigned long )p == (unsigned long )pend) {
                        return ((enum __anonenum_reg_errcode_t_25 )14);
                      }
                      myCIL___tmp___59 = p;
                      p = p + 1;
                      c = (unsigned char )*myCIL___tmp___59;
                      if (translate) {
                        c = (unsigned char )*(translate + c);
                      }
                      break;
                    }
                    if ((unsigned long )p == (unsigned long )pend) {
                      return ((enum __anonenum_reg_errcode_t_25 )7);
                    }
                    ch = 0;
                    while (ch < 1 << 8) {
                      if (is_alnum) {
                        myCIL___tmp___60 = __ctype_b_loc();
                        if ((int )*(*myCIL___tmp___60 + ch) & 8) {
                          *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                        } else {
                          goto _L___12;
                        }
                      } else {
                        _L___12: /* CIL Label */ 
                        if (is_alpha) {
                          myCIL___tmp___61 = __ctype_b_loc();
                          if ((int )*(*myCIL___tmp___61 + ch) & 1024) {
                            *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                          } else {
                            goto _L___11;
                          }
                        } else {
                          _L___11: /* CIL Label */ 
                          if (is_blank) {
                            myCIL___tmp___62 = __ctype_b_loc();
                            if ((int )*(*myCIL___tmp___62 + ch) & 1) {
                              *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                            } else {
                              goto _L___10;
                            }
                          } else {
                            _L___10: /* CIL Label */ 
                            if (is_cntrl) {
                              myCIL___tmp___63 = __ctype_b_loc();
                              if ((int )*(*myCIL___tmp___63 + ch) & 2) {
                                *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                              } else {
                                goto _L___9;
                              }
                            } else {
                              _L___9: /* CIL Label */ 
                              if (is_digit) {
                                myCIL___tmp___64 = __ctype_b_loc();
                                if ((int )*(*myCIL___tmp___64 + ch) & 2048) {
                                  *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                                } else {
                                  goto _L___8;
                                }
                              } else {
                                _L___8: /* CIL Label */ 
                                if (is_graph) {
                                  myCIL___tmp___65 = __ctype_b_loc();
                                  if ((int )*(*myCIL___tmp___65 + ch) & 32768) {
                                    *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                                  } else {
                                    goto _L___7;
                                  }
                                } else {
                                  _L___7: /* CIL Label */ 
                                  if (is_lower) {
                                    myCIL___tmp___66 = __ctype_b_loc();
                                    if ((int )*(*myCIL___tmp___66 + ch) & 512) {
                                      *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                                    } else {
                                      goto _L___6;
                                    }
                                  } else {
                                    _L___6: /* CIL Label */ 
                                    if (is_print) {
                                      myCIL___tmp___67 = __ctype_b_loc();
                                      if ((int )*(*myCIL___tmp___67 + ch) & 16384) {
                                        *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                                      } else {
                                        goto _L___5;
                                      }
                                    } else {
                                      _L___5: /* CIL Label */ 
                                      if (is_punct) {
                                        myCIL___tmp___68 = __ctype_b_loc();
                                        if ((int )*(*myCIL___tmp___68 + ch) & 4) {
                                          *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                                        } else {
                                          goto _L___4;
                                        }
                                      } else {
                                        _L___4: /* CIL Label */ 
                                        if (is_space) {
                                          myCIL___tmp___69 = __ctype_b_loc();
                                          if ((int )*(*myCIL___tmp___69 + ch) & 8192) {
                                            *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                                          } else {
                                            goto _L___3;
                                          }
                                        } else {
                                          _L___3: /* CIL Label */ 
                                          if (is_upper) {
                                            myCIL___tmp___70 = __ctype_b_loc();
                                            if ((int )*(*myCIL___tmp___70 + ch) & 256) {
                                              *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                                            } else {
                                              goto _L___2;
                                            }
                                          } else {
                                            _L___2: /* CIL Label */ 
                                            if (is_xdigit) {
                                              myCIL___tmp___71 = __ctype_b_loc();
                                              if ((int )*(*myCIL___tmp___71 + ch) & 4096) {
                                                *(b + (int )((unsigned char )ch) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )ch) / 8) | (1 << (int )((unsigned char )ch) % 8));
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                      ch = ch + 1;
                    }
                    had_char_class = (char)1;
                  } else {
                    goto _L___13;
                  }
                } else {
                  _L___13: /* CIL Label */ 
                  c1 = (unsigned char )((int )c1 + 1);
                  while (1) {
                    myCIL___tmp___72 = c1;
                    c1 = (unsigned char )((int )c1 - 1);
                    if (! myCIL___tmp___72) {
                      break;
                    }
                    p = p - 1;
                  }
                  *(b + 11) = (unsigned char )((int )*(b + 11) | (1 << 3));
                  *(b + 7) = (unsigned char )((int )*(b + 7) | (1 << 2));
                  had_char_class = (char)0;
                }
              } else {
                had_char_class = (char)0;
                *(b + (int )c / 8) = (unsigned char )((int )*(b + (int )c / 8) | (1 << (int )c % 8));
              }
            } else {
              had_char_class = (char)0;
              *(b + (int )c / 8) = (unsigned char )((int )*(b + (int )c / 8) | (1 << (int )c % 8));
            }
          } else {
            had_char_class = (char)0;
            *(b + (int )c / 8) = (unsigned char )((int )*(b + (int )c / 8) | (1 << (int )c % 8));
          }
        }
      }
      __Cont: /* CIL Label */ ;
    }
    while (1) {
      if ((int )*(b + -1) > 0) {
        if (! ((int )*(b + ((int )*(b + -1) - 1)) == 0)) {
          break;
        }
      } else {
        break;
      }
      *(b + -1) = (unsigned char )((int )*(b + -1) - 1);
    }
    b = b + (int )*(b + -1);
    break;
    case 40: 
    if (syntax & (unsigned int )(((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto handle_open;
    } else {
      goto normal_char;
    }
    case 41: 
    if (syntax & (unsigned int )(((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto handle_close;
    } else {
      goto normal_char;
    }
    case 10: 
    if (syntax & (unsigned int )(((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto handle_alt;
    } else {
      goto normal_char;
    }
    case 124: 
    if (syntax & (unsigned int )(((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto handle_alt;
    } else {
      goto normal_char;
    }
    case 123: 
    if (syntax & (unsigned int )(((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      if (syntax & (unsigned int )((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        goto handle_interval;
      } else {
        goto normal_char;
      }
    } else {
      goto normal_char;
    }
    case 92: 
    if ((unsigned long )p == (unsigned long )pend) {
      return ((enum __anonenum_reg_errcode_t_25 )5);
    }
    while (1) {
      if ((unsigned long )p == (unsigned long )pend) {
        return ((enum __anonenum_reg_errcode_t_25 )14);
      }
      myCIL___tmp___73 = p;
      p = p + 1;
      c = (unsigned char )*myCIL___tmp___73;
      break;
    }
    switch ((int )c) {
    case 40: 
    if (syntax & (unsigned int )(((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_backslash;
    }
    handle_open: 
    bufp->re_nsub = bufp->re_nsub + 1UL;
    regnum = regnum + 1U;
    if (compile_stack.avail == compile_stack.size) {
      myCIL___tmp___74 = realloc((void *)compile_stack.stack, (unsigned long )(compile_stack.size << 1) * sizeof(compile_stack_elt_t ));
      compile_stack.stack = (compile_stack_elt_t *)myCIL___tmp___74;
      if ((unsigned long )compile_stack.stack == (unsigned long )((void *)0)) {
        return ((enum __anonenum_reg_errcode_t_25 )12);
      }
      compile_stack.size = compile_stack.size << 1;
    }
    (compile_stack.stack + compile_stack.avail)->begalt_offset = begalt - bufp->buffer;
    if (fixup_alt_jump) {
      (compile_stack.stack + compile_stack.avail)->fixup_alt_jump = (fixup_alt_jump - bufp->buffer) + 1;
    } else {
      (compile_stack.stack + compile_stack.avail)->fixup_alt_jump = 0;
    }
    (compile_stack.stack + compile_stack.avail)->laststart_offset = b - bufp->buffer;
    (compile_stack.stack + compile_stack.avail)->regnum = regnum;
    if (regnum <= 255U) {
      (compile_stack.stack + compile_stack.avail)->inner_group_offset = (b - bufp->buffer) + 2;
      while (1) {
        while ((unsigned long )((b - bufp->buffer) + 3) > bufp->allocated) {
          while (1) {
            old_buffer___8 = bufp->buffer;
            if (bufp->allocated == (unsigned long )(1L << 16)) {
              return ((enum __anonenum_reg_errcode_t_25 )15);
            }
            bufp->allocated = bufp->allocated << 1;
            if (bufp->allocated > (unsigned long )(1L << 16)) {
              bufp->allocated = (unsigned long )(1L << 16);
            }
            myCIL___tmp___75 = realloc((void *)bufp->buffer, bufp->allocated);
            bufp->buffer = (unsigned char *)myCIL___tmp___75;
            if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
              return ((enum __anonenum_reg_errcode_t_25 )12);
            }
            if ((unsigned long )old_buffer___8 != (unsigned long )bufp->buffer) {
              b = bufp->buffer + (b - old_buffer___8);
              begalt = bufp->buffer + (begalt - old_buffer___8);
              if (fixup_alt_jump) {
                fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___8);
              }
              if (laststart) {
                laststart = bufp->buffer + (laststart - old_buffer___8);
              }
              if (pending_exact) {
                pending_exact = bufp->buffer + (pending_exact - old_buffer___8);
              }
            }
            break;
          }
        }
        myCIL___tmp___76 = b;
        b = b + 1;
        *myCIL___tmp___76 = (unsigned char)5;
        myCIL___tmp___77 = b;
        b = b + 1;
        *myCIL___tmp___77 = (unsigned char )regnum;
        myCIL___tmp___78 = b;
        b = b + 1;
        *myCIL___tmp___78 = (unsigned char)0;
        break;
      }
    }
    compile_stack.avail = compile_stack.avail + 1U;
    fixup_alt_jump = (unsigned char *)0;
    laststart = (unsigned char *)0;
    begalt = b;
    pending_exact = (unsigned char *)0;
    break;
    case 41: 
    if (syntax & (unsigned int )(((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_backslash;
    }
    if (compile_stack.avail == 0U) {
      if (syntax & (unsigned int )(((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        goto normal_backslash;
      } else {
        return ((enum __anonenum_reg_errcode_t_25 )16);
      }
    }
    handle_close: 
    if (fixup_alt_jump) {
      while (1) {
        while ((unsigned long )((b - bufp->buffer) + 1) > bufp->allocated) {
          while (1) {
            old_buffer___9 = bufp->buffer;
            if (bufp->allocated == (unsigned long )(1L << 16)) {
              return ((enum __anonenum_reg_errcode_t_25 )15);
            }
            bufp->allocated = bufp->allocated << 1;
            if (bufp->allocated > (unsigned long )(1L << 16)) {
              bufp->allocated = (unsigned long )(1L << 16);
            }
            myCIL___tmp___79 = realloc((void *)bufp->buffer, bufp->allocated);
            bufp->buffer = (unsigned char *)myCIL___tmp___79;
            if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
              return ((enum __anonenum_reg_errcode_t_25 )12);
            }
            if ((unsigned long )old_buffer___9 != (unsigned long )bufp->buffer) {
              b = bufp->buffer + (b - old_buffer___9);
              begalt = bufp->buffer + (begalt - old_buffer___9);
              if (fixup_alt_jump) {
                fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___9);
              }
              if (laststart) {
                laststart = bufp->buffer + (laststart - old_buffer___9);
              }
              if (pending_exact) {
                pending_exact = bufp->buffer + (pending_exact - old_buffer___9);
              }
            }
            break;
          }
        }
        myCIL___tmp___80 = b;
        b = b + 1;
        *myCIL___tmp___80 = (unsigned char)19;
        break;
      }
      store_op1(13, fixup_alt_jump, ((b - 1) - fixup_alt_jump) - 3);
    }
    if (compile_stack.avail == 0U) {
      if (syntax & (unsigned int )(((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        goto normal_char;
      } else {
        return ((enum __anonenum_reg_errcode_t_25 )16);
      }
    }
    compile_stack.avail = compile_stack.avail - 1U;
    begalt = bufp->buffer + (compile_stack.stack + compile_stack.avail)->begalt_offset;
    if ((compile_stack.stack + compile_stack.avail)->fixup_alt_jump) {
      fixup_alt_jump = (bufp->buffer + (compile_stack.stack + compile_stack.avail)->fixup_alt_jump) - 1;
    } else {
      fixup_alt_jump = (unsigned char *)0;
    }
    laststart = bufp->buffer + (compile_stack.stack + compile_stack.avail)->laststart_offset;
    this_group_regnum = (compile_stack.stack + compile_stack.avail)->regnum;
    pending_exact = (unsigned char *)0;
    if (this_group_regnum <= 255U) {
      inner_group_loc = bufp->buffer + (compile_stack.stack + compile_stack.avail)->inner_group_offset;
      *inner_group_loc = (unsigned char )(regnum - this_group_regnum);
      while (1) {
        while ((unsigned long )((b - bufp->buffer) + 3) > bufp->allocated) {
          while (1) {
            old_buffer___10 = bufp->buffer;
            if (bufp->allocated == (unsigned long )(1L << 16)) {
              return ((enum __anonenum_reg_errcode_t_25 )15);
            }
            bufp->allocated = bufp->allocated << 1;
            if (bufp->allocated > (unsigned long )(1L << 16)) {
              bufp->allocated = (unsigned long )(1L << 16);
            }
            myCIL___tmp___81 = realloc((void *)bufp->buffer, bufp->allocated);
            bufp->buffer = (unsigned char *)myCIL___tmp___81;
            if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
              return ((enum __anonenum_reg_errcode_t_25 )12);
            }
            if ((unsigned long )old_buffer___10 != (unsigned long )bufp->buffer) {
              b = bufp->buffer + (b - old_buffer___10);
              begalt = bufp->buffer + (begalt - old_buffer___10);
              if (fixup_alt_jump) {
                fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___10);
              }
              if (laststart) {
                laststart = bufp->buffer + (laststart - old_buffer___10);
              }
              if (pending_exact) {
                pending_exact = bufp->buffer + (pending_exact - old_buffer___10);
              }
            }
            break;
          }
        }
        myCIL___tmp___82 = b;
        b = b + 1;
        *myCIL___tmp___82 = (unsigned char)6;
        myCIL___tmp___83 = b;
        b = b + 1;
        *myCIL___tmp___83 = (unsigned char )this_group_regnum;
        myCIL___tmp___84 = b;
        b = b + 1;
        *myCIL___tmp___84 = (unsigned char )(regnum - this_group_regnum);
        break;
      }
    }
    break;
    case 124: 
    if (syntax & (unsigned int )((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_backslash;
    } else {
      if (syntax & (unsigned int )(((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        goto normal_backslash;
      }
    }
    handle_alt: 
    if (syntax & (unsigned int )((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    }
    while ((unsigned long )((b - bufp->buffer) + 3) > bufp->allocated) {
      while (1) {
        old_buffer___11 = bufp->buffer;
        if (bufp->allocated == (unsigned long )(1L << 16)) {
          return ((enum __anonenum_reg_errcode_t_25 )15);
        }
        bufp->allocated = bufp->allocated << 1;
        if (bufp->allocated > (unsigned long )(1L << 16)) {
          bufp->allocated = (unsigned long )(1L << 16);
        }
        myCIL___tmp___85 = realloc((void *)bufp->buffer, bufp->allocated);
        bufp->buffer = (unsigned char *)myCIL___tmp___85;
        if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
          return ((enum __anonenum_reg_errcode_t_25 )12);
        }
        if ((unsigned long )old_buffer___11 != (unsigned long )bufp->buffer) {
          b = bufp->buffer + (b - old_buffer___11);
          begalt = bufp->buffer + (begalt - old_buffer___11);
          if (fixup_alt_jump) {
            fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___11);
          }
          if (laststart) {
            laststart = bufp->buffer + (laststart - old_buffer___11);
          }
          if (pending_exact) {
            pending_exact = bufp->buffer + (pending_exact - old_buffer___11);
          }
        }
        break;
      }
    }
    insert_op1(14, begalt, ((b + 6) - begalt) - 3, b);
    pending_exact = (unsigned char *)0;
    b = b + 3;
    if (fixup_alt_jump) {
      store_op1(13, fixup_alt_jump, (b - fixup_alt_jump) - 3);
    }
    fixup_alt_jump = b;
    while ((unsigned long )((b - bufp->buffer) + 3) > bufp->allocated) {
      while (1) {
        old_buffer___12 = bufp->buffer;
        if (bufp->allocated == (unsigned long )(1L << 16)) {
          return ((enum __anonenum_reg_errcode_t_25 )15);
        }
        bufp->allocated = bufp->allocated << 1;
        if (bufp->allocated > (unsigned long )(1L << 16)) {
          bufp->allocated = (unsigned long )(1L << 16);
        }
        myCIL___tmp___86 = realloc((void *)bufp->buffer, bufp->allocated);
        bufp->buffer = (unsigned char *)myCIL___tmp___86;
        if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
          return ((enum __anonenum_reg_errcode_t_25 )12);
        }
        if ((unsigned long )old_buffer___12 != (unsigned long )bufp->buffer) {
          b = bufp->buffer + (b - old_buffer___12);
          begalt = bufp->buffer + (begalt - old_buffer___12);
          if (fixup_alt_jump) {
            fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___12);
          }
          if (laststart) {
            laststart = bufp->buffer + (laststart - old_buffer___12);
          }
          if (pending_exact) {
            pending_exact = bufp->buffer + (pending_exact - old_buffer___12);
          }
        }
        break;
      }
    }
    b = b + 3;
    laststart = (unsigned char *)0;
    begalt = b;
    break;
    case 123: 
    if (! (syntax & (unsigned int )(((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      goto normal_backslash;
    } else {
      if (syntax & (unsigned int )(((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        if (syntax & (unsigned int )((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
          goto normal_backslash;
        } else {
          goto _L___21;
        }
      } else {
        _L___21: /* CIL Label */ 
        if ((unsigned long )(p - 2) == (unsigned long )pattern) {
          if ((unsigned long )p == (unsigned long )pend) {
            goto normal_backslash;
          }
        }
      }
    }
    handle_interval: 
    lower_bound = -1;
    upper_bound = -1;
    beg_interval = p - 1;
    if ((unsigned long )p == (unsigned long )pend) {
      if (syntax & (unsigned int )((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        goto unfetch_interval;
      } else {
        return ((enum __anonenum_reg_errcode_t_25 )9);
      }
    }
    if ((unsigned long )p != (unsigned long )pend) {
      while (1) {
        if ((unsigned long )p == (unsigned long )pend) {
          return ((enum __anonenum_reg_errcode_t_25 )14);
        }
        myCIL___tmp___87 = p;
        p = p + 1;
        c = (unsigned char )*myCIL___tmp___87;
        if (translate) {
          c = (unsigned char )*(translate + c);
        }
        break;
      }
      while (1) {
        myCIL___tmp___89 = __ctype_b_loc();
        if (! ((int )*(*myCIL___tmp___89 + (int )c) & 2048)) {
          break;
        }
        if (lower_bound < 0) {
          lower_bound = 0;
        }
        lower_bound = (lower_bound * 10 + (int )c) - 48;
        if ((unsigned long )p == (unsigned long )pend) {
          break;
        }
        while (1) {
          if ((unsigned long )p == (unsigned long )pend) {
            return ((enum __anonenum_reg_errcode_t_25 )14);
          }
          myCIL___tmp___88 = p;
          p = p + 1;
          c = (unsigned char )*myCIL___tmp___88;
          if (translate) {
            c = (unsigned char )*(translate + c);
          }
          break;
        }
      }
    }
    if ((int )c == 44) {
      if ((unsigned long )p != (unsigned long )pend) {
        while (1) {
          if ((unsigned long )p == (unsigned long )pend) {
            return ((enum __anonenum_reg_errcode_t_25 )14);
          }
          myCIL___tmp___90 = p;
          p = p + 1;
          c = (unsigned char )*myCIL___tmp___90;
          if (translate) {
            c = (unsigned char )*(translate + c);
          }
          break;
        }
        while (1) {
          myCIL___tmp___92 = __ctype_b_loc();
          if (! ((int )*(*myCIL___tmp___92 + (int )c) & 2048)) {
            break;
          }
          if (upper_bound < 0) {
            upper_bound = 0;
          }
          upper_bound = (upper_bound * 10 + (int )c) - 48;
          if ((unsigned long )p == (unsigned long )pend) {
            break;
          }
          while (1) {
            if ((unsigned long )p == (unsigned long )pend) {
              return ((enum __anonenum_reg_errcode_t_25 )14);
            }
            myCIL___tmp___91 = p;
            p = p + 1;
            c = (unsigned char )*myCIL___tmp___91;
            if (translate) {
              c = (unsigned char )*(translate + c);
            }
            break;
          }
        }
      }
      if (upper_bound < 0) {
        upper_bound = (1 << 15) - 1;
      }
    } else {
      upper_bound = lower_bound;
    }
    if (lower_bound < 0) {
      goto _L___22;
    } else {
      if (upper_bound > (1 << 15) - 1) {
        goto _L___22;
      } else {
        if (lower_bound > upper_bound) {
          _L___22: /* CIL Label */ 
          if (syntax & (unsigned int )((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
            goto unfetch_interval;
          } else {
            return ((enum __anonenum_reg_errcode_t_25 )10);
          }
        }
      }
    }
    if (! (syntax & (unsigned int )((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      if ((int )c != 92) {
        return ((enum __anonenum_reg_errcode_t_25 )9);
      }
      while (1) {
        if ((unsigned long )p == (unsigned long )pend) {
          return ((enum __anonenum_reg_errcode_t_25 )14);
        }
        myCIL___tmp___93 = p;
        p = p + 1;
        c = (unsigned char )*myCIL___tmp___93;
        if (translate) {
          c = (unsigned char )*(translate + c);
        }
        break;
      }
    }
    if ((int )c != 125) {
      if (syntax & (unsigned int )((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        goto unfetch_interval;
      } else {
        return ((enum __anonenum_reg_errcode_t_25 )10);
      }
    }
    if (! laststart) {
      if (syntax & (unsigned int )(((((1 << 1) << 1) << 1) << 1) << 1)) {
        return ((enum __anonenum_reg_errcode_t_25 )13);
      } else {
        if (syntax & (unsigned int )((((1 << 1) << 1) << 1) << 1)) {
          laststart = b;
        } else {
          goto unfetch_interval;
        }
      }
    }
    if (upper_bound == 0) {
      while ((unsigned long )((b - bufp->buffer) + 3) > bufp->allocated) {
        while (1) {
          old_buffer___13 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((enum __anonenum_reg_errcode_t_25 )15);
          }
          bufp->allocated = bufp->allocated << 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          myCIL___tmp___94 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)myCIL___tmp___94;
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((enum __anonenum_reg_errcode_t_25 )12);
          }
          if ((unsigned long )old_buffer___13 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___13);
            begalt = bufp->buffer + (begalt - old_buffer___13);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___13);
            }
            if (laststart) {
              laststart = bufp->buffer + (laststart - old_buffer___13);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___13);
            }
          }
          break;
        }
      }
      insert_op1(12, laststart, ((b + 3) - laststart) - 3, b);
      b = b + 3;
    } else {
      if (upper_bound > 1) {
        nbytes = (unsigned int )(10 + (1) * 10);
      }
      else {
        nbytes = (unsigned int )(10 + (0) * 10);
      }
      while ((unsigned long )((unsigned int )(b - bufp->buffer) + nbytes) > bufp->allocated) {
        while (1) {
          old_buffer___14 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((enum __anonenum_reg_errcode_t_25 )15);
          }
          bufp->allocated = bufp->allocated << 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          myCIL___tmp___95 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)myCIL___tmp___95;
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((enum __anonenum_reg_errcode_t_25 )12);
          }
          if ((unsigned long )old_buffer___14 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___14);
            begalt = bufp->buffer + (begalt - old_buffer___14);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___14);
            }
            if (laststart) {
              laststart = bufp->buffer + (laststart - old_buffer___14);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___14);
            }
          }
          break;
        }
      }
      insert_op2(20, laststart, (((b + 5) + (upper_bound > 1) * 5) - laststart) - 3, lower_bound, b);
      b = b + 5;
      insert_op2(22, laststart, 5, lower_bound, b);
      b = b + 5;
      if (upper_bound > 1) {
        store_op2(21, b, ((laststart + 5) - b) - 3, upper_bound - 1);
        b = b + 5;
        insert_op2(22, laststart, b - laststart, upper_bound - 1, b);
        b = b + 5;
      }
    }
    pending_exact = (unsigned char *)0;
    beg_interval = (char *)((void *)0);
    break;
    unfetch_interval: 
    p = beg_interval;
    beg_interval = (char *)((void *)0);
    while (1) {
      if ((unsigned long )p == (unsigned long )pend) {
        return ((enum __anonenum_reg_errcode_t_25 )14);
      }
      myCIL___tmp___96 = p;
      p = p + 1;
      c = (unsigned char )*myCIL___tmp___96;
      if (translate) {
        c = (unsigned char )*(translate + c);
      }
      break;
    }
    if (! (syntax & (unsigned int )((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      if ((unsigned long )p > (unsigned long )pattern) {
        if ((int )*(p + -1) == 92) {
          goto normal_backslash;
        }
      }
    }
    goto normal_char;
    case 119: 
    laststart = b;
    while (1) {
      while ((unsigned long )((b - bufp->buffer) + 1) > bufp->allocated) {
        while (1) {
          old_buffer___15 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((enum __anonenum_reg_errcode_t_25 )15);
          }
          bufp->allocated = bufp->allocated << 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          myCIL___tmp___97 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)myCIL___tmp___97;
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((enum __anonenum_reg_errcode_t_25 )12);
          }
          if ((unsigned long )old_buffer___15 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___15);
            begalt = bufp->buffer + (begalt - old_buffer___15);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___15);
            }
            if (laststart) {
              laststart = bufp->buffer + (laststart - old_buffer___15);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___15);
            }
          }
          break;
        }
      }
      myCIL___tmp___98 = b;
      b = b + 1;
      *myCIL___tmp___98 = (unsigned char)23;
      break;
    }
    break;
    case 87: 
    laststart = b;
    while (1) {
      while ((unsigned long )((b - bufp->buffer) + 1) > bufp->allocated) {
        while (1) {
          old_buffer___16 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((enum __anonenum_reg_errcode_t_25 )15);
          }
          bufp->allocated = bufp->allocated << 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          myCIL___tmp___99 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)myCIL___tmp___99;
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((enum __anonenum_reg_errcode_t_25 )12);
          }
          if ((unsigned long )old_buffer___16 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___16);
            begalt = bufp->buffer + (begalt - old_buffer___16);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___16);
            }
            if (laststart) {
              laststart = bufp->buffer + (laststart - old_buffer___16);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___16);
            }
          }
          break;
        }
      }
      myCIL___tmp___100 = b;
      b = b + 1;
      *myCIL___tmp___100 = (unsigned char)24;
      break;
    }
    break;
    case 60: 
    while (1) {
      while ((unsigned long )((b - bufp->buffer) + 1) > bufp->allocated) {
        while (1) {
          old_buffer___17 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((enum __anonenum_reg_errcode_t_25 )15);
          }
          bufp->allocated = bufp->allocated << 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          myCIL___tmp___101 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)myCIL___tmp___101;
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((enum __anonenum_reg_errcode_t_25 )12);
          }
          if ((unsigned long )old_buffer___17 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___17);
            begalt = bufp->buffer + (begalt - old_buffer___17);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___17);
            }
            if (laststart) {
              laststart = bufp->buffer + (laststart - old_buffer___17);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___17);
            }
          }
          break;
        }
      }
      myCIL___tmp___102 = b;
      b = b + 1;
      *myCIL___tmp___102 = (unsigned char)25;
      break;
    }
    break;
    case 62: 
    while (1) {
      while ((unsigned long )((b - bufp->buffer) + 1) > bufp->allocated) {
        while (1) {
          old_buffer___18 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((enum __anonenum_reg_errcode_t_25 )15);
          }
          bufp->allocated = bufp->allocated << 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          myCIL___tmp___103 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)myCIL___tmp___103;
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((enum __anonenum_reg_errcode_t_25 )12);
          }
          if ((unsigned long )old_buffer___18 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___18);
            begalt = bufp->buffer + (begalt - old_buffer___18);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___18);
            }
            if (laststart) {
              laststart = bufp->buffer + (laststart - old_buffer___18);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___18);
            }
          }
          break;
        }
      }
      myCIL___tmp___104 = b;
      b = b + 1;
      *myCIL___tmp___104 = (unsigned char)26;
      break;
    }
    break;
    case 98: 
    while (1) {
      while ((unsigned long )((b - bufp->buffer) + 1) > bufp->allocated) {
        while (1) {
          old_buffer___19 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((enum __anonenum_reg_errcode_t_25 )15);
          }
          bufp->allocated = bufp->allocated << 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          myCIL___tmp___105 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)myCIL___tmp___105;
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((enum __anonenum_reg_errcode_t_25 )12);
          }
          if ((unsigned long )old_buffer___19 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___19);
            begalt = bufp->buffer + (begalt - old_buffer___19);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___19);
            }
            if (laststart) {
              laststart = bufp->buffer + (laststart - old_buffer___19);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___19);
            }
          }
          break;
        }
      }
      myCIL___tmp___106 = b;
      b = b + 1;
      *myCIL___tmp___106 = (unsigned char)27;
      break;
    }
    break;
    case 66: 
    while (1) {
      while ((unsigned long )((b - bufp->buffer) + 1) > bufp->allocated) {
        while (1) {
          old_buffer___20 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((enum __anonenum_reg_errcode_t_25 )15);
          }
          bufp->allocated = bufp->allocated << 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          myCIL___tmp___107 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)myCIL___tmp___107;
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((enum __anonenum_reg_errcode_t_25 )12);
          }
          if ((unsigned long )old_buffer___20 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___20);
            begalt = bufp->buffer + (begalt - old_buffer___20);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___20);
            }
            if (laststart) {
              laststart = bufp->buffer + (laststart - old_buffer___20);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___20);
            }
          }
          break;
        }
      }
      myCIL___tmp___108 = b;
      b = b + 1;
      *myCIL___tmp___108 = (unsigned char)28;
      break;
    }
    break;
    case 96: 
    while (1) {
      while ((unsigned long )((b - bufp->buffer) + 1) > bufp->allocated) {
        while (1) {
          old_buffer___21 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((enum __anonenum_reg_errcode_t_25 )15);
          }
          bufp->allocated = bufp->allocated << 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          myCIL___tmp___109 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)myCIL___tmp___109;
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((enum __anonenum_reg_errcode_t_25 )12);
          }
          if ((unsigned long )old_buffer___21 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___21);
            begalt = bufp->buffer + (begalt - old_buffer___21);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___21);
            }
            if (laststart) {
              laststart = bufp->buffer + (laststart - old_buffer___21);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___21);
            }
          }
          break;
        }
      }
      myCIL___tmp___110 = b;
      b = b + 1;
      *myCIL___tmp___110 = (unsigned char)10;
      break;
    }
    break;
    case 39: 
    while (1) {
      while ((unsigned long )((b - bufp->buffer) + 1) > bufp->allocated) {
        while (1) {
          old_buffer___22 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((enum __anonenum_reg_errcode_t_25 )15);
          }
          bufp->allocated = bufp->allocated << 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          myCIL___tmp___111 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)myCIL___tmp___111;
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((enum __anonenum_reg_errcode_t_25 )12);
          }
          if ((unsigned long )old_buffer___22 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___22);
            begalt = bufp->buffer + (begalt - old_buffer___22);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___22);
            }
            if (laststart) {
              laststart = bufp->buffer + (laststart - old_buffer___22);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___22);
            }
          }
          break;
        }
      }
      myCIL___tmp___112 = b;
      b = b + 1;
      *myCIL___tmp___112 = (unsigned char)11;
      break;
    }
    break;
    case 49: 
    case 50: 
    case 51: 
    case 52: 
    case 53: 
    case 54: 
    case 55: 
    case 56: 
    case 57: 
    if (syntax & (unsigned int )((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    }
    c1 = (unsigned char )((int )c - 48);
    if ((regnum_t )c1 > regnum) {
      return ((enum __anonenum_reg_errcode_t_25 )6);
    }
    myCIL___tmp___113 = group_in_compile_stack(compile_stack, c1);
    if (myCIL___tmp___113) {
      goto normal_char;
    }
    laststart = b;
    while (1) {
      while ((unsigned long )((b - bufp->buffer) + 2) > bufp->allocated) {
        while (1) {
          old_buffer___23 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((enum __anonenum_reg_errcode_t_25 )15);
          }
          bufp->allocated = bufp->allocated << 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          myCIL___tmp___114 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)myCIL___tmp___114;
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((enum __anonenum_reg_errcode_t_25 )12);
          }
          if ((unsigned long )old_buffer___23 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___23);
            begalt = bufp->buffer + (begalt - old_buffer___23);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___23);
            }
            if (laststart) {
              laststart = bufp->buffer + (laststart - old_buffer___23);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___23);
            }
          }
          break;
        }
      }
      myCIL___tmp___115 = b;
      b = b + 1;
      *myCIL___tmp___115 = (unsigned char)7;
      myCIL___tmp___116 = b;
      b = b + 1;
      *myCIL___tmp___116 = c1;
      break;
    }
    break;
    case 43: 
    case 63: 
    if (syntax & (unsigned int )(1 << 1)) {
      goto handle_plus;
    } else {
      goto normal_backslash;
    }
    default: ;
    normal_backslash: 
    if (translate) {
      c = (unsigned char )*(translate + c);
    } else {
      c = c;
    }
    goto normal_char;
    }
    break;
    default: ;
    normal_char: 
    if (! pending_exact) {
      goto _L___23;
    } else {
      if ((unsigned long )((pending_exact + (int )*pending_exact) + 1) != (unsigned long )b) {
        goto _L___23;
      } else {
        if ((int )*pending_exact == (1 << 8) - 1) {
          goto _L___23;
        } else {
          if ((int )*p == 42) {
            goto _L___23;
          } else {
            if ((int )*p == 94) {
              goto _L___23;
            } else {
              if (syntax & (unsigned int )(1 << 1)) {
                if ((int )*p == 92) {
                  if ((int )*(p + 1) == 43) {
                    myCIL___tmp___120 = 1;
                  } else {
                    if ((int )*(p + 1) == 63) {
                      myCIL___tmp___120 = 1;
                    } else {
                      myCIL___tmp___120 = 0;
                    }
                  }
                } else {
                  myCIL___tmp___120 = 0;
                }
                myCIL___tmp___122 = myCIL___tmp___120;
              } else {
                if ((int )*p == 43) {
                  myCIL___tmp___121 = 1;
                } else {
                  if ((int )*p == 63) {
                    myCIL___tmp___121 = 1;
                  } else {
                    myCIL___tmp___121 = 0;
                  }
                }
                myCIL___tmp___122 = myCIL___tmp___121;
              }
              if (myCIL___tmp___122) {
                goto _L___23;
              } else {
                if (syntax & (unsigned int )(((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
                  if (syntax & (unsigned int )((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
                    if ((int )*p == 123) {
                        myCIL___tmp___124 = 1;
                    }
                    else {
                        myCIL___tmp___124 = 0;
                    }
                  } else {
                    if ((int )*(p + 0) == 92) {
                      if ((int )*(p + 1) == 123) {
                        myCIL___tmp___123 = 1;
                      } else {
                        myCIL___tmp___123 = 0;
                      }
                    } else {
                      myCIL___tmp___123 = 0;
                    }
                    myCIL___tmp___124 = myCIL___tmp___123;
                  }
                  if (myCIL___tmp___124) {
                    _L___23: /* CIL Label */ 
                    laststart = b;
                    while (1) {
                      while ((unsigned long )((b - bufp->buffer) + 2) > bufp->allocated) {
                        while (1) {
                          old_buffer___24 = bufp->buffer;
                          if (bufp->allocated == (unsigned long )(1L << 16)) {
                            return ((enum __anonenum_reg_errcode_t_25 )15);
                          }
                          bufp->allocated = bufp->allocated << 1;
                          if (bufp->allocated > (unsigned long )(1L << 16)) {
                            bufp->allocated = (unsigned long )(1L << 16);
                          }
                          myCIL___tmp___117 = realloc((void *)bufp->buffer, bufp->allocated);
                          bufp->buffer = (unsigned char *)myCIL___tmp___117;
                          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
                            return ((enum __anonenum_reg_errcode_t_25 )12);
                          }
                          if ((unsigned long )old_buffer___24 != (unsigned long )bufp->buffer) {
                            b = bufp->buffer + (b - old_buffer___24);
                            begalt = bufp->buffer + (begalt - old_buffer___24);
                            if (fixup_alt_jump) {
                              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___24);
                            }
                            if (laststart) {
                              laststart = bufp->buffer + (laststart - old_buffer___24);
                            }
                            if (pending_exact) {
                              pending_exact = bufp->buffer + (pending_exact - old_buffer___24);
                            }
                          }
                          break;
                        }
                      }
                      myCIL___tmp___118 = b;
                      b = b + 1;
                      *myCIL___tmp___118 = (unsigned char)1;
                      myCIL___tmp___119 = b;
                      b = b + 1;
                      *myCIL___tmp___119 = (unsigned char)0;
                      break;
                    }
                    pending_exact = b - 1;
                  }
                }
              }
            }
          }
        }
      }
    }
    while (1) {
      while ((unsigned long )((b - bufp->buffer) + 1) > bufp->allocated) {
        while (1) {
          old_buffer___25 = bufp->buffer;
          if (bufp->allocated == (unsigned long )(1L << 16)) {
            return ((enum __anonenum_reg_errcode_t_25 )15);
          }
          bufp->allocated = bufp->allocated << 1;
          if (bufp->allocated > (unsigned long )(1L << 16)) {
            bufp->allocated = (unsigned long )(1L << 16);
          }
          myCIL___tmp___125 = realloc((void *)bufp->buffer, bufp->allocated);
          bufp->buffer = (unsigned char *)myCIL___tmp___125;
          if ((unsigned long )bufp->buffer == (unsigned long )((void *)0)) {
            return ((enum __anonenum_reg_errcode_t_25 )12);
          }
          if ((unsigned long )old_buffer___25 != (unsigned long )bufp->buffer) {
            b = bufp->buffer + (b - old_buffer___25);
            begalt = bufp->buffer + (begalt - old_buffer___25);
            if (fixup_alt_jump) {
              fixup_alt_jump = bufp->buffer + (fixup_alt_jump - old_buffer___25);
            }
            if (laststart) {
              laststart = bufp->buffer + (laststart - old_buffer___25);
            }
            if (pending_exact) {
              pending_exact = bufp->buffer + (pending_exact - old_buffer___25);
            }
          }
          break;
        }
      }
      myCIL___tmp___126 = b;
      b = b + 1;
      *myCIL___tmp___126 = c;
      break;
    }
    *pending_exact = (unsigned char )((int )*pending_exact + 1);
    break;
    }
  }
  if (fixup_alt_jump) {
    store_op1(13, fixup_alt_jump, (b - fixup_alt_jump) - 3);
  }
  if (! (compile_stack.avail == 0U)) {
    return ((enum __anonenum_reg_errcode_t_25 )8);
  }
  bufp->used = (unsigned long )(b - bufp->buffer);
  return ((enum __anonenum_reg_errcode_t_25 )0);
}
}
static void store_op1(re_opcode_t op , unsigned char *loc , int arg ) 
{ 

  {
  *loc = (unsigned char )op;
  while (1) {
    *((loc + 1) + 0) = (unsigned char )(arg & 255);
    *((loc + 1) + 1) = (unsigned char )(arg >> 8);
    break;
  }
  return;
}
}
static void store_op2(re_opcode_t op , unsigned char *loc , int arg1 , int arg2 ) 
{ 

  {
  *loc = (unsigned char )op;
  while (1) {
    *((loc + 1) + 0) = (unsigned char )(arg1 & 255);
    *((loc + 1) + 1) = (unsigned char )(arg1 >> 8);
    break;
  }
  while (1) {
    *((loc + 3) + 0) = (unsigned char )(arg2 & 255);
    *((loc + 3) + 1) = (unsigned char )(arg2 >> 8);
    break;
  }
  return;
}
}
static void insert_op1(re_opcode_t op , unsigned char *loc , int arg , unsigned char *end ) 
{ register unsigned char *pfrom ;
  register unsigned char *pto ;

  {
  pfrom = end;
  pto = end + 3;
  while ((unsigned long )pfrom != (unsigned long )loc) {
    pto = pto - 1;
    pfrom = pfrom - 1;
    *pto = *pfrom;
  }
  store_op1(op, loc, arg);
  return;
}
}
static void insert_op2(re_opcode_t op , unsigned char *loc , int arg1 , int arg2 , unsigned char *end ) 
{ register unsigned char *pfrom ;
  register unsigned char *pto ;

  {
  pfrom = end;
  pto = end + 5;
  while ((unsigned long )pfrom != (unsigned long )loc) {
    pto = pto - 1;
    pfrom = pfrom - 1;
    *pto = *pfrom;
  }
  store_op2(op, loc, arg1, arg2);
  return;
}
}
static boolean at_begline_loc_p(char *pattern , char *p , reg_syntax_t syntax ) 
{ char *prev ;
  boolean prev_prev_backslash ;
  int myCIL___tmp ;
  int myCIL___tmp___0 ;

  {
  prev = p - 2;
  if ((unsigned long )prev > (unsigned long )pattern) {
    if ((int )*(prev + -1) == 92) {
      myCIL___tmp = 1;
    } else {
      myCIL___tmp = 0;
    }
  } else {
    myCIL___tmp = 0;
  }
  prev_prev_backslash = (boolean )myCIL___tmp;
  if ((int )*prev == 40) {
    if (syntax & (unsigned int )(((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      myCIL___tmp___0 = 1;
    } else {
      if (prev_prev_backslash) {
        myCIL___tmp___0 = 1;
      } else {
        goto _L;
      }
    }
  } else {
    _L: /* CIL Label */ 
    if ((int )*prev == 124) {
      if (syntax & (unsigned int )(((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        myCIL___tmp___0 = 1;
      } else {
        if (prev_prev_backslash) {
          myCIL___tmp___0 = 1;
        } else {
          myCIL___tmp___0 = 0;
        }
      }
    } else {
      myCIL___tmp___0 = 0;
    }
  }
  return ((char )myCIL___tmp___0);
}
}
static boolean at_endline_loc_p(char *p , char *pend , int syntax ) 
{ char *next ;
  boolean next_backslash ;
  char *next_next ;
  char *myCIL___tmp ;
  int myCIL___tmp___0 ;
  int myCIL___tmp___1 ;
  int myCIL___tmp___2 ;
  int myCIL___tmp___3 ;
  int myCIL___tmp___4 ;

  {
  next = p;
  if ((int )*next == 92) {
    next_backslash = 1;
  }
  else {
    next_backslash = 0;
  }
  if ((unsigned long )(p + 1) < (unsigned long )pend) {
    myCIL___tmp = p + 1;
  } else {
    myCIL___tmp = (char *)((void *)0);
  }
  next_next = myCIL___tmp;
  if (syntax & (((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
    if ((int )*next == 41) {
      myCIL___tmp___1 = 1;
    }
    else {
      myCIL___tmp___1 = 0;
    }
  } else {
    if (next_backslash) {
      if (next_next) {
        if ((int )*next_next == 41) {
          myCIL___tmp___0 = 1;
        } else {
          myCIL___tmp___0 = 0;
        }
      } else {
        myCIL___tmp___0 = 0;
      }
    } else {
      myCIL___tmp___0 = 0;
    }
    myCIL___tmp___1 = myCIL___tmp___0;
  }
  if (myCIL___tmp___1) {
    myCIL___tmp___4 = 1;
  } else {
    if (syntax & (((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      if ((int )*next == 124) {
        myCIL___tmp___3 = 1;
      }
      else {
        myCIL___tmp___3 = 0;
      }
    } else {
      if (next_backslash) {
        if (next_next) {
          if ((int )*next_next == 124) {
            myCIL___tmp___2 = 1;
          } else {
            myCIL___tmp___2 = 0;
          }
        } else {
          myCIL___tmp___2 = 0;
        }
      } else {
        myCIL___tmp___2 = 0;
      }
      myCIL___tmp___3 = myCIL___tmp___2;
    }
    if (myCIL___tmp___3) {
      myCIL___tmp___4 = 1;
    } else {
      myCIL___tmp___4 = 0;
    }
  }
  return ((char )myCIL___tmp___4);
}
}
static boolean group_in_compile_stack(compile_stack_type compile_stack , regnum_t regnum ) 
{ int this_element ;

  {
  this_element = (int )(compile_stack.avail - 1U);
  while (this_element >= 0) {
    if ((compile_stack.stack + this_element)->regnum == regnum) {
      return ((char)1);
    }
    this_element = this_element - 1;
  }
  return ((char)0);
}
}
static reg_errcode_t compile_range(char **p_ptr , char *pend , char *translate , reg_syntax_t syntax , unsigned char *b ) 
{ unsigned int this_char ;
  char *p ;
  int range_start ;
  int range_end ;
  int myCIL___tmp ;
  unsigned int myCIL___tmp___0 ;
  unsigned int myCIL___tmp___1 ;

  {
  p = *p_ptr;
  if ((unsigned long )p == (unsigned long )pend) {
    return ((enum __anonenum_reg_errcode_t_25 )11);
  }
  range_start = (int )*((unsigned char *)p + -2);
  range_end = (int )*((unsigned char *)p + 0);
  *p_ptr = *p_ptr + 1;
  if (range_start > range_end) {
    if (syntax & (unsigned int )((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      myCIL___tmp = 11;
    } else {
      myCIL___tmp = 0;
    }
    return ((enum __anonenum_reg_errcode_t_25 )myCIL___tmp);
  }
  this_char = (unsigned int )range_start;
  while (this_char <= (unsigned int )range_end) {
    if (translate) {
      myCIL___tmp___0 = (unsigned int )*(translate + (unsigned char )this_char);
    } else {
      myCIL___tmp___0 = this_char;
    }
    if (translate) {
      myCIL___tmp___1 = (unsigned int )*(translate + (unsigned char )this_char);
    } else {
      myCIL___tmp___1 = this_char;
    }
    *(b + (int )((unsigned char )myCIL___tmp___0) / 8) = (unsigned char )((int )*(b + (int )((unsigned char )myCIL___tmp___0) / 8) | (1 << (int )((unsigned char )myCIL___tmp___1) % 8));
    this_char = this_char + 1U;
  }
  return ((enum __anonenum_reg_errcode_t_25 )0);
}
}
int re_max_failures  =    2000;
int re_compile_fastmap(struct re_pattern_buffer *bufp ) 
{ int j ;
  int k ;
  fail_stack_type fail_stack ;
  char *destination ;
  unsigned int num_regs ;
  register char *fastmap ;
  unsigned char *pattern ;
  unsigned long size ;
  unsigned char *p ;
  register unsigned char *pend ;
  boolean path_can_be_null ;
  boolean succeed_n_p ;
  void *myCIL___tmp ;
  unsigned char *myCIL___tmp___0 ;
  unsigned char *myCIL___tmp___1 ;
  unsigned char *myCIL___tmp___2 ;
  unsigned int myCIL___tmp___6 ;
  int myCIL___tmp___7 ;
  void *myCIL___tmp___8 ;
  int myCIL___tmp___9 ;
  int myCIL___tmp___10 ;

  {
  num_regs = 0U;
  fastmap = bufp->fastmap;
  pattern = bufp->buffer;
  size = bufp->used;
  p = (unsigned char *)pattern;
  pend = pattern + size;
  path_can_be_null = (boolean )1;
  succeed_n_p = (boolean )0;
  while (1) {
    myCIL___tmp = __builtin_alloca(5UL * sizeof(fail_stack_elt_t ));
    fail_stack.stack = (fail_stack_elt_t *)myCIL___tmp;
    if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
      return (-2);
    }
    fail_stack.size = 5U;
    fail_stack.avail = 0U;
    break;
  }
  memset((void *)fastmap, 0, (unsigned long )(1 << 8));
  bufp->fastmap_accurate = 1U;
  bufp->can_be_null = 0U;
  while (1) {
    if (! ((unsigned long )p != (unsigned long )pend)) {
      if (! (! (fail_stack.avail == 0U))) {
        break;
      }
    }
    if ((unsigned long )p == (unsigned long )pend) {
      bufp->can_be_null = bufp->can_be_null | (unsigned int )path_can_be_null;
      path_can_be_null = (char)1;
      fail_stack.avail = fail_stack.avail - 1U;
      p = *(fail_stack.stack + fail_stack.avail);
    }
    myCIL___tmp___0 = p;
    p = p + 1;
    switch ((int )((enum __anonenum_re_opcode_t_28 )*myCIL___tmp___0)) {
    case 7: 
    bufp->can_be_null = 1U;
    return (0);
    case 1: 
    *(fastmap + *(p + 1)) = (char)1;
    break;
    case 3: 
    myCIL___tmp___1 = p;
    p = p + 1;
    j = (int )((int )*myCIL___tmp___1 * 8 - 1);
    while (j >= 0) {
      if ((int )*(p + j / 8) & (int )(1 << j % 8)) {
        *(fastmap + j) = (char)1;
      }
      j = j - 1;
    }
    break;
    case 4: 
    j = (int )((int )*p * 8);
    while (j < 1 << 8) {
      *(fastmap + j) = (char)1;
      j = j + 1;
    }
    myCIL___tmp___2 = p;
    p = p + 1;
    j = (int )((int )*myCIL___tmp___2 * 8 - 1);
    while (j >= 0) {
      if (! ((int )*(p + j / 8) & (int )(1 << j % 8))) {
        *(fastmap + j) = (char)1;
      }
      j = j - 1;
    }
    break;
    case 23: 
    j = 0;
    while (j < 1 << 8) {
      if ((int )re_syntax_table[j] == 1) {
        *(fastmap + j) = (char)1;
      }
      j = j + 1;
    }
    break;
    case 24: 
    j = 0;
    while (j < 1 << 8) {
      if ((int )re_syntax_table[j] != 1) {
        *(fastmap + j) = (char)1;
      }
      j = j + 1;
    }
    break;
    case 2: 
    j = 0;
    while (j < 1 << 8) {
      *(fastmap + j) = (char)1;
      j = j + 1;
    }
    if (! (bufp->syntax & (unsigned int )((((((1 << 1) << 1) << 1) << 1) << 1) << 1))) {
      *(fastmap + '\n') = (char)0;
    } else {
      if (bufp->can_be_null) {
        return (0);
      }
    }
    break;
    case 0: 
    case 8: 
    case 9: 
    case 10: 
    case 11: 
    case 27: 
    case 28: 
    case 25: 
    case 26: 
    case 19: 
    continue;
    case 21: 
    case 16: 
    case 17: 
    case 12: 
    case 13: 
    case 18: 
    while (1) {
      while (1) {
        j = (int )((int )*p & 255);
        j = j + ((int )((signed char )*(p + 1)) << 8);
        break;
      }
      p = p + 2;
      break;
    }
    p = p + j;
    if (j > 0) {
      continue;
    }
    if ((unsigned int )((enum __anonenum_re_opcode_t_28 )*p) != 14U) {
      if ((unsigned int )((enum __anonenum_re_opcode_t_28 )*p) != 20U) {
        continue;
      }
    }
    p = p + 1;
    while (1) {
      while (1) {
        j = (int )((int )*p & 255);
        j = j + ((int )((signed char )*(p + 1)) << 8);
        break;
      }
      p = p + 2;
      break;
    }
    p = p + j;
    if (! (fail_stack.avail == 0U)) {
      if ((unsigned long )*(fail_stack.stack + (fail_stack.avail - 1U)) == (unsigned long )p) {
        fail_stack.avail = fail_stack.avail - 1U;
      }
    }
    continue;
    handle_on_failure_jump: 
    case 14: 
    case 15: 
    while (1) {
      while (1) {
        j = (int )((int )*p & 255);
        j = j + ((int )((signed char )*(p + 1)) << 8);
        break;
      }
      p = p + 2;
      break;
    }
    if ((unsigned long )(p + j) < (unsigned long )pend) {
      if (fail_stack.avail == fail_stack.size) {
        if (fail_stack.size > (unsigned int )re_max_failures * ((num_regs - 1U) * 3U + 4U)) {
          myCIL___tmp___10 = 0;
        } else {
          myCIL___tmp___8 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(fail_stack_elt_t ));
          destination = (char *)myCIL___tmp___8;
          memcpy((void *)destination, (void *)fail_stack.stack, (unsigned long )fail_stack.size * sizeof(fail_stack_elt_t ));
          fail_stack.stack = (fail_stack_elt_t *)destination;
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
            myCIL___tmp___9 = 0;
          } else {
            fail_stack.size = fail_stack.size << 1;
            myCIL___tmp___9 = 1;
          }
          myCIL___tmp___10 = myCIL___tmp___9;
        }
        if (myCIL___tmp___10) {
          myCIL___tmp___6 = fail_stack.avail;
          fail_stack.avail = fail_stack.avail + 1U;
          *(fail_stack.stack + myCIL___tmp___6) = p + j;
          myCIL___tmp___7 = 1;
        } else {
          myCIL___tmp___7 = 0;
        }
      } else {
        myCIL___tmp___6 = fail_stack.avail;
        fail_stack.avail = fail_stack.avail + 1U;
        *(fail_stack.stack + myCIL___tmp___6) = p + j;
        myCIL___tmp___7 = 1;
      }
      if (! myCIL___tmp___7) {
        return (-2);
      }
    } else {
      bufp->can_be_null = 1U;
    }
    if (succeed_n_p) {
      while (1) {
        while (1) {
          k = (int )((int )*p & 255);
          k = k + ((int )((signed char )*(p + 1)) << 8);
          break;
        }
        p = p + 2;
        break;
      }
      succeed_n_p = (char)0;
    }
    continue;
    case 20: 
    p = p + 2;
    while (1) {
      while (1) {
        k = (int )((int )*p & 255);
        k = k + ((int )((signed char )*(p + 1)) << 8);
        break;
      }
      p = p + 2;
      break;
    }
    if (k == 0) {
      p = p - 4;
      succeed_n_p = (char)1;
      goto handle_on_failure_jump;
    }
    continue;
    case 22: 
    p = p + 4;
    continue;
    case 5: 
    case 6: 
    p = p + 2;
    continue;
    default: 
    abort();
    }
    path_can_be_null = (char)0;
    p = (unsigned char *)pend;
  }
  bufp->can_be_null = bufp->can_be_null | (unsigned int )path_can_be_null;
  return (0);
}
}
void re_set_registers(struct re_pattern_buffer *bufp , struct re_registers *regs , unsigned int num_regs , regoff_t *starts , regoff_t *ends ) 
{ regoff_t *myCIL___tmp ;

  {
  if (num_regs) {
    bufp->regs_allocated = 1U;
    regs->num_regs = num_regs;
    regs->start = starts;
    regs->end = ends;
  } else {
    bufp->regs_allocated = 0U;
    regs->num_regs = 0U;
    myCIL___tmp = (regoff_t *)0;
    regs->end = myCIL___tmp;
    regs->start = myCIL___tmp;
  }
  return;
}
}
int re_search(struct re_pattern_buffer *bufp , char *string , int size , int startpos , int range , struct re_registers *regs ) 
{ int myCIL___tmp ;

  {
  myCIL___tmp = re_search_2(bufp, (char *)((void *)0), 0, string, size, startpos, range, regs, size);
  return (myCIL___tmp);
}
}
int re_search_2(struct re_pattern_buffer *bufp , char *string1 , int size1 , char *string2 , int size2 , int startpos , int range , struct re_registers *regs , int stop ) 
{ int val ;
  register char *fastmap ;
  register char *translate ;
  int total_size ;
  int endpos ;
  int myCIL___tmp ;
  register char *d ;
  register int lim ;
  int irange ;
  char *myCIL___tmp___0 ;
  char *myCIL___tmp___1 ;
  char *myCIL___tmp___2 ;
  register char c ;
  int myCIL___tmp___3 ;
  int myCIL___tmp___4 ;

  {
  fastmap = bufp->fastmap;
  translate = bufp->translate;
  total_size = size1 + size2;
  endpos = startpos + range;
  if (startpos < 0) {
    return (-1);
  } else {
    if (startpos > total_size) {
      return (-1);
    }
  }
  if (endpos < -1) {
    range = -1 - startpos;
  } else {
    if (endpos > total_size) {
      range = total_size - startpos;
    }
  }
  if (bufp->used > 0UL) {
    if ((unsigned int )((enum __anonenum_re_opcode_t_28 )*(bufp->buffer + 0)) == 10U) {
      if (range > 0) {
        if (startpos > 0) {
          return (-1);
        } else {
          range = 1;
        }
      }
    }
  }
  if (fastmap) {
    if (! bufp->fastmap_accurate) {
      myCIL___tmp = re_compile_fastmap(bufp);
      if (myCIL___tmp == -2) {
        return (-2);
      }
    }
  }
  while (1) {
    if (fastmap) {
      if (startpos < total_size) {
        if (! bufp->can_be_null) {
          if (range > 0) {
            lim = 0;
            irange = range;
            if (startpos < size1) {
              if (startpos + range >= size1) {
                lim = range - (size1 - startpos);
              }
            }
            if (startpos >= size1) {
              myCIL___tmp___0 = string2 - size1;
            } else {
              myCIL___tmp___0 = string1;
            }
            d = myCIL___tmp___0 + startpos;
            if (translate) {
              while (1) {
                if (range > lim) {
                  myCIL___tmp___1 = d;
                  d = d + 1;
                  if (*(fastmap + (unsigned char )*(translate + (unsigned char )*myCIL___tmp___1))) {
                    break;
                  }
                } else {
                  break;
                }
                range = range - 1;
              }
            } else {
              while (1) {
                if (range > lim) {
                  myCIL___tmp___2 = d;
                  d = d + 1;
                  if (*(fastmap + (unsigned char )*myCIL___tmp___2)) {
                    break;
                  }
                } else {
                  break;
                }
                range = range - 1;
              }
            }
            startpos = startpos + (irange - range);
          } else {
            if (size1 == 0) {
              myCIL___tmp___3 = (int )*(string2 + (startpos - size1));
            } else {
              if (startpos >= size1) {
                myCIL___tmp___3 = (int )*(string2 + (startpos - size1));
              } else {
                myCIL___tmp___3 = (int )*(string1 + startpos);
              }
            }
            c = (char )myCIL___tmp___3;
            if (translate) {
              myCIL___tmp___4 = (int )*(translate + (unsigned char )c);
            } else {
              myCIL___tmp___4 = (int )c;
            }
            if (! *(fastmap + (unsigned char )myCIL___tmp___4)) {
              goto advance;
            }
          }
        }
      }
    }
    if (range >= 0) {
      if (startpos == total_size) {
        if (fastmap) {
          if (! bufp->can_be_null) {
            return (-1);
          }
        }
      }
    }
    val = re_match_2(bufp, string1, size1, string2, size2, startpos, regs, stop);
    if (val >= 0) {
      return (startpos);
    }
    if (val == -2) {
      return (-2);
    }
    advance: 
    if (! range) {
      break;
    } else {
      if (range > 0) {
        range = range - 1;
        startpos = startpos + 1;
      } else {
        range = range + 1;
        startpos = startpos - 1;
      }
    }
  }
  return (-1);
}
}
static int bcmp_translate(unsigned char *s1 , unsigned char *s2 , int len , char *translate ) ;
static boolean alt_match_null_string_p(unsigned char *p , unsigned char *end , register_info_type *reg_info ) ;
static boolean common_op_match_null_string_p(unsigned char **p , unsigned char *end , register_info_type *reg_info ) ;
static boolean group_match_null_string_p(unsigned char **p , unsigned char *end , register_info_type *reg_info ) ;
int re_match(struct re_pattern_buffer *bufp , char *string , int size , int pos , struct re_registers *regs ) 
{ int myCIL___tmp ;

  {
  myCIL___tmp = re_match_2(bufp, (char *)((void *)0), 0, string, size, pos, regs, size);
  return (myCIL___tmp);
}
}
int re_match_2(struct re_pattern_buffer *bufp , char *string1 , int size1 , char *string2 , int size2 , int pos , struct re_registers *regs , int stop ) 
{ int mcnt ;
  unsigned char *p1 ;
  char *end1 ;
  char *end2 ;
  char *end_match_1 ;
  char *end_match_2 ;
  char *d ;
  char *dend ;
  unsigned char *p ;
  register unsigned char *pend ;
  char *translate ;
  fail_stack_type fail_stack ;
  unsigned int num_regs ;
  unsigned int lowest_active_reg ;
  unsigned int highest_active_reg ;
  char **regstart ;
  char **regend ;
  char **old_regstart ;
  char **old_regend ;
  register_info_type *reg_info ;
  unsigned int best_regs_set ;
  char **best_regstart ;
  char **best_regend ;
  char *match_end ;
  char **reg_dummy ;
  register_info_type *reg_info_dummy ;
  void *myCIL___tmp ;
  void *myCIL___tmp___0 ;
  void *myCIL___tmp___1 ;
  void *myCIL___tmp___2 ;
  void *myCIL___tmp___3 ;
  void *myCIL___tmp___4 ;
  void *myCIL___tmp___5 ;
  void *myCIL___tmp___6 ;
  void *myCIL___tmp___7 ;
  void *myCIL___tmp___8 ;
  char *myCIL___tmp___9 ;
  char *myCIL___tmp___10 ;
  char *myCIL___tmp___11 ;
  boolean same_str_p ;
  int myCIL___tmp___12 ;
  void *myCIL___tmp___13 ;
  void *myCIL___tmp___14 ;
  void *myCIL___tmp___15 ;
  void *myCIL___tmp___16 ;
  regoff_t myCIL___tmp___17 ;
  unsigned int myCIL___tmp___18 ;
  regoff_t myCIL___tmp___19 ;
  char *myCIL___tmp___20 ;
  unsigned char *myCIL___tmp___21 ;
  unsigned char *myCIL___tmp___22 ;
  char *myCIL___tmp___23 ;
  unsigned char *myCIL___tmp___24 ;
  char *myCIL___tmp___25 ;
  unsigned char *myCIL___tmp___26 ;
  unsigned int r ;
  unsigned int myCIL___tmp___27 ;
  int myCIL___tmp___28 ;
  int myCIL___tmp___29 ;
  unsigned int r___0 ;
  unsigned int myCIL___tmp___30 ;
  register unsigned char c ;
  boolean not ;
  unsigned int r___1 ;
  unsigned int myCIL___tmp___31 ;
  boolean myCIL___tmp___32 ;
  char *myCIL___tmp___33 ;
  char *myCIL___tmp___34 ;
  unsigned char r___2 ;
  boolean is_a_jump_n ;
  unsigned char *myCIL___tmp___35 ;
  unsigned int r___3 ;
  char *destination ;
  int this_reg ;
  void *myCIL___tmp___36 ;
  int myCIL___tmp___37 ;
  int myCIL___tmp___38 ;
  unsigned int myCIL___tmp___39 ;
  unsigned int myCIL___tmp___40 ;
  unsigned int myCIL___tmp___41 ;
  unsigned int myCIL___tmp___42 ;
  unsigned int myCIL___tmp___43 ;
  unsigned int myCIL___tmp___44 ;
  unsigned int myCIL___tmp___45 ;
  register char *d2 ;
  register char *dend2 ;
  int regno ;
  unsigned char *myCIL___tmp___46 ;
  int myCIL___tmp___49 ;
  int myCIL___tmp___50 ;
  int myCIL___tmp___51 ;
  int myCIL___tmp___52 ;
  int myCIL___tmp___53 ;
  char *myCIL___tmp___54 ;
  int myCIL___tmp___55 ;
  char *myCIL___tmp___56 ;
  char *destination___0 ;
  int this_reg___0 ;
  void *myCIL___tmp___57 ;
  int myCIL___tmp___58 ;
  int myCIL___tmp___59 ;
  unsigned int myCIL___tmp___60 ;
  unsigned int myCIL___tmp___61 ;
  unsigned int myCIL___tmp___62 ;
  unsigned int myCIL___tmp___63 ;
  unsigned int myCIL___tmp___64 ;
  unsigned int myCIL___tmp___65 ;
  unsigned int myCIL___tmp___66 ;
  char *destination___1 ;
  int this_reg___1 ;
  void *myCIL___tmp___67 ;
  int myCIL___tmp___68 ;
  int myCIL___tmp___69 ;
  unsigned int myCIL___tmp___70 ;
  unsigned int myCIL___tmp___71 ;
  unsigned int myCIL___tmp___72 ;
  unsigned int myCIL___tmp___73 ;
  unsigned int myCIL___tmp___74 ;
  unsigned int myCIL___tmp___75 ;
  unsigned int myCIL___tmp___76 ;
  register unsigned char *p2 ;
  register unsigned char c___0 ;
  int myCIL___tmp___77 ;
  int not___0 ;
  unsigned int dummy_low_reg ;
  unsigned int dummy_high_reg ;
  unsigned char *pdummy ;
  char *sdummy ;
  int this_reg___2 ;
  unsigned char *string_temp ;
  char *destination___2 ;
  int this_reg___3 ;
  void *myCIL___tmp___78 ;
  int myCIL___tmp___79 ;
  int myCIL___tmp___80 ;
  unsigned int myCIL___tmp___81 ;
  unsigned int myCIL___tmp___82 ;
  unsigned int myCIL___tmp___83 ;
  unsigned int myCIL___tmp___84 ;
  unsigned int myCIL___tmp___85 ;
  unsigned int myCIL___tmp___86 ;
  unsigned int myCIL___tmp___87 ;
  char *destination___3 ;
  int this_reg___4 ;
  void *myCIL___tmp___88 ;
  int myCIL___tmp___89 ;
  int myCIL___tmp___90 ;
  unsigned int myCIL___tmp___91 ;
  unsigned int myCIL___tmp___92 ;
  unsigned int myCIL___tmp___93 ;
  unsigned int myCIL___tmp___94 ;
  unsigned int myCIL___tmp___95 ;
  unsigned int myCIL___tmp___96 ;
  unsigned int myCIL___tmp___97 ;
  char *myCIL___tmp___98 ;
  int myCIL___tmp___99 ;
  int myCIL___tmp___100 ;
  int myCIL___tmp___101 ;
  int myCIL___tmp___102 ;
  char *myCIL___tmp___103 ;
  int myCIL___tmp___104 ;
  int myCIL___tmp___105 ;
  int myCIL___tmp___106 ;
  int myCIL___tmp___107 ;
  int myCIL___tmp___108 ;
  int myCIL___tmp___109 ;
  char *myCIL___tmp___110 ;
  int myCIL___tmp___111 ;
  int myCIL___tmp___112 ;
  char *myCIL___tmp___113 ;
  int myCIL___tmp___114 ;
  int myCIL___tmp___115 ;
  int myCIL___tmp___116 ;
  int myCIL___tmp___117 ;
  int myCIL___tmp___118 ;
  int myCIL___tmp___119 ;
  unsigned int r___4 ;
  unsigned int myCIL___tmp___120 ;
  int myCIL___tmp___121 ;
  int myCIL___tmp___122 ;
  unsigned int r___5 ;
  unsigned int myCIL___tmp___123 ;
  int this_reg___5 ;
  unsigned char *string_temp___0 ;
  boolean is_a_jump_n___0 ;

  {
  p = bufp->buffer;
  pend = p + bufp->used;
  translate = bufp->translate;
  num_regs = (unsigned int )(bufp->re_nsub + 1UL);
  lowest_active_reg = (unsigned int )((1 << 8) + 1);
  highest_active_reg = (unsigned int )(1 << 8);
  best_regs_set = 0U;
  match_end = (char *)((void *)0);
  while (1) {
    myCIL___tmp = __builtin_alloca(5UL * sizeof(fail_stack_elt_t ));
    fail_stack.stack = (fail_stack_elt_t *)myCIL___tmp;
    if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
      return (-2);
    }
    fail_stack.size = 5U;
    fail_stack.avail = 0U;
    break;
  }
  if (bufp->re_nsub) {
    myCIL___tmp___0 = __builtin_alloca((unsigned long )num_regs * sizeof(char *));
    regstart = (char **)myCIL___tmp___0;
    myCIL___tmp___1 = __builtin_alloca((unsigned long )num_regs * sizeof(char *));
    regend = (char **)myCIL___tmp___1;
    myCIL___tmp___2 = __builtin_alloca((unsigned long )num_regs * sizeof(char *));
    old_regstart = (char **)myCIL___tmp___2;
    myCIL___tmp___3 = __builtin_alloca((unsigned long )num_regs * sizeof(char *));
    old_regend = (char **)myCIL___tmp___3;
    myCIL___tmp___4 = __builtin_alloca((unsigned long )num_regs * sizeof(char *));
    best_regstart = (char **)myCIL___tmp___4;
    myCIL___tmp___5 = __builtin_alloca((unsigned long )num_regs * sizeof(char *));
    best_regend = (char **)myCIL___tmp___5;
    myCIL___tmp___6 = __builtin_alloca((unsigned long )num_regs * sizeof(register_info_type ));
    reg_info = (register_info_type *)myCIL___tmp___6;
    myCIL___tmp___7 = __builtin_alloca((unsigned long )num_regs * sizeof(char *));
    reg_dummy = (char **)myCIL___tmp___7;
    myCIL___tmp___8 = __builtin_alloca((unsigned long )num_regs * sizeof(register_info_type ));
    reg_info_dummy = (register_info_type *)myCIL___tmp___8;
    if (regstart) {
      if (regend) {
        if (old_regstart) {
          if (old_regend) {
            if (reg_info) {
              if (best_regstart) {
                if (best_regend) {
                  if (reg_dummy) {
                    if (! reg_info_dummy) {
                      __builtin_alloca(0UL);
                      return (-2);
                    }
                  } else {
                    __builtin_alloca(0UL);
                    return (-2);
                  }
                } else {
                  __builtin_alloca(0UL);
                  return (-2);
                }
              } else {
                __builtin_alloca(0UL);
                return (-2);
              }
            } else {
              __builtin_alloca(0UL);
              return (-2);
            }
          } else {
            __builtin_alloca(0UL);
            return (-2);
          }
        } else {
          __builtin_alloca(0UL);
          return (-2);
        }
      } else {
        __builtin_alloca(0UL);
        return (-2);
      }
    } else {
      __builtin_alloca(0UL);
      return (-2);
    }
  }
  if (pos < 0) {
    __builtin_alloca(0UL);
    return (-1);
  } else {
    if (pos > size1 + size2) {
      __builtin_alloca(0UL);
      return (-1);
    }
  }
  mcnt = 1;
  while ((unsigned int )mcnt < num_regs) {
    myCIL___tmp___11 = (char *)((char *)-1);
    *(old_regend + mcnt) = myCIL___tmp___11;
    myCIL___tmp___10 = myCIL___tmp___11;
    *(old_regstart + mcnt) = myCIL___tmp___10;
    myCIL___tmp___9 = myCIL___tmp___10;
    *(regend + mcnt) = myCIL___tmp___9;
    *(regstart + mcnt) = myCIL___tmp___9;
    (reg_info + mcnt)->bits.match_null_string_p = 3U;
    (reg_info + mcnt)->bits.is_active = 0U;
    (reg_info + mcnt)->bits.matched_something = 0U;
    (reg_info + mcnt)->bits.ever_matched_something = 0U;
    mcnt = mcnt + 1;
  }
  if (size2 == 0) {
    if ((unsigned long )string1 != (unsigned long )((void *)0)) {
      string2 = string1;
      size2 = size1;
      string1 = (char *)0;
      size1 = 0;
    }
  }
  end1 = string1 + size1;
  end2 = string2 + size2;
  if (stop <= size1) {
    end_match_1 = string1 + stop;
    end_match_2 = string2;
  } else {
    end_match_1 = end1;
    end_match_2 = (string2 + stop) - size1;
  }
  if (size1 > 0) {
    if (pos <= size1) {
      d = string1 + pos;
      dend = end_match_1;
    } else {
      d = (string2 + pos) - size1;
      dend = end_match_2;
    }
  } else {
    d = (string2 + pos) - size1;
    dend = end_match_2;
  }
  while (1) {
    if ((unsigned long )p == (unsigned long )pend) {
      if ((unsigned long )d != (unsigned long )end_match_2) {
        if (! (fail_stack.avail == 0U)) {
          if (size1) {
            if ((unsigned long )string1 <= (unsigned long )match_end) {
              if ((unsigned long )match_end <= (unsigned long )(string1 + size1)) {
                myCIL___tmp___12 = 1;
              } else {
                myCIL___tmp___12 = 0;
              }
            } else {
              myCIL___tmp___12 = 0;
            }
          } else {
            myCIL___tmp___12 = 0;
          }
          if (((unsigned long )dend == (unsigned long )end_match_1)) {
            if ((myCIL___tmp___12 == 1)) {
              same_str_p = 1;
            }
            else {
              same_str_p = 0;
            }
          }
          else {
            if ((myCIL___tmp___12 == 0)) {
              same_str_p = 1;
            }
            else {
              same_str_p = 0;
            }
          }
          if (! best_regs_set) {
            goto _L;
          } else {
            if (same_str_p) {
              if ((unsigned long )d > (unsigned long )match_end) {
                goto _L;
              } else {
                goto _L___0;
              }
            } else {
              _L___0: /* CIL Label */ 
              if (! same_str_p) {
                if (! ((unsigned long )dend == (unsigned long )end_match_1)) {
                  _L: /* CIL Label */ 
                  best_regs_set = 1U;
                  match_end = d;
                  mcnt = 1;
                  while ((unsigned int )mcnt < num_regs) {
                    *(best_regstart + mcnt) = *(regstart + mcnt);
                    *(best_regend + mcnt) = *(regend + mcnt);
                    mcnt = mcnt + 1;
                  }
                }
              }
            }
          }
          goto fail;
        } else {
          if (best_regs_set) {
            restore_best_regs: 
            d = match_end;
            if ((unsigned long )d >= (unsigned long )string1) {
              if ((unsigned long )d <= (unsigned long )end1) {
                dend = end_match_1;
              } else {
                dend = end_match_2;
              }
            } else {
              dend = end_match_2;
            }
            mcnt = 1;
            while ((unsigned int )mcnt < num_regs) {
              *(regstart + mcnt) = *(best_regstart + mcnt);
              *(regend + mcnt) = *(best_regend + mcnt);
              mcnt = mcnt + 1;
            }
          }
        }
      }
      if (regs) {
        if (! bufp->no_sub) {
          if (bufp->regs_allocated == 0U) {
            if (30U > num_regs + 1U) {
              regs->num_regs = 30U;
            } else {
              regs->num_regs = num_regs + 1U;
            }
            myCIL___tmp___13 = malloc((unsigned long )regs->num_regs * sizeof(regoff_t ));
            regs->start = (regoff_t *)myCIL___tmp___13;
            myCIL___tmp___14 = malloc((unsigned long )regs->num_regs * sizeof(regoff_t ));
            regs->end = (regoff_t *)myCIL___tmp___14;
            if ((unsigned long )regs->start == (unsigned long )((void *)0)) {
              return (-2);
            } else {
              if ((unsigned long )regs->end == (unsigned long )((void *)0)) {
                return (-2);
              }
            }
            bufp->regs_allocated = 1U;
          } else {
            if (bufp->regs_allocated == 1U) {
              if (regs->num_regs < num_regs + 1U) {
                regs->num_regs = num_regs + 1U;
                myCIL___tmp___15 = realloc((void *)regs->start, (unsigned long )regs->num_regs * sizeof(regoff_t ));
                regs->start = (regoff_t *)myCIL___tmp___15;
                myCIL___tmp___16 = realloc((void *)regs->end, (unsigned long )regs->num_regs * sizeof(regoff_t ));
                regs->end = (regoff_t *)myCIL___tmp___16;
                if ((unsigned long )regs->start == (unsigned long )((void *)0)) {
                  return (-2);
                } else {
                  if ((unsigned long )regs->end == (unsigned long )((void *)0)) {
                    return (-2);
                  }
                }
              }
            }
          }
          if (regs->num_regs > 0U) {
            *(regs->start + 0) = pos;
            if ((unsigned long )dend == (unsigned long )end_match_1) {
              *(regs->end + 0) = d - string1;
            } else {
              *(regs->end + 0) = (d - string2) + size1;
            }
          }
          mcnt = 1;
          while (1) {
            if (num_regs < regs->num_regs) {
              myCIL___tmp___18 = num_regs;
            } else {
              myCIL___tmp___18 = regs->num_regs;
            }
            if (! ((unsigned int )mcnt < myCIL___tmp___18)) {
              break;
            }
            if ((unsigned long )*(regstart + mcnt) == (unsigned long )((char *)-1)) {
              myCIL___tmp___17 = -1;
              *(regs->end + mcnt) = myCIL___tmp___17;
              *(regs->start + mcnt) = myCIL___tmp___17;
            } else {
              if ((unsigned long )*(regend + mcnt) == (unsigned long )((char *)-1)) {
                myCIL___tmp___17 = -1;
                *(regs->end + mcnt) = myCIL___tmp___17;
                *(regs->start + mcnt) = myCIL___tmp___17;
              } else {
                if (size1) {
                  if ((unsigned long )string1 <= (unsigned long )*(regstart + mcnt)) {
                    if ((unsigned long )*(regstart + mcnt) <= (unsigned long )(string1 + size1)) {
                      *(regs->start + mcnt) = *(regstart + mcnt) - string1;
                    } else {
                      *(regs->start + mcnt) = (*(regstart + mcnt) - string2) + size1;
                    }
                  } else {
                    *(regs->start + mcnt) = (*(regstart + mcnt) - string2) + size1;
                  }
                } else {
                  *(regs->start + mcnt) = (*(regstart + mcnt) - string2) + size1;
                }
                if (size1) {
                  if ((unsigned long )string1 <= (unsigned long )*(regend + mcnt)) {
                    if ((unsigned long )*(regend + mcnt) <= (unsigned long )(string1 + size1)) {
                      *(regs->end + mcnt) = *(regend + mcnt) - string1;
                    } else {
                      *(regs->end + mcnt) = (*(regend + mcnt) - string2) + size1;
                    }
                  } else {
                    *(regs->end + mcnt) = (*(regend + mcnt) - string2) + size1;
                  }
                } else {
                  *(regs->end + mcnt) = (*(regend + mcnt) - string2) + size1;
                }
              }
            }
            mcnt = mcnt + 1;
          }
          mcnt = (int )num_regs;
          while ((unsigned int )mcnt < regs->num_regs) {
            myCIL___tmp___19 = -1;
            *(regs->end + mcnt) = myCIL___tmp___19;
            *(regs->start + mcnt) = myCIL___tmp___19;
            mcnt = mcnt + 1;
          }
        }
      }
      __builtin_alloca(0UL);
      if ((unsigned long )dend == (unsigned long )end_match_1) {
        myCIL___tmp___20 = string1;
      } else {
        myCIL___tmp___20 = string2 - size1;
      }
      mcnt = (d - pos) - myCIL___tmp___20;
      return (mcnt);
    }
    myCIL___tmp___21 = p;
    p = p + 1;
    switch ((int )((enum __anonenum_re_opcode_t_28 )*myCIL___tmp___21)) {
    case 0: ;
    break;
    case 1: 
    myCIL___tmp___22 = p;
    p = p + 1;
    mcnt = (int )*myCIL___tmp___22;
    if (translate) {
      while (1) {
        while ((unsigned long )d == (unsigned long )dend) {
          if ((unsigned long )dend == (unsigned long )end_match_2) {
            goto fail;
          }
          d = string2;
          dend = end_match_2;
        }
        myCIL___tmp___23 = d;
        d = d + 1;
        myCIL___tmp___24 = p;
        p = p + 1;
        if ((int )*(translate + (unsigned char )*myCIL___tmp___23) != (int )((char )*myCIL___tmp___24)) {
          goto fail;
        }
        mcnt = mcnt - 1;
        if (! mcnt) {
          break;
        }
      }
    } else {
      while (1) {
        while ((unsigned long )d == (unsigned long )dend) {
          if ((unsigned long )dend == (unsigned long )end_match_2) {
            goto fail;
          }
          d = string2;
          dend = end_match_2;
        }
        myCIL___tmp___25 = d;
        d = d + 1;
        myCIL___tmp___26 = p;
        p = p + 1;
        if ((int )*myCIL___tmp___25 != (int )((char )*myCIL___tmp___26)) {
          goto fail;
        }
        mcnt = mcnt - 1;
        if (! mcnt) {
          break;
        }
      }
    }
    while (1) {
      r = lowest_active_reg;
      while (r <= highest_active_reg) {
        myCIL___tmp___27 = 1U;
        (reg_info + r)->bits.ever_matched_something = myCIL___tmp___27;
        (reg_info + r)->bits.matched_something = myCIL___tmp___27;
        r = r + 1U;
      }
      break;
    }
    break;
    case 2: ;
    while ((unsigned long )d == (unsigned long )dend) {
      if ((unsigned long )dend == (unsigned long )end_match_2) {
        goto fail;
      }
      d = string2;
      dend = end_match_2;
    }
    if (! (bufp->syntax & (unsigned int )((((((1 << 1) << 1) << 1) << 1) << 1) << 1))) {
      if (translate) {
        myCIL___tmp___28 = (int )*(translate + (unsigned char )*d);
      } else {
        myCIL___tmp___28 = (int )*d;
      }
      if (myCIL___tmp___28 == 10) {
        goto fail;
      } else {
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      if (bufp->syntax & (unsigned int )(((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        if (translate) {
          myCIL___tmp___29 = (int )*(translate + (unsigned char )*d);
        } else {
          myCIL___tmp___29 = (int )*d;
        }
        if (myCIL___tmp___29 == 0) {
          goto fail;
        }
      }
    }
    while (1) {
      r___0 = lowest_active_reg;
      while (r___0 <= highest_active_reg) {
        myCIL___tmp___30 = 1U;
        (reg_info + r___0)->bits.ever_matched_something = myCIL___tmp___30;
        (reg_info + r___0)->bits.matched_something = myCIL___tmp___30;
        r___0 = r___0 + 1U;
      }
      break;
    }
    d = d + 1;
    break;
    case 3: 
    case 4: 
    if (((unsigned int )((enum __anonenum_re_opcode_t_28 )*(p - 1)) == 4U))
        not = 1;
    else
        not = 0;
    while ((unsigned long )d == (unsigned long )dend) {
      if ((unsigned long )dend == (unsigned long )end_match_2) {
        goto fail;
      }
      d = string2;
      dend = end_match_2;
    }
    if (translate) {
      c = (unsigned char )*(translate + (unsigned char )*d);
    } else {
      c = (unsigned char )*d;
    }
    if ((unsigned int )c < (unsigned int )((int )*p * 8)) {
      if ((int )*(p + (1 + (int )c / 8)) & (1 << (int )c % 8)) {
        not = (char )(! not);
      }
    }
    p = p + (1 + (int )*p);
    if (! not) {
      goto fail;
    }
    while (1) {
      r___1 = lowest_active_reg;
      while (r___1 <= highest_active_reg) {
        myCIL___tmp___31 = 1U;
        (reg_info + r___1)->bits.ever_matched_something = myCIL___tmp___31;
        (reg_info + r___1)->bits.matched_something = myCIL___tmp___31;
        r___1 = r___1 + 1U;
      }
      break;
    }
    d = d + 1;
    break;
    case 5: 
    p1 = p;
    if ((reg_info + *p)->bits.match_null_string_p == 3U) {
      myCIL___tmp___32 = group_match_null_string_p(& p1, pend, reg_info);
      (reg_info + *p)->bits.match_null_string_p = (unsigned int )myCIL___tmp___32;
    }
    if ((reg_info + *p)->bits.match_null_string_p) {
      if ((unsigned long )*(regstart + *p) == (unsigned long )((char *)-1)) {
        myCIL___tmp___33 = d;
      } else {
        myCIL___tmp___33 = *(regstart + *p);
      }
      *(old_regstart + *p) = myCIL___tmp___33;
    } else {
      *(old_regstart + *p) = *(regstart + *p);
    }
    *(regstart + *p) = d;
    (reg_info + *p)->bits.is_active = 1U;
    (reg_info + *p)->bits.matched_something = 0U;
    highest_active_reg = (unsigned int )*p;
    if (lowest_active_reg == (unsigned int )((1 << 8) + 1)) {
      lowest_active_reg = (unsigned int )*p;
    }
    p = p + 2;
    break;
    case 6: ;
    if ((reg_info + *p)->bits.match_null_string_p) {
      if ((unsigned long )*(regend + *p) == (unsigned long )((char *)-1)) {
        myCIL___tmp___34 = d;
      } else {
        myCIL___tmp___34 = *(regend + *p);
      }
      *(old_regend + *p) = myCIL___tmp___34;
    } else {
      *(old_regend + *p) = *(regend + *p);
    }
    *(regend + *p) = d;
    (reg_info + *p)->bits.is_active = 0U;
    if (lowest_active_reg == highest_active_reg) {
      lowest_active_reg = (unsigned int )((1 << 8) + 1);
      highest_active_reg = (unsigned int )(1 << 8);
    } else {
      r___2 = (unsigned char )((int )*p - 1);
      while (1) {
        if ((int )r___2 > 0) {
          if (! (! (reg_info + r___2)->bits.is_active)) {
            break;
          }
        } else {
          break;
        }
        r___2 = (unsigned char )((int )r___2 - 1);
      }
      if ((int )r___2 == 0) {
        lowest_active_reg = (unsigned int )((1 << 8) + 1);
        highest_active_reg = (unsigned int )(1 << 8);
      } else {
        highest_active_reg = (unsigned int )r___2;
      }
    }
    if (! (reg_info + *p)->bits.matched_something) {
      goto _L___2;
    } else {
      if ((unsigned int )((enum __anonenum_re_opcode_t_28 )*(p + -3)) == 5U) {
        _L___2: /* CIL Label */ 
        if ((unsigned long )(p + 2) < (unsigned long )pend) {
          is_a_jump_n = (boolean )0;
          p1 = p + 2;
          mcnt = 0;
          myCIL___tmp___35 = p1;
          p1 = p1 + 1;
          switch ((int )((enum __anonenum_re_opcode_t_28 )*myCIL___tmp___35)) {
          case 21: 
          is_a_jump_n = (char)1;
          case 16: 
          case 17: 
          case 12: 
          case 18: 
          while (1) {
            while (1) {
              mcnt = (int )*p1 & 255;
              mcnt = mcnt + ((int )((signed char )*(p1 + 1)) << 8);
              break;
            }
            p1 = p1 + 2;
            break;
          }
          if (is_a_jump_n) {
            p1 = p1 + 2;
          }
          break;
          default: ;
          }
          p1 = p1 + mcnt;
          if (mcnt < 0) {
            if ((unsigned int )((enum __anonenum_re_opcode_t_28 )*p1) == 14U) {
              if ((unsigned int )((enum __anonenum_re_opcode_t_28 )*(p1 + 3)) == 5U) {
                if ((int )*(p1 + 4) == (int )*p) {
                  if ((reg_info + *p)->bits.ever_matched_something) {
                    (reg_info + *p)->bits.ever_matched_something = 0U;
                    r___3 = (unsigned int )*p;
                    while (r___3 < (unsigned int )((int )*p + (int )*(p + 1))) {
                      *(regstart + r___3) = *(old_regstart + r___3);
                      if ((int )*(old_regend + r___3) >= (int )*(regstart + r___3)) {
                        *(regend + r___3) = *(old_regend + r___3);
                      }
                      r___3 = r___3 + 1U;
                    }
                  }
                  p1 = p1 + 1;
                  while (1) {
                    while (1) {
                      mcnt = (int )*p1 & 255;
                      mcnt = mcnt + ((int )((signed char )*(p1 + 1)) << 8);
                      break;
                    }
                    p1 = p1 + 2;
                    break;
                  }
                  while (1) {
                    while (fail_stack.size - fail_stack.avail < ((highest_active_reg - lowest_active_reg) + 1U) * 3U + 4U) {
                      if (fail_stack.size > (unsigned int )re_max_failures * ((num_regs - 1U) * 3U + 4U)) {
                        myCIL___tmp___38 = 0;
                      } else {
                        myCIL___tmp___36 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(fail_stack_elt_t ));
                        destination = (char *)myCIL___tmp___36;
                        memcpy((void *)destination, (void *)fail_stack.stack, (unsigned long )fail_stack.size * sizeof(fail_stack_elt_t ));
                        fail_stack.stack = (fail_stack_elt_t *)destination;
                        if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
                          myCIL___tmp___37 = 0;
                        } else {
                          fail_stack.size = fail_stack.size << 1;
                          myCIL___tmp___37 = 1;
                        }
                        myCIL___tmp___38 = myCIL___tmp___37;
                      }
                      if (! myCIL___tmp___38) {
                        return (-2);
                      }
                    }
                    this_reg = (int )lowest_active_reg;
                    while ((unsigned int )this_reg <= highest_active_reg) {
                      myCIL___tmp___39 = fail_stack.avail;
                      fail_stack.avail = fail_stack.avail + 1U;
                      *(fail_stack.stack + myCIL___tmp___39) = (unsigned char *)*(regstart + this_reg);
                      myCIL___tmp___40 = fail_stack.avail;
                      fail_stack.avail = fail_stack.avail + 1U;
                      *(fail_stack.stack + myCIL___tmp___40) = (unsigned char *)*(regend + this_reg);
                      myCIL___tmp___41 = fail_stack.avail;
                      fail_stack.avail = fail_stack.avail + 1U;
                      *(fail_stack.stack + myCIL___tmp___41) = (reg_info + this_reg)->word;
                      this_reg = this_reg + 1;
                    }
                    myCIL___tmp___42 = fail_stack.avail;
                    fail_stack.avail = fail_stack.avail + 1U;
                    *(fail_stack.stack + myCIL___tmp___42) = (unsigned char *)lowest_active_reg;
                    myCIL___tmp___43 = fail_stack.avail;
                    fail_stack.avail = fail_stack.avail + 1U;
                    *(fail_stack.stack + myCIL___tmp___43) = (unsigned char *)highest_active_reg;
                    myCIL___tmp___44 = fail_stack.avail;
                    fail_stack.avail = fail_stack.avail + 1U;
                    *(fail_stack.stack + myCIL___tmp___44) = (unsigned char *)p1 + mcnt;
                    myCIL___tmp___45 = fail_stack.avail;
                    fail_stack.avail = fail_stack.avail + 1U;
                    *(fail_stack.stack + myCIL___tmp___45) = (unsigned char *)d;
                    break;
                  }
                  goto fail;
                }
              }
            }
          }
        }
      }
    }
    p = p + 2;
    break;
    case 7: 
    myCIL___tmp___46 = p;
    p = p + 1;
    regno = (int )*myCIL___tmp___46;
    if ((unsigned long )*(regstart + regno) == (unsigned long )((char *)-1)) {
      goto fail;
    } else {
      if ((unsigned long )*(regend + regno) == (unsigned long )((char *)-1)) {
        goto fail;
      }
    }
    d2 = *(regstart + regno);
    if (size1) {
      if ((unsigned long )string1 <= (unsigned long )*(regstart + regno)) {
        if ((unsigned long )*(regstart + regno) <= (unsigned long )(string1 + size1)) {
          myCIL___tmp___49 = 1;
        } else {
          myCIL___tmp___49 = 0;
        }
      } else {
        myCIL___tmp___49 = 0;
      }
    } else {
      myCIL___tmp___49 = 0;
    }
    if (size1) {
      if ((unsigned long )string1 <= (unsigned long )*(regend + regno)) {
        if ((unsigned long )*(regend + regno) <= (unsigned long )(string1 + size1)) {
          myCIL___tmp___50 = 1;
        } else {
          myCIL___tmp___50 = 0;
        }
      } else {
        myCIL___tmp___50 = 0;
      }
    } else {
      myCIL___tmp___50 = 0;
    }
    if (myCIL___tmp___49 == myCIL___tmp___50) {
      dend2 = *(regend + regno);
    } else {
      dend2 = end_match_1;
    }
    while (1) {
      while ((unsigned long )d2 == (unsigned long )dend2) {
        if ((unsigned long )dend2 == (unsigned long )end_match_2) {
          break;
        }
        if ((unsigned long )dend2 == (unsigned long )*(regend + regno)) {
          break;
        }
        d2 = string2;
        dend2 = *(regend + regno);
      }
      if ((unsigned long )d2 == (unsigned long )dend2) {
        break;
      }
      while ((unsigned long )d == (unsigned long )dend) {
        if ((unsigned long )dend == (unsigned long )end_match_2) {
          goto fail;
        }
        d = string2;
        dend = end_match_2;
      }
      mcnt = dend - d;
      if (mcnt > dend2 - d2) {
        mcnt = dend2 - d2;
      }
      if (translate) {
        myCIL___tmp___51 = bcmp_translate(d, d2, mcnt, translate);
        myCIL___tmp___53 = myCIL___tmp___51;
      } else {
        myCIL___tmp___52 = memcmp((void *)d, (void *)d2, (unsigned long )mcnt);
        myCIL___tmp___53 = myCIL___tmp___52;
      }
      if (myCIL___tmp___53) {
        goto fail;
      }
      d = d + mcnt;
      d2 = d2 + mcnt;
    }
    break;
    case 8: ;
    if (size1) {
      myCIL___tmp___54 = string1;
    } else {
      myCIL___tmp___54 = string2;
    }
    if ((unsigned long )d == (unsigned long )myCIL___tmp___54) {
      goto _L___3;
    } else {
      if (! size2) {
        _L___3: /* CIL Label */ 
        if (! bufp->not_bol) {
          break;
        }
      } else {
        if ((int )*(d + -1) == 10) {
          if (bufp->newline_anchor) {
            break;
          }
        }
      }
    }
    goto fail;
    case 9: ;
    if ((unsigned long )d == (unsigned long )end2) {
      if (! bufp->not_eol) {
        break;
      }
    } else {
      if ((unsigned long )d == (unsigned long )end1) {
        myCIL___tmp___55 = (int )*string2;
      } else {
        myCIL___tmp___55 = (int )*d;
      }
      if (myCIL___tmp___55 == 10) {
        if (bufp->newline_anchor) {
          break;
        }
      }
    }
    goto fail;
    case 10: ;
    if (size1) {
      myCIL___tmp___56 = string1;
    } else {
      myCIL___tmp___56 = string2;
    }
    if ((unsigned long )d == (unsigned long )myCIL___tmp___56) {
      break;
    } else {
      if (! size2) {
        break;
      }
    }
    goto fail;
    case 11: ;
    if ((unsigned long )d == (unsigned long )end2) {
      break;
    }
    goto fail;
    case 15: ;
    while (1) {
      while (1) {
        mcnt = (int )*p & 255;
        mcnt = mcnt + ((int )((signed char )*(p + 1)) << 8);
        break;
      }
      p = p + 2;
      break;
    }
    while (1) {
      while (fail_stack.size - fail_stack.avail < ((highest_active_reg - lowest_active_reg) + 1U) * 3U + 4U) {
        if (fail_stack.size > (unsigned int )re_max_failures * ((num_regs - 1U) * 3U + 4U)) {
          myCIL___tmp___59 = 0;
        } else {
          myCIL___tmp___57 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(fail_stack_elt_t ));
          destination___0 = (char *)myCIL___tmp___57;
          memcpy((void *)destination___0, (void *)fail_stack.stack, (unsigned long )fail_stack.size * sizeof(fail_stack_elt_t ));
          fail_stack.stack = (fail_stack_elt_t *)destination___0;
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
            myCIL___tmp___58 = 0;
          } else {
            fail_stack.size = fail_stack.size << 1;
            myCIL___tmp___58 = 1;
          }
          myCIL___tmp___59 = myCIL___tmp___58;
        }
        if (! myCIL___tmp___59) {
          return (-2);
        }
      }
      this_reg___0 = (int )lowest_active_reg;
      while ((unsigned int )this_reg___0 <= highest_active_reg) {
        myCIL___tmp___60 = fail_stack.avail;
        fail_stack.avail = fail_stack.avail + 1U;
        *(fail_stack.stack + myCIL___tmp___60) = (unsigned char *)*(regstart + this_reg___0);
        myCIL___tmp___61 = fail_stack.avail;
        fail_stack.avail = fail_stack.avail + 1U;
        *(fail_stack.stack + myCIL___tmp___61) = (unsigned char *)*(regend + this_reg___0);
        myCIL___tmp___62 = fail_stack.avail;
        fail_stack.avail = fail_stack.avail + 1U;
        *(fail_stack.stack + myCIL___tmp___62) = (reg_info + this_reg___0)->word;
        this_reg___0 = this_reg___0 + 1;
      }
      myCIL___tmp___63 = fail_stack.avail;
      fail_stack.avail = fail_stack.avail + 1U;
      *(fail_stack.stack + myCIL___tmp___63) = (unsigned char *)lowest_active_reg;
      myCIL___tmp___64 = fail_stack.avail;
      fail_stack.avail = fail_stack.avail + 1U;
      *(fail_stack.stack + myCIL___tmp___64) = (unsigned char *)highest_active_reg;
      myCIL___tmp___65 = fail_stack.avail;
      fail_stack.avail = fail_stack.avail + 1U;
      *(fail_stack.stack + myCIL___tmp___65) = (unsigned char *)p + mcnt;
      myCIL___tmp___66 = fail_stack.avail;
      fail_stack.avail = fail_stack.avail + 1U;
      *(fail_stack.stack + myCIL___tmp___66) = (unsigned char *)((void *)0);
      break;
    }
    break;
    on_failure: 
    case 14: ;
    while (1) {
      while (1) {
        mcnt = (int )*p & 255;
        mcnt = mcnt + ((int )((signed char )*(p + 1)) << 8);
        break;
      }
      p = p + 2;
      break;
    }
    p1 = p;
    while (1) {
      if ((unsigned long )p1 < (unsigned long )pend) {
        if (! ((unsigned int )((enum __anonenum_re_opcode_t_28 )*p1) == 0U)) {
          break;
        }
      } else {
        break;
      }
      p1 = p1 + 1;
    }
    if ((unsigned long )p1 < (unsigned long )pend) {
      if ((unsigned int )((enum __anonenum_re_opcode_t_28 )*p1) == 5U) {
        highest_active_reg = (unsigned int )((int )*(p1 + 1) + (int )*(p1 + 2));
        if (lowest_active_reg == (unsigned int )((1 << 8) + 1)) {
          lowest_active_reg = (unsigned int )*(p1 + 1);
        }
      }
    }
    while (1) {
      while (fail_stack.size - fail_stack.avail < ((highest_active_reg - lowest_active_reg) + 1U) * 3U + 4U) {
        if (fail_stack.size > (unsigned int )re_max_failures * ((num_regs - 1U) * 3U + 4U)) {
          myCIL___tmp___69 = 0;
        } else {
          myCIL___tmp___67 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(fail_stack_elt_t ));
          destination___1 = (char *)myCIL___tmp___67;
          memcpy((void *)destination___1, (void *)fail_stack.stack, (unsigned long )fail_stack.size * sizeof(fail_stack_elt_t ));
          fail_stack.stack = (fail_stack_elt_t *)destination___1;
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
            myCIL___tmp___68 = 0;
          } else {
            fail_stack.size = fail_stack.size << 1;
            myCIL___tmp___68 = 1;
          }
          myCIL___tmp___69 = myCIL___tmp___68;
        }
        if (! myCIL___tmp___69) {
          return (-2);
        }
      }
      this_reg___1 = (int )lowest_active_reg;
      while ((unsigned int )this_reg___1 <= highest_active_reg) {
        myCIL___tmp___70 = fail_stack.avail;
        fail_stack.avail = fail_stack.avail + 1U;
        *(fail_stack.stack + myCIL___tmp___70) = (unsigned char *)*(regstart + this_reg___1);
        myCIL___tmp___71 = fail_stack.avail;
        fail_stack.avail = fail_stack.avail + 1U;
        *(fail_stack.stack + myCIL___tmp___71) = (unsigned char *)*(regend + this_reg___1);
        myCIL___tmp___72 = fail_stack.avail;
        fail_stack.avail = fail_stack.avail + 1U;
        *(fail_stack.stack + myCIL___tmp___72) = (reg_info + this_reg___1)->word;
        this_reg___1 = this_reg___1 + 1;
      }
      myCIL___tmp___73 = fail_stack.avail;
      fail_stack.avail = fail_stack.avail + 1U;
      *(fail_stack.stack + myCIL___tmp___73) = (unsigned char *)lowest_active_reg;
      myCIL___tmp___74 = fail_stack.avail;
      fail_stack.avail = fail_stack.avail + 1U;
      *(fail_stack.stack + myCIL___tmp___74) = (unsigned char *)highest_active_reg;
      myCIL___tmp___75 = fail_stack.avail;
      fail_stack.avail = fail_stack.avail + 1U;
      *(fail_stack.stack + myCIL___tmp___75) = (unsigned char *)p + mcnt;
      myCIL___tmp___76 = fail_stack.avail;
      fail_stack.avail = fail_stack.avail + 1U;
      *(fail_stack.stack + myCIL___tmp___76) = (unsigned char *)d;
      break;
    }
    break;
    case 17: 
    while (1) {
      while (1) {
        mcnt = (int )*p & 255;
        mcnt = mcnt + ((int )((signed char )*(p + 1)) << 8);
        break;
      }
      p = p + 2;
      break;
    }
    p2 = p;
    while (1) {
      if ((unsigned long )(p2 + 2) < (unsigned long )pend) {
        if (! ((unsigned int )((enum __anonenum_re_opcode_t_28 )*p2) == 6U)) {
          if (! ((unsigned int )((enum __anonenum_re_opcode_t_28 )*p2) == 5U)) {
            break;
          }
        }
      } else {
        break;
      }
      p2 = p2 + 3;
    }
    if ((unsigned long )p2 == (unsigned long )pend) {
      *(p + -3) = (unsigned char)16;
    } else {
      if ((unsigned int )((enum __anonenum_re_opcode_t_28 )*p2) == 1U) {
        goto _L___6;
      } else {
        if (bufp->newline_anchor) {
          if ((unsigned int )((enum __anonenum_re_opcode_t_28 )*p2) == 9U) {
            _L___6: /* CIL Label */ 
            if ((int )*p2 == 9) {
              myCIL___tmp___77 = '\n';
            } else {
              myCIL___tmp___77 = (int )*(p2 + 2);
            }
            c___0 = (unsigned char )myCIL___tmp___77;
            p1 = p + mcnt;
            if ((unsigned int )((enum __anonenum_re_opcode_t_28 )*(p1 + 3)) == 1U) {
              if ((int )*(p1 + 5) != (int )c___0) {
                *(p + -3) = (unsigned char)16;
              } else {
                goto _L___5;
              }
            } else {
              _L___5: /* CIL Label */ 
              if ((unsigned int )((enum __anonenum_re_opcode_t_28 )*(p1 + 3)) == 3U) {
                goto _L___4;
              } else {
                if ((unsigned int )((enum __anonenum_re_opcode_t_28 )*(p1 + 3)) == 4U) {
                  _L___4: /* CIL Label */ 
                  if ((unsigned int )((enum __anonenum_re_opcode_t_28 )*(p1 + 3)) == 4U)
                    not___0 = 1;
                  else
                    not___0 = 0;
                  if ((int )c___0 < (int )((unsigned char )((int )*(p1 + 4) * 8))) {
                    if ((int )*(p1 + (5 + (int )c___0 / 8)) & (1 << (int )c___0 % 8)) {
                      not___0 = ! not___0;
                    }
                  }
                  if (! not___0) {
                    *(p + -3) = (unsigned char)16;
                  }
                }
              }
            }
          }
        }
      }
    }
    p = p - 2;
    if ((unsigned int )((enum __anonenum_re_opcode_t_28 )*(p + -1)) != 16U) {
      *(p + -1) = (unsigned char)12;
      goto unconditional_jump;
    }
    case 16: 
    fail_stack.avail = fail_stack.avail - 1U;
    string_temp = *(fail_stack.stack + fail_stack.avail);
    if ((unsigned long )string_temp != (unsigned long )((void *)0)) {
      sdummy = (char *)string_temp;
    }
    fail_stack.avail = fail_stack.avail - 1U;
    pdummy = (unsigned char *)*(fail_stack.stack + fail_stack.avail);
    fail_stack.avail = fail_stack.avail - 1U;
    dummy_high_reg = (unsigned int )*(fail_stack.stack + fail_stack.avail);
    fail_stack.avail = fail_stack.avail - 1U;
    dummy_low_reg = (unsigned int )*(fail_stack.stack + fail_stack.avail);
    this_reg___2 = (int )dummy_high_reg;
    while ((unsigned int )this_reg___2 >= dummy_low_reg) {
      fail_stack.avail = fail_stack.avail - 1U;
      (reg_info_dummy + this_reg___2)->word = *(fail_stack.stack + fail_stack.avail);
      fail_stack.avail = fail_stack.avail - 1U;
      *(reg_dummy + this_reg___2) = (char *)*(fail_stack.stack + fail_stack.avail);
      fail_stack.avail = fail_stack.avail - 1U;
      *(reg_dummy + this_reg___2) = (char *)*(fail_stack.stack + fail_stack.avail);
      this_reg___2 = this_reg___2 - 1;
    }
    unconditional_jump: 
    case 12: 
    while (1) {
      while (1) {
        mcnt = (int )*p & 255;
        mcnt = mcnt + ((int )((signed char )*(p + 1)) << 8);
        break;
      }
      p = p + 2;
      break;
    }
    p = p + mcnt;
    break;
    case 13: ;
    goto unconditional_jump;
    case 18: ;
    while (1) {
      while (fail_stack.size - fail_stack.avail < ((highest_active_reg - lowest_active_reg) + 1U) * 3U + 4U) {
        if (fail_stack.size > (unsigned int )re_max_failures * ((num_regs - 1U) * 3U + 4U)) {
          myCIL___tmp___80 = 0;
        } else {
          myCIL___tmp___78 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(fail_stack_elt_t ));
          destination___2 = (char *)myCIL___tmp___78;
          memcpy((void *)destination___2, (void *)fail_stack.stack, (unsigned long )fail_stack.size * sizeof(fail_stack_elt_t ));
          fail_stack.stack = (fail_stack_elt_t *)destination___2;
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
            myCIL___tmp___79 = 0;
          } else {
            fail_stack.size = fail_stack.size << 1;
            myCIL___tmp___79 = 1;
          }
          myCIL___tmp___80 = myCIL___tmp___79;
        }
        if (! myCIL___tmp___80) {
          return (-2);
        }
      }
      this_reg___3 = (int )lowest_active_reg;
      while ((unsigned int )this_reg___3 <= highest_active_reg) {
        myCIL___tmp___81 = fail_stack.avail;
        fail_stack.avail = fail_stack.avail + 1U;
        *(fail_stack.stack + myCIL___tmp___81) = (unsigned char *)*(regstart + this_reg___3);
        myCIL___tmp___82 = fail_stack.avail;
        fail_stack.avail = fail_stack.avail + 1U;
        *(fail_stack.stack + myCIL___tmp___82) = (unsigned char *)*(regend + this_reg___3);
        myCIL___tmp___83 = fail_stack.avail;
        fail_stack.avail = fail_stack.avail + 1U;
        *(fail_stack.stack + myCIL___tmp___83) = (reg_info + this_reg___3)->word;
        this_reg___3 = this_reg___3 + 1;
      }
      myCIL___tmp___84 = fail_stack.avail;
      fail_stack.avail = fail_stack.avail + 1U;
      *(fail_stack.stack + myCIL___tmp___84) = (unsigned char *)lowest_active_reg;
      myCIL___tmp___85 = fail_stack.avail;
      fail_stack.avail = fail_stack.avail + 1U;
      *(fail_stack.stack + myCIL___tmp___85) = (unsigned char *)highest_active_reg;
      myCIL___tmp___86 = fail_stack.avail;
      fail_stack.avail = fail_stack.avail + 1U;
      *(fail_stack.stack + myCIL___tmp___86) = (unsigned char *)0;
      myCIL___tmp___87 = fail_stack.avail;
      fail_stack.avail = fail_stack.avail + 1U;
      *(fail_stack.stack + myCIL___tmp___87) = (unsigned char *)0;
      break;
    }
    goto unconditional_jump;
    case 19: ;
    while (1) {
      while (fail_stack.size - fail_stack.avail < ((highest_active_reg - lowest_active_reg) + 1U) * 3U + 4U) {
        if (fail_stack.size > (unsigned int )re_max_failures * ((num_regs - 1U) * 3U + 4U)) {
          myCIL___tmp___90 = 0;
        } else {
          myCIL___tmp___88 = __builtin_alloca((unsigned long )(fail_stack.size << 1) * sizeof(fail_stack_elt_t ));
          destination___3 = (char *)myCIL___tmp___88;
          memcpy((void *)destination___3, (void *)fail_stack.stack, (unsigned long )fail_stack.size * sizeof(fail_stack_elt_t ));
          fail_stack.stack = (fail_stack_elt_t *)destination___3;
          if ((unsigned long )fail_stack.stack == (unsigned long )((void *)0)) {
            myCIL___tmp___89 = 0;
          } else {
            fail_stack.size = fail_stack.size << 1;
            myCIL___tmp___89 = 1;
          }
          myCIL___tmp___90 = myCIL___tmp___89;
        }
        if (! myCIL___tmp___90) {
          return (-2);
        }
      }
      this_reg___4 = (int )lowest_active_reg;
      while ((unsigned int )this_reg___4 <= highest_active_reg) {
        myCIL___tmp___91 = fail_stack.avail;
        fail_stack.avail = fail_stack.avail + 1U;
        *(fail_stack.stack + myCIL___tmp___91) = (unsigned char *)*(regstart + this_reg___4);
        myCIL___tmp___92 = fail_stack.avail;
        fail_stack.avail = fail_stack.avail + 1U;
        *(fail_stack.stack + myCIL___tmp___92) = (unsigned char *)*(regend + this_reg___4);
        myCIL___tmp___93 = fail_stack.avail;
        fail_stack.avail = fail_stack.avail + 1U;
        *(fail_stack.stack + myCIL___tmp___93) = (reg_info + this_reg___4)->word;
        this_reg___4 = this_reg___4 + 1;
      }
      myCIL___tmp___94 = fail_stack.avail;
      fail_stack.avail = fail_stack.avail + 1U;
      *(fail_stack.stack + myCIL___tmp___94) = (unsigned char *)lowest_active_reg;
      myCIL___tmp___95 = fail_stack.avail;
      fail_stack.avail = fail_stack.avail + 1U;
      *(fail_stack.stack + myCIL___tmp___95) = (unsigned char *)highest_active_reg;
      myCIL___tmp___96 = fail_stack.avail;
      fail_stack.avail = fail_stack.avail + 1U;
      *(fail_stack.stack + myCIL___tmp___96) = (unsigned char *)0;
      myCIL___tmp___97 = fail_stack.avail;
      fail_stack.avail = fail_stack.avail + 1U;
      *(fail_stack.stack + myCIL___tmp___97) = (unsigned char *)0;
      break;
    }
    break;
    case 20: 
    while (1) {
      mcnt = (int )*(p + 2) & 255;
      mcnt = mcnt + ((int )((signed char )*((p + 2) + 1)) << 8);
      break;
    }
    if (mcnt > 0) {
      mcnt = mcnt - 1;
      p = p + 2;
      while (1) {
        while (1) {
          *(p + 0) = (unsigned char )(mcnt & 255);
          *(p + 1) = (unsigned char )(mcnt >> 8);
          break;
        }
        p = p + 2;
        break;
      }
    } else {
      if (mcnt == 0) {
        *(p + 2) = (unsigned char)0;
        *(p + 3) = (unsigned char)0;
        goto on_failure;
      }
    }
    break;
    case 21: 
    while (1) {
      mcnt = (int )*(p + 2) & 255;
      mcnt = mcnt + ((int )((signed char )*((p + 2) + 1)) << 8);
      break;
    }
    if (mcnt) {
      mcnt = mcnt - 1;
      while (1) {
        *((p + 2) + 0) = (unsigned char )(mcnt & 255);
        *((p + 2) + 1) = (unsigned char )(mcnt >> 8);
        break;
      }
      goto unconditional_jump;
    } else {
      p = p + 4;
    }
    break;
    case 22: 
    while (1) {
      while (1) {
        mcnt = (int )*p & 255;
        mcnt = mcnt + ((int )((signed char )*(p + 1)) << 8);
        break;
      }
      p = p + 2;
      break;
    }
    p1 = p + mcnt;
    while (1) {
      while (1) {
        mcnt = (int )*p & 255;
        mcnt = mcnt + ((int )((signed char )*(p + 1)) << 8);
        break;
      }
      p = p + 2;
      break;
    }
    while (1) {
      *(p1 + 0) = (unsigned char )(mcnt & 255);
      *(p1 + 1) = (unsigned char )(mcnt >> 8);
      break;
    }
    break;
    case 27: ;
    if (size1) {
      myCIL___tmp___98 = string1;
    } else {
      myCIL___tmp___98 = string2;
    }
    if ((unsigned long )d == (unsigned long )myCIL___tmp___98) {
      break;
    } else {
      if (! size2) {
        break;
      } else {
        if ((unsigned long )d == (unsigned long )end2) {
          break;
        } else {
          if ((unsigned long )(d - 1) == (unsigned long )end1) {
            myCIL___tmp___100 = (int )*string2;
          } else {
            if ((unsigned long )(d - 1) == (unsigned long )(string2 - 1)) {
              myCIL___tmp___99 = (int )*(end1 - 1);
            } else {
              myCIL___tmp___99 = (int )*(d - 1);
            }
            myCIL___tmp___100 = myCIL___tmp___99;
          }
          if ((unsigned long )d == (unsigned long )end1) {
            myCIL___tmp___102 = (int )*string2;
          } else {
            if ((unsigned long )d == (unsigned long )(string2 - 1)) {
              myCIL___tmp___101 = (int )*(end1 - 1);
            } else {
              myCIL___tmp___101 = (int )*d;
            }
            myCIL___tmp___102 = myCIL___tmp___101;
          }
          if (((int )re_syntax_table[myCIL___tmp___100] == 1) != ((int )re_syntax_table[myCIL___tmp___102] == 1)) {
            break;
          }
        }
      }
    }
    goto fail;
    case 28: ;
    if (size1) {
      myCIL___tmp___103 = string1;
    } else {
      myCIL___tmp___103 = string2;
    }
    if ((unsigned long )d == (unsigned long )myCIL___tmp___103) {
      goto fail;
    } else {
      if (! size2) {
        goto fail;
      } else {
        if ((unsigned long )d == (unsigned long )end2) {
          goto fail;
        } else {
          if ((unsigned long )(d - 1) == (unsigned long )end1) {
            myCIL___tmp___105 = (int )*string2;
          } else {
            if ((unsigned long )(d - 1) == (unsigned long )(string2 - 1)) {
              myCIL___tmp___104 = (int )*(end1 - 1);
            } else {
              myCIL___tmp___104 = (int )*(d - 1);
            }
            myCIL___tmp___105 = myCIL___tmp___104;
          }
          if ((unsigned long )d == (unsigned long )end1) {
            myCIL___tmp___107 = (int )*string2;
          } else {
            if ((unsigned long )d == (unsigned long )(string2 - 1)) {
              myCIL___tmp___106 = (int )*(end1 - 1);
            } else {
              myCIL___tmp___106 = (int )*d;
            }
            myCIL___tmp___107 = myCIL___tmp___106;
          }
          if (((int )re_syntax_table[myCIL___tmp___105] == 1) != ((int )re_syntax_table[myCIL___tmp___107] == 1)) {
            goto fail;
          }
        }
      }
    }
    break;
    case 25: ;
    if ((unsigned long )d == (unsigned long )end1) {
      myCIL___tmp___109 = (int )*string2;
    } else {
      if ((unsigned long )d == (unsigned long )(string2 - 1)) {
        myCIL___tmp___108 = (int )*(end1 - 1);
      } else {
        myCIL___tmp___108 = (int )*d;
      }
      myCIL___tmp___109 = myCIL___tmp___108;
    }
    if ((int )re_syntax_table[myCIL___tmp___109] == 1) {
      if (size1) {
        myCIL___tmp___110 = string1;
      } else {
        myCIL___tmp___110 = string2;
      }
      if ((unsigned long )d == (unsigned long )myCIL___tmp___110) {
        break;
      } else {
        if (! size2) {
          break;
        } else {
          if ((unsigned long )(d - 1) == (unsigned long )end1) {
            myCIL___tmp___112 = (int )*string2;
          } else {
            if ((unsigned long )(d - 1) == (unsigned long )(string2 - 1)) {
              myCIL___tmp___111 = (int )*(end1 - 1);
            } else {
              myCIL___tmp___111 = (int )*(d - 1);
            }
            myCIL___tmp___112 = myCIL___tmp___111;
          }
          if (! ((int )re_syntax_table[myCIL___tmp___112] == 1)) {
            break;
          }
        }
      }
    }
    goto fail;
    case 26: ;
    if (size1) {
      myCIL___tmp___113 = string1;
    } else {
      myCIL___tmp___113 = string2;
    }
    if (! ((unsigned long )d == (unsigned long )myCIL___tmp___113)) {
      if (! (! size2)) {
        if ((unsigned long )(d - 1) == (unsigned long )end1) {
          myCIL___tmp___115 = (int )*string2;
        } else {
          if ((unsigned long )(d - 1) == (unsigned long )(string2 - 1)) {
            myCIL___tmp___114 = (int )*(end1 - 1);
          } else {
            myCIL___tmp___114 = (int )*(d - 1);
          }
          myCIL___tmp___115 = myCIL___tmp___114;
        }
        if ((int )re_syntax_table[myCIL___tmp___115] == 1) {
          if ((unsigned long )d == (unsigned long )end1) {
            myCIL___tmp___117 = (int )*string2;
          } else {
            if ((unsigned long )d == (unsigned long )(string2 - 1)) {
              myCIL___tmp___116 = (int )*(end1 - 1);
            } else {
              myCIL___tmp___116 = (int )*d;
            }
            myCIL___tmp___117 = myCIL___tmp___116;
          }
          if ((int )re_syntax_table[myCIL___tmp___117] == 1) {
            if ((unsigned long )d == (unsigned long )end2) {
              break;
            }
          } else {
            break;
          }
        }
      }
    }
    goto fail;
    case 23: ;
    while ((unsigned long )d == (unsigned long )dend) {
      if ((unsigned long )dend == (unsigned long )end_match_2) {
        goto fail;
      }
      d = string2;
      dend = end_match_2;
    }
    if ((unsigned long )d == (unsigned long )end1) {
      myCIL___tmp___119 = (int )*string2;
    } else {
      if ((unsigned long )d == (unsigned long )(string2 - 1)) {
        myCIL___tmp___118 = (int )*(end1 - 1);
      } else {
        myCIL___tmp___118 = (int )*d;
      }
      myCIL___tmp___119 = myCIL___tmp___118;
    }
    if (! ((int )re_syntax_table[myCIL___tmp___119] == 1)) {
      goto fail;
    }
    while (1) {
      r___4 = lowest_active_reg;
      while (r___4 <= highest_active_reg) {
        myCIL___tmp___120 = 1U;
        (reg_info + r___4)->bits.ever_matched_something = myCIL___tmp___120;
        (reg_info + r___4)->bits.matched_something = myCIL___tmp___120;
        r___4 = r___4 + 1U;
      }
      break;
    }
    d = d + 1;
    break;
    case 24: ;
    while ((unsigned long )d == (unsigned long )dend) {
      if ((unsigned long )dend == (unsigned long )end_match_2) {
        goto fail;
      }
      d = string2;
      dend = end_match_2;
    }
    if ((unsigned long )d == (unsigned long )end1) {
      myCIL___tmp___122 = (int )*string2;
    } else {
      if ((unsigned long )d == (unsigned long )(string2 - 1)) {
        myCIL___tmp___121 = (int )*(end1 - 1);
      } else {
        myCIL___tmp___121 = (int )*d;
      }
      myCIL___tmp___122 = myCIL___tmp___121;
    }
    if ((int )re_syntax_table[myCIL___tmp___122] == 1) {
      goto fail;
    }
    while (1) {
      r___5 = lowest_active_reg;
      while (r___5 <= highest_active_reg) {
        myCIL___tmp___123 = 1U;
        (reg_info + r___5)->bits.ever_matched_something = myCIL___tmp___123;
        (reg_info + r___5)->bits.matched_something = myCIL___tmp___123;
        r___5 = r___5 + 1U;
      }
      break;
    }
    d = d + 1;
    break;
    default: 
    abort();
    }
    goto __Cont;
    fail: 
    if (! (fail_stack.avail == 0U)) {
      fail_stack.avail = fail_stack.avail - 1U;
      string_temp___0 = *(fail_stack.stack + fail_stack.avail);
      if ((unsigned long )string_temp___0 != (unsigned long )((void *)0)) {
        d = (char *)string_temp___0;
      }
      fail_stack.avail = fail_stack.avail - 1U;
      p = (unsigned char *)*(fail_stack.stack + fail_stack.avail);
      fail_stack.avail = fail_stack.avail - 1U;
      highest_active_reg = (unsigned int )*(fail_stack.stack + fail_stack.avail);
      fail_stack.avail = fail_stack.avail - 1U;
      lowest_active_reg = (unsigned int )*(fail_stack.stack + fail_stack.avail);
      this_reg___5 = (int )highest_active_reg;
      while ((unsigned int )this_reg___5 >= lowest_active_reg) {
        fail_stack.avail = fail_stack.avail - 1U;
        (reg_info + this_reg___5)->word = *(fail_stack.stack + fail_stack.avail);
        fail_stack.avail = fail_stack.avail - 1U;
        *(regend + this_reg___5) = (char *)*(fail_stack.stack + fail_stack.avail);
        fail_stack.avail = fail_stack.avail - 1U;
        *(regstart + this_reg___5) = (char *)*(fail_stack.stack + fail_stack.avail);
        this_reg___5 = this_reg___5 - 1;
      }
      if (! p) {
        goto fail;
      }
      if ((unsigned long )p < (unsigned long )pend) {
        is_a_jump_n___0 = (boolean )0;
        switch ((int )((enum __anonenum_re_opcode_t_28 )*p)) {
        case 21: 
        is_a_jump_n___0 = (char)1;
        case 17: 
        case 16: 
        case 12: 
        p1 = p + 1;
        while (1) {
          while (1) {
            mcnt = (int )*p1 & 255;
            mcnt = mcnt + ((int )((signed char )*(p1 + 1)) << 8);
            break;
          }
          p1 = p1 + 2;
          break;
        }
        p1 = p1 + mcnt;
        if (is_a_jump_n___0) {
          if ((unsigned int )((enum __anonenum_re_opcode_t_28 )*p1) == 20U) {
            goto fail;
          } else {
            goto _L___7;
          }
        } else {
          _L___7: /* CIL Label */ 
          if (! is_a_jump_n___0) {
            if ((unsigned int )((enum __anonenum_re_opcode_t_28 )*p1) == 14U) {
              goto fail;
            }
          }
        }
        break;
        default: ;
        }
      }
      if ((unsigned long )d >= (unsigned long )string1) {
        if ((unsigned long )d <= (unsigned long )end1) {
          dend = end_match_1;
        }
      }
    } else {
      break;
    }
    __Cont: /* CIL Label */ ;
  }
  if (best_regs_set) {
    goto restore_best_regs;
  }
  __builtin_alloca(0UL);
  return (-1);
}
}
static boolean group_match_null_string_p(unsigned char **p , unsigned char *end , register_info_type *reg_info ) 
{ int mcnt ;
  unsigned char *p1 ;
  boolean myCIL___tmp ;
  boolean myCIL___tmp___0 ;
  boolean myCIL___tmp___1 ;

  {
  p1 = *p + 2;
  while ((unsigned long )p1 < (unsigned long )end) {
    switch ((int )((enum __anonenum_re_opcode_t_28 )*p1)) {
    case 14: 
    p1 = p1 + 1;
    while (1) {
      while (1) {
        mcnt = (int )*p1 & 255;
        mcnt = mcnt + ((int )((signed char )*(p1 + 1)) << 8);
        break;
      }
      p1 = p1 + 2;
      break;
    }
    if (mcnt >= 0) {
      while ((unsigned int )((enum __anonenum_re_opcode_t_28 )*(p1 + (mcnt - 3))) == 13U) {
        myCIL___tmp = alt_match_null_string_p(p1, (p1 + mcnt) - 3, reg_info);
        if (! myCIL___tmp) {
          return ((char)0);
        }
        p1 = p1 + mcnt;
        if ((unsigned int )((enum __anonenum_re_opcode_t_28 )*p1) != 14U) {
          break;
        }
        p1 = p1 + 1;
        while (1) {
          while (1) {
            mcnt = (int )*p1 & 255;
            mcnt = mcnt + ((int )((signed char )*(p1 + 1)) << 8);
            break;
          }
          p1 = p1 + 2;
          break;
        }
        if ((unsigned int )((enum __anonenum_re_opcode_t_28 )*(p1 + (mcnt - 3))) != 13U) {
          p1 = p1 - 3;
          break;
        }
      }
      while (1) {
        mcnt = (int )*(p1 - 2) & 255;
        mcnt = mcnt + ((int )((signed char )*((p1 - 2) + 1)) << 8);
        break;
      }
      myCIL___tmp___0 = alt_match_null_string_p(p1, p1 + mcnt, reg_info);
      if (! myCIL___tmp___0) {
        return ((char)0);
      }
      p1 = p1 + mcnt;
    }
    break;
    case 6: 
    *p = p1 + 2;
    return ((char)1);
    default: 
    myCIL___tmp___1 = common_op_match_null_string_p(& p1, end, reg_info);
    if (! myCIL___tmp___1) {
      return ((char)0);
    }
    }
  }
  return ((char)0);
}
}
static boolean alt_match_null_string_p(unsigned char *p , unsigned char *end , register_info_type *reg_info ) 
{ int mcnt ;
  unsigned char *p1 ;
  boolean myCIL___tmp ;

  {
  p1 = p;
  while ((unsigned long )p1 < (unsigned long )end) {
    switch ((int )((enum __anonenum_re_opcode_t_28 )*p1)) {
    case 14: 
    p1 = p1 + 1;
    while (1) {
      while (1) {
        mcnt = (int )*p1 & 255;
        mcnt = mcnt + ((int )((signed char )*(p1 + 1)) << 8);
        break;
      }
      p1 = p1 + 2;
      break;
    }
    p1 = p1 + mcnt;
    break;
    default: 
    myCIL___tmp = common_op_match_null_string_p(& p1, end, reg_info);
    if (! myCIL___tmp) {
      return ((char)0);
    }
    }
  }
  return ((char)1);
}
}
static boolean common_op_match_null_string_p(unsigned char **p , unsigned char *end , register_info_type *reg_info ) 
{ int mcnt ;
  boolean ret ;
  int reg_no ;
  unsigned char *p1 ;
  unsigned char *myCIL___tmp ;

  {
  p1 = *p;
  myCIL___tmp = p1;
  p1 = p1 + 1;
  switch ((int )((enum __anonenum_re_opcode_t_28 )*myCIL___tmp)) {
  case 0: 
  case 8: 
  case 9: 
  case 10: 
  case 11: 
  case 25: 
  case 26: 
  case 27: 
  case 28: 
  break;
  case 5: 
  reg_no = (int )*p1;
  ret = group_match_null_string_p(& p1, end, reg_info);
  if ((reg_info + reg_no)->bits.match_null_string_p == 3U) {
    (reg_info + reg_no)->bits.match_null_string_p = (unsigned int )ret;
  }
  if (! ret) {
    return ((char)0);
  }
  break;
  case 12: 
  while (1) {
    while (1) {
      mcnt = (int )*p1 & 255;
      mcnt = mcnt + ((int )((signed char )*(p1 + 1)) << 8);
      break;
    }
    p1 = p1 + 2;
    break;
  }
  if (mcnt >= 0) {
    p1 = p1 + mcnt;
  } else {
    return ((char)0);
  }
  break;
  case 20: 
  p1 = p1 + 2;
  while (1) {
    while (1) {
      mcnt = (int )*p1 & 255;
      mcnt = mcnt + ((int )((signed char )*(p1 + 1)) << 8);
      break;
    }
    p1 = p1 + 2;
    break;
  }
  if (mcnt == 0) {
    p1 = p1 - 4;
    while (1) {
      while (1) {
        mcnt = (int )*p1 & 255;
        mcnt = mcnt + ((int )((signed char )*(p1 + 1)) << 8);
        break;
      }
      p1 = p1 + 2;
      break;
    }
    p1 = p1 + mcnt;
  } else {
    return ((char)0);
  }
  break;
  case 7: 
  if (! (reg_info + *p1)->bits.match_null_string_p) {
    return ((char)0);
  }
  break;
  case 22: 
  p1 = p1 + 4;
  default: ;
  return ((char)0);
  }
  *p = p1;
  return ((char)1);
}
}
static int bcmp_translate(unsigned char *s1 , unsigned char *s2 , int len , char *translate ) 
{ register unsigned char *p1 ;
  register unsigned char *p2 ;
  unsigned char *myCIL___tmp ;
  unsigned char *myCIL___tmp___0 ;

  {
  p1 = s1;
  p2 = s2;
  while (len) {
    myCIL___tmp = p1;
    p1 = p1 + 1;
    myCIL___tmp___0 = p2;
    p2 = p2 + 1;
    if ((int )*(translate + *myCIL___tmp) != (int )*(translate + *myCIL___tmp___0)) {
      return (1);
    }
    len = len - 1;
  }
  return (0);
}
}
char *re_compile_pattern(char *pattern , int length , struct re_pattern_buffer *bufp ) 
{ reg_errcode_t ret ;

  {
  bufp->regs_allocated = 0U;
  bufp->no_sub = 0U;
  bufp->newline_anchor = 1U;
  ret = regex_compile(pattern, length, re_syntax_options, bufp);
  return (re_error_msg[(int )ret]);
}
}
int regcomp(regex_t *preg , char *pattern , int cflags ) 
{ reg_errcode_t ret ;
  unsigned int syntax ;
  int myCIL___tmp ;
  unsigned int i ;
  void *myCIL___tmp___0 ;
  int myCIL___tmp___2 ;
  unsigned short **myCIL___tmp___3 ;
  size_t myCIL___tmp___4 ;

  {
  if (cflags & 1) {
    myCIL___tmp = (((((((((((1 << 1) << 1) | ((((((1 << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1 << 1) << 1) << 1)) | ((((1 << 1) << 1) << 1) << 1)) | ((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  } else {
    myCIL___tmp = ((((((1 << 1) << 1) | ((((((1 << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1 << 1);
  }
  syntax = (unsigned int )myCIL___tmp;
  preg->buffer = (unsigned char *)0;
  preg->allocated = 0UL;
  preg->used = 0UL;
  preg->fastmap = (char *)0;
  if (cflags & (1 << 1)) {
    myCIL___tmp___0 = malloc(256UL);
    preg->translate = (char *)myCIL___tmp___0;
    if ((unsigned long )preg->translate == (unsigned long )((void *)0)) {
      return (12);
    }
    i = 0U;
    while (i < 256U) {
      myCIL___tmp___3 = __ctype_b_loc();
      if ((int )*(*myCIL___tmp___3 + (int )i) & 256) {
        myCIL___tmp___2 = tolower((int )i);
        *(preg->translate + i) = (char )myCIL___tmp___2;
      } else {
        *(preg->translate + i) = (char )i;
      }
      i = i + 1U;
    }
  } else {
    preg->translate = (char *)((void *)0);
  }
  if (cflags & ((1 << 1) << 1)) {
    syntax = syntax & (unsigned int )(~ ((((((1 << 1) << 1) << 1) << 1) << 1) << 1));
    syntax = syntax | (unsigned int )((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
    preg->newline_anchor = 1U;
  } else {
    preg->newline_anchor = 0U;
  }
  preg->no_sub = (unsigned int )(! (! (cflags & (((1 << 1) << 1) << 1))));
  myCIL___tmp___4 = strlen(pattern);
  ret = regex_compile(pattern, (int )myCIL___tmp___4, syntax, preg);
  if ((unsigned int )ret == 16U) {
    ret = (enum __anonenum_reg_errcode_t_25 )8;
  }
  return ((int )ret);
}
}
int regexec(regex_t *preg , char *string , size_t nmatch , regmatch_t *pmatch , int eflags ) 
{ int ret ;
  struct re_registers regs ;
  regex_t private_preg ;
  int len ;
  size_t myCIL___tmp ;
  boolean want_reg_info ;
  int myCIL___tmp___0 ;
  void *myCIL___tmp___1 ;
  void *myCIL___tmp___2 ;
  struct re_registers *myCIL___tmp___3 ;
  unsigned int r ;
  int myCIL___tmp___4 ;

  {
  myCIL___tmp = strlen(string);
  len = (int )myCIL___tmp;
  if (! preg->no_sub) {
    if (nmatch > 0UL) {
      myCIL___tmp___0 = 1;
    } else {
      myCIL___tmp___0 = 0;
    }
  } else {
    myCIL___tmp___0 = 0;
  }
  want_reg_info = (boolean )myCIL___tmp___0;
  private_preg = (struct re_pattern_buffer )*preg;
  private_preg.not_bol = (unsigned int )(! (! (eflags & 1)));
  private_preg.not_eol = (unsigned int )(! (! (eflags & (1 << 1))));
  private_preg.regs_allocated = 2U;
  if (want_reg_info) {
    regs.num_regs = (unsigned int )nmatch;
    myCIL___tmp___1 = malloc(nmatch * sizeof(regoff_t ));
    regs.start = (regoff_t *)myCIL___tmp___1;
    myCIL___tmp___2 = malloc(nmatch * sizeof(regoff_t ));
    regs.end = (regoff_t *)myCIL___tmp___2;
    if ((unsigned long )regs.start == (unsigned long )((void *)0)) {
      return (1);
    } else {
      if ((unsigned long )regs.end == (unsigned long )((void *)0)) {
        return (1);
      }
    }
  }
  if (want_reg_info) {
    myCIL___tmp___3 = & regs;
  } else {
    myCIL___tmp___3 = (struct re_registers *)0;
  }
  ret = re_search(& private_preg, string, len, 0, len, myCIL___tmp___3);
  if (want_reg_info) {
    if (ret >= 0) {
      r = 0U;
      while ((size_t )r < nmatch) {
        (pmatch + r)->rm_so = *(regs.start + r);
        (pmatch + r)->rm_eo = *(regs.end + r);
        r = r + 1U;
      }
    }
  }
  if (ret >= 0) {
    myCIL___tmp___4 = 0;
  } else {
    myCIL___tmp___4 = 1;
  }
  return (myCIL___tmp___4);
}
}
size_t regerror(int errcode , regex_t *preg , char *errbuf , size_t errbuf_size ) 
{ char *msg ;
  size_t msg_size ;
  size_t myCIL___tmp ;

  {
  if (errcode < 0) {
    abort();
  } else {
    if ((unsigned long )errcode >= sizeof(re_error_msg) / sizeof(re_error_msg[0])) {
      abort();
    }
  }
  msg = re_error_msg[errcode];
  if (! msg) {
    msg = "Success";
  }
  myCIL___tmp = strlen(msg);
  msg_size = myCIL___tmp + 1UL;
  if (errbuf_size != 0UL) {
    if (msg_size > errbuf_size) {
      strncpy((char *)errbuf, (char *)msg, errbuf_size - 1UL);
      *(errbuf + (errbuf_size - 1UL)) = (char)0;
    } else {
      strcpy((char *)errbuf, (char *)msg);
    }
  }
  return (msg_size);
}
}
void regfree(regex_t *preg ) 
{ 

  {
  if ((unsigned long )preg->buffer != (unsigned long )((void *)0)) {
  }
  preg->buffer = (unsigned char *)((void *)0);
  preg->allocated = 0UL;
  preg->used = 0UL;
  if ((unsigned long )preg->fastmap != (unsigned long )((void *)0)) {
  }
  preg->fastmap = (char *)((void *)0);
  preg->fastmap_accurate = 0U;
  if ((unsigned long )preg->translate != (unsigned long )((void *)0)) {
  }
  preg->translate = (char *)((void *)0);
  return;
}
}
void dfasyntax(int bits , int fold ) ;
void dfacomp(char *s , size_t len , struct dfa *d , int searchflag ) ;
char *dfaexec(struct dfa *d , char *begin , char *end , int newline___0 , int *count , int *backref ) ;
void dfafree(struct dfa *d ) ;
void dfainit(struct dfa *d ) ;
void dfaparse(char *s , size_t len , struct dfa *d ) ;
void dfaanalyze(struct dfa *d , int searchflag ) ;
void dfastate(int s , struct dfa *d , int *trans ) ;
void dfaerror(char *mesg ) ;
static void dfamust(struct dfa *dfa___0 ) ;
static ptr_t xcalloc(int n , size_t s ) 
{ ptr_t r ;
  void *myCIL___tmp ;

  {
  myCIL___tmp = calloc((unsigned long )n, s);
  r = myCIL___tmp;
  if (! r) {
    dfaerror((char *)"Memory exhausted");
  }
  return (r);
}
}
static ptr_t xmalloc_1(size_t n ) 
{ ptr_t r ;
  void *myCIL___tmp ;

  {
  myCIL___tmp = malloc(n);
  r = myCIL___tmp;
  if (! r) {
    dfaerror((char *)"Memory exhausted");
  }
  return (r);
}
}
static ptr_t xrealloc_1(ptr_t p , size_t n ) 
{ ptr_t r ;
  void *myCIL___tmp ;

  {
  myCIL___tmp = realloc(p, n);
  r = myCIL___tmp;
  if (! r) {
    dfaerror((char *)"Memory exhausted");
  }
  return (r);
}
}
static int tstbit(int b , int *c ) 
{ 

  {
  return (*(c + (unsigned long )b / (8UL * sizeof(int ))) & (1 << (unsigned long )b % (8UL * sizeof(int ))));
}
}
static void setbit(int b , int *c ) 
{ 

  {
  *(c + (unsigned long )b / (8UL * sizeof(int ))) = *(c + (unsigned long )b / (8UL * sizeof(int ))) | (1 << (unsigned long )b % (8UL * sizeof(int )));
  return;
}
}
static void clrbit(int b , int *c ) 
{ 

  {
  *(c + (unsigned long )b / (8UL * sizeof(int ))) = *(c + (unsigned long )b / (8UL * sizeof(int ))) & ~ (1 << (unsigned long )b % (8UL * sizeof(int )));
  return;
}
}
static void copyset(int *src , int *dst ) 
{ int i ;

  {
  i = 0;
  while ((unsigned long )i < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
    *(dst + i) = *(src + i);
    i = i + 1;
  }
  return;
}
}
static void zeroset(int *s ) 
{ int i ;

  {
  i = 0;
  while ((unsigned long )i < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
    *(s + i) = 0;
    i = i + 1;
  }
  return;
}
}
static void notset(int *s ) 
{ int i ;

  {
  i = 0;
  while ((unsigned long )i < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
    *(s + i) = ~ *(s + i);
    i = i + 1;
  }
  return;
}
}
static int equal(int *s1 , int *s2 ) 
{ int i ;

  {
  i = 0;
  while ((unsigned long )i < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
    if (*(s1 + i) != *(s2 + i)) {
      return (0);
    }
    i = i + 1;
  }
  return (1);
}
}
static struct dfa *dfa  ;
static int charclass_index(int *s ) 
{ int i ;
  int myCIL___tmp ;
  ptr_t myCIL___tmp___0 ;

  {
  i = 0;
  while (i < dfa->cindex) {
    myCIL___tmp = equal(s, *(dfa->charclasses + i));
    if (myCIL___tmp) {
      return (i);
    }
    i = i + 1;
  }
  if (dfa->cindex >= dfa->calloc) {
    while (dfa->cindex >= dfa->calloc) {
      dfa->calloc = dfa->calloc * 2;
    }
    myCIL___tmp___0 = xrealloc_1((void *)dfa->charclasses, (unsigned long )dfa->calloc * sizeof(charclass ));
    dfa->charclasses = (charclass *)myCIL___tmp___0;
  }
  dfa->cindex = dfa->cindex + 1;
  copyset(s, *(dfa->charclasses + i));
  return (i);
}
}
static int syntax_bits  ;
static int syntax_bits_set  ;
static int case_fold  ;
void dfasyntax(int bits , int fold ) 
{ 

  {
  syntax_bits_set = 1;
  syntax_bits = bits;
  case_fold = fold;
  return;
}
}
static char *lexstart  ;
static char *lexptr  ;
static int lexleft  ;
static token lasttok  ;
static int laststart  ;
static int parens  ;
static int minrep  ;
static int maxrep  ;
static int is_alpha(int c ) 
{ unsigned short **myCIL___tmp ;

  {
  myCIL___tmp = __ctype_b_loc();
  return (((int )*(*myCIL___tmp + c) & 1024) != (int )0);
}
}
static int is_upper(int c ) 
{ unsigned short **myCIL___tmp ;

  {
  myCIL___tmp = __ctype_b_loc();
  return (((int )*(*myCIL___tmp + c) & 256) != (int )0);
}
}
static int is_lower(int c ) 
{ unsigned short **myCIL___tmp ;

  {
  myCIL___tmp = __ctype_b_loc();
  return (((int )*(*myCIL___tmp + c) & 512) != (int )0);
}
}
static int is_digit(int c ) 
{ unsigned short **myCIL___tmp ;

  {
  myCIL___tmp = __ctype_b_loc();
  return (((int )*(*myCIL___tmp + c) & 2048) != (int )0);
}
}
static int is_xdigit(int c ) 
{ unsigned short **myCIL___tmp ;

  {
  myCIL___tmp = __ctype_b_loc();
  return (((int )*(*myCIL___tmp + c) & 4096) != (int )0);
}
}
static int is_space(int c ) 
{ unsigned short **myCIL___tmp ;

  {
  myCIL___tmp = __ctype_b_loc();
  return (((int )*(*myCIL___tmp + c) & 8192) != (int )0);
}
}
static int is_punct(int c ) 
{ unsigned short **myCIL___tmp ;

  {
  myCIL___tmp = __ctype_b_loc();
  return (((int )*(*myCIL___tmp + c) & 4) != (int )0);
}
}
static int is_alnum(int c ) 
{ unsigned short **myCIL___tmp ;

  {
  myCIL___tmp = __ctype_b_loc();
  return (((int )*(*myCIL___tmp + c) & 8) != (int )0);
}
}
static int is_print(int c ) 
{ unsigned short **myCIL___tmp ;

  {
  myCIL___tmp = __ctype_b_loc();
  return (((int )*(*myCIL___tmp + c) & 16384) != (int )0);
}
}
static int is_graph(int c ) 
{ unsigned short **myCIL___tmp ;

  {
  myCIL___tmp = __ctype_b_loc();
  return (((int )*(*myCIL___tmp + c) & 32768) != (int )0);
}
}
static int is_cntrl(int c ) 
{ unsigned short **myCIL___tmp ;

  {
  myCIL___tmp = __ctype_b_loc();
  return (((int )*(*myCIL___tmp + c) & 2) != (int )0);
}
}
static struct __anonstruct_prednames_38 prednames[12]  ; //= 
//  {      {(char *)":alpha:]", (int (*)())(& is_alpha)}, 
//        {(char *)":upper:]", (int (*)())(& is_upper)}, 
//        {(char *)":lower:]", (int (*)())(& is_lower)}, 
//        {(char *)":digit:]", (int (*)())(& is_digit)}, 
//        {(char *)":xdigit:]", (int (*)())(& is_xdigit)}, 
//        {(char *)":space:]", (int (*)())(& is_space)}, 
//        {(char *)":punct:]", (int (*)())(& is_punct)}, 
//        {(char *)":alnum:]", (int (*)())(& is_alnum)}, 
//        {(char *)":print:]", (int (*)())(& is_print)}, 
//        {(char *)":graph:]", (int (*)())(& is_graph)}, 
//        {(char *)":cntrl:]", (int (*)())(& is_cntrl)}, 
//        {(char *)0, (int (*)())0}};
static int looking_at(char *s ) 
{ int len ;
  size_t myCIL___tmp ;
  int myCIL___tmp___0 ;

  {
  myCIL___tmp = strlen((char *)s);
  len = (int )myCIL___tmp;
  if (lexleft < len) {
    return (0);
  }
  myCIL___tmp___0 = strncmp((char *)s, (char *)lexptr, (unsigned long )len);
  return (myCIL___tmp___0 == 0);
}
}
static token lex(void) 
{ token c ;
  token c1 ;
  token c2 ;
  int backslash ;
  int invert ;
  charclass ccl ;
  int i ;
  char *myCIL___tmp ;
  int myCIL___tmp___0 ;
  int myCIL___tmp___1 ;
  int myCIL___tmp___2 ;
  int myCIL___tmp___3 ;
  int myCIL___tmp___4 ;
  int myCIL___tmp___5 ;
  char *myCIL___tmp___6 ;
  char *myCIL___tmp___7 ;
  unsigned short **myCIL___tmp___8 ;
  unsigned short **myCIL___tmp___9 ;
  char *myCIL___tmp___10 ;
  unsigned short **myCIL___tmp___11 ;
  char *myCIL___tmp___12 ;
  int myCIL___tmp___13 ;
  unsigned short **myCIL___tmp___14 ;
  int myCIL___tmp___15 ;
  char *myCIL___tmp___16 ;
  char *myCIL___tmp___17 ;
  int myCIL___tmp___18 ;
  size_t myCIL___tmp___19 ;
  size_t myCIL___tmp___20 ;
  char *myCIL___tmp___21 ;
  int myCIL___tmp___22 ;
  char *myCIL___tmp___23 ;
  char *myCIL___tmp___24 ;
  char *myCIL___tmp___25 ;
  char *myCIL___tmp___26 ;
  char *myCIL___tmp___27 ;
  int myCIL___tmp___28 ;
  int myCIL___tmp___29 ;
  unsigned short **myCIL___tmp___30 ;
  unsigned short **myCIL___tmp___31 ;
  int myCIL___tmp___32 ;
  int myCIL___tmp___33 ;
  int myCIL___tmp___34 ;
  unsigned short **myCIL___tmp___35 ;
  int myCIL___tmp___36 ;
  unsigned short **myCIL___tmp___37 ;

  {
  backslash = 0;
  i = 0;
  while (i < 2) {
    if (! lexleft) {
      return ((enum __anonenum_token_34 )-1);
    }
    myCIL___tmp = lexptr;
    lexptr = lexptr + 1;
    c = (enum __anonenum_token_34 )((unsigned char )*myCIL___tmp);
    lexleft = lexleft - 1;
    switch ((int )c) {
    case 92: 
    if (backslash) {
      goto normal_char;
    }
    if (lexleft == 0) {
      dfaerror((char *)"Unfinished \\ escape");
    }
    backslash = 1;
    break;
    case 94: 
    if (backslash) {
      goto normal_char;
    }
    if (syntax_bits & (((1 << 1) << 1) << 1)) {
      lasttok = (enum __anonenum_token_34 )258;
      return (lasttok);
    } else {
      if ((int )lasttok == -1) {
        lasttok = (enum __anonenum_token_34 )258;
        return (lasttok);
      } else {
        if ((int )lasttok == 271) {
          lasttok = (enum __anonenum_token_34 )258;
          return (lasttok);
        } else {
          if ((int )lasttok == 269) {
            lasttok = (enum __anonenum_token_34 )258;
            return (lasttok);
          }
        }
      }
    }
    goto normal_char;
    case 36: 
    if (backslash) {
      goto normal_char;
    }
    if (syntax_bits & (((1 << 1) << 1) << 1)) {
      lasttok = (enum __anonenum_token_34 )259;
      return (lasttok);
    } else {
      if (lexleft == 0) {
        lasttok = (enum __anonenum_token_34 )259;
        return (lasttok);
      } else {
        if (syntax_bits & (((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
          if (lexleft > 0) {
            if ((int )*lexptr == 41) {
              myCIL___tmp___0 = 1;
            } else {
              myCIL___tmp___0 = 0;
            }
          } else {
            myCIL___tmp___0 = 0;
          }
          myCIL___tmp___2 = myCIL___tmp___0;
        } else {
          if (lexleft > 1) {
            if ((int )*(lexptr + 0) == 92) {
              if ((int )*(lexptr + 1) == 41) {
                myCIL___tmp___1 = 1;
              } else {
                myCIL___tmp___1 = 0;
              }
            } else {
              myCIL___tmp___1 = 0;
            }
          } else {
            myCIL___tmp___1 = 0;
          }
          myCIL___tmp___2 = myCIL___tmp___1;
        }
        if (myCIL___tmp___2) {
          lasttok = (enum __anonenum_token_34 )259;
          return (lasttok);
        } else {
          if (syntax_bits & (((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
            if (lexleft > 0) {
              if ((int )*lexptr == 124) {
                myCIL___tmp___3 = 1;
              } else {
                myCIL___tmp___3 = 0;
              }
            } else {
              myCIL___tmp___3 = 0;
            }
            myCIL___tmp___5 = myCIL___tmp___3;
          } else {
            if (lexleft > 1) {
              if ((int )*(lexptr + 0) == 92) {
                if ((int )*(lexptr + 1) == 124) {
                  myCIL___tmp___4 = 1;
                } else {
                  myCIL___tmp___4 = 0;
                }
              } else {
                myCIL___tmp___4 = 0;
              }
            } else {
              myCIL___tmp___4 = 0;
            }
            myCIL___tmp___5 = myCIL___tmp___4;
          }
          if (myCIL___tmp___5) {
            lasttok = (enum __anonenum_token_34 )259;
            return (lasttok);
          } else {
            if (syntax_bits & (((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
              if (lexleft > 0) {
                if ((int )*lexptr == 10) {
                  lasttok = (enum __anonenum_token_34 )259;
                  return (lasttok);
                }
              }
            }
          }
        }
      }
    }
    goto normal_char;
    case 49: 
    case 50: 
    case 51: 
    case 52: 
    case 53: 
    case 54: 
    case 55: 
    case 56: 
    case 57: 
    if (backslash) {
      if (! (syntax_bits & ((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
        laststart = 0;
        lasttok = (enum __anonenum_token_34 )257;
        return (lasttok);
      }
    }
    goto normal_char;
    case 60: 
    if (backslash) {
      lasttok = (enum __anonenum_token_34 )260;
      return (lasttok);
    }
    goto normal_char;
    case 62: 
    if (backslash) {
      lasttok = (enum __anonenum_token_34 )261;
      return (lasttok);
    }
    goto normal_char;
    case 98: 
    if (backslash) {
      lasttok = (enum __anonenum_token_34 )262;
      return (lasttok);
    }
    goto normal_char;
    case 66: 
    if (backslash) {
      lasttok = (enum __anonenum_token_34 )263;
      return (lasttok);
    }
    goto normal_char;
    case 63: 
    if (syntax_bits & ((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    }
    if (backslash != ((syntax_bits & (1 << 1)) != 0)) {
      goto normal_char;
    }
    if (! (syntax_bits & ((((1 << 1) << 1) << 1) << 1))) {
      if (laststart) {
        goto normal_char;
      }
    }
    lasttok = (enum __anonenum_token_34 )264;
    return (lasttok);
    case 42: 
    if (backslash) {
      goto normal_char;
    }
    if (! (syntax_bits & ((((1 << 1) << 1) << 1) << 1))) {
      if (laststart) {
        goto normal_char;
      }
    }
    lasttok = (enum __anonenum_token_34 )265;
    return (lasttok);
    case 43: 
    if (syntax_bits & ((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    }
    if (backslash != ((syntax_bits & (1 << 1)) != 0)) {
      goto normal_char;
    }
    if (! (syntax_bits & ((((1 << 1) << 1) << 1) << 1))) {
      if (laststart) {
        goto normal_char;
      }
    }
    lasttok = (enum __anonenum_token_34 )266;
    return (lasttok);
    case 123: 
    if (! (syntax_bits & (((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      goto normal_char;
    }
    if (backslash != ((syntax_bits & ((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0)) {
      goto normal_char;
    }
    maxrep = 0;
    minrep = maxrep;
    if (! lexleft) {
      if ((unsigned long )"unfinished repeat count" != (unsigned long )((char *)0)) {
        dfaerror((char *)"unfinished repeat count");
      } else {
        return ((enum __anonenum_token_34 )-1);
      }
    }
    myCIL___tmp___6 = lexptr;
    lexptr = lexptr + 1;
    c = (enum __anonenum_token_34 )((unsigned char )*myCIL___tmp___6);
    lexleft = lexleft - 1;
    myCIL___tmp___9 = __ctype_b_loc();
    if ((int )*(*myCIL___tmp___9 + (int )c) & 2048) {
      minrep = (int )c - 48;
      while (1) {
        if (! lexleft) {
          if ((unsigned long )"unfinished repeat count" != (unsigned long )((char *)0)) {
            dfaerror((char *)"unfinished repeat count");
          } else {
            return ((enum __anonenum_token_34 )-1);
          }
        }
        myCIL___tmp___7 = lexptr;
        lexptr = lexptr + 1;
        c = (enum __anonenum_token_34 )((unsigned char )*myCIL___tmp___7);
        lexleft = lexleft - 1;
        myCIL___tmp___8 = __ctype_b_loc();
        if (! ((int )*(*myCIL___tmp___8 + (int )c) & 2048)) {
          break;
        }
        minrep = (10 * minrep + (int )c) - 48;
      }
    } else {
      if ((int )c != 44) {
        dfaerror((char *)"malformed repeat count");
      }
    }
    if ((int )c == 44) {
      while (1) {
        if (! lexleft) {
          if ((unsigned long )"unfinished repeat count" != (unsigned long )((char *)0)) {
            dfaerror((char *)"unfinished repeat count");
          } else {
            return ((enum __anonenum_token_34 )-1);
          }
        }
        myCIL___tmp___10 = lexptr;
        lexptr = lexptr + 1;
        c = (enum __anonenum_token_34 )((unsigned char )*myCIL___tmp___10);
        lexleft = lexleft - 1;
        myCIL___tmp___11 = __ctype_b_loc();
        if (! ((int )*(*myCIL___tmp___11 + (int )c) & 2048)) {
          break;
        }
        maxrep = (10 * maxrep + (int )c) - 48;
      }
    } else {
      maxrep = minrep;
    }
    if (! (syntax_bits & ((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
      if ((int )c != 92) {
        dfaerror((char *)"malformed repeat count");
      }
      if (! lexleft) {
        if ((unsigned long )"unfinished repeat count" != (unsigned long )((char *)0)) {
          dfaerror((char *)"unfinished repeat count");
        } else {
          return ((enum __anonenum_token_34 )-1);
        }
      }
      myCIL___tmp___12 = lexptr;
      lexptr = lexptr + 1;
      c = (enum __anonenum_token_34 )((unsigned char )*myCIL___tmp___12);
      lexleft = lexleft - 1;
    }
    if ((int )c != 125) {
      dfaerror((char *)"malformed repeat count");
    }
    laststart = 0;
    lasttok = (enum __anonenum_token_34 )267;
    return (lasttok);
    case 124: 
    if (syntax_bits & ((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    }
    if (backslash != ((syntax_bits & (((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0)) {
      goto normal_char;
    }
    laststart = 1;
    lasttok = (enum __anonenum_token_34 )269;
    return (lasttok);
    case 10: 
    if (syntax_bits & ((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      goto normal_char;
    } else {
      if (backslash) {
        goto normal_char;
      } else {
        if (! (syntax_bits & (((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
          goto normal_char;
        }
      }
    }
    laststart = 1;
    lasttok = (enum __anonenum_token_34 )269;
    return (lasttok);
    case 40: 
    if (backslash != ((syntax_bits & (((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0)) {
      goto normal_char;
    }
    parens = parens + 1;
    laststart = 1;
    lasttok = (enum __anonenum_token_34 )271;
    return (lasttok);
    case 41: 
    if (backslash != ((syntax_bits & (((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) == 0)) {
      goto normal_char;
    }
    if (parens == 0) {
      if (syntax_bits & (((((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        goto normal_char;
      }
    }
    parens = parens - 1;
    laststart = 0;
    lasttok = (enum __anonenum_token_34 )272;
    return (lasttok);
    case 46: 
    if (backslash) {
      goto normal_char;
    }
    zeroset(ccl);
    notset(ccl);
    if (! (syntax_bits & ((((((1 << 1) << 1) << 1) << 1) << 1) << 1))) {
      clrbit('\n', ccl);
    }
    if (syntax_bits & (((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
      clrbit('\000', ccl);
    }
    laststart = 0;
    myCIL___tmp___13 = charclass_index(ccl);
    lasttok = (enum __anonenum_token_34 )(273 + myCIL___tmp___13);
    return (lasttok);
    case 119: 
    case 87: 
    if (! backslash) {
      goto normal_char;
    }
    zeroset(ccl);
    c2 = (enum __anonenum_token_34 )0;
    while ((int )c2 < 1 << 8) {
      myCIL___tmp___14 = __ctype_b_loc();
      if ((int )*(*myCIL___tmp___14 + (int )c2) & 8) {
        setbit((int )c2, ccl);
      }
      c2 = (token )((int )c2 + 1);
    }
    if ((int )c == 87) {
      notset(ccl);
    }
    laststart = 0;
    myCIL___tmp___15 = charclass_index(ccl);
    lasttok = (enum __anonenum_token_34 )(273 + myCIL___tmp___15);
    return (lasttok);
    case 91: 
    if (backslash) {
      goto normal_char;
    }
    zeroset(ccl);
    if (! lexleft) {
      if ((unsigned long )"Unbalanced [" != (unsigned long )((char *)0)) {
        dfaerror((char *)"Unbalanced [");
      } else {
        return ((enum __anonenum_token_34 )-1);
      }
    }
    myCIL___tmp___16 = lexptr;
    lexptr = lexptr + 1;
    c = (enum __anonenum_token_34 )((unsigned char )*myCIL___tmp___16);
    lexleft = lexleft - 1;
    if ((int )c == 94) {
      if (! lexleft) {
        if ((unsigned long )"Unbalanced [" != (unsigned long )((char *)0)) {
          dfaerror((char *)"Unbalanced [");
        } else {
          return ((enum __anonenum_token_34 )-1);
        }
      }
      myCIL___tmp___17 = lexptr;
      lexptr = lexptr + 1;
      c = (enum __anonenum_token_34 )((unsigned char )*myCIL___tmp___17);
      lexleft = lexleft - 1;
      invert = 1;
    } else {
      invert = 0;
    }
    while (1) {
      if ((int )c == 91) {
        if (syntax_bits & ((1 << 1) << 1)) {
          c1 = (enum __anonenum_token_34 )0;
          while (prednames[c1].name) {
            myCIL___tmp___22 = looking_at(prednames[c1].name);
            if (myCIL___tmp___22) {
              c2 = (enum __anonenum_token_34 )0;
              while ((int )c2 < 1 << 8) {
                myCIL___tmp___18 = (*(prednames[c1].pred))(c2);
                if (myCIL___tmp___18) {
                  setbit((int )c2, ccl);
                }
                c2 = (token )((int )c2 + 1);
              }
              myCIL___tmp___19 = strlen((char *)prednames[c1].name);
              lexptr = lexptr + myCIL___tmp___19;
              myCIL___tmp___20 = strlen((char *)prednames[c1].name);
              lexleft = (int )((size_t )lexleft - myCIL___tmp___20);
              if (! lexleft) {
                if ((unsigned long )"Unbalanced [" != (unsigned long )((char *)0)) {
                  dfaerror((char *)"Unbalanced [");
                } else {
                  return ((enum __anonenum_token_34 )-1);
                }
              }
              myCIL___tmp___21 = lexptr;
              lexptr = lexptr + 1;
              c1 = (enum __anonenum_token_34 )((unsigned char )*myCIL___tmp___21);
              lexleft = lexleft - 1;
              goto skip;
            }
            c1 = (token )((int )c1 + 1);
          }
        }
      }
      if ((int )c == 92) {
        if (syntax_bits & 1) {
          if (! lexleft) {
            if ((unsigned long )"Unbalanced [" != (unsigned long )((char *)0)) {
              dfaerror((char *)"Unbalanced [");
            } else {
              return ((enum __anonenum_token_34 )-1);
            }
          }
          myCIL___tmp___23 = lexptr;
          lexptr = lexptr + 1;
          c = (enum __anonenum_token_34 )((unsigned char )*myCIL___tmp___23);
          lexleft = lexleft - 1;
        }
      }
      if (! lexleft) {
        if ((unsigned long )"Unbalanced [" != (unsigned long )((char *)0)) {
          dfaerror((char *)"Unbalanced [");
        } else {
          return ((enum __anonenum_token_34 )-1);
        }
      }
      myCIL___tmp___24 = lexptr;
      lexptr = lexptr + 1;
      c1 = (enum __anonenum_token_34 )((unsigned char )*myCIL___tmp___24);
      lexleft = lexleft - 1;
      if ((int )c1 == 45) {
        if (! lexleft) {
          if ((unsigned long )"Unbalanced [" != (unsigned long )((char *)0)) {
            dfaerror((char *)"Unbalanced [");
          } else {
            return ((enum __anonenum_token_34 )-1);
          }
        }
        myCIL___tmp___25 = lexptr;
        lexptr = lexptr + 1;
        c2 = (enum __anonenum_token_34 )((unsigned char )*myCIL___tmp___25);
        lexleft = lexleft - 1;
        if ((int )c2 == 93) {
          lexptr = lexptr - 1;
          lexleft = lexleft + 1;
          c2 = c;
        } else {
          if ((int )c2 == 92) {
            if (syntax_bits & 1) {
              if (! lexleft) {
                if ((unsigned long )"Unbalanced [" != (unsigned long )((char *)0)) {
                  dfaerror((char *)"Unbalanced [");
                } else {
                  return ((enum __anonenum_token_34 )-1);
                }
              }
              myCIL___tmp___26 = lexptr;
              lexptr = lexptr + 1;
              c2 = (enum __anonenum_token_34 )((unsigned char )*myCIL___tmp___26);
              lexleft = lexleft - 1;
            }
          }
          if (! lexleft) {
            if ((unsigned long )"Unbalanced [" != (unsigned long )((char *)0)) {
              dfaerror((char *)"Unbalanced [");
            } else {
              return ((enum __anonenum_token_34 )-1);
            }
          }
          myCIL___tmp___27 = lexptr;
          lexptr = lexptr + 1;
          c1 = (enum __anonenum_token_34 )((unsigned char )*myCIL___tmp___27);
          lexleft = lexleft - 1;
        }
      } else {
        c2 = c;
      }
      while ((int )c <= (int )c2) {
        setbit((int )c, ccl);
        if (case_fold) {
          myCIL___tmp___31 = __ctype_b_loc();
          if ((int )*(*myCIL___tmp___31 + (int )c) & 256) {
            myCIL___tmp___28 = tolower((int )c);
            setbit(myCIL___tmp___28, ccl);
          } else {
            myCIL___tmp___30 = __ctype_b_loc();
            if ((int )*(*myCIL___tmp___30 + (int )c) & 512) {
              myCIL___tmp___29 = toupper((int )c);
              setbit(myCIL___tmp___29, ccl);
            }
          }
        }
        c = (token )((int )c + 1);
      }
      skip: 
      c = c1;
      if (! ((int )c != 93)) {
        break;
      }
    }
    if (invert) {
      notset(ccl);
      if (syntax_bits & ((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
        clrbit('\n', ccl);
      }
    }
    laststart = 0;
    myCIL___tmp___32 = charclass_index(ccl);
    lasttok = (enum __anonenum_token_34 )(273 + myCIL___tmp___32);
    return (lasttok);
    default: ;
    normal_char: 
    laststart = 0;
    if (case_fold) {
      myCIL___tmp___37 = __ctype_b_loc();
      if ((int )*(*myCIL___tmp___37 + (int )c) & 1024) {
        zeroset(ccl);
        setbit((int )c, ccl);
        myCIL___tmp___35 = __ctype_b_loc();
        if ((int )*(*myCIL___tmp___35 + (int )c) & 256) {
          myCIL___tmp___33 = tolower((int )c);
          setbit(myCIL___tmp___33, ccl);
        } else {
          myCIL___tmp___34 = toupper((int )c);
          setbit(myCIL___tmp___34, ccl);
        }
        myCIL___tmp___36 = charclass_index(ccl);
        lasttok = (enum __anonenum_token_34 )(273 + myCIL___tmp___36);
        return (lasttok);
      }
    }
    return (c);
    }
    i = i + 1;
  }
  abort();
}
}
static token tok  ;
static int depth  ;
static void addtok(token t ) 
{ ptr_t myCIL___tmp ;
  int myCIL___tmp___0 ;

  {
  if (dfa->tindex >= dfa->talloc) {
    while (dfa->tindex >= dfa->talloc) {
      dfa->talloc = dfa->talloc * 2;
    }
    myCIL___tmp = xrealloc_1((void *)dfa->tokens, (unsigned long )dfa->talloc * sizeof(token ));
    dfa->tokens = (token *)myCIL___tmp;
  }
  myCIL___tmp___0 = dfa->tindex;
  dfa->tindex = dfa->tindex + 1;
  *(dfa->tokens + myCIL___tmp___0) = t;
  switch ((int )t) {
  case 264: 
  case 265: 
  case 266: 
  break;
  case 268: 
  case 269: 
  case 270: 
  depth = depth - 1;
  break;
  default: 
  dfa->nleaves = dfa->nleaves + 1;
  case 256: 
  depth = depth + 1;
  break;
  }
  if (depth > dfa->depth) {
    dfa->depth = depth;
  }
  return;
}
}
static void regexp(int toplevel ) ;
static void atom(void) 
{ 

  {
  if ((int )tok >= 0) {
    if ((int )tok < 1 << 8) {
      addtok(tok);
      tok = lex();
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if ((int )tok >= 273) {
      addtok(tok);
      tok = lex();
    } else {
      if ((int )tok == 257) {
        addtok(tok);
        tok = lex();
      } else {
        if ((int )tok == 258) {
          addtok(tok);
          tok = lex();
        } else {
          if ((int )tok == 259) {
            addtok(tok);
            tok = lex();
          } else {
            if ((int )tok == 260) {
              addtok(tok);
              tok = lex();
            } else {
              if ((int )tok == 261) {
                addtok(tok);
                tok = lex();
              } else {
                if ((int )tok == 262) {
                  addtok(tok);
                  tok = lex();
                } else {
                  if ((int )tok == 263) {
                    addtok(tok);
                    tok = lex();
                  } else {
                    if ((int )tok == 271) {
                      tok = lex();
                      regexp(0);
                      if ((int )tok != 272) {
                        dfaerror((char *)"Unbalanced (");
                      }
                      tok = lex();
                    } else {
                      addtok((enum __anonenum_token_34 )256);
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return;
}
}
static int nsubtoks(int tindex ) 
{ int ntoks1 ;
  int myCIL___tmp ;
  int myCIL___tmp___0 ;

  {
  switch ((int )*(dfa->tokens + (tindex - 1))) {
  default: ;
  return (1);
  case 264: 
  case 265: 
  case 266: 
  myCIL___tmp = nsubtoks(tindex - 1);
  return (1 + myCIL___tmp);
  case 268: 
  case 269: 
  case 270: 
  ntoks1 = nsubtoks(tindex - 1);
  myCIL___tmp___0 = nsubtoks((tindex - 1) - ntoks1);
  return ((1 + ntoks1) + myCIL___tmp___0);
  }
}
}
static void copytoks(int tindex , int ntokens ) 
{ int i ;

  {
  i = 0;
  while (i < ntokens) {
    addtok(*(dfa->tokens + (tindex + i)));
    i = i + 1;
  }
  return;
}
}
static void closure(void) 
{ int tindex ;
  int ntokens ;
  int i ;

  {
  atom();
  while (1) {
    if (! ((int )tok == 264)) {
      if (! ((int )tok == 265)) {
        if (! ((int )tok == 266)) {
          if (! ((int )tok == 267)) {
            break;
          }
        }
      }
    }
    if ((int )tok == 267) {
      ntokens = nsubtoks(dfa->tindex);
      tindex = dfa->tindex - ntokens;
      if (maxrep == 0) {
        addtok((enum __anonenum_token_34 )266);
      }
      if (minrep == 0) {
        addtok((enum __anonenum_token_34 )264);
      }
      i = 1;
      while (i < minrep) {
        copytoks(tindex, ntokens);
        addtok((enum __anonenum_token_34 )268);
        i = i + 1;
      }
      while (i < maxrep) {
        copytoks(tindex, ntokens);
        addtok((enum __anonenum_token_34 )264);
        addtok((enum __anonenum_token_34 )268);
        i = i + 1;
      }
      tok = lex();
    } else {
      addtok(tok);
      tok = lex();
    }
  }
  return;
}
}
static void branch(void) 
{ 

  {
  closure();
  while (1) {
    if ((int )tok != 272) {
      if ((int )tok != 269) {
        if (! ((int )tok >= 0)) {
          break;
        }
      } else {
        break;
      }
    } else {
      break;
    }
    closure();
    addtok((enum __anonenum_token_34 )268);
  }
  return;
}
}
static void regexp(int toplevel ) 
{ 

  {
  branch();
  while ((int )tok == 269) {
    tok = lex();
    branch();
    if (toplevel) {
      addtok((enum __anonenum_token_34 )270);
    } else {
      addtok((enum __anonenum_token_34 )269);
    }
  }
  return;
}
}
void dfaparse(char *s , size_t len , struct dfa *d ) 
{ 

  {
  dfa = d;
  lexptr = s;
  lexstart = lexptr;
  lexleft = (int )len;
  lasttok = (enum __anonenum_token_34 )-1;
  laststart = 1;
  parens = 0;
  if (! syntax_bits_set) {
    dfaerror((char *)"No syntax specified");
  }
  tok = lex();
  depth = d->depth;
  regexp(1);
  if ((int )tok != -1) {
    dfaerror((char *)"Unbalanced )");
  }
  addtok((enum __anonenum_token_34 )(-1 - d->nregexps));
  addtok((enum __anonenum_token_34 )268);
  if (d->nregexps) {
    addtok((enum __anonenum_token_34 )270);
  }
  d->nregexps = d->nregexps + 1;
  return;
}
}
static void copy(position_set *src , position_set *dst ) 
{ int i ;

  {
  i = 0;
  while (i < src->nelem) {
    *(dst->elems + i) = *(src->elems + i);
    i = i + 1;
  }
  dst->nelem = src->nelem;
  return;
}
}
static void insert(position p , position_set *s ) 
{ int i ;
  position t1 ;
  position t2 ;
  int myCIL___tmp ;

  {
  i = 0;
  while (1) {
    if (i < s->nelem) {
      if (! (p.strchr < (s->elems + i)->strchr)) {
        break;
      }
    } else {
      break;
    }
    i = i + 1;
  }
  if (i < s->nelem) {
    if (p.strchr == (s->elems + i)->strchr) {
      (s->elems + i)->constraint = (s->elems + i)->constraint | p.constraint;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    t1 = p;
    s->nelem = s->nelem + 1;
    while (i < s->nelem) {
      t2 = *(s->elems + i);
      myCIL___tmp = i;
      i = i + 1;
      *(s->elems + myCIL___tmp) = t1;
      t1 = t2;
    }
  }
  return;
}
}
static void merge(position_set *s1 , position_set *s2 , position_set *m ) 
{ int i ;
  int j ;
  int myCIL___tmp ;
  int myCIL___tmp___0 ;
  int myCIL___tmp___1 ;
  int myCIL___tmp___2 ;
  int myCIL___tmp___3 ;
  int myCIL___tmp___4 ;
  int myCIL___tmp___5 ;
  int myCIL___tmp___6 ;
  int myCIL___tmp___7 ;
  int myCIL___tmp___8 ;
  int myCIL___tmp___9 ;

  {
  i = 0;
  j = 0;
  m->nelem = 0;
  while (1) {
    if (i < s1->nelem) {
      if (! (j < s2->nelem)) {
        break;
      }
    } else {
      break;
    }
    if ((s1->elems + i)->strchr > (s2->elems + j)->strchr) {
      myCIL___tmp = m->nelem;
      m->nelem = m->nelem + 1;
      myCIL___tmp___0 = i;
      i = i + 1;
      *(m->elems + myCIL___tmp) = *(s1->elems + myCIL___tmp___0);
    } else {
      if ((s1->elems + i)->strchr < (s2->elems + j)->strchr) {
        myCIL___tmp___1 = m->nelem;
        m->nelem = m->nelem + 1;
        myCIL___tmp___2 = j;
        j = j + 1;
        *(m->elems + myCIL___tmp___1) = *(s2->elems + myCIL___tmp___2);
      } else {
        myCIL___tmp___3 = i;
        i = i + 1;
        *(m->elems + m->nelem) = *(s1->elems + myCIL___tmp___3);
        myCIL___tmp___4 = m->nelem;
        m->nelem = m->nelem + 1;
        myCIL___tmp___5 = j;
        j = j + 1;
        (m->elems + myCIL___tmp___4)->constraint = (m->elems + myCIL___tmp___4)->constraint | (s2->elems + myCIL___tmp___5)->constraint;
      }
    }
  }
  while (i < s1->nelem) {
    myCIL___tmp___6 = m->nelem;
    m->nelem = m->nelem + 1;
    myCIL___tmp___7 = i;
    i = i + 1;
    *(m->elems + myCIL___tmp___6) = *(s1->elems + myCIL___tmp___7);
  }
  while (j < s2->nelem) {
    myCIL___tmp___8 = m->nelem;
    m->nelem = m->nelem + 1;
    myCIL___tmp___9 = j;
    j = j + 1;
    *(m->elems + myCIL___tmp___8) = *(s2->elems + myCIL___tmp___9);
  }
  return;
}
}
static void delete(position p , position_set *s ) 
{ int i ;

  {
  i = 0;
  while (i < s->nelem) {
    if (p.strchr == (s->elems + i)->strchr) {
      break;
    }
    i = i + 1;
  }
  if (i < s->nelem) {
    s->nelem = s->nelem - 1;
    while (i < s->nelem) {
      *(s->elems + i) = *(s->elems + (i + 1));
      i = i + 1;
    }
  }
  return;
}
}
static int state_index(struct dfa *d , position_set *s , int newline , int letter ) 
{ int hash ;
  int constraint ;
  int i ;
  int j ;
  ptr_t myCIL___tmp ;
  ptr_t myCIL___tmp___0 ;
  int myCIL___tmp___1 ;
  int myCIL___tmp___2 ;
  int myCIL___tmp___3 ;
  int myCIL___tmp___4 ;
  int myCIL___tmp___5 ;
  int myCIL___tmp___6 ;
  int myCIL___tmp___7 ;
  int myCIL___tmp___8 ;

  {
  hash = 0;
  if (newline) {
    newline = 1;
  } else {
    newline = 0;
  }
  if (letter) {
    letter = 1;
  } else {
    letter = 0;
  }
  i = 0;
  while (i < s->nelem) {
    hash = (int )((unsigned int )hash ^ ((s->elems + i)->strchr + (s->elems + i)->constraint));
    i = i + 1;
  }
  i = 0;
  while (i < d->sindex) {
    if (hash != (d->states + i)->hash) {
      goto __Cont;
    } else {
      if (s->nelem != (d->states + i)->elems.nelem) {
        goto __Cont;
      } else {
        if (newline != (int )(d->states + i)->newline) {
          goto __Cont;
        } else {
          if (letter != (int )(d->states + i)->letter) {
            goto __Cont;
          }
        }
      }
    }
    j = 0;
    while (j < s->nelem) {
      if ((s->elems + j)->constraint != ((d->states + i)->elems.elems + j)->constraint) {
        break;
      } else {
        if ((s->elems + j)->strchr != ((d->states + i)->elems.elems + j)->strchr) {
          break;
        }
      }
      j = j + 1;
    }
    if (j == s->nelem) {
      return (i);
    }
    __Cont: /* CIL Label */ 
    i = i + 1;
  }
  if (d->sindex >= d->salloc) {
    while (d->sindex >= d->salloc) {
      d->salloc = d->salloc * 2;
    }
    myCIL___tmp = xrealloc_1((void *)d->states, (unsigned long )d->salloc * sizeof(dfa_state ));
    d->states = (dfa_state *)myCIL___tmp;
  }
  (d->states + i)->hash = hash;
  myCIL___tmp___0 = xmalloc_1((unsigned long )s->nelem * sizeof(position ));
  (d->states + i)->elems.elems = (position *)myCIL___tmp___0;
  copy(s, & (d->states + i)->elems);
  (d->states + i)->newline = (char )newline;
  (d->states + i)->letter = (char )letter;
  (d->states + i)->backref = (char)0;
  (d->states + i)->constraint = (unsigned char)0;
  (d->states + i)->first_end = 0;
  j = 0;
  while (j < s->nelem) {
    if ((int )*(d->tokens + (s->elems + j)->strchr) < 0) {
      constraint = (int )(s->elems + j)->constraint;
      if (newline) {
        myCIL___tmp___1 = 2;
      } else {
        myCIL___tmp___1 = 0;
      }
      if (constraint & (1 << (myCIL___tmp___1 + 4))) {
        if (letter) {
          myCIL___tmp___2 = 2;
        } else {
          myCIL___tmp___2 = 0;
        }
        if (constraint & (1 << myCIL___tmp___2)) {
          (d->states + i)->constraint = (unsigned char )((int )(d->states + i)->constraint | constraint);
        } else {
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
        if (newline) {
          myCIL___tmp___3 = 2;
        } else {
          myCIL___tmp___3 = 0;
        }
        if (constraint & (1 << (myCIL___tmp___3 + 4))) {
          if (letter) {
            myCIL___tmp___4 = 2;
          } else {
            myCIL___tmp___4 = 0;
          }
          if (constraint & (1 << (myCIL___tmp___4 + 1))) {
            (d->states + i)->constraint = (unsigned char )((int )(d->states + i)->constraint | constraint);
          } else {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          if (newline) {
            myCIL___tmp___5 = 2;
          } else {
            myCIL___tmp___5 = 0;
          }
          if (constraint & (1 << ((myCIL___tmp___5 + 1) + 4))) {
            if (letter) {
              myCIL___tmp___6 = 2;
            } else {
              myCIL___tmp___6 = 0;
            }
            if (constraint & (1 << myCIL___tmp___6)) {
              (d->states + i)->constraint = (unsigned char )((int )(d->states + i)->constraint | constraint);
            } else {
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
            if (newline) {
              myCIL___tmp___7 = 2;
            } else {
              myCIL___tmp___7 = 0;
            }
            if (constraint & (1 << ((myCIL___tmp___7 + 1) + 4))) {
              if (letter) {
                myCIL___tmp___8 = 2;
              } else {
                myCIL___tmp___8 = 0;
              }
              if (constraint & (1 << (myCIL___tmp___8 + 1))) {
                (d->states + i)->constraint = (unsigned char )((int )(d->states + i)->constraint | constraint);
              }
            }
          }
        }
      }
      if (! (d->states + i)->first_end) {
        (d->states + i)->first_end = (int )*(d->tokens + (s->elems + j)->strchr);
      }
    } else {
      if ((int )*(d->tokens + (s->elems + j)->strchr) == 257) {
        (d->states + i)->constraint = (unsigned char)255;
        (d->states + i)->backref = (char)1;
      }
    }
    j = j + 1;
  }
  d->sindex = d->sindex + 1;
  return (i);
}
}
void epsclosure(position_set *s , struct dfa *d ) 
{ int i ;
  int j ;
  int *visited ;
  position p ;
  position old ;
  ptr_t myCIL___tmp ;

  {
  myCIL___tmp = xmalloc_1((unsigned long )d->tindex * sizeof(int ));
  visited = (int *)myCIL___tmp;
  i = 0;
  while (i < d->tindex) {
    *(visited + i) = 0;
    i = i + 1;
  }
  i = 0;
  while (i < s->nelem) {
    if ((int )*(d->tokens + (s->elems + i)->strchr) >= 1 << 8) {
      if ((int )*(d->tokens + (s->elems + i)->strchr) != 257) {
        if ((int )*(d->tokens + (s->elems + i)->strchr) < 273) {
          old = *(s->elems + i);
          p.constraint = old.constraint;
          delete(*(s->elems + i), s);
          if (*(visited + old.strchr)) {
            i = i - 1;
            goto __Cont;
          }
          *(visited + old.strchr) = 1;
          switch ((int )*(d->tokens + old.strchr)) {
          case 258: 
          p.constraint = p.constraint & 207U;
          break;
          case 259: 
          p.constraint = p.constraint & 175U;
          break;
          case 260: 
          p.constraint = p.constraint & 242U;
          break;
          case 261: 
          p.constraint = p.constraint & 244U;
          break;
          case 262: 
          p.constraint = p.constraint & 246U;
          break;
          case 263: 
          p.constraint = p.constraint & 249U;
          break;
          default: ;
          break;
          }
          j = 0;
          while (j < (d->follows + old.strchr)->nelem) {
            p.strchr = ((d->follows + old.strchr)->elems + j)->strchr;
            insert(p, s);
            j = j + 1;
          }
          i = -1;
        }
      }
    }
    __Cont: /* CIL Label */ 
    i = i + 1;
  }
  return;
}
}
void dfaanalyze(struct dfa *d , int searchflag ) 
{ int *nullable ;
  int *nfirstpos ;
  position *firstpos ;
  int *nlastpos ;
  position *lastpos ;
  int *nalloc ;
  position_set tmp ;
  position_set merged ;
  int wants_newline ;
  int *o_nullable ;
  int *o_nfirst ;
  int *o_nlast ;
  position *o_firstpos ;
  position *o_lastpos ;
  int i ;
  int j ;
  position *pos ;
  ptr_t myCIL___tmp ;
  ptr_t myCIL___tmp___0 ;
  ptr_t myCIL___tmp___1 ;
  ptr_t myCIL___tmp___2 ;
  ptr_t myCIL___tmp___3 ;
  ptr_t myCIL___tmp___4 ;
  ptr_t myCIL___tmp___5 ;
  ptr_t myCIL___tmp___6 ;
  int *myCIL___tmp___7 ;
  int *myCIL___tmp___8 ;
  int *myCIL___tmp___9 ;
  int myCIL___tmp___10 ;
  ptr_t myCIL___tmp___11 ;
  ptr_t myCIL___tmp___12 ;
  int myCIL___tmp___13 ;
  int myCIL___tmp___14 ;
  int *myCIL___tmp___15 ;
  int *myCIL___tmp___16 ;
  int *myCIL___tmp___17 ;
  int myCIL___tmp___18 ;
  unsigned int myCIL___tmp___19 ;
  unsigned int myCIL___tmp___20 ;
  ptr_t myCIL___tmp___21 ;
  ptr_t myCIL___tmp___22 ;
  ptr_t myCIL___tmp___23 ;

  {
  d->searchflag = searchflag;
  myCIL___tmp = xmalloc_1((unsigned long )d->depth * sizeof(int ));
  nullable = (int *)myCIL___tmp;
  o_nullable = nullable;
  myCIL___tmp___0 = xmalloc_1((unsigned long )d->depth * sizeof(int ));
  nfirstpos = (int *)myCIL___tmp___0;
  o_nfirst = nfirstpos;
  myCIL___tmp___1 = xmalloc_1((unsigned long )d->nleaves * sizeof(position ));
  firstpos = (position *)myCIL___tmp___1;
  o_firstpos = firstpos;
  firstpos = firstpos + d->nleaves;
  myCIL___tmp___2 = xmalloc_1((unsigned long )d->depth * sizeof(int ));
  nlastpos = (int *)myCIL___tmp___2;
  o_nlast = nlastpos;
  myCIL___tmp___3 = xmalloc_1((unsigned long )d->nleaves * sizeof(position ));
  lastpos = (position *)myCIL___tmp___3;
  o_lastpos = lastpos;
  lastpos = lastpos + d->nleaves;
  myCIL___tmp___4 = xmalloc_1((unsigned long )d->tindex * sizeof(int ));
  nalloc = (int *)myCIL___tmp___4;
  i = 0;
  while (i < d->tindex) {
    *(nalloc + i) = 0;
    i = i + 1;
  }
  myCIL___tmp___5 = xmalloc_1((unsigned long )d->nleaves * sizeof(position ));
  merged.elems = (position *)myCIL___tmp___5;
  myCIL___tmp___6 = xcalloc(d->tindex, sizeof(position_set ));
  d->follows = (position_set *)myCIL___tmp___6;
  i = 0;
  while (i < d->tindex) {
    switch ((int )*(d->tokens + i)) {
    case 256: 
    myCIL___tmp___7 = nullable;
    nullable = nullable + 1;
    *myCIL___tmp___7 = 1;
    myCIL___tmp___8 = nfirstpos;
    nfirstpos = nfirstpos + 1;
    myCIL___tmp___9 = nlastpos;
    nlastpos = nlastpos + 1;
    myCIL___tmp___10 = 0;
    *myCIL___tmp___9 = myCIL___tmp___10;
    *myCIL___tmp___8 = myCIL___tmp___10;
    break;
    case 265: 
    case 266: 
    tmp.nelem = *(nfirstpos + -1);
    tmp.elems = firstpos;
    pos = lastpos;
    j = 0;
    while (j < *(nlastpos + -1)) {
      merge(& tmp, d->follows + (pos + j)->strchr, & merged);
      if (merged.nelem - 1 >= *(nalloc + (pos + j)->strchr)) {
        while (merged.nelem - 1 >= *(nalloc + (pos + j)->strchr)) {
          *(nalloc + (pos + j)->strchr) = *(nalloc + (pos + j)->strchr) * 2;
        }
        myCIL___tmp___11 = xrealloc_1((void *)(d->follows + (pos + j)->strchr)->elems, (unsigned long )*(nalloc + (pos + j)->strchr) * sizeof(position ));
        (d->follows + (pos + j)->strchr)->elems = (position *)myCIL___tmp___11;
      }
      copy(& merged, d->follows + (pos + j)->strchr);
      j = j + 1;
    }
    case 264: 
    if ((int )*(d->tokens + i) != 266) {
      *(nullable + -1) = 1;
    }
    break;
    case 268: 
    tmp.nelem = *(nfirstpos + -1);
    tmp.elems = firstpos;
    pos = lastpos + *(nlastpos + -1);
    j = 0;
    while (j < *(nlastpos + -2)) {
      merge(& tmp, d->follows + (pos + j)->strchr, & merged);
      if (merged.nelem - 1 >= *(nalloc + (pos + j)->strchr)) {
        while (merged.nelem - 1 >= *(nalloc + (pos + j)->strchr)) {
          *(nalloc + (pos + j)->strchr) = *(nalloc + (pos + j)->strchr) * 2;
        }
        myCIL___tmp___12 = xrealloc_1((void *)(d->follows + (pos + j)->strchr)->elems, (unsigned long )*(nalloc + (pos + j)->strchr) * sizeof(position ));
        (d->follows + (pos + j)->strchr)->elems = (position *)myCIL___tmp___12;
      }
      copy(& merged, d->follows + (pos + j)->strchr);
      j = j + 1;
    }
    if (*(nullable + -2)) {
      *(nfirstpos + -2) = *(nfirstpos + -2) + *(nfirstpos + -1);
    } else {
      firstpos = firstpos + *(nfirstpos + -1);
    }
    nfirstpos = nfirstpos - 1;
    if (*(nullable + -1)) {
      *(nlastpos + -2) = *(nlastpos + -2) + *(nlastpos + -1);
    } else {
      pos = lastpos + *(nlastpos + -2);
      j = *(nlastpos + -1) - 1;
      while (j >= 0) {
        *(pos + j) = *(lastpos + j);
        j = j - 1;
      }
      lastpos = lastpos + *(nlastpos + -2);
      *(nlastpos + -2) = *(nlastpos + -1);
    }
    nlastpos = nlastpos - 1;
    if (*(nullable + -1)) {
      if (*(nullable + -2)) {
        myCIL___tmp___13 = 1;
      } else {
        myCIL___tmp___13 = 0;
      }
    } else {
      myCIL___tmp___13 = 0;
    }
    *(nullable + -2) = myCIL___tmp___13;
    nullable = nullable - 1;
    break;
    case 269: 
    case 270: 
    *(nfirstpos + -2) = *(nfirstpos + -2) + *(nfirstpos + -1);
    nfirstpos = nfirstpos - 1;
    *(nlastpos + -2) = *(nlastpos + -2) + *(nlastpos + -1);
    nlastpos = nlastpos - 1;
    if (*(nullable + -1)) {
      myCIL___tmp___14 = 1;
    } else {
      if (*(nullable + -2)) {
        myCIL___tmp___14 = 1;
      } else {
        myCIL___tmp___14 = 0;
      }
    }
    *(nullable + -2) = myCIL___tmp___14;
    nullable = nullable - 1;
    break;
    default: 
    myCIL___tmp___15 = nullable;
    nullable = nullable + 1;
    if ((int )*(d->tokens + i) == 257)
        *myCIL___tmp___15 = 1;
    else
        *myCIL___tmp___15 = 0;
    myCIL___tmp___16 = nfirstpos;
    nfirstpos = nfirstpos + 1;
    myCIL___tmp___17 = nlastpos;
    nlastpos = nlastpos + 1;
    myCIL___tmp___18 = 1;
    *myCIL___tmp___17 = myCIL___tmp___18;
    *myCIL___tmp___16 = myCIL___tmp___18;
    firstpos = firstpos - 1;
    lastpos = lastpos - 1;
    myCIL___tmp___19 = (unsigned int )i;
    lastpos->strchr = myCIL___tmp___19;
    firstpos->strchr = myCIL___tmp___19;
    myCIL___tmp___20 = 255U;
    lastpos->constraint = myCIL___tmp___20;
    firstpos->constraint = myCIL___tmp___20;
    *(nalloc + i) = 1;
    myCIL___tmp___21 = xmalloc_1((unsigned long )*(nalloc + i) * sizeof(position ));
    (d->follows + i)->elems = (position *)myCIL___tmp___21;
    break;
    }
    i = i + 1;
  }
  i = 0;
  while (i < d->tindex) {
    if ((int )*(d->tokens + i) < 1 << 8) {
      goto _L;
    } else {
      if ((int )*(d->tokens + i) == 257) {
        goto _L;
      } else {
        if ((int )*(d->tokens + i) >= 273) {
          _L: /* CIL Label */ 
          copy(d->follows + i, & merged);
          epsclosure(& merged, d);
          if ((d->follows + i)->nelem < merged.nelem) {
            myCIL___tmp___22 = xrealloc_1((void *)(d->follows + i)->elems, (unsigned long )merged.nelem * sizeof(position ));
            (d->follows + i)->elems = (position *)myCIL___tmp___22;
          }
          copy(& merged, d->follows + i);
        }
      }
    }
    i = i + 1;
  }
  merged.nelem = 0;
  i = 0;
  while (i < *(nfirstpos + -1)) {
    insert(*(firstpos + i), & merged);
    i = i + 1;
  }
  epsclosure(& merged, d);
  wants_newline = 0;
  i = 0;
  while (i < merged.nelem) {
    if (((merged.elems + i)->constraint & 192U) >> 2 != ((merged.elems + i)->constraint & 48U)) {
      wants_newline = 1;
    }
    i = i + 1;
  }
  d->salloc = 1;
  d->sindex = 0;
  myCIL___tmp___23 = xmalloc_1((unsigned long )d->salloc * sizeof(dfa_state ));
  d->states = (dfa_state *)myCIL___tmp___23;
  state_index(d, & merged, wants_newline, 0);
  return;
}
}
static charclass letters  ;
static charclass newline  ;
static int initialized___0  ;
void dfastate(int s , struct dfa *d , int *trans ) 
{ position_set grps[1 << 8] ;
  charclass labels[1 << 8] ;
  int ngrps ;
  position pos ;
  charclass matches ;
  int matchesf ;
  charclass intersect ;
  int intersectf ;
  charclass leftovers ;
  int leftoversf ;
  position_set follows ;
  position_set tmp ;
  int state ;
  int wants_newline ;
  int state_newline ;
  int wants_letter ;
  int state_letter ;
  int i ;
  int j ;
  int k ;
  unsigned short **myCIL___tmp ;
  int myCIL___tmp___0 ;
  int myCIL___tmp___1 ;
  int myCIL___tmp___2 ;
  int myCIL___tmp___3 ;
  int myCIL___tmp___4 ;
  int myCIL___tmp___5 ;
  int match ;
  int label ;
  int myCIL___tmp___6 ;
  int myCIL___tmp___7 ;
  ptr_t myCIL___tmp___8 ;
  int myCIL___tmp___9 ;
  ptr_t myCIL___tmp___10 ;
  ptr_t myCIL___tmp___11 ;
  ptr_t myCIL___tmp___12 ;
  unsigned short **myCIL___tmp___13 ;
  int myCIL___tmp___14 ;
  int c ;
  unsigned short **myCIL___tmp___15 ;

  {
  ngrps = 0;
  if (! initialized___0) {
    initialized___0 = 1;
    i = 0;
    while (i < 1 << 8) {
      myCIL___tmp = __ctype_b_loc();
      if ((int )*(*myCIL___tmp + i) & 8) {
        setbit(i, letters);
      }
      i = i + 1;
    }
    setbit('\n', newline);
  }
  zeroset(matches);
  i = 0;
  while (i < (d->states + s)->elems.nelem) {
    pos = *((d->states + s)->elems.elems + i);
    if ((int )*(d->tokens + pos.strchr) >= 0) {
      if ((int )*(d->tokens + pos.strchr) < 1 << 8) {
        setbit((int )*(d->tokens + pos.strchr), matches);
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      if ((int )*(d->tokens + pos.strchr) >= 273) {
        copyset(*(d->charclasses + ((int )*(d->tokens + pos.strchr) - 273)), matches);
      } else {
        goto __Cont;
      }
    }
    if (pos.constraint != 255U) {
      if ((d->states + s)->newline) {
        myCIL___tmp___0 = 2;
      } else {
        myCIL___tmp___0 = 0;
      }
      if (! (pos.constraint & (unsigned int )(1 << ((myCIL___tmp___0 + 1) + 4)))) {
        clrbit('\n', matches);
      }
      if ((d->states + s)->newline) {
        myCIL___tmp___1 = 2;
      } else {
        myCIL___tmp___1 = 0;
      }
      if (! (pos.constraint & (unsigned int )(1 << (myCIL___tmp___1 + 4)))) {
        j = 0;
        while ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
          matches[j] = matches[j] & newline[j];
          j = j + 1;
        }
      }
      if ((d->states + s)->letter) {
        myCIL___tmp___2 = 2;
      } else {
        myCIL___tmp___2 = 0;
      }
      if (! (pos.constraint & (unsigned int )(1 << (myCIL___tmp___2 + 1)))) {
        j = 0;
        while ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
          matches[j] = matches[j] & ~ letters[j];
          j = j + 1;
        }
      }
      if ((d->states + s)->letter) {
        myCIL___tmp___3 = 2;
      } else {
        myCIL___tmp___3 = 0;
      }
      if (! (pos.constraint & (unsigned int )(1 << myCIL___tmp___3))) {
        j = 0;
        while ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
          matches[j] = matches[j] & letters[j];
          j = j + 1;
        }
      }
      j = 0;
      while (1) {
        if ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
          if (! (! matches[j])) {
            break;
          }
        } else {
          break;
        }
        j = j + 1;
      }
      if ((unsigned long )j == (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
        goto __Cont;
      }
    }
    j = 0;
    while (j < ngrps) {
      if ((int )*(d->tokens + pos.strchr) >= 0) {
        if ((int )*(d->tokens + pos.strchr) < 1 << 8) {
          myCIL___tmp___4 = tstbit((int )*(d->tokens + pos.strchr), labels[j]);
          if (! myCIL___tmp___4) {
            goto __Cont___0;
          }
        }
      }
      intersectf = 0;
      k = 0;
      while ((unsigned long )k < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
        myCIL___tmp___5 = matches[k] & labels[j][k];
        intersect[k] = myCIL___tmp___5;
        if (myCIL___tmp___5) {
          intersectf = 1;
        }
        k = k + 1;
      }
      if (! intersectf) {
        goto __Cont___0;
      }
      matchesf = 0;
      leftoversf = matchesf;
      k = 0;
      while ((unsigned long )k < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
        match = matches[k];
        label = labels[j][k];
        myCIL___tmp___6 = ~ match & label;
        leftovers[k] = myCIL___tmp___6;
        if (myCIL___tmp___6) {
          leftoversf = 1;
        }
        myCIL___tmp___7 = match & ~ label;
        matches[k] = myCIL___tmp___7;
        if (myCIL___tmp___7) {
          matchesf = 1;
        }
        k = k + 1;
      }
      if (leftoversf) {
        copyset(leftovers, labels[ngrps]);
        copyset(intersect, labels[j]);
        myCIL___tmp___8 = xmalloc_1((unsigned long )d->nleaves * sizeof(position ));
        grps[ngrps].elems = (position *)myCIL___tmp___8;
        copy(& grps[j], & grps[ngrps]);
        ngrps = ngrps + 1;
      }
      myCIL___tmp___9 = grps[j].nelem;
      grps[j].nelem = grps[j].nelem + 1;
      *(grps[j].elems + myCIL___tmp___9) = pos;
      if (! matchesf) {
        break;
      }
      __Cont___0: /* CIL Label */ 
      j = j + 1;
    }
    if (j == ngrps) {
      copyset(matches, labels[ngrps]);
      zeroset(matches);
      myCIL___tmp___10 = xmalloc_1((unsigned long )d->nleaves * sizeof(position ));
      grps[ngrps].elems = (position *)myCIL___tmp___10;
      grps[ngrps].nelem = 1;
      *(grps[ngrps].elems + 0) = pos;
      ngrps = ngrps + 1;
    }
    __Cont: /* CIL Label */ 
    i = i + 1;
  }
  myCIL___tmp___11 = xmalloc_1((unsigned long )d->nleaves * sizeof(position ));
  follows.elems = (position *)myCIL___tmp___11;
  myCIL___tmp___12 = xmalloc_1((unsigned long )d->nleaves * sizeof(position ));
  tmp.elems = (position *)myCIL___tmp___12;
  if (d->searchflag) {
    wants_newline = 0;
    wants_letter = 0;
    i = 0;
    while (i < (d->states + 0)->elems.nelem) {
      if ((((d->states + 0)->elems.elems + i)->constraint & 192U) >> 2 != (((d->states + 0)->elems.elems + i)->constraint & 48U)) {
        wants_newline = 1;
      }
      if ((((d->states + 0)->elems.elems + i)->constraint & 12U) >> 2 != (((d->states + 0)->elems.elems + i)->constraint & 3U)) {
        wants_letter = 1;
      }
      i = i + 1;
    }
    copy(& (d->states + 0)->elems, & follows);
    state = state_index(d, & follows, 0, 0);
    if (wants_newline) {
      state_newline = state_index(d, & follows, 1, 0);
    } else {
      state_newline = state;
    }
    if (wants_letter) {
      state_letter = state_index(d, & follows, 0, 1);
    } else {
      state_letter = state;
    }
    i = 0;
    while (i < 1 << 8) {
      if (i == 10) {
        *(trans + i) = state_newline;
      } else {
        myCIL___tmp___13 = __ctype_b_loc();
        if ((int )*(*myCIL___tmp___13 + i) & 8) {
          *(trans + i) = state_letter;
        } else {
          *(trans + i) = state;
        }
      }
      i = i + 1;
    }
  } else {
    i = 0;
    while (i < 1 << 8) {
      *(trans + i) = -1;
      i = i + 1;
    }
  }
  i = 0;
  while (i < ngrps) {
    follows.nelem = 0;
    j = 0;
    while (j < grps[i].nelem) {
      k = 0;
      while (k < (d->follows + (grps[i].elems + j)->strchr)->nelem) {
        insert(*((d->follows + (grps[i].elems + j)->strchr)->elems + k), & follows);
        k = k + 1;
      }
      j = j + 1;
    }
    if (d->searchflag) {
      j = 0;
      while (j < (d->states + 0)->elems.nelem) {
        insert(*((d->states + 0)->elems.elems + j), & follows);
        j = j + 1;
      }
    }
    wants_newline = 0;
    myCIL___tmp___14 = tstbit('\n', labels[i]);
    if (myCIL___tmp___14) {
      j = 0;
      while (j < follows.nelem) {
        if (((follows.elems + j)->constraint & 192U) >> 2 != ((follows.elems + j)->constraint & 48U)) {
          wants_newline = 1;
        }
        j = j + 1;
      }
    }
    wants_letter = 0;
    j = 0;
    while ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
      if (labels[i][j] & letters[j]) {
        break;
      }
      j = j + 1;
    }
    if ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
      j = 0;
      while (j < follows.nelem) {
        if (((follows.elems + j)->constraint & 12U) >> 2 != ((follows.elems + j)->constraint & 3U)) {
          wants_letter = 1;
        }
        j = j + 1;
      }
    }
    state = state_index(d, & follows, 0, 0);
    if (wants_newline) {
      state_newline = state_index(d, & follows, 1, 0);
    } else {
      state_newline = state;
    }
    if (wants_letter) {
      state_letter = state_index(d, & follows, 0, 1);
    } else {
      state_letter = state;
    }
    j = 0;
    while ((unsigned long )j < (((unsigned long )(1 << 8) + 8UL * sizeof(int )) - 1UL) / (8UL * sizeof(int ))) {
      k = 0;
      while ((unsigned long )k < 8UL * sizeof(int )) {
        if (labels[i][j] & (1 << k)) {
          c = (int )((unsigned long )j * (8UL * sizeof(int )) + (unsigned long )k);
          if (c == 10) {
            *(trans + c) = state_newline;
          } else {
            myCIL___tmp___15 = __ctype_b_loc();
            if ((int )*(*myCIL___tmp___15 + c) & 8) {
              *(trans + c) = state_letter;
            } else {
              if (c < 1 << 8) {
                *(trans + c) = state;
              }
            }
          }
        }
        k = k + 1;
      }
      j = j + 1;
    }
    i = i + 1;
  }
  i = 0;
  while (i < ngrps) {
    i = i + 1;
  }
  return;
}
}
static void build_state(int s , struct dfa *d ) 
{ int *trans ;
  int i ;
  int myCIL___tmp ;
  int myCIL___tmp___0 ;
  int myCIL___tmp___1 ;
  int myCIL___tmp___2 ;
  int myCIL___tmp___3 ;
  int myCIL___tmp___4 ;
  ptr_t myCIL___tmp___5 ;
  int oldalloc ;
  ptr_t myCIL___tmp___6 ;
  ptr_t myCIL___tmp___7 ;
  ptr_t myCIL___tmp___8 ;
  ptr_t myCIL___tmp___9 ;
  int myCIL___tmp___10 ;

  {
  if (d->trcount >= 1024) {
    i = 0;
    while (i < d->tralloc) {
      if (*(d->trans + i)) {
        *(d->trans + i) = (int *)((void *)0);
      } else {
        if (*(d->fails + i)) {
          *(d->fails + i) = (int *)((void *)0);
        }
      }
      i = i + 1;
    }
    d->trcount = 0;
  }
  d->trcount = d->trcount + 1;
  *(d->success + s) = 0;
  if ((d->states + s)->newline) {
    myCIL___tmp = 2;
  } else {
    myCIL___tmp = 0;
  }
  if ((int )(d->states + s)->constraint & (1 << ((myCIL___tmp + 1) + 4))) {
    if ((d->states + s)->letter) {
      myCIL___tmp___0 = 2;
    } else {
      myCIL___tmp___0 = 0;
    }
    if ((int )(d->states + s)->constraint & (1 << myCIL___tmp___0)) {
      *(d->success + s) = *(d->success + s) | 4;
    }
  }
  if ((d->states + s)->newline) {
    myCIL___tmp___1 = 2;
  } else {
    myCIL___tmp___1 = 0;
  }
  if ((int )(d->states + s)->constraint & (1 << (myCIL___tmp___1 + 4))) {
    if ((d->states + s)->letter) {
      myCIL___tmp___2 = 2;
    } else {
      myCIL___tmp___2 = 0;
    }
    if ((int )(d->states + s)->constraint & (1 << (myCIL___tmp___2 + 1))) {
      *(d->success + s) = *(d->success + s) | 2;
    }
  }
  if ((d->states + s)->newline) {
    myCIL___tmp___3 = 2;
  } else {
    myCIL___tmp___3 = 0;
  }
  if ((int )(d->states + s)->constraint & (1 << (myCIL___tmp___3 + 4))) {
    if ((d->states + s)->letter) {
      myCIL___tmp___4 = 2;
    } else {
      myCIL___tmp___4 = 0;
    }
    if ((int )(d->states + s)->constraint & (1 << myCIL___tmp___4)) {
      *(d->success + s) = *(d->success + s) | 1;
    }
  }
  myCIL___tmp___5 = xmalloc_1((unsigned long )(1 << 8) * sizeof(int ));
  trans = (int *)myCIL___tmp___5;
  dfastate(s, d, trans);
  i = 0;
  while (i < 1 << 8) {
    if (*(trans + i) >= d->tralloc) {
      oldalloc = d->tralloc;
      while (*(trans + i) >= d->tralloc) {
        d->tralloc = d->tralloc * 2;
      }
      myCIL___tmp___6 = xrealloc_1((void *)d->realtrans, (unsigned long )(d->tralloc + 1) * sizeof(int *));
      d->realtrans = (int **)myCIL___tmp___6;
      d->trans = d->realtrans + 1;
      myCIL___tmp___7 = xrealloc_1((void *)d->fails, (unsigned long )d->tralloc * sizeof(int *));
      d->fails = (int **)myCIL___tmp___7;
      myCIL___tmp___8 = xrealloc_1((void *)d->success, (unsigned long )d->tralloc * sizeof(int ));
      d->success = (int *)myCIL___tmp___8;
      myCIL___tmp___9 = xrealloc_1((void *)d->newlines, (unsigned long )d->tralloc * sizeof(int ));
      d->newlines = (int *)myCIL___tmp___9;
      while (oldalloc < d->tralloc) {
        *(d->trans + oldalloc) = (int *)((void *)0);
        myCIL___tmp___10 = oldalloc;
        oldalloc = oldalloc + 1;
        *(d->fails + myCIL___tmp___10) = (int *)((void *)0);
      }
    }
    i = i + 1;
  }
  *(d->newlines + s) = *(trans + '\n');
  *(trans + '\n') = -1;
  if ((d->states + s)->constraint) {
    *(d->fails + s) = trans;
  } else {
    *(d->trans + s) = trans;
  }
  return;
}
}
static void build_state_zero(struct dfa *d ) 
{ ptr_t myCIL___tmp ;
  ptr_t myCIL___tmp___0 ;
  ptr_t myCIL___tmp___1 ;
  ptr_t myCIL___tmp___2 ;

  {
  d->tralloc = 1;
  d->trcount = 0;
  myCIL___tmp = xcalloc(d->tralloc + 1, sizeof(int *));
  d->realtrans = (int **)myCIL___tmp;
  d->trans = d->realtrans + 1;
  myCIL___tmp___0 = xcalloc(d->tralloc, sizeof(int *));
  d->fails = (int **)myCIL___tmp___0;
  myCIL___tmp___1 = xmalloc_1((unsigned long )d->tralloc * sizeof(int ));
  d->success = (int *)myCIL___tmp___1;
  myCIL___tmp___2 = xmalloc_1((unsigned long )d->tralloc * sizeof(int ));
  d->newlines = (int *)myCIL___tmp___2;
  build_state(0, d);
  return;
}
}
static int sbit[256]  ;
static int sbit_init  ;
char *dfaexec(struct dfa *d , char *begin , char *end , int newline___0 , int *count , int *backref ) 
{ register int s ;
  register int s1 ;
  register int tmp ;
  register unsigned char *p ;
  register int **trans ;
  register int *t ;
  int i ;
  unsigned short **myCIL___tmp ;
  unsigned char *myCIL___tmp___0 ;
  unsigned char *myCIL___tmp___1 ;
  unsigned char *myCIL___tmp___2 ;

  {
  if (! sbit_init) {
    sbit_init = 1;
    i = 0;
    while (i < 1 << 8) {
      if (i == 10) {
        sbit[i] = 4;
      } else {
        myCIL___tmp = __ctype_b_loc();
        if ((int )*(*myCIL___tmp + i) & 8) {
          sbit[i] = 2;
        } else {
          sbit[i] = 1;
        }
      }
      i = i + 1;
    }
  }
  if (! d->tralloc) {
    build_state_zero(d);
  }
  s1 = 0;
  s = s1;
  p = (unsigned char *)begin;
  trans = d->trans;
  *end = (char )'\n';
  while (1) {
    t = *(trans + s);
    if ((unsigned long )t != (unsigned long )((int *)0)) {
      while (1) {
        myCIL___tmp___0 = p;
        p = p + 1;
        s1 = *(t + *myCIL___tmp___0);
        t = *(trans + s1);
        if (! t) {
          goto last_was_s;
        }
        myCIL___tmp___1 = p;
        p = p + 1;
        s = *(t + *myCIL___tmp___1);
        t = *(trans + s);
        if (! ((unsigned long )t != (unsigned long )((int *)0))) {
          break;
        }
      }
    }
    goto last_was_s1;
    last_was_s: 
    tmp = s;
    s = s1;
    s1 = tmp;
    last_was_s1: 
    if (s >= 0) {
      if ((unsigned long )p <= (unsigned long )((unsigned char *)end)) {
        if (*(d->fails + s)) {
          if (*(d->success + s) & sbit[*p]) {
            if (backref) {
              if ((d->states + s)->backref) {
                *backref = 1;
              } else {
                *backref = 0;
              }
            }
            return ((char *)p);
          }
          s1 = s;
          myCIL___tmp___2 = p;
          p = p + 1;
          s = *(*(d->fails + s) + *myCIL___tmp___2);
          goto __Cont;
        }
      }
    }
    if (count) {
      if ((unsigned long )((char *)p) <= (unsigned long )end) {
        if ((int )*(p + -1) == 10) {
          *count = *count + 1;
        }
      }
    }
    if ((unsigned long )((char *)p) > (unsigned long )end) {
      return ((char *)((void *)0));
    }
    if (s >= 0) {
      build_state(s, d);
      trans = d->trans;
      goto __Cont;
    }
    if ((int )*(p + -1) == 10) {
      if (newline___0) {
        s = *(d->newlines + s1);
        goto __Cont;
      }
    }
    s = 0;
    __Cont: /* CIL Label */ ;
  }
}
}
void dfainit(struct dfa *d ) 
{ ptr_t myCIL___tmp ;
  ptr_t myCIL___tmp___0 ;
  int myCIL___tmp___1 ;
  int myCIL___tmp___2 ;
  int myCIL___tmp___3 ;

  {
  d->calloc = 1;
  myCIL___tmp = xmalloc_1((unsigned long )d->calloc * sizeof(charclass ));
  d->charclasses = (charclass *)myCIL___tmp;
  d->cindex = 0;
  d->talloc = 1;
  myCIL___tmp___0 = xmalloc_1((unsigned long )d->talloc * sizeof(token ));
  d->tokens = (token *)myCIL___tmp___0;
  myCIL___tmp___3 = 0;
  d->nregexps = myCIL___tmp___3;
  myCIL___tmp___2 = myCIL___tmp___3;
  d->nleaves = myCIL___tmp___2;
  myCIL___tmp___1 = myCIL___tmp___2;
  d->depth = myCIL___tmp___1;
  d->tindex = myCIL___tmp___1;
  d->searchflag = 0;
  d->tralloc = 0;
  d->musts = (struct dfamust *)0;
  return;
}
}
void dfacomp(char *s , size_t len , struct dfa *d , int searchflag ) 
{ char *copy___0 ;
  int i ;
  void *myCIL___tmp ;
  int myCIL___tmp___0 ;
  unsigned short **myCIL___tmp___1 ;
  int myCIL___tmp___2 ;
  int myCIL___tmp___3 ;
  int myCIL___tmp___4 ;
  int myCIL___tmp___5 ;

  {
  if (case_fold) {
    myCIL___tmp = malloc(len);
    copy___0 = (char *)myCIL___tmp;
    if (! copy___0) {
      dfaerror((char *)"out of memory");
    }
    case_fold = 0;
    i = 0;
    while ((size_t )i < len) {
      myCIL___tmp___1 = __ctype_b_loc();
      if ((int )*(*myCIL___tmp___1 + (int )*(s + i)) & 256) {
        myCIL___tmp___0 = tolower((int )*(s + i));
        *(copy___0 + i) = (char )myCIL___tmp___0;
      } else {
        *(copy___0 + i) = *(s + i);
      }
      i = i + 1;
    }
    dfainit(d);
    dfaparse(copy___0, len, d);
    dfamust(d);
    myCIL___tmp___5 = 0;
    d->nregexps = myCIL___tmp___5;
    myCIL___tmp___4 = myCIL___tmp___5;
    d->nleaves = myCIL___tmp___4;
    myCIL___tmp___3 = myCIL___tmp___4;
    d->depth = myCIL___tmp___3;
    myCIL___tmp___2 = myCIL___tmp___3;
    d->tindex = myCIL___tmp___2;
    d->cindex = myCIL___tmp___2;
    case_fold = 1;
    dfaparse(s, len, d);
    dfaanalyze(d, searchflag);
  } else {
    dfainit(d);
    dfaparse(s, len, d);
    dfamust(d);
    dfaanalyze(d, searchflag);
  }
  return;
}
}
void dfafree(struct dfa *d ) 
{ int i ;
  struct dfamust *dm ;
  struct dfamust *ndm ;

  {
  i = 0;
  while (i < d->sindex) {
    i = i + 1;
  }
  i = 0;
  while (i < d->tindex) {
    if ((d->follows + i)->elems) {
    }
    i = i + 1;
  }
  i = 0;
  while (i < d->tralloc) {
    if (*(d->trans + i)) {
    } else {
      if (*(d->fails + i)) {
      }
    }
    i = i + 1;
  }
  dm = d->musts;
  while (dm) {
    ndm = dm->next;
    dm = ndm;
  }
  return;
}
}
static char *icatalloc(char *old , char *new ) 
{ char *result ;
  int oldsize ;
  int newsize ;
  size_t myCIL___tmp ;
  size_t myCIL___tmp___0 ;
  void *myCIL___tmp___1 ;
  void *myCIL___tmp___2 ;

  {
  if ((unsigned long )new == (unsigned long )((void *)0)) {
    newsize = 0;
  } else {
    myCIL___tmp = strlen((char *)new);
    newsize = (int )myCIL___tmp;
  }
  if ((unsigned long )old == (unsigned long )((void *)0)) {
    oldsize = 0;
  } else {
    if (newsize == 0) {
      return (old);
    } else {
      myCIL___tmp___0 = strlen((char *)old);
      oldsize = (int )myCIL___tmp___0;
    }
  }
  if ((unsigned long )old == (unsigned long )((void *)0)) {
    myCIL___tmp___1 = malloc((unsigned long )(newsize + 1));
    result = (char *)myCIL___tmp___1;
  } else {
    myCIL___tmp___2 = realloc((void *)old, (unsigned long )((oldsize + newsize) + 1));
    result = (char *)myCIL___tmp___2;
  }
  if ((unsigned long )result != (unsigned long )((void *)0)) {
    if ((unsigned long )new != (unsigned long )((void *)0)) {
      strcpy((char *)(result + oldsize), (char *)new);
    }
  }
  return (result);
}
}
static char *icpyalloc(char *string ) 
{ char *myCIL___tmp ;

  {
  myCIL___tmp = icatalloc((char *)((void *)0), string);
  return (myCIL___tmp);
}
}
static char *istrstr(char *lookin , char *lookfor ) 
{ char *cp ;
  int len ;
  size_t myCIL___tmp ;
  int myCIL___tmp___0 ;

  {
  myCIL___tmp = strlen((char *)lookfor);
  len = (int )myCIL___tmp;
  cp = lookin;
  while ((int )*cp != 0) {
    myCIL___tmp___0 = strncmp((char *)cp, (char *)lookfor, (unsigned long )len);
    if (myCIL___tmp___0 == 0) {
      return (cp);
    }
    cp = cp + 1;
  }
  return ((char *)((void *)0));
}
}
static void ifree(char *cp ) 
{ 

  {
  if ((unsigned long )cp != (unsigned long )((void *)0)) {
  }
  return;
}
}
static void freelist(char **cpp ) 
{ int i ;

  {
  if ((unsigned long )cpp == (unsigned long )((void *)0)) {
    return;
  }
  i = 0;
  while ((unsigned long )*(cpp + i) != (unsigned long )((void *)0)) {
    *(cpp + i) = (char *)((void *)0);
    i = i + 1;
  }
  return;
}
}
static char **enlist(char **cpp , char *new , int len ) 
{ int i ;
  int j ;
  char *myCIL___tmp ;
  char *myCIL___tmp___0 ;
  void *myCIL___tmp___1 ;

  {
  if ((unsigned long )cpp == (unsigned long )((void *)0)) {
    return ((char **)((void *)0));
  }
  new = icpyalloc(new);
  if ((unsigned long )new == (unsigned long )((void *)0)) {
    freelist(cpp);
    return ((char **)((void *)0));
  }
  *(new + len) = (char )'\000';
  i = 0;
  while ((unsigned long )*(cpp + i) != (unsigned long )((void *)0)) {
    myCIL___tmp = istrstr(*(cpp + i), new);
    if ((unsigned long )myCIL___tmp != (unsigned long )((void *)0)) {
      return (cpp);
    }
    i = i + 1;
  }
  j = 0;
  while ((unsigned long )*(cpp + j) != (unsigned long )((void *)0)) {
    myCIL___tmp___0 = istrstr(new, *(cpp + j));
    if ((unsigned long )myCIL___tmp___0 == (unsigned long )((void *)0)) {
      j = j + 1;
    } else {
      i = i - 1;
      if (i == j) {
        break;
      }
      *(cpp + j) = *(cpp + i);
      *(cpp + i) = (char *)((void *)0);
    }
  }
  myCIL___tmp___1 = realloc((void *)((char *)cpp), (unsigned long )(i + 2) * sizeof(*cpp));
  cpp = (char **)myCIL___tmp___1;
  if ((unsigned long )cpp == (unsigned long )((void *)0)) {
    return ((char **)((void *)0));
  }
  *(cpp + i) = new;
  *(cpp + (i + 1)) = (char *)((void *)0);
  return (cpp);
}
}
static char **comsubs(char *left , char *right ) 
{ char **cpp ;
  char *lcp ;
  char *rcp ;
  int i ;
  int len ;
  void *myCIL___tmp ;

  {
  if ((unsigned long )left == (unsigned long )((void *)0)) {
    return ((char **)((void *)0));
  } else {
    if ((unsigned long )right == (unsigned long )((void *)0)) {
      return ((char **)((void *)0));
    }
  }
  myCIL___tmp = malloc(sizeof(*cpp));
  cpp = (char **)myCIL___tmp;
  if ((unsigned long )cpp == (unsigned long )((void *)0)) {
    return ((char **)((void *)0));
  }
  *(cpp + 0) = (char *)((void *)0);
  lcp = left;
  while ((int )*lcp != 0) {
    len = 0;
    rcp = strchr((char *)right, (int )*lcp);
    while ((unsigned long )rcp != (unsigned long )((void *)0)) {
      i = 1;
      while (1) {
        if ((int )*(lcp + i) != 0) {
          if (! ((int )*(lcp + i) == (int )*(rcp + i))) {
            break;
          }
        } else {
          break;
        }
        i = i + 1;
      }
      if (i > len) {
        len = i;
      }
      rcp = strchr((char *)(rcp + 1), (int )*lcp);
    }
    if (len == 0) {
      goto __Cont;
    }
    cpp = enlist(cpp, lcp, len);
    if ((unsigned long )cpp == (unsigned long )((void *)0)) {
      break;
    }
    __Cont: /* CIL Label */ 
    lcp = lcp + 1;
  }
  return (cpp);
}
}
static char **addlists(char **old , char **new ) 
{ int i ;
  size_t myCIL___tmp ;

  {
  if ((unsigned long )old == (unsigned long )((void *)0)) {
    return ((char **)((void *)0));
  } else {
    if ((unsigned long )new == (unsigned long )((void *)0)) {
      return ((char **)((void *)0));
    }
  }
  i = 0;
  while ((unsigned long )*(new + i) != (unsigned long )((void *)0)) {
    myCIL___tmp = strlen((char *)*(new + i));
    old = enlist(old, *(new + i), (int )myCIL___tmp);
    if ((unsigned long )old == (unsigned long )((void *)0)) {
      break;
    }
    i = i + 1;
  }
  return (old);
}
}
static char **inboth(char **left , char **right ) 
{ char **both ;
  char **temp ;
  int lnum ;
  int rnum ;
  void *myCIL___tmp ;

  {
  if ((unsigned long )left == (unsigned long )((void *)0)) {
    return ((char **)((void *)0));
  } else {
    if ((unsigned long )right == (unsigned long )((void *)0)) {
      return ((char **)((void *)0));
    }
  }
  myCIL___tmp = malloc(sizeof(*both));
  both = (char **)myCIL___tmp;
  if ((unsigned long )both == (unsigned long )((void *)0)) {
    return ((char **)((void *)0));
  }
  *(both + 0) = (char *)((void *)0);
  lnum = 0;
  while ((unsigned long )*(left + lnum) != (unsigned long )((void *)0)) {
    rnum = 0;
    while ((unsigned long )*(right + rnum) != (unsigned long )((void *)0)) {
      temp = comsubs(*(left + lnum), *(right + rnum));
      if ((unsigned long )temp == (unsigned long )((void *)0)) {
        freelist(both);
        return ((char **)((void *)0));
      }
      both = addlists(both, temp);
      freelist(temp);
      if ((unsigned long )both == (unsigned long )((void *)0)) {
        return ((char **)((void *)0));
      }
      rnum = rnum + 1;
    }
    lnum = lnum + 1;
  }
  return (both);
}
}
static void resetmust(must *mp ) 
{ char myCIL___tmp ;
  char myCIL___tmp___0 ;

  {
  myCIL___tmp___0 = (char )'\000';
  *(mp->is + 0) = myCIL___tmp___0;
  myCIL___tmp = myCIL___tmp___0;
  *(mp->right + 0) = myCIL___tmp;
  *(mp->left + 0) = myCIL___tmp;
  freelist(mp->in);
  return;
}
}
static must must0  ;
static void dfamust(struct dfa *dfa___0 ) 
{ must *musts ;
  must *mp ;
  char *result ;
  int ri ;
  int i ;
  int exact ;
  token t ;
  struct dfamust *dm ;
  void *myCIL___tmp ;
  void *myCIL___tmp___0 ;
  void *myCIL___tmp___1 ;
  void *myCIL___tmp___2 ;
  void *myCIL___tmp___3 ;
  char myCIL___tmp___4 ;
  char myCIL___tmp___5 ;
  char **new ;
  must *lmp ;
  must *rmp ;
  int j ;
  int ln ;
  int rn ;
  int n ;
  int myCIL___tmp___6 ;
  size_t myCIL___tmp___7 ;
  size_t myCIL___tmp___8 ;
  size_t myCIL___tmp___9 ;
  size_t myCIL___tmp___10 ;
  int myCIL___tmp___11 ;
  must *lmp___0 ;
  must *rmp___0 ;
  char *tp ;
  size_t myCIL___tmp___12 ;
  char myCIL___tmp___13 ;
  char myCIL___tmp___14 ;
  char myCIL___tmp___15 ;
  char myCIL___tmp___16 ;
  void *myCIL___tmp___17 ;
  size_t myCIL___tmp___18 ;
  void *myCIL___tmp___19 ;
  size_t myCIL___tmp___20 ;

  {
  result = (char *)"";
  exact = 0;
  myCIL___tmp = malloc((unsigned long )(dfa___0->tindex + 1) * sizeof(*musts));
  musts = (must *)myCIL___tmp;
  if ((unsigned long )musts == (unsigned long )((void *)0)) {
    return;
  }
  mp = musts;
  i = 0;
  while (i <= dfa___0->tindex) {
    *(mp + i) = must0;
    i = i + 1;
  }
  i = 0;
  while (i <= dfa___0->tindex) {
    myCIL___tmp___0 = malloc(sizeof(*((mp + i)->in)));
    (mp + i)->in = (char **)myCIL___tmp___0;
    myCIL___tmp___1 = malloc(2UL);
    (mp + i)->left = (char *)myCIL___tmp___1;
    myCIL___tmp___2 = malloc(2UL);
    (mp + i)->right = (char *)myCIL___tmp___2;
    myCIL___tmp___3 = malloc(2UL);
    (mp + i)->is = (char *)myCIL___tmp___3;
    if ((unsigned long )(mp + i)->in == (unsigned long )((void *)0)) {
      goto done;
    } else {
      if ((unsigned long )(mp + i)->left == (unsigned long )((void *)0)) {
        goto done;
      } else {
        if ((unsigned long )(mp + i)->right == (unsigned long )((void *)0)) {
          goto done;
        } else {
          if ((unsigned long )(mp + i)->is == (unsigned long )((void *)0)) {
            goto done;
          }
        }
      }
    }
    myCIL___tmp___5 = (char )'\000';
    *((mp + i)->is + 0) = myCIL___tmp___5;
    myCIL___tmp___4 = myCIL___tmp___5;
    *((mp + i)->right + 0) = myCIL___tmp___4;
    *((mp + i)->left + 0) = myCIL___tmp___4;
    *((mp + i)->in + 0) = (char *)((void *)0);
    i = i + 1;
  }
  ri = 0;
  while (ri < dfa___0->tindex) {
    t = *(dfa___0->tokens + ri);
    switch ((int )t) {
    case 271: 
    case 272: 
    goto done;
    case 256: 
    case 258: 
    case 259: 
    case 260: 
    case 261: 
    case 262: 
    case 263: 
    case 257: 
    resetmust(mp);
    break;
    case 265: 
    case 264: 
    if ((unsigned long )mp <= (unsigned long )musts) {
      goto done;
    }
    mp = mp - 1;
    resetmust(mp);
    break;
    case 269: 
    case 270: 
    if ((unsigned long )mp < (unsigned long )(musts + 2)) {
      goto done;
    }
    mp = mp - 1;
    rmp = mp;
    mp = mp - 1;
    lmp = mp;
    myCIL___tmp___6 = strcmp((char *)lmp->is, (char *)rmp->is);
    if (myCIL___tmp___6 != 0) {
      *(lmp->is + 0) = (char )'\000';
    }
    i = 0;
    while (1) {
      if ((int )*(lmp->left + i) != 0) {
        if (! ((int )*(lmp->left + i) == (int )*(rmp->left + i))) {
          break;
        }
      } else {
        break;
      }
      i = i + 1;
    }
    *(lmp->left + i) = (char )'\000';
    myCIL___tmp___7 = strlen((char *)lmp->right);
    ln = (int )myCIL___tmp___7;
    myCIL___tmp___8 = strlen((char *)rmp->right);
    rn = (int )myCIL___tmp___8;
    n = ln;
    if (n > rn) {
      n = rn;
    }
    i = 0;
    while (i < n) {
      if ((int )*(lmp->right + ((ln - i) - 1)) != (int )*(rmp->right + ((rn - i) - 1))) {
        break;
      }
      i = i + 1;
    }
    j = 0;
    while (j < i) {
      *(lmp->right + j) = *(lmp->right + ((ln - i) + j));
      j = j + 1;
    }
    *(lmp->right + j) = (char )'\000';
    new = inboth(lmp->in, rmp->in);
    if ((unsigned long )new == (unsigned long )((void *)0)) {
      goto done;
    }
    freelist(lmp->in);
    lmp->in = new;
    break;
    case 266: 
    if ((unsigned long )mp <= (unsigned long )musts) {
      goto done;
    }
    mp = mp - 1;
    *(mp->is + 0) = (char )'\000';
    break;
    case -1: 
    if ((unsigned long )mp != (unsigned long )(musts + 1)) {
      goto done;
    }
    i = 0;
    while ((unsigned long )*((musts + 0)->in + i) != (unsigned long )((void *)0)) {
      myCIL___tmp___9 = strlen((char *)*((musts + 0)->in + i));
      myCIL___tmp___10 = strlen((char *)result);
      if (myCIL___tmp___9 > myCIL___tmp___10) {
        result = *((musts + 0)->in + i);
      }
      i = i + 1;
    }
    myCIL___tmp___11 = strcmp((char *)result, (char *)(musts + 0)->is);
    if (myCIL___tmp___11 == 0) {
      exact = 1;
    }
    goto done;
    case 268: 
    if ((unsigned long )mp < (unsigned long )(musts + 2)) {
      goto done;
    }
    mp = mp - 1;
    rmp___0 = mp;
    mp = mp - 1;
    lmp___0 = mp;
    lmp___0->in = addlists(lmp___0->in, rmp___0->in);
    if ((unsigned long )lmp___0->in == (unsigned long )((void *)0)) {
      goto done;
    }
    if ((int )*(lmp___0->right + 0) != 0) {
      if ((int )*(rmp___0->left + 0) != 0) {
        tp = icpyalloc(lmp___0->right);
        if ((unsigned long )tp == (unsigned long )((void *)0)) {
          goto done;
        }
        tp = icatalloc(tp, rmp___0->left);
        if ((unsigned long )tp == (unsigned long )((void *)0)) {
          goto done;
        }
        myCIL___tmp___12 = strlen((char *)tp);
        lmp___0->in = enlist(lmp___0->in, tp, (int )myCIL___tmp___12);
        if ((unsigned long )lmp___0->in == (unsigned long )((void *)0)) {
          goto done;
        }
      }
    }
    if ((int )*(lmp___0->is + 0) != 0) {
      lmp___0->left = icatalloc(lmp___0->left, rmp___0->left);
      if ((unsigned long )lmp___0->left == (unsigned long )((void *)0)) {
        goto done;
      }
    }
    if ((int )*(rmp___0->is + 0) == 0) {
      *(lmp___0->right + 0) = (char )'\000';
    }
    lmp___0->right = icatalloc(lmp___0->right, rmp___0->right);
    if ((unsigned long )lmp___0->right == (unsigned long )((void *)0)) {
      goto done;
    }
    if ((int )*(lmp___0->is + 0) != 0) {
      if ((int )*(rmp___0->is + 0) != 0) {
        lmp___0->is = icatalloc(lmp___0->is, rmp___0->is);
        if ((unsigned long )lmp___0->is == (unsigned long )((void *)0)) {
          goto done;
        }
      } else {
        *(lmp___0->is + 0) = (char )'\000';
      }
    } else {
      *(lmp___0->is + 0) = (char )'\000';
    }
    break;
    default: ;
    if ((int )t < -1) {
      goto done;
    } else {
      if ((int )t == 0) {
        goto done;
      } else {
        if ((int )t >= 273) {
          resetmust(mp);
        } else {
          resetmust(mp);
          myCIL___tmp___14 = (char )t;
          *(mp->right + 0) = myCIL___tmp___14;
          myCIL___tmp___13 = myCIL___tmp___14;
          *(mp->left + 0) = myCIL___tmp___13;
          *(mp->is + 0) = myCIL___tmp___13;
          myCIL___tmp___16 = (char )'\000';
          *(mp->right + 1) = myCIL___tmp___16;
          myCIL___tmp___15 = myCIL___tmp___16;
          *(mp->left + 1) = myCIL___tmp___15;
          *(mp->is + 1) = myCIL___tmp___15;
          mp->in = enlist(mp->in, mp->is, 1);
          if ((unsigned long )mp->in == (unsigned long )((void *)0)) {
            goto done;
          }
        }
      }
    }
    break;
    }
    mp = mp + 1;
    ri = ri + 1;
  }
  done: 
  myCIL___tmp___20 = strlen((char *)result);
  if (myCIL___tmp___20) {
    myCIL___tmp___17 = malloc(sizeof(struct dfamust ));
    dm = (struct dfamust *)myCIL___tmp___17;
    dm->exact = exact;
    myCIL___tmp___18 = strlen((char *)result);
    myCIL___tmp___19 = malloc(myCIL___tmp___18 + 1UL);
    dm->must = (char *)myCIL___tmp___19;
    strcpy((char *)dm->must, (char *)result);
    dm->next = dfa___0->musts;
    dfa___0->musts = dm;
  }
  mp = musts;
  i = 0;
  while (i <= dfa___0->tindex) {
    freelist((mp + i)->in);
    ifree((char *)(mp + i)->in);
    ifree((mp + i)->left);
    ifree((mp + i)->right);
    ifree((mp + i)->is);
    i = i + 1;
  }
  return;
}
}
kwset_t kwsalloc(char *trans ) ;
char *kwsincr(kwset_t kws , char *text , size_t len ) ;
char *kwsprep(kwset_t kws ) ;
char *kwsexec(kwset_t kws , char *text , size_t size , struct kwsmatch *kwsmatch ) ;
void kwsfree(kwset_t kws ) ;
extern void _obstack_newchunk(struct obstack * , int  ) ;
extern void _obstack_begin(struct obstack * , int  , int  , void *(*)() , void (*)() ) ;
extern void obstack_free(struct obstack *obstack , void *block ) ;
kwset_t kwsalloc(char *trans ) 
{ struct kwset *kwset ;
  char *myCIL___tmp ;
  struct obstack *myh ;
  struct obstack *o ;
  int len ;
  struct obstack *o1 ;
  void *value ;

  {
  myCIL___tmp = xmalloc(sizeof(struct kwset ));
  kwset = (struct kwset *)myCIL___tmp;
  if (! kwset) {
    return ((void *)0);
  }
  kwset->words = 0;
  myh = & kwset->obstack;
  o = myh;
  len = (int )sizeof(struct trie );
  if (o->chunk_limit - o->next_free < len) {
    _obstack_newchunk(o, len);
  }
  o->next_free = o->next_free + len;
  o1 = myh;
  value = (void *)o1->object_base;
  if ((unsigned long )o1->next_free == (unsigned long )value) {
    o1->maybe_empty_object = 1U;
  }
  o1->next_free = (char *)0 + (((o1->next_free - (char *)0) + o1->alignment_mask) & ~ o1->alignment_mask);
  if (o1->next_free - (char *)o1->chunk > o1->chunk_limit - (char *)o1->chunk) {
    o1->next_free = o1->chunk_limit;
  }
  o1->object_base = o1->next_free;
  kwset->trie = (struct trie *)value;
  if (! kwset->trie) {
    kwsfree((void *)kwset);
    return ((void *)0);
  }
  (kwset->trie)->accepting = 0U;
  (kwset->trie)->links = (struct tree *)0;
  (kwset->trie)->parent = (struct trie *)0;
  (kwset->trie)->next = (struct trie *)0;
  (kwset->trie)->fail = (struct trie *)0;
  (kwset->trie)->depth = 0;
  (kwset->trie)->shift = 0;
  kwset->mind = 2147483647;
  kwset->maxd = -1;
  kwset->target = (char *)0;
  kwset->trans = trans;
  return ((void *)kwset);
}
}
char *kwsincr(kwset_t kws , char *text , size_t len ) 
{ struct kwset *kwset ;
  register struct trie *trie ;
  register unsigned char label ;
  register struct tree *link___0 ;
  register int depth___0 ;
  struct tree *links[12] ;
  enum __anonenum_dirs_40 dirs[12] ;
  struct tree *t ;
  struct tree *r ;
  struct tree *l ;
  struct tree *rl ;
  struct tree *lr ;
  int myCIL___tmp ;
  int myCIL___tmp___0 ;
  struct obstack *us__h ;
  struct obstack *us__o ;
  int us__len ;
  struct obstack *us__o1 ;
  void *value ;
  struct obstack *us__h___0 ;
  struct obstack *us__o___0 ;
  int us__len___0 ;
  struct obstack *us__o1___0 ;
  void *value___0 ;
  char myCIL___tmp___1 ;
  char myCIL___tmp___2 ;
  size_t myCIL___tmp___3 ;

  {
  kwset = (struct kwset *)kws;
  trie = kwset->trie;
  text = text + len;
  while (1) {
    myCIL___tmp___3 = len;
    len = len - 1UL;
    if (! myCIL___tmp___3) {
      break;
    }
    if (kwset->trans) {
      text = text - 1;
      label = (unsigned char )*(kwset->trans + (unsigned char )*text);
    } else {
      text = text - 1;
      label = (unsigned char )*text;
    }
    link___0 = trie->links;
    links[0] = (struct tree *)(& trie->links);
    dirs[0] = 0;
    depth___0 = 1;
    while (1) {
      if (link___0) {
        if (! ((int )label != (int )link___0->label)) {
          break;
        }
      } else {
        break;
      }
      links[depth___0] = link___0;
      if ((int )label < (int )link___0->label) {
        myCIL___tmp = depth___0;
        depth___0 = depth___0 + 1;
        dirs[myCIL___tmp] = 0;
        link___0 = link___0->llink;
      } else {
        myCIL___tmp___0 = depth___0;
        depth___0 = depth___0 + 1;
        dirs[myCIL___tmp___0] = 1;
        link___0 = link___0->rlink;
      }
    }
    if (! link___0) {
      us__h = & kwset->obstack;
      us__o = us__h;
      us__len = (int )sizeof(struct tree );
      if (us__o->chunk_limit - us__o->next_free < us__len) {
        _obstack_newchunk(us__o, us__len);
      }
      us__o->next_free = us__o->next_free + us__len;
      us__o1 = us__h;
      value = (void *)us__o1->object_base;
      if ((unsigned long )us__o1->next_free == (unsigned long )value) {
        us__o1->maybe_empty_object = 1U;
      }
      us__o1->next_free = (char *)0 + (((us__o1->next_free - (char *)0) + us__o1->alignment_mask) & ~ us__o1->alignment_mask);
      if (us__o1->next_free - (char *)us__o1->chunk > us__o1->chunk_limit - (char *)us__o1->chunk) {
        us__o1->next_free = us__o1->chunk_limit;
      }
      us__o1->object_base = us__o1->next_free;
      link___0 = (struct tree *)value;
      if (! link___0) {
        return ((char *)"memory exhausted");
      }
      link___0->llink = (struct tree *)0;
      link___0->rlink = (struct tree *)0;
      us__h___0 = & kwset->obstack;
      us__o___0 = us__h___0;
      us__len___0 = (int )sizeof(struct trie );
      if (us__o___0->chunk_limit - us__o___0->next_free < us__len___0) {
        _obstack_newchunk(us__o___0, us__len___0);
      }
      us__o___0->next_free = us__o___0->next_free + us__len___0;
      us__o1___0 = us__h___0;
      value___0 = (void *)us__o1___0->object_base;
      if ((unsigned long )us__o1___0->next_free == (unsigned long )value___0) {
        us__o1___0->maybe_empty_object = 1U;
      }
      us__o1___0->next_free = (char *)0 + (((us__o1___0->next_free - (char *)0) + us__o1___0->alignment_mask) & ~ us__o1___0->alignment_mask);
      if (us__o1___0->next_free - (char *)us__o1___0->chunk > us__o1___0->chunk_limit - (char *)us__o1___0->chunk) {
        us__o1___0->next_free = us__o1___0->chunk_limit;
      }
      us__o1___0->object_base = us__o1___0->next_free;
      link___0->trie = (struct trie *)value___0;
      if (! link___0->trie) {
        return ((char *)"memory exhausted");
      }
      (link___0->trie)->accepting = 0U;
      (link___0->trie)->links = (struct tree *)0;
      (link___0->trie)->parent = trie;
      (link___0->trie)->next = (struct trie *)0;
      (link___0->trie)->fail = (struct trie *)0;
      (link___0->trie)->depth = trie->depth + 1;
      (link___0->trie)->shift = 0;
      link___0->label = label;
      link___0->balance = (char)0;
      depth___0 = depth___0 - 1;
      if ((unsigned int )dirs[depth___0] == 0U) {
        (links[depth___0])->llink = link___0;
      } else {
        (links[depth___0])->rlink = link___0;
      }
      while (1) {
        if (depth___0) {
          if (! (! (links[depth___0])->balance)) {
            break;
          }
        } else {
          break;
        }
        if ((unsigned int )dirs[depth___0] == 0U) {
          (links[depth___0])->balance = (char )((int )(links[depth___0])->balance - 1);
        } else {
          (links[depth___0])->balance = (char )((int )(links[depth___0])->balance + 1);
        }
        depth___0 = depth___0 - 1;
      }
      if (depth___0) {
        if ((unsigned int )dirs[depth___0] == 0U) {
          (links[depth___0])->balance = (char )((int )(links[depth___0])->balance - 1);
          if ((links[depth___0])->balance) {
            goto _L;
          } else {
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
          if ((unsigned int )dirs[depth___0] == 1U) {
            (links[depth___0])->balance = (char )((int )(links[depth___0])->balance + 1);
            if ((links[depth___0])->balance) {
              _L: /* CIL Label */ 
              switch ((int )(links[depth___0])->balance) {
              case (char)-2: 
              switch ((int )dirs[depth___0 + 1]) {
              case 0: 
              r = links[depth___0];
              t = r->llink;
              rl = t->rlink;
              t->rlink = r;
              r->llink = rl;
              myCIL___tmp___1 = (char)0;
              r->balance = myCIL___tmp___1;
              t->balance = myCIL___tmp___1;
              break;
              case 1: 
              r = links[depth___0];
              l = r->llink;
              t = l->rlink;
              rl = t->rlink;
              lr = t->llink;
              t->llink = l;
              l->rlink = lr;
              t->rlink = r;
              r->llink = rl;
              if ((int )t->balance != 1) {
                l->balance = (char)0;
              } else {
                l->balance = (char)-1;
              }
              if ((int )t->balance != -1) {
                r->balance = (char)0;
              } else {
                r->balance = (char)1;
              }
              t->balance = (char)0;
              break;
              }
              break;
              case 2: 
              switch ((int )dirs[depth___0 + 1]) {
              case 1: 
              l = links[depth___0];
              t = l->rlink;
              lr = t->llink;
              t->llink = l;
              l->rlink = lr;
              myCIL___tmp___2 = (char)0;
              l->balance = myCIL___tmp___2;
              t->balance = myCIL___tmp___2;
              break;
              case 0: 
              l = links[depth___0];
              r = l->rlink;
              t = r->llink;
              lr = t->llink;
              rl = t->rlink;
              t->llink = l;
              l->rlink = lr;
              t->rlink = r;
              r->llink = rl;
              if ((int )t->balance != 1) {
                l->balance = (char)0;
              } else {
                l->balance = (char)-1;
              }
              if ((int )t->balance != -1) {
                r->balance = (char)0;
              } else {
                r->balance = (char)1;
              }
              t->balance = (char)0;
              break;
              }
              break;
              }
              if ((unsigned int )dirs[depth___0 - 1] == 0U) {
                (links[depth___0 - 1])->llink = t;
              } else {
                (links[depth___0 - 1])->rlink = t;
              }
            }
          }
        }
      }
    }
    trie = link___0->trie;
  }
  if (! trie->accepting) {
    trie->accepting = (unsigned int )(1 + 2 * kwset->words);
  }
  kwset->words = kwset->words + 1;
  if (trie->depth < kwset->mind) {
    kwset->mind = trie->depth;
  }
  if (trie->depth > kwset->maxd) {
    kwset->maxd = trie->depth;
  }
  return ((char *)0);
}
}
static void enqueue(struct tree *tree , struct trie **last ) 
{ struct trie *myCIL___tmp ;

  {
  if (! tree) {
    return;
  }
  enqueue(tree->llink, last);
  enqueue(tree->rlink, last);
  myCIL___tmp = tree->trie;
  (*last)->next = myCIL___tmp;
  *last = myCIL___tmp;
  return;
}
}
static void treefails(struct tree *tree , struct trie *fail , struct trie *recourse ) 
{ register struct tree *link___0 ;

  {
  if (! tree) {
    return;
  }
  treefails(tree->llink, fail, recourse);
  treefails(tree->rlink, fail, recourse);
  while (fail) {
    link___0 = fail->links;
    while (1) {
      if (link___0) {
        if (! ((int )tree->label != (int )link___0->label)) {
          break;
        }
      } else {
        break;
      }
      if ((int )tree->label < (int )link___0->label) {
        link___0 = link___0->llink;
      } else {
        link___0 = link___0->rlink;
      }
    }
    if (link___0) {
      (tree->trie)->fail = link___0->trie;
      return;
    }
    fail = fail->fail;
  }
  (tree->trie)->fail = recourse;
  return;
}
}
static void treedelta(struct tree *tree , unsigned int depth___0 , unsigned char *delta ) 
{ 

  {
  if (! tree) {
    return;
  }
  treedelta(tree->llink, depth___0, delta);
  treedelta(tree->rlink, depth___0, delta);
  if (depth___0 < (unsigned int )*(delta + tree->label)) {
    *(delta + tree->label) = (unsigned char )depth___0;
  }
  return;
}
}
static int hasevery(struct tree *a , struct tree *b ) 
{ int myCIL___tmp ;
  int myCIL___tmp___0 ;

  {
  if (! b) {
    return (1);
  }
  myCIL___tmp = hasevery(a, b->llink);
  if (! myCIL___tmp) {
    return (0);
  }
  myCIL___tmp___0 = hasevery(a, b->rlink);
  if (! myCIL___tmp___0) {
    return (0);
  }
  while (1) {
    if (a) {
      if (! ((int )b->label != (int )a->label)) {
        break;
      }
    } else {
      break;
    }
    if ((int )b->label < (int )a->label) {
      a = a->llink;
    } else {
      a = a->rlink;
    }
  }
  return (! (! a));
}
}
static void treenext(struct tree *tree , struct trie **next ) 
{ 

  {
  if (! tree) {
    return;
  }
  treenext(tree->llink, next);
  treenext(tree->rlink, next);
  *(next + tree->label) = tree->trie;
  return;
}
}
char *kwsprep(kwset_t kws ) 
{ register struct kwset *kwset ;
  register int i ;
  register struct trie *curr ;
  register struct trie *fail ;
  register char *trans ;
  unsigned char delta[256] ;
  struct trie *last ;
  struct trie *next[256] ;
  struct obstack *myh ;
  struct obstack *o ;
  int len ;
  struct obstack *o1 ;
  void *value ;
  int myCIL___tmp ;

  {
  kwset = (struct kwset *)kws;
  if (kwset->mind < 256) {
    i = 0;
    while (i < 256) {
      delta[i] = (unsigned char )kwset->mind;
      i = i + 1;
    }
  } else {
    i = 0;
    while (i < 256) {
      delta[i] = (unsigned char)255;
      i = i + 1;
    }
  }
  if (kwset->words == 1) {
    if ((unsigned long )kwset->trans == (unsigned long )((char *)0)) {
      myh = & kwset->obstack;
      o = myh;
      len = kwset->mind;
      if (o->chunk_limit - o->next_free < len) {
        _obstack_newchunk(o, len);
      }
      o->next_free = o->next_free + len;
      o1 = myh;
      value = (void *)o1->object_base;
      if ((unsigned long )o1->next_free == (unsigned long )value) {
        o1->maybe_empty_object = 1U;
      }
      o1->next_free = (char *)0 + (((o1->next_free - (char *)0) + o1->alignment_mask) & ~ o1->alignment_mask);
      if (o1->next_free - (char *)o1->chunk > o1->chunk_limit - (char *)o1->chunk) {
        o1->next_free = o1->chunk_limit;
      }
      o1->object_base = o1->next_free;
      kwset->target = (char *)value;
      i = kwset->mind - 1;
      curr = kwset->trie;
      while (i >= 0) {
        *(kwset->target + i) = (char )(curr->links)->label;
        curr = (curr->links)->trie;
        i = i - 1;
      }
      i = 0;
      while (i < kwset->mind) {
        delta[(unsigned char )*(kwset->target + i)] = (unsigned char )(kwset->mind - (i + 1));
        i = i + 1;
      }
      kwset->mind2 = kwset->mind;
      i = 0;
      while (i < kwset->mind - 1) {
        if ((int )*(kwset->target + i) == (int )*(kwset->target + (kwset->mind - 1))) {
          kwset->mind2 = kwset->mind - (i + 1);
        }
        i = i + 1;
      }
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    last = kwset->trie;
    curr = last;
    while (curr) {
      enqueue(curr->links, & last);
      curr->shift = kwset->mind;
      curr->maxshift = kwset->mind;
      treedelta(curr->links, (unsigned int )curr->depth, delta);
      treefails(curr->links, curr->fail, kwset->trie);
      fail = curr->fail;
      while (fail) {
        myCIL___tmp = hasevery(fail->links, curr->links);
        if (! myCIL___tmp) {
          if (curr->depth - fail->depth < fail->shift) {
            fail->shift = curr->depth - fail->depth;
          }
        }
        if (curr->accepting) {
          if (fail->maxshift > curr->depth - fail->depth) {
            fail->maxshift = curr->depth - fail->depth;
          }
        }
        fail = fail->fail;
      }
      curr = curr->next;
    }
    curr = (kwset->trie)->next;
    while (curr) {
      if (curr->maxshift > (curr->parent)->maxshift) {
        curr->maxshift = (curr->parent)->maxshift;
      }
      if (curr->shift > curr->maxshift) {
        curr->shift = curr->maxshift;
      }
      curr = curr->next;
    }
    i = 0;
    while (i < 256) {
      next[i] = (struct trie *)0;
      i = i + 1;
    }
    treenext((kwset->trie)->links, next);
    trans = kwset->trans;
    if ((unsigned long )trans != (unsigned long )((char *)0)) {
      i = 0;
      while (i < 256) {
        kwset->next[i] = next[(unsigned char )*(trans + i)];
        i = i + 1;
      }
    } else {
      i = 0;
      while (i < 256) {
        kwset->next[i] = next[i];
        i = i + 1;
      }
    }
  }
  trans = kwset->trans;
  if ((unsigned long )trans != (unsigned long )((char *)0)) {
    i = 0;
    while (i < 256) {
      kwset->delta[i] = delta[(unsigned char )*(trans + i)];
      i = i + 1;
    }
  } else {
    i = 0;
    while (i < 256) {
      kwset->delta[i] = delta[i];
      i = i + 1;
    }
  }
  return ((char *)0);
}
}
static char *bmexec(kwset_t kws , char *text , size_t size ) 
{ struct kwset *kwset ;
  register unsigned char *d1 ;
  register char *ep ;
  register char *sp ;
  register char *tp ;
  register int d ;
  register int gc ;
  register int i ;
  register int len ;
  register int md2 ;
  void *myCIL___tmp ;

  {
  kwset = (struct kwset *)kws;
  len = kwset->mind;
  if (len == 0) {
    return (text);
  }
  if ((size_t )len > size) {
    return ((char *)0);
  }
  if (len == 1) {
    myCIL___tmp = memchr((void *)text, (int )*(kwset->target + 0), size);
    return ((char *)myCIL___tmp);
  }
  d1 = kwset->delta;
  sp = kwset->target + len;
  gc = (int )((unsigned char )*(sp + -2));
  md2 = kwset->mind2;
  tp = text + len;
  if (size > (size_t )(12 * len)) {
    ep = (text + size) - 11 * len;
    while (1) {
      while ((unsigned long )tp <= (unsigned long )ep) {
        d = (int )*(d1 + (unsigned char )*(tp + -1));
        tp = tp + d;
        d = (int )*(d1 + (unsigned char )*(tp + -1));
        tp = tp + d;
        if (d == 0) {
          goto found;
        }
        d = (int )*(d1 + (unsigned char )*(tp + -1));
        tp = tp + d;
        d = (int )*(d1 + (unsigned char )*(tp + -1));
        tp = tp + d;
        d = (int )*(d1 + (unsigned char )*(tp + -1));
        tp = tp + d;
        if (d == 0) {
          goto found;
        }
        d = (int )*(d1 + (unsigned char )*(tp + -1));
        tp = tp + d;
        d = (int )*(d1 + (unsigned char )*(tp + -1));
        tp = tp + d;
        d = (int )*(d1 + (unsigned char )*(tp + -1));
        tp = tp + d;
        if (d == 0) {
          goto found;
        }
        d = (int )*(d1 + (unsigned char )*(tp + -1));
        tp = tp + d;
        d = (int )*(d1 + (unsigned char )*(tp + -1));
        tp = tp + d;
      }
      break;
      found: 
      if ((int )((unsigned char )*(tp + -2)) == gc) {
        i = 3;
        while (1) {
          if (i <= len) {
            if (! ((int )((unsigned char )*(tp + - i)) == (int )((unsigned char )*(sp + - i)))) {
              break;
            }
          } else {
            break;
          }
          i = i + 1;
        }
        if (i > len) {
          return (tp - len);
        }
      }
      tp = tp + md2;
    }
  }
  ep = text + size;
  d = (int )*(d1 + (unsigned char )*(tp + -1));
  while (d <= ep - tp) {
    tp = tp + d;
    d = (int )*(d1 + (unsigned char )*(tp + -1));
    if (d != 0) {
      continue;
    }
    if ((int )*(tp + -2) == gc) {
      i = 3;
      while (1) {
        if (i <= len) {
          if (! ((int )((unsigned char )*(tp + - i)) == (int )((unsigned char )*(sp + - i)))) {
            break;
          }
        } else {
          break;
        }
        i = i + 1;
      }
      if (i > len) {
        return (tp - len);
      }
    }
    d = md2;
  }
  return ((char *)0);
}
}
static char *cwexec(kwset_t kws , char *text , size_t len , struct kwsmatch *kwsmatch ) 
{ struct kwset *kwset ;
  struct trie **next ;
  struct trie *trie ;
  struct trie *accept ;
  char *beg ;
  char *lim ;
  char *mch ;
  char *lmch ;
  register unsigned char c ;
  register unsigned char *delta ;
  register int d ;
  register char *end ;
  register char *qlim ;
  register struct tree *tree ;
  register char *trans ;

  {
  kwset = (struct kwset *)kws;
  if (len < (size_t )kwset->mind) {
    return ((char *)0);
  }
  next = kwset->next;
  delta = kwset->delta;
  trans = kwset->trans;
  lim = text + len;
  end = text;
  d = kwset->mind;
  if (d != 0) {
    mch = (char *)0;
  } else {
    mch = text;
    accept = kwset->trie;
    goto match;
  }
  if (len >= (size_t )(4 * kwset->mind)) {
    qlim = lim - 4 * kwset->mind;
  } else {
    qlim = (char *)0;
  }
  while (lim - end >= d) {
    if (qlim) {
      if ((unsigned long )end <= (unsigned long )qlim) {
        end = end + (d - 1);
        while (1) {
          c = (unsigned char )*end;
          d = (int )*(delta + c);
          if (d) {
            if (! ((unsigned long )end < (unsigned long )qlim)) {
              break;
            }
          } else {
            break;
          }
          end = end + d;
          end = end + (int )*(delta + (unsigned char )*end);
          end = end + (int )*(delta + (unsigned char )*end);
        }
        end = end + 1;
      } else {
        end = end + d;
        c = (unsigned char )*(end + -1);
        d = (int )*(delta + c);
      }
    } else {
      end = end + d;
      c = (unsigned char )*(end + -1);
      d = (int )*(delta + c);
    }
    if (d) {
      continue;
    }
    beg = end - 1;
    trie = *(next + c);
    if (trie->accepting) {
      mch = beg;
      accept = trie;
    }
    d = trie->shift;
    while ((unsigned long )beg > (unsigned long )text) {
      if (trans) {
        beg = beg - 1;
        c = (unsigned char )*(trans + (unsigned char )*beg);
      } else {
        beg = beg - 1;
        c = (unsigned char )*beg;
      }
      tree = trie->links;
      while (1) {
        if (tree) {
          if (! ((int )c != (int )tree->label)) {
            break;
          }
        } else {
          break;
        }
        if ((int )c < (int )tree->label) {
          tree = tree->llink;
        } else {
          tree = tree->rlink;
        }
      }
      if (tree) {
        trie = tree->trie;
        if (trie->accepting) {
          mch = beg;
          accept = trie;
        }
      } else {
        break;
      }
      d = trie->shift;
    }
    if (mch) {
      goto match;
    }
  }
  return ((char *)0);
  match: 
  if (lim - mch > kwset->maxd) {
    lim = mch + kwset->maxd;
  }
  lmch = (char *)0;
  d = 1;
  while (lim - end >= d) {
    end = end + d;
    c = (unsigned char )*(end + -1);
    d = (int )*(delta + c);
    if (d != 0) {
      continue;
    }
    beg = end - 1;
    trie = *(next + c);
    if (! trie) {
      d = 1;
      continue;
    }
    if (trie->accepting) {
      if ((unsigned long )beg <= (unsigned long )mch) {
        lmch = beg;
        accept = trie;
      }
    }
    d = trie->shift;
    while ((unsigned long )beg > (unsigned long )text) {
      if (trans) {
        beg = beg - 1;
        c = (unsigned char )*(trans + (unsigned char )*beg);
      } else {
        beg = beg - 1;
        c = (unsigned char )*beg;
      }
      tree = trie->links;
      while (1) {
        if (tree) {
          if (! ((int )c != (int )tree->label)) {
            break;
          }
        } else {
          break;
        }
        if ((int )c < (int )tree->label) {
          tree = tree->llink;
        } else {
          tree = tree->rlink;
        }
      }
      if (tree) {
        trie = tree->trie;
        if (trie->accepting) {
          if ((unsigned long )beg <= (unsigned long )mch) {
            lmch = beg;
            accept = trie;
          }
        }
      } else {
        break;
      }
      d = trie->shift;
    }
    if (lmch) {
      mch = lmch;
      goto match;
    }
    if (! d) {
      d = 1;
    }
  }
  if (kwsmatch) {
    kwsmatch->strchr = (int )(accept->accepting / 2U);
    kwsmatch->beg[0] = mch;
    kwsmatch->size[0] = (unsigned long )accept->depth;
  }
  return (mch);
}
}
char *kwsexec(kwset_t kws , char *text , size_t size , struct kwsmatch *kwsmatch ) 
{ struct kwset *kwset ;
  char *ret ;
  char *myCIL___tmp ;

  {
  kwset = (struct kwset *)kws;
  if (kwset->words == 1) {
    if ((unsigned long )kwset->trans == (unsigned long )((char *)0)) {
      ret = bmexec(kws, text, size);
      if ((unsigned long )kwsmatch != (unsigned long )((struct kwsmatch *)0)) {
        if ((unsigned long )ret != (unsigned long )((char *)0)) {
          kwsmatch->strchr = 0;
          kwsmatch->beg[0] = ret;
          kwsmatch->size[0] = (unsigned long )kwset->mind;
        }
      }
      return (ret);
    } else {
      myCIL___tmp = cwexec(kws, text, size, kwsmatch);
      return (myCIL___tmp);
    }
  } else {
    myCIL___tmp = cwexec(kws, text, size, kwsmatch);
    return (myCIL___tmp);
  }
}
}
void kwsfree(kwset_t kws ) 
{ struct kwset *kwset ;
  struct obstack *o ;
  void *obj ;
  char *myCIL___tmp ;

  {
  kwset = (struct kwset *)kws;
  o = & kwset->obstack;
  obj = (void *)0;
  if ((unsigned long )obj > (unsigned long )((void *)o->chunk)) {
    if ((unsigned long )obj < (unsigned long )((void *)o->chunk_limit)) {
      myCIL___tmp = (char *)obj;
      o->object_base = myCIL___tmp;
      o->next_free = myCIL___tmp;
    } else {
      obstack_free(o, obj);
    }
  } else {
    obstack_free(o, obj);
  }
  return;
}
}
static void Gcompile(char *pattern , size_t size ) ;
static void Ecompile(char *pattern , size_t size ) ;
static char *EGexecute(char *buf , size_t size , char **endp ) ;
static void Fcompile(char *pattern , size_t size ) ;
static char *Fexecute(char *buf , size_t size , char **endp ) ;
struct matcher matchers[9]  ; //= 
//  {      {(char *)"default", & Gcompile, & EGexecute}, 
//        {(char *)"grep", & Gcompile, & EGexecute}, 
//        {(char *)"ggrep", & Gcompile, & EGexecute}, 
//        {(char *)"egrep", & Ecompile, & EGexecute}, 
//        {(char *)"posix-egrep", & Ecompile, & EGexecute}, 
//        {(char *)"gegrep", & Ecompile, & EGexecute}, 
//        {(char *)"fgrep", & Fcompile, & Fexecute}, 
//        {(char *)"gfgrep", & Fcompile, & Fexecute}, 
//        {(char *)0, (void (*)(char * , size_t  ))0, (char *(*)(char * , size_t  , char ** ))0}};
static struct dfa dfa_1  ;
static struct re_pattern_buffer regex  ;
static kwset_t kwset  ;
static int lastexact  ;
void dfaerror(char *mesg ) 
{ 

  {
  fatal((char *)mesg, 0);
  return;
}
}
static char trans[256]  ;
static void kwsinit(void) 
{ int i ;
  int myCIL___tmp___0 ;
  unsigned short **myCIL___tmp___1 ;
  char *myCIL___tmp___2 ;

  {
  if (match_icase) {
    i = 0;
    while (i < 256) {
      myCIL___tmp___1 = __ctype_b_loc();
      if ((int )*(*myCIL___tmp___1 + i) & 256) {
        myCIL___tmp___0 = tolower(i);
        trans[i] = (char )myCIL___tmp___0;
      } else {
        trans[i] = (char )i;
      }
      i = i + 1;
    }
  }
  if (match_icase) {
    myCIL___tmp___2 = trans;
  } else {
    myCIL___tmp___2 = (char *)0;
  }
  kwset = kwsalloc(myCIL___tmp___2);
  if (! kwset) {
    fatal("memory exhausted", 0);
  }
  return;
}
}
static void kwsmusts(void) 
{ struct dfamust *dm ;
  char *err ;
  size_t myCIL___tmp ;
  size_t myCIL___tmp___0 ;

  {
  if (dfa_1.musts) {
    kwsinit();
    dm = dfa_1.musts;
    while (dm) {
      if (! dm->exact) {
        goto __Cont;
      }
      lastexact = lastexact + 1;
      myCIL___tmp = strlen((char *)dm->must);
      err = kwsincr(kwset, dm->must, myCIL___tmp);
      if ((unsigned long )err != (unsigned long )((char *)0)) {
        fatal((char *)err, 0);
      }
      __Cont: /* CIL Label */ 
      dm = dm->next;
    }
    dm = dfa_1.musts;
    while (dm) {
      if (dm->exact) {
        goto __Cont___0;
      }
      myCIL___tmp___0 = strlen((char *)dm->must);
      err = kwsincr(kwset, dm->must, myCIL___tmp___0);
      if ((unsigned long )err != (unsigned long )((char *)0)) {
        fatal((char *)err, 0);
      }
      __Cont___0: /* CIL Label */ 
      dm = dm->next;
    }
    err = kwsprep(kwset);
    if ((unsigned long )err != (unsigned long )((char *)0)) {
      fatal((char *)err, 0);
    }
  }
  return;
}
}
static void Gcompile(char *pattern , size_t size ) 
{ char *err ;
  char *n ;
  char *myCIL___tmp ;
  int i ;
  size_t myCIL___tmp___0 ;
  size_t myCIL___tmp___1 ;

  {
  re_set_syntax((unsigned int )((((((1 << 1) | ((1 << 1) << 1)) | ((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)));
  dfasyntax((((((1 << 1) | ((1 << 1) << 1)) | ((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1), match_icase);
  err = re_compile_pattern((char *)pattern, (int )size, & regex);
  if ((unsigned long )err != (unsigned long )((char *)0)) {
    fatal(err, 0);
  }
  dfainit(& dfa_1);
  if (match_words) {
    goto _L;
  } else {
    if (match_lines) {
      _L: /* CIL Label */ 
      myCIL___tmp = xmalloc(size + 50UL);
      n = myCIL___tmp;
      i = 0;
      strcpy((char *)n, (char *)"");
      if (match_lines) {
        strcpy((char *)n, (char *)"^\\(");
      }
      if (match_words) {
        strcpy((char *)n, (char *)"\\(^\\|[^0-9A-Za-z_]\\)\\(");
      }
      myCIL___tmp___0 = strlen((char *)n);
      i = (int )myCIL___tmp___0;
      memcpy((void *)(n + i), (void *)pattern, size);
      i = (int )((size_t )i + size);
      if (match_words) {
        strcpy((char *)(n + i), (char *)"\\)\\([^0-9A-Za-z_]\\|$\\)");
      }
      if (match_lines) {
        strcpy((char *)(n + i), (char *)"\\)$");
      }
      myCIL___tmp___1 = strlen((char *)(n + i));
      i = (int )((size_t )i + myCIL___tmp___1);
      dfacomp(n, (unsigned long )i, & dfa_1, 1);
    } else {
      dfacomp(pattern, size, & dfa_1, 1);
    }
  }
  kwsmusts();
  return;
}
}
static void Ecompile(char *pattern , size_t size ) 
{ char *err ;
  int myCIL___tmp ;
  char *n ;
  char *myCIL___tmp___0 ;
  int i ;
  size_t myCIL___tmp___1 ;
  size_t myCIL___tmp___2 ;

  {
  myCIL___tmp = strcmp((char *)matcher, "posix-egrep");
  if (myCIL___tmp == 0) {
    re_set_syntax((unsigned int )((((((((((1 << 1) << 1) | (((1 << 1) << 1) << 1)) | ((((1 << 1) << 1) << 1) << 1)) | ((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)));
    dfasyntax((((((((((1 << 1) << 1) | (((1 << 1) << 1) << 1)) | ((((1 << 1) << 1) << 1) << 1)) | ((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1), match_icase);
  } else {
    re_set_syntax((unsigned int )((((((((1 << 1) << 1) | (((1 << 1) << 1) << 1)) | ((((1 << 1) << 1) << 1) << 1)) | ((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)));
    dfasyntax((((((((1 << 1) << 1) | (((1 << 1) << 1) << 1)) | ((((1 << 1) << 1) << 1) << 1)) | ((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1 << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1), match_icase);
  }
  err = re_compile_pattern((char *)pattern, (int )size, & regex);
  if ((unsigned long )err != (unsigned long )((char *)0)) {
    fatal(err, 0);
  }
  dfainit(& dfa_1);
  if (match_words) {
    goto _L;
  } else {
    if (match_lines) {
      _L: /* CIL Label */ 
      myCIL___tmp___0 = xmalloc(size + 50UL);
      n = myCIL___tmp___0;
      i = 0;
      strcpy((char *)n, (char *)"");
      if (match_lines) {
        strcpy((char *)n, (char *)"^(");
      }
      if (match_words) {
        strcpy((char *)n, (char *)"(^|[^0-9A-Za-z_])(");
      }
      myCIL___tmp___1 = strlen((char *)n);
      i = (int )myCIL___tmp___1;
      memcpy((void *)(n + i), (void *)pattern, size);
      i = (int )((size_t )i + size);
      if (match_words) {
        strcpy((char *)(n + i), (char *)")([^0-9A-Za-z_]|$)");
      }
      if (match_lines) {
        strcpy((char *)(n + i), (char *)")$");
      }
      myCIL___tmp___2 = strlen((char *)(n + i));
      i = (int )((size_t )i + myCIL___tmp___2);
      dfacomp(n, (unsigned long )i, & dfa_1, 1);
    } else {
      dfacomp(pattern, size, & dfa_1, 1);
    }
  }
  kwsmusts();
  return;
}
}
static struct re_registers regs  ;
static char *EGexecute(char *buf , size_t size , char **endp ) 
{ register char *buflim___0 ;
  register char *beg ;
  register char *end ;
  register char save ;
  int backref ;
  int start ;
  int len ;
  struct kwsmatch kwsm ;
  void *myCIL___tmp ;
  char *myCIL___tmp___0 ;
  void *myCIL___tmp___1 ;
  unsigned short **myCIL___tmp___2 ;
  unsigned short **myCIL___tmp___3 ;

  {
  buflim___0 = buf + size;
  end = buf;
  beg = end;
  while ((unsigned long )end < (unsigned long )buflim___0) {
    if (kwset) {
      beg = kwsexec(kwset, beg, (unsigned long )(buflim___0 - beg), & kwsm);
      if (! beg) {
        goto failure;
      }
      myCIL___tmp = memchr((void *)beg, '\n', (unsigned long )(buflim___0 - beg));
      end = (char *)myCIL___tmp;
      if (! end) {
        end = buflim___0;
      }
      while (1) {
        if ((unsigned long )beg > (unsigned long )buf) {
          if (! ((int )*(beg + -1) != 10)) {
            break;
          }
        } else {
          break;
        }
        beg = beg - 1;
      }
      save = *end;
      if (kwsm.strchr < lastexact) {
        goto success;
      }
      myCIL___tmp___0 = dfaexec(& dfa_1, beg, end, 0, (int *)0, & backref);
      if (! myCIL___tmp___0) {
        *end = save;
        goto __Cont;
      }
      *end = save;
      if (! backref) {
        goto success;
      }
    } else {
      save = *buflim___0;
      beg = dfaexec(& dfa_1, beg, buflim___0, 0, (int *)0, & backref);
      *buflim___0 = save;
      if (! beg) {
        goto failure;
      }
      myCIL___tmp___1 = memchr((void *)beg, '\n', (unsigned long )(buflim___0 - beg));
      end = (char *)myCIL___tmp___1;
      if (! end) {
        end = buflim___0;
      }
      while (1) {
        if ((unsigned long )beg > (unsigned long )buf) {
          if (! ((int )*(beg + -1) != 10)) {
            break;
          }
        } else {
          break;
        }
        beg = beg - 1;
      }
      if (! backref) {
        goto success;
      }
    }
    regex.not_eol = 0U;
    start = re_search(& regex, (char *)beg, end - beg, 0, end - beg, & regs);
    if (start >= 0) {
      len = *(regs.end + 0) - start;
      if (! match_lines) {
        if (! match_words) {
          goto success;
        } else {
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        if (match_lines) {
          if (len == end - beg) {
            goto success;
          }
        }
      }
      if (match_words) {
        while (start >= 0) {
          if (start == 0) {
            goto _L___0;
          } else {
            myCIL___tmp___2 = __ctype_b_loc();
            if (! ((int )*(*myCIL___tmp___2 + (int )*(beg + (start - 1))) & 8)) {
              if (! ((int )*(beg + (start - 1)) == 95)) {
                _L___0: /* CIL Label */ 
                if (len == end - beg) {
                  goto success;
                } else {
                  myCIL___tmp___3 = __ctype_b_loc();
                  if (! ((int )*(*myCIL___tmp___3 + (int )*(beg + (start + len))) & 8)) {
                    if (! ((int )*(beg + (start + len)) == 95)) {
                      goto success;
                    }
                  }
                }
              }
            }
          }
          if (len > 0) {
            len = len - 1;
            regex.not_eol = 1U;
            len = re_match(& regex, (char *)beg, start + len, start, & regs);
          }
          if (len <= 0) {
            if (start == end - beg) {
              break;
            }
            start = start + 1;
            regex.not_eol = 0U;
            start = re_search(& regex, (char *)beg, end - beg, start, (end - beg) - start, & regs);
            len = *(regs.end + 0) - start;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
    beg = end + 1;
  }
  failure: 
  return ((char *)0);
  success: 
  if ((unsigned long )end < (unsigned long )buflim___0) {
    *endp = end + 1;
  } else {
    *endp = end;
  }
  return (beg);
}
}
static void Fcompile(char *pattern , size_t size ) 
{ char *beg ;
  char *lim ;
  char *err ;

  {
  kwsinit();
  beg = pattern;
  while (1) {
    lim = beg;
    while (1) {
      if ((unsigned long )lim < (unsigned long )(pattern + size)) {
        if (! ((int )*lim != 10)) {
          break;
        }
      } else {
        break;
      }
      lim = lim + 1;
    }
    err = kwsincr(kwset, beg, (unsigned long )(lim - beg));
    if ((unsigned long )err != (unsigned long )((char *)0)) {
      fatal((char *)err, 0);
    }
    if ((unsigned long )lim < (unsigned long )(pattern + size)) {
      lim = lim + 1;
    }
    beg = lim;
    if (! ((unsigned long )beg < (unsigned long )(pattern + size))) {
      break;
    }
  }
  err = kwsprep(kwset);
  if ((unsigned long )err != (unsigned long )((char *)0)) {
    fatal((char *)err, 0);
  }
  return;
}
}
static char *Fexecute(char *buf , size_t size , char **endp ) 
{ register char *beg ;
  register char *try ;
  register char *end ;
  register size_t len ;
  struct kwsmatch kwsmatch ;
  unsigned short **myCIL___tmp ;
  unsigned short **myCIL___tmp___0 ;
  void *myCIL___tmp___1 ;

  {
  beg = buf;
  while ((unsigned long )beg <= (unsigned long )(buf + size)) {
    beg = kwsexec(kwset, beg, (unsigned long )((buf + size) - beg), & kwsmatch);
    if (! beg) {
      return ((char *)0);
    }
    len = kwsmatch.size[0];
    if (match_lines) {
      if ((unsigned long )beg > (unsigned long )buf) {
        if ((int )*(beg + -1) != 10) {
          goto __Cont;
        }
      }
      if ((unsigned long )(beg + len) < (unsigned long )(buf + size)) {
        if ((int )*(beg + len) != 10) {
          goto __Cont;
        }
      }
      goto success;
    } else {
      if (match_words) {
        try = beg;
        while (1) {
          if (len) {
            if (! try) {
              break;
            }
          } else {
            break;
          }
          if ((unsigned long )try > (unsigned long )buf) {
            myCIL___tmp = __ctype_b_loc();
            if ((int )*(*myCIL___tmp + (int )((unsigned char )*(try + -1))) & 8) {
              break;
            } else {
              if ((int )((unsigned char )*(try + -1)) == 95) {
                break;
              }
            }
          }
          if ((unsigned long )(try + len) < (unsigned long )(buf + size)) {
            myCIL___tmp___0 = __ctype_b_loc();
            if ((int )*(*myCIL___tmp___0 + (int )((unsigned char )*(try + len))) & 8) {
              len = len - 1UL;
              try = kwsexec(kwset, beg, len, & kwsmatch);
              len = kwsmatch.size[0];
            } else {
              if ((int )((unsigned char )*(try + len)) == 95) {
                len = len - 1UL;
                try = kwsexec(kwset, beg, len, & kwsmatch);
                len = kwsmatch.size[0];
              } else {
                goto success;
              }
            }
          } else {
            goto success;
          }
        }
      } else {
        goto success;
      }
    }
    __Cont: /* CIL Label */ 
    beg = beg + 1;
  }
  return ((char *)0);
  success: 
  myCIL___tmp___1 = memchr((void *)(beg + len), '\n', (unsigned long )((buf + size) - (beg + len)));
  end = (char *)myCIL___tmp___1;
  if ((unsigned long )end != (unsigned long )((char *)0)) {
    end = end + 1;
  } else {
    end = buf + size;
  }
  *endp = end;
  while (1) {
    if ((unsigned long )beg > (unsigned long )buf) {
      if (! ((int )*(beg + -1) != 10)) {
        break;
      }
    } else {
      break;
    }
    beg = beg - 1;
  }
  return (beg);
}
}

/* Generated by Frontc */
int __BLAST_NONDET;


#line 16 "C:/NTDDK/inc/stddef.h"

#pragma once
#line 67
extern int errno ;

#line 77
typedef int intptr_t ;

#line 86
typedef unsigned int uintptr_t ;

#line 95
typedef int ptrdiff_t ;

#line 105
typedef unsigned int size_t ;

#line 112
typedef unsigned short wchar_t ;

#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"

#pragma once
#line 32

#pragma pack(push, 8)
#line 72
typedef enum _EXCEPTION_DISPOSITION {
	ExceptionContinueExecution,
	ExceptionContinueSearch,
	ExceptionNestedException,
	ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION ;

#line 89
struct _EXCEPTION_RECORD ;

#line 90
struct _CONTEXT ;

EXCEPTION_DISPOSITION __cdecl _except_handler(struct _EXCEPTION_RECORD * 
	ExceptionRecord , void *  EstablisherFrame , struct _CONTEXT * 
	ContextRecord , void *  DispatcherContext ) ;
#line 133
unsigned long __cdecl _exception_code(void  ) ;
void * __cdecl _exception_info(void  ) ;
int __cdecl _abnormal_termination(void  ) ;

#line 155

#pragma pack(pop)
#line 25 "C:/NTDDK/inc/ntdef.h"

#pragma once
#line 15 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"

#pragma once
#line 66
typedef wchar_t wint_t ;

#line 67
typedef wchar_t wctype_t ;

#line 106
int __cdecl _isctype(int  , int  ) ;
int __cdecl isalpha(int  ) ;
int __cdecl isupper(int  ) ;
int __cdecl islower(int  ) ;
int __cdecl isdigit(int  ) ;
int __cdecl isxdigit(int  ) ;
int __cdecl isspace(int  ) ;
int __cdecl ispunct(int  ) ;
int __cdecl isalnum(int  ) ;
int __cdecl isprint(int  ) ;
int __cdecl isgraph(int  ) ;
int __cdecl iscntrl(int  ) ;
int __cdecl toupper(int  ) ;
int __cdecl tolower(int  ) ;
int __cdecl _tolower(int  ) ;
int __cdecl _toupper(int  ) ;
int __cdecl __isascii(int  ) ;
int __cdecl __toascii(int  ) ;
int __cdecl __iscsymf(int  ) ;
int __cdecl __iscsym(int  ) ;
#line 137
int __cdecl iswalpha(wint_t ) ;
int __cdecl iswupper(wint_t ) ;
int __cdecl iswlower(wint_t ) ;
int __cdecl iswdigit(wint_t ) ;
int __cdecl iswxdigit(wint_t ) ;
int __cdecl iswspace(wint_t ) ;
int __cdecl iswpunct(wint_t ) ;
int __cdecl iswalnum(wint_t ) ;
int __cdecl iswprint(wint_t ) ;
int __cdecl iswgraph(wint_t ) ;
int __cdecl iswcntrl(wint_t ) ;
int __cdecl iswascii(wint_t ) ;
int __cdecl isleadbyte(int  ) ;
#line 151
wchar_t __cdecl towupper(wchar_t ) ;
wchar_t __cdecl towlower(wchar_t ) ;
#line 154
int __cdecl iswctype(wint_t , wctype_t ) ;
#line 157
int __cdecl is_wctype(wint_t , wctype_t ) ;

#line 127 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long POINTER_64_INT ;

#line 25 "C:/NTDDK/inc/basetsd.h"

#pragma once
#line 36
typedef int LONG32 , *  PLONG32 ;

#line 37
typedef int INT32 , *  PINT32 ;

#line 43
typedef unsigned int ULONG32 , *  PULONG32 ;

#line 44
typedef unsigned int DWORD32 , *  PDWORD32 ;

#line 45
typedef unsigned int UINT32 , *  PUINT32 ;

#line 84
typedef int INT_PTR , *  PINT_PTR ;

#line 85
typedef unsigned int UINT_PTR , *  PUINT_PTR ;

typedef long LONG_PTR , *  PLONG_PTR ;

#line 88
typedef unsigned long ULONG_PTR , *  PULONG_PTR ;

#line 248
typedef unsigned short UHALF_PTR , *  PUHALF_PTR ;

#line 249
typedef short HALF_PTR , *  PHALF_PTR ;

#line 250
typedef unsigned long HANDLE_PTR ;

#line 288
typedef ULONG_PTR SIZE_T , *  PSIZE_T ;

#line 289
typedef LONG_PTR SSIZE_T , *  PSSIZE_T ;

#line 295
typedef ULONG_PTR DWORD_PTR , *  PDWORD_PTR ;

#line 301
typedef __int64 LONG64 , *  PLONG64 ;

#line 302
typedef __int64 INT64 , *  PINT64 ;

#line 309
typedef unsigned __int64 ULONG64 , *  PULONG64 ;

#line 310
typedef unsigned __int64 DWORD64 , *  PDWORD64 ;

#line 311
typedef unsigned __int64 UINT64 , *  PUINT64 ;

#line 217 "C:/NTDDK/inc/ntdef.h"
typedef void *  PVOID ;

#line 218
typedef void *  PVOID64 ;

#line 266
typedef char CHAR ;

#line 267
typedef short SHORT ;

#line 268
typedef long LONG ;

#line 276
typedef wchar_t WCHAR ;

#line 282
typedef WCHAR *  PWCHAR ;

#line 283
typedef WCHAR *  LPWCH , *  PWCH ;

#line 284
typedef const WCHAR *  LPCWCH , *  PCWCH ;

#line 285
typedef WCHAR *  NWPSTR ;

#line 286
typedef WCHAR *  LPWSTR , *  PWSTR ;

typedef const WCHAR *  LPCWSTR , *  PCWSTR ;

#line 293
typedef CHAR *  PCHAR ;

#line 294
typedef CHAR *  LPCH , *  PCH ;

typedef const CHAR *  LPCCH , *  PCCH ;

#line 297
typedef CHAR *  NPSTR ;

#line 298
typedef CHAR *  LPSTR , *  PSTR ;

#line 299
typedef const CHAR *  LPCSTR , *  PCSTR ;

#line 321
typedef char TCHAR , *  PTCHAR ;

#line 322
typedef unsigned char TUCHAR , *  PTUCHAR ;

#line 326
typedef LPSTR LPTCH , PTCH ;

#line 327
typedef LPSTR PTSTR , LPTSTR ;

#line 328
typedef LPCSTR PCTSTR , LPCTSTR ;

#line 337
typedef double DOUBLE ;

typedef struct _QUAD {
	double DoNotUseThisField ;
} QUAD ;

#line 349
typedef SHORT *  PSHORT ;

#line 350
typedef LONG *  PLONG ;

#line 351
typedef QUAD *  PQUAD ;

#line 360
typedef unsigned char UCHAR ;

#line 361
typedef unsigned short USHORT ;

#line 362
typedef unsigned long ULONG ;

#line 363
typedef QUAD UQUAD ;

#line 369
typedef UCHAR *  PUCHAR ;

#line 370
typedef USHORT *  PUSHORT ;

#line 371
typedef ULONG *  PULONG ;

#line 372
typedef UQUAD *  PUQUAD ;

#line 378
typedef signed char SCHAR ;

#line 379
typedef SCHAR *  PSCHAR ;

#line 394
typedef void *  HANDLE ;

#line 400
typedef HANDLE *  PHANDLE ;

#line 406
typedef UCHAR FCHAR ;

#line 407
typedef USHORT FSHORT ;

#line 408
typedef ULONG FLONG ;

#line 414
typedef LONG HRESULT ;

#line 478
typedef char CCHAR ;

#line 479
typedef short CSHORT ;

#line 480
typedef ULONG CLONG ;

typedef CCHAR *  PCCHAR ;

#line 483
typedef CSHORT *  PCSHORT ;

#line 484
typedef CLONG *  PCLONG ;

#line 492
typedef ULONG LCID ;

#line 493
typedef PULONG PLCID ;

#line 494
typedef USHORT LANGID ;

#line 500
typedef ULONG LOGICAL ;

#line 501
typedef ULONG *  PLOGICAL ;

#line 508
typedef LONG NTSTATUS ;

typedef NTSTATUS *  PNTSTATUS ;

#line 602
typedef struct _FLOAT128 {
	__int64 LowPart ;
	__int64 HighPart ;
} FLOAT128 ;

typedef FLOAT128 *  PFLOAT128 ;

#line 621
typedef __int64 LONGLONG ;

#line 622
typedef unsigned __int64 ULONGLONG ;

#line 639
typedef LONGLONG *  PLONGLONG ;

#line 640
typedef ULONGLONG *  PULONGLONG ;

#line 644
typedef LONGLONG USN ;

#line 649
typedef union _LARGE_INTEGER {
	struct  {
		ULONG LowPart ;
		LONG HighPart ;
	}  ;
	struct  {
		ULONG LowPart ;
		LONG HighPart ;
	} u ;
	LONGLONG QuadPart ;
} LARGE_INTEGER ;

#line 662
typedef LARGE_INTEGER *  PLARGE_INTEGER ;

#line 668
typedef union _ULARGE_INTEGER {
	struct  {
		ULONG LowPart ;
		ULONG HighPart ;
	}  ;
	struct  {
		ULONG LowPart ;
		ULONG HighPart ;
	} u ;
	ULONGLONG QuadPart ;
} ULARGE_INTEGER ;

#line 681
typedef ULARGE_INTEGER *  PULARGE_INTEGER ;

#line 690
typedef struct _LUID {
	ULONG LowPart ;
	LONG HighPart ;
} LUID , *  PLUID ;

#line 696
typedef ULONGLONG DWORDLONG ;

#line 697
typedef DWORDLONG *  PDWORDLONG ;

#line 707
typedef LARGE_INTEGER PHYSICAL_ADDRESS , *  PPHYSICAL_ADDRESS ;

#line 809
ULONGLONG __stdcall Int64ShllMod32(ULONGLONG Value , ULONG ShiftCount ) ;
#line 816
LONGLONG __stdcall Int64ShraMod32(LONGLONG Value , ULONG ShiftCount ) ;
#line 823
ULONGLONG __stdcall Int64ShrlMod32(ULONGLONG Value , ULONG ShiftCount ) ;

#line 831

#pragma warning(push)

#pragma warning(disable:4035)
__inline ULONGLONG __stdcall Int64ShllMod32___0(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 842
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    
		};
}

#line 845
__inline LONGLONG __stdcall Int64ShraMod32___0(LONGLONG Value , ULONG ShiftCount
	)
{
	#line 852
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    
		};
}

#line 855
__inline ULONGLONG __stdcall Int64ShrlMod32___0(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 862
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    
		};
}


#pragma warning(pop)
#line 956
typedef enum _EVENT_TYPE {
	NotificationEvent,
	SynchronizationEvent
} EVENT_TYPE ;

#line 965
typedef enum _TIMER_TYPE {
	NotificationTimer,
	SynchronizationTimer
} TIMER_TYPE ;

#line 974
typedef enum _WAIT_TYPE {
	WaitAll,
	WaitAny
} WAIT_TYPE ;

#line 983
typedef CHAR *  PSZ ;

#line 984
typedef const char *  PCSZ ;

#line 991
typedef struct _STRING {
	USHORT Length ;
	USHORT MaximumLength ;
	PCHAR Buffer ;
} STRING ;

#line 999
typedef STRING *  PSTRING ;

typedef STRING ANSI_STRING ;

#line 1002
typedef PSTRING PANSI_STRING ;

typedef STRING OEM_STRING ;

#line 1005
typedef PSTRING POEM_STRING ;

#line 1011
typedef struct _CSTRING {
	USHORT Length ;
	USHORT MaximumLength ;
	const char *  Buffer ;
} CSTRING ;

#line 1016
typedef CSTRING *  PCSTRING ;

#line 1019
typedef STRING CANSI_STRING ;

#line 1020
typedef PSTRING PCANSI_STRING ;

#line 1027
typedef struct _UNICODE_STRING {
	USHORT Length ;
	USHORT MaximumLength ;
	PWSTR Buffer ;
} UNICODE_STRING ;

#line 1036
typedef UNICODE_STRING *  PUNICODE_STRING ;

#line 1037
typedef const UNICODE_STRING *  PCUNICODE_STRING ;

#line 1046
typedef UCHAR BOOLEAN ;

#line 1047
typedef BOOLEAN *  PBOOLEAN ;

#line 1057
typedef struct _LIST_ENTRY {
	struct _LIST_ENTRY *  Flink ;
	struct _LIST_ENTRY *  Blink ;
} LIST_ENTRY , *  PLIST_ENTRY , *  PRLIST_ENTRY ;

#line 1067
typedef struct _SINGLE_LIST_ENTRY {
	struct _SINGLE_LIST_ENTRY *  Next ;
} SINGLE_LIST_ENTRY , *  PSINGLE_LIST_ENTRY ;

#line 1078
typedef struct LIST_ENTRY32 {
	ULONG Flink ;
	ULONG Blink ;
} LIST_ENTRY32 ;

#line 1082
typedef LIST_ENTRY32 *  PLIST_ENTRY32 ;

typedef struct LIST_ENTRY64 {
	ULONGLONG Flink ;
	ULONGLONG Blink ;
} LIST_ENTRY64 ;

#line 1088
typedef LIST_ENTRY64 *  PLIST_ENTRY64 ;

#line 1094
__inline void ListEntry32To64(PLIST_ENTRY32 l32 , PLIST_ENTRY64 l64 )
{
	#line 1101
	l64->Flink = (ULONGLONG )((LONGLONG )((LONG )l32->Flink));
	l64->Blink = (ULONGLONG )((LONGLONG )((LONG )l32->Blink));
}

__inline void ListEntry64To32(PLIST_ENTRY64 l64 , PLIST_ENTRY32 l32 )
{
	#line 1112
	l32->Flink = (ULONG )l64->Flink;
	l32->Blink = (ULONG )l64->Blink;
}

#line 1127
typedef struct _STRING32 {
	USHORT Length ;
	USHORT MaximumLength ;
	ULONG Buffer ;
} STRING32 ;

#line 1132
typedef STRING32 *  PSTRING32 ;

typedef STRING32 UNICODE_STRING32 ;

#line 1135
typedef UNICODE_STRING32 *  PUNICODE_STRING32 ;

typedef STRING32 ANSI_STRING32 ;

#line 1138
typedef ANSI_STRING32 *  PANSI_STRING32 ;

#line 1141
typedef struct _STRING64 {
	USHORT Length ;
	USHORT MaximumLength ;
	ULONGLONG Buffer ;
} STRING64 ;

#line 1146
typedef STRING64 *  PSTRING64 ;

typedef STRING64 UNICODE_STRING64 ;

#line 1149
typedef UNICODE_STRING64 *  PUNICODE_STRING64 ;

typedef STRING64 ANSI_STRING64 ;

#line 1152
typedef ANSI_STRING64 *  PANSI_STRING64 ;

#line 1173
typedef struct _OBJECT_ATTRIBUTES {
	ULONG Length ;
	HANDLE RootDirectory ;
	PUNICODE_STRING ObjectName ;
	ULONG Attributes ;
	PVOID SecurityDescriptor ;
	PVOID SecurityQualityOfService ;
} OBJECT_ATTRIBUTES ;

#line 1181
typedef OBJECT_ATTRIBUTES *  POBJECT_ATTRIBUTES ;

#line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID {
	unsigned long Data1 ;
	unsigned short Data2 ;
	unsigned short Data3 ;
	unsigned char Data4[8] ;
} GUID ;

#line 70
typedef GUID *  LPGUID ;

#line 75
typedef const GUID *  LPCGUID ;

#line 81
typedef GUID IID ;

#line 82
typedef IID *  LPIID ;

#line 85
typedef GUID CLSID ;

#line 86
typedef CLSID *  LPCLSID ;

#line 89
typedef GUID FMTID ;

#line 90
typedef FMTID *  LPFMTID ;

#line 16 "C:/NTDDK/inc/string.h"

#pragma once
#line 93
void * __cdecl memcpy(void *  , const void *  , size_t ) ;
int __cdecl memcmp(const void *  , const void *  , size_t ) ;
void * __cdecl memset(void *  , int  , size_t ) ;
char * __cdecl _strset(char *  , int  ) ;
char * __cdecl strcpy(char *  , const char *  ) ;
char * __cdecl strcat(char *  , const char *  ) ;
int __cdecl strcmp(const char *  , const char *  ) ;
size_t __cdecl strlen(const char *  ) ;
#line 102
void * __cdecl _memccpy(void *  , const void *  , int  , size_t ) ;
void * __cdecl memchr(const void *  , int  , size_t ) ;
int __cdecl _memicmp(const void *  , const void *  , size_t ) ;
#line 110
void * __cdecl memmove(void *  , const void *  , size_t ) ;
#line 114
char * __cdecl strchr(const char *  , int  ) ;
int __cdecl _strcmpi(const char *  , const char *  ) ;
int __cdecl _stricmp(const char *  , const char *  ) ;
int __cdecl strcoll(const char *  , const char *  ) ;
int __cdecl _stricoll(const char *  , const char *  ) ;
int __cdecl _strncoll(const char *  , const char *  , size_t ) ;
int __cdecl _strnicoll(const char *  , const char *  , size_t ) ;
size_t __cdecl strcspn(const char *  , const char *  ) ;
char * __cdecl _strdup(const char *  ) ;
char * __cdecl _strerror(const char *  ) ;
char * __cdecl strerror(int  ) ;
char * __cdecl _strlwr(char *  ) ;
char * __cdecl strncat(char *  , const char *  , size_t ) ;
int __cdecl strncmp(const char *  , const char *  , size_t ) ;
int __cdecl _strnicmp(const char *  , const char *  , size_t ) ;
char * __cdecl strncpy(char *  , const char *  , size_t ) ;
char * __cdecl _strnset(char *  , int  , size_t ) ;
char * __cdecl strpbrk(const char *  , const char *  ) ;
char * __cdecl strrchr(const char *  , int  ) ;
char * __cdecl _strrev(char *  ) ;
size_t __cdecl strspn(const char *  , const char *  ) ;
char * __cdecl strstr(const char *  , const char *  ) ;
char * __cdecl strtok(char *  , const char *  ) ;
char * __cdecl _strupr(char *  ) ;
size_t __cdecl strxfrm(char *  , const char *  , size_t ) ;
#line 144
void * __cdecl memccpy(void *  , const void *  , int  , size_t ) ;
int __cdecl memicmp(const void *  , const void *  , size_t ) ;
int __cdecl strcmpi(const char *  , const char *  ) ;
int __cdecl stricmp(const char *  , const char *  ) ;
char * __cdecl strdup(const char *  ) ;
char * __cdecl strlwr(char *  ) ;
int __cdecl strnicmp(const char *  , const char *  , size_t ) ;
char * __cdecl strnset(char *  , int  , size_t ) ;
char * __cdecl strrev(char *  ) ;
char * __cdecl strset(char *  , int  ) ;
char * __cdecl strupr(char *  ) ;
#line 163
wchar_t * __cdecl wcscat(wchar_t *  , const wchar_t *  ) ;
wchar_t * __cdecl wcschr(const wchar_t *  , wchar_t ) ;
int __cdecl wcscmp(const wchar_t *  , const wchar_t *  ) ;
wchar_t * __cdecl wcscpy(wchar_t *  , const wchar_t *  ) ;
size_t __cdecl wcscspn(const wchar_t *  , const wchar_t *  ) ;
size_t __cdecl wcslen(const wchar_t *  ) ;
wchar_t * __cdecl wcsncat(wchar_t *  , const wchar_t *  , size_t ) ;
int __cdecl wcsncmp(const wchar_t *  , const wchar_t *  , size_t ) ;
wchar_t * __cdecl wcsncpy(wchar_t *  , const wchar_t *  , size_t ) ;
wchar_t * __cdecl wcspbrk(const wchar_t *  , const wchar_t *  ) ;
wchar_t * __cdecl wcsrchr(const wchar_t *  , wchar_t ) ;
size_t __cdecl wcsspn(const wchar_t *  , const wchar_t *  ) ;
wchar_t * __cdecl wcsstr(const wchar_t *  , const wchar_t *  ) ;
wchar_t * __cdecl wcstok(wchar_t *  , const wchar_t *  ) ;
#line 178
wchar_t * __cdecl _wcsdup(const wchar_t *  ) ;
int __cdecl _wcsicmp(const wchar_t *  , const wchar_t *  ) ;
int __cdecl _wcsnicmp(const wchar_t *  , const wchar_t *  , size_t ) ;
wchar_t * __cdecl _wcsnset(wchar_t *  , wchar_t , size_t ) ;
wchar_t * __cdecl _wcsrev(wchar_t *  ) ;
wchar_t * __cdecl _wcsset(wchar_t *  , wchar_t ) ;
#line 185
wchar_t * __cdecl _wcslwr(wchar_t *  ) ;
wchar_t * __cdecl _wcsupr(wchar_t *  ) ;
size_t __cdecl wcsxfrm(wchar_t *  , const wchar_t *  , size_t ) ;
int __cdecl wcscoll(const wchar_t *  , const wchar_t *  ) ;
int __cdecl _wcsicoll(const wchar_t *  , const wchar_t *  ) ;
int __cdecl _wcsncoll(const wchar_t *  , const wchar_t *  , size_t ) ;
int __cdecl _wcsnicoll(const wchar_t *  , const wchar_t *  , size_t ) ;
#line 199
wchar_t * __cdecl wcsdup(const wchar_t *  ) ;
int __cdecl wcsicmp(const wchar_t *  , const wchar_t *  ) ;
int __cdecl wcsnicmp(const wchar_t *  , const wchar_t *  , size_t ) ;
wchar_t * __cdecl wcsnset(wchar_t *  , wchar_t , size_t ) ;
wchar_t * __cdecl wcsrev(wchar_t *  ) ;
wchar_t * __cdecl wcsset(wchar_t *  , wchar_t ) ;
wchar_t * __cdecl wcslwr(wchar_t *  ) ;
wchar_t * __cdecl wcsupr(wchar_t *  ) ;
int __cdecl wcsicoll(const wchar_t *  , const wchar_t *  ) ;

#line 1233 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECTID {
	GUID Lineage ;
	ULONG Uniquifier ;
} OBJECTID ;

#line 1288
struct _CONTEXT ;

#line 1289
struct _EXCEPTION_RECORD ;

typedef EXCEPTION_DISPOSITION ( *  PEXCEPTION_ROUTINE
	)(struct _EXCEPTION_RECORD *  ExceptionRecord , PVOID EstablisherFrame ,
	struct _CONTEXT *  ContextRecord , PVOID DispatcherContext ) ;

#line 1306
typedef UCHAR KIRQL ;

typedef KIRQL *  PKIRQL ;

#line 1316
typedef enum _NT_PRODUCT_TYPE {
	NtProductWinNt = 1,
	NtProductLanManNt,
	NtProductServer
} NT_PRODUCT_TYPE , *  PNT_PRODUCT_TYPE ;

#line 1329
typedef enum _SUITE_TYPE {
	SmallBusiness,
	Enterprise,
	BackOffice,
	CommunicationServer,
	TerminalServer,
	SmallBusinessRestricted,
	EmbeddedNT,
	DataCenter,
	SingleUserTS,
	MaxSuiteType
} SUITE_TYPE ;

#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD *  PKTHREAD ;

#line 76
typedef struct _ETHREAD *  PETHREAD ;

#line 77
typedef struct _EPROCESS *  PEPROCESS ;

#line 78
typedef struct _PEB *  PPEB ;

#line 79
typedef struct _KINTERRUPT *  PKINTERRUPT ;

#line 80
typedef struct _IO_TIMER *  PIO_TIMER ;

#line 81
typedef struct _OBJECT_TYPE *  POBJECT_TYPE ;

#line 82
typedef struct _CALLBACK_OBJECT *  PCALLBACK_OBJECT___0 ;

#line 83
typedef struct _DEVICE_HANDLER_OBJECT *  PDEVICE_HANDLER_OBJECT ;

#line 84
typedef struct _BUS_HANDLER *  PBUS_HANDLER ;

#line 101
PKTHREAD __stdcall KeGetCurrentThread() ;
#line 124
extern PCCHAR KeNumberProcessors ;

#line 143
typedef union _SLIST_HEADER {
	ULONGLONG Alignment ;
	struct  {
		SINGLE_LIST_ENTRY Next ;
		USHORT Depth ;
		USHORT Sequence ;
	}  ;
} SLIST_HEADER , *  PSLIST_HEADER ;

#line 204
typedef CCHAR KPROCESSOR_MODE ;

typedef enum _MODE {
	KernelMode,
	UserMode,
	MaximumMode
} MODE ;

#line 222
struct _KAPC ;

typedef void ( *  PKNORMAL_ROUTINE )(PVOID NormalContext , PVOID SystemArgument1
	, PVOID SystemArgument2 ) ;

#line 232
typedef void ( *  PKKERNEL_ROUTINE )(struct _KAPC *  Apc , PKNORMAL_ROUTINE * 
	NormalRoutine , PVOID *  NormalContext , PVOID *  SystemArgument1 ,
	PVOID *  SystemArgument2 ) ;

#line 242
typedef void ( *  PKRUNDOWN_ROUTINE )(struct _KAPC *  Apc ) ;

#line 248
typedef BOOLEAN ( *  PKSYNCHRONIZE_ROUTINE )(PVOID SynchronizeContext ) ;

#line 254
typedef BOOLEAN ( *  PKTRANSFER_ROUTINE )(void  ) ;

#line 265
typedef struct _KAPC {
	CSHORT Type ;
	CSHORT Size ;
	ULONG Spare0 ;
	struct _KTHREAD *  Thread ;
	LIST_ENTRY ApcListEntry ;
	PKKERNEL_ROUTINE KernelRoutine ;
	PKRUNDOWN_ROUTINE RundownRoutine ;
	PKNORMAL_ROUTINE NormalRoutine ;
	PVOID NormalContext ;
	PVOID SystemArgument1 ;
	PVOID SystemArgument2 ;
	CCHAR ApcStateIndex ;
	KPROCESSOR_MODE ApcMode ;
	BOOLEAN Inserted ;
} KAPC , *  PKAPC , *  PRKAPC ;

#line 292
struct _KDPC ;

typedef void ( *  PKDEFERRED_ROUTINE )(struct _KDPC *  Dpc , PVOID
	DeferredContext , PVOID SystemArgument1 , PVOID SystemArgument2 ) ;

#line 351
typedef enum _KDPC_IMPORTANCE {
	LowImportance,
	MediumImportance,
	HighImportance
} KDPC_IMPORTANCE ;

#line 361
typedef struct _KDPC {
	CSHORT Type ;
	UCHAR Number ;
	UCHAR Importance ;
	LIST_ENTRY DpcListEntry ;
	PKDEFERRED_ROUTINE DeferredRoutine ;
	PVOID DeferredContext ;
	PVOID SystemArgument1 ;
	PVOID SystemArgument2 ;
	PULONG_PTR Lock ;
} KDPC , *  PKDPC , *  PRKDPC ;

#line 377
typedef PVOID PKIPI_CONTEXT ;

typedef void ( *  PKIPI_WORKER )(PKIPI_CONTEXT PacketContext , PVOID Parameter1
	, PVOID Parameter2 , PVOID Parameter3 ) ;

#line 392
typedef struct _KIPI_COUNTS {
	ULONG Freeze ;
	ULONG Packet ;
	ULONG DPC ;
	ULONG APC ;
	ULONG FlushSingleTb ;
	ULONG FlushMultipleTb ;
	ULONG FlushEntireTb ;
	ULONG GenericCall ;
	ULONG ChangeColor ;
	ULONG SweepDcache ;
	ULONG SweepIcache ;
	ULONG SweepIcacheRange ;
	ULONG FlushIoBuffers ;
	ULONG GratuitousDPC ;
} KIPI_COUNTS , *  PKIPI_COUNTS ;

#line 443
typedef struct _MDL {
	struct _MDL *  Next ;
	CSHORT Size ;
	CSHORT MdlFlags ;
	struct _EPROCESS *  Process ;
	PVOID MappedSystemVa ;
	PVOID StartVa ;
	ULONG ByteCount ;
	ULONG ByteOffset ;
} MDL , *  PMDL ;

#line 532
typedef PVOID PACCESS_TOKEN ;

#line 538
typedef PVOID PSECURITY_DESCRIPTOR ;

#line 544
typedef PVOID PSID ;

typedef ULONG ACCESS_MASK ;

#line 547
typedef ACCESS_MASK *  PACCESS_MASK ;

#line 597
typedef struct _GENERIC_MAPPING {
	ACCESS_MASK GenericRead ;
	ACCESS_MASK GenericWrite ;
	ACCESS_MASK GenericExecute ;
	ACCESS_MASK GenericAll ;
} GENERIC_MAPPING ;

#line 603
typedef GENERIC_MAPPING *  PGENERIC_MAPPING ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES {
	LUID Luid ;
	ULONG Attributes ;
} LUID_AND_ATTRIBUTES , *  PLUID_AND_ATTRIBUTES ;

#line 622
typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[1] ;

#line 623
typedef LUID_AND_ATTRIBUTES_ARRAY *  PLUID_AND_ATTRIBUTES_ARRAY ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 642 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACL {
	UCHAR AclRevision ;
	UCHAR Sbz1 ;
	USHORT AclSize ;
	USHORT AceCount ;
	USHORT Sbz2 ;
} ACL ;

#line 649
typedef ACL *  PACL ;

#line 681
typedef struct _PRIVILEGE_SET {
	ULONG PrivilegeCount ;
	ULONG Control ;
	LUID_AND_ATTRIBUTES Privilege[1] ;
} PRIVILEGE_SET , *  PPRIVILEGE_SET ;

#line 735
typedef enum _SECURITY_IMPERSONATION_LEVEL {
	SecurityAnonymous,
	SecurityIdentification,
	SecurityImpersonation,
	SecurityDelegation
} SECURITY_IMPERSONATION_LEVEL , *  PSECURITY_IMPERSONATION_LEVEL ;

#line 753
typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE , * 
	PSECURITY_CONTEXT_TRACKING_MODE ;

#line 762
typedef struct _SECURITY_QUALITY_OF_SERVICE {
	ULONG Length ;
	SECURITY_IMPERSONATION_LEVEL ImpersonationLevel ;
	SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode ;
	BOOLEAN EffectiveOnly ;
} SECURITY_QUALITY_OF_SERVICE , *  PSECURITY_QUALITY_OF_SERVICE ;

#line 774
typedef struct _SE_IMPERSONATION_STATE {
	PACCESS_TOKEN Token ;
	BOOLEAN CopyOnOpen ;
	BOOLEAN EffectiveOnly ;
	SECURITY_IMPERSONATION_LEVEL Level ;
} SE_IMPERSONATION_STATE , *  PSE_IMPERSONATION_STATE ;

#line 782
typedef ULONG SECURITY_INFORMATION , *  PSECURITY_INFORMATION ;

#line 809
typedef ULONG KAFFINITY ;

#line 810
typedef KAFFINITY *  PKAFFINITY ;

#line 816
typedef LONG KPRIORITY ;

#line 824
typedef ULONG_PTR KSPIN_LOCK ;

#line 825
typedef KSPIN_LOCK *  PKSPIN_LOCK ;

#line 833
typedef void ( *  PKINTERRUPT_ROUTINE )(void  ) ;

#line 842
typedef enum _KPROFILE_SOURCE {
	ProfileTime,
	ProfileAlignmentFixup,
	ProfileTotalIssues,
	ProfilePipelineDry,
	ProfileLoadInstructions,
	ProfilePipelineFrozen,
	ProfileBranchInstructions,
	ProfileTotalNonissues,
	ProfileDcacheMisses,
	ProfileIcacheMisses,
	ProfileCacheMisses,
	ProfileBranchMispredictions,
	ProfileStoreInstructions,
	ProfileFpInstructions,
	ProfileIntegerInstructions,
	Profile2Issue,
	Profile3Issue,
	Profile4Issue,
	ProfileSpecialInstructions,
	ProfileTotalCycles,
	ProfileIcacheIssues,
	ProfileDcacheAccesses,
	ProfileMemoryBarrierCycles,
	ProfileLoadLinkedIssues,
	ProfileMaximum
} KPROFILE_SOURCE ;

#line 1058
__declspec(dllimport) void __stdcall RtlGetCallersAddress(PVOID * 
	CallersAddress , PVOID *  CallersCaller ) ;
#line 1067
__declspec(dllimport) ULONG __stdcall RtlWalkFrameChain(PVOID *  Callers , ULONG
	Count , ULONG Flags ) ;

#line 1079
typedef NTSTATUS (__stdcall *  PRTL_QUERY_REGISTRY_ROUTINE )(PWSTR ValueName ,
	ULONG ValueType , PVOID ValueData , ULONG ValueLength , PVOID Context ,
	PVOID EntryContext ) ;

#line 1088
typedef struct _RTL_QUERY_REGISTRY_TABLE {
	PRTL_QUERY_REGISTRY_ROUTINE QueryRoutine ;
	ULONG Flags ;
	PWSTR Name ;
	PVOID EntryContext ;
	ULONG DefaultType ;
	PVOID DefaultData ;
	ULONG DefaultLength ;
} RTL_QUERY_REGISTRY_TABLE , *  PRTL_QUERY_REGISTRY_TABLE ;

#line 1136
__declspec(dllimport) NTSTATUS __stdcall RtlQueryRegistryValues(ULONG RelativeTo
	, PCWSTR Path , PRTL_QUERY_REGISTRY_TABLE QueryTable , PVOID Context ,
	PVOID Environment ) ;
#line 1147
__declspec(dllimport) NTSTATUS __stdcall RtlWriteRegistryValue(ULONG RelativeTo
	, PCWSTR Path , PCWSTR ValueName , ULONG ValueType , PVOID ValueData ,
	ULONG ValueLength ) ;
#line 1159
__declspec(dllimport) NTSTATUS __stdcall RtlDeleteRegistryValue(ULONG RelativeTo
	, PCWSTR Path , PCWSTR ValueName ) ;
#line 1170
__declspec(dllimport) NTSTATUS __stdcall RtlCreateRegistryKey(ULONG RelativeTo ,
	PWSTR Path ) ;
#line 1178
__declspec(dllimport) NTSTATUS __stdcall RtlCheckRegistryKey(ULONG RelativeTo ,
	PWSTR Path ) ;
#line 1202
__declspec(dllimport) NTSTATUS __stdcall RtlCharToInteger(PCSZ String , ULONG
	Base , PULONG Value ) ;
#line 1211
__declspec(dllimport) NTSTATUS __stdcall RtlIntegerToUnicodeString(ULONG Value ,
	ULONG Base , PUNICODE_STRING String ) ;
#line 1220
__declspec(dllimport) NTSTATUS __stdcall RtlInt64ToUnicodeString(ULONGLONG Value
	, ULONG Base , PUNICODE_STRING String ) ;
#line 1235
__declspec(dllimport) NTSTATUS __stdcall
	RtlUnicodeStringToInteger(PUNICODE_STRING String , ULONG Base , PULONG
	Value ) ;
#line 1261
extern BOOLEAN ( *  NlsMbCodePageTag ) ;
extern BOOLEAN ( *  NlsMbOemCodePageTag ) ;
#line 1264
__declspec(dllimport) void __stdcall RtlInitString(PSTRING DestinationString ,
	PCSZ SourceString ) ;
#line 1272
__declspec(dllimport) void __stdcall RtlInitAnsiString(PANSI_STRING
	DestinationString , PCSZ SourceString ) ;
#line 1280
__declspec(dllimport) void __stdcall RtlInitUnicodeString(PUNICODE_STRING
	DestinationString , PCWSTR SourceString ) ;
#line 1289
__declspec(dllimport) void __stdcall RtlCopyString(PSTRING DestinationString ,
	PSTRING SourceString ) ;
#line 1297
__declspec(dllimport) CHAR __stdcall RtlUpperChar(CHAR Character ) ;
#line 1304
__declspec(dllimport) LONG __stdcall RtlCompareString(PSTRING String1 , PSTRING
	String2 , BOOLEAN CaseInSensitive ) ;
#line 1313
__declspec(dllimport) BOOLEAN __stdcall RtlEqualString(PSTRING String1 , PSTRING
	String2 , BOOLEAN CaseInSensitive ) ;
#line 1323
__declspec(dllimport) void __stdcall RtlUpperString(PSTRING DestinationString ,
	PSTRING SourceString ) ;
#line 1335
__declspec(dllimport) NTSTATUS __stdcall
	RtlAnsiStringToUnicodeString(PUNICODE_STRING DestinationString ,
	PANSI_STRING SourceString , BOOLEAN AllocateDestinationString ) ;
#line 1345
__declspec(dllimport) NTSTATUS __stdcall
	RtlUnicodeStringToAnsiString(PANSI_STRING DestinationString ,
	PUNICODE_STRING SourceString , BOOLEAN AllocateDestinationString ) ;
#line 1355
__declspec(dllimport) LONG __stdcall RtlCompareUnicodeString(PUNICODE_STRING
	String1 , PUNICODE_STRING String2 , BOOLEAN CaseInSensitive ) ;
#line 1364
__declspec(dllimport) BOOLEAN __stdcall RtlEqualUnicodeString(const
	UNICODE_STRING *  String1 , const UNICODE_STRING *  String2 , BOOLEAN
	CaseInSensitive ) ;
#line 1375
__declspec(dllimport) BOOLEAN __stdcall RtlPrefixUnicodeString(PUNICODE_STRING
	String1 , PUNICODE_STRING String2 , BOOLEAN CaseInSensitive ) ;
#line 1384
__declspec(dllimport) NTSTATUS __stdcall RtlUpcaseUnicodeString(PUNICODE_STRING
	DestinationString , PCUNICODE_STRING SourceString , BOOLEAN
	AllocateDestinationString ) ;
#line 1394
__declspec(dllimport) void __stdcall RtlCopyUnicodeString(PUNICODE_STRING
	DestinationString , PUNICODE_STRING SourceString ) ;
#line 1402
__declspec(dllimport) NTSTATUS __stdcall
	RtlAppendUnicodeStringToString(PUNICODE_STRING Destination ,
	PUNICODE_STRING Source ) ;
#line 1410
__declspec(dllimport) NTSTATUS __stdcall
	RtlAppendUnicodeToString(PUNICODE_STRING Destination , PCWSTR Source ) ;
#line 1420
__declspec(dllimport) WCHAR __stdcall RtlUpcaseUnicodeChar(WCHAR SourceCharacter
	) ;
#line 1429
__declspec(dllimport) void __stdcall RtlFreeUnicodeString(PUNICODE_STRING
	UnicodeString ) ;
#line 1436
__declspec(dllimport) void __stdcall RtlFreeAnsiString(PANSI_STRING AnsiString )
	;
#line 1444
__declspec(dllimport) ULONG __stdcall RtlxAnsiStringToUnicodeSize(PANSI_STRING
	AnsiString ) ;
#line 1494
__declspec(dllimport) NTSTATUS __stdcall RtlStringFromGUID(const GUID * const
	Guid , PUNICODE_STRING GuidString ) ;
#line 1502
__declspec(dllimport) NTSTATUS __stdcall RtlGUIDFromString(PUNICODE_STRING
	GuidString , GUID *  Guid ) ;
#line 1516
__declspec(dllimport) SIZE_T __stdcall RtlCompareMemory(const void *  Source1 ,
	const void *  Source2 , SIZE_T Length ) ;
#line 1641
void __stdcall DbgBreakPoint(void  ) ;
#line 1649
__declspec(dllimport) void __stdcall DbgBreakPointWithStatus(ULONG Status ) ;
#line 1690
ULONG _cdecl DbgPrint(PCH Format , ...) ;
#line 1699
ULONG _cdecl DbgPrintReturnControlC(PCH Format , ...) ;

#line 1718
__inline LARGE_INTEGER __stdcall RtlLargeIntegerAdd(LARGE_INTEGER Addend1 ,
	LARGE_INTEGER Addend2 )
{
	#line 1726
	LARGE_INTEGER Sum ;
	#line 1728
	Sum.QuadPart = Addend1.QuadPart + Addend2.QuadPart;
	return Sum;
}

#line 1736
__inline LARGE_INTEGER __stdcall RtlEnlargedIntegerMultiply(LONG Multiplicand ,
	LONG Multiplier )
{
	#line 1744
	LARGE_INTEGER Product ;
	#line 1746
	Product.QuadPart = (LONGLONG )Multiplicand * (ULONGLONG )Multiplier;
	return Product;
}

#line 1754
__inline LARGE_INTEGER __stdcall RtlEnlargedUnsignedMultiply(ULONG Multiplicand
	, ULONG Multiplier )
{
	#line 1762
	LARGE_INTEGER Product ;
	#line 1764
	Product.QuadPart = (ULONGLONG )Multiplicand * (ULONGLONG )Multiplier;
	return Product;
}

#line 1772
__inline ULONG __stdcall RtlEnlargedUnsignedDivide(ULARGE_INTEGER Dividend ,
	ULONG Divisor , PULONG Remainder )
{
	#line 1781
	ULONG Quotient ;
	#line 1783
	Quotient = (ULONG )(Dividend.QuadPart / Divisor);
	if((CHAR *  )Remainder != (CHAR *  )((void *  )0))
	{
		* Remainder = (ULONG )(Dividend.QuadPart % Divisor);
	}
	#line 1789
	return Quotient;
}

#line 1796
__inline LARGE_INTEGER __stdcall RtlLargeIntegerNegate(LARGE_INTEGER Subtrahend
	)
{
	#line 1803
	LARGE_INTEGER Difference ;
	#line 1805
	Difference.QuadPart = - Subtrahend.QuadPart;
	return Difference;
}

#line 1813
__inline LARGE_INTEGER __stdcall RtlLargeIntegerSubtract(LARGE_INTEGER Minuend ,
	LARGE_INTEGER Subtrahend )
{
	#line 1821
	LARGE_INTEGER Difference ;
	#line 1823
	Difference.QuadPart = Minuend.QuadPart - Subtrahend.QuadPart;
	return Difference;
}

#line 1833
__declspec(dllimport) LARGE_INTEGER __stdcall
	RtlExtendedMagicDivide(LARGE_INTEGER Dividend , LARGE_INTEGER
	MagicDivisor , CCHAR ShiftCount ) ;
#line 1846
__declspec(dllimport) LARGE_INTEGER __stdcall
	RtlExtendedLargeIntegerDivide(LARGE_INTEGER Dividend , ULONG Divisor ,
	PULONG Remainder ) ;
#line 1860
__declspec(dllimport) LARGE_INTEGER __stdcall
	RtlLargeIntegerDivide(LARGE_INTEGER Dividend , LARGE_INTEGER Divisor ,
	PLARGE_INTEGER Remainder ) ;
#line 1874
__declspec(dllimport) LARGE_INTEGER __stdcall
	RtlExtendedIntegerMultiply(LARGE_INTEGER Multiplicand , LONG Multiplier
	) ;

#line 1952

#pragma warning(push)

#pragma warning(disable:4035)
#line 1960
__inline LARGE_INTEGER __stdcall RtlConvertLongToLargeInteger(LONG SignedInteger
	)
{
	#line 1966
	__asm {
        mov     eax, SignedInteger
        cdq                 ; (edx:eax) = signed LargeInt
    
		};
}

#line 1973
__inline LARGE_INTEGER __stdcall RtlConvertUlongToLargeInteger(ULONG
	UnsignedInteger )
{
	#line 1979
	__asm {
        sub     edx, edx    ; zero highpart
        mov     eax, UnsignedInteger
    
		};
}

#line 1986
__inline LARGE_INTEGER __stdcall RtlLargeIntegerShiftLeft(LARGE_INTEGER
	LargeInteger , CCHAR ShiftCount )
{
	#line 1993
	__asm {
        mov     cl, ShiftCount
        and     cl, 0x3f                    ; mod 64

        cmp     cl, 32
        jc      short sl10

        mov     edx, LargeInteger.LowPart   ; ShiftCount >= 32
        xor     eax, eax                    ; lowpart is zero
        shl     edx, cl                     ; store highpart
        jmp     short done

sl10:
        mov     eax, LargeInteger.LowPart   ; ShiftCount < 32
        mov     edx, LargeInteger.HighPart
        shld    edx, eax, cl
        shl     eax, cl
done:
    
		};
}

__inline LARGE_INTEGER __stdcall RtlLargeIntegerShiftRight(LARGE_INTEGER
	LargeInteger , CCHAR ShiftCount )
{
	#line 2004
	__asm {
        mov     cl, ShiftCount
        and     cl, 0x3f               ; mod 64

        cmp     cl, 32
        jc      short sr10

        mov     eax, LargeInteger.HighPart  ; ShiftCount >= 32
        xor     edx, edx                    ; lowpart is zero
        shr     eax, cl                     ; store highpart
        jmp     short done

sr10:
        mov     eax, LargeInteger.LowPart   ; ShiftCount < 32
        mov     edx, LargeInteger.HighPart
        shrd    eax, edx, cl
        shr     edx, cl
done:
    
		};
}

__inline LARGE_INTEGER __stdcall RtlLargeIntegerArithmeticShift(LARGE_INTEGER
	LargeInteger , CCHAR ShiftCount )
{
	#line 2015
	__asm {
        mov     cl, ShiftCount
        and     cl, 3fh                 ; mod 64

        cmp     cl, 32
        jc      short sar10

        mov     eax, LargeInteger.HighPart
        sar     eax, cl
        bt      eax, 31                     ; sign bit set?
        sbb     edx, edx                    ; duplicate sign bit into highpart
        jmp     short done
sar10:
        mov     eax, LargeInteger.LowPart   ; (eax) = LargeInteger.LowPart
        mov     edx, LargeInteger.HighPart  ; (edx) = LargeInteger.HighPart
        shrd    eax, edx, cl
        sar     edx, cl
done:
    
		};
}


#pragma warning(pop)
#line 2214
typedef struct _TIME_FIELDS {
	CSHORT Year ;
	CSHORT Month ;
	CSHORT Day ;
	CSHORT Hour ;
	CSHORT Minute ;
	CSHORT Second ;
	CSHORT Milliseconds ;
	CSHORT Weekday ;
} TIME_FIELDS ;

#line 2224
typedef TIME_FIELDS *  PTIME_FIELDS ;

#line 2227
__declspec(dllimport) void __stdcall RtlTimeToTimeFields(PLARGE_INTEGER Time ,
	PTIME_FIELDS TimeFields ) ;
#line 2239
__declspec(dllimport) BOOLEAN __stdcall RtlTimeFieldsToTime(PTIME_FIELDS
	TimeFields , PLARGE_INTEGER Time ) ;

#line 2499
typedef struct _RTL_BITMAP {
	ULONG SizeOfBitMap ;
	PULONG Buffer ;
} RTL_BITMAP ;

#line 2503
typedef RTL_BITMAP *  PRTL_BITMAP ;

#line 2511
__declspec(dllimport) void __stdcall RtlInitializeBitMap(PRTL_BITMAP
	BitMapHeader , PULONG BitMapBuffer , ULONG SizeOfBitMap ) ;
#line 2525
__declspec(dllimport) void __stdcall RtlClearAllBits(PRTL_BITMAP BitMapHeader )
	;
#line 2532
__declspec(dllimport) void __stdcall RtlSetAllBits(PRTL_BITMAP BitMapHeader ) ;
#line 2549
__declspec(dllimport) ULONG __stdcall RtlFindClearBits(PRTL_BITMAP BitMapHeader
	, ULONG NumberToFind , ULONG HintIndex ) ;
#line 2558
__declspec(dllimport) ULONG __stdcall RtlFindSetBits(PRTL_BITMAP BitMapHeader ,
	ULONG NumberToFind , ULONG HintIndex ) ;
#line 2578
__declspec(dllimport) ULONG __stdcall RtlFindClearBitsAndSet(PRTL_BITMAP
	BitMapHeader , ULONG NumberToFind , ULONG HintIndex ) ;
#line 2587
__declspec(dllimport) ULONG __stdcall RtlFindSetBitsAndClear(PRTL_BITMAP
	BitMapHeader , ULONG NumberToFind , ULONG HintIndex ) ;
#line 2601
__declspec(dllimport) void __stdcall RtlClearBits(PRTL_BITMAP BitMapHeader ,
	ULONG StartingIndex , ULONG NumberToClear ) ;
#line 2610
__declspec(dllimport) void __stdcall RtlSetBits(PRTL_BITMAP BitMapHeader , ULONG
	StartingIndex , ULONG NumberToSet ) ;

#line 2627
typedef struct _RTL_BITMAP_RUN {
	ULONG StartingIndex ;
	ULONG NumberOfBits ;
} RTL_BITMAP_RUN ;

#line 2633
typedef RTL_BITMAP_RUN *  PRTL_BITMAP_RUN ;

__declspec(dllimport) ULONG __stdcall RtlFindClearRuns(PRTL_BITMAP BitMapHeader
	, PRTL_BITMAP_RUN RunArray , ULONG SizeOfRunArray , BOOLEAN
	LocateLongestRuns ) ;
#line 2652
__declspec(dllimport) ULONG __stdcall RtlFindLongestRunClear(PRTL_BITMAP
	BitMapHeader , PULONG StartingIndex ) ;
#line 2667
__declspec(dllimport) ULONG __stdcall RtlFindFirstRunClear(PRTL_BITMAP
	BitMapHeader , PULONG StartingIndex ) ;
#line 2699
__declspec(dllimport) ULONG __stdcall RtlNumberOfClearBits(PRTL_BITMAP
	BitMapHeader ) ;
#line 2706
__declspec(dllimport) ULONG __stdcall RtlNumberOfSetBits(PRTL_BITMAP
	BitMapHeader ) ;
#line 2718
__declspec(dllimport) BOOLEAN __stdcall RtlAreBitsClear(PRTL_BITMAP BitMapHeader
	, ULONG StartingIndex , ULONG Length ) ;
#line 2727
__declspec(dllimport) BOOLEAN __stdcall RtlAreBitsSet(PRTL_BITMAP BitMapHeader ,
	ULONG StartingIndex , ULONG Length ) ;
#line 2736
__declspec(dllimport) ULONG __stdcall RtlFindNextForwardRunClear(PRTL_BITMAP
	BitMapHeader , ULONG FromIndex , PULONG StartingRunIndex ) ;
#line 2745
__declspec(dllimport) ULONG __stdcall RtlFindLastBackwardRunClear(PRTL_BITMAP
	BitMapHeader , ULONG FromIndex , PULONG StartingRunIndex ) ;
#line 2760
__declspec(dllimport) CCHAR __stdcall RtlFindLeastSignificantBit(ULONGLONG Set )
	;
#line 2767
__declspec(dllimport) CCHAR __stdcall RtlFindMostSignificantBit(ULONGLONG Set )
	;

#line 2796
__inline LUID __stdcall RtlConvertLongToLuid(LONG Long )
{
	#line 2802
	LUID TempLuid ;
	LARGE_INTEGER TempLi ;
	#line 2805
	TempLi = RtlConvertLongToLargeInteger(Long);
	TempLuid.LowPart = TempLi.LowPart;
	TempLuid.HighPart = TempLi.HighPart;
	return TempLuid;
}

__inline LUID __stdcall RtlConvertUlongToLuid(ULONG Ulong )
{
	#line 2817
	LUID TempLuid ;
	#line 2819
	TempLuid.LowPart = Ulong;
	TempLuid.HighPart = 0;
	return TempLuid;
}

#line 2826
__declspec(dllimport) void __stdcall RtlMapGenericMask(PACCESS_MASK AccessMask ,
	PGENERIC_MAPPING GenericMapping ) ;
#line 2837
__declspec(dllimport) NTSTATUS __stdcall
	RtlCreateSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor ,
	ULONG Revision ) ;
#line 2846
__declspec(dllimport) BOOLEAN __stdcall
	RtlValidSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor ) ;
#line 2854
__declspec(dllimport) ULONG __stdcall
	RtlLengthSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor ) ;
#line 2861
__declspec(dllimport) BOOLEAN __stdcall
	RtlValidRelativeSecurityDescriptor(PSECURITY_DESCRIPTOR
	SecurityDescriptorInput , ULONG SecurityDescriptorLength ,
	SECURITY_INFORMATION RequiredInformation ) ;
#line 2871
__declspec(dllimport) NTSTATUS __stdcall
	RtlSetDaclSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor ,
	BOOLEAN DaclPresent , PACL Dacl , BOOLEAN DaclDefaulted ) ;

#line 2886
typedef struct _RTL_RANGE {
	ULONGLONG Start ;
	ULONGLONG End ;
	PVOID UserData ;
	PVOID Owner ;
	UCHAR Attributes ;
	UCHAR Flags ;
} RTL_RANGE , *  PRTL_RANGE ;

#line 2924
typedef struct _RTL_RANGE_LIST {
	LIST_ENTRY ListHead ;
	ULONG Flags ;
	ULONG Count ;
	ULONG Stamp ;
} RTL_RANGE_LIST , *  PRTL_RANGE_LIST ;

#line 2950
typedef struct _RANGE_LIST_ITERATOR {
	PLIST_ENTRY RangeListHead ;
	PLIST_ENTRY MergedHead ;
	PVOID Current ;
	ULONG Stamp ;
} RTL_RANGE_LIST_ITERATOR , *  PRTL_RANGE_LIST_ITERATOR ;

#line 2960
__declspec(dllimport) void __stdcall RtlInitializeRangeList(PRTL_RANGE_LIST
	RangeList ) ;
#line 2967
__declspec(dllimport) void __stdcall RtlFreeRangeList(PRTL_RANGE_LIST RangeList
	) ;
#line 2974
__declspec(dllimport) NTSTATUS __stdcall RtlCopyRangeList(PRTL_RANGE_LIST
	CopyRangeList , PRTL_RANGE_LIST RangeList ) ;
#line 2985
__declspec(dllimport) NTSTATUS __stdcall RtlAddRange(PRTL_RANGE_LIST RangeList ,
	ULONGLONG Start , ULONGLONG End , UCHAR Attributes , ULONG Flags , PVOID
	UserData , PVOID Owner ) ;
#line 2998
__declspec(dllimport) NTSTATUS __stdcall RtlDeleteRange(PRTL_RANGE_LIST
	RangeList , ULONGLONG Start , ULONGLONG End , PVOID Owner ) ;
#line 3008
__declspec(dllimport) NTSTATUS __stdcall RtlDeleteOwnersRanges(PRTL_RANGE_LIST
	RangeList , PVOID Owner ) ;

#line 3019
typedef BOOLEAN ( *  PRTL_CONFLICT_RANGE_CALLBACK )(PVOID Context , PRTL_RANGE
	Range ) ;

#line 3026
__declspec(dllimport) NTSTATUS __stdcall RtlFindRange(PRTL_RANGE_LIST RangeList
	, ULONGLONG Minimum , ULONGLONG Maximum , ULONG Length , ULONG Alignment
	, ULONG Flags , UCHAR AttributeAvailableMask , PVOID Context ,
	PRTL_CONFLICT_RANGE_CALLBACK Callback , PULONGLONG Start ) ;
#line 3042
__declspec(dllimport) NTSTATUS __stdcall RtlIsRangeAvailable(PRTL_RANGE_LIST
	RangeList , ULONGLONG Start , ULONGLONG End , ULONG Flags , UCHAR
	AttributeAvailableMask , PVOID Context , PRTL_CONFLICT_RANGE_CALLBACK
	Callback , PBOOLEAN Available ) ;
#line 3068
__declspec(dllimport) NTSTATUS __stdcall RtlGetFirstRange(PRTL_RANGE_LIST
	RangeList , PRTL_RANGE_LIST_ITERATOR Iterator , PRTL_RANGE *  Range ) ;
#line 3077
__declspec(dllimport) NTSTATUS __stdcall RtlGetLastRange(PRTL_RANGE_LIST
	RangeList , PRTL_RANGE_LIST_ITERATOR Iterator , PRTL_RANGE *  Range ) ;
#line 3086
__declspec(dllimport) NTSTATUS __stdcall
	RtlGetNextRange(PRTL_RANGE_LIST_ITERATOR Iterator , PRTL_RANGE *  Range
	, BOOLEAN MoveForwards ) ;
#line 3097
__declspec(dllimport) NTSTATUS __stdcall RtlMergeRangeLists(PRTL_RANGE_LIST
	MergedRangeList , PRTL_RANGE_LIST RangeList1 , PRTL_RANGE_LIST
	RangeList2 , ULONG Flags ) ;
#line 3107
__declspec(dllimport) NTSTATUS __stdcall RtlInvertRangeList(PRTL_RANGE_LIST
	InvertedRangeList , PRTL_RANGE_LIST RangeList ) ;
#line 3124
USHORT _fastcall RtlUshortByteSwap(USHORT Source ) ;
#line 3130
ULONG _fastcall RtlUlongByteSwap(ULONG Source ) ;
#line 3136
ULONGLONG _fastcall RtlUlonglongByteSwap(ULONGLONG Source ) ;
#line 3147
__declspec(dllimport) NTSTATUS __stdcall RtlVolumeDeviceToDosName(PVOID
	VolumeDeviceObject , PUNICODE_STRING DosName ) ;

#line 3155
typedef struct _OSVERSIONINFOA {
	ULONG dwOSVersionInfoSize ;
	ULONG dwMajorVersion ;
	ULONG dwMinorVersion ;
	ULONG dwBuildNumber ;
	ULONG dwPlatformId ;
	CHAR szCSDVersion[128] ;
} OSVERSIONINFOA , *  POSVERSIONINFOA , *  LPOSVERSIONINFOA ;

typedef struct _OSVERSIONINFOW {
	ULONG dwOSVersionInfoSize ;
	ULONG dwMajorVersion ;
	ULONG dwMinorVersion ;
	ULONG dwBuildNumber ;
	ULONG dwPlatformId ;
	WCHAR szCSDVersion[128] ;
} OSVERSIONINFOW , *  POSVERSIONINFOW , *  LPOSVERSIONINFOW , RTL_OSVERSIONINFOW
	, *  PRTL_OSVERSIONINFOW ;

#line 3177
typedef OSVERSIONINFOA OSVERSIONINFO ;

#line 3178
typedef POSVERSIONINFOA POSVERSIONINFO ;

#line 3179
typedef LPOSVERSIONINFOA LPOSVERSIONINFO ;

#line 3182
typedef struct _OSVERSIONINFOEXA {
	ULONG dwOSVersionInfoSize ;
	ULONG dwMajorVersion ;
	ULONG dwMinorVersion ;
	ULONG dwBuildNumber ;
	ULONG dwPlatformId ;
	CHAR szCSDVersion[128] ;
	USHORT wServicePackMajor ;
	USHORT wServicePackMinor ;
	USHORT wSuiteMask ;
	UCHAR wProductType ;
	UCHAR wReserved ;
} OSVERSIONINFOEXA , *  POSVERSIONINFOEXA , *  LPOSVERSIONINFOEXA ;

#line 3195
typedef struct _OSVERSIONINFOEXW {
	ULONG dwOSVersionInfoSize ;
	ULONG dwMajorVersion ;
	ULONG dwMinorVersion ;
	ULONG dwBuildNumber ;
	ULONG dwPlatformId ;
	WCHAR szCSDVersion[128] ;
	USHORT wServicePackMajor ;
	USHORT wServicePackMinor ;
	USHORT wSuiteMask ;
	UCHAR wProductType ;
	UCHAR wReserved ;
} OSVERSIONINFOEXW , *  POSVERSIONINFOEXW , *  LPOSVERSIONINFOEXW ,
	RTL_OSVERSIONINFOEXW , *  PRTL_OSVERSIONINFOEXW ;

#line 3213
typedef OSVERSIONINFOEXA OSVERSIONINFOEX ;

#line 3214
typedef POSVERSIONINFOEXA POSVERSIONINFOEX ;

#line 3215
typedef LPOSVERSIONINFOEXA LPOSVERSIONINFOEX ;

#line 3275
ULONGLONG __stdcall VerSetConditionMask(ULONGLONG ConditionMask , ULONG TypeMask
	, UCHAR Condition ) ;
#line 3286
__declspec(dllimport) NTSTATUS RtlGetVersion(PRTL_OSVERSIONINFOW
	lpVersionInformation ) ;
#line 3292
__declspec(dllimport) NTSTATUS RtlVerifyVersionInfo(PRTL_OSVERSIONINFOEXW
	VersionInfo , ULONG TypeMask , ULONGLONG ConditionMask ) ;

#line 3648
typedef struct _IO_STATUS_BLOCK {
	union  {
		NTSTATUS Status ;
		PVOID Pointer ;
	}  ;
	ULONG_PTR Information ;
} IO_STATUS_BLOCK , *  PIO_STATUS_BLOCK ;

#line 3669
typedef void (__stdcall *  PIO_APC_ROUTINE )(PVOID ApcContext , PIO_STATUS_BLOCK
	IoStatusBlock , ULONG Reserved ) ;

#line 3685
typedef enum _FILE_INFORMATION_CLASS {
	FileDirectoryInformation = 1,
	FileFullDirectoryInformation,
	FileBothDirectoryInformation,
	FileBasicInformation,
	FileStandardInformation,
	FileInternalInformation,
	FileEaInformation,
	FileAccessInformation,
	FileNameInformation,
	FileRenameInformation,
	FileLinkInformation,
	FileNamesInformation,
	FileDispositionInformation,
	FilePositionInformation,
	FileFullEaInformation,
	FileModeInformation,
	FileAlignmentInformation,
	FileAllInformation,
	FileAllocationInformation,
	FileEndOfFileInformation,
	FileAlternateNameInformation,
	FileStreamInformation,
	FilePipeInformation,
	FilePipeLocalInformation,
	FilePipeRemoteInformation,
	FileMailslotQueryInformation,
	FileMailslotSetInformation,
	FileCompressionInformation,
	FileObjectIdInformation,
	FileCompletionInformation,
	FileMoveClusterInformation,
	FileQuotaInformation,
	FileReparsePointInformation,
	FileNetworkOpenInformation,
	FileAttributeTagInformation,
	FileTrackingInformation,
	FileMaximumInformation
} FILE_INFORMATION_CLASS , *  PFILE_INFORMATION_CLASS ;

#line 3731
typedef struct _FILE_BASIC_INFORMATION {
	LARGE_INTEGER CreationTime ;
	LARGE_INTEGER LastAccessTime ;
	LARGE_INTEGER LastWriteTime ;
	LARGE_INTEGER ChangeTime ;
	ULONG FileAttributes ;
} FILE_BASIC_INFORMATION , *  PFILE_BASIC_INFORMATION ;

typedef struct _FILE_STANDARD_INFORMATION {
	LARGE_INTEGER AllocationSize ;
	LARGE_INTEGER EndOfFile ;
	ULONG NumberOfLinks ;
	BOOLEAN DeletePending ;
	BOOLEAN Directory ;
} FILE_STANDARD_INFORMATION , *  PFILE_STANDARD_INFORMATION ;

typedef struct _FILE_POSITION_INFORMATION {
	LARGE_INTEGER CurrentByteOffset ;
} FILE_POSITION_INFORMATION , *  PFILE_POSITION_INFORMATION ;

typedef struct _FILE_ALIGNMENT_INFORMATION {
	ULONG AlignmentRequirement ;
} FILE_ALIGNMENT_INFORMATION , *  PFILE_ALIGNMENT_INFORMATION ;

typedef struct _FILE_NAME_INFORMATION {
	ULONG FileNameLength ;
	WCHAR FileName[1] ;
} FILE_NAME_INFORMATION , *  PFILE_NAME_INFORMATION ;

typedef struct _FILE_NETWORK_OPEN_INFORMATION {
	LARGE_INTEGER CreationTime ;
	LARGE_INTEGER LastAccessTime ;
	LARGE_INTEGER LastWriteTime ;
	LARGE_INTEGER ChangeTime ;
	LARGE_INTEGER AllocationSize ;
	LARGE_INTEGER EndOfFile ;
	ULONG FileAttributes ;
} FILE_NETWORK_OPEN_INFORMATION , *  PFILE_NETWORK_OPEN_INFORMATION ;

typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION {
	ULONG FileAttributes ;
	ULONG ReparseTag ;
} FILE_ATTRIBUTE_TAG_INFORMATION , *  PFILE_ATTRIBUTE_TAG_INFORMATION ;

typedef struct _FILE_DISPOSITION_INFORMATION {
	BOOLEAN DeleteFile ;
} FILE_DISPOSITION_INFORMATION , *  PFILE_DISPOSITION_INFORMATION ;

typedef struct _FILE_END_OF_FILE_INFORMATION {
	LARGE_INTEGER EndOfFile ;
} FILE_END_OF_FILE_INFORMATION , *  PFILE_END_OF_FILE_INFORMATION ;

#line 3784
typedef struct _FILE_FULL_EA_INFORMATION {
	ULONG NextEntryOffset ;
	UCHAR Flags ;
	UCHAR EaNameLength ;
	USHORT EaValueLength ;
	CHAR EaName[1] ;
} FILE_FULL_EA_INFORMATION , *  PFILE_FULL_EA_INFORMATION ;

#line 3798
typedef enum _FSINFOCLASS {
	FileFsVolumeInformation = 1,
	FileFsLabelInformation,
	FileFsSizeInformation,
	FileFsDeviceInformation,
	FileFsAttributeInformation,
	FileFsControlInformation,
	FileFsFullSizeInformation,
	FileFsObjectIdInformation,
	FileFsMaximumInformation
} FS_INFORMATION_CLASS , *  PFS_INFORMATION_CLASS ;

typedef struct _FILE_FS_DEVICE_INFORMATION {
	ULONG DeviceType ;
	ULONG Characteristics ;
} FILE_FS_DEVICE_INFORMATION , *  PFILE_FS_DEVICE_INFORMATION ;

#line 3820
typedef union _FILE_SEGMENT_ELEMENT {
	PVOID64 Buffer ;
	ULONGLONG Alignment ;
} FILE_SEGMENT_ELEMENT , *  PFILE_SEGMENT_ELEMENT ;

#line 3829
typedef enum _INTERFACE_TYPE {
	InterfaceTypeUndefined = - 1,
	Internal,
	Isa,
	Eisa,
	MicroChannel,
	TurboChannel,
	PCIBus,
	VMEBus,
	NuBus,
	PCMCIABus,
	CBus,
	MPIBus,
	MPSABus,
	ProcessorInternal,
	InternalPowerBus,
	PNPISABus,
	PNPBus,
	MaximumInterfaceType
} INTERFACE_TYPE , *  PINTERFACE_TYPE ;

#line 3854
typedef enum _DMA_WIDTH {
	Width8Bits,
	Width16Bits,
	Width32Bits,
	MaximumDmaWidth
} DMA_WIDTH , *  PDMA_WIDTH ;

#line 3865
typedef enum _DMA_SPEED {
	Compatible,
	TypeA,
	TypeB,
	TypeC,
	TypeF,
	MaximumDmaSpeed
} DMA_SPEED , *  PDMA_SPEED ;

#line 3879
typedef void ( *  PINTERFACE_REFERENCE )(PVOID Context ) ;

#line 3880
typedef void ( *  PINTERFACE_DEREFERENCE )(PVOID Context ) ;

#line 3888
typedef enum _BUS_DATA_TYPE {
	ConfigurationSpaceUndefined = - 1,
	Cmos,
	EisaConfiguration,
	Pos,
	CbusConfiguration,
	PCIConfiguration,
	VMEConfiguration,
	NuBusConfiguration,
	PCMCIAConfiguration,
	MPIConfiguration,
	MPSAConfiguration,
	PNPISAConfiguration,
	SgiInternalConfiguration,
	MaximumBusDataType
} BUS_DATA_TYPE , *  PBUS_DATA_TYPE ;

#line 3910
typedef struct _IO_ERROR_LOG_PACKET {
	UCHAR MajorFunctionCode ;
	UCHAR RetryCount ;
	USHORT DumpDataSize ;
	USHORT NumberOfStrings ;
	USHORT StringOffset ;
	USHORT EventCategory ;
	NTSTATUS ErrorCode ;
	ULONG UniqueErrorValue ;
	NTSTATUS FinalStatus ;
	ULONG SequenceNumber ;
	ULONG IoControlCode ;
	LARGE_INTEGER DeviceOffset ;
	ULONG DumpData[1] ;
} IO_ERROR_LOG_PACKET , *  PIO_ERROR_LOG_PACKET ;

#line 3931
typedef struct _IO_ERROR_LOG_MESSAGE {
	USHORT Type ;
	USHORT Size ;
	USHORT DriverNameLength ;
	LARGE_INTEGER TimeStamp ;
	ULONG DriverNameOffset ;
	IO_ERROR_LOG_PACKET EntryData ;
} IO_ERROR_LOG_MESSAGE , *  PIO_ERROR_LOG_MESSAGE ;

#line 4074
typedef struct _KEY_BASIC_INFORMATION {
	LARGE_INTEGER LastWriteTime ;
	ULONG TitleIndex ;
	ULONG NameLength ;
	WCHAR Name[1] ;
} KEY_BASIC_INFORMATION , *  PKEY_BASIC_INFORMATION ;

typedef struct _KEY_NODE_INFORMATION {
	LARGE_INTEGER LastWriteTime ;
	ULONG TitleIndex ;
	ULONG ClassOffset ;
	ULONG ClassLength ;
	ULONG NameLength ;
	WCHAR Name[1] ;
} KEY_NODE_INFORMATION , *  PKEY_NODE_INFORMATION ;

#line 4091
typedef struct _KEY_FULL_INFORMATION {
	LARGE_INTEGER LastWriteTime ;
	ULONG TitleIndex ;
	ULONG ClassOffset ;
	ULONG ClassLength ;
	ULONG SubKeys ;
	ULONG MaxNameLen ;
	ULONG MaxClassLen ;
	ULONG Values ;
	ULONG MaxValueNameLen ;
	ULONG MaxValueDataLen ;
	WCHAR Class[1] ;
} KEY_FULL_INFORMATION , *  PKEY_FULL_INFORMATION ;

#line 4106
typedef struct _KEY_NAME_INFORMATION {
	ULONG NameLength ;
	WCHAR Name[1] ;
} KEY_NAME_INFORMATION , *  PKEY_NAME_INFORMATION ;

#line 4112
typedef enum _KEY_INFORMATION_CLASS {
	KeyBasicInformation,
	KeyNodeInformation,
	KeyFullInformation,
	KeyNameInformation
} KEY_INFORMATION_CLASS ;

#line 4122
typedef struct _KEY_WRITE_TIME_INFORMATION {
	LARGE_INTEGER LastWriteTime ;
} KEY_WRITE_TIME_INFORMATION , *  PKEY_WRITE_TIME_INFORMATION ;

typedef enum _KEY_SET_INFORMATION_CLASS {
	KeyWriteTimeInformation
} KEY_SET_INFORMATION_CLASS ;

#line 4134
typedef struct _KEY_VALUE_BASIC_INFORMATION {
	ULONG TitleIndex ;
	ULONG Type ;
	ULONG NameLength ;
	WCHAR Name[1] ;
} KEY_VALUE_BASIC_INFORMATION , *  PKEY_VALUE_BASIC_INFORMATION ;

typedef struct _KEY_VALUE_FULL_INFORMATION {
	ULONG TitleIndex ;
	ULONG Type ;
	ULONG DataOffset ;
	ULONG DataLength ;
	ULONG NameLength ;
	WCHAR Name[1] ;
} KEY_VALUE_FULL_INFORMATION , *  PKEY_VALUE_FULL_INFORMATION ;

#line 4151
typedef struct _KEY_VALUE_PARTIAL_INFORMATION {
	ULONG TitleIndex ;
	ULONG Type ;
	ULONG DataLength ;
	UCHAR Data[1] ;
} KEY_VALUE_PARTIAL_INFORMATION , *  PKEY_VALUE_PARTIAL_INFORMATION ;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 {
	ULONG Type ;
	ULONG DataLength ;
	UCHAR Data[1] ;
} KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 , * 
	PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ;

#line 4164
typedef struct _KEY_VALUE_ENTRY {
	PUNICODE_STRING ValueName ;
	ULONG DataLength ;
	ULONG DataOffset ;
	ULONG Type ;
} KEY_VALUE_ENTRY , *  PKEY_VALUE_ENTRY ;

typedef enum _KEY_VALUE_INFORMATION_CLASS {
	KeyValueBasicInformation,
	KeyValueFullInformation,
	KeyValuePartialInformation,
	KeyValueFullInformationAlign64,
	KeyValuePartialInformationAlign64
} KEY_VALUE_INFORMATION_CLASS ;

#line 4210
typedef struct _OBJECT_NAME_INFORMATION {
	UNICODE_STRING Name ;
} OBJECT_NAME_INFORMATION , *  POBJECT_NAME_INFORMATION ;

#line 4221
typedef enum _SECTION_INHERIT {
	ViewShare = 1,
	ViewUnmap = 2
} SECTION_INHERIT ;

#line 4294
typedef struct _CLIENT_ID {
	HANDLE UniqueProcess ;
	HANDLE UniqueThread ;
} CLIENT_ID ;

#line 4298
typedef CLIENT_ID *  PCLIENT_ID ;

#line 4315
typedef struct _NT_TIB {
	struct _EXCEPTION_REGISTRATION_RECORD *  ExceptionList ;
	PVOID StackBase ;
	PVOID StackLimit ;
	PVOID SubSystemTib ;
	union  {
		PVOID FiberData ;
		ULONG Version ;
	}  ;
	PVOID ArbitraryUserPointer ;
	struct _NT_TIB *  Self ;
} NT_TIB ;

#line 4327
typedef NT_TIB *  PNT_TIB ;

#line 4332
typedef enum _PROCESSINFOCLASS {
	ProcessBasicInformation,
	ProcessQuotaLimits,
	ProcessIoCounters,
	ProcessVmCounters,
	ProcessTimes,
	ProcessBasePriority,
	ProcessRaisePriority,
	ProcessDebugPort,
	ProcessExceptionPort,
	ProcessAccessToken,
	ProcessLdtInformation,
	ProcessLdtSize,
	ProcessDefaultHardErrorMode,
	ProcessIoPortHandlers,
	ProcessPooledUsageAndLimits,
	ProcessWorkingSetWatch,
	ProcessUserModeIOPL,
	ProcessEnableAlignmentFaultFixup,
	ProcessPriorityClass,
	ProcessWx86Information,
	ProcessHandleCount,
	ProcessAffinityMask,
	ProcessPriorityBoost,
	ProcessDeviceMap,
	ProcessSessionInformation,
	ProcessForegroundInformation,
	ProcessWow64Information,
	MaxProcessInfoClass
} PROCESSINFOCLASS ;

#line 4366
typedef enum _THREADINFOCLASS {
	ThreadBasicInformation,
	ThreadTimes,
	ThreadPriority,
	ThreadBasePriority,
	ThreadAffinityMask,
	ThreadImpersonationToken,
	ThreadDescriptorTableEntry,
	ThreadEnableAlignmentFaultFixup,
	ThreadEventPair_Reusable,
	ThreadQuerySetWin32StartAddress,
	ThreadZeroTlsCell,
	ThreadPerformanceCount,
	ThreadAmILastThread,
	ThreadIdealProcessor,
	ThreadPriorityBoost,
	ThreadSetTlsArrayAddress,
	ThreadIsIoPending,
	ThreadHideFromDebugger,
	MaxThreadInfoClass
} THREADINFOCLASS ;

#line 4395
typedef struct _PROCESS_WS_WATCH_INFORMATION {
	PVOID FaultingPc ;
	PVOID FaultingVa ;
} PROCESS_WS_WATCH_INFORMATION , *  PPROCESS_WS_WATCH_INFORMATION ;

#line 4405
typedef struct _PROCESS_BASIC_INFORMATION {
	NTSTATUS ExitStatus ;
	PPEB PebBaseAddress ;
	ULONG_PTR AffinityMask ;
	KPRIORITY BasePriority ;
	ULONG_PTR UniqueProcessId ;
	ULONG_PTR InheritedFromUniqueProcessId ;
} PROCESS_BASIC_INFORMATION ;

#line 4413
typedef PROCESS_BASIC_INFORMATION *  PPROCESS_BASIC_INFORMATION ;

#line 4422
typedef struct _PROCESS_DEVICEMAP_INFORMATION {
	union  {
		struct  {
			HANDLE DirectoryHandle ;
		} Set ;
		struct  {
			ULONG DriveMap ;
			UCHAR DriveType[32] ;
		} Query ;
	}  ;
} PROCESS_DEVICEMAP_INFORMATION , *  PPROCESS_DEVICEMAP_INFORMATION ;

#line 4440
typedef struct _PROCESS_SESSION_INFORMATION {
	ULONG SessionId ;
} PROCESS_SESSION_INFORMATION , *  PPROCESS_SESSION_INFORMATION ;

#line 4454
typedef struct _QUOTA_LIMITS {
	SIZE_T PagedPoolLimit ;
	SIZE_T NonPagedPoolLimit ;
	SIZE_T MinimumWorkingSetSize ;
	SIZE_T MaximumWorkingSetSize ;
	SIZE_T PagefileLimit ;
	LARGE_INTEGER TimeLimit ;
} QUOTA_LIMITS ;

#line 4462
typedef QUOTA_LIMITS *  PQUOTA_LIMITS ;

#line 4472
typedef struct _IO_COUNTERS {
	ULONGLONG ReadOperationCount ;
	ULONGLONG WriteOperationCount ;
	ULONGLONG OtherOperationCount ;
	ULONGLONG ReadTransferCount ;
	ULONGLONG WriteTransferCount ;
	ULONGLONG OtherTransferCount ;
} IO_COUNTERS ;

#line 4480
typedef IO_COUNTERS *  PIO_COUNTERS ;

#line 4488
typedef struct _VM_COUNTERS {
	SIZE_T PeakVirtualSize ;
	SIZE_T VirtualSize ;
	ULONG PageFaultCount ;
	SIZE_T PeakWorkingSetSize ;
	SIZE_T WorkingSetSize ;
	SIZE_T QuotaPeakPagedPoolUsage ;
	SIZE_T QuotaPagedPoolUsage ;
	SIZE_T QuotaPeakNonPagedPoolUsage ;
	SIZE_T QuotaNonPagedPoolUsage ;
	SIZE_T PagefileUsage ;
	SIZE_T PeakPagefileUsage ;
} VM_COUNTERS ;

#line 4501
typedef VM_COUNTERS *  PVM_COUNTERS ;

#line 4508
typedef struct _POOLED_USAGE_AND_LIMITS {
	SIZE_T PeakPagedPoolUsage ;
	SIZE_T PagedPoolUsage ;
	SIZE_T PagedPoolLimit ;
	SIZE_T PeakNonPagedPoolUsage ;
	SIZE_T NonPagedPoolUsage ;
	SIZE_T NonPagedPoolLimit ;
	SIZE_T PeakPagefileUsage ;
	SIZE_T PagefileUsage ;
	SIZE_T PagefileLimit ;
} POOLED_USAGE_AND_LIMITS ;

#line 4519
typedef POOLED_USAGE_AND_LIMITS *  PPOOLED_USAGE_AND_LIMITS ;

#line 4528
typedef struct _PROCESS_ACCESS_TOKEN {
	HANDLE Token ;
	HANDLE Thread ;
} PROCESS_ACCESS_TOKEN , *  PPROCESS_ACCESS_TOKEN ;

#line 4555
typedef struct _KERNEL_USER_TIMES {
	LARGE_INTEGER CreateTime ;
	LARGE_INTEGER ExitTime ;
	LARGE_INTEGER KernelTime ;
	LARGE_INTEGER UserTime ;
} KERNEL_USER_TIMES ;

#line 4561
typedef KERNEL_USER_TIMES *  PKERNEL_USER_TIMES ;

#line 4562
__declspec(dllimport) NTSTATUS __stdcall NtOpenProcess(PHANDLE ProcessHandle ,
	ACCESS_MASK DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes ,
	PCLIENT_ID ClientId ) ;
#line 4572
__declspec(dllimport) NTSTATUS __stdcall NtQueryInformationProcess(HANDLE
	ProcessHandle , PROCESSINFOCLASS ProcessInformationClass , PVOID
	ProcessInformation , ULONG ProcessInformationLength , PULONG
	ReturnLength ) ;

#line 4587
typedef enum _SYSTEM_POWER_STATE {
	PowerSystemUnspecified = 0,
	PowerSystemWorking,
	PowerSystemSleeping1,
	PowerSystemSleeping2,
	PowerSystemSleeping3,
	PowerSystemHibernate,
	PowerSystemShutdown,
	PowerSystemMaximum
} SYSTEM_POWER_STATE , *  PSYSTEM_POWER_STATE ;

typedef enum  {
	PowerActionNone = 0,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
} POWER_ACTION , *  PPOWER_ACTION ;

typedef enum _DEVICE_POWER_STATE {
	PowerDeviceUnspecified = 0,
	PowerDeviceD0,
	PowerDeviceD1,
	PowerDeviceD2,
	PowerDeviceD3,
	PowerDeviceMaximum
} DEVICE_POWER_STATE , *  PDEVICE_POWER_STATE ;

typedef union _POWER_STATE {
	SYSTEM_POWER_STATE SystemState ;
	DEVICE_POWER_STATE DeviceState ;
} POWER_STATE , *  PPOWER_STATE ;

typedef enum _POWER_STATE_TYPE {
	SystemPowerState = 0,
	DevicePowerState
} POWER_STATE_TYPE , *  PPOWER_STATE_TYPE ;

#line 4654
typedef ULONG EXECUTION_STATE ;

typedef enum  {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
} LATENCY_TIME ;

#line 4663
typedef enum  {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation
} POWER_INFORMATION_LEVEL ;

#line 4690
typedef ULONG PFN_COUNT ;

typedef LONG SPFN_NUMBER , *  PSPFN_NUMBER ;

#line 4693
typedef ULONG PFN_NUMBER , *  PPFN_NUMBER ;

#line 4719
typedef union _MCI_STATS {
	struct  {
		USHORT McaCod ;
		USHORT MsCod ;
		ULONG OtherInfo  : 25;
		ULONG Damage  : 1;
		ULONG AddressValid  : 1;
		ULONG MiscValid  : 1;
		ULONG Enabled  : 1;
		ULONG UnCorrected  : 1;
		ULONG OverFlow  : 1;
		ULONG Valid  : 1;
	} MciStats ;
	ULONGLONG QuadPart ;
} MCI_STATS , *  PMCI_STATS ;

#line 4768
__declspec(dllimport) UCHAR READ_REGISTER_UCHAR(PUCHAR Register ) ;
#line 4774
__declspec(dllimport) USHORT READ_REGISTER_USHORT(PUSHORT Register ) ;
#line 4780
__declspec(dllimport) ULONG READ_REGISTER_ULONG(PULONG Register ) ;
#line 4786
__declspec(dllimport) void READ_REGISTER_BUFFER_UCHAR(PUCHAR Register , PUCHAR
	Buffer , ULONG Count ) ;
#line 4794
__declspec(dllimport) void READ_REGISTER_BUFFER_USHORT(PUSHORT Register ,
	PUSHORT Buffer , ULONG Count ) ;
#line 4802
__declspec(dllimport) void READ_REGISTER_BUFFER_ULONG(PULONG Register , PULONG
	Buffer , ULONG Count ) ;
#line 4811
__declspec(dllimport) void WRITE_REGISTER_UCHAR(PUCHAR Register , UCHAR Value )
	;
#line 4818
__declspec(dllimport) void WRITE_REGISTER_USHORT(PUSHORT Register , USHORT Value
	) ;
#line 4825
__declspec(dllimport) void WRITE_REGISTER_ULONG(PULONG Register , ULONG Value )
	;
#line 4832
__declspec(dllimport) void WRITE_REGISTER_BUFFER_UCHAR(PUCHAR Register , PUCHAR
	Buffer , ULONG Count ) ;
#line 4840
__declspec(dllimport) void WRITE_REGISTER_BUFFER_USHORT(PUSHORT Register ,
	PUSHORT Buffer , ULONG Count ) ;
#line 4848
__declspec(dllimport) void WRITE_REGISTER_BUFFER_ULONG(PULONG Register , PULONG
	Buffer , ULONG Count ) ;
#line 4856
__declspec(dllimport) UCHAR READ_PORT_UCHAR(PUCHAR Port ) ;
#line 4862
__declspec(dllimport) USHORT READ_PORT_USHORT(PUSHORT Port ) ;
#line 4868
__declspec(dllimport) ULONG READ_PORT_ULONG(PULONG Port ) ;
#line 4874
__declspec(dllimport) void READ_PORT_BUFFER_UCHAR(PUCHAR Port , PUCHAR Buffer ,
	ULONG Count ) ;
#line 4882
__declspec(dllimport) void READ_PORT_BUFFER_USHORT(PUSHORT Port , PUSHORT Buffer
	, ULONG Count ) ;
#line 4890
__declspec(dllimport) void READ_PORT_BUFFER_ULONG(PULONG Port , PULONG Buffer ,
	ULONG Count ) ;
#line 4898
__declspec(dllimport) void WRITE_PORT_UCHAR(PUCHAR Port , UCHAR Value ) ;
#line 4905
__declspec(dllimport) void WRITE_PORT_USHORT(PUSHORT Port , USHORT Value ) ;
#line 4912
__declspec(dllimport) void WRITE_PORT_ULONG(PULONG Port , ULONG Value ) ;
#line 4919
__declspec(dllimport) void WRITE_PORT_BUFFER_UCHAR(PUCHAR Port , PUCHAR Buffer ,
	ULONG Count ) ;
#line 4927
__declspec(dllimport) void WRITE_PORT_BUFFER_USHORT(PUSHORT Port , PUSHORT
	Buffer , ULONG Count ) ;
#line 4935
__declspec(dllimport) void WRITE_PORT_BUFFER_ULONG(PULONG Port , PULONG Buffer ,
	ULONG Count ) ;

#line 4978
typedef struct _KPCR {
	NT_TIB NtTib ;
	struct _KPCR *  SelfPcr ;
	struct _KPRCB *  Prcb ;
	KIRQL Irql ;
	ULONG IRR ;
	ULONG IrrActive ;
	ULONG IDR ;
	ULONG Reserved2 ;
	struct _KIDTENTRY *  IDT ;
	struct _KGDTENTRY *  GDT ;
	struct _KTSS *  TSS ;
	USHORT MajorVersion ;
	USHORT MinorVersion ;
	KAFFINITY SetMember ;
	ULONG StallScaleFactor ;
	UCHAR DebugActive ;
	UCHAR Number ;
} KPCR ;

#line 5006
typedef KPCR *  PKPCR ;

#line 5012
typedef struct _KFLOATING_SAVE {
	ULONG ControlWord ;
	ULONG StatusWord ;
	ULONG ErrorOffset ;
	ULONG ErrorSelector ;
	ULONG DataOffset ;
	ULONG DataSelector ;
	ULONG Cr0NpxState ;
	ULONG Spare1 ;
} KFLOATING_SAVE , *  PKFLOATING_SAVE ;

#line 5069
extern PVOID *  MmHighestUserAddress ;
extern PVOID *  MmSystemRangeStart ;
extern ULONG *  MmUserProbeAddress ;

#line 5153
typedef enum _INTERLOCKED_RESULT {
	ResultNegative = 0x8000 & ~ 0x4000 & (0x8000 | 0x4000),
	ResultZero = ~ 0x8000 & 0x4000 & (0x8000 | 0x4000),
	ResultPositive = ~ 0x8000 & ~ 0x4000 & (0x8000 | 0x4000)
} INTERLOCKED_RESULT ;

__declspec(dllimport) INTERLOCKED_RESULT _fastcall
	Exfi386InterlockedIncrementLong(PLONG Addend ) ;
#line 5166
__declspec(dllimport) INTERLOCKED_RESULT _fastcall
	Exfi386InterlockedDecrementLong(PLONG Addend ) ;
#line 5173
__declspec(dllimport) LARGE_INTEGER
	ExInterlockedExchangeAddLargeInteger(PLARGE_INTEGER Addend ,
	LARGE_INTEGER Increment , PKSPIN_LOCK Lock ) ;
#line 5181
__declspec(dllimport) ULONG _fastcall Exfi386InterlockedExchangeUlong(PULONG
	Target , ULONG Value ) ;
#line 5197
__declspec(dllimport) LONG _fastcall InterlockedIncrement(PLONG Addend ) ;
#line 5204
__declspec(dllimport) LONG _fastcall InterlockedDecrement(PLONG Addend ) ;
#line 5211
__declspec(dllimport) LONG _fastcall InterlockedExchange(PLONG Target , LONG
	Value ) ;
#line 5222
LONG _fastcall InterlockedExchangeAdd(PLONG Addend , LONG Increment ) ;
#line 5229
__declspec(dllimport) LONG _fastcall InterlockedCompareExchange(PLONG
	Destination , LONG ExChange , LONG Comperand ) ;

#line 5252

#pragma warning(disable:4035)
#line 5262
__declspec(dllimport) KIRQL KeGetCurrentIrql() ;

#line 5271
__inline ULONG KeGetCurrentProcessorNumber(void  )
{
	__asm {  movzx eax, fs:[0] KPCR.Number  };
}

#line 5280
__declspec(dllimport) NTSTATUS __stdcall
	KeSaveFloatingPointState(PKFLOATING_SAVE FloatSave ) ;
#line 5287
__declspec(dllimport) NTSTATUS __stdcall
	KeRestoreFloatingPointState(PKFLOATING_SAVE FloatSave ) ;

#line 6994
typedef struct _KSYSTEM_TIME {
	ULONG LowPart ;
	LONG High1Time ;
	LONG High2Time ;
} KSYSTEM_TIME , *  PKSYSTEM_TIME ;

#line 7014

#pragma warning(push)

#pragma warning(disable:4164)
#line 7019

#pragma function(_enable)
#line 7020

#pragma function(_disable)
#line 7024

#pragma warning(pop)
#line 7085
typedef struct _FLOATING_SAVE_AREA {
	ULONG ControlWord ;
	ULONG StatusWord ;
	ULONG TagWord ;
	ULONG ErrorOffset ;
	ULONG ErrorSelector ;
	ULONG DataOffset ;
	ULONG DataSelector ;
	UCHAR RegisterArea[80] ;
	ULONG Cr0NpxState ;
} FLOATING_SAVE_AREA ;

typedef FLOATING_SAVE_AREA *  PFLOATING_SAVE_AREA ;

#line 7109
typedef struct _CONTEXT {
	ULONG ContextFlags ;
	ULONG Dr0 ;
	ULONG Dr1 ;
	ULONG Dr2 ;
	ULONG Dr3 ;
	ULONG Dr6 ;
	ULONG Dr7 ;
	FLOATING_SAVE_AREA FloatSave ;
	ULONG SegGs ;
	ULONG SegFs ;
	ULONG SegEs ;
	ULONG SegDs ;
	ULONG Edi ;
	ULONG Esi ;
	ULONG Ebx ;
	ULONG Edx ;
	ULONG Ecx ;
	ULONG Eax ;
	ULONG Ebp ;
	ULONG Eip ;
	ULONG SegCs ;
	ULONG EFlags ;
	ULONG Esp ;
	ULONG SegSs ;
	UCHAR ExtendedRegisters[512] ;
} CONTEXT ;

#line 7197
typedef CONTEXT *  PCONTEXT ;

#line 7826
typedef void ( *  PTIMER_APC_ROUTINE )(PVOID TimerContext , ULONG TimerLowValue
	, LONG TimerHighValue ) ;

#line 7850
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE {
	StandardDesign,
	NEC98x86,
	EndAlternatives
} ALTERNATIVE_ARCHITECTURE_TYPE ;

#line 7899
typedef struct _KUSER_SHARED_DATA {
	volatile ULONG TickCountLow ;
	ULONG TickCountMultiplier ;
	volatile KSYSTEM_TIME InterruptTime ;
	volatile KSYSTEM_TIME SystemTime ;
	volatile KSYSTEM_TIME TimeZoneBias ;
	USHORT ImageNumberLow ;
	USHORT ImageNumberHigh ;
	WCHAR NtSystemRoot[260] ;
	ULONG MaxStackTraceDepth ;
	ULONG CryptoExponent ;
	ULONG TimeZoneId ;
	ULONG Reserved2[8] ;
	NT_PRODUCT_TYPE NtProductType ;
	BOOLEAN ProductTypeIsValid ;
	ULONG NtMajorVersion ;
	ULONG NtMinorVersion ;
	BOOLEAN ProcessorFeatures[64] ;
	ULONG Reserved1 ;
	ULONG Reserved3 ;
	volatile ULONG TimeSlip ;
	ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture ;
	LARGE_INTEGER SystemExpirationDate ;
	ULONG SuiteMask ;
	BOOLEAN KdDebuggerEnabled ;
} KUSER_SHARED_DATA , *  PKUSER_SHARED_DATA ;

#line 8123
typedef enum _CM_SERVICE_NODE_TYPE {
	DriverType = 0x00000001,
	FileSystemType = 0x00000002,
	Win32ServiceOwnProcess = 0x00000010,
	Win32ServiceShareProcess = 0x00000020,
	AdapterType = 0x00000004,
	RecognizerType = 0x00000008
} SERVICE_NODE_TYPE ;

typedef enum _CM_SERVICE_LOAD_TYPE {
	BootLoad = 0x00000000,
	SystemLoad = 0x00000001,
	AutoLoad = 0x00000002,
	DemandLoad = 0x00000003,
	DisableLoad = 0x00000004
} SERVICE_LOAD_TYPE ;

typedef enum _CM_ERROR_CONTROL_TYPE {
	IgnoreError = 0x00000000,
	NormalError = 0x00000001,
	SevereError = 0x00000002,
	CriticalError = 0x00000003
} SERVICE_ERROR_TYPE ;

#line 8172
typedef int CM_RESOURCE_TYPE ;

#line 8198
typedef enum _CM_SHARE_DISPOSITION {
	CmResourceShareUndetermined = 0,
	CmResourceShareDeviceExclusive,
	CmResourceShareDriverExclusive,
	CmResourceShareShared
} CM_SHARE_DISPOSITION ;

#line 8211
typedef PVOID PASSIGNED_RESOURCE ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
	UCHAR Type ;
	UCHAR ShareDisposition ;
	USHORT Flags ;
	union  {
		struct  {
			PHYSICAL_ADDRESS Start ;
			ULONG Length ;
		} Generic ;
		struct  {
			PHYSICAL_ADDRESS Start ;
			ULONG Length ;
		} Port ;
		struct  {
			ULONG Level ;
			ULONG Vector ;
			ULONG Affinity ;
		} Interrupt ;
		struct  {
			PHYSICAL_ADDRESS Start ;
			ULONG Length ;
		} Memory ;
		struct  {
			ULONG Channel ;
			ULONG Port ;
			ULONG Reserved1 ;
		} Dma ;
		struct  {
			ULONG Data[3] ;
		} DevicePrivate ;
		struct  {
			ULONG Start ;
			ULONG Length ;
			ULONG Reserved ;
		} BusNumber ;
		struct  {
			ULONG DataSize ;
			ULONG Reserved1 ;
			ULONG Reserved2 ;
		} DeviceSpecificData ;
	} u ;
} CM_PARTIAL_RESOURCE_DESCRIPTOR , *  PCM_PARTIAL_RESOURCE_DESCRIPTOR ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST {
	USHORT Version ;
	USHORT Revision ;
	ULONG Count ;
	CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1] ;
} CM_PARTIAL_RESOURCE_LIST , *  PCM_PARTIAL_RESOURCE_LIST ;

#line 8443
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR {
	INTERFACE_TYPE InterfaceType ;
	ULONG BusNumber ;
	CM_PARTIAL_RESOURCE_LIST PartialResourceList ;
} CM_FULL_RESOURCE_DESCRIPTOR , *  PCM_FULL_RESOURCE_DESCRIPTOR ;

#line 8454
typedef struct _CM_RESOURCE_LIST {
	ULONG Count ;
	CM_FULL_RESOURCE_DESCRIPTOR List[1] ;
} CM_RESOURCE_LIST , *  PCM_RESOURCE_LIST ;

#line 8471
typedef struct _DEVICE_FLAGS {
	ULONG Failed  : 1;
	ULONG ReadOnly  : 1;
	ULONG Removable  : 1;
	ULONG ConsoleIn  : 1;
	ULONG ConsoleOut  : 1;
	ULONG Input  : 1;
	ULONG Output  : 1;
} DEVICE_FLAGS , *  PDEVICE_FLAGS ;

#line 8485
typedef struct _CM_COMPONENT_INFORMATION {
	DEVICE_FLAGS Flags ;
	ULONG Version ;
	ULONG Key ;
	ULONG AffinityMask ;
} CM_COMPONENT_INFORMATION , *  PCM_COMPONENT_INFORMATION ;

#line 8503
typedef struct _CM_ROM_BLOCK {
	ULONG Address ;
	ULONG Size ;
} CM_ROM_BLOCK , *  PCM_ROM_BLOCK ;

#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 8518 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_INT13_DRIVE_PARAMETER {
	USHORT DriveSelect ;
	ULONG MaxCylinders ;
	USHORT SectorsPerTrack ;
	USHORT MaxHeads ;
	USHORT NumberDrives ;
} CM_INT13_DRIVE_PARAMETER , *  PCM_INT13_DRIVE_PARAMETER ;

#line 8532
typedef struct _CM_MCA_POS_DATA {
	USHORT AdapterId ;
	UCHAR PosData1 ;
	UCHAR PosData2 ;
	UCHAR PosData3 ;
	UCHAR PosData4 ;
} CM_MCA_POS_DATA , *  PCM_MCA_POS_DATA ;

#line 8544
typedef struct _EISA_MEMORY_TYPE {
	UCHAR ReadWrite  : 1;
	UCHAR Cached  : 1;
	UCHAR Reserved0  : 1;
	UCHAR Type  : 2;
	UCHAR Shared  : 1;
	UCHAR Reserved1  : 1;
	UCHAR MoreEntries  : 1;
} EISA_MEMORY_TYPE , *  PEISA_MEMORY_TYPE ;

typedef struct _EISA_MEMORY_CONFIGURATION {
	EISA_MEMORY_TYPE ConfigurationByte ;
	UCHAR DataSize ;
	USHORT AddressLowWord ;
	UCHAR AddressHighByte ;
	USHORT MemorySize ;
} EISA_MEMORY_CONFIGURATION , *  PEISA_MEMORY_CONFIGURATION ;

#line 8567
typedef struct _EISA_IRQ_DESCRIPTOR {
	UCHAR Interrupt  : 4;
	UCHAR Reserved  : 1;
	UCHAR LevelTriggered  : 1;
	UCHAR Shared  : 1;
	UCHAR MoreEntries  : 1;
} EISA_IRQ_DESCRIPTOR , *  PEISA_IRQ_DESCRIPTOR ;

typedef struct _EISA_IRQ_CONFIGURATION {
	EISA_IRQ_DESCRIPTOR ConfigurationByte ;
	UCHAR Reserved ;
} EISA_IRQ_CONFIGURATION , *  PEISA_IRQ_CONFIGURATION ;

#line 8585
typedef struct _DMA_CONFIGURATION_BYTE0 {
	UCHAR Channel  : 3;
	UCHAR Reserved  : 3;
	UCHAR Shared  : 1;
	UCHAR MoreEntries  : 1;
} DMA_CONFIGURATION_BYTE0 ;

typedef struct _DMA_CONFIGURATION_BYTE1 {
	UCHAR Reserved0  : 2;
	UCHAR TransferSize  : 2;
	UCHAR Timing  : 2;
	UCHAR Reserved1  : 2;
} DMA_CONFIGURATION_BYTE1 ;

typedef struct _EISA_DMA_CONFIGURATION {
	DMA_CONFIGURATION_BYTE0 ConfigurationByte0 ;
	DMA_CONFIGURATION_BYTE1 ConfigurationByte1 ;
} EISA_DMA_CONFIGURATION , *  PEISA_DMA_CONFIGURATION ;

#line 8609
typedef struct _EISA_PORT_DESCRIPTOR {
	UCHAR NumberPorts  : 5;
	UCHAR Reserved  : 1;
	UCHAR Shared  : 1;
	UCHAR MoreEntries  : 1;
} EISA_PORT_DESCRIPTOR , *  PEISA_PORT_DESCRIPTOR ;

typedef struct _EISA_PORT_CONFIGURATION {
	EISA_PORT_DESCRIPTOR Configuration ;
	USHORT PortAddress ;
} EISA_PORT_CONFIGURATION , *  PEISA_PORT_CONFIGURATION ;

#line 8628
typedef struct _CM_EISA_SLOT_INFORMATION {
	UCHAR ReturnCode ;
	UCHAR ReturnFlags ;
	UCHAR MajorRevision ;
	UCHAR MinorRevision ;
	USHORT Checksum ;
	UCHAR NumberFunctions ;
	UCHAR FunctionInformation ;
	ULONG CompressedId ;
} CM_EISA_SLOT_INFORMATION , *  PCM_EISA_SLOT_INFORMATION ;

#line 8644
typedef struct _CM_EISA_FUNCTION_INFORMATION {
	ULONG CompressedId ;
	UCHAR IdSlotFlags1 ;
	UCHAR IdSlotFlags2 ;
	UCHAR MinorRevision ;
	UCHAR MajorRevision ;
	UCHAR Selections[26] ;
	UCHAR FunctionFlags ;
	UCHAR TypeString[80] ;
	EISA_MEMORY_CONFIGURATION EisaMemory[9] ;
	EISA_IRQ_CONFIGURATION EisaIrq[7] ;
	EISA_DMA_CONFIGURATION EisaDma[4] ;
	EISA_PORT_CONFIGURATION EisaPort[20] ;
	UCHAR InitializationData[60] ;
} CM_EISA_FUNCTION_INFORMATION , *  PCM_EISA_FUNCTION_INFORMATION ;

#line 8678
typedef struct _CM_PNP_BIOS_DEVICE_NODE {
	USHORT Size ;
	UCHAR Node ;
	ULONG ProductId ;
	UCHAR DeviceType[3] ;
	USHORT DeviceAttributes ;
} CM_PNP_BIOS_DEVICE_NODE , *  PCM_PNP_BIOS_DEVICE_NODE ;

#line 8692
typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK {
	UCHAR Signature[4] ;
	UCHAR Revision ;
	UCHAR Length ;
	USHORT ControlField ;
	UCHAR Checksum ;
	ULONG EventFlagAddress ;
	USHORT RealModeEntryOffset ;
	USHORT RealModeEntrySegment ;
	USHORT ProtectedModeEntryOffset ;
	ULONG ProtectedModeCodeBaseAddress ;
	ULONG OemDeviceId ;
	USHORT RealModeDataBaseAddress ;
	ULONG ProtectedModeDataBaseAddress ;
} CM_PNP_BIOS_INSTALLATION_CHECK , *  PCM_PNP_BIOS_INSTALLATION_CHECK ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8761 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_SCSI_DEVICE_DATA {
	USHORT Version ;
	USHORT Revision ;
	UCHAR HostIdentifier ;
} CM_SCSI_DEVICE_DATA , *  PCM_SCSI_DEVICE_DATA ;

#line 8775
typedef struct _CM_VIDEO_DEVICE_DATA {
	USHORT Version ;
	USHORT Revision ;
	ULONG VideoClock ;
} CM_VIDEO_DEVICE_DATA , *  PCM_VIDEO_DEVICE_DATA ;

#line 8785
typedef struct _CM_SONIC_DEVICE_DATA {
	USHORT Version ;
	USHORT Revision ;
	USHORT DataConfigurationRegister ;
	UCHAR EthernetAddress[8] ;
} CM_SONIC_DEVICE_DATA , *  PCM_SONIC_DEVICE_DATA ;

#line 8796
typedef struct _CM_SERIAL_DEVICE_DATA {
	USHORT Version ;
	USHORT Revision ;
	ULONG BaudClock ;
} CM_SERIAL_DEVICE_DATA , *  PCM_SERIAL_DEVICE_DATA ;

#line 8810
typedef struct _CM_MONITOR_DEVICE_DATA {
	USHORT Version ;
	USHORT Revision ;
	USHORT HorizontalScreenSize ;
	USHORT VerticalScreenSize ;
	USHORT HorizontalResolution ;
	USHORT VerticalResolution ;
	USHORT HorizontalDisplayTimeLow ;
	USHORT HorizontalDisplayTime ;
	USHORT HorizontalDisplayTimeHigh ;
	USHORT HorizontalBackPorchLow ;
	USHORT HorizontalBackPorch ;
	USHORT HorizontalBackPorchHigh ;
	USHORT HorizontalFrontPorchLow ;
	USHORT HorizontalFrontPorch ;
	USHORT HorizontalFrontPorchHigh ;
	USHORT HorizontalSyncLow ;
	USHORT HorizontalSync ;
	USHORT HorizontalSyncHigh ;
	USHORT VerticalBackPorchLow ;
	USHORT VerticalBackPorch ;
	USHORT VerticalBackPorchHigh ;
	USHORT VerticalFrontPorchLow ;
	USHORT VerticalFrontPorch ;
	USHORT VerticalFrontPorchHigh ;
	USHORT VerticalSyncLow ;
	USHORT VerticalSync ;
	USHORT VerticalSyncHigh ;
} CM_MONITOR_DEVICE_DATA , *  PCM_MONITOR_DEVICE_DATA ;

#line 8844
typedef struct _CM_FLOPPY_DEVICE_DATA {
	USHORT Version ;
	USHORT Revision ;
	CHAR Size[8] ;
	ULONG MaxDensity ;
	ULONG MountDensity ;
	UCHAR StepRateHeadUnloadTime ;
	UCHAR HeadLoadTime ;
	UCHAR MotorOffTime ;
	UCHAR SectorLengthCode ;
	UCHAR SectorPerTrack ;
	UCHAR ReadWriteGapLength ;
	UCHAR DataTransferLength ;
	UCHAR FormatGapLength ;
	UCHAR FormatFillCharacter ;
	UCHAR HeadSettleTime ;
	UCHAR MotorSettleTime ;
	UCHAR MaximumTrackValue ;
	UCHAR DataTransferRate ;
} CM_FLOPPY_DEVICE_DATA , *  PCM_FLOPPY_DEVICE_DATA ;

#line 8881
typedef struct _CM_KEYBOARD_DEVICE_DATA {
	USHORT Version ;
	USHORT Revision ;
	UCHAR Type ;
	UCHAR Subtype ;
	USHORT KeyboardFlags ;
} CM_KEYBOARD_DEVICE_DATA , *  PCM_KEYBOARD_DEVICE_DATA ;

#line 8893
typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA {
	ULONG BytesPerSector ;
	ULONG NumberOfCylinders ;
	ULONG SectorsPerTrack ;
	ULONG NumberOfHeads ;
} CM_DISK_GEOMETRY_DEVICE_DATA , *  PCM_DISK_GEOMETRY_DEVICE_DATA ;

#line 8905
typedef struct _CM_PCCARD_DEVICE_DATA {
	UCHAR Flags ;
	UCHAR ErrorCode ;
	USHORT Reserved ;
	ULONG BusData ;
	ULONG DeviceId ;
	ULONG LegacyBaseAddress ;
	UCHAR IRQMap[16] ;
} CM_PCCARD_DEVICE_DATA , *  PCM_PCCARD_DEVICE_DATA ;

#line 8944
typedef struct _IO_RESOURCE_DESCRIPTOR {
	UCHAR Option ;
	UCHAR Type ;
	UCHAR ShareDisposition ;
	UCHAR Spare1 ;
	USHORT Flags ;
	USHORT Spare2 ;
	union  {
		struct  {
			ULONG Length ;
			ULONG Alignment ;
			PHYSICAL_ADDRESS MinimumAddress ;
			PHYSICAL_ADDRESS MaximumAddress ;
		} Port ;
		struct  {
			ULONG Length ;
			ULONG Alignment ;
			PHYSICAL_ADDRESS MinimumAddress ;
			PHYSICAL_ADDRESS MaximumAddress ;
		} Memory ;
		struct  {
			ULONG MinimumVector ;
			ULONG MaximumVector ;
		} Interrupt ;
		struct  {
			ULONG MinimumChannel ;
			ULONG MaximumChannel ;
		} Dma ;
		struct  {
			ULONG Length ;
			ULONG Alignment ;
			PHYSICAL_ADDRESS MinimumAddress ;
			PHYSICAL_ADDRESS MaximumAddress ;
		} Generic ;
		struct  {
			ULONG Data[3] ;
		} DevicePrivate ;
		struct  {
			ULONG Length ;
			ULONG MinBusNumber ;
			ULONG MaxBusNumber ;
			ULONG Reserved ;
		} BusNumber ;
		struct  {
			PASSIGNED_RESOURCE AssignedResource ;
		} AssignedResource ;
		struct  {
			UCHAR Type ;
			UCHAR Reserved[3] ;
			PASSIGNED_RESOURCE AssignedResource ;
			PHYSICAL_ADDRESS Transformation ;
		} SubAllocateFrom ;
		struct  {
			ULONG Priority ;
			ULONG Reserved1 ;
			ULONG Reserved2 ;
		} ConfigData ;
	} u ;
} IO_RESOURCE_DESCRIPTOR , *  PIO_RESOURCE_DESCRIPTOR ;

#line 9027
typedef struct _IO_RESOURCE_LIST {
	USHORT Version ;
	USHORT Revision ;
	ULONG Count ;
	IO_RESOURCE_DESCRIPTOR Descriptors[1] ;
} IO_RESOURCE_LIST , *  PIO_RESOURCE_LIST ;

#line 9036
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST {
	ULONG ListSize ;
	INTERFACE_TYPE InterfaceType ;
	ULONG BusNumber ;
	ULONG SlotNumber ;
	ULONG Reserved[3] ;
	ULONG AlternativeLists ;
	IO_RESOURCE_LIST List[1] ;
} IO_RESOURCE_REQUIREMENTS_LIST , *  PIO_RESOURCE_REQUIREMENTS_LIST ;

#line 9065
typedef struct _EXCEPTION_RECORD {
	NTSTATUS ExceptionCode ;
	ULONG ExceptionFlags ;
	struct _EXCEPTION_RECORD *  ExceptionRecord ;
	PVOID ExceptionAddress ;
	ULONG NumberParameters ;
	ULONG_PTR ExceptionInformation[15] ;
} EXCEPTION_RECORD ;

typedef EXCEPTION_RECORD *  PEXCEPTION_RECORD ;

typedef struct _EXCEPTION_RECORD32 {
	NTSTATUS ExceptionCode ;
	ULONG ExceptionFlags ;
	ULONG ExceptionRecord ;
	ULONG ExceptionAddress ;
	ULONG NumberParameters ;
	ULONG ExceptionInformation[15] ;
} EXCEPTION_RECORD32 , *  PEXCEPTION_RECORD32 ;

typedef struct _EXCEPTION_RECORD64 {
	NTSTATUS ExceptionCode ;
	ULONG ExceptionFlags ;
	ULONG64 ExceptionRecord ;
	ULONG64 ExceptionAddress ;
	ULONG NumberParameters ;
	ULONG __unusedAlignment ;
	ULONG64 ExceptionInformation[15] ;
} EXCEPTION_RECORD64 , *  PEXCEPTION_RECORD64 ;

#line 9099
typedef struct _EXCEPTION_POINTERS {
	PEXCEPTION_RECORD ExceptionRecord ;
	PCONTEXT ContextRecord ;
} EXCEPTION_POINTERS , *  PEXCEPTION_POINTERS ;

#line 9111
typedef enum _CONFIGURATION_TYPE {
	ArcSystem,
	CentralProcessor,
	FloatingPointProcessor,
	PrimaryIcache,
	PrimaryDcache,
	SecondaryIcache,
	SecondaryDcache,
	SecondaryCache,
	EisaAdapter,
	TcAdapter,
	ScsiAdapter,
	DtiAdapter,
	MultiFunctionAdapter,
	DiskController,
	TapeController,
	CdromController,
	WormController,
	SerialController,
	NetworkController,
	DisplayController,
	ParallelController,
	PointerController,
	KeyboardController,
	AudioController,
	OtherController,
	DiskPeripheral,
	FloppyDiskPeripheral,
	TapePeripheral,
	ModemPeripheral,
	MonitorPeripheral,
	PrinterPeripheral,
	PointerPeripheral,
	KeyboardPeripheral,
	TerminalPeripheral,
	OtherPeripheral,
	LinePeripheral,
	NetworkPeripheral,
	SystemMemory,
	DockingInformation,
	RealModeIrqRoutingTable,
	MaximumType
} CONFIGURATION_TYPE , *  PCONFIGURATION_TYPE ;

#line 9161
typedef enum _KINTERRUPT_MODE {
	LevelSensitive,
	Latched
} KINTERRUPT_MODE ;

#line 9170
typedef enum _KWAIT_REASON {
	Executive,
	FreePage,
	PageIn,
	PoolAllocation,
	DelayExecution,
	Suspended,
	UserRequest,
	WrExecutive,
	WrFreePage,
	WrPageIn,
	WrPoolAllocation,
	WrDelayExecution,
	WrSuspended,
	WrUserRequest,
	WrEventPair,
	WrQueue,
	WrLpcReceive,
	WrLpcReply,
	WrVirtualMemory,
	WrPageOut,
	WrRendezvous,
	Spare2,
	Spare3,
	Spare4,
	Spare5,
	Spare6,
	WrKernel,
	MaximumWaitReason
} KWAIT_REASON ;

#line 9207
typedef struct _DISPATCHER_HEADER {
	UCHAR Type ;
	UCHAR Absolute ;
	UCHAR Size ;
	UCHAR Inserted ;
	LONG SignalState ;
	LIST_ENTRY WaitListHead ;
} DISPATCHER_HEADER ;

#line 9217
typedef struct _KWAIT_BLOCK {
	LIST_ENTRY WaitListEntry ;
	struct _KTHREAD *  Thread ;
	PVOID Object ;
	struct _KWAIT_BLOCK *  NextWaitBlock ;
	USHORT WaitKey ;
	USHORT WaitType ;
} KWAIT_BLOCK , *  PKWAIT_BLOCK , *  PRKWAIT_BLOCK ;

#line 9230
typedef void ( *  PKSTART_ROUTINE )(PVOID StartContext ) ;

#line 9244
typedef struct _KDEVICE_QUEUE {
	CSHORT Type ;
	CSHORT Size ;
	LIST_ENTRY DeviceListHead ;
	KSPIN_LOCK Lock ;
	BOOLEAN Busy ;
} KDEVICE_QUEUE , *  PKDEVICE_QUEUE , *  PRKDEVICE_QUEUE ;

typedef struct _KDEVICE_QUEUE_ENTRY {
	LIST_ENTRY DeviceListEntry ;
	ULONG SortKey ;
	BOOLEAN Inserted ;
} KDEVICE_QUEUE_ENTRY , *  PKDEVICE_QUEUE_ENTRY , *  PRKDEVICE_QUEUE_ENTRY ;

#line 9263
typedef struct _KEVENT {
	DISPATCHER_HEADER Header ;
} KEVENT , *  PKEVENT , *  PRKEVENT ;

#line 9271
typedef BOOLEAN ( *  PKSERVICE_ROUTINE )(struct _KINTERRUPT *  Interrupt , PVOID
	ServiceContext ) ;

#line 9281
typedef struct _KMUTANT {
	DISPATCHER_HEADER Header ;
	LIST_ENTRY MutantListEntry ;
	struct _KTHREAD *  OwnerThread ;
	BOOLEAN Abandoned ;
	UCHAR ApcDisable ;
} KMUTANT , *  PKMUTANT , *  PRKMUTANT , KMUTEX , *  PKMUTEX , *  PRKMUTEX ;

#line 9294
typedef struct _KSEMAPHORE {
	DISPATCHER_HEADER Header ;
	LONG Limit ;
} KSEMAPHORE , *  PKSEMAPHORE , *  PRKSEMAPHORE ;

#line 9304
typedef struct _KTIMER {
	DISPATCHER_HEADER Header ;
	ULARGE_INTEGER DueTime ;
	LIST_ENTRY TimerListEntry ;
	struct _KDPC *  Dpc ;
	LONG Period ;
} KTIMER , *  PKTIMER , *  PRKTIMER ;

#line 9316
__declspec(dllimport) void KeInitializeDpc(PRKDPC Dpc , PKDEFERRED_ROUTINE
	DeferredRoutine , PVOID DeferredContext ) ;
#line 9324
__declspec(dllimport) BOOLEAN KeInsertQueueDpc(PRKDPC Dpc , PVOID
	SystemArgument1 , PVOID SystemArgument2 ) ;
#line 9332
__declspec(dllimport) BOOLEAN KeRemoveQueueDpc(PRKDPC Dpc ) ;
#line 9340
__declspec(dllimport) void KeSetImportanceDpc(PRKDPC Dpc , KDPC_IMPORTANCE
	Importance ) ;
#line 9347
__declspec(dllimport) void KeSetTargetProcessorDpc(PRKDPC Dpc , CCHAR Number ) ;
#line 9359
__declspec(dllimport) void KeInitializeDeviceQueue(PKDEVICE_QUEUE DeviceQueue )
	;
#line 9365
__declspec(dllimport) BOOLEAN KeInsertDeviceQueue(PKDEVICE_QUEUE DeviceQueue ,
	PKDEVICE_QUEUE_ENTRY DeviceQueueEntry ) ;
#line 9372
__declspec(dllimport) BOOLEAN KeInsertByKeyDeviceQueue(PKDEVICE_QUEUE
	DeviceQueue , PKDEVICE_QUEUE_ENTRY DeviceQueueEntry , ULONG SortKey ) ;
#line 9380
__declspec(dllimport) PKDEVICE_QUEUE_ENTRY KeRemoveDeviceQueue(PKDEVICE_QUEUE
	DeviceQueue ) ;
#line 9386
__declspec(dllimport) PKDEVICE_QUEUE_ENTRY
	KeRemoveByKeyDeviceQueue(PKDEVICE_QUEUE DeviceQueue , ULONG SortKey ) ;
#line 9393
__declspec(dllimport) BOOLEAN KeRemoveEntryDeviceQueue(PKDEVICE_QUEUE
	DeviceQueue , PKDEVICE_QUEUE_ENTRY DeviceQueueEntry ) ;
#line 9400
__declspec(dllimport) BOOLEAN KeSynchronizeExecution(PKINTERRUPT Interrupt ,
	PKSYNCHRONIZE_ROUTINE SynchronizeRoutine , PVOID SynchronizeContext ) ;
#line 9415
__declspec(dllimport) void KeInitializeEvent(PRKEVENT Event , EVENT_TYPE Type ,
	BOOLEAN State ) ;
#line 9423
__declspec(dllimport) void KeClearEvent(PRKEVENT Event ) ;
#line 9429
__declspec(dllimport) LONG KePulseEvent(PRKEVENT Event , KPRIORITY Increment ,
	BOOLEAN Wait ) ;
#line 9437
__declspec(dllimport) LONG KeReadStateEvent(PRKEVENT Event ) ;
#line 9445
__declspec(dllimport) LONG KeResetEvent(PRKEVENT Event ) ;
#line 9451
__declspec(dllimport) LONG KeSetEvent(PRKEVENT Event , KPRIORITY Increment ,
	BOOLEAN Wait ) ;
#line 9463
__declspec(dllimport) void KeInitializeMutex(PRKMUTEX Mutex , ULONG Level ) ;
#line 9472
__declspec(dllimport) LONG KeReleaseMutex(PRKMUTEX Mutex , BOOLEAN Wait ) ;
#line 9483
__declspec(dllimport) void KeInitializeSemaphore(PRKSEMAPHORE Semaphore , LONG
	Count , LONG Limit ) ;
#line 9491
__declspec(dllimport) LONG KeReadStateSemaphore(PRKSEMAPHORE Semaphore ) ;
#line 9497
__declspec(dllimport) LONG KeReleaseSemaphore(PRKSEMAPHORE Semaphore , KPRIORITY
	Increment , LONG Adjustment , BOOLEAN Wait ) ;
#line 9506
__declspec(dllimport) NTSTATUS KeDelayExecutionThread(KPROCESSOR_MODE WaitMode ,
	BOOLEAN Alertable , PLARGE_INTEGER Interval ) ;
#line 9514
__declspec(dllimport) KPRIORITY KeQueryPriorityThread(PKTHREAD Thread ) ;
#line 9520
__declspec(dllimport) LONG KeSetBasePriorityThread(PKTHREAD Thread , LONG
	Increment ) ;
#line 9527
__declspec(dllimport) KPRIORITY KeSetPriorityThread(PKTHREAD Thread , KPRIORITY
	Priority ) ;
#line 9539
__declspec(dllimport) void KeEnterCriticalRegion(void  ) ;
#line 9545
__declspec(dllimport) void KeLeaveCriticalRegion(void  ) ;
#line 9623
__declspec(dllimport) void KeInitializeTimer(PKTIMER Timer ) ;
#line 9629
__declspec(dllimport) void KeInitializeTimerEx(PKTIMER Timer , TIMER_TYPE Type )
	;
#line 9636
__declspec(dllimport) BOOLEAN KeCancelTimer(PKTIMER ) ;
#line 9642
__declspec(dllimport) BOOLEAN KeReadStateTimer(PKTIMER Timer ) ;
#line 9648
__declspec(dllimport) BOOLEAN KeSetTimer(PKTIMER Timer , LARGE_INTEGER DueTime ,
	PKDPC Dpc ) ;
#line 9656
__declspec(dllimport) BOOLEAN KeSetTimerEx(PKTIMER Timer , LARGE_INTEGER DueTime
	, LONG Period , PKDPC Dpc ) ;
#line 9668
__declspec(dllimport) NTSTATUS KeWaitForMultipleObjects(ULONG Count , PVOID
	Object[] , WAIT_TYPE WaitType , KWAIT_REASON WaitReason ,
	KPROCESSOR_MODE WaitMode , BOOLEAN Alertable , PLARGE_INTEGER Timeout ,
	PKWAIT_BLOCK WaitBlockArray ) ;
#line 9681
__declspec(dllimport) NTSTATUS KeWaitForSingleObject(PVOID Object , KWAIT_REASON
	WaitReason , KPROCESSOR_MODE WaitMode , BOOLEAN Alertable ,
	PLARGE_INTEGER Timeout ) ;
#line 9711
__declspec(dllimport) void __stdcall KeInitializeSpinLock(PKSPIN_LOCK SpinLock )
	;
#line 9720
__declspec(dllimport) void _fastcall KefAcquireSpinLockAtDpcLevel(PKSPIN_LOCK
	SpinLock ) ;
#line 9727
__declspec(dllimport) void _fastcall KefReleaseSpinLockFromDpcLevel(PKSPIN_LOCK
	SpinLock ) ;
#line 9737
__declspec(dllimport) KIRQL _fastcall KfAcquireSpinLock(PKSPIN_LOCK SpinLock ) ;
#line 9744
__declspec(dllimport) void _fastcall KfReleaseSpinLock(PKSPIN_LOCK SpinLock ,
	KIRQL NewIrql ) ;
#line 9754
__declspec(dllimport) KIRQL _fastcall KeAcquireSpinLockRaiseToSynch(PKSPIN_LOCK
	SpinLock ) ;
#line 9808
__declspec(dllimport) void _fastcall KfLowerIrql(KIRQL NewIrql ) ;
#line 9815
__declspec(dllimport) KIRQL _fastcall KfRaiseIrql(KIRQL NewIrql ) ;
#line 9824
__declspec(dllimport) KIRQL KeRaiseIrqlToDpcLevel(void  ) ;
#line 9830
__declspec(dllimport) KIRQL KeRaiseIrqlToSynchLevel(void  ) ;
#line 9893
BOOLEAN KeGetBugMessageText(ULONG MessageId , PANSI_STRING ReturnedString ) ;

#line 9899
typedef enum _KBUGCHECK_BUFFER_DUMP_STATE {
	BufferEmpty,
	BufferInserted,
	BufferStarted,
	BufferFinished,
	BufferIncomplete
} KBUGCHECK_BUFFER_DUMP_STATE ;

typedef void ( *  PKBUGCHECK_CALLBACK_ROUTINE )(PVOID Buffer , ULONG Length ) ;

#line 9914
typedef struct _KBUGCHECK_CALLBACK_RECORD {
	LIST_ENTRY Entry ;
	PKBUGCHECK_CALLBACK_ROUTINE CallbackRoutine ;
	PVOID Buffer ;
	ULONG Length ;
	PUCHAR Component ;
	ULONG_PTR Checksum ;
	UCHAR State ;
} KBUGCHECK_CALLBACK_RECORD , *  PKBUGCHECK_CALLBACK_RECORD ;

__declspec(dllimport) __declspec(noreturn) void __stdcall KeBugCheck(ULONG
	BugCheckCode ) ;
#line 9934
__declspec(dllimport) __declspec(noreturn) void KeBugCheckEx(ULONG BugCheckCode
	, ULONG_PTR BugCheckParameter1 , ULONG_PTR BugCheckParameter2 ,
	ULONG_PTR BugCheckParameter3 , ULONG_PTR BugCheckParameter4 ) ;
#line 9950
__declspec(dllimport) BOOLEAN
	KeDeregisterBugCheckCallback(PKBUGCHECK_CALLBACK_RECORD CallbackRecord )
	;
#line 9956
__declspec(dllimport) BOOLEAN
	KeRegisterBugCheckCallback(PKBUGCHECK_CALLBACK_RECORD CallbackRecord ,
	PKBUGCHECK_CALLBACK_ROUTINE CallbackRoutine , PVOID Buffer , ULONG
	Length , PUCHAR Component ) ;
#line 9966
__declspec(dllimport) void KeEnterKernelDebugger(void  ) ;
#line 9973
__declspec(dllimport) ULONGLONG KeQueryInterruptTime(void  ) ;
#line 9979
__declspec(dllimport) void KeQuerySystemTime(PLARGE_INTEGER CurrentTime ) ;
#line 9985
__declspec(dllimport) ULONG KeQueryTimeIncrement(void  ) ;
#line 9992
__declspec(dllimport) KAFFINITY KeQueryActiveProcessors(void  ) ;

#line 10002
typedef void (_fastcall *  PSWAP_CONTEXT_NOTIFY_ROUTINE )(HANDLE OldThreadId ,
	HANDLE NewThreadId ) ;

#line 10009
__declspec(dllimport) void _fastcall
	KeSetSwapContextNotifyRoutine(PSWAP_CONTEXT_NOTIFY_ROUTINE NotifyRoutine
	) ;

#line 10020
typedef LOGICAL (_fastcall *  PTHREAD_SELECT_NOTIFY_ROUTINE )(HANDLE ThreadId )
	;

#line 10026
__declspec(dllimport) void _fastcall
	KeSetThreadSelectNotifyRoutine(PTHREAD_SELECT_NOTIFY_ROUTINE
	NotifyRoutine ) ;

#line 10037
typedef void (_fastcall *  PTIME_UPDATE_NOTIFY_ROUTINE )(HANDLE ThreadId ,
	KPROCESSOR_MODE Mode ) ;

#line 10044
__declspec(dllimport) void _fastcall
	KeSetTimeUpdateNotifyRoutine(PTIME_UPDATE_NOTIFY_ROUTINE NotifyRoutine )
	;
#line 10051
extern volatile KSYSTEM_TIME KeTickCount ;

typedef enum _MEMORY_CACHING_TYPE_ORIG {
	MmFrameBufferCached = 2
} MEMORY_CACHING_TYPE_ORIG ;

typedef enum _MEMORY_CACHING_TYPE {
	MmNonCached = 0,
	MmCached = 1,
	MmWriteCombined = MmFrameBufferCached,
	MmHardwareCoherentCached,
	MmNonCachedUnordered,
	MmUSWCCached,
	MmMaximumCacheType
} MEMORY_CACHING_TYPE ;

#line 10074
extern PBOOLEAN KdDebuggerNotPresent ;
extern PBOOLEAN KdDebuggerEnabled ;

#line 10087
typedef struct _DBGKD_DEBUG_DATA_HEADER64 *  PDBGKD_DEBUG_DATA_HEADER64 ;

BOOLEAN KdRegisterDebuggerDataBlock(ULONG Tag , PDBGKD_DEBUG_DATA_HEADER64
	DataHeader , ULONG Size ) ;
#line 10096
void KdDeregisterDebuggerDataBlock32(PDBGKD_DEBUG_DATA_HEADER64 DataHeader ) ;
#line 10101
void KdDisableDebugger(void  ) ;
#line 10106
void KdEnableDebugger(void  ) ;

#line 10115
typedef enum _POOL_TYPE {
	NonPagedPool,
	PagedPool,
	NonPagedPoolMustSucceed,
	DontUseThisType,
	NonPagedPoolCacheAligned,
	PagedPoolCacheAligned,
	NonPagedPoolCacheAlignedMustS,
	MaxPoolType,
	NonPagedPoolSession = 32,
	PagedPoolSession = NonPagedPoolSession + 1,
	NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
	DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
	NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
	PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
	NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1
} POOL_TYPE ;

#line 10145
__declspec(dllimport) PVOID ExAllocatePool(POOL_TYPE PoolType , SIZE_T
	NumberOfBytes ) ;
#line 10152
__declspec(dllimport) PVOID ExAllocatePoolWithQuota(POOL_TYPE PoolType , SIZE_T
	NumberOfBytes ) ;
#line 10159
__declspec(dllimport) PVOID __stdcall ExAllocatePoolWithTag(POOL_TYPE PoolType ,
	SIZE_T NumberOfBytes , ULONG Tag ) ;

#line 10195
typedef enum _EX_POOL_PRIORITY {
	LowPoolPriority,
	LowPoolPrioritySpecialPoolOverrun = 8,
	LowPoolPrioritySpecialPoolUnderrun = 9,
	NormalPoolPriority = 16,
	NormalPoolPrioritySpecialPoolOverrun = 24,
	NormalPoolPrioritySpecialPoolUnderrun = 25,
	HighPoolPriority = 32,
	HighPoolPrioritySpecialPoolOverrun = 40,
	HighPoolPrioritySpecialPoolUnderrun = 41
} EX_POOL_PRIORITY ;

#line 10208
__declspec(dllimport) PVOID __stdcall ExAllocatePoolWithTagPriority(POOL_TYPE
	PoolType , SIZE_T NumberOfBytes , ULONG Tag , EX_POOL_PRIORITY Priority
	) ;
#line 10224
__declspec(dllimport) PVOID ExAllocatePoolWithQuotaTag(POOL_TYPE PoolType ,
	SIZE_T NumberOfBytes , ULONG Tag ) ;
#line 10236
__declspec(dllimport) void __stdcall ExFreePool(PVOID P ) ;

#line 10247
typedef struct _FAST_MUTEX {
	LONG Count ;
	PKTHREAD Owner ;
	ULONG Contention ;
	KEVENT Event ;
	ULONG OldIrql ;
} FAST_MUTEX , *  PFAST_MUTEX ;

#line 10272
__declspec(dllimport) void _fastcall ExAcquireFastMutexUnsafe(PFAST_MUTEX
	FastMutex ) ;
#line 10279
__declspec(dllimport) void _fastcall ExReleaseFastMutexUnsafe(PFAST_MUTEX
	FastMutex ) ;
#line 10315
__declspec(dllimport) void _fastcall ExAcquireFastMutex(PFAST_MUTEX FastMutex )
	;
#line 10322
__declspec(dllimport) void _fastcall ExReleaseFastMutex(PFAST_MUTEX FastMutex )
	;
#line 10331
__declspec(dllimport) BOOLEAN _fastcall ExTryToAcquireFastMutex(PFAST_MUTEX
	FastMutex ) ;
#line 10348
__declspec(dllimport) void _fastcall
	ExInterlockedAddLargeStatistic(PLARGE_INTEGER Addend , ULONG Increment )
	;
#line 10358
__declspec(dllimport) LARGE_INTEGER ExInterlockedAddLargeInteger(PLARGE_INTEGER
	Addend , LARGE_INTEGER Increment , PKSPIN_LOCK Lock ) ;
#line 10367
__declspec(dllimport) ULONG _fastcall ExfInterlockedAddUlong(PULONG Addend ,
	ULONG Increment , PKSPIN_LOCK Lock ) ;
#line 10394
__declspec(dllimport) LONGLONG _fastcall
	ExInterlockedCompareExchange64(PLONGLONG Destination , PLONGLONG
	Exchange , PLONGLONG Comperand , PKSPIN_LOCK Lock ) ;
#line 10406
__declspec(dllimport) PLIST_ENTRY _fastcall
	ExfInterlockedInsertHeadList(PLIST_ENTRY ListHead , PLIST_ENTRY
	ListEntry , PKSPIN_LOCK Lock ) ;
#line 10415
__declspec(dllimport) PLIST_ENTRY _fastcall
	ExfInterlockedInsertTailList(PLIST_ENTRY ListHead , PLIST_ENTRY
	ListEntry , PKSPIN_LOCK Lock ) ;
#line 10424
__declspec(dllimport) PLIST_ENTRY _fastcall
	ExfInterlockedRemoveHeadList(PLIST_ENTRY ListHead , PKSPIN_LOCK Lock ) ;
#line 10432
__declspec(dllimport) PSINGLE_LIST_ENTRY _fastcall
	ExfInterlockedPopEntryList(PSINGLE_LIST_ENTRY ListHead , PKSPIN_LOCK
	Lock ) ;
#line 10440
__declspec(dllimport) PSINGLE_LIST_ENTRY _fastcall
	ExfInterlockedPushEntryList(PSINGLE_LIST_ENTRY ListHead ,
	PSINGLE_LIST_ENTRY ListEntry , PKSPIN_LOCK Lock ) ;
#line 10547
__declspec(dllimport) PSINGLE_LIST_ENTRY _fastcall
	ExInterlockedPopEntrySList(PSLIST_HEADER ListHead , PKSPIN_LOCK Lock ) ;
#line 10555
__declspec(dllimport) PSINGLE_LIST_ENTRY _fastcall
	ExInterlockedPushEntrySList(PSLIST_HEADER ListHead , PSINGLE_LIST_ENTRY
	ListEntry , PKSPIN_LOCK Lock ) ;
#line 10564
__declspec(dllimport) PSINGLE_LIST_ENTRY _fastcall
	ExInterlockedFlushSList(PSLIST_HEADER ListHead ) ;

#line 10574
typedef PVOID ( *  PALLOCATE_FUNCTION )(POOL_TYPE PoolType , SIZE_T
	NumberOfBytes , ULONG Tag ) ;

#line 10582
typedef void ( *  PFREE_FUNCTION )(PVOID Buffer ) ;

#line 10588
typedef struct _GENERAL_LOOKASIDE {
	SLIST_HEADER ListHead ;
	USHORT Depth ;
	USHORT MaximumDepth ;
	ULONG TotalAllocates ;
	union  {
		ULONG AllocateMisses ;
		ULONG AllocateHits ;
	}  ;
	ULONG TotalFrees ;
	union  {
		ULONG FreeMisses ;
		ULONG FreeHits ;
	}  ;
	POOL_TYPE Type ;
	ULONG Tag ;
	ULONG Size ;
	PALLOCATE_FUNCTION Allocate ;
	PFREE_FUNCTION Free ;
	LIST_ENTRY ListEntry ;
	ULONG LastTotalAllocates ;
	union  {
		ULONG LastAllocateMisses ;
		ULONG LastAllocateHits ;
	}  ;
	ULONG Future[2] ;
} GENERAL_LOOKASIDE , *  PGENERAL_LOOKASIDE ;

#line 10619
typedef struct _NPAGED_LOOKASIDE_LIST {
	GENERAL_LOOKASIDE L ;
	KSPIN_LOCK Lock ;
} NPAGED_LOOKASIDE_LIST , *  PNPAGED_LOOKASIDE_LIST ;

#line 10625
__declspec(dllimport)
	void ExInitializeNPagedLookasideList(PNPAGED_LOOKASIDE_LIST Lookaside ,
	PALLOCATE_FUNCTION Allocate , PFREE_FUNCTION Free , ULONG Flags , SIZE_T
	Size , ULONG Tag , USHORT Depth ) ;
#line 10637
__declspec(dllimport) void ExDeleteNPagedLookasideList(PNPAGED_LOOKASIDE_LIST
	Lookaside ) ;

#line 10643
__inline PVOID ExAllocateFromNPagedLookasideList(PNPAGED_LOOKASIDE_LIST
	Lookaside )
{
	#line 10670
	PVOID Entry ;
	#line 10672
	(Lookaside->L).TotalAllocates += 1;
	Entry = ExInterlockedPopEntrySList(& (Lookaside->L).ListHead, &
		Lookaside->Lock);
	#line 10674
	if(Entry == (void *  )0)
	{
		#line 10675
		(Lookaside->L).AllocateMisses += 1;
		Entry = ((Lookaside->L).Allocate)((Lookaside->L).Type,
			(Lookaside->L).Size, (Lookaside->L).Tag);
	}
	#line 10681
	return Entry;
}

__inline void ExFreeToNPagedLookasideList(PNPAGED_LOOKASIDE_LIST Lookaside ,
	PVOID Entry )
{
	#line 10713
	(Lookaside->L).TotalFrees += 1;
	if((USHORT )(& (Lookaside->L).ListHead)->Depth >= (Lookaside->L).Depth)
	{
		#line 10715
		(Lookaside->L).FreeMisses += 1;
		((Lookaside->L).Free)(Entry);
	}
	else
	{
		#line 10719
		ExInterlockedPushEntrySList(& (Lookaside->L).ListHead,
			(PSINGLE_LIST_ENTRY )Entry, & Lookaside->Lock);
	}
	#line 10724
	return;
}

#line 10729
typedef struct _PAGED_LOOKASIDE_LIST {
	GENERAL_LOOKASIDE L ;
	FAST_MUTEX Lock ;
} PAGED_LOOKASIDE_LIST , *  PPAGED_LOOKASIDE_LIST ;

__declspec(dllimport) void ExInitializePagedLookasideList(PPAGED_LOOKASIDE_LIST
	Lookaside , PALLOCATE_FUNCTION Allocate , PFREE_FUNCTION Free , ULONG
	Flags , SIZE_T Size , ULONG Tag , USHORT Depth ) ;
#line 10746
__declspec(dllimport) void ExDeletePagedLookasideList(PPAGED_LOOKASIDE_LIST
	Lookaside ) ;
#line 10754
__declspec(dllimport) PVOID
	ExAllocateFromPagedLookasideList(PPAGED_LOOKASIDE_LIST Lookaside ) ;
#line 10760
__declspec(dllimport) void ExFreeToPagedLookasideList(PPAGED_LOOKASIDE_LIST
	Lookaside , PVOID Entry ) ;
#line 10856
__declspec(dllimport) void __stdcall ProbeForRead(const void *  Address , ULONG
	Length , ULONG Alignment ) ;
#line 10869
__declspec(dllimport) void __stdcall ProbeForWrite(PVOID Address , ULONG Length
	, ULONG Alignment ) ;

#line 10882
typedef enum _WORK_QUEUE_TYPE {
	CriticalWorkQueue,
	DelayedWorkQueue,
	HyperCriticalWorkQueue,
	MaximumWorkQueue
} WORK_QUEUE_TYPE ;

typedef void ( *  PWORKER_THREAD_ROUTINE )(PVOID Parameter ) ;

#line 10895
typedef struct _WORK_QUEUE_ITEM {
	LIST_ENTRY List ;
	PWORKER_THREAD_ROUTINE WorkerRoutine ;
	PVOID Parameter ;
} WORK_QUEUE_ITEM , *  PWORK_QUEUE_ITEM ;

#line 10907
__declspec(dllimport) void ExQueueWorkItem(PWORK_QUEUE_ITEM WorkItem ,
	WORK_QUEUE_TYPE QueueType ) ;
#line 10916
__declspec(dllimport) BOOLEAN ExIsProcessorFeaturePresent(ULONG ProcessorFeature
	) ;

#line 10926
typedef struct _ZONE_SEGMENT_HEADER {
	SINGLE_LIST_ENTRY SegmentList ;
	PVOID Reserved ;
} ZONE_SEGMENT_HEADER , *  PZONE_SEGMENT_HEADER ;

typedef struct _ZONE_HEADER {
	SINGLE_LIST_ENTRY FreeList ;
	SINGLE_LIST_ENTRY SegmentList ;
	ULONG BlockSize ;
	ULONG TotalSegmentSize ;
} ZONE_HEADER , *  PZONE_HEADER ;

#line 10939
__declspec(dllimport) NTSTATUS ExInitializeZone(PZONE_HEADER Zone , ULONG
	BlockSize , PVOID InitialSegment , ULONG InitialSegmentSize ) ;
#line 10948
__declspec(dllimport) NTSTATUS ExExtendZone(PZONE_HEADER Zone , PVOID Segment ,
	ULONG SegmentSize ) ;
#line 10956
__declspec(dllimport) NTSTATUS ExInterlockedExtendZone(PZONE_HEADER Zone , PVOID
	Segment , ULONG SegmentSize , PKSPIN_LOCK Lock ) ;

#line 11156
typedef ULONG_PTR ERESOURCE_THREAD ;

#line 11157
typedef ERESOURCE_THREAD *  PERESOURCE_THREAD ;

typedef struct _OWNER_ENTRY {
	ERESOURCE_THREAD OwnerThread ;
	union  {
		LONG OwnerCount ;
		ULONG TableSize ;
	}  ;
} OWNER_ENTRY , *  POWNER_ENTRY ;

#line 11168
typedef struct _ERESOURCE {
	LIST_ENTRY SystemResourcesList ;
	POWNER_ENTRY OwnerTable ;
	SHORT ActiveCount ;
	USHORT Flag ;
	PKSEMAPHORE SharedWaiters ;
	PKEVENT ExclusiveWaiters ;
	OWNER_ENTRY OwnerThreads[2] ;
	ULONG ContentionCount ;
	USHORT NumberOfSharedWaiters ;
	USHORT NumberOfExclusiveWaiters ;
	union  {
		PVOID Address ;
		ULONG_PTR CreatorBackTraceIndex ;
	}  ;
	KSPIN_LOCK SpinLock ;
} ERESOURCE , *  PERESOURCE ;

#line 11197
typedef struct _RESOURCE_HASH_ENTRY {
	LIST_ENTRY ListEntry ;
	PVOID Address ;
	ULONG ContentionCount ;
	ULONG Number ;
} RESOURCE_HASH_ENTRY , *  PRESOURCE_HASH_ENTRY ;

typedef struct _RESOURCE_PERFORMANCE_DATA {
	ULONG ActiveResourceCount ;
	ULONG TotalResourceCount ;
	ULONG ExclusiveAcquire ;
	ULONG SharedFirstLevel ;
	ULONG SharedSecondLevel ;
	ULONG StarveFirstLevel ;
	ULONG StarveSecondLevel ;
	ULONG WaitForExclusive ;
	ULONG OwnerTableExpands ;
	ULONG MaximumTableExpand ;
	LIST_ENTRY HashTable[64] ;
} RESOURCE_PERFORMANCE_DATA , *  PRESOURCE_PERFORMANCE_DATA ;

#line 11222
__declspec(dllimport) NTSTATUS ExInitializeResourceLite(PERESOURCE Resource ) ;
#line 11228
__declspec(dllimport) NTSTATUS ExReinitializeResourceLite(PERESOURCE Resource )
	;
#line 11234
__declspec(dllimport) BOOLEAN ExAcquireResourceSharedLite(PERESOURCE Resource ,
	BOOLEAN Wait ) ;
#line 11241
__declspec(dllimport) BOOLEAN ExAcquireResourceExclusiveLite(PERESOURCE Resource
	, BOOLEAN Wait ) ;
#line 11248
__declspec(dllimport) BOOLEAN ExAcquireSharedStarveExclusive(PERESOURCE Resource
	, BOOLEAN Wait ) ;
#line 11255
__declspec(dllimport) BOOLEAN ExAcquireSharedWaitForExclusive(PERESOURCE
	Resource , BOOLEAN Wait ) ;
#line 11262
__declspec(dllimport) BOOLEAN ExTryToAcquireResourceExclusiveLite(PERESOURCE
	Resource ) ;
#line 11277
__declspec(dllimport) void _fastcall ExReleaseResourceLite(PERESOURCE Resource )
	;
#line 11284
__declspec(dllimport) void ExReleaseResourceForThreadLite(PERESOURCE Resource ,
	ERESOURCE_THREAD ResourceThreadId ) ;
#line 11291
__declspec(dllimport) void ExSetResourceOwnerPointer(PERESOURCE Resource , PVOID
	OwnerPointer ) ;
#line 11298
__declspec(dllimport) void ExConvertExclusiveToSharedLite(PERESOURCE Resource )
	;
#line 11304
__declspec(dllimport) NTSTATUS ExDeleteResourceLite(PERESOURCE Resource ) ;
#line 11310
__declspec(dllimport) ULONG ExGetExclusiveWaiterCount(PERESOURCE Resource ) ;
#line 11316
__declspec(dllimport) ULONG ExGetSharedWaiterCount(PERESOURCE Resource ) ;
#line 11330
__declspec(dllimport) BOOLEAN ExIsResourceAcquiredExclusiveLite(PERESOURCE
	Resource ) ;
#line 11336
__declspec(dllimport) ULONG ExIsResourceAcquiredSharedLite(PERESOURCE Resource )
	;
#line 11360
__declspec(dllimport) KPROCESSOR_MODE ExGetPreviousMode(void  ) ;
#line 11369
__declspec(dllimport) void __stdcall ExRaiseStatus(NTSTATUS Status ) ;
#line 11378
__declspec(dllimport) void ExRaiseDatatypeMisalignment(void  ) ;
#line 11384
__declspec(dllimport) void ExRaiseAccessViolation(void  ) ;
#line 11394
__declspec(dllimport) ULONG ExSetTimerResolution(ULONG DesiredTime , BOOLEAN
	SetResolution ) ;
#line 11406
__declspec(dllimport) void ExSystemTimeToLocalTime(PLARGE_INTEGER SystemTime ,
	PLARGE_INTEGER LocalTime ) ;
#line 11417
__declspec(dllimport) void ExLocalTimeToSystemTime(PLARGE_INTEGER LocalTime ,
	PLARGE_INTEGER SystemTime ) ;

#line 11429
typedef struct _CALLBACK_OBJECT *  PCALLBACK_OBJECT___0 ;

typedef void ( *  PCALLBACK_FUNCTION )(PVOID CallbackContext , PVOID Argument1 ,
	PVOID Argument2 ) ;

#line 11438
__declspec(dllimport) NTSTATUS ExCreateCallback(PCALLBACK_OBJECT___0 * 
	CallbackObject , POBJECT_ATTRIBUTES ObjectAttributes , BOOLEAN Create ,
	BOOLEAN AllowMultipleCallbacks ) ;
#line 11447
__declspec(dllimport) PVOID ExRegisterCallback(PCALLBACK_OBJECT___0
	CallbackObject , PCALLBACK_FUNCTION CallbackFunction , PVOID
	CallbackContext ) ;
#line 11455
__declspec(dllimport) void ExUnregisterCallback(PVOID CallbackRegistration ) ;
#line 11461
__declspec(dllimport) void ExNotifyCallback(PVOID CallbackObject , PVOID
	Argument1 , PVOID Argument2 ) ;

#line 11474
typedef GUID UUID ;

__declspec(dllimport) NTSTATUS ExUuidCreate(UUID *  Uuid ) ;
#line 11596
extern PBOOLEAN Mm64BitPhysicalAddress ;

#line 11862
typedef enum _MM_SYSTEM_SIZE {
	MmSmallSystem,
	MmMediumSystem,
	MmLargeSystem
} MM_SYSTEMSIZE ;

__declspec(dllimport) MM_SYSTEMSIZE MmQuerySystemSize(void  ) ;
#line 11876
__declspec(dllimport) BOOLEAN MmIsThisAnNtAsSystem(void  ) ;

#line 11884
typedef enum _LOCK_OPERATION {
	IoReadAccess,
	IoWriteAccess,
	IoModifyAccess
} LOCK_OPERATION ;

#line 11891
__declspec(dllimport) void MmProbeAndLockProcessPages(PMDL MemoryDescriptorList
	, PEPROCESS Process , KPROCESSOR_MODE AccessMode , LOCK_OPERATION
	Operation ) ;
#line 11906
__declspec(dllimport) void MmProbeAndLockPages(PMDL MemoryDescriptorList ,
	KPROCESSOR_MODE AccessMode , LOCK_OPERATION Operation ) ;
#line 11915
__declspec(dllimport) void MmUnlockPages(PMDL MemoryDescriptorList ) ;
#line 11921
__declspec(dllimport) void MmBuildMdlForNonPagedPool(PMDL MemoryDescriptorList )
	;
#line 11927
__declspec(dllimport) PVOID MmMapLockedPages(PMDL MemoryDescriptorList ,
	KPROCESSOR_MODE AccessMode ) ;
#line 11934
__declspec(dllimport) PVOID MmGetSystemRoutineAddress(PUNICODE_STRING
	SystemRoutineName ) ;
#line 11942
__declspec(dllimport) NTSTATUS MmMapUserAddressesToPage(PVOID BaseAddress ,
	SIZE_T NumberOfBytes , PVOID PageAddress ) ;

#line 11970
typedef enum _MM_PAGE_PRIORITY {
	LowPagePriority,
	NormalPagePriority = 16,
	HighPagePriority = 32
} MM_PAGE_PRIORITY ;

#line 11979
__declspec(dllimport) PVOID MmMapLockedPagesSpecifyCache(PMDL
	MemoryDescriptorList , KPROCESSOR_MODE AccessMode , MEMORY_CACHING_TYPE
	CacheType , PVOID BaseAddress , ULONG BugCheckOnFailure ,
	MM_PAGE_PRIORITY Priority ) ;
#line 11990
__declspec(dllimport) void MmUnmapLockedPages(PVOID BaseAddress , PMDL
	MemoryDescriptorList ) ;

#line 11999
typedef struct _PHYSICAL_MEMORY_RANGE {
	PHYSICAL_ADDRESS BaseAddress ;
	LARGE_INTEGER NumberOfBytes ;
} PHYSICAL_MEMORY_RANGE , *  PPHYSICAL_MEMORY_RANGE ;

__declspec(dllimport) NTSTATUS MmAddPhysicalMemory(PPHYSICAL_ADDRESS
	StartAddress , PLARGE_INTEGER NumberOfBytes ) ;
#line 12011
__declspec(dllimport) NTSTATUS MmRemovePhysicalMemory(PPHYSICAL_ADDRESS
	StartAddress , PLARGE_INTEGER NumberOfBytes ) ;
#line 12018
__declspec(dllimport) PPHYSICAL_MEMORY_RANGE MmGetPhysicalMemoryRanges(void  ) ;
#line 12024
__declspec(dllimport) PMDL MmAllocatePagesForMdl(PHYSICAL_ADDRESS LowAddress ,
	PHYSICAL_ADDRESS HighAddress , PHYSICAL_ADDRESS SkipBytes , SIZE_T
	TotalBytes ) ;
#line 12033
__declspec(dllimport) void MmFreePagesFromMdl(PMDL MemoryDescriptorList ) ;
#line 12041
__declspec(dllimport) PVOID MmMapIoSpace(PHYSICAL_ADDRESS PhysicalAddress ,
	SIZE_T NumberOfBytes , MEMORY_CACHING_TYPE CacheType ) ;
#line 12049
__declspec(dllimport) void MmUnmapIoSpace(PVOID BaseAddress , SIZE_T
	NumberOfBytes ) ;
#line 12057
__declspec(dllimport) PVOID MmMapVideoDisplay(PHYSICAL_ADDRESS PhysicalAddress ,
	SIZE_T NumberOfBytes , MEMORY_CACHING_TYPE CacheType ) ;
#line 12065
__declspec(dllimport) void MmUnmapVideoDisplay(PVOID BaseAddress , SIZE_T
	NumberOfBytes ) ;
#line 12072
__declspec(dllimport) PHYSICAL_ADDRESS MmGetPhysicalAddress(PVOID BaseAddress )
	;
#line 12078
__declspec(dllimport) PVOID MmGetVirtualForPhysical(PHYSICAL_ADDRESS
	PhysicalAddress ) ;
#line 12084
__declspec(dllimport) PVOID MmAllocateContiguousMemory(SIZE_T NumberOfBytes ,
	PHYSICAL_ADDRESS HighestAcceptableAddress ) ;
#line 12091
__declspec(dllimport) PVOID MmAllocateContiguousMemorySpecifyCache(SIZE_T
	NumberOfBytes , PHYSICAL_ADDRESS LowestAcceptableAddress ,
	PHYSICAL_ADDRESS HighestAcceptableAddress , PHYSICAL_ADDRESS
	BoundaryAddressMultiple , MEMORY_CACHING_TYPE CacheType ) ;
#line 12101
__declspec(dllimport) void MmFreeContiguousMemory(PVOID BaseAddress ) ;
#line 12107
__declspec(dllimport) void MmFreeContiguousMemorySpecifyCache(PVOID BaseAddress
	, SIZE_T NumberOfBytes , MEMORY_CACHING_TYPE CacheType ) ;
#line 12116
__declspec(dllimport) PVOID MmAllocateNonCachedMemory(SIZE_T NumberOfBytes ) ;
#line 12122
__declspec(dllimport) void MmFreeNonCachedMemory(PVOID BaseAddress , SIZE_T
	NumberOfBytes ) ;
#line 12129
__declspec(dllimport) BOOLEAN MmIsAddressValid(PVOID VirtualAddress ) ;
#line 12135
__declspec(dllimport) BOOLEAN MmIsNonPagedSystemAddressValid(PVOID
	VirtualAddress ) ;
#line 12143
__declspec(dllimport) SIZE_T MmSizeOfMdl(PVOID Base , SIZE_T Length ) ;
#line 12150
__declspec(dllimport) PMDL MmCreateMdl(PMDL MemoryDescriptorList , PVOID Base ,
	SIZE_T Length ) ;
#line 12158
__declspec(dllimport) PVOID MmLockPagableDataSection(PVOID AddressWithinSection
	) ;
#line 12166
__declspec(dllimport) void MmLockPagableSectionByHandle(PVOID ImageSectionHandle
	) ;
#line 12172
__declspec(dllimport) void MmResetDriverPaging(PVOID AddressWithinSection ) ;
#line 12179
__declspec(dllimport) PVOID MmPageEntireDriver(PVOID AddressWithinSection ) ;
#line 12185
__declspec(dllimport) void MmUnlockPagableImageSection(PVOID ImageSectionHandle
	) ;
#line 12193
__declspec(dllimport) HANDLE MmSecureVirtualMemory(PVOID Address , SIZE_T Size ,
	ULONG ProbeMode ) ;
#line 12201
__declspec(dllimport) void MmUnsecureVirtualMemory(HANDLE SecureHandle ) ;
#line 12207
__declspec(dllimport) NTSTATUS MmMapViewInSystemSpace(PVOID Section , PVOID * 
	MappedBase , PSIZE_T ViewSize ) ;
#line 12215
__declspec(dllimport) NTSTATUS MmUnmapViewInSystemSpace(PVOID MappedBase ) ;
#line 12221
__declspec(dllimport) NTSTATUS MmMapViewInSessionSpace(PVOID Section , PVOID * 
	MappedBase , PSIZE_T ViewSize ) ;
#line 12229
__declspec(dllimport) NTSTATUS MmUnmapViewInSessionSpace(PVOID MappedBase ) ;

#line 12385
typedef NTSTATUS ( *  PMM_DLL_INITIALIZE )(PUNICODE_STRING RegistryPath ) ;

#line 12389
typedef NTSTATUS ( *  PMM_DLL_UNLOAD )(void  ) ;

#line 12399
struct _DRIVER_OBJECT ;

__declspec(dllimport) LOGICAL MmIsDriverVerifying(struct _DRIVER_OBJECT * 
	DriverObject ) ;

#line 12411
typedef enum _SECURITY_OPERATION_CODE {
	SetSecurityDescriptor,
	QuerySecurityDescriptor,
	DeleteSecurityDescriptor,
	AssignSecurityDescriptor
} SECURITY_OPERATION_CODE , *  PSECURITY_OPERATION_CODE ;

#line 12426
typedef struct _SECURITY_SUBJECT_CONTEXT {
	PACCESS_TOKEN ClientToken ;
	SECURITY_IMPERSONATION_LEVEL ImpersonationLevel ;
	PACCESS_TOKEN PrimaryToken ;
	PVOID ProcessAuditId ;
} SECURITY_SUBJECT_CONTEXT , *  PSECURITY_SUBJECT_CONTEXT ;

#line 12448
typedef struct _INITIAL_PRIVILEGE_SET {
	ULONG PrivilegeCount ;
	ULONG Control ;
	LUID_AND_ATTRIBUTES Privilege[3] ;
} INITIAL_PRIVILEGE_SET , *  PINITIAL_PRIVILEGE_SET ;

#line 12462
typedef struct _ACCESS_STATE {
	LUID OperationID ;
	BOOLEAN SecurityEvaluated ;
	BOOLEAN GenerateAudit ;
	BOOLEAN GenerateOnClose ;
	BOOLEAN PrivilegesAllocated ;
	ULONG Flags ;
	ACCESS_MASK RemainingDesiredAccess ;
	ACCESS_MASK PreviouslyGrantedAccess ;
	ACCESS_MASK OriginalDesiredAccess ;
	SECURITY_SUBJECT_CONTEXT SubjectSecurityContext ;
	PSECURITY_DESCRIPTOR SecurityDescriptor ;
	PVOID AuxData ;
	union  {
		INITIAL_PRIVILEGE_SET InitialPrivilegeSet ;
		PRIVILEGE_SET PrivilegeSet ;
	} Privileges ;
	BOOLEAN AuditPrivileges ;
	UNICODE_STRING ObjectName ;
	UNICODE_STRING ObjectTypeName ;
} ACCESS_STATE , *  PACCESS_STATE ;

#line 12487
__declspec(dllimport) NTSTATUS SeAssignSecurity(PSECURITY_DESCRIPTOR
	ParentDescriptor , PSECURITY_DESCRIPTOR ExplicitDescriptor ,
	PSECURITY_DESCRIPTOR *  NewDescriptor , BOOLEAN IsDirectoryObject ,
	PSECURITY_SUBJECT_CONTEXT SubjectContext , PGENERIC_MAPPING
	GenericMapping , POOL_TYPE PoolType ) ;
#line 12499
__declspec(dllimport) NTSTATUS SeAssignSecurityEx(PSECURITY_DESCRIPTOR
	ParentDescriptor , PSECURITY_DESCRIPTOR ExplicitDescriptor ,
	PSECURITY_DESCRIPTOR *  NewDescriptor , GUID *  ObjectType , BOOLEAN
	IsDirectoryObject , ULONG AutoInheritFlags , PSECURITY_SUBJECT_CONTEXT
	SubjectContext , PGENERIC_MAPPING GenericMapping , POOL_TYPE PoolType )
	;
#line 12513
__declspec(dllimport) NTSTATUS SeDeassignSecurity(PSECURITY_DESCRIPTOR * 
	SecurityDescriptor ) ;
#line 12519
__declspec(dllimport) BOOLEAN SeAccessCheck(PSECURITY_DESCRIPTOR
	SecurityDescriptor , PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext ,
	BOOLEAN SubjectContextLocked , ACCESS_MASK DesiredAccess , ACCESS_MASK
	PreviouslyGrantedAccess , PPRIVILEGE_SET *  Privileges ,
	PGENERIC_MAPPING GenericMapping , KPROCESSOR_MODE AccessMode ,
	PACCESS_MASK GrantedAccess , PNTSTATUS AccessStatus ) ;
#line 12535
__declspec(dllimport) BOOLEAN SeValidSecurityDescriptor(ULONG Length ,
	PSECURITY_DESCRIPTOR SecurityDescriptor ) ;
#line 12542
__declspec(dllimport) BOOLEAN SeSinglePrivilegeCheck(LUID PrivilegeValue ,
	KPROCESSOR_MODE PreviousMode ) ;
#line 12552
__declspec(dllimport) NTSTATUS PsCreateSystemThread(PHANDLE ThreadHandle , ULONG
	DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes , HANDLE
	ProcessHandle , PCLIENT_ID ClientId , PKSTART_ROUTINE StartRoutine ,
	PVOID StartContext ) ;
#line 12564
__declspec(dllimport) NTSTATUS PsTerminateSystemThread(NTSTATUS ExitStatus ) ;

#line 12571
typedef void ( *  PCREATE_PROCESS_NOTIFY_ROUTINE )(HANDLE ParentId , HANDLE
	ProcessId , BOOLEAN Create ) ;

#line 12579
NTSTATUS PsSetCreateProcessNotifyRoutine(PCREATE_PROCESS_NOTIFY_ROUTINE
	NotifyRoutine , BOOLEAN Remove ) ;

#line 12585
typedef void ( *  PCREATE_THREAD_NOTIFY_ROUTINE )(HANDLE ProcessId , HANDLE
	ThreadId , BOOLEAN Create ) ;

#line 12593
NTSTATUS PsSetCreateThreadNotifyRoutine(PCREATE_THREAD_NOTIFY_ROUTINE
	NotifyRoutine ) ;

#line 12602
typedef struct _IMAGE_INFO {
	union  {
		ULONG Properties ;
		struct  {
			ULONG ImageAddressingMode  : 8;
			ULONG SystemModeImage  : 1;
			ULONG ImageMappedToAllPids  : 1;
			ULONG Reserved  : 22;
		}  ;
	}  ;
	PVOID ImageBase ;
	ULONG ImageSelector ;
	SIZE_T ImageSize ;
	ULONG ImageSectionNumber ;
} IMAGE_INFO , *  PIMAGE_INFO ;

#line 12620
typedef void ( *  PLOAD_IMAGE_NOTIFY_ROUTINE )(PUNICODE_STRING FullImageName ,
	HANDLE ProcessId , PIMAGE_INFO ImageInfo ) ;

#line 12628
NTSTATUS PsSetLoadImageNotifyRoutine(PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine )
	;
#line 12633
HANDLE PsGetCurrentProcessId(void  ) ;
#line 12636
HANDLE PsGetCurrentThreadId(void  ) ;
#line 12639
BOOLEAN PsGetVersion(PULONG MajorVersion , PULONG MinorVersion , PULONG
	BuildNumber , PUNICODE_STRING CSDVersion ) ;

#line 12859
typedef NTSTATUS ( *  PIO_QUERY_DEVICE_ROUTINE )(PVOID Context , PUNICODE_STRING
	PathName , INTERFACE_TYPE BusType , ULONG BusNumber ,
	PKEY_VALUE_FULL_INFORMATION *  BusInformation , CONFIGURATION_TYPE
	ControllerType , ULONG ControllerNumber , PKEY_VALUE_FULL_INFORMATION * 
	ControllerInformation , CONFIGURATION_TYPE PeripheralType , ULONG
	PeripheralNumber , PKEY_VALUE_FULL_INFORMATION *  PeripheralInformation
	) ;

#line 12878
typedef enum _IO_QUERY_DEVICE_DATA_FORMAT {
	IoQueryDeviceIdentifier = 0,
	IoQueryDeviceConfigurationData,
	IoQueryDeviceComponentInformation,
	IoQueryDeviceMaxData
} IO_QUERY_DEVICE_DATA_FORMAT , *  PIO_QUERY_DEVICE_DATA_FORMAT ;

#line 12890
typedef enum _CREATE_FILE_TYPE {
	CreateFileTypeNone,
	CreateFileTypeNamedPipe,
	CreateFileTypeMailslot
} CREATE_FILE_TYPE ;

#line 12905
struct _DEVICE_DESCRIPTION ;

#line 12906
struct _DEVICE_OBJECT ;

#line 12907
struct _DMA_ADAPTER ;

#line 12908
struct _DRIVER_OBJECT ;

#line 12909
struct _DRIVE_LAYOUT_INFORMATION ;

#line 12910
struct _DISK_PARTITION ;

#line 12911
struct _FILE_OBJECT ;

#line 12912
struct _IRP ;

#line 12913
struct _SCSI_REQUEST_BLOCK ;

#line 12919
typedef void ( *  PIO_DPC_ROUTINE )(PKDPC Dpc , struct _DEVICE_OBJECT * 
	DeviceObject , struct _IRP *  Irp , PVOID Context ) ;

#line 12932
typedef void ( *  PIO_TIMER_ROUTINE )(struct _DEVICE_OBJECT *  DeviceObject ,
	PVOID Context ) ;

#line 12943
typedef NTSTATUS ( *  PDRIVER_INITIALIZE )(struct _DRIVER_OBJECT *  DriverObject
	, PUNICODE_STRING RegistryPath ) ;

#line 12955
typedef void ( *  PDRIVER_REINITIALIZE )(struct _DRIVER_OBJECT *  DriverObject ,
	PVOID Context , ULONG Count ) ;

#line 12968
typedef void ( *  PDRIVER_CANCEL )(struct _DEVICE_OBJECT *  DeviceObject ,
	struct _IRP *  Irp ) ;

#line 12979
typedef NTSTATUS ( *  PDRIVER_DISPATCH )(struct _DEVICE_OBJECT *  DeviceObject ,
	struct _IRP *  Irp ) ;

#line 12990
typedef void ( *  PDRIVER_STARTIO )(struct _DEVICE_OBJECT *  DeviceObject ,
	struct _IRP *  Irp ) ;

#line 13001
typedef void ( *  PDRIVER_UNLOAD )(struct _DRIVER_OBJECT *  DriverObject ) ;

#line 13011
typedef NTSTATUS ( *  PDRIVER_ADD_DEVICE )(struct _DRIVER_OBJECT *  DriverObject
	, struct _DEVICE_OBJECT *  PhysicalDeviceObject ) ;

#line 13025
typedef BOOLEAN ( *  PFAST_IO_CHECK_IF_POSSIBLE )(struct _FILE_OBJECT * 
	FileObject , PLARGE_INTEGER FileOffset , ULONG Length , BOOLEAN Wait ,
	ULONG LockKey , BOOLEAN CheckForReadOperation , PIO_STATUS_BLOCK
	IoStatus , struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13038
typedef BOOLEAN ( *  PFAST_IO_READ )(struct _FILE_OBJECT *  FileObject ,
	PLARGE_INTEGER FileOffset , ULONG Length , BOOLEAN Wait , ULONG LockKey
	, PVOID Buffer , PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT * 
	DeviceObject ) ;

#line 13051
typedef BOOLEAN ( *  PFAST_IO_WRITE )(struct _FILE_OBJECT *  FileObject ,
	PLARGE_INTEGER FileOffset , ULONG Length , BOOLEAN Wait , ULONG LockKey
	, PVOID Buffer , PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT * 
	DeviceObject ) ;

#line 13068
typedef BOOLEAN ( *  PFAST_IO_QUERY_BASIC_INFO )(struct _FILE_OBJECT * 
	FileObject , BOOLEAN Wait , PFILE_BASIC_INFORMATION Buffer ,
	PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13078
typedef BOOLEAN ( *  PFAST_IO_QUERY_STANDARD_INFO )(struct _FILE_OBJECT * 
	FileObject , BOOLEAN Wait , PFILE_STANDARD_INFORMATION Buffer ,
	PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13092
typedef BOOLEAN ( *  PFAST_IO_LOCK )(struct _FILE_OBJECT *  FileObject ,
	PLARGE_INTEGER FileOffset , PLARGE_INTEGER Length , PEPROCESS ProcessId
	, ULONG Key , BOOLEAN FailImmediately , BOOLEAN ExclusiveLock ,
	PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13106
typedef BOOLEAN ( *  PFAST_IO_UNLOCK_SINGLE )(struct _FILE_OBJECT *  FileObject
	, PLARGE_INTEGER FileOffset , PLARGE_INTEGER Length , PEPROCESS
	ProcessId , ULONG Key , PIO_STATUS_BLOCK IoStatus ,
	struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13118
typedef BOOLEAN ( *  PFAST_IO_UNLOCK_ALL )(struct _FILE_OBJECT *  FileObject ,
	PEPROCESS ProcessId , PIO_STATUS_BLOCK IoStatus ,
	struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13127
typedef BOOLEAN ( *  PFAST_IO_UNLOCK_ALL_BY_KEY )(struct _FILE_OBJECT * 
	FileObject , PVOID ProcessId , ULONG Key , PIO_STATUS_BLOCK IoStatus ,
	struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13141
typedef BOOLEAN ( *  PFAST_IO_DEVICE_CONTROL )(struct _FILE_OBJECT *  FileObject
	, BOOLEAN Wait , PVOID InputBuffer , ULONG InputBufferLength , PVOID
	OutputBuffer , ULONG OutputBufferLength , ULONG IoControlCode ,
	PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13161
typedef void ( *  PFAST_IO_ACQUIRE_FILE )(struct _FILE_OBJECT *  FileObject ) ;

#line 13167
typedef void ( *  PFAST_IO_RELEASE_FILE )(struct _FILE_OBJECT *  FileObject ) ;

#line 13179
typedef void ( *  PFAST_IO_DETACH_DEVICE )(struct _DEVICE_OBJECT *  SourceDevice
	, struct _DEVICE_OBJECT *  TargetDevice ) ;

#line 13193
typedef BOOLEAN ( *  PFAST_IO_QUERY_NETWORK_OPEN_INFO )(struct _FILE_OBJECT * 
	FileObject , BOOLEAN Wait , struct _FILE_NETWORK_OPEN_INFORMATION * 
	Buffer , struct _IO_STATUS_BLOCK *  IoStatus , struct _DEVICE_OBJECT * 
	DeviceObject ) ;

#line 13207
typedef BOOLEAN ( *  PFAST_IO_MDL_READ )(struct _FILE_OBJECT *  FileObject ,
	PLARGE_INTEGER FileOffset , ULONG Length , ULONG LockKey , PMDL * 
	MdlChain , PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT * 
	DeviceObject ) ;

#line 13219
typedef BOOLEAN ( *  PFAST_IO_MDL_READ_COMPLETE )(struct _FILE_OBJECT * 
	FileObject , PMDL MdlChain , struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13227
typedef BOOLEAN ( *  PFAST_IO_PREPARE_MDL_WRITE )(struct _FILE_OBJECT * 
	FileObject , PLARGE_INTEGER FileOffset , ULONG Length , ULONG LockKey ,
	PMDL *  MdlChain , PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT * 
	DeviceObject ) ;

#line 13239
typedef BOOLEAN ( *  PFAST_IO_MDL_WRITE_COMPLETE )(struct _FILE_OBJECT * 
	FileObject , PLARGE_INTEGER FileOffset , PMDL MdlChain ,
	struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13253
typedef NTSTATUS ( *  PFAST_IO_ACQUIRE_FOR_MOD_WRITE )(struct _FILE_OBJECT * 
	FileObject , PLARGE_INTEGER EndingOffset , struct _ERESOURCE *  * 
	ResourceToRelease , struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13262
typedef NTSTATUS ( *  PFAST_IO_RELEASE_FOR_MOD_WRITE )(struct _FILE_OBJECT * 
	FileObject , struct _ERESOURCE *  ResourceToRelease ,
	struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13275
typedef NTSTATUS ( *  PFAST_IO_ACQUIRE_FOR_CCFLUSH )(struct _FILE_OBJECT * 
	FileObject , struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13282
typedef NTSTATUS ( *  PFAST_IO_RELEASE_FOR_CCFLUSH )(struct _FILE_OBJECT * 
	FileObject , struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13289
typedef BOOLEAN ( *  PFAST_IO_READ_COMPRESSED )(struct _FILE_OBJECT * 
	FileObject , PLARGE_INTEGER FileOffset , ULONG Length , ULONG LockKey ,
	PVOID Buffer , PMDL *  MdlChain , PIO_STATUS_BLOCK IoStatus ,
	struct _COMPRESSED_DATA_INFO *  CompressedDataInfo , ULONG
	CompressedDataInfoLength , struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13304
typedef BOOLEAN ( *  PFAST_IO_WRITE_COMPRESSED )(struct _FILE_OBJECT * 
	FileObject , PLARGE_INTEGER FileOffset , ULONG Length , ULONG LockKey ,
	PVOID Buffer , PMDL *  MdlChain , PIO_STATUS_BLOCK IoStatus ,
	struct _COMPRESSED_DATA_INFO *  CompressedDataInfo , ULONG
	CompressedDataInfoLength , struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13319
typedef BOOLEAN ( *  PFAST_IO_MDL_READ_COMPLETE_COMPRESSED
	)(struct _FILE_OBJECT *  FileObject , PMDL MdlChain ,
	struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13327
typedef BOOLEAN ( *  PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED
	)(struct _FILE_OBJECT *  FileObject , PLARGE_INTEGER FileOffset , PMDL
	MdlChain , struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13336
typedef BOOLEAN ( *  PFAST_IO_QUERY_OPEN )(struct _IRP *  Irp ,
	PFILE_NETWORK_OPEN_INFORMATION NetworkInformation ,
	struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13350
typedef struct _FAST_IO_DISPATCH {
	ULONG SizeOfFastIoDispatch ;
	PFAST_IO_CHECK_IF_POSSIBLE FastIoCheckIfPossible ;
	PFAST_IO_READ FastIoRead ;
	PFAST_IO_WRITE FastIoWrite ;
	PFAST_IO_QUERY_BASIC_INFO FastIoQueryBasicInfo ;
	PFAST_IO_QUERY_STANDARD_INFO FastIoQueryStandardInfo ;
	PFAST_IO_LOCK FastIoLock ;
	PFAST_IO_UNLOCK_SINGLE FastIoUnlockSingle ;
	PFAST_IO_UNLOCK_ALL FastIoUnlockAll ;
	PFAST_IO_UNLOCK_ALL_BY_KEY FastIoUnlockAllByKey ;
	PFAST_IO_DEVICE_CONTROL FastIoDeviceControl ;
	PFAST_IO_ACQUIRE_FILE AcquireFileForNtCreateSection ;
	PFAST_IO_RELEASE_FILE ReleaseFileForNtCreateSection ;
	PFAST_IO_DETACH_DEVICE FastIoDetachDevice ;
	PFAST_IO_QUERY_NETWORK_OPEN_INFO FastIoQueryNetworkOpenInfo ;
	PFAST_IO_ACQUIRE_FOR_MOD_WRITE AcquireForModWrite ;
	PFAST_IO_MDL_READ MdlRead ;
	PFAST_IO_MDL_READ_COMPLETE MdlReadComplete ;
	PFAST_IO_PREPARE_MDL_WRITE PrepareMdlWrite ;
	PFAST_IO_MDL_WRITE_COMPLETE MdlWriteComplete ;
	PFAST_IO_READ_COMPRESSED FastIoReadCompressed ;
	PFAST_IO_WRITE_COMPRESSED FastIoWriteCompressed ;
	PFAST_IO_MDL_READ_COMPLETE_COMPRESSED MdlReadCompleteCompressed ;
	PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED MdlWriteCompleteCompressed ;
	PFAST_IO_QUERY_OPEN FastIoQueryOpen ;
	PFAST_IO_RELEASE_FOR_MOD_WRITE ReleaseForModWrite ;
	PFAST_IO_ACQUIRE_FOR_CCFLUSH AcquireForCcFlush ;
	PFAST_IO_RELEASE_FOR_CCFLUSH ReleaseForCcFlush ;
} FAST_IO_DISPATCH , *  PFAST_IO_DISPATCH ;

#line 13386
typedef enum _IO_ALLOCATION_ACTION {
	KeepObject = 1,
	DeallocateObject,
	DeallocateObjectKeepRegisters
} IO_ALLOCATION_ACTION , *  PIO_ALLOCATION_ACTION ;

#line 13396
typedef IO_ALLOCATION_ACTION ( *  PDRIVER_CONTROL )(struct _DEVICE_OBJECT * 
	DeviceObject , struct _IRP *  Irp , PVOID MapRegisterBase , PVOID
	Context ) ;

#line 13410
typedef struct _IO_SECURITY_CONTEXT {
	PSECURITY_QUALITY_OF_SERVICE SecurityQos ;
	PACCESS_STATE AccessState ;
	ACCESS_MASK DesiredAccess ;
	ULONG FullCreateOptions ;
} IO_SECURITY_CONTEXT , *  PIO_SECURITY_CONTEXT ;

#line 13434
typedef struct _VPB {
	CSHORT Type ;
	CSHORT Size ;
	USHORT Flags ;
	USHORT VolumeLabelLength ;
	struct _DEVICE_OBJECT *  DeviceObject ;
	struct _DEVICE_OBJECT *  RealDevice ;
	ULONG SerialNumber ;
	ULONG ReferenceCount ;
	WCHAR VolumeLabel[32 * sizeof(WCHAR ) / sizeof(WCHAR )] ;
} VPB , *  PVPB ;

#line 13482
typedef struct _ADAPTER_OBJECT *  PADAPTER_OBJECT ;

#line 13491
typedef struct _WAIT_CONTEXT_BLOCK {
	KDEVICE_QUEUE_ENTRY WaitQueueEntry ;
	PDRIVER_CONTROL DeviceRoutine ;
	PVOID DeviceContext ;
	ULONG NumberOfMapRegisters ;
	PVOID DeviceObject ;
	PVOID CurrentIrp ;
	PKDPC BufferChainingDpc ;
} WAIT_CONTEXT_BLOCK , *  PWAIT_CONTEXT_BLOCK ;

#line 13503
typedef struct _CONTROLLER_OBJECT {
	CSHORT Type ;
	CSHORT Size ;
	PVOID ControllerExtension ;
	KDEVICE_QUEUE DeviceWaitQueue ;
	ULONG Spare1 ;
	LARGE_INTEGER Spare2 ;
} CONTROLLER_OBJECT , *  PCONTROLLER_OBJECT ;

#line 13537
typedef struct _DEVICE_OBJECT {
	CSHORT Type ;
	USHORT Size ;
	LONG ReferenceCount ;
	struct _DRIVER_OBJECT *  DriverObject ;
	struct _DEVICE_OBJECT *  NextDevice ;
	struct _DEVICE_OBJECT *  AttachedDevice ;
	struct _IRP *  CurrentIrp ;
	PIO_TIMER Timer ;
	ULONG Flags ;
	ULONG Characteristics ;
	PVPB Vpb ;
	PVOID DeviceExtension ;
	ULONG DeviceType ;
	CCHAR StackSize ;
	union  {
		LIST_ENTRY ListEntry ;
		WAIT_CONTEXT_BLOCK Wcb ;
	} Queue ;
	ULONG AlignmentRequirement ;
	KDEVICE_QUEUE DeviceQueue ;
	KDPC Dpc ;
	ULONG ActiveThreadCount ;
	PSECURITY_DESCRIPTOR SecurityDescriptor ;
	KEVENT DeviceLock ;
	USHORT SectorSize ;
	USHORT Spare1 ;
	struct _DEVOBJ_EXTENSION *  DeviceObjectExtension ;
	PVOID Reserved ;
} DEVICE_OBJECT ;

#line 13575
typedef struct _DEVICE_OBJECT *  PDEVICE_OBJECT ;

#line 13578
struct _DEVICE_OBJECT_POWER_EXTENSION ;

typedef struct _DEVOBJ_EXTENSION {
	CSHORT Type ;
	USHORT Size ;
	PDEVICE_OBJECT DeviceObject ;
} DEVOBJ_EXTENSION , *  PDEVOBJ_EXTENSION ;

#line 13608
typedef struct _DRIVER_EXTENSION {
	struct _DRIVER_OBJECT *  DriverObject ;
	PDRIVER_ADD_DEVICE AddDevice ;
	ULONG Count ;
	UNICODE_STRING ServiceKeyName ;
} DRIVER_EXTENSION , *  PDRIVER_EXTENSION ;

#line 13645
typedef struct _DRIVER_OBJECT {
	CSHORT Type ;
	CSHORT Size ;
	PDEVICE_OBJECT DeviceObject ;
	ULONG Flags ;
	PVOID DriverStart ;
	ULONG DriverSize ;
	PVOID DriverSection ;
	PDRIVER_EXTENSION DriverExtension ;
	UNICODE_STRING DriverName ;
	PUNICODE_STRING HardwareDatabase ;
	PFAST_IO_DISPATCH FastIoDispatch ;
	PDRIVER_INITIALIZE DriverInit ;
	PDRIVER_STARTIO DriverStartIo ;
	PDRIVER_UNLOAD DriverUnload ;
	PDRIVER_DISPATCH MajorFunction[0x1b + 1] ;
} DRIVER_OBJECT ;

#line 13706
typedef struct _DRIVER_OBJECT *  PDRIVER_OBJECT ;

#line 13715
typedef struct _SECTION_OBJECT_POINTERS {
	PVOID DataSectionObject ;
	PVOID SharedCacheMap ;
	PVOID ImageSectionObject ;
} SECTION_OBJECT_POINTERS ;

#line 13720
typedef SECTION_OBJECT_POINTERS *  PSECTION_OBJECT_POINTERS ;

#line 13726
typedef struct _IO_COMPLETION_CONTEXT {
	PVOID Port ;
	PVOID Key ;
} IO_COMPLETION_CONTEXT , *  PIO_COMPLETION_CONTEXT ;

#line 13759
typedef struct _FILE_OBJECT {
	CSHORT Type ;
	CSHORT Size ;
	PDEVICE_OBJECT DeviceObject ;
	PVPB Vpb ;
	PVOID FsContext ;
	PVOID FsContext2 ;
	PSECTION_OBJECT_POINTERS SectionObjectPointer ;
	PVOID PrivateCacheMap ;
	NTSTATUS FinalStatus ;
	struct _FILE_OBJECT *  RelatedFileObject ;
	BOOLEAN LockOperation ;
	BOOLEAN DeletePending ;
	BOOLEAN ReadAccess ;
	BOOLEAN WriteAccess ;
	BOOLEAN DeleteAccess ;
	BOOLEAN SharedRead ;
	BOOLEAN SharedWrite ;
	BOOLEAN SharedDelete ;
	ULONG Flags ;
	UNICODE_STRING FileName ;
	LARGE_INTEGER CurrentByteOffset ;
	ULONG Waiters ;
	ULONG Busy ;
	PVOID LastLock ;
	KEVENT Lock ;
	KEVENT Event ;
	PIO_COMPLETION_CONTEXT CompletionContext ;
} FILE_OBJECT ;

#line 13788
typedef struct _FILE_OBJECT *  PFILE_OBJECT ;

#line 13828
typedef struct _IRP {
	CSHORT Type ;
	USHORT Size ;
	PMDL MdlAddress ;
	ULONG Flags ;
	union  {
		struct _IRP *  MasterIrp ;
		LONG IrpCount ;
		PVOID SystemBuffer ;
	} AssociatedIrp ;
	LIST_ENTRY ThreadListEntry ;
	IO_STATUS_BLOCK IoStatus ;
	KPROCESSOR_MODE RequestorMode ;
	BOOLEAN PendingReturned ;
	CHAR StackCount ;
	CHAR CurrentLocation ;
	BOOLEAN Cancel ;
	KIRQL CancelIrql ;
	CCHAR ApcEnvironment ;
	UCHAR AllocationFlags ;
	PIO_STATUS_BLOCK UserIosb ;
	PKEVENT UserEvent ;
	union  {
		struct  {
			PIO_APC_ROUTINE UserApcRoutine ;
			PVOID UserApcContext ;
		} AsynchronousParameters ;
		LARGE_INTEGER AllocationSize ;
	} Overlay ;
	PDRIVER_CANCEL CancelRoutine ;
	PVOID UserBuffer ;
	union  {
		struct  {
			union  {
				KDEVICE_QUEUE_ENTRY DeviceQueueEntry ;
				struct  {
					PVOID DriverContext[4] ;
				}  ;
			}  ;
			PETHREAD Thread ;
			PCHAR AuxiliaryBuffer ;
			struct  {
				LIST_ENTRY ListEntry ;
				union  {
					struct _IO_STACK_LOCATION * 
						CurrentStackLocation ;
					ULONG PacketType ;
				}  ;
			}  ;
			PFILE_OBJECT OriginalFileObject ;
		} Overlay ;
		KAPC Apc ;
		PVOID CompletionKey ;
	} Tail ;
} IRP , *  PIRP ;

#line 14078
typedef NTSTATUS ( *  PIO_COMPLETION_ROUTINE )(PDEVICE_OBJECT DeviceObject ,
	PIRP Irp , PVOID Context ) ;

#line 14163
typedef enum _DEVICE_RELATION_TYPE {
	BusRelations,
	EjectionRelations,
	PowerRelations,
	RemovalRelations,
	TargetDeviceRelation
} DEVICE_RELATION_TYPE , *  PDEVICE_RELATION_TYPE ;

typedef struct _DEVICE_RELATIONS {
	ULONG Count ;
	PDEVICE_OBJECT Objects[1] ;
} DEVICE_RELATIONS , *  PDEVICE_RELATIONS ;

typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE {
	DeviceUsageTypeUndefined,
	DeviceUsageTypePaging,
	DeviceUsageTypeHibernation,
	DeviceUsageTypeDumpFile
} DEVICE_USAGE_NOTIFICATION_TYPE ;

#line 14185
typedef struct _INTERFACE {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
} INTERFACE , *  PINTERFACE ;

#line 14196
typedef struct _DEVICE_CAPABILITIES {
	USHORT Size ;
	USHORT Version ;
	ULONG DeviceD1  : 1;
	ULONG DeviceD2  : 1;
	ULONG LockSupported  : 1;
	ULONG EjectSupported  : 1;
	ULONG Removable  : 1;
	ULONG DockDevice  : 1;
	ULONG UniqueID  : 1;
	ULONG SilentInstall  : 1;
	ULONG RawDeviceOK  : 1;
	ULONG SurpriseRemovalOK  : 1;
	ULONG WakeFromD0  : 1;
	ULONG WakeFromD1  : 1;
	ULONG WakeFromD2  : 1;
	ULONG WakeFromD3  : 1;
	ULONG HardwareDisabled  : 1;
	ULONG NonDynamic  : 1;
	ULONG WarmEjectSupported  : 1;
	ULONG Reserved  : 15;
	ULONG Address ;
	ULONG UINumber ;
	DEVICE_POWER_STATE DeviceState[PowerSystemMaximum] ;
	SYSTEM_POWER_STATE SystemWake ;
	DEVICE_POWER_STATE DeviceWake ;
	ULONG D1Latency ;
	ULONG D2Latency ;
	ULONG D3Latency ;
} DEVICE_CAPABILITIES , *  PDEVICE_CAPABILITIES ;

#line 14229
typedef struct _POWER_SEQUENCE {
	ULONG SequenceD1 ;
	ULONG SequenceD2 ;
	ULONG SequenceD3 ;
} POWER_SEQUENCE , *  PPOWER_SEQUENCE ;

typedef enum  {
	BusQueryDeviceID = 0,
	BusQueryHardwareIDs = 1,
	BusQueryCompatibleIDs = 2,
	BusQueryInstanceID = 3,
	BusQueryDeviceSerialNumber = 4
} BUS_QUERY_ID_TYPE , *  PBUS_QUERY_ID_TYPE ;

typedef ULONG PNP_DEVICE_STATE , *  PPNP_DEVICE_STATE ;

#line 14252
typedef enum  {
	DeviceTextDescription = 0,
	DeviceTextLocationInformation = 1
} DEVICE_TEXT_TYPE , *  PDEVICE_TEXT_TYPE ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION {
	UCHAR MajorFunction ;
	UCHAR MinorFunction ;
	UCHAR Flags ;
	UCHAR Control ;
	union  {
		struct  {
			PIO_SECURITY_CONTEXT SecurityContext ;
			ULONG Options ;
			USHORT FileAttributes ;
			USHORT ShareAccess ;
			ULONG EaLength ;
		} Create ;
		struct  {
			ULONG Length ;
			ULONG Key ;
			LARGE_INTEGER ByteOffset ;
		} Read ;
		struct  {
			ULONG Length ;
			ULONG Key ;
			LARGE_INTEGER ByteOffset ;
		} Write ;
		struct  {
			ULONG Length ;
			FILE_INFORMATION_CLASS FileInformationClass ;
		} QueryFile ;
		struct  {
			ULONG Length ;
			FILE_INFORMATION_CLASS FileInformationClass ;
			PFILE_OBJECT FileObject ;
			union  {
				struct  {
					BOOLEAN ReplaceIfExists ;
					BOOLEAN AdvanceOnly ;
				}  ;
				ULONG ClusterCount ;
				HANDLE DeleteHandle ;
			}  ;
		} SetFile ;
		struct  {
			ULONG Length ;
			FS_INFORMATION_CLASS FsInformationClass ;
		} QueryVolume ;
		struct  {
			ULONG OutputBufferLength ;
			ULONG InputBufferLength ;
			ULONG IoControlCode ;
			PVOID Type3InputBuffer ;
		} DeviceIoControl ;
		struct  {
			SECURITY_INFORMATION SecurityInformation ;
			ULONG Length ;
		} QuerySecurity ;
		struct  {
			SECURITY_INFORMATION SecurityInformation ;
			PSECURITY_DESCRIPTOR SecurityDescriptor ;
		} SetSecurity ;
		struct  {
			PVPB Vpb ;
			PDEVICE_OBJECT DeviceObject ;
		} MountVolume ;
		struct  {
			PVPB Vpb ;
			PDEVICE_OBJECT DeviceObject ;
		} VerifyVolume ;
		struct  {
			struct _SCSI_REQUEST_BLOCK *  Srb ;
		} Scsi ;
		struct  {
			DEVICE_RELATION_TYPE Type ;
		} QueryDeviceRelations ;
		struct  {
			const GUID *  InterfaceType ;
			USHORT Size ;
			USHORT Version ;
			PINTERFACE Interface ;
			PVOID InterfaceSpecificData ;
		} QueryInterface ;
		struct  {
			PDEVICE_CAPABILITIES Capabilities ;
		} DeviceCapabilities ;
		struct  {
			PIO_RESOURCE_REQUIREMENTS_LIST IoResourceRequirementList
				;
		} FilterResourceRequirements ;
		struct  {
			ULONG WhichSpace ;
			PVOID Buffer ;
			ULONG Offset ;
			ULONG Length ;
		} ReadWriteConfig ;
		struct  {
			BOOLEAN Lock ;
		} SetLock ;
		struct  {
			BUS_QUERY_ID_TYPE IdType ;
		} QueryId ;
		struct  {
			DEVICE_TEXT_TYPE DeviceTextType ;
			LCID LocaleId ;
		} QueryDeviceText ;
		struct  {
			BOOLEAN InPath ;
			BOOLEAN Reserved[3] ;
			DEVICE_USAGE_NOTIFICATION_TYPE Type ;
		} UsageNotification ;
		struct  {
			SYSTEM_POWER_STATE PowerState ;
		} WaitWake ;
		struct  {
			PPOWER_SEQUENCE PowerSequence ;
		} PowerSequence ;
		struct  {
			ULONG SystemContext ;
			POWER_STATE_TYPE Type ;
			POWER_STATE State ;
			POWER_ACTION ShutdownType ;
		} Power ;
		struct  {
			PCM_RESOURCE_LIST AllocatedResources ;
			PCM_RESOURCE_LIST AllocatedResourcesTranslated ;
		} StartDevice ;
		struct  {
			ULONG_PTR ProviderId ;
			PVOID DataPath ;
			ULONG BufferSize ;
			PVOID Buffer ;
		} WMI ;
		struct  {
			PVOID Argument1 ;
			PVOID Argument2 ;
			PVOID Argument3 ;
			PVOID Argument4 ;
		} Others ;
	} Parameters ;
	PDEVICE_OBJECT DeviceObject ;
	PFILE_OBJECT FileObject ;
	PIO_COMPLETION_ROUTINE CompletionRoutine ;
	PVOID Context ;
} IO_STACK_LOCATION , *  PIO_STACK_LOCATION ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 14615 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SHARE_ACCESS {
	ULONG OpenCount ;
	ULONG Readers ;
	ULONG Writers ;
	ULONG Deleters ;
	ULONG SharedRead ;
	ULONG SharedWrite ;
	ULONG SharedDelete ;
} SHARE_ACCESS , *  PSHARE_ACCESS ;

#line 14635
typedef struct _CONFIGURATION_INFORMATION {
	ULONG DiskCount ;
	ULONG FloppyCount ;
	ULONG CdRomCount ;
	ULONG TapeCount ;
	ULONG ScsiPortCount ;
	ULONG SerialCount ;
	ULONG ParallelCount ;
	BOOLEAN AtDiskPrimaryAddressClaimed ;
	BOOLEAN AtDiskSecondaryAddressClaimed ;
	ULONG Version ;
	ULONG MediumChangerCount ;
} CONFIGURATION_INFORMATION , *  PCONFIGURATION_INFORMATION ;

#line 14681
__declspec(dllimport) void IoAcquireCancelSpinLock(PKIRQL Irql ) ;
#line 14688
__declspec(dllimport) NTSTATUS IoAllocateAdapterChannel(PADAPTER_OBJECT
	AdapterObject , PDEVICE_OBJECT DeviceObject , ULONG NumberOfMapRegisters
	, PDRIVER_CONTROL ExecutionRoutine , PVOID Context ) ;
#line 14698
__declspec(dllimport) void IoAllocateController(PCONTROLLER_OBJECT
	ControllerObject , PDEVICE_OBJECT DeviceObject , PDRIVER_CONTROL
	ExecutionRoutine , PVOID Context ) ;
#line 14709
__declspec(dllimport) NTSTATUS IoAllocateDriverObjectExtension(PDRIVER_OBJECT
	DriverObject , PVOID ClientIdentificationAddress , ULONG
	DriverObjectExtensionSize , PVOID *  DriverObjectExtension ) ;
#line 14720
__declspec(dllimport) PVOID IoAllocateErrorLogEntry(PVOID IoObject , UCHAR
	EntrySize ) ;
#line 14727
__declspec(dllimport) PIRP IoAllocateIrp(CCHAR StackSize , BOOLEAN ChargeQuota )
	;
#line 14734
__declspec(dllimport) PMDL IoAllocateMdl(PVOID VirtualAddress , ULONG Length ,
	BOOLEAN SecondaryBuffer , BOOLEAN ChargeQuota , PIRP Irp ) ;
#line 14776
__declspec(dllimport) NTSTATUS IoAssignResources(PUNICODE_STRING RegistryPath ,
	PUNICODE_STRING DriverClassName , PDRIVER_OBJECT DriverObject ,
	PDEVICE_OBJECT DeviceObject , PIO_RESOURCE_REQUIREMENTS_LIST
	RequestedResources , PCM_RESOURCE_LIST *  AllocatedResources ) ;
#line 14788
__declspec(dllimport) NTSTATUS IoAttachDevice(PDEVICE_OBJECT SourceDevice ,
	PUNICODE_STRING TargetDevice , PDEVICE_OBJECT *  AttachedDevice ) ;
#line 14798
__declspec(dllimport) NTSTATUS IoAttachDeviceByPointer(PDEVICE_OBJECT
	SourceDevice , PDEVICE_OBJECT TargetDevice ) ;
#line 14807
__declspec(dllimport) PDEVICE_OBJECT IoAttachDeviceToDeviceStack(PDEVICE_OBJECT
	SourceDevice , PDEVICE_OBJECT TargetDevice ) ;
#line 14814
__declspec(dllimport) PIRP IoBuildAsynchronousFsdRequest(ULONG MajorFunction ,
	PDEVICE_OBJECT DeviceObject , PVOID Buffer , ULONG Length ,
	PLARGE_INTEGER StartingOffset , PIO_STATUS_BLOCK IoStatusBlock ) ;
#line 14825
__declspec(dllimport) PIRP IoBuildDeviceIoControlRequest(ULONG IoControlCode ,
	PDEVICE_OBJECT DeviceObject , PVOID InputBuffer , ULONG
	InputBufferLength , PVOID OutputBuffer , ULONG OutputBufferLength ,
	BOOLEAN InternalDeviceIoControl , PKEVENT Event , PIO_STATUS_BLOCK
	IoStatusBlock ) ;
#line 14839
__declspec(dllimport) void IoBuildPartialMdl(PMDL SourceMdl , PMDL TargetMdl ,
	PVOID VirtualAddress , ULONG Length ) ;

#line 14848
typedef struct _BOOTDISK_INFORMATION {
	LONGLONG BootPartitionOffset ;
	LONGLONG SystemPartitionOffset ;
	ULONG BootDeviceSignature ;
	ULONG SystemDeviceSignature ;
} BOOTDISK_INFORMATION , *  PBOOTDISK_INFORMATION ;

__declspec(dllimport) NTSTATUS IoGetBootDiskInformation(PBOOTDISK_INFORMATION
	BootDiskInformation , ULONG Size ) ;
#line 14863
__declspec(dllimport) PIRP IoBuildSynchronousFsdRequest(ULONG MajorFunction ,
	PDEVICE_OBJECT DeviceObject , PVOID Buffer , ULONG Length ,
	PLARGE_INTEGER StartingOffset , PKEVENT Event , PIO_STATUS_BLOCK
	IoStatusBlock ) ;
#line 14875
__declspec(dllimport) NTSTATUS _fastcall IofCallDriver(PDEVICE_OBJECT
	DeviceObject , PIRP Irp ) ;
#line 14886
__declspec(dllimport) BOOLEAN IoCancelIrp(PIRP Irp ) ;
#line 14893
__declspec(dllimport) NTSTATUS IoCheckShareAccess(ACCESS_MASK DesiredAccess ,
	ULONG DesiredShareAccess , PFILE_OBJECT FileObject , PSHARE_ACCESS
	ShareAccess , BOOLEAN Update ) ;
#line 14903
__declspec(dllimport) void _fastcall IofCompleteRequest(PIRP Irp , CCHAR
	PriorityBoost ) ;
#line 14916
__declspec(dllimport) NTSTATUS IoConnectInterrupt(PKINTERRUPT *  InterruptObject
	, PKSERVICE_ROUTINE ServiceRoutine , PVOID ServiceContext , PKSPIN_LOCK
	SpinLock , ULONG Vector , KIRQL Irql , KIRQL SynchronizeIrql ,
	KINTERRUPT_MODE InterruptMode , BOOLEAN ShareVector , KAFFINITY
	ProcessorEnableMask , BOOLEAN FloatingSave ) ;
#line 14934
__declspec(dllimport) PCONTROLLER_OBJECT IoCreateController(ULONG Size ) ;
#line 14942
__declspec(dllimport) NTSTATUS IoCreateDevice(PDRIVER_OBJECT DriverObject ,
	ULONG DeviceExtensionSize , PUNICODE_STRING DeviceName , ULONG
	DeviceType , ULONG DeviceCharacteristics , BOOLEAN Exclusive ,
	PDEVICE_OBJECT *  DeviceObject ) ;
#line 14957
__declspec(dllimport) BOOLEAN IoIsWdmVersionAvailable(UCHAR MajorVersion , UCHAR
	MinorVersion ) ;
#line 14966
__declspec(dllimport) NTSTATUS IoCreateFile(PHANDLE FileHandle , ACCESS_MASK
	DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes , PIO_STATUS_BLOCK
	IoStatusBlock , PLARGE_INTEGER AllocationSize , ULONG FileAttributes ,
	ULONG ShareAccess , ULONG Disposition , ULONG CreateOptions , PVOID
	EaBuffer , ULONG EaLength , CREATE_FILE_TYPE CreateFileType , PVOID
	ExtraCreateParameters , ULONG Options ) ;
#line 14986
__declspec(dllimport) PKEVENT IoCreateNotificationEvent(PUNICODE_STRING
	EventName , PHANDLE EventHandle ) ;
#line 14993
__declspec(dllimport) NTSTATUS IoCreateSymbolicLink(PUNICODE_STRING
	SymbolicLinkName , PUNICODE_STRING DeviceName ) ;
#line 15002
__declspec(dllimport) PKEVENT IoCreateSynchronizationEvent(PUNICODE_STRING
	EventName , PHANDLE EventHandle ) ;
#line 15011
__declspec(dllimport) NTSTATUS IoCreateUnprotectedSymbolicLink(PUNICODE_STRING
	SymbolicLinkName , PUNICODE_STRING DeviceName ) ;
#line 15049
__declspec(dllimport) void IoDeleteController(PCONTROLLER_OBJECT
	ControllerObject ) ;
#line 15057
__declspec(dllimport) void IoDeleteDevice(PDEVICE_OBJECT DeviceObject ) ;
#line 15063
__declspec(dllimport) NTSTATUS IoDeleteSymbolicLink(PUNICODE_STRING
	SymbolicLinkName ) ;
#line 15069
__declspec(dllimport) void IoDetachDevice(PDEVICE_OBJECT TargetDevice ) ;
#line 15077
__declspec(dllimport) void IoDisconnectInterrupt(PKINTERRUPT InterruptObject ) ;
#line 15084
__declspec(dllimport) void IoFreeController(PCONTROLLER_OBJECT ControllerObject
	) ;
#line 15092
__declspec(dllimport) void IoFreeIrp(PIRP Irp ) ;
#line 15098
__declspec(dllimport) void IoFreeMdl(PMDL Mdl ) ;
#line 15104
__declspec(dllimport) PDEVICE_OBJECT IoGetAttachedDeviceReference(PDEVICE_OBJECT
	DeviceObject ) ;
#line 15110
__declspec(dllimport) PCONFIGURATION_INFORMATION
	IoGetConfigurationInformation(void  ) ;
#line 15141
__declspec(dllimport) PDEVICE_OBJECT IoGetDeviceToVerify(PETHREAD Thread ) ;
#line 15149
__declspec(dllimport) PVOID IoGetDriverObjectExtension(PDRIVER_OBJECT
	DriverObject , PVOID ClientIdentificationAddress ) ;
#line 15156
__declspec(dllimport) PEPROCESS IoGetCurrentProcess(void  ) ;
#line 15164
__declspec(dllimport) NTSTATUS IoGetDeviceObjectPointer(PUNICODE_STRING
	ObjectName , ACCESS_MASK DesiredAccess , PFILE_OBJECT *  FileObject ,
	PDEVICE_OBJECT *  DeviceObject ) ;
#line 15173
__declspec(dllimport) struct _DMA_ADAPTER *  IoGetDmaAdapter(PDEVICE_OBJECT
	PhysicalDeviceObject , struct _DEVICE_DESCRIPTION *  DeviceDescription ,
	PULONG NumberOfMapRegisters ) ;
#line 15183
__declspec(dllimport) PGENERIC_MAPPING IoGetFileObjectGenericMapping(void  ) ;
#line 15228
__declspec(dllimport) PVOID IoGetInitialStack(void  ) ;
#line 15234
__declspec(dllimport) void IoGetStackLimits(PULONG_PTR LowLimit , PULONG_PTR
	HighLimit ) ;

#line 15246
__inline ULONG_PTR IoGetRemainingStackSize(void  )
{
	#line 15252
	ULONG_PTR Top ;
	ULONG_PTR Bottom ;
	#line 15255
	IoGetStackLimits(& Bottom, & Top);
	return (ULONG_PTR )(& Top) - Bottom;
}

#line 15286
__declspec(dllimport) PDEVICE_OBJECT IoGetRelatedDeviceObject(PFILE_OBJECT
	FileObject ) ;
#line 15326
__declspec(dllimport) void IoInitializeIrp(PIRP Irp , USHORT PacketSize , CCHAR
	StackSize ) ;
#line 15334
__declspec(dllimport) NTSTATUS IoInitializeTimer(PDEVICE_OBJECT DeviceObject ,
	PIO_TIMER_ROUTINE TimerRoutine , PVOID Context ) ;
#line 15343
__declspec(dllimport) void IoReuseIrp(PIRP Irp , NTSTATUS Iostatus ) ;
#line 15351
__declspec(dllimport) void IoCancelFileOpen(PDEVICE_OBJECT DeviceObject ,
	PFILE_OBJECT FileObject ) ;
#line 15390
__declspec(dllimport) PIRP IoMakeAssociatedIrp(PIRP Irp , CCHAR StackSize ) ;
#line 15426
__declspec(dllimport) NTSTATUS IoQueryDeviceDescription(PINTERFACE_TYPE BusType
	, PULONG BusNumber , PCONFIGURATION_TYPE ControllerType , PULONG
	ControllerNumber , PCONFIGURATION_TYPE PeripheralType , PULONG
	PeripheralNumber , PIO_QUERY_DEVICE_ROUTINE CalloutRoutine , PVOID
	Context ) ;
#line 15439
__declspec(dllimport) void IoRaiseHardError(PIRP Irp , PVPB Vpb , PDEVICE_OBJECT
	RealDeviceObject ) ;
#line 15447
__declspec(dllimport) BOOLEAN IoRaiseInformationalHardError(NTSTATUS ErrorStatus
	, PUNICODE_STRING String , PKTHREAD Thread ) ;
#line 15455
__declspec(dllimport) BOOLEAN IoSetThreadHardErrorMode(BOOLEAN EnableHardErrors
	) ;
#line 15461
__declspec(dllimport) void IoRegisterBootDriverReinitialization(PDRIVER_OBJECT
	DriverObject , PDRIVER_REINITIALIZE DriverReinitializationRoutine ,
	PVOID Context ) ;
#line 15469
__declspec(dllimport) void IoRegisterDriverReinitialization(PDRIVER_OBJECT
	DriverObject , PDRIVER_REINITIALIZE DriverReinitializationRoutine ,
	PVOID Context ) ;
#line 15478
__declspec(dllimport) NTSTATUS IoRegisterShutdownNotification(PDEVICE_OBJECT
	DeviceObject ) ;
#line 15484
__declspec(dllimport) NTSTATUS
	IoRegisterLastChanceShutdownNotification(PDEVICE_OBJECT DeviceObject ) ;
#line 15492
__declspec(dllimport) void IoReleaseCancelSpinLock(KIRQL Irql ) ;
#line 15499
__declspec(dllimport) void IoRemoveShareAccess(PFILE_OBJECT FileObject ,
	PSHARE_ACCESS ShareAccess ) ;
#line 15507
__declspec(dllimport) NTSTATUS IoReportResourceUsage(PUNICODE_STRING
	DriverClassName , PDRIVER_OBJECT DriverObject , PCM_RESOURCE_LIST
	DriverList , ULONG DriverListSize , PDEVICE_OBJECT DeviceObject ,
	PCM_RESOURCE_LIST DeviceList , ULONG DeviceListSize , BOOLEAN
	OverrideConflict , PBOOLEAN ConflictDetected ) ;
#line 15641
__declspec(dllimport) void IoSetHardErrorOrVerifyDevice(PIRP Irp ,
	PDEVICE_OBJECT DeviceObject ) ;
#line 15743
__declspec(dllimport) void IoSetShareAccess(ACCESS_MASK DesiredAccess , ULONG
	DesiredShareAccess , PFILE_OBJECT FileObject , PSHARE_ACCESS ShareAccess
	) ;

#line 15754
typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK *  PIO_REMOVE_LOCK_TRACKING_BLOCK
	;

#line 15756
typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK {
	BOOLEAN Removed ;
	BOOLEAN Reserved[3] ;
	LONG IoCount ;
	KEVENT RemoveEvent ;
} IO_REMOVE_LOCK_COMMON_BLOCK ;

#line 15764
typedef struct _IO_REMOVE_LOCK_DBG_BLOCK {
	LONG Signature ;
	LONG HighWatermark ;
	LONGLONG MaxLockedTicks ;
	LONG AllocateTag ;
	LIST_ENTRY LockList ;
	KSPIN_LOCK Spin ;
	LONG LowMemoryCount ;
	ULONG Reserved1[4] ;
	PVOID Reserved2 ;
	PIO_REMOVE_LOCK_TRACKING_BLOCK Blocks ;
} IO_REMOVE_LOCK_DBG_BLOCK ;

typedef struct _IO_REMOVE_LOCK {
	IO_REMOVE_LOCK_COMMON_BLOCK Common ;
} IO_REMOVE_LOCK , *  PIO_REMOVE_LOCK ;

#line 15787
__declspec(dllimport) void __stdcall IoInitializeRemoveLockEx(PIO_REMOVE_LOCK
	Lock , ULONG AllocateTag , ULONG MaxLockedMinutes , ULONG HighWatermark
	, ULONG RemlockSize ) ;
#line 15808
__declspec(dllimport) NTSTATUS __stdcall IoAcquireRemoveLockEx(PIO_REMOVE_LOCK
	RemoveLock , PVOID Tag , PCSTR File , ULONG Line , ULONG RemlockSize ) ;
#line 15857
__declspec(dllimport) void __stdcall IoReleaseRemoveLockEx(PIO_REMOVE_LOCK
	RemoveLock , PVOID Tag , ULONG RemlockSize ) ;
#line 15893
__declspec(dllimport) void __stdcall
	IoReleaseRemoveLockAndWaitEx(PIO_REMOVE_LOCK RemoveLock , PVOID Tag ,
	ULONG RemlockSize ) ;
#line 15949
__declspec(dllimport) void IoStartNextPacket(PDEVICE_OBJECT DeviceObject ,
	BOOLEAN Cancelable ) ;
#line 15956
__declspec(dllimport) void IoStartNextPacketByKey(PDEVICE_OBJECT DeviceObject ,
	BOOLEAN Cancelable , ULONG Key ) ;
#line 15964
__declspec(dllimport) void IoStartPacket(PDEVICE_OBJECT DeviceObject , PIRP Irp
	, PULONG Key , PDRIVER_CANCEL CancelFunction ) ;
#line 15975
__declspec(dllimport) void IoStartTimer(PDEVICE_OBJECT DeviceObject ) ;
#line 15981
__declspec(dllimport) void IoStopTimer(PDEVICE_OBJECT DeviceObject ) ;
#line 15988
__declspec(dllimport) void IoUnregisterShutdownNotification(PDEVICE_OBJECT
	DeviceObject ) ;
#line 15996
__declspec(dllimport) void IoUpdateShareAccess(PFILE_OBJECT FileObject ,
	PSHARE_ACCESS ShareAccess ) ;
#line 16003
__declspec(dllimport) void IoWriteErrorLogEntry(PVOID ElEntry ) ;

#line 16009
typedef struct _IO_WORKITEM *  PIO_WORKITEM ;

typedef void ( *  PIO_WORKITEM_ROUTINE )(PDEVICE_OBJECT DeviceObject , PVOID
	Context ) ;

#line 16018
PIO_WORKITEM IoAllocateWorkItem(PDEVICE_OBJECT DeviceObject ) ;
#line 16023
void IoFreeWorkItem(PIO_WORKITEM IoWorkItem ) ;
#line 16028
void IoQueueWorkItem(PIO_WORKITEM IoWorkItem , PIO_WORKITEM_ROUTINE
	WorkerRoutine , WORK_QUEUE_TYPE QueueType , PVOID Context ) ;
#line 16040
__declspec(dllimport) NTSTATUS IoWMIRegistrationControl(PDEVICE_OBJECT
	DeviceObject , ULONG Action ) ;
#line 16064
__declspec(dllimport) NTSTATUS IoWMIAllocateInstanceIds(GUID *  Guid , ULONG
	InstanceCount , ULONG *  FirstInstanceId ) ;
#line 16072
__declspec(dllimport) NTSTATUS IoWMISuggestInstanceName(PDEVICE_OBJECT
	PhysicalDeviceObject , PUNICODE_STRING SymbolicLinkName , BOOLEAN
	CombineNames , PUNICODE_STRING SuggestedInstanceName ) ;
#line 16081
__declspec(dllimport) NTSTATUS IoWMIWriteEvent(PVOID WnodeEventItem ) ;

#line 16100
typedef enum  {
	DevicePropertyDeviceDescription,
	DevicePropertyHardwareID,
	DevicePropertyCompatibleIDs,
	DevicePropertyBootConfiguration,
	DevicePropertyBootConfigurationTranslated,
	DevicePropertyClassName,
	DevicePropertyClassGuid,
	DevicePropertyDriverKeyName,
	DevicePropertyManufacturer,
	DevicePropertyFriendlyName,
	DevicePropertyLocationInformation,
	DevicePropertyPhysicalDeviceObjectName,
	DevicePropertyBusTypeGuid,
	DevicePropertyLegacyBusType,
	DevicePropertyBusNumber,
	DevicePropertyEnumeratorName,
	DevicePropertyAddress,
	DevicePropertyUINumber
} DEVICE_REGISTRY_PROPERTY ;

typedef BOOLEAN ( *  PTRANSLATE_BUS_ADDRESS )(PVOID Context , PHYSICAL_ADDRESS
	BusAddress , ULONG Length , PULONG AddressSpace , PPHYSICAL_ADDRESS
	TranslatedAddress ) ;

#line 16129
typedef struct _DMA_ADAPTER *  ( *  PGET_DMA_ADAPTER )(PVOID Context ,
	struct _DEVICE_DESCRIPTION *  DeviceDescriptor , PULONG
	NumberOfMapRegisters ) ;

#line 16135
typedef ULONG ( *  PGET_SET_DEVICE_DATA )(PVOID Context , ULONG DataType , PVOID
	Buffer , ULONG Offset , ULONG Length ) ;

#line 16148
typedef struct _PNP_BUS_INFORMATION {
	GUID BusTypeGuid ;
	INTERFACE_TYPE LegacyBusType ;
	ULONG BusNumber ;
} PNP_BUS_INFORMATION , *  PPNP_BUS_INFORMATION ;

#line 16162
typedef struct _LEGACY_BUS_INFORMATION {
	GUID BusTypeGuid ;
	INTERFACE_TYPE LegacyBusType ;
	ULONG BusNumber ;
} LEGACY_BUS_INFORMATION , *  PLEGACY_BUS_INFORMATION ;

typedef struct _BUS_INTERFACE_STANDARD {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PTRANSLATE_BUS_ADDRESS TranslateBusAddress ;
	PGET_DMA_ADAPTER GetDmaAdapter ;
	PGET_SET_DEVICE_DATA SetBusData ;
	PGET_SET_DEVICE_DATA GetBusData ;
} BUS_INTERFACE_STANDARD , *  PBUS_INTERFACE_STANDARD ;

#line 16190
typedef BOOLEAN ( *  PGPE_SERVICE_ROUTINE )(PVOID , PVOID ) ;

#line 16194
typedef NTSTATUS ( *  PGPE_CONNECT_VECTOR )(PDEVICE_OBJECT , ULONG ,
	KINTERRUPT_MODE , BOOLEAN , PGPE_SERVICE_ROUTINE , PVOID , PVOID ) ;

#line 16203
typedef NTSTATUS ( *  PGPE_DISCONNECT_VECTOR )(PVOID ) ;

#line 16206
typedef NTSTATUS ( *  PGPE_ENABLE_EVENT )(PDEVICE_OBJECT , PVOID ) ;

#line 16210
typedef NTSTATUS ( *  PGPE_DISABLE_EVENT )(PDEVICE_OBJECT , PVOID ) ;

#line 16214
typedef NTSTATUS ( *  PGPE_CLEAR_STATUS )(PDEVICE_OBJECT , PVOID ) ;

#line 16218
typedef void ( *  PDEVICE_NOTIFY_CALLBACK )(PVOID , ULONG ) ;

#line 16222
typedef NTSTATUS ( *  PREGISTER_FOR_DEVICE_NOTIFICATIONS )(PDEVICE_OBJECT ,
	PDEVICE_NOTIFY_CALLBACK , PVOID ) ;

#line 16227
typedef void ( *  PUNREGISTER_FOR_DEVICE_NOTIFICATIONS )(PDEVICE_OBJECT ,
	PDEVICE_NOTIFY_CALLBACK ) ;

#line 16231
typedef struct _ACPI_INTERFACE_STANDARD {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PGPE_CONNECT_VECTOR GpeConnectVector ;
	PGPE_DISCONNECT_VECTOR GpeDisconnectVector ;
	PGPE_ENABLE_EVENT GpeEnableEvent ;
	PGPE_DISABLE_EVENT GpeDisableEvent ;
	PGPE_CLEAR_STATUS GpeClearStatus ;
	PREGISTER_FOR_DEVICE_NOTIFICATIONS RegisterForDeviceNotifications ;
	PUNREGISTER_FOR_DEVICE_NOTIFICATIONS UnregisterForDeviceNotifications ;
} ACPI_INTERFACE_STANDARD , *  PACPI_INTERFACE_STANDARD ;

#line 16255
typedef enum _ACPI_REG_TYPE {
	PM1a_ENABLE,
	PM1b_ENABLE,
	PM1a_STATUS,
	PM1b_STATUS,
	PM1a_CONTROL,
	PM1b_CONTROL,
	GP_STATUS,
	GP_ENABLE,
	SMI_CMD,
	MaxRegType
} ACPI_REG_TYPE , *  PACPI_REG_TYPE ;

typedef USHORT ( *  PREAD_ACPI_REGISTER )(ACPI_REG_TYPE AcpiReg , ULONG Register
	) ;

#line 16272
typedef void ( *  PWRITE_ACPI_REGISTER )(ACPI_REG_TYPE AcpiReg , ULONG Register
	, USHORT Value ) ;

#line 16278
typedef struct ACPI_REGS_INTERFACE_STANDARD {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PREAD_ACPI_REGISTER ReadAcpiRegister ;
	PWRITE_ACPI_REGISTER WriteAcpiRegister ;
} ACPI_REGS_INTERFACE_STANDARD , *  PACPI_REGS_INTERFACE_STANDARD ;

#line 16300
typedef struct  {
	PVOID LinkNode ;
	ULONG StaticVector ;
	UCHAR Flags ;
} ROUTING_TOKEN , *  PROUTING_TOKEN ;

#line 16314
typedef NTSTATUS ( *  PGET_INTERRUPT_ROUTING )(PDEVICE_OBJECT Pdo , ULONG *  Bus
	, ULONG *  PciSlot , UCHAR *  InterruptLine , UCHAR *  InterruptPin ,
	UCHAR *  ClassCode , UCHAR *  SubClassCode , PDEVICE_OBJECT *  ParentPdo
	, ROUTING_TOKEN *  RoutingToken , UCHAR *  Flags ) ;

#line 16329
typedef NTSTATUS ( *  PSET_INTERRUPT_ROUTING_TOKEN )(PDEVICE_OBJECT Pdo ,
	PROUTING_TOKEN RoutingToken ) ;

#line 16336
typedef void ( *  PUPDATE_INTERRUPT_LINE )(PDEVICE_OBJECT Pdo , UCHAR
	LineRegister ) ;

#line 16343
typedef struct _INT_ROUTE_INTERFACE_STANDARD {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PGET_INTERRUPT_ROUTING GetInterruptRouting ;
	PSET_INTERRUPT_ROUTING_TOKEN SetInterruptRoutingToken ;
	PUPDATE_INTERRUPT_LINE UpdateInterruptLine ;
} INT_ROUTE_INTERFACE_STANDARD , *  PINT_ROUTE_INTERFACE_STANDARD ;

#line 16366
typedef struct _IO_ASSIGNED_RESOURCES {
	ULONG Count ;
	PASSIGNED_RESOURCE AssignedResources[1] ;
} IO_ASSIGNED_RESOURCES , *  PIO_ASSIGNED_RESOURCES ;

__declspec(dllimport) NTSTATUS
	IoGetAssignedResourcesForSuballocation(INTERFACE_TYPE InterfaceType ,
	ULONG BusNumber , ULONG SlotNumber , PIO_RESOURCE_DESCRIPTOR
	ResourceDescriptor , PIO_ASSIGNED_RESOURCES *  List ) ;
#line 16381
__declspec(dllimport) NTSTATUS IoReportDetectedDevice(PDRIVER_OBJECT
	DriverObject , INTERFACE_TYPE LegacyBusType , ULONG BusNumber , ULONG
	SlotNumber , PCM_RESOURCE_LIST ResourceList ,
	PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirements , BOOLEAN
	ResourceAssigned , PDEVICE_OBJECT *  DeviceObject ) ;
#line 16396
__declspec(dllimport) void IoInvalidateDeviceRelations(PDEVICE_OBJECT
	DeviceObject , DEVICE_RELATION_TYPE Type ) ;
#line 16403
__declspec(dllimport) void IoRequestDeviceEject(PDEVICE_OBJECT
	PhysicalDeviceObject ) ;
#line 16409
__declspec(dllimport) NTSTATUS IoGetDeviceProperty(PDEVICE_OBJECT DeviceObject ,
	DEVICE_REGISTRY_PROPERTY DeviceProperty , ULONG BufferLength , PVOID
	PropertyBuffer , PULONG ResultLength ) ;
#line 16427
__declspec(dllimport) NTSTATUS IoOpenDeviceRegistryKey(PDEVICE_OBJECT
	DeviceObject , ULONG DevInstKeyType , ACCESS_MASK DesiredAccess ,
	PHANDLE DevInstRegKey ) ;
#line 16436
__declspec(dllimport) NTSTATUS __stdcall
	IoRegisterDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject , const
	GUID *  InterfaceClassGuid , PUNICODE_STRING ReferenceString ,
	PUNICODE_STRING SymbolicLinkName ) ;
#line 16446
__declspec(dllimport) NTSTATUS IoOpenDeviceInterfaceRegistryKey(PUNICODE_STRING
	SymbolicLinkName , ACCESS_MASK DesiredAccess , PHANDLE
	DeviceInterfaceKey ) ;
#line 16456
__declspec(dllimport) NTSTATUS IoSetDeviceInterfaceState(PUNICODE_STRING
	SymbolicLinkName , BOOLEAN Enable ) ;
#line 16465
__declspec(dllimport) NTSTATUS __stdcall IoGetDeviceInterfaces(const GUID * 
	InterfaceClassGuid , PDEVICE_OBJECT PhysicalDeviceObject , ULONG Flags ,
	PWSTR *  SymbolicLinkList ) ;
#line 16477
__declspec(dllimport) NTSTATUS __stdcall
	IoGetDeviceInterfaceAlias(PUNICODE_STRING SymbolicLinkName , const GUID
	*  AliasInterfaceClassGuid , PUNICODE_STRING AliasSymbolicLinkName ) ;

#line 16490
typedef enum _IO_NOTIFICATION_EVENT_CATEGORY {
	EventCategoryReserved,
	EventCategoryHardwareProfileChange,
	EventCategoryDeviceInterfaceChange,
	EventCategoryTargetDeviceChange
} IO_NOTIFICATION_EVENT_CATEGORY ;

#line 16504
typedef NTSTATUS ( *  PDRIVER_NOTIFICATION_CALLBACK_ROUTINE )(PVOID
	NotificationStructure , PVOID Context ) ;

#line 16512
__declspec(dllimport) NTSTATUS
	IoRegisterPlugPlayNotification(IO_NOTIFICATION_EVENT_CATEGORY
	EventCategory , ULONG EventCategoryFlags , PVOID EventCategoryData ,
	PDRIVER_OBJECT DriverObject , PDRIVER_NOTIFICATION_CALLBACK_ROUTINE
	CallbackRoutine , PVOID Context , PVOID *  NotificationEntry ) ;
#line 16524
__declspec(dllimport) NTSTATUS IoUnregisterPlugPlayNotification(PVOID
	NotificationEntry ) ;
#line 16530
__declspec(dllimport) NTSTATUS IoReportTargetDeviceChange(PDEVICE_OBJECT
	PhysicalDeviceObject , PVOID NotificationStructure ) ;

#line 16537
typedef void ( *  PDEVICE_CHANGE_COMPLETE_CALLBACK )(PVOID Context ) ;

#line 16543
__declspec(dllimport) void IoInvalidateDeviceState(PDEVICE_OBJECT
	PhysicalDeviceObject ) ;
#line 16559
__declspec(dllimport) NTSTATUS
	IoReportTargetDeviceChangeAsynchronous(PDEVICE_OBJECT
	PhysicalDeviceObject , PVOID NotificationStructure ,
	PDEVICE_CHANGE_COMPLETE_CALLBACK Callback , PVOID Context ) ;

#line 16573
typedef enum _ARBITER_ACTION {
	ArbiterActionTestAllocation,
	ArbiterActionRetestAllocation,
	ArbiterActionCommitAllocation,
	ArbiterActionRollbackAllocation,
	ArbiterActionQueryAllocatedResources,
	ArbiterActionWriteReservedResources,
	ArbiterActionQueryConflict,
	ArbiterActionQueryArbitrate,
	ArbiterActionAddReserved,
	ArbiterActionBootAllocation
} ARBITER_ACTION , *  PARBITER_ACTION ;

typedef struct _ARBITER_CONFLICT_INFO {
	PDEVICE_OBJECT OwningObject ;
	ULONGLONG Start ;
	ULONGLONG End ;
} ARBITER_CONFLICT_INFO , *  PARBITER_CONFLICT_INFO ;

#line 16608
typedef struct _ARBITER_PARAMETERS {
	union  {
		struct  {
			PLIST_ENTRY ArbitrationList ;
			ULONG AllocateFromCount ;
			PCM_PARTIAL_RESOURCE_DESCRIPTOR AllocateFrom ;
		} TestAllocation ;
		struct  {
			PLIST_ENTRY ArbitrationList ;
			ULONG AllocateFromCount ;
			PCM_PARTIAL_RESOURCE_DESCRIPTOR AllocateFrom ;
		} RetestAllocation ;
		struct  {
			PLIST_ENTRY ArbitrationList ;
		} BootAllocation ;
		struct  {
			PCM_PARTIAL_RESOURCE_LIST *  AllocatedResources ;
		} QueryAllocatedResources ;
		struct  {
			PDEVICE_OBJECT PhysicalDeviceObject ;
			PIO_RESOURCE_DESCRIPTOR ConflictingResource ;
			PULONG ConflictCount ;
			PARBITER_CONFLICT_INFO *  Conflicts ;
		} QueryConflict ;
		struct  {
			PLIST_ENTRY ArbitrationList ;
		} QueryArbitrate ;
		struct  {
			PDEVICE_OBJECT ReserveDevice ;
		} AddReserved ;
	} Parameters ;
} ARBITER_PARAMETERS , *  PARBITER_PARAMETERS ;

#line 16719
typedef enum _ARBITER_REQUEST_SOURCE {
	ArbiterRequestUndefined = - 1,
	ArbiterRequestLegacyReported,
	ArbiterRequestHalReported,
	ArbiterRequestLegacyAssigned,
	ArbiterRequestPnpDetected,
	ArbiterRequestPnpEnumerated
} ARBITER_REQUEST_SOURCE ;

#line 16731
typedef enum _ARBITER_RESULT {
	ArbiterResultUndefined = - 1,
	ArbiterResultSuccess,
	ArbiterResultExternalConflict,
	ArbiterResultNullRequest
} ARBITER_RESULT ;

#line 16748
__declspec(dllimport) NTSTATUS IoReportResourceForDetection(PDRIVER_OBJECT
	DriverObject , PCM_RESOURCE_LIST DriverList , ULONG DriverListSize ,
	PDEVICE_OBJECT DeviceObject , PCM_RESOURCE_LIST DeviceList , ULONG
	DeviceListSize , PBOOLEAN ConflictDetected ) ;

#line 16761
typedef struct _ARBITER_LIST_ENTRY {
	LIST_ENTRY ListEntry ;
	ULONG AlternativeCount ;
	PIO_RESOURCE_DESCRIPTOR Alternatives ;
	PDEVICE_OBJECT PhysicalDeviceObject ;
	ARBITER_REQUEST_SOURCE RequestSource ;
	ULONG Flags ;
	LONG_PTR WorkSpace ;
	INTERFACE_TYPE InterfaceType ;
	ULONG SlotNumber ;
	ULONG BusNumber ;
	PCM_PARTIAL_RESOURCE_DESCRIPTOR Assignment ;
	PIO_RESOURCE_DESCRIPTOR SelectedAlternative ;
	ARBITER_RESULT Result ;
} ARBITER_LIST_ENTRY , *  PARBITER_LIST_ENTRY ;

#line 16832
typedef NTSTATUS ( *  PARBITER_HANDLER )(PVOID Context , ARBITER_ACTION Action ,
	PARBITER_PARAMETERS Parameters ) ;

#line 16853
typedef struct _ARBITER_INTERFACE {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PARBITER_HANDLER ArbiterHandler ;
	ULONG Flags ;
} ARBITER_INTERFACE , *  PARBITER_INTERFACE ;

#line 16880
typedef enum _RESOURCE_TRANSLATION_DIRECTION {
	TranslateChildToParent,
	TranslateParentToChild
} RESOURCE_TRANSLATION_DIRECTION ;

#line 16889
typedef NTSTATUS ( *  PTRANSLATE_RESOURCE_HANDLER )(PVOID Context ,
	PCM_PARTIAL_RESOURCE_DESCRIPTOR Source , RESOURCE_TRANSLATION_DIRECTION
	Direction , ULONG AlternativesCount , IO_RESOURCE_DESCRIPTOR
	Alternatives[] , PDEVICE_OBJECT PhysicalDeviceObject ,
	PCM_PARTIAL_RESOURCE_DESCRIPTOR Target ) ;

#line 16901
typedef NTSTATUS ( *  PTRANSLATE_RESOURCE_REQUIREMENTS_HANDLER )(PVOID Context ,
	PIO_RESOURCE_DESCRIPTOR Source , PDEVICE_OBJECT PhysicalDeviceObject ,
	PULONG TargetCount , PIO_RESOURCE_DESCRIPTOR *  Target ) ;

#line 16915
typedef struct _TRANSLATOR_INTERFACE {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PTRANSLATE_RESOURCE_HANDLER TranslateResources ;
	PTRANSLATE_RESOURCE_REQUIREMENTS_HANDLER TranslateResourceRequirements ;
} TRANSLATOR_INTERFACE , *  PTRANSLATOR_INTERFACE ;

#line 16931
typedef NTSTATUS ( *  PLEGACY_DEVICE_DETECTION_HANDLER )(PVOID Context ,
	INTERFACE_TYPE LegacyBusType , ULONG BusNumber , ULONG SlotNumber ,
	PDEVICE_OBJECT *  PhysicalDeviceObject ) ;

#line 16945
typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PLEGACY_DEVICE_DETECTION_HANDLER LegacyDeviceDetection ;
} LEGACY_DEVICE_DETECTION_INTERFACE , *  PLEGACY_DEVICE_DETECTION_INTERFACE ;

#line 16959
typedef struct _PLUGPLAY_NOTIFICATION_HEADER {
	USHORT Version ;
	USHORT Size ;
	GUID Event ;
} PLUGPLAY_NOTIFICATION_HEADER , *  PPLUGPLAY_NOTIFICATION_HEADER ;

#line 16972
typedef struct _HWPROFILE_CHANGE_NOTIFICATION {
	USHORT Version ;
	USHORT Size ;
	GUID Event ;
} HWPROFILE_CHANGE_NOTIFICATION , *  PHWPROFILE_CHANGE_NOTIFICATION ;

#line 16986
typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION {
	USHORT Version ;
	USHORT Size ;
	GUID Event ;
	GUID InterfaceClassGuid ;
	PUNICODE_STRING SymbolicLinkName ;
} DEVICE_INTERFACE_CHANGE_NOTIFICATION , * 
	PDEVICE_INTERFACE_CHANGE_NOTIFICATION ;

#line 17006
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION {
	USHORT Version ;
	USHORT Size ;
	GUID Event ;
	PFILE_OBJECT FileObject ;
} TARGET_DEVICE_REMOVAL_NOTIFICATION , *  PTARGET_DEVICE_REMOVAL_NOTIFICATION ;

#line 17026
typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION {
	USHORT Version ;
	USHORT Size ;
	GUID Event ;
	PFILE_OBJECT FileObject ;
	LONG NameBufferOffset ;
	UCHAR CustomDataBuffer[1] ;
} TARGET_DEVICE_CUSTOM_NOTIFICATION , *  PTARGET_DEVICE_CUSTOM_NOTIFICATION ;

#line 17054
typedef struct _DEVICE_DESCRIPTION {
	ULONG Version ;
	BOOLEAN Master ;
	BOOLEAN ScatterGather ;
	BOOLEAN DemandMode ;
	BOOLEAN AutoInitialize ;
	BOOLEAN Dma32BitAddresses ;
	BOOLEAN IgnoreCount ;
	BOOLEAN Reserved1 ;
	BOOLEAN Dma64BitAddresses ;
	ULONG BusNumber ;
	ULONG DmaChannel ;
	INTERFACE_TYPE InterfaceType ;
	DMA_WIDTH DmaWidth ;
	DMA_SPEED DmaSpeed ;
	ULONG MaximumLength ;
	ULONG DmaPort ;
} DEVICE_DESCRIPTION , *  PDEVICE_DESCRIPTION ;

#line 17086
typedef BOOLEAN ( *  PHAL_RESET_DISPLAY_PARAMETERS )(ULONG Columns , ULONG Rows
	) ;

#line 17093
__declspec(dllimport)
	void HalAcquireDisplayOwnership(PHAL_RESET_DISPLAY_PARAMETERS
	ResetDisplayParameters ) ;
#line 17114
__declspec(dllimport) void KeFlushWriteBuffer(void  ) ;
#line 17124
__declspec(dllimport) NTSTATUS HalAssignSlotResources(PUNICODE_STRING
	RegistryPath , PUNICODE_STRING DriverClassName , PDRIVER_OBJECT
	DriverObject , PDEVICE_OBJECT DeviceObject , INTERFACE_TYPE BusType ,
	ULONG BusNumber , ULONG SlotNumber , PCM_RESOURCE_LIST * 
	AllocatedResources ) ;
#line 17137
__declspec(dllimport) ULONG HalGetInterruptVector(INTERFACE_TYPE InterfaceType ,
	ULONG BusNumber , ULONG BusInterruptLevel , ULONG BusInterruptVector ,
	PKIRQL Irql , PKAFFINITY Affinity ) ;
#line 17148
__declspec(dllimport) ULONG HalSetBusData(BUS_DATA_TYPE BusDataType , ULONG
	BusNumber , ULONG SlotNumber , PVOID Buffer , ULONG Length ) ;
#line 17159
__declspec(dllimport) ULONG HalSetBusDataByOffset(BUS_DATA_TYPE BusDataType ,
	ULONG BusNumber , ULONG SlotNumber , PVOID Buffer , ULONG Offset , ULONG
	Length ) ;
#line 17170
__declspec(dllimport) BOOLEAN HalTranslateBusAddress(INTERFACE_TYPE
	InterfaceType , ULONG BusNumber , PHYSICAL_ADDRESS BusAddress , PULONG
	AddressSpace , PPHYSICAL_ADDRESS TranslatedAddress ) ;
#line 17196
__declspec(dllimport) PVOID HalAllocateCrashDumpRegisters(PADAPTER_OBJECT
	AdapterObject , PULONG NumberOfMapRegisters ) ;
#line 17204
__declspec(dllimport) ULONG HalGetBusData(BUS_DATA_TYPE BusDataType , ULONG
	BusNumber , ULONG SlotNumber , PVOID Buffer , ULONG Length ) ;
#line 17215
__declspec(dllimport) ULONG HalGetBusDataByOffset(BUS_DATA_TYPE BusDataType ,
	ULONG BusNumber , ULONG SlotNumber , PVOID Buffer , ULONG Offset , ULONG
	Length ) ;
#line 17226
__declspec(dllimport) PADAPTER_OBJECT HalGetAdapter(PDEVICE_DESCRIPTION
	DeviceDescription , PULONG NumberOfMapRegisters ) ;
#line 17237
__declspec(dllimport) BOOLEAN HalMakeBeep(ULONG Frequency ) ;
#line 17282
__declspec(dllimport) NTSTATUS IoReadPartitionTable(PDEVICE_OBJECT DeviceObject
	, ULONG SectorSize , BOOLEAN ReturnRecognizedPartitions ,
	struct _DRIVE_LAYOUT_INFORMATION *  *  PartitionBuffer ) ;
#line 17291
__declspec(dllimport) NTSTATUS IoSetPartitionInformation(PDEVICE_OBJECT
	DeviceObject , ULONG SectorSize , ULONG PartitionNumber , ULONG
	PartitionType ) ;
#line 17300
__declspec(dllimport) NTSTATUS IoWritePartitionTable(PDEVICE_OBJECT DeviceObject
	, ULONG SectorSize , ULONG SectorsPerTrack , ULONG NumberOfHeads ,
	struct _DRIVE_LAYOUT_INFORMATION *  PartitionBuffer ) ;
#line 17315
__declspec(dllimport) LARGE_INTEGER KeQueryPerformanceCounter(PLARGE_INTEGER
	PerformanceFrequency ) ;
#line 17326
__declspec(dllimport) void KeStallExecutionProcessor(ULONG MicroSeconds ) ;

#line 17333
typedef void ( *  PDEVICE_CONTROL_COMPLETION )(struct _DEVICE_CONTROL_CONTEXT * 
	ControlContext ) ;

#line 17339
typedef struct _DEVICE_CONTROL_CONTEXT {
	NTSTATUS Status ;
	PDEVICE_HANDLER_OBJECT DeviceHandler ;
	PDEVICE_OBJECT DeviceObject ;
	ULONG ControlCode ;
	PVOID Buffer ;
	PULONG BufferLength ;
	PVOID Context ;
} DEVICE_CONTROL_CONTEXT , *  PDEVICE_CONTROL_CONTEXT ;

typedef PBUS_HANDLER (_fastcall *  pHalHandlerForBus )(INTERFACE_TYPE
	InterfaceType , ULONG BusNumber ) ;

#line 17355
typedef void (_fastcall *  pHalReferenceBusHandler )(PBUS_HANDLER BusHandler ) ;

#line 17365
typedef enum _HAL_QUERY_INFORMATION_CLASS {
	HalInstalledBusInformation,
	HalProfileSourceInformation,
	HalInformationClassUnused1,
	HalPowerInformation,
	HalProcessorSpeedInformation,
	HalCallbackInformation,
	HalMapRegisterInformation,
	HalMcaLogInformation,
	HalFrameBufferCachingInformation,
	HalDisplayBiosInformation,
	HalProcessorFeatureInformation
} HAL_QUERY_INFORMATION_CLASS , *  PHAL_QUERY_INFORMATION_CLASS ;

#line 17381
typedef enum _HAL_SET_INFORMATION_CLASS {
	HalProfileSourceInterval,
	HalProfileSourceInterruptHandler,
	HalMcaRegisterDriver
} HAL_SET_INFORMATION_CLASS , *  PHAL_SET_INFORMATION_CLASS ;

#line 17388
typedef NTSTATUS ( *  pHalQuerySystemInformation )(HAL_QUERY_INFORMATION_CLASS
	InformationClass , ULONG BufferSize , PVOID Buffer , PULONG
	ReturnedLength ) ;

#line 17397
NTSTATUS HaliQuerySystemInformation(HAL_SET_INFORMATION_CLASS InformationClass ,
	ULONG BufferSize , PVOID Buffer , PULONG ReturnedLength ) ;

#line 17405
typedef NTSTATUS ( *  pHalSetSystemInformation )(HAL_SET_INFORMATION_CLASS
	InformationClass , ULONG BufferSize , PVOID Buffer ) ;

#line 17413
NTSTATUS HaliSetSystemInformation(HAL_SET_INFORMATION_CLASS InformationClass ,
	ULONG BufferSize , PVOID Buffer ) ;

#line 17420
typedef void (_fastcall *  pHalExamineMBR )(PDEVICE_OBJECT DeviceObject , ULONG
	SectorSize , ULONG MBRTypeIdentifier , PVOID *  Buffer ) ;

#line 17429
typedef void (_fastcall *  pHalIoAssignDriveLetters
	)(struct _LOADER_PARAMETER_BLOCK *  LoaderBlock , PSTRING NtDeviceName ,
	PUCHAR NtSystemPath , PSTRING NtSystemPathString ) ;

#line 17438
typedef NTSTATUS (_fastcall *  pHalIoReadPartitionTable )(PDEVICE_OBJECT
	DeviceObject , ULONG SectorSize , BOOLEAN ReturnRecognizedPartitions ,
	struct _DRIVE_LAYOUT_INFORMATION *  *  PartitionBuffer ) ;

#line 17447
typedef NTSTATUS (_fastcall *  pHalIoSetPartitionInformation )(PDEVICE_OBJECT
	DeviceObject , ULONG SectorSize , ULONG PartitionNumber , ULONG
	PartitionType ) ;

#line 17456
typedef NTSTATUS (_fastcall *  pHalIoWritePartitionTable )(PDEVICE_OBJECT
	DeviceObject , ULONG SectorSize , ULONG SectorsPerTrack , ULONG
	NumberOfHeads , struct _DRIVE_LAYOUT_INFORMATION *  PartitionBuffer ) ;

#line 17466
typedef NTSTATUS ( *  pHalQueryBusSlots )(PBUS_HANDLER BusHandler , ULONG
	BufferSize , PULONG SlotNumbers , PULONG ReturnedLength ) ;

#line 17475
typedef NTSTATUS ( *  pHalInitPnpDriver )(void  ) ;

#line 17481
NTSTATUS HaliInitPnpDriver(void  ) ;

#line 17486
typedef struct _PM_DISPATCH_TABLE {
	ULONG Signature ;
	ULONG Version ;
	PVOID Function[1] ;
} PM_DISPATCH_TABLE , *  PPM_DISPATCH_TABLE ;

typedef NTSTATUS ( *  pHalInitPowerManagement )(PPM_DISPATCH_TABLE
	PmDriverDispatchTable , PPM_DISPATCH_TABLE *  PmHalDispatchTable ) ;

#line 17499
NTSTATUS HaliInitPowerManagement(PPM_DISPATCH_TABLE PmDriverDispatchTable ,
	PPM_DISPATCH_TABLE *  PmHalDispatchTable ) ;

#line 17505
typedef struct _DMA_ADAPTER *  ( *  pHalGetDmaAdapter )(PVOID Context ,
	struct _DEVICE_DESCRIPTION *  DeviceDescriptor , PULONG
	NumberOfMapRegisters ) ;

#line 17513
struct _DMA_ADAPTER *  HaliGetDmaAdapter(PVOID Context ,
	struct _DEVICE_DESCRIPTION *  DeviceDescriptor , PULONG
	NumberOfMapRegisters ) ;

#line 17520
typedef NTSTATUS ( *  pHalGetInterruptTranslator )(INTERFACE_TYPE
	ParentInterfaceType , ULONG ParentBusNumber , INTERFACE_TYPE
	BridgeInterfaceType , USHORT Size , USHORT Version ,
	PTRANSLATOR_INTERFACE Translator , PULONG BridgeBusNumber ) ;

#line 17532
NTSTATUS HaliGetInterruptTranslator(INTERFACE_TYPE ParentInterfaceType , ULONG
	ParentBusNumber , INTERFACE_TYPE BridgeInterfaceType , USHORT Size ,
	USHORT Version , PTRANSLATOR_INTERFACE Translator , PULONG
	BridgeBusNumber ) ;

#line 17543
typedef BOOLEAN ( *  pHalTranslateBusAddress )(INTERFACE_TYPE InterfaceType ,
	ULONG BusNumber , PHYSICAL_ADDRESS BusAddress , PULONG AddressSpace ,
	PPHYSICAL_ADDRESS TranslatedAddress ) ;

#line 17553
typedef NTSTATUS ( *  pHalAssignSlotResources )(PUNICODE_STRING RegistryPath ,
	PUNICODE_STRING DriverClassName , PDRIVER_OBJECT DriverObject ,
	PDEVICE_OBJECT DeviceObject , INTERFACE_TYPE BusType , ULONG BusNumber ,
	ULONG SlotNumber , PCM_RESOURCE_LIST *  AllocatedResources ) ;

#line 17566
typedef void ( *  pHalHaltSystem )(void  ) ;

#line 17572
typedef void ( *  pHalResetDisplay )(void  ) ;

#line 17578
typedef BOOLEAN ( *  pHalFindBusAddressTranslation )(PHYSICAL_ADDRESS BusAddress
	, PULONG AddressSpace , PPHYSICAL_ADDRESS TranslatedAddress , PULONG_PTR
	Context , BOOLEAN NextBus ) ;

#line 17588
typedef struct  {
	ULONG Version ;
	pHalQuerySystemInformation HalQuerySystemInformation ;
	pHalSetSystemInformation HalSetSystemInformation ;
	pHalQueryBusSlots HalQueryBusSlots ;
	ULONG Spare1 ;
	pHalExamineMBR HalExamineMBR ;
	pHalIoAssignDriveLetters HalIoAssignDriveLetters ;
	pHalIoReadPartitionTable HalIoReadPartitionTable ;
	pHalIoSetPartitionInformation HalIoSetPartitionInformation ;
	pHalIoWritePartitionTable HalIoWritePartitionTable ;
	pHalHandlerForBus HalReferenceHandlerForBus ;
	pHalReferenceBusHandler HalReferenceBusHandler ;
	pHalReferenceBusHandler HalDereferenceBusHandler ;
	pHalInitPnpDriver HalInitPnpDriver ;
	pHalInitPowerManagement HalInitPowerManagement ;
	pHalGetDmaAdapter HalGetDmaAdapter ;
	pHalGetInterruptTranslator HalGetInterruptTranslator ;
} HAL_DISPATCH , *  PHAL_DISPATCH ;

#line 17613
extern PHAL_DISPATCH HalDispatchTable ;

#line 17650
typedef struct _HAL_BUS_INFORMATION {
	INTERFACE_TYPE BusType ;
	BUS_DATA_TYPE ConfigurationType ;
	ULONG BusNumber ;
	ULONG Reserved ;
} HAL_BUS_INFORMATION , *  PHAL_BUS_INFORMATION ;

#line 17658
typedef struct _HAL_PROFILE_SOURCE_INFORMATION {
	KPROFILE_SOURCE Source ;
	BOOLEAN Supported ;
	ULONG Interval ;
} HAL_PROFILE_SOURCE_INFORMATION , *  PHAL_PROFILE_SOURCE_INFORMATION ;

#line 17665
typedef struct _HAL_PROFILE_SOURCE_INTERVAL {
	KPROFILE_SOURCE Source ;
	ULONG_PTR Interval ;
} HAL_PROFILE_SOURCE_INTERVAL , *  PHAL_PROFILE_SOURCE_INTERVAL ;

#line 17671
typedef enum _HAL_DISPLAY_BIOS_INFORMATION {
	HalDisplayInt10Bios,
	HalDisplayEmulatedBios,
	HalDisplayNoBios
} HAL_DISPLAY_BIOS_INFORMATION , *  PHAL_DISPLAY_BIOS_INFORMATION ;

#line 17678
typedef struct _HAL_POWER_INFORMATION {
	ULONG TBD ;
} HAL_POWER_INFORMATION , *  PHAL_POWER_INFORMATION ;

#line 17683
typedef struct _HAL_PROCESSOR_SPEED_INFO {
	ULONG TBD ;
} HAL_PROCESSOR_SPEED_INFORMATION , *  PHAL_PROCESSOR_SPEED_INFORMATION ;

#line 17688
typedef struct _HAL_CALLBACKS {
	PCALLBACK_OBJECT___0 SetSystemInformation ;
	PCALLBACK_OBJECT___0 BusCheck ;
} HAL_CALLBACKS , *  PHAL_CALLBACKS ;

#line 17694
typedef struct _HAL_PROCESSOR_FEATURE {
	ULONG UsableFeatureBits ;
} HAL_PROCESSOR_FEATURE ;

#line 17706
typedef union _MCI_ADDR {
	struct  {
		ULONG Address ;
		ULONG Reserved ;
	}  ;
	ULONGLONG QuadPart ;
} MCI_ADDR , *  PMCI_ADDR ;

#line 17716
typedef enum  {
	HAL_MCE_RECORD,
	HAL_MCA_RECORD
} MCA_EXCEPTION_TYPE ;

#line 17726
typedef struct _MCA_EXCEPTION {
	ULONG VersionNumber ;
	MCA_EXCEPTION_TYPE ExceptionType ;
	LARGE_INTEGER TimeStamp ;
	ULONG ProcessorNumber ;
	union  {
		struct  {
			UCHAR BankNumber ;
			MCI_STATS Status ;
			MCI_ADDR Address ;
			ULONGLONG Misc ;
		} Mca ;
		struct  {
			ULONGLONG Address ;
			ULONGLONG Type ;
		} Mce ;
	} u ;
} MCA_EXCEPTION , *  PMCA_EXCEPTION ;

#line 17752
typedef void ( *  PDRIVER_EXCPTN_CALLBACK )(PVOID Context , PMCA_EXCEPTION
	BankLog ) ;

#line 17762
typedef struct _MCA_DRIVER_INFO {
	PDRIVER_EXCPTN_CALLBACK ExceptionCallback ;
	PKDEFERRED_ROUTINE DpcCallback ;
	PVOID DeviceContext ;
} MCA_DRIVER_INFO , *  PMCA_DRIVER_INFO ;

#line 17772
typedef struct _SCATTER_GATHER_ELEMENT {
	PHYSICAL_ADDRESS Address ;
	ULONG Length ;
	ULONG_PTR Reserved ;
} SCATTER_GATHER_ELEMENT , *  PSCATTER_GATHER_ELEMENT ;


#pragma warning(disable:4200)
#line 17779
typedef struct _SCATTER_GATHER_LIST {
	ULONG NumberOfElements ;
	ULONG_PTR Reserved ;
	SCATTER_GATHER_ELEMENT Elements[] ;
} SCATTER_GATHER_LIST , *  PSCATTER_GATHER_LIST ;

#line 17784

#pragma warning(default:4200)
#line 17788
typedef struct _DMA_OPERATIONS *  PDMA_OPERATIONS ;

typedef struct _DMA_ADAPTER {
	USHORT Version ;
	USHORT Size ;
	PDMA_OPERATIONS DmaOperations ;
} DMA_ADAPTER , *  PDMA_ADAPTER ;

#line 17797
typedef void ( *  PPUT_DMA_ADAPTER )(PDMA_ADAPTER DmaAdapter ) ;

#line 17801
typedef PVOID ( *  PALLOCATE_COMMON_BUFFER )(PDMA_ADAPTER DmaAdapter , ULONG
	Length , PPHYSICAL_ADDRESS LogicalAddress , BOOLEAN CacheEnabled ) ;

#line 17808
typedef void ( *  PFREE_COMMON_BUFFER )(PDMA_ADAPTER DmaAdapter , ULONG Length ,
	PHYSICAL_ADDRESS LogicalAddress , PVOID VirtualAddress , BOOLEAN
	CacheEnabled ) ;

#line 17816
typedef NTSTATUS ( *  PALLOCATE_ADAPTER_CHANNEL )(PDMA_ADAPTER DmaAdapter ,
	PDEVICE_OBJECT DeviceObject , ULONG NumberOfMapRegisters ,
	PDRIVER_CONTROL ExecutionRoutine , PVOID Context ) ;

#line 17824
typedef BOOLEAN ( *  PFLUSH_ADAPTER_BUFFERS )(PDMA_ADAPTER DmaAdapter , PMDL Mdl
	, PVOID MapRegisterBase , PVOID CurrentVa , ULONG Length , BOOLEAN
	WriteToDevice ) ;

#line 17833
typedef void ( *  PFREE_ADAPTER_CHANNEL )(PDMA_ADAPTER DmaAdapter ) ;

#line 17837
typedef void ( *  PFREE_MAP_REGISTERS )(PDMA_ADAPTER DmaAdapter , PVOID
	MapRegisterBase , ULONG NumberOfMapRegisters ) ;

#line 17843
typedef PHYSICAL_ADDRESS ( *  PMAP_TRANSFER )(PDMA_ADAPTER DmaAdapter , PMDL Mdl
	, PVOID MapRegisterBase , PVOID CurrentVa , PULONG Length , BOOLEAN
	WriteToDevice ) ;

#line 17852
typedef ULONG ( *  PGET_DMA_ALIGNMENT )(PDMA_ADAPTER DmaAdapter ) ;

#line 17856
typedef ULONG ( *  PREAD_DMA_COUNTER )(PDMA_ADAPTER DmaAdapter ) ;

#line 17860
typedef void ( *  PDRIVER_LIST_CONTROL )(struct _DEVICE_OBJECT *  DeviceObject ,
	struct _IRP *  Irp , PSCATTER_GATHER_LIST ScatterGather , PVOID Context
	) ;

#line 17868
typedef NTSTATUS ( *  PGET_SCATTER_GATHER_LIST )(PDMA_ADAPTER DmaAdapter ,
	PDEVICE_OBJECT DeviceObject , PMDL Mdl , PVOID CurrentVa , ULONG Length
	, PDRIVER_LIST_CONTROL ExecutionRoutine , PVOID Context , BOOLEAN
	WriteToDevice ) ;

#line 17880
typedef void ( *  PPUT_SCATTER_GATHER_LIST )(PDMA_ADAPTER DmaAdapter ,
	PSCATTER_GATHER_LIST ScatterGather , BOOLEAN WriteToDevice ) ;

#line 17887
typedef struct _DMA_OPERATIONS {
	ULONG Size ;
	PPUT_DMA_ADAPTER PutDmaAdapter ;
	PALLOCATE_COMMON_BUFFER AllocateCommonBuffer ;
	PFREE_COMMON_BUFFER FreeCommonBuffer ;
	PALLOCATE_ADAPTER_CHANNEL AllocateAdapterChannel ;
	PFLUSH_ADAPTER_BUFFERS FlushAdapterBuffers ;
	PFREE_ADAPTER_CHANNEL FreeAdapterChannel ;
	PFREE_MAP_REGISTERS FreeMapRegisters ;
	PMAP_TRANSFER MapTransfer ;
	PGET_DMA_ALIGNMENT GetDmaAlignment ;
	PREAD_DMA_COUNTER ReadDmaCounter ;
	PGET_SCATTER_GATHER_LIST GetScatterGatherList ;
	PPUT_SCATTER_GATHER_LIST PutScatterGatherList ;
} DMA_OPERATIONS ;

#line 18126
__declspec(dllimport) NTSTATUS HalAllocateAdapterChannel(PADAPTER_OBJECT
	AdapterObject , PWAIT_CONTEXT_BLOCK Wcb , ULONG NumberOfMapRegisters ,
	PDRIVER_CONTROL ExecutionRoutine ) ;
#line 18135
__declspec(dllimport) PVOID HalAllocateCommonBuffer(PADAPTER_OBJECT
	AdapterObject , ULONG Length , PPHYSICAL_ADDRESS LogicalAddress ,
	BOOLEAN CacheEnabled ) ;
#line 18144
__declspec(dllimport) void HalFreeCommonBuffer(PADAPTER_OBJECT AdapterObject ,
	ULONG Length , PHYSICAL_ADDRESS LogicalAddress , PVOID VirtualAddress ,
	BOOLEAN CacheEnabled ) ;
#line 18154
__declspec(dllimport) ULONG HalReadDmaCounter(PADAPTER_OBJECT AdapterObject ) ;
#line 18160
__declspec(dllimport) BOOLEAN IoFlushAdapterBuffers(PADAPTER_OBJECT
	AdapterObject , PMDL Mdl , PVOID MapRegisterBase , PVOID CurrentVa ,
	ULONG Length , BOOLEAN WriteToDevice ) ;
#line 18171
__declspec(dllimport) void IoFreeAdapterChannel(PADAPTER_OBJECT AdapterObject )
	;
#line 18177
__declspec(dllimport) void IoFreeMapRegisters(PADAPTER_OBJECT AdapterObject ,
	PVOID MapRegisterBase , ULONG NumberOfMapRegisters ) ;
#line 18185
__declspec(dllimport) PHYSICAL_ADDRESS IoMapTransfer(PADAPTER_OBJECT
	AdapterObject , PMDL Mdl , PVOID MapRegisterBase , PVOID CurrentVa ,
	PULONG Length , BOOLEAN WriteToDevice ) ;
#line 18197
NTSTATUS HalGetScatterGatherList(PADAPTER_OBJECT DmaAdapter , PDEVICE_OBJECT
	DeviceObject , PMDL Mdl , PVOID CurrentVa , ULONG Length ,
	PDRIVER_LIST_CONTROL ExecutionRoutine , PVOID Context , BOOLEAN
	WriteToDevice ) ;
#line 18209
void HalPutScatterGatherList(PADAPTER_OBJECT DmaAdapter , PSCATTER_GATHER_LIST
	ScatterGather , BOOLEAN WriteToDevice ) ;
#line 18216
void HalPutDmaAdapter(PADAPTER_OBJECT DmaAdapter ) ;
#line 18222
__declspec(dllimport) void PoSetSystemState(EXECUTION_STATE Flags ) ;
#line 18228
__declspec(dllimport) PVOID PoRegisterSystemState(PVOID StateHandle ,
	EXECUTION_STATE Flags ) ;

#line 18235
typedef void ( *  PREQUEST_POWER_COMPLETE )(PDEVICE_OBJECT DeviceObject , UCHAR
	MinorFunction , POWER_STATE PowerState , PVOID Context ,
	PIO_STATUS_BLOCK IoStatus ) ;

#line 18245
__declspec(dllimport) NTSTATUS PoRequestPowerIrp(PDEVICE_OBJECT DeviceObject ,
	UCHAR MinorFunction , POWER_STATE PowerState , PREQUEST_POWER_COMPLETE
	CompletionFunction , PVOID Context , PIRP *  Irp ) ;
#line 18256
__declspec(dllimport) void PoUnregisterSystemState(PVOID StateHandle ) ;
#line 18263
__declspec(dllimport) POWER_STATE PoSetPowerState(PDEVICE_OBJECT DeviceObject ,
	POWER_STATE_TYPE Type , POWER_STATE State ) ;
#line 18271
__declspec(dllimport) NTSTATUS PoCallDriver(PDEVICE_OBJECT DeviceObject , PIRP
	Irp ) ;
#line 18278
__declspec(dllimport) void PoStartNextPowerIrp(PIRP Irp ) ;
#line 18285
__declspec(dllimport) PULONG PoRegisterDeviceForIdleDetection(PDEVICE_OBJECT
	DeviceObject , ULONG ConservationIdleTime , ULONG PerformanceIdleTime ,
	DEVICE_POWER_STATE State ) ;
#line 18311
__declspec(dllimport) BOOLEAN FsRtlIsTotalDeviceFailure(NTSTATUS Status ) ;

#line 18321
typedef struct _OBJECT_HANDLE_INFORMATION {
	ULONG HandleAttributes ;
	ACCESS_MASK GrantedAccess ;
} OBJECT_HANDLE_INFORMATION , *  POBJECT_HANDLE_INFORMATION ;

__declspec(dllimport) NTSTATUS ObReferenceObjectByHandle(HANDLE Handle ,
	ACCESS_MASK DesiredAccess , POBJECT_TYPE ObjectType , KPROCESSOR_MODE
	AccessMode , PVOID *  Object , POBJECT_HANDLE_INFORMATION
	HandleInformation ) ;
#line 18342
__declspec(dllimport) void _fastcall ObfReferenceObject(PVOID Object ) ;
#line 18350
__declspec(dllimport) NTSTATUS ObReferenceObjectByPointer(PVOID Object ,
	ACCESS_MASK DesiredAccess , POBJECT_TYPE ObjectType , KPROCESSOR_MODE
	AccessMode ) ;
#line 18359
__declspec(dllimport) void _fastcall ObfDereferenceObject(PVOID Object ) ;
#line 18366
NTSTATUS ObGetObjectSecurity(PVOID Object , PSECURITY_DESCRIPTOR * 
	SecurityDescriptor , PBOOLEAN MemoryAllocated ) ;
#line 18373
void ObReleaseObjectSecurity(PSECURITY_DESCRIPTOR SecurityDescriptor , BOOLEAN
	MemoryAllocated ) ;

#line 18402
typedef struct _PCI_SLOT_NUMBER {
	union  {
		struct  {
			ULONG DeviceNumber  : 5;
			ULONG FunctionNumber  : 3;
			ULONG Reserved  : 24;
		} bits ;
		ULONG AsULONG ;
	} u ;
} PCI_SLOT_NUMBER , *  PPCI_SLOT_NUMBER ;

#line 18418
typedef struct _PCI_COMMON_CONFIG {
	USHORT VendorID ;
	USHORT DeviceID ;
	USHORT Command ;
	USHORT Status ;
	UCHAR RevisionID ;
	UCHAR ProgIf ;
	UCHAR SubClass ;
	UCHAR BaseClass ;
	UCHAR CacheLineSize ;
	UCHAR LatencyTimer ;
	UCHAR HeaderType ;
	UCHAR BIST ;
	union  {
		struct _PCI_HEADER_TYPE_0 {
			ULONG BaseAddresses[6] ;
			ULONG CIS ;
			USHORT SubVendorID ;
			USHORT SubSystemID ;
			ULONG ROMBaseAddress ;
			UCHAR CapabilitiesPtr ;
			UCHAR Reserved1[3] ;
			ULONG Reserved2 ;
			UCHAR InterruptLine ;
			UCHAR InterruptPin ;
			UCHAR MinimumGrant ;
			UCHAR MaximumLatency ;
		} type0 ;
		struct _PCI_HEADER_TYPE_1 {
			ULONG BaseAddresses[2] ;
			UCHAR PrimaryBus ;
			UCHAR SecondaryBus ;
			UCHAR SubordinateBus ;
			UCHAR SecondaryLatency ;
			UCHAR IOBase ;
			UCHAR IOLimit ;
			USHORT SecondaryStatus ;
			USHORT MemoryBase ;
			USHORT MemoryLimit ;
			USHORT PrefetchBase ;
			USHORT PrefetchLimit ;
			ULONG PrefetchBaseUpper32 ;
			ULONG PrefetchLimitUpper32 ;
			USHORT IOBaseUpper16 ;
			USHORT IOLimitUpper16 ;
			UCHAR CapabilitiesPtr ;
			UCHAR Reserved1[3] ;
			ULONG ROMBaseAddress ;
			UCHAR InterruptLine ;
			UCHAR InterruptPin ;
			USHORT BridgeControl ;
		} type1 ;
		struct _PCI_HEADER_TYPE_2 {
			ULONG SocketRegistersBaseAddress ;
			UCHAR CapabilitiesPtr ;
			UCHAR Reserved ;
			USHORT SecondaryStatus ;
			UCHAR PrimaryBus ;
			UCHAR SecondaryBus ;
			UCHAR SubordinateBus ;
			UCHAR SecondaryLatency ;
			struct  {
				ULONG Base ;
				ULONG Limit ;
			} Range[5 - 1] ;
			UCHAR InterruptLine ;
			UCHAR InterruptPin ;
			USHORT BridgeControl ;
		} type2 ;
	} u ;
	UCHAR DeviceSpecific[192] ;
} PCI_COMMON_CONFIG , *  PPCI_COMMON_CONFIG ;

#line 18591
typedef struct _PCI_CAPABILITIES_HEADER {
	UCHAR CapabilityID ;
	UCHAR Next ;
} PCI_CAPABILITIES_HEADER , *  PPCI_CAPABILITIES_HEADER ;

#line 18600
typedef struct _PCI_PMC {
	UCHAR Version  : 3;
	UCHAR PMEClock  : 1;
	UCHAR Rsvd1  : 1;
	UCHAR DeviceSpecificInitialization  : 1;
	UCHAR Rsvd2  : 2;
	struct _PM_SUPPORT {
		UCHAR Rsvd2  : 1;
		UCHAR D1  : 1;
		UCHAR D2  : 1;
		UCHAR PMED0  : 1;
		UCHAR PMED1  : 1;
		UCHAR PMED2  : 1;
		UCHAR PMED3Hot  : 1;
		UCHAR PMED3Cold  : 1;
	} Support ;
} PCI_PMC , *  PPCI_PMC ;

typedef struct _PCI_PMCSR {
	USHORT PowerState  : 2;
	USHORT Rsvd1  : 6;
	USHORT PMEEnable  : 1;
	USHORT DataSelect  : 4;
	USHORT DataScale  : 2;
	USHORT PMEStatus  : 1;
} PCI_PMCSR , *  PPCI_PMCSR ;

#line 18628
typedef struct _PCI_PMCSR_BSE {
	UCHAR Rsvd1  : 6;
	UCHAR D3HotSupportsStopClock  : 1;
	UCHAR BusPowerClockControlEnabled  : 1;
} PCI_PMCSR_BSE , *  PPCI_PMCSR_BSE ;

#line 18635
typedef struct _PCI_PM_CAPABILITY {
	PCI_CAPABILITIES_HEADER Header ;
	union  {
		PCI_PMC Capabilities ;
		USHORT AsUSHORT ;
	} PMC ;
	union  {
		PCI_PMCSR ControlStatus ;
		USHORT AsUSHORT ;
	} PMCSR ;
	union  {
		PCI_PMCSR_BSE BridgeSupport ;
		UCHAR AsUCHAR ;
	} PMCSR_BSE ;
	UCHAR Data ;
} PCI_PM_CAPABILITY , *  PPCI_PM_CAPABILITY ;

#line 18679
typedef struct _PCI_AGP_CAPABILITY {
	PCI_CAPABILITIES_HEADER Header ;
	USHORT Minor  : 4;
	USHORT Major  : 4;
	USHORT Rsvd1  : 8;
	struct _PCI_AGP_STATUS {
		ULONG Rate  : 3;
		ULONG Rsvd1  : 1;
		ULONG FastWrite  : 1;
		ULONG FourGB  : 1;
		ULONG Rsvd2  : 3;
		ULONG SideBandAddressing  : 1;
		ULONG Rsvd3  : 14;
		ULONG RequestQueueDepthMaximum  : 8;
	} AGPStatus ;
	struct _PCI_AGP_COMMAND {
		ULONG Rate  : 3;
		ULONG Rsvd1  : 1;
		ULONG FastWriteEnable  : 1;
		ULONG FourGBEnable  : 1;
		ULONG Rsvd2  : 2;
		ULONG AGPEnable  : 1;
		ULONG SBAEnable  : 1;
		ULONG Rsvd3  : 14;
		ULONG RequestQueueDepth  : 8;
	} AGPCommand ;
} PCI_AGP_CAPABILITY , *  PPCI_AGP_CAPABILITY ;

#line 18720
typedef struct _PCI_MSI_CAPABILITY {
	PCI_CAPABILITIES_HEADER Header ;
	struct _PCI_MSI_MESSAGE_CONTROL {
		USHORT MSIEnable  : 1;
		USHORT MultipleMessageCapable  : 3;
		USHORT MultipleMessageEnable  : 3;
		USHORT CapableOf64Bits  : 1;
		USHORT Reserved  : 8;
	} MessageControl ;
	union  {
		struct _PCI_MSI_MESSAGE_ADDRESS {
			ULONG_PTR Reserved  : 2;
			ULONG_PTR Address  : 30;
		} Register ;
		ULONG_PTR Raw ;
	} MessageAddress ;
	union  {
		struct _PCI_MSI_64BIT_DATA {
			ULONG MessageUpperAddress ;
			USHORT MessageData ;
		} Bit64 ;
		struct _PCI_MSI_32BIT_DATA {
			USHORT MessageData ;
			ULONG Unused ;
		} Bit32 ;
	} Data ;
} PCI_MSI_CAPABILITY , *  PPCI_PCI_CAPABILITY ;

#line 18946
typedef void ( *  PciPin2Line )(struct _BUS_HANDLER *  BusHandler ,
	struct _BUS_HANDLER *  RootHandler , PCI_SLOT_NUMBER SlotNumber ,
	PPCI_COMMON_CONFIG PciData ) ;

#line 18954
typedef void ( *  PciLine2Pin )(struct _BUS_HANDLER *  BusHandler ,
	struct _BUS_HANDLER *  RootHandler , PCI_SLOT_NUMBER SlotNumber ,
	PPCI_COMMON_CONFIG PciNewData , PPCI_COMMON_CONFIG PciOldData ) ;

#line 18963
typedef void ( *  PciReadWriteConfig )(struct _BUS_HANDLER *  BusHandler ,
	PCI_SLOT_NUMBER Slot , PVOID Buffer , ULONG Offset , ULONG Length ) ;

#line 18975
typedef struct _PCIBUSDATA {
	ULONG Tag ;
	ULONG Version ;
	PciReadWriteConfig ReadConfig ;
	PciReadWriteConfig WriteConfig ;
	PciPin2Line Pin2Line ;
	PciLine2Pin Line2Pin ;
	PCI_SLOT_NUMBER ParentSlot ;
	PVOID Reserved[4] ;
} PCIBUSDATA , *  PPCIBUSDATA ;

typedef ULONG ( *  PCI_READ_WRITE_CONFIG )(PVOID Context , UCHAR BusOffset ,
	ULONG Slot , PVOID Buffer , ULONG Offset , ULONG Length ) ;

#line 18995
typedef void ( *  PCI_PIN_TO_LINE )(PVOID Context , PPCI_COMMON_CONFIG PciData )
	;

#line 19000
typedef void ( *  PCI_LINE_TO_PIN )(PVOID Context , PPCI_COMMON_CONFIG
	PciNewData , PPCI_COMMON_CONFIG PciOldData ) ;

#line 19006
typedef struct _PCI_BUS_INTERFACE_STANDARD {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PCI_READ_WRITE_CONFIG ReadConfig ;
	PCI_READ_WRITE_CONFIG WriteConfig ;
	PCI_PIN_TO_LINE PinToLine ;
	PCI_LINE_TO_PIN LineToPin ;
} PCI_BUS_INTERFACE_STANDARD , *  PPCI_BUS_INTERFACE_STANDARD ;

#line 19028
typedef BOOLEAN ( *  PPCI_IS_DEVICE_PRESENT )(USHORT VendorID , USHORT DeviceID
	, UCHAR RevisionID , USHORT SubVendorID , USHORT SubSystemID , ULONG
	Flags ) ;

#line 19043
typedef struct _PCI_DEVICE_PRESENT_INTERFACE {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PPCI_IS_DEVICE_PRESENT IsDevicePresent ;
} PCI_DEVICE_PRESENT_INTERFACE , *  PPCI_DEVICE_PRESENT_INTERFACE ;

#line 19066
extern POBJECT_TYPE *  IoFileObjectType ;
extern POBJECT_TYPE *  ExEventObjectType ;
extern POBJECT_TYPE *  ExSemaphoreObjectType ;
#line 19074
__declspec(dllimport) NTSTATUS __stdcall ZwCreateFile(PHANDLE FileHandle ,
	ACCESS_MASK DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes ,
	PIO_STATUS_BLOCK IoStatusBlock , PLARGE_INTEGER AllocationSize , ULONG
	FileAttributes , ULONG ShareAccess , ULONG CreateDisposition , ULONG
	CreateOptions , PVOID EaBuffer , ULONG EaLength ) ;
#line 19091
__declspec(dllimport) NTSTATUS __stdcall ZwOpenFile(PHANDLE FileHandle ,
	ACCESS_MASK DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes ,
	PIO_STATUS_BLOCK IoStatusBlock , ULONG ShareAccess , ULONG OpenOptions )
	;
#line 19103
__declspec(dllimport) NTSTATUS __stdcall ZwQueryInformationFile(HANDLE
	FileHandle , PIO_STATUS_BLOCK IoStatusBlock , PVOID FileInformation ,
	ULONG Length , FILE_INFORMATION_CLASS FileInformationClass ) ;
#line 19114
__declspec(dllimport) NTSTATUS __stdcall ZwSetInformationFile(HANDLE FileHandle
	, PIO_STATUS_BLOCK IoStatusBlock , PVOID FileInformation , ULONG Length
	, FILE_INFORMATION_CLASS FileInformationClass ) ;
#line 19125
__declspec(dllimport) NTSTATUS __stdcall ZwReadFile(HANDLE FileHandle , HANDLE
	Event , PIO_APC_ROUTINE ApcRoutine , PVOID ApcContext , PIO_STATUS_BLOCK
	IoStatusBlock , PVOID Buffer , ULONG Length , PLARGE_INTEGER ByteOffset
	, PULONG Key ) ;
#line 19140
__declspec(dllimport) NTSTATUS __stdcall ZwWriteFile(HANDLE FileHandle , HANDLE
	Event , PIO_APC_ROUTINE ApcRoutine , PVOID ApcContext , PIO_STATUS_BLOCK
	IoStatusBlock , PVOID Buffer , ULONG Length , PLARGE_INTEGER ByteOffset
	, PULONG Key ) ;
#line 19155
__declspec(dllimport) NTSTATUS __stdcall ZwClose(HANDLE Handle ) ;
#line 19162
__declspec(dllimport) NTSTATUS __stdcall ZwCreateDirectoryObject(PHANDLE
	DirectoryHandle , ACCESS_MASK DesiredAccess , POBJECT_ATTRIBUTES
	ObjectAttributes ) ;
#line 19171
__declspec(dllimport) NTSTATUS __stdcall ZwMakeTemporaryObject(HANDLE Handle ) ;
#line 19178
__declspec(dllimport) NTSTATUS __stdcall ZwOpenSection(PHANDLE SectionHandle ,
	ACCESS_MASK DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes ) ;
#line 19187
__declspec(dllimport) NTSTATUS __stdcall ZwMapViewOfSection(HANDLE SectionHandle
	, HANDLE ProcessHandle , PVOID *  BaseAddress , ULONG ZeroBits , ULONG
	CommitSize , PLARGE_INTEGER SectionOffset , PSIZE_T ViewSize ,
	SECTION_INHERIT InheritDisposition , ULONG AllocationType , ULONG
	Protect ) ;
#line 19203
__declspec(dllimport) NTSTATUS __stdcall ZwUnmapViewOfSection(HANDLE
	ProcessHandle , PVOID BaseAddress ) ;
#line 19211
__declspec(dllimport) NTSTATUS __stdcall ZwSetInformationThread(HANDLE
	ThreadHandle , THREADINFOCLASS ThreadInformationClass , PVOID
	ThreadInformation , ULONG ThreadInformationLength ) ;
#line 19221
__declspec(dllimport) NTSTATUS __stdcall ZwCreateKey(PHANDLE KeyHandle ,
	ACCESS_MASK DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes , ULONG
	TitleIndex , PUNICODE_STRING Class , ULONG CreateOptions , PULONG
	Disposition ) ;
#line 19234
__declspec(dllimport) NTSTATUS __stdcall ZwOpenKey(PHANDLE KeyHandle ,
	ACCESS_MASK DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes ) ;
#line 19243
__declspec(dllimport) NTSTATUS __stdcall ZwDeleteKey(HANDLE KeyHandle ) ;
#line 19250
__declspec(dllimport) NTSTATUS __stdcall ZwEnumerateKey(HANDLE KeyHandle , ULONG
	Index , KEY_INFORMATION_CLASS KeyInformationClass , PVOID KeyInformation
	, ULONG Length , PULONG ResultLength ) ;
#line 19262
__declspec(dllimport) NTSTATUS __stdcall ZwEnumerateValueKey(HANDLE KeyHandle ,
	ULONG Index , KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass ,
	PVOID KeyValueInformation , ULONG Length , PULONG ResultLength ) ;
#line 19274
__declspec(dllimport) NTSTATUS __stdcall ZwFlushKey(HANDLE KeyHandle ) ;
#line 19281
__declspec(dllimport) NTSTATUS __stdcall ZwQueryKey(HANDLE KeyHandle ,
	KEY_INFORMATION_CLASS KeyInformationClass , PVOID KeyInformation , ULONG
	Length , PULONG ResultLength ) ;
#line 19292
__declspec(dllimport) NTSTATUS __stdcall ZwQueryValueKey(HANDLE KeyHandle ,
	PUNICODE_STRING ValueName , KEY_VALUE_INFORMATION_CLASS
	KeyValueInformationClass , PVOID KeyValueInformation , ULONG Length ,
	PULONG ResultLength ) ;
#line 19304
__declspec(dllimport) NTSTATUS __stdcall ZwSetValueKey(HANDLE KeyHandle ,
	PUNICODE_STRING ValueName , ULONG TitleIndex , ULONG Type , PVOID Data ,
	ULONG DataSize ) ;
#line 19316
__declspec(dllimport) NTSTATUS __stdcall ZwOpenSymbolicLinkObject(PHANDLE
	LinkHandle , ACCESS_MASK DesiredAccess , POBJECT_ATTRIBUTES
	ObjectAttributes ) ;
#line 19325
__declspec(dllimport) NTSTATUS __stdcall ZwQuerySymbolicLinkObject(HANDLE
	LinkHandle , PUNICODE_STRING LinkTarget , PULONG ReturnedLength ) ;
#line 19334
NTSTATUS ZwCreateTimer(PHANDLE TimerHandle , ACCESS_MASK DesiredAccess ,
	POBJECT_ATTRIBUTES ObjectAttributes , TIMER_TYPE TimerType ) ;
#line 19342
NTSTATUS ZwOpenTimer(PHANDLE TimerHandle , ACCESS_MASK DesiredAccess ,
	POBJECT_ATTRIBUTES ObjectAttributes ) ;
#line 19349
NTSTATUS ZwCancelTimer(HANDLE TimerHandle , PBOOLEAN CurrentState ) ;
#line 19355
NTSTATUS ZwSetTimer(HANDLE TimerHandle , PLARGE_INTEGER DueTime ,
	PTIMER_APC_ROUTINE TimerApcRoutine , PVOID TimerContext , BOOLEAN
	WakeTimer , LONG Period , PBOOLEAN PreviousState ) ;
#line 45 "C:/NTDDK/inc/ntddser.h"
extern const GUID GUID_CLASS_COMPORT ;
extern const GUID GUID_SERENUM_BUS_ENUMERATOR ;

#line 127
typedef struct _SERIALPERF_STATS {
	ULONG ReceivedCount ;
	ULONG TransmittedCount ;
	ULONG FrameErrorCount ;
	ULONG SerialOverrunErrorCount ;
	ULONG BufferOverrunErrorCount ;
	ULONG ParityErrorCount ;
} SERIALPERF_STATS , *  PSERIALPERF_STATS ;

typedef struct _SERIALCONFIG {
	ULONG Size ;
	USHORT Version ;
	ULONG SubType ;
	ULONG ProvOffset ;
	ULONG ProviderSize ;
	WCHAR ProviderData[1] ;
} SERIALCONFIG , *  PSERIALCONFIG ;

#line 154
typedef struct _SERIAL_LINE_CONTROL {
	UCHAR StopBits ;
	UCHAR Parity ;
	UCHAR WordLength ;
} SERIAL_LINE_CONTROL , *  PSERIAL_LINE_CONTROL ;

typedef struct _SERIAL_TIMEOUTS {
	ULONG ReadIntervalTimeout ;
	ULONG ReadTotalTimeoutMultiplier ;
	ULONG ReadTotalTimeoutConstant ;
	ULONG WriteTotalTimeoutMultiplier ;
	ULONG WriteTotalTimeoutConstant ;
} SERIAL_TIMEOUTS , *  PSERIAL_TIMEOUTS ;

#line 175
typedef struct _SERIAL_QUEUE_SIZE {
	ULONG InSize ;
	ULONG OutSize ;
} SERIAL_QUEUE_SIZE , *  PSERIAL_QUEUE_SIZE ;

#line 185
typedef struct _SERIAL_BAUD_RATE {
	ULONG BaudRate ;
} SERIAL_BAUD_RATE , *  PSERIAL_BAUD_RATE ;

#line 247
typedef struct _SERIAL_CHARS {
	UCHAR EofChar ;
	UCHAR ErrorChar ;
	UCHAR BreakChar ;
	UCHAR EventChar ;
	UCHAR XonChar ;
	UCHAR XoffChar ;
} SERIAL_CHARS , *  PSERIAL_CHARS ;

#line 284
typedef struct _SERIAL_HANDFLOW {
	ULONG ControlHandShake ;
	ULONG FlowReplace ;
	LONG XonLimit ;
	LONG XoffLimit ;
} SERIAL_HANDFLOW , *  PSERIAL_HANDFLOW ;

#line 340
typedef struct _SERIAL_BASIC_SETTINGS {
	SERIAL_TIMEOUTS Timeouts ;
	SERIAL_HANDFLOW HandFlow ;
	ULONG RxFifo ;
	ULONG TxFifo ;
} SERIAL_BASIC_SETTINGS , *  PSERIAL_BASIC_SETTINGS ;

#line 353
typedef struct _SERIAL_STATUS {
	ULONG Errors ;
	ULONG HoldReasons ;
	ULONG AmountInInQueue ;
	ULONG AmountInOutQueue ;
	BOOLEAN EofReceived ;
	BOOLEAN WaitForImmediate ;
} SERIAL_STATUS , *  PSERIAL_STATUS ;

#line 433
typedef struct _SERIAL_XOFF_COUNTER {
	ULONG Timeout ;
	LONG Counter ;
	UCHAR XoffChar ;
} SERIAL_XOFF_COUNTER , *  PSERIAL_XOFF_COUNTER ;

#line 539
typedef struct _SERIAL_COMMPROP {
	USHORT PacketLength ;
	USHORT PacketVersion ;
	ULONG ServiceMask ;
	ULONG Reserved1 ;
	ULONG MaxTxQueue ;
	ULONG MaxRxQueue ;
	ULONG MaxBaud ;
	ULONG ProvSubType ;
	ULONG ProvCapabilities ;
	ULONG SettableParams ;
	ULONG SettableBaud ;
	USHORT SettableData ;
	USHORT SettableStopParity ;
	ULONG CurrentTxQueue ;
	ULONG CurrentRxQueue ;
	ULONG ProvSpec1 ;
	ULONG ProvSpec2 ;
	WCHAR ProvChar[1] ;
} SERIAL_COMMPROP , *  PSERIAL_COMMPROP ;

#line 631
typedef struct _SERENUM_PORT_DESC {
	ULONG Size ;
	PVOID PortHandle ;
	LARGE_INTEGER PortAddress ;
	USHORT Reserved[1] ;
} SERENUM_PORT_DESC , *  PSERENUM_PORT_DESC ;

#line 652
typedef UCHAR ( *  PSERENUM_READPORT )(PVOID SerPortAddress ) ;

#line 658
typedef void ( *  PSERENUM_WRITEPORT )(PVOID SerPortAddress , UCHAR Value ) ;

#line 665
typedef enum _SERENUM_PORTION {
	SerenumFirstHalf,
	SerenumSecondHalf,
	SerenumWhole
} SERENUM_PORTION ;

typedef struct _SERENUM_PORT_PARAMETERS {
	ULONG Size ;
	PSERENUM_READPORT ReadAccessor ;
	PSERENUM_WRITEPORT WriteAccessor ;
	PVOID SerPortAddress ;
	PVOID HardwareHandle ;
	SERENUM_PORTION Portion ;
	USHORT NumberAxis ;
	USHORT Reserved[3] ;
} SERENUM_PORT_PARAMETERS , *  PSERENUM_PORT_PARAMETERS ;

#line 28 "C:/NTDDK/inc/ddk/wdm/wmilib.h"

#pragma once
#line 38
typedef struct  {
	LPCGUID Guid ;
	ULONG InstanceCount ;
	ULONG Flags ;
} WMIGUIDREGINFO , *  PWMIGUIDREGINFO ;

#line 45
typedef NTSTATUS ( *  PWMI_QUERY_REGINFO )(PDEVICE_OBJECT DeviceObject , PULONG
	RegFlags , PUNICODE_STRING InstanceName , PUNICODE_STRING * 
	RegistryPath , PUNICODE_STRING MofResourceName , PDEVICE_OBJECT *  Pdo )
	;

#line 101
typedef NTSTATUS ( *  PWMI_QUERY_DATABLOCK )(PDEVICE_OBJECT DeviceObject , PIRP
	Irp , ULONG GuidIndex , ULONG InstanceIndex , ULONG InstanceCount ,
	PULONG InstanceLengthArray , ULONG BufferAvail , PUCHAR Buffer ) ;

#line 162
typedef NTSTATUS ( *  PWMI_SET_DATABLOCK )(PDEVICE_OBJECT DeviceObject , PIRP
	Irp , ULONG GuidIndex , ULONG InstanceIndex , ULONG BufferSize , PUCHAR
	Buffer ) ;

#line 206
typedef NTSTATUS ( *  PWMI_SET_DATAITEM )(PDEVICE_OBJECT DeviceObject , PIRP Irp
	, ULONG GuidIndex , ULONG InstanceIndex , ULONG DataItemId , ULONG
	BufferSize , PUCHAR Buffer ) ;

#line 253
typedef NTSTATUS ( *  PWMI_EXECUTE_METHOD )(PDEVICE_OBJECT DeviceObject , PIRP
	Irp , ULONG GuidIndex , ULONG InstanceIndex , ULONG MethodId , ULONG
	InBufferSize , ULONG OutBufferSize , PUCHAR Buffer ) ;

#line 306
typedef enum  {
	WmiEventControl,
	WmiDataBlockControl
} WMIENABLEDISABLECONTROL ;

#line 312
typedef NTSTATUS ( *  PWMI_FUNCTION_CONTROL )(PDEVICE_OBJECT DeviceObject , PIRP
	Irp , ULONG GuidIndex , WMIENABLEDISABLECONTROL Function , BOOLEAN
	Enable ) ;

#line 355
typedef struct _WMILIB_CONTEXT {
	ULONG GuidCount ;
	PWMIGUIDREGINFO GuidList ;
	PWMI_QUERY_REGINFO QueryWmiRegInfo ;
	PWMI_QUERY_DATABLOCK QueryWmiDataBlock ;
	PWMI_SET_DATABLOCK SetWmiDataBlock ;
	PWMI_SET_DATAITEM SetWmiDataItem ;
	PWMI_EXECUTE_METHOD ExecuteWmiMethod ;
	PWMI_FUNCTION_CONTROL WmiFunctionControl ;
} WMILIB_CONTEXT , *  PWMILIB_CONTEXT ;

#line 372
NTSTATUS WmiCompleteRequest(PDEVICE_OBJECT DeviceObject , PIRP Irp , NTSTATUS
	Status , ULONG BufferUsed , CCHAR PriorityBoost ) ;

#line 411
typedef enum  {
	IrpProcessed,
	IrpNotCompleted,
	IrpNotWmi,
	IrpForward
} SYSCTL_IRP_DISPOSITION , *  PSYSCTL_IRP_DISPOSITION ;

#line 420
NTSTATUS WmiSystemControl(PWMILIB_CONTEXT WmiLibInfo , PDEVICE_OBJECT
	DeviceObject , PIRP Irp , PSYSCTL_IRP_DISPOSITION IrpDisposition ) ;
#line 453
NTSTATUS WmiFireEvent(PDEVICE_OBJECT DeviceObject , LPGUID Guid , ULONG
	InstanceIndex , ULONG EventDataSize , PVOID EventData ) ;
#line 10 "C:/NTDDK/inc/wmidata.h"
extern const GUID MSWmi_MofData_GUID ;

#line 13
typedef struct _MSWmi_MofData {
	ULONG Unused1 ;
	ULONG Unused2 ;
	ULONG Size ;
	ULONG Unused4 ;
	UCHAR BinaryMofData[1] ;
} MSWmi_MofData , *  PMSWmi_MofData ;

#line 47
extern const GUID MSWmi_ProviderInfo_GUID ;

#line 51
typedef struct _MSWmi_ProviderInfo {
	char VariableData[1] ;
} MSWmi_ProviderInfo , *  PMSWmi_ProviderInfo ;

#line 63
extern const GUID MSWmi_PnPDeviceId_GUID ;

#line 66
typedef struct _MSWmi_PnPDeviceId {
	CHAR VariableData[1] ;
} MSWmi_PnPDeviceId , *  PMSWmi_PnPDeviceId ;

#line 80
extern const GUID MSWmi_PnPInstanceNames_GUID ;

#line 83
typedef struct _MSWmi_PnPInstanceNames {
	ULONG Count ;
	WCHAR InstanceNameList[1] ;
} MSWmi_PnPInstanceNames , *  PMSWmi_PnPInstanceNames ;

#line 102
extern const GUID MSSmBios_RawSMBiosTables_GUID ;

#line 105
typedef struct _MSSmBios_RawSMBiosTables {
	BOOLEAN Used20CallingMethod ;
	UCHAR SmbiosMajorVersion ;
	UCHAR SmbiosMinorVersion ;
	UCHAR DmiRevision ;
	ULONG Size ;
	UCHAR SMBiosData[1] ;
} MSSmBios_RawSMBiosTables , *  PMSSmBios_RawSMBiosTables ;

#line 144
extern const GUID MSPower_DeviceEnable_GUID ;

#line 147
typedef struct _MSPower_DeviceEnable {
	BOOLEAN Enable ;
} MSPower_DeviceEnable , *  PMSPower_DeviceEnable ;

#line 162
extern const GUID MSPower_DeviceWakeEnable_GUID ;

#line 165
typedef struct _MSPower_DeviceWakeEnable {
	BOOLEAN Enable ;
} MSPower_DeviceWakeEnable , *  PMSPower_DeviceWakeEnable ;

#line 179
extern const GUID MSNdis_NetworkAddress_GUID ;

#line 182
typedef struct _MSNdis_NetworkAddress {
	UCHAR Address[6] ;
} MSNdis_NetworkAddress , *  PMSNdis_NetworkAddress ;

#line 196
extern const GUID MSNdis_NetworkShortAddress_GUID ;

#line 199
typedef struct _MSNdis_NetworkShortAddress {
	UCHAR Address[2] ;
} MSNdis_NetworkShortAddress , *  PMSNdis_NetworkShortAddress ;

#line 213
extern const GUID MSNdis_NetworkLinkSpeed_GUID ;

#line 216
typedef struct _MSNdis_NetworkLinkSpeed {
	ULONG Outbound ;
	ULONG Inbound ;
} MSNdis_NetworkLinkSpeed , *  PMSNdis_NetworkLinkSpeed ;

#line 236
extern const GUID MSNdis_EnumerateAdapter_GUID ;

#line 239
typedef struct _MSNdis_EnumerateAdapter {
	CHAR VariableData[1] ;
} MSNdis_EnumerateAdapter , *  PMSNdis_EnumerateAdapter ;

#line 253
extern const GUID MSNdis_NotifyAdapterRemoval_GUID ;

#line 256
typedef struct _MSNdis_NotifyAdapterRemoval {
	CHAR VariableData[1] ;
} MSNdis_NotifyAdapterRemoval , *  PMSNdis_NotifyAdapterRemoval ;

#line 270
extern const GUID MSNdis_NotifyAdapterArrival_GUID ;

#line 273
typedef struct _MSNdis_NotifyAdapterArrival {
	CHAR VariableData[1] ;
} MSNdis_NotifyAdapterArrival , *  PMSNdis_NotifyAdapterArrival ;

#line 287
extern const GUID MSNdis_NdisEnumerateVc_GUID ;

#line 291
typedef struct _MSNdis_NdisEnumerateVc {
	char VariableData[1] ;
} MSNdis_NdisEnumerateVc , *  PMSNdis_NdisEnumerateVc ;

#line 303
extern const GUID MSNdis_NotifyVcRemoval_GUID ;

#line 307
typedef struct _MSNdis_NotifyVcRemoval {
	char VariableData[1] ;
} MSNdis_NotifyVcRemoval , *  PMSNdis_NotifyVcRemoval ;

#line 319
extern const GUID MSNdis_NotifyVcArrival_GUID ;

#line 323
typedef struct _MSNdis_NotifyVcArrival {
	char VariableData[1] ;
} MSNdis_NotifyVcArrival , *  PMSNdis_NotifyVcArrival ;

#line 335
extern const GUID MSNdis_HardwareStatus_GUID ;

#line 338
typedef struct _MSNdis_HardwareStatus {
	ULONG NdisHardwareStatus ;
} MSNdis_HardwareStatus , *  PMSNdis_HardwareStatus ;

#line 353
extern const GUID MSNdis_MediaSupported_GUID ;

#line 356
typedef struct _MSNdis_MediaSupported {
	ULONG NumberElements ;
	ULONG NdisMediaSupported[1] ;
} MSNdis_MediaSupported , *  PMSNdis_MediaSupported ;

#line 375
extern const GUID MSNdis_MediaInUse_GUID ;

#line 378
typedef struct _MSNdis_MediaInUse {
	ULONG NumberElements ;
	ULONG NdisMediaInUse[1] ;
} MSNdis_MediaInUse , *  PMSNdis_MediaInUse ;

#line 397
extern const GUID MSNdis_MaximumLookahead_GUID ;

#line 400
typedef struct _MSNdis_MaximumLookahead {
	ULONG NdisMaximumLookahead ;
} MSNdis_MaximumLookahead , *  PMSNdis_MaximumLookahead ;

#line 415
extern const GUID MSNdis_MaximumFrameSize_GUID ;

#line 418
typedef struct _MSNdis_MaximumFrameSize {
	ULONG NdisMaximumFrameSize ;
} MSNdis_MaximumFrameSize , *  PMSNdis_MaximumFrameSize ;

#line 433
extern const GUID MSNdis_LinkSpeed_GUID ;

#line 436
typedef struct _MSNdis_LinkSpeed {
	ULONG NdisLinkSpeed ;
} MSNdis_LinkSpeed , *  PMSNdis_LinkSpeed ;

#line 451
extern const GUID MSNdis_TransmitBufferSpace_GUID ;

#line 454
typedef struct _MSNdis_TransmitBufferSpace {
	ULONG NdisTransmitBufferSpace ;
} MSNdis_TransmitBufferSpace , *  PMSNdis_TransmitBufferSpace ;

#line 469
extern const GUID MSNdis_ReceiveBufferSpace_GUID ;

#line 472
typedef struct _MSNdis_ReceiveBufferSpace {
	ULONG NdisReceiveBufferSpace ;
} MSNdis_ReceiveBufferSpace , *  PMSNdis_ReceiveBufferSpace ;

#line 487
extern const GUID MSNdis_TransmitBlockSize_GUID ;

#line 490
typedef struct _MSNdis_TransmitBlockSize {
	ULONG NdisTransmitBlockSize ;
} MSNdis_TransmitBlockSize , *  PMSNdis_TransmitBlockSize ;

#line 505
extern const GUID MSNdis_ReceiveBlockSize_GUID ;

#line 508
typedef struct _MSNdis_ReceiveBlockSize {
	ULONG NdisReceiveBlockSize ;
} MSNdis_ReceiveBlockSize , *  PMSNdis_ReceiveBlockSize ;

#line 523
extern const GUID MSNdis_VendorID_GUID ;

#line 526
typedef struct _MSNdis_VendorID {
	ULONG NdisVendorID ;
} MSNdis_VendorID , *  PMSNdis_VendorID ;

#line 541
extern const GUID MSNdis_VendorDescription_GUID ;

#line 544
typedef struct _MSNdis_VendorDescription {
	CHAR VariableData[1] ;
} MSNdis_VendorDescription , *  PMSNdis_VendorDescription ;

#line 558
extern const GUID MSNdis_CurrentPacketFilter_GUID ;

#line 561
typedef struct _MSNdis_CurrentPacketFilter {
	ULONG NdisCurrentPacketFilter ;
} MSNdis_CurrentPacketFilter , *  PMSNdis_CurrentPacketFilter ;

#line 576
extern const GUID MSNdis_CurrentLookahead_GUID ;

#line 579
typedef struct _MSNdis_CurrentLookahead {
	ULONG NdisCurrentLookahead ;
} MSNdis_CurrentLookahead , *  PMSNdis_CurrentLookahead ;

#line 594
extern const GUID MSNdis_DriverVersion_GUID ;

#line 597
typedef struct _MSNdis_DriverVersion {
	USHORT NdisDriverVersion ;
} MSNdis_DriverVersion , *  PMSNdis_DriverVersion ;

#line 612
extern const GUID MSNdis_MaximumTotalSize_GUID ;

#line 615
typedef struct _MSNdis_MaximumTotalSize {
	ULONG NdisMaximumTotalSize ;
} MSNdis_MaximumTotalSize , *  PMSNdis_MaximumTotalSize ;

#line 630
extern const GUID MSNdis_MacOptions_GUID ;

#line 633
typedef struct _MSNdis_MacOptions {
	ULONG NdisMacOptions ;
} MSNdis_MacOptions , *  PMSNdis_MacOptions ;

#line 648
extern const GUID MSNdis_MediaConnectStatus_GUID ;

#line 651
typedef struct _MSNdis_MediaConnectStatus {
	ULONG NdisMediaConnectStatus ;
} MSNdis_MediaConnectStatus , *  PMSNdis_MediaConnectStatus ;

#line 666
extern const GUID MSNdis_MaximumSendPackets_GUID ;

#line 669
typedef struct _MSNdis_MaximumSendPackets {
	ULONG NdisMaximumSendPackets ;
} MSNdis_MaximumSendPackets , *  PMSNdis_MaximumSendPackets ;

#line 684
extern const GUID MSNdis_VendorDriverVersion_GUID ;

#line 687
typedef struct _MSNdis_VendorDriverVersion {
	ULONG NdisVendorDriverVersion ;
} MSNdis_VendorDriverVersion , *  PMSNdis_VendorDriverVersion ;

#line 702
extern const GUID MSNdis_TransmitsOk_GUID ;

#line 705
typedef struct _MSNdis_TransmitsOk {
	ULONG NdisTransmitsOk ;
} MSNdis_TransmitsOk , *  PMSNdis_TransmitsOk ;

#line 720
extern const GUID MSNdis_ReceivesOk_GUID ;

#line 723
typedef struct _MSNdis_ReceivesOk {
	ULONG NdisReceivesOk ;
} MSNdis_ReceivesOk , *  PMSNdis_ReceivesOk ;

#line 738
extern const GUID MSNdis_TransmitsError_GUID ;

#line 741
typedef struct _MSNdis_TransmitsError {
	ULONG NdisTransmitsError ;
} MSNdis_TransmitsError , *  PMSNdis_TransmitsError ;

#line 756
extern const GUID MSNdis_ReceiveError_GUID ;

#line 759
typedef struct _MSNdis_ReceiveError {
	ULONG NdisReceiveError ;
} MSNdis_ReceiveError , *  PMSNdis_ReceiveError ;

#line 774
extern const GUID MSNdis_ReceiveNoBuffer_GUID ;

#line 777
typedef struct _MSNdis_ReceiveNoBuffer {
	ULONG NdisReceiveNoBuffer ;
} MSNdis_ReceiveNoBuffer , *  PMSNdis_ReceiveNoBuffer ;

#line 792
extern const GUID MSNdis_CoHardwareStatus_GUID ;

#line 795
typedef struct _MSNdis_CoHardwareStatus {
	ULONG NdisCoHardwareStatus ;
} MSNdis_CoHardwareStatus , *  PMSNdis_CoHardwareStatus ;

#line 810
extern const GUID MSNdis_CoMediaSupported_GUID ;

#line 813
typedef struct _MSNdis_CoMediaSupported {
	ULONG NumberElements ;
	ULONG NdisCoMediaSupported[1] ;
} MSNdis_CoMediaSupported , *  PMSNdis_CoMediaSupported ;

#line 832
extern const GUID MSNdis_CoMediaInUse_GUID ;

#line 835
typedef struct _MSNdis_CoMediaInUse {
	ULONG NumberElements ;
	ULONG NdisCoMediaInUse[1] ;
} MSNdis_CoMediaInUse , *  PMSNdis_CoMediaInUse ;

#line 854
extern const GUID MSNdis_CoLinkSpeed_GUID ;

#line 857
typedef struct _MSNdis_CoLinkSpeed {
	MSNdis_NetworkLinkSpeed NdisCoLinkSpeed ;
} MSNdis_CoLinkSpeed , *  PMSNdis_CoLinkSpeed ;

#line 872
extern const GUID MSNdis_CoVendorId_GUID ;

#line 875
typedef struct _MSNdis_CoVendorId {
	ULONG NdisCoVendorID ;
} MSNdis_CoVendorId , *  PMSNdis_CoVendorId ;

#line 890
extern const GUID MSNdis_CoVendorDescription_GUID ;

#line 893
typedef struct _MSNdis_CoVendorDescription {
	CHAR VariableData[1] ;
} MSNdis_CoVendorDescription , *  PMSNdis_CoVendorDescription ;

#line 907
extern const GUID MSNdis_CoDriverVersion_GUID ;

#line 910
typedef struct _MSNdis_CoDriverVersion {
	USHORT NdisCoDriverVersion ;
} MSNdis_CoDriverVersion , *  PMSNdis_CoDriverVersion ;

#line 925
extern const GUID MSNdis_CoMacOptions_GUID ;

#line 928
typedef struct _MSNdis_CoMacOptions {
	ULONG NdisCoMacOptions ;
} MSNdis_CoMacOptions , *  PMSNdis_CoMacOptions ;

#line 943
extern const GUID MSNdis_CoMediaConnectStatus_GUID ;

#line 946
typedef struct _MSNdis_CoMediaConnectStatus {
	ULONG NdisCoMediaConnectStatus ;
} MSNdis_CoMediaConnectStatus , *  PMSNdis_CoMediaConnectStatus ;

#line 961
extern const GUID MSNdis_CoVendorDriverVersion_GUID ;

#line 964
typedef struct _MSNdis_CoVendorDriverVersion {
	ULONG NdisCoVendorDriverVersion ;
} MSNdis_CoVendorDriverVersion , *  PMSNdis_CoVendorDriverVersion ;

#line 979
extern const GUID MSNdis_CoMinimumLinkSpeed_GUID ;

#line 982
typedef struct _MSNdis_CoMinimumLinkSpeed {
	MSNdis_NetworkLinkSpeed NdisCoMinimumLinkSpeed ;
} MSNdis_CoMinimumLinkSpeed , *  PMSNdis_CoMinimumLinkSpeed ;

#line 997
extern const GUID MSNdis_CoTransmitPdusOk_GUID ;

#line 1000
typedef struct _MSNdis_CoTransmitPdusOk {
	ULONG NdisCoTransmitPdusOk ;
} MSNdis_CoTransmitPdusOk , *  PMSNdis_CoTransmitPdusOk ;

#line 1015
extern const GUID MSNdis_CoReceivePdusOk_GUID ;

#line 1018
typedef struct _MSNdis_CoReceivePdusOk {
	ULONG NdisCoReceivePdusOk ;
} MSNdis_CoReceivePdusOk , *  PMSNdis_CoReceivePdusOk ;

#line 1033
extern const GUID MSNdis_CoTransmitPduErrors_GUID ;

#line 1036
typedef struct _MSNdis_CoTransmitPduErrors {
	ULONG NdisCoTransmitPduErrors ;
} MSNdis_CoTransmitPduErrors , *  PMSNdis_CoTransmitPduErrors ;

#line 1051
extern const GUID MSNdis_CoReceivePduErrors_GUID ;

#line 1054
typedef struct _MSNdis_CoReceivePduErrors {
	ULONG NdisCoReceivePduErrors ;
} MSNdis_CoReceivePduErrors , *  PMSNdis_CoReceivePduErrors ;

#line 1069
extern const GUID MSNdis_CoReceivePdusNoBuffer_GUID ;

#line 1072
typedef struct _MSNdis_CoReceivePdusNoBuffer {
	ULONG NdisCoReceivePdusNoBuffer ;
} MSNdis_CoReceivePdusNoBuffer , *  PMSNdis_CoReceivePdusNoBuffer ;

#line 1087
extern const GUID MSNdis_AtmSupportedVcRates_GUID ;

#line 1090
typedef struct _MSNdis_AtmSupportedVcRates {
	ULONG MinCellRate ;
	ULONG MaxCellRate ;
} MSNdis_AtmSupportedVcRates , *  PMSNdis_AtmSupportedVcRates ;

#line 1110
extern const GUID MSNdis_AtmSupportedServiceCategory_GUID ;

#line 1113
typedef struct _MSNdis_AtmSupportedServiceCategory {
	ULONG NdisAtmSupportedServiceCategory ;
} MSNdis_AtmSupportedServiceCategory , *  PMSNdis_AtmSupportedServiceCategory ;

#line 1128
extern const GUID MSNdis_AtmSupportedAalTypes_GUID ;

#line 1131
typedef struct _MSNdis_AtmSupportedAalTypes {
	ULONG NdisAtmSupportedAalTypes ;
} MSNdis_AtmSupportedAalTypes , *  PMSNdis_AtmSupportedAalTypes ;

#line 1146
extern const GUID MSNdis_AtmHardwareCurrentAddress_GUID ;

#line 1149
typedef struct _MSNdis_AtmHardwareCurrentAddress {
	MSNdis_NetworkAddress NdisAtmHardwareCurrentAddress ;
} MSNdis_AtmHardwareCurrentAddress , *  PMSNdis_AtmHardwareCurrentAddress ;

#line 1164
extern const GUID MSNdis_AtmMaxActiveVcs_GUID ;

#line 1167
typedef struct _MSNdis_AtmMaxActiveVcs {
	ULONG NdisAtmMaxActiveVcs ;
} MSNdis_AtmMaxActiveVcs , *  PMSNdis_AtmMaxActiveVcs ;

#line 1182
extern const GUID MSNdis_AtmMaxActiveVciBits_GUID ;

#line 1185
typedef struct _MSNdis_AtmMaxActiveVciBits {
	ULONG NdisAtmMaxActiveVciBits ;
} MSNdis_AtmMaxActiveVciBits , *  PMSNdis_AtmMaxActiveVciBits ;

#line 1200
extern const GUID MSNdis_AtmMaxActiveVpiBits_GUID ;

#line 1203
typedef struct _MSNdis_AtmMaxActiveVpiBits {
	ULONG NdisAtmMaxActiveVpiBits ;
} MSNdis_AtmMaxActiveVpiBits , *  PMSNdis_AtmMaxActiveVpiBits ;

#line 1218
extern const GUID MSNdis_AtmMaxAal0PacketSize_GUID ;

#line 1221
typedef struct _MSNdis_AtmMaxAal0PacketSize {
	ULONG NdisAtmMaxAal0PacketSize ;
} MSNdis_AtmMaxAal0PacketSize , *  PMSNdis_AtmMaxAal0PacketSize ;

#line 1236
extern const GUID MSNdis_AtmMaxAal1PacketSize_GUID ;

#line 1239
typedef struct _MSNdis_AtmMaxAal1PacketSize {
	ULONG NdisAtmMaxAal1PacketSize ;
} MSNdis_AtmMaxAal1PacketSize , *  PMSNdis_AtmMaxAal1PacketSize ;

#line 1254
extern const GUID MSNdis_AtmMaxAal34PacketSize_GUID ;

#line 1257
typedef struct _MSNdis_AtmMaxAal34PacketSize {
	ULONG NdisAtmMaxAal34PacketSize ;
} MSNdis_AtmMaxAal34PacketSize , *  PMSNdis_AtmMaxAal34PacketSize ;

#line 1272
extern const GUID MSNdis_AtmMaxAal5PacketSize_GUID ;

#line 1275
typedef struct _MSNdis_AtmMaxAal5PacketSize {
	ULONG NdisAtmMaxAal5PacketSize ;
} MSNdis_AtmMaxAal5PacketSize , *  PMSNdis_AtmMaxAal5PacketSize ;

#line 1290
extern const GUID MSNdis_AtmReceiveCellsOk_GUID ;

#line 1293
typedef struct _MSNdis_AtmReceiveCellsOk {
	ULONGLONG NdisAtmReceiveCellsOk ;
} MSNdis_AtmReceiveCellsOk , *  PMSNdis_AtmReceiveCellsOk ;

#line 1308
extern const GUID MSNdis_AtmTransmitCellsOk_GUID ;

#line 1311
typedef struct _MSNdis_AtmTransmitCellsOk {
	ULONGLONG NdisAtmTransmitCellsOk ;
} MSNdis_AtmTransmitCellsOk , *  PMSNdis_AtmTransmitCellsOk ;

#line 1326
extern const GUID MSNdis_AtmReceiveCellsDropped_GUID ;

#line 1329
typedef struct _MSNdis_AtmReceiveCellsDropped {
	ULONGLONG NdisAtmReceiveCellsDropped ;
} MSNdis_AtmReceiveCellsDropped , *  PMSNdis_AtmReceiveCellsDropped ;

#line 1344
extern const GUID MSNdis_EthernetPermanentAddress_GUID ;

#line 1347
typedef struct _MSNdis_EthernetPermanentAddress {
	MSNdis_NetworkAddress NdisPermanentAddress ;
} MSNdis_EthernetPermanentAddress , *  PMSNdis_EthernetPermanentAddress ;

#line 1362
extern const GUID MSNdis_EthernetCurrentAddress_GUID ;

#line 1365
typedef struct _MSNdis_EthernetCurrentAddress {
	MSNdis_NetworkAddress NdisCurrentAddress ;
} MSNdis_EthernetCurrentAddress , *  PMSNdis_EthernetCurrentAddress ;

#line 1380
extern const GUID MSNdis_EthernetMulticastList_GUID ;

#line 1383
typedef struct _MSNdis_EthernetMulticastList {
	ULONG NumberElements ;
	MSNdis_NetworkAddress NdisMulticastList[1] ;
} MSNdis_EthernetMulticastList , *  PMSNdis_EthernetMulticastList ;

#line 1402
extern const GUID MSNdis_EthernetMaximumMulticastListSize_GUID ;

#line 1405
typedef struct _MSNdis_EthernetMaximumMulticastListSize {
	ULONG NdisEthernetMaximumMulticastListSize ;
} MSNdis_EthernetMaximumMulticastListSize , * 
	PMSNdis_EthernetMaximumMulticastListSize ;

#line 1420
extern const GUID MSNdis_EthernetMacOptions_GUID ;

#line 1423
typedef struct _MSNdis_EthernetMacOptions {
	ULONG NdisEthernetMacOptions ;
} MSNdis_EthernetMacOptions , *  PMSNdis_EthernetMacOptions ;

#line 1438
extern const GUID MSNdis_EthernetReceiveErrorAlignment_GUID ;

#line 1441
typedef struct _MSNdis_EthernetReceiveErrorAlignment {
	ULONG NdisEthernetReceiveErrorAlignment ;
} MSNdis_EthernetReceiveErrorAlignment , * 
	PMSNdis_EthernetReceiveErrorAlignment ;

#line 1456
extern const GUID MSNdis_EthernetOneTransmitCollision_GUID ;

#line 1459
typedef struct _MSNdis_EthernetOneTransmitCollision {
	ULONG NdisEthernetOneTransmitCollision ;
} MSNdis_EthernetOneTransmitCollision , *  PMSNdis_EthernetOneTransmitCollision
	;

#line 1474
extern const GUID MSNdis_EthernetMoreTransmitCollisions_GUID ;

#line 1477
typedef struct _MSNdis_EthernetMoreTransmitCollisions {
	ULONG NdisEthernetMoreTransmitCollisions ;
} MSNdis_EthernetMoreTransmitCollisions , * 
	PMSNdis_EthernetMoreTransmitCollisions ;

#line 1492
extern const GUID MSNdis_TokenRingPermanentAddress_GUID ;

#line 1495
typedef struct _MSNdis_TokenRingPermanentAddress {
	MSNdis_NetworkAddress NdisPermanentAddress ;
} MSNdis_TokenRingPermanentAddress , *  PMSNdis_TokenRingPermanentAddress ;

#line 1510
extern const GUID MSNdis_TokenRingCurrentAddress_GUID ;

#line 1513
typedef struct _MSNdis_TokenRingCurrentAddress {
	MSNdis_NetworkAddress NdisCurrentAddress ;
} MSNdis_TokenRingCurrentAddress , *  PMSNdis_TokenRingCurrentAddress ;

#line 1528
extern const GUID MSNdis_TokenRingCurrentFunctional_GUID ;

#line 1531
typedef struct _MSNdis_TokenRingCurrentFunctional {
	ULONG NdisTokenRingCurrentFunctional ;
} MSNdis_TokenRingCurrentFunctional , *  PMSNdis_TokenRingCurrentFunctional ;

#line 1546
extern const GUID MSNdis_TokenRingCurrentGroup_GUID ;

#line 1549
typedef struct _MSNdis_TokenRingCurrentGroup {
	ULONG NdisTokenRingCurrentGroup ;
} MSNdis_TokenRingCurrentGroup , *  PMSNdis_TokenRingCurrentGroup ;

#line 1564
extern const GUID MSNdis_TokenRingLastOpenStatus_GUID ;

#line 1567
typedef struct _MSNdis_TokenRingLastOpenStatus {
	ULONG NdisTokenRingLastOpenStatus ;
} MSNdis_TokenRingLastOpenStatus , *  PMSNdis_TokenRingLastOpenStatus ;

#line 1582
extern const GUID MSNdis_TokenRingCurrentRingStatus_GUID ;

#line 1585
typedef struct _MSNdis_TokenRingCurrentRingStatus {
	ULONG NdisTokenRingCurrentRingStatus ;
} MSNdis_TokenRingCurrentRingStatus , *  PMSNdis_TokenRingCurrentRingStatus ;

#line 1600
extern const GUID MSNdis_TokenRingCurrentRingState_GUID ;

#line 1603
typedef struct _MSNdis_TokenRingCurrentRingState {
	ULONG NdisTokenRingCurrentRingState ;
} MSNdis_TokenRingCurrentRingState , *  PMSNdis_TokenRingCurrentRingState ;

#line 1618
extern const GUID MSNdis_TokenRingLineErrors_GUID ;

#line 1621
typedef struct _MSNdis_TokenRingLineErrors {
	ULONG NdisTokenRingLineErrors ;
} MSNdis_TokenRingLineErrors , *  PMSNdis_TokenRingLineErrors ;

#line 1636
extern const GUID MSNdis_TokenRingLostFrames_GUID ;

#line 1639
typedef struct _MSNdis_TokenRingLostFrames {
	ULONG NdisTokenRingLostFrames ;
} MSNdis_TokenRingLostFrames , *  PMSNdis_TokenRingLostFrames ;

#line 1654
extern const GUID MSNdis_FddiLongPermanentAddress_GUID ;

#line 1657
typedef struct _MSNdis_FddiLongPermanentAddress {
	MSNdis_NetworkAddress NdisPermanentAddress ;
} MSNdis_FddiLongPermanentAddress , *  PMSNdis_FddiLongPermanentAddress ;

#line 1672
extern const GUID MSNdis_FddiLongCurrentAddress_GUID ;

#line 1675
typedef struct _MSNdis_FddiLongCurrentAddress {
	MSNdis_NetworkAddress NdisCurrentAddress ;
} MSNdis_FddiLongCurrentAddress , *  PMSNdis_FddiLongCurrentAddress ;

#line 1690
extern const GUID MSNdis_FddiLongMulticastList_GUID ;

#line 1693
typedef struct _MSNdis_FddiLongMulticastList {
	ULONG NumberElements ;
	MSNdis_NetworkAddress NdisMulticastList[1] ;
} MSNdis_FddiLongMulticastList , *  PMSNdis_FddiLongMulticastList ;

#line 1712
extern const GUID MSNdis_FddiLongMaximumListSize_GUID ;

#line 1715
typedef struct _MSNdis_FddiLongMaximumListSize {
	ULONG NdisFddiLongMaximumListSize ;
} MSNdis_FddiLongMaximumListSize , *  PMSNdis_FddiLongMaximumListSize ;

#line 1730
extern const GUID MSNdis_FddiShortPermanentAddress_GUID ;

#line 1733
typedef struct _MSNdis_FddiShortPermanentAddress {
	MSNdis_NetworkShortAddress NdisPermanentAddress ;
} MSNdis_FddiShortPermanentAddress , *  PMSNdis_FddiShortPermanentAddress ;

#line 1748
extern const GUID MSNdis_FddiShortCurrentAddress_GUID ;

#line 1751
typedef struct _MSNdis_FddiShortCurrentAddress {
	MSNdis_NetworkShortAddress NdisCurrentAddress ;
} MSNdis_FddiShortCurrentAddress , *  PMSNdis_FddiShortCurrentAddress ;

#line 1766
extern const GUID MSNdis_FddiShortMulticastList_GUID ;

#line 1769
typedef struct _MSNdis_FddiShortMulticastList {
	ULONG NumberElements ;
	MSNdis_NetworkShortAddress NdisMulticastList[1] ;
} MSNdis_FddiShortMulticastList , *  PMSNdis_FddiShortMulticastList ;

#line 1788
extern const GUID MSNdis_FddiShortMaximumListSize_GUID ;

#line 1791
typedef struct _MSNdis_FddiShortMaximumListSize {
	ULONG NdisFddiShortMaximumListSize ;
} MSNdis_FddiShortMaximumListSize , *  PMSNdis_FddiShortMaximumListSize ;

#line 1806
extern const GUID MSNdis_FddiAttachmentType_GUID ;

#line 1809
typedef struct _MSNdis_FddiAttachmentType {
	ULONG NdisFddiAttachmentType ;
} MSNdis_FddiAttachmentType , *  PMSNdis_FddiAttachmentType ;

#line 1824
extern const GUID MSNdis_FddiUpstreamNodeLong_GUID ;

#line 1827
typedef struct _MSNdis_FddiUpstreamNodeLong {
	MSNdis_NetworkAddress NdisFddiUpstreamNodeLong ;
} MSNdis_FddiUpstreamNodeLong , *  PMSNdis_FddiUpstreamNodeLong ;

#line 1842
extern const GUID MSNdis_FddiDownstreamNodeLong_GUID ;

#line 1845
typedef struct _MSNdis_FddiDownstreamNodeLong {
	MSNdis_NetworkAddress NdisFddiDownstreamNodeLong ;
} MSNdis_FddiDownstreamNodeLong , *  PMSNdis_FddiDownstreamNodeLong ;

#line 1860
extern const GUID MSNdis_FddiFrameErrors_GUID ;

#line 1863
typedef struct _MSNdis_FddiFrameErrors {
	ULONG NdisFddiFrameErrors ;
} MSNdis_FddiFrameErrors , *  PMSNdis_FddiFrameErrors ;

#line 1878
extern const GUID MSNdis_FddiFramesLost_GUID ;

#line 1881
typedef struct _MSNdis_FddiFramesLost {
	ULONG NdisFddiFramesLost ;
} MSNdis_FddiFramesLost , *  PMSNdis_FddiFramesLost ;

#line 1896
extern const GUID MSNdis_FddiRingManagmentState_GUID ;

#line 1899
typedef struct _MSNdis_FddiRingManagmentState {
	ULONG NdisFddiRingManagmentState ;
} MSNdis_FddiRingManagmentState , *  PMSNdis_FddiRingManagmentState ;

#line 1914
extern const GUID MSNdis_FddiLctFailures_GUID ;

#line 1917
typedef struct _MSNdis_FddiLctFailures {
	ULONG NdisFddiLctFailures ;
} MSNdis_FddiLctFailures , *  PMSNdis_FddiLctFailures ;

#line 1932
extern const GUID MSNdis_FddiLemRejects_GUID ;

#line 1935
typedef struct _MSNdis_FddiLemRejects {
	ULONG NdisFddiLemRejects ;
} MSNdis_FddiLemRejects , *  PMSNdis_FddiLemRejects ;

#line 1950
extern const GUID MSNdis_FddiLConnectionState_GUID ;

#line 1953
typedef struct _MSNdis_FddiLConnectionState {
	ULONG NdisFddiLConnectionState ;
} MSNdis_FddiLConnectionState , *  PMSNdis_FddiLConnectionState ;

#line 1968
extern const GUID MSNdis_StatusResetStart_GUID ;

#line 1972
typedef struct _MSNdis_StatusResetStart {
	char VariableData[1] ;
} MSNdis_StatusResetStart , *  PMSNdis_StatusResetStart ;

#line 1984
extern const GUID MSNdis_StatusResetEnd_GUID ;

#line 1988
typedef struct _MSNdis_StatusResetEnd {
	char VariableData[1] ;
} MSNdis_StatusResetEnd , *  PMSNdis_StatusResetEnd ;

#line 2000
extern const GUID MSNdis_StatusMediaConnect_GUID ;

#line 2004
typedef struct _MSNdis_StatusMediaConnect {
	char VariableData[1] ;
} MSNdis_StatusMediaConnect , *  PMSNdis_StatusMediaConnect ;

#line 2016
extern const GUID MSNdis_StatusMediaDisconnect_GUID ;

#line 2020
typedef struct _MSNdis_StatusMediaDisconnect {
	char VariableData[1] ;
} MSNdis_StatusMediaDisconnect , *  PMSNdis_StatusMediaDisconnect ;

#line 2032
extern const GUID MSNdis_StatusMediaSpecificIndication_GUID ;

#line 2035
typedef struct _MSNdis_StatusMediaSpecificIndication {
	ULONG NumberElements ;
	UCHAR NdisStatusMediaSpecificIndication[1] ;
} MSNdis_StatusMediaSpecificIndication , * 
	PMSNdis_StatusMediaSpecificIndication ;

#line 2054
extern const GUID MSNdis_StatusLinkSpeedChange_GUID ;

#line 2057
typedef struct _MSNdis_StatusLinkSpeedChange {
	MSNdis_NetworkLinkSpeed NdisStatusLinkSpeedChange ;
} MSNdis_StatusLinkSpeedChange , *  PMSNdis_StatusLinkSpeedChange ;

#line 2072
extern const GUID MSNdis_StatusProtocolBind_GUID ;

#line 2075
typedef struct _MSNdis_StatusProtocolBind {
	CHAR VariableData[1] ;
} MSNdis_StatusProtocolBind , *  PMSNdis_StatusProtocolBind ;

#line 2089
extern const GUID MSNdis_StatusProtocolUnbind_GUID ;

#line 2092
typedef struct _MSNdis_StatusProtocolUnbind {
	CHAR VariableData[1] ;
} MSNdis_StatusProtocolUnbind , *  PMSNdis_StatusProtocolUnbind ;

#line 2106
extern const GUID MSKeyboard_PortInformation_GUID ;

#line 2109
typedef struct _KEYBOARD_PORT_WMI_STD_DATA {
	ULONG ConnectorType ;
	ULONG DataQueueSize ;
	ULONG ErrorCount ;
	ULONG FunctionKeys ;
	ULONG Indicators ;
} KEYBOARD_PORT_WMI_STD_DATA , *  PKEYBOARD_PORT_WMI_STD_DATA ;

#line 2149
extern const GUID MSMouse_PortInformation_GUID ;

#line 2152
typedef struct _POINTER_PORT_WMI_STD_DATA {
	ULONG ConnectorType ;
	ULONG DataQueueSize ;
	ULONG ErrorCount ;
	ULONG Buttons ;
	ULONG HardwareType ;
} POINTER_PORT_WMI_STD_DATA , *  PPOINTER_PORT_WMI_STD_DATA ;

#line 2202
extern const GUID MSMouse_ClassInformation_GUID ;

#line 2205
typedef struct _MSMouse_ClassInformation {
	ULONGLONG DeviceId ;
} MSMouse_ClassInformation , *  PMSMouse_ClassInformation ;

#line 2220
extern const GUID MSKeyboard_ClassInformation_GUID ;

#line 2223
typedef struct _MSKeyboard_ClassInformation {
	ULONGLONG DeviceId ;
} MSKeyboard_ClassInformation , *  PMSKeyboard_ClassInformation ;

#line 2238
extern const GUID MSAcpi_ThermalZoneTemperature_GUID ;

#line 2241
typedef struct _MSAcpi_ThermalZoneTemperature {
	ULONG ThermalStamp ;
	ULONG ThermalConstant1 ;
	ULONG ThermalConstant2 ;
	ULONG Reserved ;
	ULONG SamplingPeriod ;
	ULONG CurrentTemperature ;
	ULONG PassiveTripPoint ;
	ULONG CriticalTripPoint ;
	ULONG ActiveTripPointCount ;
	ULONG ActiveTripPoint[10] ;
} MSAcpi_ThermalZoneTemperature , *  PMSAcpi_ThermalZoneTemperature ;

#line 2301
extern const GUID MSDiskDriver_Geometry_GUID ;

#line 2304
typedef struct _WMI_DISK_GEOMETRY {
	LONGLONG Cylinders ;
	ULONG MediaType ;
	ULONG TracksPerCylinder ;
	ULONG SectorsPerTrack ;
	ULONG BytesPerSector ;
} WMI_DISK_GEOMETRY , *  PWMI_DISK_GEOMETRY ;

#line 2339
extern const GUID MSDiskDriver_PerformanceData_GUID ;

#line 2342
typedef struct _WMI_DISK_PERFORMANCE {
	LONGLONG BytesRead ;
	LONGLONG BytesWritten ;
	LONGLONG ReadTime ;
	LONGLONG WriteTime ;
	LONGLONG IdleTime ;
	ULONG ReadCount ;
	ULONG WriteCount ;
	ULONG QueueDepth ;
	ULONG SplitCount ;
	LONGLONG QueryTime ;
	ULONG StorageDeviceNumber ;
	USHORT StorageManagerName[8] ;
} WMI_DISK_PERFORMANCE , *  PWMI_DISK_PERFORMANCE ;

#line 2412
extern const GUID MSDiskDriver_Performance_GUID ;

#line 2415
typedef struct _MSDiskDriver_Performance {
	WMI_DISK_PERFORMANCE PerfData ;
	CHAR VariableData[1] ;
} MSDiskDriver_Performance , *  PMSDiskDriver_Performance ;

#line 2434
extern const GUID MSStorageDriver_FailurePredictStatus_GUID ;

#line 2437
typedef struct _STORAGE_FAILURE_PREDICT_STATUS {
	ULONG Reason ;
	BOOLEAN PredictFailure ;
} STORAGE_FAILURE_PREDICT_STATUS , *  PSTORAGE_FAILURE_PREDICT_STATUS ;

#line 2457
extern const GUID MSStorageDriver_FailurePredictData_GUID ;

#line 2460
typedef struct _STORAGE_FAILURE_PREDICT_DATA {
	ULONG Length ;
	UCHAR VendorSpecific[512] ;
} STORAGE_FAILURE_PREDICT_DATA , *  PSTORAGE_FAILURE_PREDICT_DATA ;

#line 2480
extern const GUID MSStorageDriver_FailurePredictEvent_GUID ;

#line 2483
typedef struct _STORAGE_FAILURE_PREDICT_EVENT {
	ULONG Length ;
	UCHAR VendorSpecific[1] ;
} STORAGE_FAILURE_PREDICT_EVENT , *  PSTORAGE_FAILURE_PREDICT_EVENT ;

#line 2502
extern const GUID MSStorageDriver_FailurePredictFunction_GUID ;

#line 2513
typedef struct _STORAGE_FAILURE_PREDICT_FUNCTION {
	char VariableData[1] ;
} STORAGE_FAILURE_PREDICT_FUNCTION , *  PSTORAGE_FAILURE_PREDICT_FUNCTION ;

#line 2525
extern const GUID MSIde_PortDeviceInfo_GUID ;

#line 2528
typedef struct _MSIde_PortDeviceInfo {
	UCHAR Bus ;
	UCHAR Target ;
	UCHAR Lun ;
} MSIde_PortDeviceInfo , *  PMSIde_PortDeviceInfo ;

#line 2553
extern const GUID MSSerial_PortName_GUID ;

#line 2556
typedef struct _MSSerial_PortName {
	CHAR VariableData[1] ;
} MSSerial_PortName , *  PMSSerial_PortName ;

#line 2570
extern const GUID MSSerial_CommInfo_GUID ;

#line 2573
typedef struct _SERIAL_WMI_COMM_DATA {
	ULONG BaudRate ;
	ULONG BitsPerByte ;
	ULONG Parity ;
	BOOLEAN ParityCheckEnable ;
	ULONG StopBits ;
	ULONG XoffCharacter ;
	ULONG XoffXmitThreshold ;
	ULONG XonCharacter ;
	ULONG XonXmitThreshold ;
	ULONG MaximumBaudRate ;
	ULONG MaximumOutputBufferSize ;
	ULONG MaximumInputBufferSize ;
	BOOLEAN Support16BitMode ;
	BOOLEAN SupportDTRDSR ;
	BOOLEAN SupportIntervalTimeouts ;
	BOOLEAN SupportParityCheck ;
	BOOLEAN SupportRTSCTS ;
	BOOLEAN SupportXonXoff ;
	BOOLEAN SettableBaudRate ;
	BOOLEAN SettableDataBits ;
	BOOLEAN SettableFlowControl ;
	BOOLEAN SettableParity ;
	BOOLEAN SettableParityCheck ;
	BOOLEAN SettableStopBits ;
	BOOLEAN IsBusy ;
} SERIAL_WMI_COMM_DATA , *  PSERIAL_WMI_COMM_DATA ;

#line 2720
extern const GUID MSSerial_HardwareConfiguration_GUID ;

#line 2723
typedef struct _SERIAL_WMI_HW_DATA {
	ULONG IrqNumber ;
	ULONG IrqVector ;
	ULONG IrqLevel ;
	ULONG IrqAffinityMask ;
	ULONG InterruptType ;
	ULONGLONG BaseIOAddress ;
} SERIAL_WMI_HW_DATA , *  PSERIAL_WMI_HW_DATA ;

#line 2767
extern const GUID MSSerial_PerformanceInformation_GUID ;

#line 2770
typedef struct _SERIAL_WMI_PERF_DATA {
	ULONG ReceivedCount ;
	ULONG TransmittedCount ;
	ULONG FrameErrorCount ;
	ULONG SerialOverrunErrorCount ;
	ULONG BufferOverrunErrorCount ;
	ULONG ParityErrorCount ;
} SERIAL_WMI_PERF_DATA , *  PSERIAL_WMI_PERF_DATA ;

#line 2810
extern const GUID MSSerial_CommProperties_GUID ;

#line 2813
typedef struct _SERIAL_WMI_COMMPROP {
	USHORT wPacketLength ;
	USHORT wPacketVersion ;
	ULONG dwServiceMask ;
	ULONG dwReserved1 ;
	ULONG dwMaxTxQueue ;
	ULONG dwMaxRxQueue ;
	ULONG dwMaxBaud ;
	ULONG dwProvSubType ;
	ULONG dwProvCapabilities ;
	ULONG dwSettableParams ;
	ULONG dwSettableBaud ;
	USHORT wSettableData ;
	USHORT wSettableStopParity ;
	ULONG dwCurrentTxQueue ;
	ULONG dwCurrentRxQueue ;
	ULONG dwProvSpec1 ;
	ULONG dwProvSpec2 ;
	ULONG dwProvCharSize ;
	UCHAR wcProvChar[1] ;
} SERIAL_WMI_COMMPROP , *  PSERIAL_WMI_COMMPROP ;

#line 2917
extern const GUID MSParallel_AllocFreeCounts_GUID ;

#line 2920
typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS {
	ULONG PortAllocates ;
	ULONG PortFrees ;
} PARPORT_WMI_ALLOC_FREE_COUNTS , *  PPARPORT_WMI_ALLOC_FREE_COUNTS ;

#line 2940
extern const GUID MSParallel_DeviceBytesTransferred_GUID ;

#line 2943
typedef struct _PARALLEL_WMI_LOG_INFO {
	ULONG Flags1 ;
	ULONG Flags2 ;
	ULONG spare[2] ;
	LONGLONG SppWriteCount ;
	LONGLONG NibbleReadCount ;
	LONGLONG BoundedEcpWriteCount ;
	LONGLONG BoundedEcpReadCount ;
	LONGLONG HwEcpWriteCount ;
	LONGLONG HwEcpReadCount ;
	LONGLONG SwEcpWriteCount ;
	LONGLONG SwEcpReadCount ;
	LONGLONG HwEppWriteCount ;
	LONGLONG HwEppReadCount ;
	LONGLONG SwEppWriteCount ;
	LONGLONG SwEppReadCount ;
	LONGLONG ByteReadCount ;
	LONGLONG ChannelNibbleReadCount ;
} PARALLEL_WMI_LOG_INFO , *  PPARALLEL_WMI_LOG_INFO ;

#line 3038
extern const GUID MSRedbook_DriverInformationGuid ;

#line 3041
typedef struct _REDBOOK_WMI_STD_DATA {
	ULONG NumberOfBuffers ;
	ULONG SectorsPerRead ;
	ULONG SectorsPerReadMask ;
	ULONG MaximumSectorsPerRead ;
	BOOLEAN PlayEnabled ;
	BOOLEAN CDDASupported ;
	BOOLEAN CDDAAccurate ;
	BOOLEAN Reserved1 ;
} REDBOOK_WMI_STD_DATA , *  PREDBOOK_WMI_STD_DATA ;

#line 3091
extern const GUID MSRedbook_PerformanceGuid ;

#line 3094
typedef struct _REDBOOK_WMI_PERF_DATA {
	LONGLONG TimeReadDelay ;
	LONGLONG TimeReading ;
	LONGLONG TimeStreamDelay ;
	LONGLONG TimeStreaming ;
	LONGLONG DataProcessed ;
	ULONG StreamPausedCount ;
} REDBOOK_WMI_PERF_DATA , *  PREDBOOK_WMI_PERF_DATA ;

#line 3134
extern const GUID RegisteredGuids_GUID ;

#line 3137
typedef struct _RegisteredGuids {
	ULONG GuidType ;
	ULONG LoggerId ;
	ULONG EnableLevel ;
	ULONG EnableFlags ;
	BOOLEAN IsEnabled ;
} RegisteredGuids , *  PRegisteredGuids ;

#line 475 "serial.h"
typedef struct _CONFIG_DATA {
	LARGE_INTEGER Controller ;
	LARGE_INTEGER TrController ;
	LARGE_INTEGER InterruptStatus ;
	LARGE_INTEGER TrInterruptStatus ;
	ULONG SpanOfController ;
	ULONG SpanOfInterruptStatus ;
	ULONG PortIndex ;
	ULONG ClockRate ;
	ULONG BusNumber ;
	ULONG AddressSpace ;
	ULONG DisablePort ;
	ULONG ForceFifoEnable ;
	ULONG RxFIFO ;
	ULONG TxFIFO ;
	ULONG PermitShare ;
	ULONG PermitSystemWideShare ;
	ULONG LogFifo ;
	ULONG MaskInverted ;
	KINTERRUPT_MODE InterruptMode ;
	INTERFACE_TYPE InterfaceType ;
	ULONG OriginalVector ;
	ULONG OriginalIrql ;
	ULONG TrVector ;
	ULONG TrIrql ;
	ULONG Affinity ;
	ULONG Indexed ;
	BOOLEAN Jensen ;
} CONFIG_DATA , *  PCONFIG_DATA ;

#line 509
typedef struct _SERIAL_CISR_SW {
	BOOLEAN ( *  IsrFunc )(PKINTERRUPT , PVOID ) ;
	PVOID Context ;
	LIST_ENTRY SharerList ;
} SERIAL_CISR_SW , *  PSERIAL_CISR_SW ;

#line 520
typedef struct _SERIAL_FIRMWARE_DATA {
	PDRIVER_OBJECT DriverObject ;
	ULONG ControllersFound ;
	ULONG ForceFifoEnableDefault ;
	ULONG DebugLevel ;
	ULONG ShouldBreakOnEntry ;
	ULONG RxFIFODefault ;
	ULONG TxFIFODefault ;
	ULONG PermitShareDefault ;
	ULONG PermitSystemWideShare ;
	ULONG LogFifoDefault ;
	UNICODE_STRING Directory ;
	UNICODE_STRING NtNameSuffix ;
	UNICODE_STRING DirectorySymbolicName ;
	LIST_ENTRY ConfigList ;
	BOOLEAN JensenDetected ;
} SERIAL_FIRMWARE_DATA , *  PSERIAL_FIRMWARE_DATA ;

#line 576
typedef struct _SERIAL_DEVICE_STATE {
	BOOLEAN Reopen ;
	UCHAR IER ;
	UCHAR LCR ;
	UCHAR MCR ;
} SERIAL_DEVICE_STATE , *  PSERIAL_DEVICE_STATE ;

#line 646
typedef struct _SERIAL_DEVICE_EXTENSION {
	PKSERVICE_ROUTINE TopLevelOurIsr ;
	PVOID TopLevelOurIsrContext ;
	LIST_ENTRY TopLevelSharers ;
	LIST_ENTRY CommonInterruptObject ;
	LIST_ENTRY MultiportSiblings ;
	LIST_ENTRY AllDevObjs ;
	LARGE_INTEGER OriginalController ;
	LARGE_INTEGER OriginalInterruptStatus ;
	LARGE_INTEGER IntervalTime ;
	LARGE_INTEGER ShortIntervalAmount ;
	LARGE_INTEGER LongIntervalAmount ;
	LARGE_INTEGER CutOverAmount ;
	LARGE_INTEGER LastReadTime ;
	UNICODE_STRING DeviceName ;
	UNICODE_STRING ObjectDirectory ;
	UNICODE_STRING NtNameForPort ;
	UNICODE_STRING SymbolicLinkName ;
	UNICODE_STRING DosName ;
	PLARGE_INTEGER IntervalTimeToUse ;
	PDEVICE_OBJECT DeviceObject ;
	PKSERVICE_ROUTINE OurIsr ;
	PVOID OurIsrContext ;
	PUCHAR Controller ;
	PUCHAR InterruptStatus ;
	PKINTERRUPT Interrupt ;
	LIST_ENTRY ReadQueue ;
	LIST_ENTRY WriteQueue ;
	LIST_ENTRY MaskQueue ;
	LIST_ENTRY PurgeQueue ;
	PIRP CurrentReadIrp ;
	PIRP CurrentWriteIrp ;
	PIRP CurrentMaskIrp ;
	PIRP CurrentPurgeIrp ;
	PIRP CurrentWaitIrp ;
	PIRP CurrentImmediateIrp ;
	PIRP CurrentXoffIrp ;
	ULONG WriteLength ;
	PUCHAR WriteCurrentChar ;
	PUCHAR InterruptReadBuffer ;
	PUCHAR ReadBufferBase ;
	ULONG CharsInInterruptBuffer ;
	PUCHAR CurrentCharSlot ;
	PUCHAR LastCharSlot ;
	PUCHAR FirstReadableChar ;
	PVOID LockPtr ;
	ULONG BufferSize ;
	ULONG BufferSizePt8 ;
	ULONG NumberNeededForRead ;
	ULONG IsrWaitMask ;
	ULONG HistoryMask ;
	ULONG *  IrpMaskLocation ;
	ULONG TXHolding ;
	ULONG RXHolding ;
	ULONG ErrorWord ;
	ULONG TotalCharsQueued ;
	LONG CountOnLastRead ;
	ULONG ReadByIsr ;
	ULONG CurrentBaud ;
	LONG CountSinceXoff ;
	ULONG CountOfTryingToLowerRTS ;
	ULONG SupportedBauds ;
	ULONG SpanOfController ;
	ULONG SpanOfInterruptStatus ;
	ULONG ClockRate ;
	ULONG TxFifoAmount ;
	ULONG PermitShare ;
	SERIAL_TIMEOUTS Timeouts ;
	SERIAL_CHARS SpecialChars ;
	SERIAL_HANDFLOW HandFlow ;
	SERIALPERF_STATS PerfStats ;
	UCHAR LineControl ;
	BOOLEAN DeviceIsOpened ;
	BOOLEAN UnMapRegisters ;
	BOOLEAN UnMapStatus ;
	BOOLEAN HoldingEmpty ;
	BOOLEAN TransmitImmediate ;
	BOOLEAN EmptiedTransmit ;
	BOOLEAN PortOnAMultiportCard ;
	ULONG Vector ;
	KIRQL Irql ;
	ULONG OriginalVector ;
	ULONG OriginalIrql ;
	ULONG AddressSpace ;
	ULONG BusNumber ;
	INTERFACE_TYPE InterfaceType ;
	ULONG PortIndex ;
	BOOLEAN Indexed ;
	ULONG MaskInverted ;
	ULONG NewPortIndex ;
	ULONG NewMaskInverted ;
	PVOID NewExtension ;
	UCHAR ImmediateChar ;
	UCHAR ValidDataMask ;
	UCHAR EscapeChar ;
	BOOLEAN SendXonChar ;
	BOOLEAN SendXoffChar ;
	BOOLEAN FifoPresent ;
	BOOLEAN Jensen ;
	UCHAR RxFifoTrigger ;
	BOOLEAN InterruptShareable ;
	BOOLEAN CreatedSymbolicLink ;
	BOOLEAN CreatedSerialCommEntry ;
	KSPIN_LOCK ControlLock ;
	KSPIN_LOCK FlagsLock ;
	KDPC CompleteWriteDpc ;
	KDPC CompleteReadDpc ;
	KDPC TotalReadTimeoutDpc ;
	KDPC IntervalReadTimeoutDpc ;
	KDPC TotalWriteTimeoutDpc ;
	KDPC CommErrorDpc ;
	KDPC CommWaitDpc ;
	KDPC CompleteImmediateDpc ;
	KDPC TotalImmediateTimeoutDpc ;
	KDPC XoffCountTimeoutDpc ;
	KDPC XoffCountCompleteDpc ;
	KDPC StartTimerLowerRTSDpc ;
	KDPC PerhapsLowerRTSDpc ;
	KDPC IsrUnlockPagesDpc ;
	KTIMER ReadRequestTotalTimer ;
	KTIMER ReadRequestIntervalTimer ;
	KTIMER WriteRequestTotalTimer ;
	KTIMER ImmediateTotalTimer ;
	KTIMER XoffCountTimer ;
	KTIMER LowerRTSTimer ;
	PDEVICE_OBJECT LowerDeviceObject ;
	DEVICE_POWER_STATE PowerState ;
	PDRIVER_OBJECT DriverObject ;
	KEVENT SerialSyncEvent ;
	UNICODE_STRING DeviceClassSymbolicName ;
	PSERIAL_CISR_SW CIsrSw ;
	ULONG PendingIRPCnt ;
	ULONG DevicePNPAccept ;
	KEVENT PendingIRPEvent ;
	ULONG PNPState ;
	ULONG Flags ;
	LONG OpenCount ;
	KEVENT SerialStartEvent ;
	SERIAL_DEVICE_STATE DeviceState ;
	DEVICE_POWER_STATE DeviceStateMap[PowerSystemMaximum] ;
	KEVENT PowerD0Event ;
	LIST_ENTRY StalledIrpQueue ;
	FAST_MUTEX OpenMutex ;
	FAST_MUTEX CloseMutex ;
	BOOLEAN OwnsPowerPolicy ;
	SYSTEM_POWER_STATE SystemWake ;
	DEVICE_POWER_STATE DeviceWake ;
	PDEVICE_OBJECT Pdo ;
	BOOLEAN SendWaitWake ;
	PIRP PendingWakeIrp ;
	WMILIB_CONTEXT WmiLibInfo ;
	UNICODE_STRING WmiIdentifier ;
	SERIAL_WMI_COMM_DATA WmiCommData ;
	SERIAL_WMI_HW_DATA WmiHwData ;
	SERIAL_WMI_PERF_DATA WmiPerfData ;
	ULONG DpcCount ;
	KEVENT PendingDpcEvent ;
	ULONG SkipNaming ;
} SERIAL_DEVICE_EXTENSION , *  PSERIAL_DEVICE_EXTENSION ;

#line 1808
typedef struct _SERIAL_MULTIPORT_DISPATCH {
	PUCHAR InterruptStatus ;
	PSERIAL_DEVICE_EXTENSION Extensions[16] ;
	ULONG MaskInverted ;
	UCHAR UsablePortMask ;
} SERIAL_MULTIPORT_DISPATCH , *  PSERIAL_MULTIPORT_DISPATCH ;

#line 2146
extern SERIAL_FIRMWARE_DATA driverDefaults ;
#line 2154
extern PUCHAR *  KdComPortInUse ;

#line 2157
typedef enum _SERIAL_MEM_COMPARES {
	AddressesAreEqual,
	AddressesOverlap,
	AddressesAreDisjoint
} SERIAL_MEM_COMPARES , *  PSERIAL_MEM_COMPARES ;

#line 2164
typedef struct _SERIAL_LIST_DATA {
	PLIST_ENTRY destList ;
	PLIST_ENTRY newElement ;
} SERIAL_LIST_DATA , *  PSERIAL_LIST_DATA ;

typedef struct _SERIAL_GLOBALS {
	LIST_ENTRY AllDevObjs ;
	PVOID PAGESER_Handle ;
	UNICODE_STRING RegistryPath ;
} SERIAL_GLOBALS , *  PSERIAL_GLOBALS ;

#line 2178
extern SERIAL_GLOBALS SerialGlobals ;

typedef struct _SERIAL_USER_DATA {
	LARGE_INTEGER UserPort ;
	LARGE_INTEGER UserInterruptStatus ;
	ULONG UserVector ;
	UNICODE_STRING UserSymbolicLink ;
	ULONG UserPortIndex ;
	ULONG UserBusNumber ;
	ULONG UserInterfaceType ;
	ULONG UserClockRate ;
	ULONG UserIndexed ;
	ULONG UserInterruptMode ;
	ULONG UserAddressSpace ;
	ULONG UserLevel ;
	ULONG DefaultPermitSystemWideShare ;
	ULONG DisablePort ;
	ULONG RxFIFO ;
	ULONG RxFIFODefault ;
	ULONG TxFIFO ;
	ULONG TxFIFODefault ;
	ULONG ForceFIFOEnable ;
	ULONG ForceFIFOEnableDefault ;
	ULONG PermitShareDefault ;
	ULONG LogFIFODefault ;
	ULONG MaskInverted ;
} SERIAL_USER_DATA , *  PSERIAL_USER_DATA ;

typedef struct _SERIAL_PTR_CTX {
	ULONG isPointer ;
	LARGE_INTEGER Port ;
	ULONG Vector ;
} SERIAL_PTR_CTX , *  PSERIAL_PTR_CTX ;

#line 2233
extern WMIGUIDREGINFO SerialWmiGuidList[5] ;

#line 20 "serialp.h"
typedef NTSTATUS ( *  PSERIAL_START_ROUTINE )(PSERIAL_DEVICE_EXTENSION ) ;

#line 26
typedef void ( *  PSERIAL_GET_NEXT_ROUTINE )(PIRP *  CurrentOpIrp , PLIST_ENTRY
	QueueToProcess , PIRP *  NewIrp , BOOLEAN CompleteCurrent ,
	PSERIAL_DEVICE_EXTENSION Extension ) ;

#line 36
NTSTATUS SerialRead(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 42
NTSTATUS SerialStartRead(PSERIAL_DEVICE_EXTENSION Extension ) ;
#line 47
void SerialCompleteRead(PKDPC Dpc , PVOID DeferredContext , PVOID SystemContext1
	, PVOID SystemContext2 ) ;
#line 55
void SerialReadTimeout(PKDPC Dpc , PVOID DeferredContext , PVOID SystemContext1
	, PVOID SystemContext2 ) ;
#line 63
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject , PUNICODE_STRING RegistryPath
	) ;
#line 69
void SerialIntervalReadTimeout(PKDPC Dpc , PVOID DeferredContext , PVOID
	SystemContext1 , PVOID SystemContext2 ) ;
#line 77
NTSTATUS SerialFlush(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 83
NTSTATUS SerialWrite(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 89
NTSTATUS SerialStartWrite(PSERIAL_DEVICE_EXTENSION Extension ) ;
#line 94
void SerialGetNextWrite(PIRP *  CurrentOpIrp , PLIST_ENTRY QueueToProcess , PIRP
	*  NewIrp , BOOLEAN CompleteCurrent , PSERIAL_DEVICE_EXTENSION Extension
	) ;
#line 103
void SerialCompleteWrite(PKDPC Dpc , PVOID DeferredContext , PVOID
	SystemContext1 , PVOID SystemContext2 ) ;
#line 111
BOOLEAN SerialProcessEmptyTransmit(PVOID Context ) ;
#line 116
void SerialWriteTimeout(PKDPC Dpc , PVOID DeferredContext , PVOID SystemContext1
	, PVOID SystemContext2 ) ;
#line 124
void SerialCommError(PKDPC Dpc , PVOID DeferredContext , PVOID SystemContext1 ,
	PVOID SystemContext2 ) ;
#line 132
NTSTATUS SerialCleanup(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 138
NTSTATUS SerialInitOneController(PDEVICE_OBJECT PDevObj , PCONFIG_DATA
	PConfigData ) ;
#line 141
NTSTATUS SerialCreateOpen(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 147
NTSTATUS SerialClose(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 153
BOOLEAN SerialSetDTR(PVOID Context ) ;
#line 158
BOOLEAN SerialClrDTR(PVOID Context ) ;
#line 163
BOOLEAN SerialSetRTS(PVOID Context ) ;
#line 168
BOOLEAN SerialClrRTS(PVOID Context ) ;
#line 173
BOOLEAN SerialSetChars(PVOID Context ) ;
#line 178
BOOLEAN SerialSetBaud(PVOID Context ) ;
#line 183
BOOLEAN SerialSetLineControl(PVOID Context ) ;
#line 188
BOOLEAN SerialSetupNewHandFlow(PSERIAL_DEVICE_EXTENSION Extension ,
	PSERIAL_HANDFLOW NewHandFlow ) ;
#line 194
BOOLEAN SerialSetHandFlow(PVOID Context ) ;
#line 199
BOOLEAN SerialTurnOnBreak(PVOID Context ) ;
#line 204
BOOLEAN SerialTurnOffBreak(PVOID Context ) ;
#line 209
BOOLEAN SerialPretendXoff(PVOID Context ) ;
#line 214
BOOLEAN SerialPretendXon(PVOID Context ) ;
#line 219
void SerialHandleReducedIntBuffer(PSERIAL_DEVICE_EXTENSION Extension ) ;
#line 224
void SerialProdXonXoff(PSERIAL_DEVICE_EXTENSION Extension , BOOLEAN SendXon ) ;
#line 230
NTSTATUS SerialIoControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 236
NTSTATUS SerialStartMask(PSERIAL_DEVICE_EXTENSION Extension ) ;
#line 241
void SerialCancelWait(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 247
void SerialCompleteWait(PKDPC Dpc , PVOID DeferredContext , PVOID SystemContext1
	, PVOID SystemContext2 ) ;
#line 255
void SerialStartImmediate(PSERIAL_DEVICE_EXTENSION Extension ) ;
#line 260
void SerialCompleteImmediate(PKDPC Dpc , PVOID DeferredContext , PVOID
	SystemContext1 , PVOID SystemContext2 ) ;
#line 268
void SerialTimeoutImmediate(PKDPC Dpc , PVOID DeferredContext , PVOID
	SystemContext1 , PVOID SystemContext2 ) ;
#line 276
void SerialTimeoutXoff(PKDPC Dpc , PVOID DeferredContext , PVOID SystemContext1
	, PVOID SystemContext2 ) ;
#line 284
void SerialCompleteXoff(PKDPC Dpc , PVOID DeferredContext , PVOID SystemContext1
	, PVOID SystemContext2 ) ;
#line 292
NTSTATUS SerialStartPurge(PSERIAL_DEVICE_EXTENSION Extension ) ;
#line 297
BOOLEAN SerialPurgeInterruptBuff(PVOID Context ) ;
#line 302
NTSTATUS SerialQueryInformationFile(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 308
NTSTATUS SerialSetInformationFile(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 314
void SerialKillAllReadsOrWrites(PDEVICE_OBJECT DeviceObject , PLIST_ENTRY
	QueueToClean , PIRP *  CurrentOpIrp ) ;
#line 321
void SerialGetNextIrp(PIRP *  CurrentOpIrp , PLIST_ENTRY QueueToProcess , PIRP
	*  NextIrp , BOOLEAN CompleteCurrent , PSERIAL_DEVICE_EXTENSION
	extension ) ;
#line 330
void SerialGetNextIrpLocked(PIRP *  CurrentOpIrp , PLIST_ENTRY QueueToProcess ,
	PIRP *  NextIrp , BOOLEAN CompleteCurrent , PSERIAL_DEVICE_EXTENSION
	extension , KIRQL OldIrql ) ;
#line 335
void SerialTryToCompleteCurrent(PSERIAL_DEVICE_EXTENSION Extension ,
	PKSYNCHRONIZE_ROUTINE SynchRoutine , KIRQL IrqlForRelease , NTSTATUS
	StatusToUse , PIRP *  CurrentOpIrp , PLIST_ENTRY QueueToProcess ,
	PKTIMER IntervalTimer , PKTIMER TotalTimer , PSERIAL_START_ROUTINE
	Starter , PSERIAL_GET_NEXT_ROUTINE GetNextIrp , LONG RefType ) ;
#line 350
NTSTATUS SerialStartOrQueue(PSERIAL_DEVICE_EXTENSION Extension , PIRP Irp ,
	PLIST_ENTRY QueueToExamine , PIRP *  CurrentOpIrp ,
	PSERIAL_START_ROUTINE Starter ) ;
#line 359
void SerialCancelQueued(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 365
NTSTATUS SerialCompleteIfError(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 371
ULONG SerialHandleModemUpdate(PSERIAL_DEVICE_EXTENSION Extension , BOOLEAN
	DoingTX ) ;
#line 377
BOOLEAN SerialISR(PKINTERRUPT InterruptObject , PVOID Context ) ;
#line 383
NTSTATUS SerialGetDivisorFromBaud(ULONG ClockRate , LONG DesiredBaud , PSHORT
	AppropriateDivisor ) ;
#line 390
void SerialUnload(PDRIVER_OBJECT DriverObject ) ;
#line 395
BOOLEAN SerialReset(PVOID Context ) ;
#line 400
BOOLEAN SerialPerhapsLowerRTS(PVOID Context ) ;
#line 405
void SerialStartTimerLowerRTS(PKDPC Dpc , PVOID DeferredContext , PVOID
	SystemContext1 , PVOID SystemContext2 ) ;
#line 413
void SerialInvokePerhapsLowerRTS(PKDPC Dpc , PVOID DeferredContext , PVOID
	SystemContext1 , PVOID SystemContext2 ) ;
#line 421
void SerialCleanupDevice(PSERIAL_DEVICE_EXTENSION Extension ) ;
#line 426
UCHAR SerialProcessLSR(PSERIAL_DEVICE_EXTENSION Extension ) ;
#line 431
LARGE_INTEGER SerialGetCharTime(PSERIAL_DEVICE_EXTENSION Extension ) ;
#line 436
BOOLEAN SerialSharerIsr(PKINTERRUPT InterruptObject , PVOID Context ) ;
#line 442
BOOLEAN SerialMarkClose(PVOID Context ) ;
#line 447
BOOLEAN SerialIndexedMultiportIsr(PKINTERRUPT InterruptObject , PVOID Context )
	;
#line 453
BOOLEAN SerialBitMappedMultiportIsr(PKINTERRUPT InterruptObject , PVOID Context
	) ;
#line 459
void SerialPutChar(PSERIAL_DEVICE_EXTENSION Extension , UCHAR CharToPut ) ;
#line 465
BOOLEAN SerialGetStats(PVOID Context ) ;
#line 470
BOOLEAN SerialClearStats(PVOID Context ) ;
#line 475
NTSTATUS SerialCloseComplete(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID
	Context ) ;
#line 482
NTSTATUS SerialPnpDispatch(PDEVICE_OBJECT PDevObj , PIRP PIrp ) ;
#line 485
NTSTATUS SerialPowerDispatch(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 491
NTSTATUS SerialSetPowerD0(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 497
NTSTATUS SerialSetPowerD3(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 503
NTSTATUS SerialOpenClose(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 509
NTSTATUS SerialGetConfigDefaults(PSERIAL_FIRMWARE_DATA DriverDefaultsPtr ,
	PUNICODE_STRING RegistryPath ) ;
#line 515
void SerialGetProperties(PSERIAL_DEVICE_EXTENSION Extension , PSERIAL_COMMPROP
	Properties ) ;
#line 521
NTSTATUS SerialEnumerateLegacy(PDRIVER_OBJECT DriverObject , PUNICODE_STRING
	RegistryPath , PSERIAL_FIRMWARE_DATA DriverDefaultsPtr ) ;
#line 526
NTSTATUS SerialMigrateLegacyRegistry(PDEVICE_OBJECT PPdo , PSERIAL_USER_DATA
	PUserData , BOOLEAN IsMulti ) ;
#line 531
NTSTATUS SerialBuildResourceList(PCM_RESOURCE_LIST PResourceList , PULONG
	PPartialCount , PSERIAL_USER_DATA PUserData ) ;
#line 536
NTSTATUS SerialTranslateResourceList(PDRIVER_OBJECT DriverObject ,
	PKEY_BASIC_INFORMATION UserSubKey , PCM_RESOURCE_LIST PTrResourceList ,
	PCM_RESOURCE_LIST PResourceList , ULONG PartialCount , PSERIAL_USER_DATA
	PUserData ) ;
#line 544
NTSTATUS SerialBuildRequirementsList(PIO_RESOURCE_REQUIREMENTS_LIST
	PRequiredList , ULONG PartialCount , PSERIAL_USER_DATA PUserData ) ;
#line 549
BOOLEAN SerialIsUserDataValid(PDRIVER_OBJECT DriverObject ,
	PKEY_BASIC_INFORMATION UserSubKey , PRTL_QUERY_REGISTRY_TABLE Parameters
	, ULONG DefaultInterfaceType , PSERIAL_USER_DATA PUserData ) ;
#line 556
NTSTATUS SerialControllerCallBack(PVOID Context , PUNICODE_STRING PathName ,
	INTERFACE_TYPE BusType , ULONG BusNumber , PKEY_VALUE_FULL_INFORMATION
	*  BusInformation , CONFIGURATION_TYPE ControllerType , ULONG
	ControllerNumber , PKEY_VALUE_FULL_INFORMATION *  ControllerInformation
	, CONFIGURATION_TYPE PeripheralType , ULONG PeripheralNumber ,
	PKEY_VALUE_FULL_INFORMATION *  PeripheralInformation ) ;
#line 571
void SerialLogError(PDRIVER_OBJECT DriverObject , PDEVICE_OBJECT DeviceObject ,
	LARGE_INTEGER P1 , LARGE_INTEGER P2 , ULONG SequenceNumber , UCHAR
	MajorFunctionCode , UCHAR RetryCount , ULONG UniqueErrorValue , NTSTATUS
	FinalStatus , NTSTATUS SpecificIOStatus , ULONG LengthOfInsert1 , PWCHAR
	Insert1 , ULONG LengthOfInsert2 , PWCHAR Insert2 ) ;
#line 589
NTSTATUS SerialAddDevice(PDRIVER_OBJECT DriverObject , PDEVICE_OBJECT
	PLowerDevObj ) ;
#line 592
NTSTATUS SerialCreateDevObj(PDRIVER_OBJECT DriverObject , PDEVICE_OBJECT * 
	NewDeviceObject ) ;
#line 596
NTSTATUS SerialStartDevice(PDEVICE_OBJECT PDevObj , PIRP PIrp ) ;
#line 599
NTSTATUS SerialGetRegistryKeyValue(HANDLE Handle , PWCHAR KeyNameString , ULONG
	KeyNameStringLength , PVOID Data , ULONG DataLength ) ;
#line 607
NTSTATUS SerialGetPortInfo(PDEVICE_OBJECT PDevObj , PCM_RESOURCE_LIST PResList ,
	PCM_RESOURCE_LIST PTrResList , PCONFIG_DATA PConfig , PSERIAL_USER_DATA
	PUserData ) ;
#line 612
NTSTATUS SerialFinishStartDevice(PDEVICE_OBJECT PDevObj , PCM_RESOURCE_LIST
	PResList , PCM_RESOURCE_LIST PTrResList , PSERIAL_USER_DATA PUserData )
	;
#line 618
NTSTATUS SerialPutRegistryKeyValue(HANDLE Handle , PWCHAR KeyNameString , ULONG
	KeyNameStringLength , ULONG Dtype , PVOID Data , ULONG DataLength ) ;
#line 628
NTSTATUS SerialInitController(PDEVICE_OBJECT PDevObj , PCONFIG_DATA PConfigData
	) ;
#line 631
NTSTATUS SerialInitMultiPort(PSERIAL_DEVICE_EXTENSION PDevExt , PCONFIG_DATA
	PConfigData , PDEVICE_OBJECT PDevObj ) ;
#line 635
NTSTATUS SerialFindInitController(PDEVICE_OBJECT PDevObj , PCONFIG_DATA PConfig
	) ;
#line 639
BOOLEAN SerialCIsrSw(PKINTERRUPT InterruptObject , PVOID Context ) ;
#line 642
NTSTATUS SerialDoExternalNaming(PSERIAL_DEVICE_EXTENSION PDevExt ,
	PDRIVER_OBJECT PDrvObj ) ;
#line 646
PVOID SerialGetMappedAddress(INTERFACE_TYPE BusType , ULONG BusNumber ,
	LARGE_INTEGER IoAddress , ULONG NumberOfBytes , ULONG AddressSpace ,
	PBOOLEAN MappedAddress ) ;
#line 656
NTSTATUS SerialItemCallBack(PVOID Context , PUNICODE_STRING PathName ,
	INTERFACE_TYPE BusType , ULONG BusNumber , PKEY_VALUE_FULL_INFORMATION
	*  BusInformation , CONFIGURATION_TYPE ControllerType , ULONG
	ControllerNumber , PKEY_VALUE_FULL_INFORMATION *  ControllerInformation
	, CONFIGURATION_TYPE PeripheralType , ULONG PeripheralNumber ,
	PKEY_VALUE_FULL_INFORMATION *  PeripheralInformation ) ;
#line 671
BOOLEAN SerialDoesPortExist(PSERIAL_DEVICE_EXTENSION Extension , PUNICODE_STRING
	InsertString , ULONG ForceFifo , ULONG LogFifo ) ;
#line 679
SERIAL_MEM_COMPARES SerialMemCompare(LARGE_INTEGER A , ULONG SpanOfA ,
	LARGE_INTEGER B , ULONG SpanOfB ) ;
#line 687
void SerialUndoExternalNaming(PSERIAL_DEVICE_EXTENSION Extension ) ;
#line 693
NTSTATUS SerialIRPPrologue(PIRP PIrp , PSERIAL_DEVICE_EXTENSION PDevExt ) ;
#line 696
void SerialIRPEpilogue(PSERIAL_DEVICE_EXTENSION PDevExt ) ;
#line 699
NTSTATUS SerialIoCallDriver(PSERIAL_DEVICE_EXTENSION PDevExt , PDEVICE_OBJECT
	PDevObj , PIRP PIrp ) ;
#line 703
NTSTATUS SerialPoCallDriver(PSERIAL_DEVICE_EXTENSION PDevExt , PDEVICE_OBJECT
	PDevObj , PIRP PIrp ) ;
#line 707
NTSTATUS SerialRemoveDevObj(PDEVICE_OBJECT PDevObj ) ;
#line 710
void SerialReleaseResources(PSERIAL_DEVICE_EXTENSION PDevExt ) ;
#line 713
void SerialKillPendingIrps(PDEVICE_OBJECT DeviceObject ) ;
#line 716
void SerialDisableUART(PVOID Context ) ;
#line 719
void SerialDrainUART(PSERIAL_DEVICE_EXTENSION PDevExt , PLARGE_INTEGER
	PDrainTime ) ;
#line 723
NTSTATUS SerialSystemControlDispatch(PDEVICE_OBJECT PDevObj , PIRP PIrp ) ;
#line 726
NTSTATUS SerialSetWmiDataItem(PDEVICE_OBJECT PDevObj , PIRP PIrp , ULONG
	GuidIndex , ULONG InstanceIndex , ULONG DataItemId , ULONG BufferSize ,
	PUCHAR PBuffer ) ;
#line 732
NTSTATUS SerialSetWmiDataBlock(PDEVICE_OBJECT PDevObj , PIRP PIrp , ULONG
	GuidIndex , ULONG InstanceIndex , ULONG BufferSize , PUCHAR PBuffer ) ;
#line 738
NTSTATUS SerialQueryWmiDataBlock(PDEVICE_OBJECT PDevObj , PIRP PIrp , ULONG
	GuidIndex , ULONG InstanceIndex , ULONG InstanceCount , PULONG
	InstanceLengthArray , ULONG OutBufferSize , PUCHAR PBuffer ) ;
#line 747
NTSTATUS SerialQueryWmiRegInfo(PDEVICE_OBJECT PDevObj , PULONG PRegFlags ,
	PUNICODE_STRING PInstanceName , PUNICODE_STRING *  PRegistryPath ,
	PUNICODE_STRING MofResourceName , PDEVICE_OBJECT *  Pdo ) ;
#line 754
void SerialRestoreDeviceState(PSERIAL_DEVICE_EXTENSION PDevExt ) ;
#line 757
void SerialSaveDeviceState(PSERIAL_DEVICE_EXTENSION PDevExt ) ;
#line 760
NTSTATUS SerialSyncCompletion(PDEVICE_OBJECT DeviceObject , PIRP Irp , PKEVENT
	SerialSyncEvent ) ;
#line 764
NTSTATUS SerialGotoPowerState(PDEVICE_OBJECT PDevObj , PSERIAL_DEVICE_EXTENSION
	PDevExt , DEVICE_POWER_STATE DevPowerState ) ;
#line 769
NTSTATUS SerialFilterIrps(PIRP PIrp , PSERIAL_DEVICE_EXTENSION PDevExt ) ;
#line 772
void SerialKillAllStalled(PDEVICE_OBJECT PDevObj ) ;
#line 775
void SerialUnstallIrps(PSERIAL_DEVICE_EXTENSION PDevExt ) ;
#line 778
NTSTATUS SerialInternalIoControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 781
NTSTATUS SerialSendWaitWake(PSERIAL_DEVICE_EXTENSION PDevExt ) ;
#line 784
NTSTATUS SerialWakeCompletion(PDEVICE_OBJECT PDevObj , UCHAR MinorFunction ,
	POWER_STATE PowerState , PVOID Context , PIO_STATUS_BLOCK IoStatus ) ;
#line 789
UINT32 SerialReportMaxBaudRate(ULONG Bauds ) ;
#line 792
BOOLEAN SerialSetMCRContents(PVOID Context ) ;
#line 795
BOOLEAN SerialGetMCRContents(PVOID Context ) ;
#line 798
BOOLEAN SerialSetFCRContents(PVOID Context ) ;
#line 801
NTSTATUS SerialTossWMIRequest(PDEVICE_OBJECT PDevObj , PIRP PIrp , ULONG
	GuidIndex ) ;
#line 805
void SerialDpcEpilogue(PSERIAL_DEVICE_EXTENSION PDevExt , PKDPC PDpc ) ;
#line 808
BOOLEAN SerialInsertQueueDpc(PRKDPC Dpc , PVOID Sarg1 , PVOID Sarg2 ,
	PSERIAL_DEVICE_EXTENSION PDevExt ) ;
#line 812
BOOLEAN SerialSetTimer(PKTIMER Timer , LARGE_INTEGER DueTime , PKDPC Dpc ,
	PSERIAL_DEVICE_EXTENSION PDevExt ) ;
#line 816
BOOLEAN SerialCancelTimer(PKTIMER Timer , PSERIAL_DEVICE_EXTENSION PDevExt ) ;
#line 819
void SerialUnlockPages(PKDPC PDpc , PVOID PDeferredContext , PVOID PSysContext1
	, PVOID PSysContext2 ) ;
#line 823
void SerialMarkHardwareBroken(PSERIAL_DEVICE_EXTENSION PDevExt ) ;
#line 826
void SerialDisableInterfacesResources(PDEVICE_OBJECT PDevObj , BOOLEAN
	DisableUART ) ;
#line 830
void SerialSetDeviceFlags(PSERIAL_DEVICE_EXTENSION PDevExt , PULONG PFlags ,
	ULONG Value , BOOLEAN Set ) ;

#line 835
typedef struct _SERIAL_UPDATE_CHAR {
	PSERIAL_DEVICE_EXTENSION Extension ;
	ULONG CharsCopied ;
	BOOLEAN Completed ;
} SERIAL_UPDATE_CHAR , *  PSERIAL_UPDATE_CHAR ;

#line 846
typedef struct _SERIAL_IOCTL_SYNC {
	PSERIAL_DEVICE_EXTENSION Extension ;
	PVOID Data ;
} SERIAL_IOCTL_SYNC , *  PSERIAL_IOCTL_SYNC ;


#line 15 "../slam-kernel.c"
extern void errorFn() ;


#line 22
extern int s ;
extern int UNLOADED , NP , DC , SKIP1 , SKIP2 , MPR1 , MPR3 , IPC ;
#line 26
extern int pending ;
extern PIO_COMPLETION_ROUTINE compFptr ;
extern int compRegistered ;
extern int lowerDriverReturn ;
extern int setEventCalled ;
extern int customIrp ;
extern int routine ;
#line 34
extern int myStatus ;
#line 36
extern void _BLAST_init();
extern void stub_driver_init();
#line 29 "error.c"

void SerialCommError(PKDPC Dpc , PVOID DeferredContext , PVOID SystemContext1 ,
	PVOID SystemContext2 )
{
	#line 62
	PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
	#line 64
	SystemContext1;
	SystemContext2;
	#line 67
	do
	{
		#line 67
		;
	}
	while(0);
	#line 69
	SerialKillAllReadsOrWrites(Extension->DeviceObject, &
		Extension->WriteQueue, & Extension->CurrentWriteIrp);
	#line 75
	SerialKillAllReadsOrWrites(Extension->DeviceObject, &
		Extension->ReadQueue, & Extension->CurrentReadIrp);
	#line 82
	SerialDpcEpilogue(Extension, Dpc);
}

#line 16 "C:/NTDDK/inc/stddef.h"

#pragma once
#line 77
typedef int ;

#line 86
typedef unsigned int ;

#line 95
typedef int ;

#line 105
typedef unsigned int ;

#line 112
typedef unsigned short ;

#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"

#pragma once
#line 32

#pragma pack(push, 8)
#line 72
typedef enum _EXCEPTION_DISPOSITION ;

#line 89
struct _EXCEPTION_RECORD ;

#line 90
struct _CONTEXT ;

#line 155

#pragma pack(pop)
#line 25 "C:/NTDDK/inc/ntdef.h"

#pragma once
#line 15 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"

#pragma once
#line 66
typedef wchar_t ;

#line 67
typedef wchar_t ;

#line 127 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long ;

#line 25 "C:/NTDDK/inc/basetsd.h"

#pragma once
#line 36
typedef int ;

#line 37
typedef int ;

#line 43
typedef unsigned int ;

#line 44
typedef unsigned int ;

#line 45
typedef unsigned int ;

#line 84
typedef int ;

#line 85
typedef unsigned int ;

typedef long ;

#line 88
typedef unsigned long ;

#line 248
typedef unsigned short ;

#line 249
typedef short ;

#line 250
typedef unsigned long ;

#line 288
typedef ULONG_PTR ;

#line 289
typedef LONG_PTR ;

#line 295
typedef ULONG_PTR ;

#line 301
typedef __int64 ;

#line 302
typedef __int64 ;

#line 309
typedef unsigned __int64 ;

#line 310
typedef unsigned __int64 ;

#line 311
typedef unsigned __int64 ;

#line 217 "C:/NTDDK/inc/ntdef.h"
typedef void ;

#line 218
typedef void ;

#line 266
typedef char ;

#line 267
typedef short ;

#line 268
typedef long ;

#line 276
typedef wchar_t ;

#line 282
typedef WCHAR ;

#line 283
typedef WCHAR ;

#line 284
typedef const WCHAR ;

#line 285
typedef WCHAR ;

#line 286
typedef WCHAR ;

typedef const WCHAR ;

#line 293
typedef CHAR ;

#line 294
typedef CHAR ;

typedef const CHAR ;

#line 297
typedef CHAR ;

#line 298
typedef CHAR ;

#line 299
typedef const CHAR ;

#line 321
typedef char ;

#line 322
typedef unsigned char ;

#line 326
typedef LPSTR ;

#line 327
typedef LPSTR ;

#line 328
typedef LPCSTR ;

#line 337
typedef double ;

typedef struct _QUAD ;

#line 349
typedef SHORT ;

#line 350
typedef LONG ;

#line 351
typedef QUAD ;

#line 360
typedef unsigned char ;

#line 361
typedef unsigned short ;

#line 362
typedef unsigned long ;

#line 363
typedef QUAD ;

#line 369
typedef UCHAR ;

#line 370
typedef USHORT ;

#line 371
typedef ULONG ;

#line 372
typedef UQUAD ;

#line 378
typedef signed char ;

#line 379
typedef SCHAR ;

#line 394
typedef void ;

#line 400
typedef HANDLE ;

#line 406
typedef UCHAR ;

#line 407
typedef USHORT ;

#line 408
typedef ULONG ;

#line 414
typedef LONG ;

#line 478
typedef char ;

#line 479
typedef short ;

#line 480
typedef ULONG ;

typedef CCHAR ;

#line 483
typedef CSHORT ;

#line 484
typedef CLONG ;

#line 492
typedef ULONG ;

#line 493
typedef PULONG ;

#line 494
typedef USHORT ;

#line 500
typedef ULONG ;

#line 501
typedef ULONG ;

#line 508
typedef LONG ;

typedef NTSTATUS ;

#line 602
typedef struct _FLOAT128 ;

#line 607
typedef FLOAT128 ;

#line 621
typedef __int64 ;

#line 622
typedef unsigned __int64 ;

#line 639
typedef LONGLONG ;

#line 640
typedef ULONGLONG ;

#line 644
typedef LONGLONG ;

#line 649
typedef union _LARGE_INTEGER ;

#line 662
typedef LARGE_INTEGER ;

#line 668
typedef union _ULARGE_INTEGER ;

#line 681
typedef ULARGE_INTEGER ;

#line 690
typedef struct _LUID ;

#line 696
typedef ULONGLONG ;

#line 697
typedef DWORDLONG ;

#line 707
typedef LARGE_INTEGER ;

#line 831

#pragma warning(push)

#pragma warning(disable:4035)
__inline ULONGLONG __stdcall Int64ShllMod32___1(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 842
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    
		};
}

#line 845
__inline LONGLONG __stdcall Int64ShraMod32___1(LONGLONG Value , ULONG ShiftCount
	)
{
	#line 852
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    
		};
}

#line 855
__inline ULONGLONG __stdcall Int64ShrlMod32___1(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 862
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    
		};
}


#pragma warning(pop)
#line 956
typedef enum _EVENT_TYPE ;

#line 965
typedef enum _TIMER_TYPE ;

#line 974
typedef enum _WAIT_TYPE ;

#line 983
typedef CHAR ;

#line 984
typedef const char ;

#line 991
typedef struct _STRING ;

#line 999
typedef STRING ;

typedef STRING ;

#line 1002
typedef PSTRING ;

typedef STRING ;

#line 1005
typedef PSTRING ;

#line 1011
typedef struct _CSTRING ;

#line 1016
typedef CSTRING ;

#line 1019
typedef STRING ;

#line 1020
typedef PSTRING ;

#line 1027
typedef struct _UNICODE_STRING ;

#line 1036
typedef UNICODE_STRING ;

#line 1037
typedef const UNICODE_STRING ;

#line 1046
typedef UCHAR ;

#line 1047
typedef BOOLEAN ;

#line 1057
typedef struct _LIST_ENTRY ;

#line 1067
typedef struct _SINGLE_LIST_ENTRY ;

#line 1078
typedef struct LIST_ENTRY32 ;

#line 1082
typedef LIST_ENTRY32 ;

typedef struct LIST_ENTRY64 ;

#line 1088
typedef LIST_ENTRY64 ;

#line 1127
typedef struct _STRING32 ;

#line 1132
typedef STRING32 ;

typedef STRING32 ;

#line 1135
typedef UNICODE_STRING32 ;

typedef STRING32 ;

#line 1138
typedef ANSI_STRING32 ;

#line 1141
typedef struct _STRING64 ;

#line 1146
typedef STRING64 ;

typedef STRING64 ;

#line 1149
typedef UNICODE_STRING64 ;

typedef STRING64 ;

#line 1152
typedef ANSI_STRING64 ;

#line 1173
typedef struct _OBJECT_ATTRIBUTES ;

#line 1181
typedef OBJECT_ATTRIBUTES ;

#line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID ;

#line 70
typedef GUID ;

#line 75
typedef const GUID ;

#line 81
typedef GUID ;

#line 82
typedef IID ;

#line 85
typedef GUID ;

#line 86
typedef CLSID ;

#line 89
typedef GUID ;

#line 90
typedef FMTID ;

#line 16 "C:/NTDDK/inc/string.h"

#pragma once
#line 1233 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECTID ;

#line 1288
struct _CONTEXT ;

#line 1289
struct _EXCEPTION_RECORD ;

typedef EXCEPTION_DISPOSITION ;

#line 1306
typedef UCHAR ;

typedef KIRQL ;

#line 1316
typedef enum _NT_PRODUCT_TYPE ;

#line 1329
typedef enum _SUITE_TYPE ;

#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD ;

#line 76
typedef struct _ETHREAD ;

#line 77
typedef struct _EPROCESS ;

#line 78
typedef struct _PEB ;

#line 79
typedef struct _KINTERRUPT ;

#line 80
typedef struct _IO_TIMER ;

#line 81
typedef struct _OBJECT_TYPE ;

#line 82
typedef struct _CALLBACK_OBJECT ;

#line 83
typedef struct _DEVICE_HANDLER_OBJECT ;

#line 84
typedef struct _BUS_HANDLER ;

#line 143
typedef union _SLIST_HEADER ;

#line 204
typedef CCHAR ;

typedef enum _MODE ;

#line 222
struct _KAPC ;

typedef void ;

#line 232
typedef void ;

#line 242
typedef void ;

#line 248
typedef BOOLEAN ;

#line 254
typedef BOOLEAN ;

#line 265
typedef struct _KAPC ;

#line 292
struct _KDPC ;

typedef void ;

#line 351
typedef enum _KDPC_IMPORTANCE ;

#line 361
typedef struct _KDPC ;

#line 377
typedef PVOID ;

typedef void ;

#line 392
typedef struct _KIPI_COUNTS ;

#line 443
typedef struct _MDL ;

#line 532
typedef PVOID ;

#line 538
typedef PVOID ;

#line 544
typedef PVOID ;

typedef ULONG ;

#line 547
typedef ACCESS_MASK ;

#line 597
typedef struct _GENERIC_MAPPING ;

#line 603
typedef GENERIC_MAPPING ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES ;

#line 622
typedef LUID_AND_ATTRIBUTES ;

#line 623
typedef LUID_AND_ATTRIBUTES_ARRAY ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 642 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACL ;

#line 649
typedef ACL ;

#line 681
typedef struct _PRIVILEGE_SET ;

#line 735
typedef enum _SECURITY_IMPERSONATION_LEVEL ;

#line 753
typedef BOOLEAN ;

#line 762
typedef struct _SECURITY_QUALITY_OF_SERVICE ;

#line 774
typedef struct _SE_IMPERSONATION_STATE ;

#line 782
typedef ULONG ;

#line 809
typedef ULONG ;

#line 810
typedef KAFFINITY ;

#line 816
typedef LONG ;

#line 824
typedef ULONG_PTR ;

#line 825
typedef KSPIN_LOCK ;

#line 833
typedef void ;

#line 842
typedef enum _KPROFILE_SOURCE ;

#line 1079
typedef NTSTATUS ;

#line 1088
typedef struct _RTL_QUERY_REGISTRY_TABLE ;

#line 1952

#pragma warning(push)

#pragma warning(disable:4035)
#line 2019

#pragma warning(pop)
#line 2214
typedef struct _TIME_FIELDS ;

#line 2224
typedef TIME_FIELDS ;

#line 2499
typedef struct _RTL_BITMAP ;

#line 2503
typedef RTL_BITMAP ;

#line 2627
typedef struct _RTL_BITMAP_RUN ;

#line 2633
typedef RTL_BITMAP_RUN ;

#line 2886
typedef struct _RTL_RANGE ;

#line 2924
typedef struct _RTL_RANGE_LIST ;

#line 2950
typedef struct _RANGE_LIST_ITERATOR ;

#line 3019
typedef BOOLEAN ;

#line 3155
typedef struct _OSVERSIONINFOA ;

#line 3164
typedef struct _OSVERSIONINFOW ;

#line 3177
typedef OSVERSIONINFOA ;

#line 3178
typedef POSVERSIONINFOA ;

#line 3179
typedef LPOSVERSIONINFOA ;

#line 3182
typedef struct _OSVERSIONINFOEXA ;

#line 3195
typedef struct _OSVERSIONINFOEXW ;

#line 3213
typedef OSVERSIONINFOEXA ;

#line 3214
typedef POSVERSIONINFOEXA ;

#line 3215
typedef LPOSVERSIONINFOEXA ;

#line 3648
typedef struct _IO_STATUS_BLOCK ;

#line 3669
typedef void ;

#line 3685
typedef enum _FILE_INFORMATION_CLASS ;

#line 3731
typedef struct _FILE_BASIC_INFORMATION ;

#line 3739
typedef struct _FILE_STANDARD_INFORMATION ;

#line 3747
typedef struct _FILE_POSITION_INFORMATION ;

#line 3751
typedef struct _FILE_ALIGNMENT_INFORMATION ;

#line 3755
typedef struct _FILE_NAME_INFORMATION ;

#line 3760
typedef struct _FILE_NETWORK_OPEN_INFORMATION ;

#line 3770
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION ;

#line 3775
typedef struct _FILE_DISPOSITION_INFORMATION ;

#line 3779
typedef struct _FILE_END_OF_FILE_INFORMATION ;

#line 3784
typedef struct _FILE_FULL_EA_INFORMATION ;

#line 3798
typedef enum _FSINFOCLASS ;

#line 3810
typedef struct _FILE_FS_DEVICE_INFORMATION ;

#line 3820
typedef union _FILE_SEGMENT_ELEMENT ;

#line 3829
typedef enum _INTERFACE_TYPE ;

#line 3854
typedef enum _DMA_WIDTH ;

#line 3865
typedef enum _DMA_SPEED ;

#line 3879
typedef void ;

#line 3880
typedef void ;

#line 3888
typedef enum _BUS_DATA_TYPE ;

#line 3910
typedef struct _IO_ERROR_LOG_PACKET ;

#line 3931
typedef struct _IO_ERROR_LOG_MESSAGE ;

#line 4074
typedef struct _KEY_BASIC_INFORMATION ;

#line 4081
typedef struct _KEY_NODE_INFORMATION ;

#line 4091
typedef struct _KEY_FULL_INFORMATION ;

#line 4106
typedef struct _KEY_NAME_INFORMATION ;

#line 4112
typedef enum _KEY_INFORMATION_CLASS ;

#line 4122
typedef struct _KEY_WRITE_TIME_INFORMATION ;

#line 4126
typedef enum _KEY_SET_INFORMATION_CLASS ;

#line 4134
typedef struct _KEY_VALUE_BASIC_INFORMATION ;

#line 4141
typedef struct _KEY_VALUE_FULL_INFORMATION ;

#line 4151
typedef struct _KEY_VALUE_PARTIAL_INFORMATION ;

#line 4158
typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ;

#line 4164
typedef struct _KEY_VALUE_ENTRY ;

#line 4171
typedef enum _KEY_VALUE_INFORMATION_CLASS ;

#line 4210
typedef struct _OBJECT_NAME_INFORMATION ;

#line 4221
typedef enum _SECTION_INHERIT ;

#line 4294
typedef struct _CLIENT_ID ;

#line 4298
typedef CLIENT_ID ;

#line 4315
typedef struct _NT_TIB ;

#line 4327
typedef NT_TIB ;

#line 4332
typedef enum _PROCESSINFOCLASS ;

#line 4366
typedef enum _THREADINFOCLASS ;

#line 4395
typedef struct _PROCESS_WS_WATCH_INFORMATION ;

#line 4405
typedef struct _PROCESS_BASIC_INFORMATION ;

#line 4413
typedef PROCESS_BASIC_INFORMATION ;

#line 4422
typedef struct _PROCESS_DEVICEMAP_INFORMATION ;

#line 4440
typedef struct _PROCESS_SESSION_INFORMATION ;

#line 4454
typedef struct _QUOTA_LIMITS ;

#line 4462
typedef QUOTA_LIMITS ;

#line 4472
typedef struct _IO_COUNTERS ;

#line 4480
typedef IO_COUNTERS ;

#line 4488
typedef struct _VM_COUNTERS ;

#line 4501
typedef VM_COUNTERS ;

#line 4508
typedef struct _POOLED_USAGE_AND_LIMITS ;

#line 4519
typedef POOLED_USAGE_AND_LIMITS ;

#line 4528
typedef struct _PROCESS_ACCESS_TOKEN ;

#line 4555
typedef struct _KERNEL_USER_TIMES ;

#line 4561
typedef KERNEL_USER_TIMES ;

#line 4587
typedef enum _SYSTEM_POWER_STATE ;

#line 4598
typedef enum  {
	PowerActionNone = 0,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
} ;

typedef enum _DEVICE_POWER_STATE ;

#line 4618
typedef union _POWER_STATE ;

#line 4623
typedef enum _POWER_STATE_TYPE ;

#line 4654
typedef ULONG ;

typedef enum  {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
} ;

#line 4663
typedef enum  {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation
} ;

#line 4690
typedef ULONG ;

typedef LONG ;

#line 4693
typedef ULONG ;

#line 4719
typedef union _MCI_STATS ;

#line 4978
typedef struct _KPCR ;

#line 5006
typedef KPCR ;

#line 5012
typedef struct _KFLOATING_SAVE ;

#line 5153
typedef enum _INTERLOCKED_RESULT ;

#line 5252

#pragma warning(disable:4035)
#line 6994
typedef struct _KSYSTEM_TIME ;

#line 7014

#pragma warning(push)

#pragma warning(disable:4164)
#line 7019

#pragma function(_enable)
#line 7020

#pragma function(_disable)
#line 7024

#pragma warning(pop)
#line 7085
typedef struct _FLOATING_SAVE_AREA ;

#line 7097
typedef FLOATING_SAVE_AREA ;

#line 7109
typedef struct _CONTEXT ;

#line 7197
typedef CONTEXT ;

#line 7826
typedef void ;

#line 7850
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ;

#line 7899
typedef struct _KUSER_SHARED_DATA ;

#line 8123
typedef enum _CM_SERVICE_NODE_TYPE ;

#line 8132
typedef enum _CM_SERVICE_LOAD_TYPE ;

#line 8140
typedef enum _CM_ERROR_CONTROL_TYPE ;

#line 8172
typedef int ;

#line 8198
typedef enum _CM_SHARE_DISPOSITION ;

#line 8211
typedef PVOID ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST ;

#line 8443
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR ;

#line 8454
typedef struct _CM_RESOURCE_LIST ;

#line 8471
typedef struct _DEVICE_FLAGS ;

#line 8485
typedef struct _CM_COMPONENT_INFORMATION ;

#line 8503
typedef struct _CM_ROM_BLOCK ;

#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 8518 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_INT13_DRIVE_PARAMETER ;

#line 8532
typedef struct _CM_MCA_POS_DATA ;

#line 8544
typedef struct _EISA_MEMORY_TYPE ;

#line 8554
typedef struct _EISA_MEMORY_CONFIGURATION ;

#line 8567
typedef struct _EISA_IRQ_DESCRIPTOR ;

#line 8575
typedef struct _EISA_IRQ_CONFIGURATION ;

#line 8585
typedef struct _DMA_CONFIGURATION_BYTE0 ;

#line 8592
typedef struct _DMA_CONFIGURATION_BYTE1 ;

#line 8599
typedef struct _EISA_DMA_CONFIGURATION ;

#line 8609
typedef struct _EISA_PORT_DESCRIPTOR ;

#line 8616
typedef struct _EISA_PORT_CONFIGURATION ;

#line 8628
typedef struct _CM_EISA_SLOT_INFORMATION ;

#line 8644
typedef struct _CM_EISA_FUNCTION_INFORMATION ;

#line 8678
typedef struct _CM_PNP_BIOS_DEVICE_NODE ;

#line 8692
typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8761 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_SCSI_DEVICE_DATA ;

#line 8775
typedef struct _CM_VIDEO_DEVICE_DATA ;

#line 8785
typedef struct _CM_SONIC_DEVICE_DATA ;

#line 8796
typedef struct _CM_SERIAL_DEVICE_DATA ;

#line 8810
typedef struct _CM_MONITOR_DEVICE_DATA ;

#line 8844
typedef struct _CM_FLOPPY_DEVICE_DATA ;

#line 8881
typedef struct _CM_KEYBOARD_DEVICE_DATA ;

#line 8893
typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA ;

#line 8905
typedef struct _CM_PCCARD_DEVICE_DATA ;

#line 8944
typedef struct _IO_RESOURCE_DESCRIPTOR ;

#line 9027
typedef struct _IO_RESOURCE_LIST ;

#line 9036
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST ;

#line 9065
typedef struct _EXCEPTION_RECORD ;

#line 9074
typedef EXCEPTION_RECORD ;

typedef struct _EXCEPTION_RECORD32 ;

#line 9085
typedef struct _EXCEPTION_RECORD64 ;

#line 9099
typedef struct _EXCEPTION_POINTERS ;

#line 9111
typedef enum _CONFIGURATION_TYPE ;

#line 9161
typedef enum _KINTERRUPT_MODE ;

#line 9170
typedef enum _KWAIT_REASON ;

#line 9207
typedef struct _DISPATCHER_HEADER ;

#line 9217
typedef struct _KWAIT_BLOCK ;

#line 9230
typedef void ;

#line 9244
typedef struct _KDEVICE_QUEUE ;

#line 9252
typedef struct _KDEVICE_QUEUE_ENTRY ;

#line 9263
typedef struct _KEVENT ;

#line 9271
typedef BOOLEAN ;

#line 9281
typedef struct _KMUTANT ;

#line 9294
typedef struct _KSEMAPHORE ;

#line 9304
typedef struct _KTIMER ;

#line 9899
typedef enum _KBUGCHECK_BUFFER_DUMP_STATE ;

#line 9907
typedef void ;

#line 9914
typedef struct _KBUGCHECK_CALLBACK_RECORD ;

#line 10002
typedef void ;

#line 10020
typedef LOGICAL ;

#line 10037
typedef void ;

#line 10053
typedef enum _MEMORY_CACHING_TYPE_ORIG ;

#line 10057
typedef enum _MEMORY_CACHING_TYPE ;

#line 10087
typedef struct _DBGKD_DEBUG_DATA_HEADER64 ;

#line 10115
typedef enum _POOL_TYPE ;

#line 10195
typedef enum _EX_POOL_PRIORITY ;

#line 10247
typedef struct _FAST_MUTEX ;

#line 10574
typedef PVOID ;

#line 10582
typedef void ;

#line 10588
typedef struct _GENERAL_LOOKASIDE ;

#line 10619
typedef struct _NPAGED_LOOKASIDE_LIST ;

#line 10729
typedef struct _PAGED_LOOKASIDE_LIST ;

#line 10882
typedef enum _WORK_QUEUE_TYPE ;

#line 10889
typedef void ;

#line 10895
typedef struct _WORK_QUEUE_ITEM ;

#line 10926
typedef struct _ZONE_SEGMENT_HEADER ;

#line 10931
typedef struct _ZONE_HEADER ;

#line 11156
typedef ULONG_PTR ;

#line 11157
typedef ERESOURCE_THREAD ;

typedef struct _OWNER_ENTRY ;

#line 11168
typedef struct _ERESOURCE ;

#line 11197
typedef struct _RESOURCE_HASH_ENTRY ;

#line 11204
typedef struct _RESOURCE_PERFORMANCE_DATA ;

#line 11429
typedef struct _CALLBACK_OBJECT ;

typedef void ;

#line 11474
typedef GUID ;

#line 11862
typedef enum _MM_SYSTEM_SIZE ;

#line 11884
typedef enum _LOCK_OPERATION ;

#line 11970
typedef enum _MM_PAGE_PRIORITY ;

#line 11999
typedef struct _PHYSICAL_MEMORY_RANGE ;

#line 12385
typedef NTSTATUS ;

#line 12389
typedef NTSTATUS ;

#line 12399
struct _DRIVER_OBJECT ;

#line 12411
typedef enum _SECURITY_OPERATION_CODE ;

#line 12426
typedef struct _SECURITY_SUBJECT_CONTEXT ;

#line 12448
typedef struct _INITIAL_PRIVILEGE_SET ;

#line 12462
typedef struct _ACCESS_STATE ;

#line 12571
typedef void ;

#line 12585
typedef void ;

#line 12602
typedef struct _IMAGE_INFO ;

#line 12620
typedef void ;

#line 12859
typedef NTSTATUS ;

#line 12878
typedef enum _IO_QUERY_DEVICE_DATA_FORMAT ;

#line 12890
typedef enum _CREATE_FILE_TYPE ;

#line 12905
struct _DEVICE_DESCRIPTION ;

#line 12906
struct _DEVICE_OBJECT ;

#line 12907
struct _DMA_ADAPTER ;

#line 12908
struct _DRIVER_OBJECT ;

#line 12909
struct _DRIVE_LAYOUT_INFORMATION ;

#line 12910
struct _DISK_PARTITION ;

#line 12911
struct _FILE_OBJECT ;

#line 12912
struct _IRP ;

#line 12913
struct _SCSI_REQUEST_BLOCK ;

#line 12919
typedef void ;

#line 12932
typedef void ;

#line 12943
typedef NTSTATUS ;

#line 12955
typedef void ;

#line 12968
typedef void ;

#line 12979
typedef NTSTATUS ;

#line 12990
typedef void ;

#line 13001
typedef void ;

#line 13011
typedef NTSTATUS ;

#line 13025
typedef BOOLEAN ;

#line 13038
typedef BOOLEAN ;

#line 13051
typedef BOOLEAN ;

#line 13068
typedef BOOLEAN ;

#line 13078
typedef BOOLEAN ;

#line 13092
typedef BOOLEAN ;

#line 13106
typedef BOOLEAN ;

#line 13118
typedef BOOLEAN ;

#line 13127
typedef BOOLEAN ;

#line 13141
typedef BOOLEAN ;

#line 13161
typedef void ;

#line 13167
typedef void ;

#line 13179
typedef void ;

#line 13193
typedef BOOLEAN ;

#line 13207
typedef BOOLEAN ;

#line 13219
typedef BOOLEAN ;

#line 13227
typedef BOOLEAN ;

#line 13239
typedef BOOLEAN ;

#line 13253
typedef NTSTATUS ;

#line 13262
typedef NTSTATUS ;

#line 13275
typedef NTSTATUS ;

#line 13282
typedef NTSTATUS ;

#line 13289
typedef BOOLEAN ;

#line 13304
typedef BOOLEAN ;

#line 13319
typedef BOOLEAN ;

#line 13327
typedef BOOLEAN ;

#line 13336
typedef BOOLEAN ;

#line 13350
typedef struct _FAST_IO_DISPATCH ;

#line 13386
typedef enum _IO_ALLOCATION_ACTION ;

#line 13396
typedef IO_ALLOCATION_ACTION ;

#line 13410
typedef struct _IO_SECURITY_CONTEXT ;

#line 13434
typedef struct _VPB ;

#line 13482
typedef struct _ADAPTER_OBJECT ;

#line 13491
typedef struct _WAIT_CONTEXT_BLOCK ;

#line 13503
typedef struct _CONTROLLER_OBJECT ;

#line 13537
typedef struct _DEVICE_OBJECT ;

#line 13575
typedef struct _DEVICE_OBJECT ;

#line 13578
struct _DEVICE_OBJECT_POWER_EXTENSION ;

typedef struct _DEVOBJ_EXTENSION ;

#line 13608
typedef struct _DRIVER_EXTENSION ;

#line 13645
typedef struct _DRIVER_OBJECT ;

#line 13706
typedef struct _DRIVER_OBJECT ;

#line 13715
typedef struct _SECTION_OBJECT_POINTERS ;

#line 13720
typedef SECTION_OBJECT_POINTERS ;

#line 13726
typedef struct _IO_COMPLETION_CONTEXT ;

#line 13759
typedef struct _FILE_OBJECT ;

#line 13788
typedef struct _FILE_OBJECT ;

#line 13828
typedef struct _IRP ;

#line 14078
typedef NTSTATUS ;

#line 14163
typedef enum _DEVICE_RELATION_TYPE ;

#line 14171
typedef struct _DEVICE_RELATIONS ;

#line 14176
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE ;

#line 14185
typedef struct _INTERFACE ;

#line 14196
typedef struct _DEVICE_CAPABILITIES ;

#line 14229
typedef struct _POWER_SEQUENCE ;

#line 14235
typedef enum  {
	BusQueryDeviceID = 0,
	BusQueryHardwareIDs = 1,
	BusQueryCompatibleIDs = 2,
	BusQueryInstanceID = 3,
	BusQueryDeviceSerialNumber = 4
} ;

typedef ULONG ;

#line 14252
typedef enum  {
	DeviceTextDescription = 0,
	DeviceTextLocationInformation = 1
} ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 14615 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SHARE_ACCESS ;

#line 14635
typedef struct _CONFIGURATION_INFORMATION ;

#line 14848
typedef struct _BOOTDISK_INFORMATION ;

#line 15754
typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK ;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK ;

#line 15764
typedef struct _IO_REMOVE_LOCK_DBG_BLOCK ;

#line 15777
typedef struct _IO_REMOVE_LOCK ;

#line 16009
typedef struct _IO_WORKITEM ;

typedef void ;

#line 16100
typedef enum  {
	DevicePropertyDeviceDescription,
	DevicePropertyHardwareID,
	DevicePropertyCompatibleIDs,
	DevicePropertyBootConfiguration,
	DevicePropertyBootConfigurationTranslated,
	DevicePropertyClassName,
	DevicePropertyClassGuid,
	DevicePropertyDriverKeyName,
	DevicePropertyManufacturer,
	DevicePropertyFriendlyName,
	DevicePropertyLocationInformation,
	DevicePropertyPhysicalDeviceObjectName,
	DevicePropertyBusTypeGuid,
	DevicePropertyLegacyBusType,
	DevicePropertyBusNumber,
	DevicePropertyEnumeratorName,
	DevicePropertyAddress,
	DevicePropertyUINumber
} ;

typedef BOOLEAN ;

#line 16129
typedef struct _DMA_ADAPTER ;

#line 16135
typedef ULONG ;

#line 16148
typedef struct _PNP_BUS_INFORMATION ;

#line 16162
typedef struct _LEGACY_BUS_INFORMATION ;

#line 16168
typedef struct _BUS_INTERFACE_STANDARD ;

#line 16190
typedef BOOLEAN ;

#line 16194
typedef NTSTATUS ;

#line 16203
typedef NTSTATUS ;

#line 16206
typedef NTSTATUS ;

#line 16210
typedef NTSTATUS ;

#line 16214
typedef NTSTATUS ;

#line 16218
typedef void ;

#line 16222
typedef NTSTATUS ;

#line 16227
typedef void ;

#line 16231
typedef struct _ACPI_INTERFACE_STANDARD ;

#line 16255
typedef enum _ACPI_REG_TYPE ;

#line 16268
typedef USHORT ;

#line 16272
typedef void ;

#line 16278
typedef struct ACPI_REGS_INTERFACE_STANDARD ;

#line 16300
typedef struct  {
	PVOID LinkNode ;
	ULONG StaticVector ;
	UCHAR Flags ;
} ;

#line 16314
typedef NTSTATUS ;

#line 16329
typedef NTSTATUS ;

#line 16336
typedef void ;

#line 16343
typedef struct _INT_ROUTE_INTERFACE_STANDARD ;

#line 16366
typedef struct _IO_ASSIGNED_RESOURCES ;

#line 16490
typedef enum _IO_NOTIFICATION_EVENT_CATEGORY ;

#line 16504
typedef NTSTATUS ;

#line 16537
typedef void ;

#line 16573
typedef enum _ARBITER_ACTION ;

#line 16586
typedef struct _ARBITER_CONFLICT_INFO ;

#line 16608
typedef struct _ARBITER_PARAMETERS ;

#line 16719
typedef enum _ARBITER_REQUEST_SOURCE ;

#line 16731
typedef enum _ARBITER_RESULT ;

#line 16761
typedef struct _ARBITER_LIST_ENTRY ;

#line 16832
typedef NTSTATUS ;

#line 16853
typedef struct _ARBITER_INTERFACE ;

#line 16880
typedef enum _RESOURCE_TRANSLATION_DIRECTION ;

#line 16889
typedef NTSTATUS ;

#line 16901
typedef NTSTATUS ;

#line 16915
typedef struct _TRANSLATOR_INTERFACE ;

#line 16931
typedef NTSTATUS ;

#line 16945
typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE ;

#line 16959
typedef struct _PLUGPLAY_NOTIFICATION_HEADER ;

#line 16972
typedef struct _HWPROFILE_CHANGE_NOTIFICATION ;

#line 16986
typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION ;

#line 17006
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION ;

#line 17026
typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION ;

#line 17054
typedef struct _DEVICE_DESCRIPTION ;

#line 17086
typedef BOOLEAN ;

#line 17333
typedef void ;

#line 17339
typedef struct _DEVICE_CONTROL_CONTEXT ;

#line 17349
typedef PBUS_HANDLER ;

#line 17355
typedef void ;

#line 17365
typedef enum _HAL_QUERY_INFORMATION_CLASS ;

#line 17381
typedef enum _HAL_SET_INFORMATION_CLASS ;

#line 17388
typedef NTSTATUS ;

#line 17405
typedef NTSTATUS ;

#line 17420
typedef void ;

#line 17429
typedef void ;

#line 17438
typedef NTSTATUS ;

#line 17447
typedef NTSTATUS ;

#line 17456
typedef NTSTATUS ;

#line 17466
typedef NTSTATUS ;

#line 17475
typedef NTSTATUS ;

#line 17486
typedef struct _PM_DISPATCH_TABLE ;

#line 17492
typedef NTSTATUS ;

#line 17505
typedef struct _DMA_ADAPTER ;

#line 17520
typedef NTSTATUS ;

#line 17543
typedef BOOLEAN ;

#line 17553
typedef NTSTATUS ;

#line 17566
typedef void ;

#line 17572
typedef void ;

#line 17578
typedef BOOLEAN ;

#line 17588
typedef struct  {
	ULONG Version ;
	pHalQuerySystemInformation HalQuerySystemInformation ;
	pHalSetSystemInformation HalSetSystemInformation ;
	pHalQueryBusSlots HalQueryBusSlots ;
	ULONG Spare1 ;
	pHalExamineMBR HalExamineMBR ;
	pHalIoAssignDriveLetters HalIoAssignDriveLetters ;
	pHalIoReadPartitionTable HalIoReadPartitionTable ;
	pHalIoSetPartitionInformation HalIoSetPartitionInformation ;
	pHalIoWritePartitionTable HalIoWritePartitionTable ;
	pHalHandlerForBus HalReferenceHandlerForBus ;
	pHalReferenceBusHandler HalReferenceBusHandler ;
	pHalReferenceBusHandler HalDereferenceBusHandler ;
	pHalInitPnpDriver HalInitPnpDriver ;
	pHalInitPowerManagement HalInitPowerManagement ;
	pHalGetDmaAdapter HalGetDmaAdapter ;
	pHalGetInterruptTranslator HalGetInterruptTranslator ;
} ;

#line 17650
typedef struct _HAL_BUS_INFORMATION ;

#line 17658
typedef struct _HAL_PROFILE_SOURCE_INFORMATION ;

#line 17665
typedef struct _HAL_PROFILE_SOURCE_INTERVAL ;

#line 17671
typedef enum _HAL_DISPLAY_BIOS_INFORMATION ;

#line 17678
typedef struct _HAL_POWER_INFORMATION ;

#line 17683
typedef struct _HAL_PROCESSOR_SPEED_INFO ;

#line 17688
typedef struct _HAL_CALLBACKS ;

#line 17694
typedef struct _HAL_PROCESSOR_FEATURE ;

#line 17706
typedef union _MCI_ADDR ;

#line 17716
typedef enum  {
	HAL_MCE_RECORD,
	HAL_MCA_RECORD
} ;

#line 17726
typedef struct _MCA_EXCEPTION ;

#line 17752
typedef void ;

#line 17762
typedef struct _MCA_DRIVER_INFO ;

#line 17772
typedef struct _SCATTER_GATHER_ELEMENT ;

#line 17778

#pragma warning(disable:4200)
#line 17779
typedef struct _SCATTER_GATHER_LIST ;

#line 17784

#pragma warning(default:4200)
#line 17788
typedef struct _DMA_OPERATIONS ;

typedef struct _DMA_ADAPTER ;

#line 17797
typedef void ;

#line 17801
typedef PVOID ;

#line 17808
typedef void ;

#line 17816
typedef NTSTATUS ;

#line 17824
typedef BOOLEAN ;

#line 17833
typedef void ;

#line 17837
typedef void ;

#line 17843
typedef PHYSICAL_ADDRESS ;

#line 17852
typedef ULONG ;

#line 17856
typedef ULONG ;

#line 17860
typedef void ;

#line 17868
typedef NTSTATUS ;

#line 17880
typedef void ;

#line 17887
typedef struct _DMA_OPERATIONS ;

#line 18235
typedef void ;

#line 18321
typedef struct _OBJECT_HANDLE_INFORMATION ;

#line 18402
typedef struct _PCI_SLOT_NUMBER ;

#line 18418
typedef struct _PCI_COMMON_CONFIG ;

#line 18591
typedef struct _PCI_CAPABILITIES_HEADER ;

#line 18600
typedef struct _PCI_PMC ;

#line 18618
typedef struct _PCI_PMCSR ;

#line 18628
typedef struct _PCI_PMCSR_BSE ;

#line 18635
typedef struct _PCI_PM_CAPABILITY ;

#line 18679
typedef struct _PCI_AGP_CAPABILITY ;

#line 18720
typedef struct _PCI_MSI_CAPABILITY ;

#line 18946
typedef void ;

#line 18954
typedef void ;

#line 18963
typedef void ;

#line 18975
typedef struct _PCIBUSDATA ;

#line 18986
typedef ULONG ;

#line 18995
typedef void ;

#line 19000
typedef void ;

#line 19006
typedef struct _PCI_BUS_INTERFACE_STANDARD ;

#line 19028
typedef BOOLEAN ;

#line 19043
typedef struct _PCI_DEVICE_PRESENT_INTERFACE ;

#line 127 "C:/NTDDK/inc/ntddser.h"
typedef struct _SERIALPERF_STATS ;

#line 136
typedef struct _SERIALCONFIG ;

#line 154
typedef struct _SERIAL_LINE_CONTROL ;

#line 160
typedef struct _SERIAL_TIMEOUTS ;

#line 175
typedef struct _SERIAL_QUEUE_SIZE ;

#line 185
typedef struct _SERIAL_BAUD_RATE ;

#line 247
typedef struct _SERIAL_CHARS ;

#line 284
typedef struct _SERIAL_HANDFLOW ;

#line 340
typedef struct _SERIAL_BASIC_SETTINGS ;

#line 353
typedef struct _SERIAL_STATUS ;

#line 433
typedef struct _SERIAL_XOFF_COUNTER ;

#line 539
typedef struct _SERIAL_COMMPROP ;

#line 631
typedef struct _SERENUM_PORT_DESC ;

#line 652
typedef UCHAR ;

#line 658
typedef void ;

#line 665
typedef enum _SERENUM_PORTION ;

#line 671
typedef struct _SERENUM_PORT_PARAMETERS ;

#line 28 "C:/NTDDK/inc/ddk/wdm/wmilib.h"

#pragma once
#line 38
typedef struct  {
	LPCGUID Guid ;
	ULONG InstanceCount ;
	ULONG Flags ;
} ;

#line 45
typedef NTSTATUS ;

#line 101
typedef NTSTATUS ;

#line 162
typedef NTSTATUS ;

#line 206
typedef NTSTATUS ;

#line 253
typedef NTSTATUS ;

#line 306
typedef enum  {
	WmiEventControl,
	WmiDataBlockControl
} ;

#line 312
typedef NTSTATUS ;

#line 355
typedef struct _WMILIB_CONTEXT ;

#line 411
typedef enum  {
	IrpProcessed,
	IrpNotCompleted,
	IrpNotWmi,
	IrpForward
} ;

#line 13 "C:/NTDDK/inc/wmidata.h"
typedef struct _MSWmi_MofData ;

#line 51
typedef struct _MSWmi_ProviderInfo ;

#line 66
typedef struct _MSWmi_PnPDeviceId ;

#line 83
typedef struct _MSWmi_PnPInstanceNames ;

#line 105
typedef struct _MSSmBios_RawSMBiosTables ;

#line 147
typedef struct _MSPower_DeviceEnable ;

#line 165
typedef struct _MSPower_DeviceWakeEnable ;

#line 182
typedef struct _MSNdis_NetworkAddress ;

#line 199
typedef struct _MSNdis_NetworkShortAddress ;

#line 216
typedef struct _MSNdis_NetworkLinkSpeed ;

#line 239
typedef struct _MSNdis_EnumerateAdapter ;

#line 256
typedef struct _MSNdis_NotifyAdapterRemoval ;

#line 273
typedef struct _MSNdis_NotifyAdapterArrival ;

#line 291
typedef struct _MSNdis_NdisEnumerateVc ;

#line 307
typedef struct _MSNdis_NotifyVcRemoval ;

#line 323
typedef struct _MSNdis_NotifyVcArrival ;

#line 338
typedef struct _MSNdis_HardwareStatus ;

#line 356
typedef struct _MSNdis_MediaSupported ;

#line 378
typedef struct _MSNdis_MediaInUse ;

#line 400
typedef struct _MSNdis_MaximumLookahead ;

#line 418
typedef struct _MSNdis_MaximumFrameSize ;

#line 436
typedef struct _MSNdis_LinkSpeed ;

#line 454
typedef struct _MSNdis_TransmitBufferSpace ;

#line 472
typedef struct _MSNdis_ReceiveBufferSpace ;

#line 490
typedef struct _MSNdis_TransmitBlockSize ;

#line 508
typedef struct _MSNdis_ReceiveBlockSize ;

#line 526
typedef struct _MSNdis_VendorID ;

#line 544
typedef struct _MSNdis_VendorDescription ;

#line 561
typedef struct _MSNdis_CurrentPacketFilter ;

#line 579
typedef struct _MSNdis_CurrentLookahead ;

#line 597
typedef struct _MSNdis_DriverVersion ;

#line 615
typedef struct _MSNdis_MaximumTotalSize ;

#line 633
typedef struct _MSNdis_MacOptions ;

#line 651
typedef struct _MSNdis_MediaConnectStatus ;

#line 669
typedef struct _MSNdis_MaximumSendPackets ;

#line 687
typedef struct _MSNdis_VendorDriverVersion ;

#line 705
typedef struct _MSNdis_TransmitsOk ;

#line 723
typedef struct _MSNdis_ReceivesOk ;

#line 741
typedef struct _MSNdis_TransmitsError ;

#line 759
typedef struct _MSNdis_ReceiveError ;

#line 777
typedef struct _MSNdis_ReceiveNoBuffer ;

#line 795
typedef struct _MSNdis_CoHardwareStatus ;

#line 813
typedef struct _MSNdis_CoMediaSupported ;

#line 835
typedef struct _MSNdis_CoMediaInUse ;

#line 857
typedef struct _MSNdis_CoLinkSpeed ;

#line 875
typedef struct _MSNdis_CoVendorId ;

#line 893
typedef struct _MSNdis_CoVendorDescription ;

#line 910
typedef struct _MSNdis_CoDriverVersion ;

#line 928
typedef struct _MSNdis_CoMacOptions ;

#line 946
typedef struct _MSNdis_CoMediaConnectStatus ;

#line 964
typedef struct _MSNdis_CoVendorDriverVersion ;

#line 982
typedef struct _MSNdis_CoMinimumLinkSpeed ;

#line 1000
typedef struct _MSNdis_CoTransmitPdusOk ;

#line 1018
typedef struct _MSNdis_CoReceivePdusOk ;

#line 1036
typedef struct _MSNdis_CoTransmitPduErrors ;

#line 1054
typedef struct _MSNdis_CoReceivePduErrors ;

#line 1072
typedef struct _MSNdis_CoReceivePdusNoBuffer ;

#line 1090
typedef struct _MSNdis_AtmSupportedVcRates ;

#line 1113
typedef struct _MSNdis_AtmSupportedServiceCategory ;

#line 1131
typedef struct _MSNdis_AtmSupportedAalTypes ;

#line 1149
typedef struct _MSNdis_AtmHardwareCurrentAddress ;

#line 1167
typedef struct _MSNdis_AtmMaxActiveVcs ;

#line 1185
typedef struct _MSNdis_AtmMaxActiveVciBits ;

#line 1203
typedef struct _MSNdis_AtmMaxActiveVpiBits ;

#line 1221
typedef struct _MSNdis_AtmMaxAal0PacketSize ;

#line 1239
typedef struct _MSNdis_AtmMaxAal1PacketSize ;

#line 1257
typedef struct _MSNdis_AtmMaxAal34PacketSize ;

#line 1275
typedef struct _MSNdis_AtmMaxAal5PacketSize ;

#line 1293
typedef struct _MSNdis_AtmReceiveCellsOk ;

#line 1311
typedef struct _MSNdis_AtmTransmitCellsOk ;

#line 1329
typedef struct _MSNdis_AtmReceiveCellsDropped ;

#line 1347
typedef struct _MSNdis_EthernetPermanentAddress ;

#line 1365
typedef struct _MSNdis_EthernetCurrentAddress ;

#line 1383
typedef struct _MSNdis_EthernetMulticastList ;

#line 1405
typedef struct _MSNdis_EthernetMaximumMulticastListSize ;

#line 1423
typedef struct _MSNdis_EthernetMacOptions ;

#line 1441
typedef struct _MSNdis_EthernetReceiveErrorAlignment ;

#line 1459
typedef struct _MSNdis_EthernetOneTransmitCollision ;

#line 1477
typedef struct _MSNdis_EthernetMoreTransmitCollisions ;

#line 1495
typedef struct _MSNdis_TokenRingPermanentAddress ;

#line 1513
typedef struct _MSNdis_TokenRingCurrentAddress ;

#line 1531
typedef struct _MSNdis_TokenRingCurrentFunctional ;

#line 1549
typedef struct _MSNdis_TokenRingCurrentGroup ;

#line 1567
typedef struct _MSNdis_TokenRingLastOpenStatus ;

#line 1585
typedef struct _MSNdis_TokenRingCurrentRingStatus ;

#line 1603
typedef struct _MSNdis_TokenRingCurrentRingState ;

#line 1621
typedef struct _MSNdis_TokenRingLineErrors ;

#line 1639
typedef struct _MSNdis_TokenRingLostFrames ;

#line 1657
typedef struct _MSNdis_FddiLongPermanentAddress ;

#line 1675
typedef struct _MSNdis_FddiLongCurrentAddress ;

#line 1693
typedef struct _MSNdis_FddiLongMulticastList ;

#line 1715
typedef struct _MSNdis_FddiLongMaximumListSize ;

#line 1733
typedef struct _MSNdis_FddiShortPermanentAddress ;

#line 1751
typedef struct _MSNdis_FddiShortCurrentAddress ;

#line 1769
typedef struct _MSNdis_FddiShortMulticastList ;

#line 1791
typedef struct _MSNdis_FddiShortMaximumListSize ;

#line 1809
typedef struct _MSNdis_FddiAttachmentType ;

#line 1827
typedef struct _MSNdis_FddiUpstreamNodeLong ;

#line 1845
typedef struct _MSNdis_FddiDownstreamNodeLong ;

#line 1863
typedef struct _MSNdis_FddiFrameErrors ;

#line 1881
typedef struct _MSNdis_FddiFramesLost ;

#line 1899
typedef struct _MSNdis_FddiRingManagmentState ;

#line 1917
typedef struct _MSNdis_FddiLctFailures ;

#line 1935
typedef struct _MSNdis_FddiLemRejects ;

#line 1953
typedef struct _MSNdis_FddiLConnectionState ;

#line 1972
typedef struct _MSNdis_StatusResetStart ;

#line 1988
typedef struct _MSNdis_StatusResetEnd ;

#line 2004
typedef struct _MSNdis_StatusMediaConnect ;

#line 2020
typedef struct _MSNdis_StatusMediaDisconnect ;

#line 2035
typedef struct _MSNdis_StatusMediaSpecificIndication ;

#line 2057
typedef struct _MSNdis_StatusLinkSpeedChange ;

#line 2075
typedef struct _MSNdis_StatusProtocolBind ;

#line 2092
typedef struct _MSNdis_StatusProtocolUnbind ;

#line 2109
typedef struct _KEYBOARD_PORT_WMI_STD_DATA ;

#line 2152
typedef struct _POINTER_PORT_WMI_STD_DATA ;

#line 2205
typedef struct _MSMouse_ClassInformation ;

#line 2223
typedef struct _MSKeyboard_ClassInformation ;

#line 2241
typedef struct _MSAcpi_ThermalZoneTemperature ;

#line 2304
typedef struct _WMI_DISK_GEOMETRY ;

#line 2342
typedef struct _WMI_DISK_PERFORMANCE ;

#line 2415
typedef struct _MSDiskDriver_Performance ;

#line 2437
typedef struct _STORAGE_FAILURE_PREDICT_STATUS ;

#line 2460
typedef struct _STORAGE_FAILURE_PREDICT_DATA ;

#line 2483
typedef struct _STORAGE_FAILURE_PREDICT_EVENT ;

#line 2513
typedef struct _STORAGE_FAILURE_PREDICT_FUNCTION ;

#line 2528
typedef struct _MSIde_PortDeviceInfo ;

#line 2556
typedef struct _MSSerial_PortName ;

#line 2573
typedef struct _SERIAL_WMI_COMM_DATA ;

#line 2723
typedef struct _SERIAL_WMI_HW_DATA ;

#line 2770
typedef struct _SERIAL_WMI_PERF_DATA ;

#line 2813
typedef struct _SERIAL_WMI_COMMPROP ;

#line 2920
typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS ;

#line 2943
typedef struct _PARALLEL_WMI_LOG_INFO ;

#line 3041
typedef struct _REDBOOK_WMI_STD_DATA ;

#line 3094
typedef struct _REDBOOK_WMI_PERF_DATA ;

#line 3137
typedef struct _RegisteredGuids ;

#line 475 "serial.h"
typedef struct _CONFIG_DATA ;

#line 509
typedef struct _SERIAL_CISR_SW ;

#line 520
typedef struct _SERIAL_FIRMWARE_DATA ;

#line 576
typedef struct _SERIAL_DEVICE_STATE ;

#line 646
typedef struct _SERIAL_DEVICE_EXTENSION ;

#line 1808
typedef struct _SERIAL_MULTIPORT_DISPATCH ;

#line 2157
typedef enum _SERIAL_MEM_COMPARES ;

#line 2164
typedef struct _SERIAL_LIST_DATA ;

#line 2169
typedef struct _SERIAL_GLOBALS ;

#line 2180
typedef struct _SERIAL_USER_DATA ;

#line 2206
typedef struct _SERIAL_PTR_CTX ;

#line 20 "serialp.h"
typedef NTSTATUS ;

#line 26
typedef void ;

#line 835
typedef struct _SERIAL_UPDATE_CHAR ;

#line 846
typedef struct _SERIAL_IOCTL_SYNC ;

#line 29 "flush.c"
NTSTATUS SerialStartFlush(PSERIAL_DEVICE_EXTENSION Extension ) ;

#line 35

#pragma alloc_text(PAGESRP0, SerialFlush)
#line 36

#pragma alloc_text(PAGESRP0, SerialStartFlush)
#line 40
NTSTATUS SerialFlush(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
	#line 69
	PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
	NTSTATUS status ;
	;
	#line 76
	do
	{
		#line 76
		;
	}
	while(0);
	#line 78
	do
	{
		#line 78
		;
	}
	while(0);
	#line 82
	(Irp->IoStatus).Information = 0L;
	#line 84
	if((status = SerialIRPPrologue(Irp, Extension)) == (NTSTATUS
		)0x00000000L)
	{
		#line 86
		if(SerialCompleteIfError(DeviceObject, Irp) != (NTSTATUS
			)0x00000000L)
		{
			#line 87
			do
			{
				#line 87
				;
			}
			while(0);
			#line 89
			return (NTSTATUS )0xC0000120L;
		}
		#line 93
		do
		{
			#line 93
			;
		}
		while(0);
		#line 95
		return SerialStartOrQueue(Extension, Irp, &
			Extension->WriteQueue, & Extension->CurrentWriteIrp,
			SerialStartFlush);
	}
	else
	{
		#line 99
		(Irp->IoStatus).Status = status;
		#line 101
		if(! ((NTSTATUS )status >= 0))
		{
			{
				#line 102
				IofCompleteRequest(Irp, 0);
				#line 102
				SerialIRPEpilogue(Extension);
			}
			#line 102
			;
		}
		#line 105
		do
		{
			#line 105
			;
		}
		while(0);
		#line 106
		return status;
	}
}

#line 111
NTSTATUS SerialStartFlush(PSERIAL_DEVICE_EXTENSION Extension )
{
	#line 138
	PIRP NewIrp ;
	;
	#line 141
	((Extension->CurrentWriteIrp)->IoStatus).Status = (NTSTATUS
		)0x00000000L;
	#line 147
	SerialGetNextWrite(& Extension->CurrentWriteIrp, &
		Extension->WriteQueue, & NewIrp, 1, Extension);
	#line 155
	if(NewIrp)
	{
		;
		SerialStartWrite(Extension);
	}
	#line 162
	return (NTSTATUS )0x00000000L;
}

#line 16 "C:/NTDDK/inc/stddef.h"

#pragma once
#line 77
typedef int ;

#line 86
typedef unsigned int ;

#line 95
typedef int ;

#line 105
typedef unsigned int ;

#line 112
typedef unsigned short ;

#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"

#pragma once
#line 32

#pragma pack(push, 8)
#line 72
typedef enum _EXCEPTION_DISPOSITION ;

#line 89
struct _EXCEPTION_RECORD ;

#line 90
struct _CONTEXT ;

#line 155

#pragma pack(pop)
#line 25 "C:/NTDDK/inc/ntdef.h"

#pragma once
#line 15 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"

#pragma once
#line 66
typedef wchar_t ;

#line 67
typedef wchar_t ;

#line 127 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long ;

#line 25 "C:/NTDDK/inc/basetsd.h"

#pragma once
#line 36
typedef int ;

#line 37
typedef int ;

#line 43
typedef unsigned int ;

#line 44
typedef unsigned int ;

#line 45
typedef unsigned int ;

#line 84
typedef int ;

#line 85
typedef unsigned int ;

typedef long ;

#line 88
typedef unsigned long ;

#line 248
typedef unsigned short ;

#line 249
typedef short ;

#line 250
typedef unsigned long ;

#line 288
typedef ULONG_PTR ;

#line 289
typedef LONG_PTR ;

#line 295
typedef ULONG_PTR ;

#line 301
typedef __int64 ;

#line 302
typedef __int64 ;

#line 309
typedef unsigned __int64 ;

#line 310
typedef unsigned __int64 ;

#line 311
typedef unsigned __int64 ;

#line 217 "C:/NTDDK/inc/ntdef.h"
typedef void ;

#line 218
typedef void ;

#line 266
typedef char ;

#line 267
typedef short ;

#line 268
typedef long ;

#line 276
typedef wchar_t ;

#line 282
typedef WCHAR ;

#line 283
typedef WCHAR ;

#line 284
typedef const WCHAR ;

#line 285
typedef WCHAR ;

#line 286
typedef WCHAR ;

typedef const WCHAR ;

#line 293
typedef CHAR ;

#line 294
typedef CHAR ;

typedef const CHAR ;

#line 297
typedef CHAR ;

#line 298
typedef CHAR ;

#line 299
typedef const CHAR ;

#line 321
typedef char ;

#line 322
typedef unsigned char ;

#line 326
typedef LPSTR ;

#line 327
typedef LPSTR ;

#line 328
typedef LPCSTR ;

#line 337
typedef double ;

typedef struct _QUAD ;

#line 349
typedef SHORT ;

#line 350
typedef LONG ;

#line 351
typedef QUAD ;

#line 360
typedef unsigned char ;

#line 361
typedef unsigned short ;

#line 362
typedef unsigned long ;

#line 363
typedef QUAD ;

#line 369
typedef UCHAR ;

#line 370
typedef USHORT ;

#line 371
typedef ULONG ;

#line 372
typedef UQUAD ;

#line 378
typedef signed char ;

#line 379
typedef SCHAR ;

#line 394
typedef void ;

#line 400
typedef HANDLE ;

#line 406
typedef UCHAR ;

#line 407
typedef USHORT ;

#line 408
typedef ULONG ;

#line 414
typedef LONG ;

#line 478
typedef char ;

#line 479
typedef short ;

#line 480
typedef ULONG ;

typedef CCHAR ;

#line 483
typedef CSHORT ;

#line 484
typedef CLONG ;

#line 492
typedef ULONG ;

#line 493
typedef PULONG ;

#line 494
typedef USHORT ;

#line 500
typedef ULONG ;

#line 501
typedef ULONG ;

#line 508
typedef LONG ;

typedef NTSTATUS ;

#line 602
typedef struct _FLOAT128 ;

#line 607
typedef FLOAT128 ;

#line 621
typedef __int64 ;

#line 622
typedef unsigned __int64 ;

#line 639
typedef LONGLONG ;

#line 640
typedef ULONGLONG ;

#line 644
typedef LONGLONG ;

#line 649
typedef union _LARGE_INTEGER ;

#line 662
typedef LARGE_INTEGER ;

#line 668
typedef union _ULARGE_INTEGER ;

#line 681
typedef ULARGE_INTEGER ;

#line 690
typedef struct _LUID ;

#line 696
typedef ULONGLONG ;

#line 697
typedef DWORDLONG ;

#line 707
typedef LARGE_INTEGER ;

#line 831

#pragma warning(push)

#pragma warning(disable:4035)
__inline ULONGLONG __stdcall Int64ShllMod32___2(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 842
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    
		};
}

#line 845
__inline LONGLONG __stdcall Int64ShraMod32___2(LONGLONG Value , ULONG ShiftCount
	)
{
	#line 852
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    
		};
}

#line 855
__inline ULONGLONG __stdcall Int64ShrlMod32___2(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 862
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    
		};
}


#pragma warning(pop)
#line 956
typedef enum _EVENT_TYPE ;

#line 965
typedef enum _TIMER_TYPE ;

#line 974
typedef enum _WAIT_TYPE ;

#line 983
typedef CHAR ;

#line 984
typedef const char ;

#line 991
typedef struct _STRING ;

#line 999
typedef STRING ;

typedef STRING ;

#line 1002
typedef PSTRING ;

typedef STRING ;

#line 1005
typedef PSTRING ;

#line 1011
typedef struct _CSTRING ;

#line 1016
typedef CSTRING ;

#line 1019
typedef STRING ;

#line 1020
typedef PSTRING ;

#line 1027
typedef struct _UNICODE_STRING ;

#line 1036
typedef UNICODE_STRING ;

#line 1037
typedef const UNICODE_STRING ;

#line 1046
typedef UCHAR ;

#line 1047
typedef BOOLEAN ;

#line 1057
typedef struct _LIST_ENTRY ;

#line 1067
typedef struct _SINGLE_LIST_ENTRY ;

#line 1078
typedef struct LIST_ENTRY32 ;

#line 1082
typedef LIST_ENTRY32 ;

typedef struct LIST_ENTRY64 ;

#line 1088
typedef LIST_ENTRY64 ;

#line 1127
typedef struct _STRING32 ;

#line 1132
typedef STRING32 ;

typedef STRING32 ;

#line 1135
typedef UNICODE_STRING32 ;

typedef STRING32 ;

#line 1138
typedef ANSI_STRING32 ;

#line 1141
typedef struct _STRING64 ;

#line 1146
typedef STRING64 ;

typedef STRING64 ;

#line 1149
typedef UNICODE_STRING64 ;

typedef STRING64 ;

#line 1152
typedef ANSI_STRING64 ;

#line 1173
typedef struct _OBJECT_ATTRIBUTES ;

#line 1181
typedef OBJECT_ATTRIBUTES ;

#line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID ;

#line 70
typedef GUID ;

#line 75
typedef const GUID ;

#line 81
typedef GUID ;

#line 82
typedef IID ;

#line 85
typedef GUID ;

#line 86
typedef CLSID ;

#line 89
typedef GUID ;

#line 90
typedef FMTID ;

#line 16 "C:/NTDDK/inc/string.h"

#pragma once
#line 1233 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECTID ;

#line 1288
struct _CONTEXT ;

#line 1289
struct _EXCEPTION_RECORD ;

typedef EXCEPTION_DISPOSITION ;

#line 1306
typedef UCHAR ;

typedef KIRQL ;

#line 1316
typedef enum _NT_PRODUCT_TYPE ;

#line 1329
typedef enum _SUITE_TYPE ;

#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD ;

#line 76
typedef struct _ETHREAD ;

#line 77
typedef struct _EPROCESS ;

#line 78
typedef struct _PEB ;

#line 79
typedef struct _KINTERRUPT ;

#line 80
typedef struct _IO_TIMER ;

#line 81
typedef struct _OBJECT_TYPE ;

#line 82
typedef struct _CALLBACK_OBJECT ;

#line 83
typedef struct _DEVICE_HANDLER_OBJECT ;

#line 84
typedef struct _BUS_HANDLER ;

#line 143
typedef union _SLIST_HEADER ;

#line 204
typedef CCHAR ;

typedef enum _MODE ;

#line 222
struct _KAPC ;

typedef void ;

#line 232
typedef void ;

#line 242
typedef void ;

#line 248
typedef BOOLEAN ;

#line 254
typedef BOOLEAN ;

#line 265
typedef struct _KAPC ;

#line 292
struct _KDPC ;

typedef void ;

#line 351
typedef enum _KDPC_IMPORTANCE ;

#line 361
typedef struct _KDPC ;

#line 377
typedef PVOID ;

typedef void ;

#line 392
typedef struct _KIPI_COUNTS ;

#line 443
typedef struct _MDL ;

#line 532
typedef PVOID ;

#line 538
typedef PVOID ;

#line 544
typedef PVOID ;

typedef ULONG ;

#line 547
typedef ACCESS_MASK ;

#line 597
typedef struct _GENERIC_MAPPING ;

#line 603
typedef GENERIC_MAPPING ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES ;

#line 622
typedef LUID_AND_ATTRIBUTES ;

#line 623
typedef LUID_AND_ATTRIBUTES_ARRAY ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 642 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACL ;

#line 649
typedef ACL ;

#line 681
typedef struct _PRIVILEGE_SET ;

#line 735
typedef enum _SECURITY_IMPERSONATION_LEVEL ;

#line 753
typedef BOOLEAN ;

#line 762
typedef struct _SECURITY_QUALITY_OF_SERVICE ;

#line 774
typedef struct _SE_IMPERSONATION_STATE ;

#line 782
typedef ULONG ;

#line 809
typedef ULONG ;

#line 810
typedef KAFFINITY ;

#line 816
typedef LONG ;

#line 824
typedef ULONG_PTR ;

#line 825
typedef KSPIN_LOCK ;

#line 833
typedef void ;

#line 842
typedef enum _KPROFILE_SOURCE ;

#line 1079
typedef NTSTATUS ;

#line 1088
typedef struct _RTL_QUERY_REGISTRY_TABLE ;

#line 1952

#pragma warning(push)

#pragma warning(disable:4035)
#line 2019

#pragma warning(pop)
#line 2214
typedef struct _TIME_FIELDS ;

#line 2224
typedef TIME_FIELDS ;

#line 2499
typedef struct _RTL_BITMAP ;

#line 2503
typedef RTL_BITMAP ;

#line 2627
typedef struct _RTL_BITMAP_RUN ;

#line 2633
typedef RTL_BITMAP_RUN ;

#line 2886
typedef struct _RTL_RANGE ;

#line 2924
typedef struct _RTL_RANGE_LIST ;

#line 2950
typedef struct _RANGE_LIST_ITERATOR ;

#line 3019
typedef BOOLEAN ;

#line 3155
typedef struct _OSVERSIONINFOA ;

#line 3164
typedef struct _OSVERSIONINFOW ;

#line 3177
typedef OSVERSIONINFOA ;

#line 3178
typedef POSVERSIONINFOA ;

#line 3179
typedef LPOSVERSIONINFOA ;

#line 3182
typedef struct _OSVERSIONINFOEXA ;

#line 3195
typedef struct _OSVERSIONINFOEXW ;

#line 3213
typedef OSVERSIONINFOEXA ;

#line 3214
typedef POSVERSIONINFOEXA ;

#line 3215
typedef LPOSVERSIONINFOEXA ;

#line 3648
typedef struct _IO_STATUS_BLOCK ;

#line 3669
typedef void ;

#line 3685
typedef enum _FILE_INFORMATION_CLASS ;

#line 3731
typedef struct _FILE_BASIC_INFORMATION ;

#line 3739
typedef struct _FILE_STANDARD_INFORMATION ;

#line 3747
typedef struct _FILE_POSITION_INFORMATION ;

#line 3751
typedef struct _FILE_ALIGNMENT_INFORMATION ;

#line 3755
typedef struct _FILE_NAME_INFORMATION ;

#line 3760
typedef struct _FILE_NETWORK_OPEN_INFORMATION ;

#line 3770
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION ;

#line 3775
typedef struct _FILE_DISPOSITION_INFORMATION ;

#line 3779
typedef struct _FILE_END_OF_FILE_INFORMATION ;

#line 3784
typedef struct _FILE_FULL_EA_INFORMATION ;

#line 3798
typedef enum _FSINFOCLASS ;

#line 3810
typedef struct _FILE_FS_DEVICE_INFORMATION ;

#line 3820
typedef union _FILE_SEGMENT_ELEMENT ;

#line 3829
typedef enum _INTERFACE_TYPE ;

#line 3854
typedef enum _DMA_WIDTH ;

#line 3865
typedef enum _DMA_SPEED ;

#line 3879
typedef void ;

#line 3880
typedef void ;

#line 3888
typedef enum _BUS_DATA_TYPE ;

#line 3910
typedef struct _IO_ERROR_LOG_PACKET ;

#line 3931
typedef struct _IO_ERROR_LOG_MESSAGE ;

#line 4074
typedef struct _KEY_BASIC_INFORMATION ;

#line 4081
typedef struct _KEY_NODE_INFORMATION ;

#line 4091
typedef struct _KEY_FULL_INFORMATION ;

#line 4106
typedef struct _KEY_NAME_INFORMATION ;

#line 4112
typedef enum _KEY_INFORMATION_CLASS ;

#line 4122
typedef struct _KEY_WRITE_TIME_INFORMATION ;

#line 4126
typedef enum _KEY_SET_INFORMATION_CLASS ;

#line 4134
typedef struct _KEY_VALUE_BASIC_INFORMATION ;

#line 4141
typedef struct _KEY_VALUE_FULL_INFORMATION ;

#line 4151
typedef struct _KEY_VALUE_PARTIAL_INFORMATION ;

#line 4158
typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ;

#line 4164
typedef struct _KEY_VALUE_ENTRY ;

#line 4171
typedef enum _KEY_VALUE_INFORMATION_CLASS ;

#line 4210
typedef struct _OBJECT_NAME_INFORMATION ;

#line 4221
typedef enum _SECTION_INHERIT ;

#line 4294
typedef struct _CLIENT_ID ;

#line 4298
typedef CLIENT_ID ;

#line 4315
typedef struct _NT_TIB ;

#line 4327
typedef NT_TIB ;

#line 4332
typedef enum _PROCESSINFOCLASS ;

#line 4366
typedef enum _THREADINFOCLASS ;

#line 4395
typedef struct _PROCESS_WS_WATCH_INFORMATION ;

#line 4405
typedef struct _PROCESS_BASIC_INFORMATION ;

#line 4413
typedef PROCESS_BASIC_INFORMATION ;

#line 4422
typedef struct _PROCESS_DEVICEMAP_INFORMATION ;

#line 4440
typedef struct _PROCESS_SESSION_INFORMATION ;

#line 4454
typedef struct _QUOTA_LIMITS ;

#line 4462
typedef QUOTA_LIMITS ;

#line 4472
typedef struct _IO_COUNTERS ;

#line 4480
typedef IO_COUNTERS ;

#line 4488
typedef struct _VM_COUNTERS ;

#line 4501
typedef VM_COUNTERS ;

#line 4508
typedef struct _POOLED_USAGE_AND_LIMITS ;

#line 4519
typedef POOLED_USAGE_AND_LIMITS ;

#line 4528
typedef struct _PROCESS_ACCESS_TOKEN ;

#line 4555
typedef struct _KERNEL_USER_TIMES ;

#line 4561
typedef KERNEL_USER_TIMES ;

#line 4587
typedef enum _SYSTEM_POWER_STATE ;

#line 4598
typedef enum  {
	PowerActionNone = 0,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
} ;

typedef enum _DEVICE_POWER_STATE ;

#line 4618
typedef union _POWER_STATE ;

#line 4623
typedef enum _POWER_STATE_TYPE ;

#line 4654
typedef ULONG ;

typedef enum  {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
} ;

#line 4663
typedef enum  {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation
} ;

#line 4690
typedef ULONG ;

typedef LONG ;

#line 4693
typedef ULONG ;

#line 4719
typedef union _MCI_STATS ;

#line 4978
typedef struct _KPCR ;

#line 5006
typedef KPCR ;

#line 5012
typedef struct _KFLOATING_SAVE ;

#line 5153
typedef enum _INTERLOCKED_RESULT ;

#line 5252

#pragma warning(disable:4035)
#line 6994
typedef struct _KSYSTEM_TIME ;

#line 7014

#pragma warning(push)

#pragma warning(disable:4164)
#line 7019

#pragma function(_enable)
#line 7020

#pragma function(_disable)
#line 7024

#pragma warning(pop)
#line 7085
typedef struct _FLOATING_SAVE_AREA ;

#line 7097
typedef FLOATING_SAVE_AREA ;

#line 7109
typedef struct _CONTEXT ;

#line 7197
typedef CONTEXT ;

#line 7826
typedef void ;

#line 7850
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ;

#line 7899
typedef struct _KUSER_SHARED_DATA ;

#line 8123
typedef enum _CM_SERVICE_NODE_TYPE ;

#line 8132
typedef enum _CM_SERVICE_LOAD_TYPE ;

#line 8140
typedef enum _CM_ERROR_CONTROL_TYPE ;

#line 8172
typedef int ;

#line 8198
typedef enum _CM_SHARE_DISPOSITION ;

#line 8211
typedef PVOID ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST ;

#line 8443
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR ;

#line 8454
typedef struct _CM_RESOURCE_LIST ;

#line 8471
typedef struct _DEVICE_FLAGS ;

#line 8485
typedef struct _CM_COMPONENT_INFORMATION ;

#line 8503
typedef struct _CM_ROM_BLOCK ;

#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 8518 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_INT13_DRIVE_PARAMETER ;

#line 8532
typedef struct _CM_MCA_POS_DATA ;

#line 8544
typedef struct _EISA_MEMORY_TYPE ;

#line 8554
typedef struct _EISA_MEMORY_CONFIGURATION ;

#line 8567
typedef struct _EISA_IRQ_DESCRIPTOR ;

#line 8575
typedef struct _EISA_IRQ_CONFIGURATION ;

#line 8585
typedef struct _DMA_CONFIGURATION_BYTE0 ;

#line 8592
typedef struct _DMA_CONFIGURATION_BYTE1 ;

#line 8599
typedef struct _EISA_DMA_CONFIGURATION ;

#line 8609
typedef struct _EISA_PORT_DESCRIPTOR ;

#line 8616
typedef struct _EISA_PORT_CONFIGURATION ;

#line 8628
typedef struct _CM_EISA_SLOT_INFORMATION ;

#line 8644
typedef struct _CM_EISA_FUNCTION_INFORMATION ;

#line 8678
typedef struct _CM_PNP_BIOS_DEVICE_NODE ;

#line 8692
typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8761 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_SCSI_DEVICE_DATA ;

#line 8775
typedef struct _CM_VIDEO_DEVICE_DATA ;

#line 8785
typedef struct _CM_SONIC_DEVICE_DATA ;

#line 8796
typedef struct _CM_SERIAL_DEVICE_DATA ;

#line 8810
typedef struct _CM_MONITOR_DEVICE_DATA ;

#line 8844
typedef struct _CM_FLOPPY_DEVICE_DATA ;

#line 8881
typedef struct _CM_KEYBOARD_DEVICE_DATA ;

#line 8893
typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA ;

#line 8905
typedef struct _CM_PCCARD_DEVICE_DATA ;

#line 8944
typedef struct _IO_RESOURCE_DESCRIPTOR ;

#line 9027
typedef struct _IO_RESOURCE_LIST ;

#line 9036
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST ;

#line 9065
typedef struct _EXCEPTION_RECORD ;

#line 9074
typedef EXCEPTION_RECORD ;

typedef struct _EXCEPTION_RECORD32 ;

#line 9085
typedef struct _EXCEPTION_RECORD64 ;

#line 9099
typedef struct _EXCEPTION_POINTERS ;

#line 9111
typedef enum _CONFIGURATION_TYPE ;

#line 9161
typedef enum _KINTERRUPT_MODE ;

#line 9170
typedef enum _KWAIT_REASON ;

#line 9207
typedef struct _DISPATCHER_HEADER ;

#line 9217
typedef struct _KWAIT_BLOCK ;

#line 9230
typedef void ;

#line 9244
typedef struct _KDEVICE_QUEUE ;

#line 9252
typedef struct _KDEVICE_QUEUE_ENTRY ;

#line 9263
typedef struct _KEVENT ;

#line 9271
typedef BOOLEAN ;

#line 9281
typedef struct _KMUTANT ;

#line 9294
typedef struct _KSEMAPHORE ;

#line 9304
typedef struct _KTIMER ;

#line 9899
typedef enum _KBUGCHECK_BUFFER_DUMP_STATE ;

#line 9907
typedef void ;

#line 9914
typedef struct _KBUGCHECK_CALLBACK_RECORD ;

#line 10002
typedef void ;

#line 10020
typedef LOGICAL ;

#line 10037
typedef void ;

#line 10053
typedef enum _MEMORY_CACHING_TYPE_ORIG ;

#line 10057
typedef enum _MEMORY_CACHING_TYPE ;

#line 10087
typedef struct _DBGKD_DEBUG_DATA_HEADER64 ;

#line 10115
typedef enum _POOL_TYPE ;

#line 10195
typedef enum _EX_POOL_PRIORITY ;

#line 10247
typedef struct _FAST_MUTEX ;

#line 10574
typedef PVOID ;

#line 10582
typedef void ;

#line 10588
typedef struct _GENERAL_LOOKASIDE ;

#line 10619
typedef struct _NPAGED_LOOKASIDE_LIST ;

#line 10729
typedef struct _PAGED_LOOKASIDE_LIST ;

#line 10882
typedef enum _WORK_QUEUE_TYPE ;

#line 10889
typedef void ;

#line 10895
typedef struct _WORK_QUEUE_ITEM ;

#line 10926
typedef struct _ZONE_SEGMENT_HEADER ;

#line 10931
typedef struct _ZONE_HEADER ;

#line 11156
typedef ULONG_PTR ;

#line 11157
typedef ERESOURCE_THREAD ;

typedef struct _OWNER_ENTRY ;

#line 11168
typedef struct _ERESOURCE ;

#line 11197
typedef struct _RESOURCE_HASH_ENTRY ;

#line 11204
typedef struct _RESOURCE_PERFORMANCE_DATA ;

#line 11429
typedef struct _CALLBACK_OBJECT ;

typedef void ;

#line 11474
typedef GUID ;

#line 11862
typedef enum _MM_SYSTEM_SIZE ;

#line 11884
typedef enum _LOCK_OPERATION ;

#line 11970
typedef enum _MM_PAGE_PRIORITY ;

#line 11999
typedef struct _PHYSICAL_MEMORY_RANGE ;

#line 12385
typedef NTSTATUS ;

#line 12389
typedef NTSTATUS ;

#line 12399
struct _DRIVER_OBJECT ;

#line 12411
typedef enum _SECURITY_OPERATION_CODE ;

#line 12426
typedef struct _SECURITY_SUBJECT_CONTEXT ;

#line 12448
typedef struct _INITIAL_PRIVILEGE_SET ;

#line 12462
typedef struct _ACCESS_STATE ;

#line 12571
typedef void ;

#line 12585
typedef void ;

#line 12602
typedef struct _IMAGE_INFO ;

#line 12620
typedef void ;

#line 12859
typedef NTSTATUS ;

#line 12878
typedef enum _IO_QUERY_DEVICE_DATA_FORMAT ;

#line 12890
typedef enum _CREATE_FILE_TYPE ;

#line 12905
struct _DEVICE_DESCRIPTION ;

#line 12906
struct _DEVICE_OBJECT ;

#line 12907
struct _DMA_ADAPTER ;

#line 12908
struct _DRIVER_OBJECT ;

#line 12909
struct _DRIVE_LAYOUT_INFORMATION ;

#line 12910
struct _DISK_PARTITION ;

#line 12911
struct _FILE_OBJECT ;

#line 12912
struct _IRP ;

#line 12913
struct _SCSI_REQUEST_BLOCK ;

#line 12919
typedef void ;

#line 12932
typedef void ;

#line 12943
typedef NTSTATUS ;

#line 12955
typedef void ;

#line 12968
typedef void ;

#line 12979
typedef NTSTATUS ;

#line 12990
typedef void ;

#line 13001
typedef void ;

#line 13011
typedef NTSTATUS ;

#line 13025
typedef BOOLEAN ;

#line 13038
typedef BOOLEAN ;

#line 13051
typedef BOOLEAN ;

#line 13068
typedef BOOLEAN ;

#line 13078
typedef BOOLEAN ;

#line 13092
typedef BOOLEAN ;

#line 13106
typedef BOOLEAN ;

#line 13118
typedef BOOLEAN ;

#line 13127
typedef BOOLEAN ;

#line 13141
typedef BOOLEAN ;

#line 13161
typedef void ;

#line 13167
typedef void ;

#line 13179
typedef void ;

#line 13193
typedef BOOLEAN ;

#line 13207
typedef BOOLEAN ;

#line 13219
typedef BOOLEAN ;

#line 13227
typedef BOOLEAN ;

#line 13239
typedef BOOLEAN ;

#line 13253
typedef NTSTATUS ;

#line 13262
typedef NTSTATUS ;

#line 13275
typedef NTSTATUS ;

#line 13282
typedef NTSTATUS ;

#line 13289
typedef BOOLEAN ;

#line 13304
typedef BOOLEAN ;

#line 13319
typedef BOOLEAN ;

#line 13327
typedef BOOLEAN ;

#line 13336
typedef BOOLEAN ;

#line 13350
typedef struct _FAST_IO_DISPATCH ;

#line 13386
typedef enum _IO_ALLOCATION_ACTION ;

#line 13396
typedef IO_ALLOCATION_ACTION ;

#line 13410
typedef struct _IO_SECURITY_CONTEXT ;

#line 13434
typedef struct _VPB ;

#line 13482
typedef struct _ADAPTER_OBJECT ;

#line 13491
typedef struct _WAIT_CONTEXT_BLOCK ;

#line 13503
typedef struct _CONTROLLER_OBJECT ;

#line 13537
typedef struct _DEVICE_OBJECT ;

#line 13575
typedef struct _DEVICE_OBJECT ;

#line 13578
struct _DEVICE_OBJECT_POWER_EXTENSION ;

typedef struct _DEVOBJ_EXTENSION ;

#line 13608
typedef struct _DRIVER_EXTENSION ;

#line 13645
typedef struct _DRIVER_OBJECT ;

#line 13706
typedef struct _DRIVER_OBJECT ;

#line 13715
typedef struct _SECTION_OBJECT_POINTERS ;

#line 13720
typedef SECTION_OBJECT_POINTERS ;

#line 13726
typedef struct _IO_COMPLETION_CONTEXT ;

#line 13759
typedef struct _FILE_OBJECT ;

#line 13788
typedef struct _FILE_OBJECT ;

#line 13828
typedef struct _IRP ;

#line 14078
typedef NTSTATUS ;

#line 14163
typedef enum _DEVICE_RELATION_TYPE ;

#line 14171
typedef struct _DEVICE_RELATIONS ;

#line 14176
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE ;

#line 14185
typedef struct _INTERFACE ;

#line 14196
typedef struct _DEVICE_CAPABILITIES ;

#line 14229
typedef struct _POWER_SEQUENCE ;

#line 14235
typedef enum  {
	BusQueryDeviceID = 0,
	BusQueryHardwareIDs = 1,
	BusQueryCompatibleIDs = 2,
	BusQueryInstanceID = 3,
	BusQueryDeviceSerialNumber = 4
} ;

typedef ULONG ;

#line 14252
typedef enum  {
	DeviceTextDescription = 0,
	DeviceTextLocationInformation = 1
} ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 14615 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SHARE_ACCESS ;

#line 14635
typedef struct _CONFIGURATION_INFORMATION ;

#line 14848
typedef struct _BOOTDISK_INFORMATION ;

#line 15754
typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK ;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK ;

#line 15764
typedef struct _IO_REMOVE_LOCK_DBG_BLOCK ;

#line 15777
typedef struct _IO_REMOVE_LOCK ;

#line 16009
typedef struct _IO_WORKITEM ;

typedef void ;

#line 16100
typedef enum  {
	DevicePropertyDeviceDescription,
	DevicePropertyHardwareID,
	DevicePropertyCompatibleIDs,
	DevicePropertyBootConfiguration,
	DevicePropertyBootConfigurationTranslated,
	DevicePropertyClassName,
	DevicePropertyClassGuid,
	DevicePropertyDriverKeyName,
	DevicePropertyManufacturer,
	DevicePropertyFriendlyName,
	DevicePropertyLocationInformation,
	DevicePropertyPhysicalDeviceObjectName,
	DevicePropertyBusTypeGuid,
	DevicePropertyLegacyBusType,
	DevicePropertyBusNumber,
	DevicePropertyEnumeratorName,
	DevicePropertyAddress,
	DevicePropertyUINumber
} ;

typedef BOOLEAN ;

#line 16129
typedef struct _DMA_ADAPTER ;

#line 16135
typedef ULONG ;

#line 16148
typedef struct _PNP_BUS_INFORMATION ;

#line 16162
typedef struct _LEGACY_BUS_INFORMATION ;

#line 16168
typedef struct _BUS_INTERFACE_STANDARD ;

#line 16190
typedef BOOLEAN ;

#line 16194
typedef NTSTATUS ;

#line 16203
typedef NTSTATUS ;

#line 16206
typedef NTSTATUS ;

#line 16210
typedef NTSTATUS ;

#line 16214
typedef NTSTATUS ;

#line 16218
typedef void ;

#line 16222
typedef NTSTATUS ;

#line 16227
typedef void ;

#line 16231
typedef struct _ACPI_INTERFACE_STANDARD ;

#line 16255
typedef enum _ACPI_REG_TYPE ;

#line 16268
typedef USHORT ;

#line 16272
typedef void ;

#line 16278
typedef struct ACPI_REGS_INTERFACE_STANDARD ;

#line 16300
typedef struct  {
	PVOID LinkNode ;
	ULONG StaticVector ;
	UCHAR Flags ;
} ;

#line 16314
typedef NTSTATUS ;

#line 16329
typedef NTSTATUS ;

#line 16336
typedef void ;

#line 16343
typedef struct _INT_ROUTE_INTERFACE_STANDARD ;

#line 16366
typedef struct _IO_ASSIGNED_RESOURCES ;

#line 16490
typedef enum _IO_NOTIFICATION_EVENT_CATEGORY ;

#line 16504
typedef NTSTATUS ;

#line 16537
typedef void ;

#line 16573
typedef enum _ARBITER_ACTION ;

#line 16586
typedef struct _ARBITER_CONFLICT_INFO ;

#line 16608
typedef struct _ARBITER_PARAMETERS ;

#line 16719
typedef enum _ARBITER_REQUEST_SOURCE ;

#line 16731
typedef enum _ARBITER_RESULT ;

#line 16761
typedef struct _ARBITER_LIST_ENTRY ;

#line 16832
typedef NTSTATUS ;

#line 16853
typedef struct _ARBITER_INTERFACE ;

#line 16880
typedef enum _RESOURCE_TRANSLATION_DIRECTION ;

#line 16889
typedef NTSTATUS ;

#line 16901
typedef NTSTATUS ;

#line 16915
typedef struct _TRANSLATOR_INTERFACE ;

#line 16931
typedef NTSTATUS ;

#line 16945
typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE ;

#line 16959
typedef struct _PLUGPLAY_NOTIFICATION_HEADER ;

#line 16972
typedef struct _HWPROFILE_CHANGE_NOTIFICATION ;

#line 16986
typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION ;

#line 17006
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION ;

#line 17026
typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION ;

#line 17054
typedef struct _DEVICE_DESCRIPTION ;

#line 17086
typedef BOOLEAN ;

#line 17333
typedef void ;

#line 17339
typedef struct _DEVICE_CONTROL_CONTEXT ;

#line 17349
typedef PBUS_HANDLER ;

#line 17355
typedef void ;

#line 17365
typedef enum _HAL_QUERY_INFORMATION_CLASS ;

#line 17381
typedef enum _HAL_SET_INFORMATION_CLASS ;

#line 17388
typedef NTSTATUS ;

#line 17405
typedef NTSTATUS ;

#line 17420
typedef void ;

#line 17429
typedef void ;

#line 17438
typedef NTSTATUS ;

#line 17447
typedef NTSTATUS ;

#line 17456
typedef NTSTATUS ;

#line 17466
typedef NTSTATUS ;

#line 17475
typedef NTSTATUS ;

#line 17486
typedef struct _PM_DISPATCH_TABLE ;

#line 17492
typedef NTSTATUS ;

#line 17505
typedef struct _DMA_ADAPTER ;

#line 17520
typedef NTSTATUS ;

#line 17543
typedef BOOLEAN ;

#line 17553
typedef NTSTATUS ;

#line 17566
typedef void ;

#line 17572
typedef void ;

#line 17578
typedef BOOLEAN ;

#line 17588
typedef struct  {
	ULONG Version ;
	pHalQuerySystemInformation HalQuerySystemInformation ;
	pHalSetSystemInformation HalSetSystemInformation ;
	pHalQueryBusSlots HalQueryBusSlots ;
	ULONG Spare1 ;
	pHalExamineMBR HalExamineMBR ;
	pHalIoAssignDriveLetters HalIoAssignDriveLetters ;
	pHalIoReadPartitionTable HalIoReadPartitionTable ;
	pHalIoSetPartitionInformation HalIoSetPartitionInformation ;
	pHalIoWritePartitionTable HalIoWritePartitionTable ;
	pHalHandlerForBus HalReferenceHandlerForBus ;
	pHalReferenceBusHandler HalReferenceBusHandler ;
	pHalReferenceBusHandler HalDereferenceBusHandler ;
	pHalInitPnpDriver HalInitPnpDriver ;
	pHalInitPowerManagement HalInitPowerManagement ;
	pHalGetDmaAdapter HalGetDmaAdapter ;
	pHalGetInterruptTranslator HalGetInterruptTranslator ;
} ;

#line 17650
typedef struct _HAL_BUS_INFORMATION ;

#line 17658
typedef struct _HAL_PROFILE_SOURCE_INFORMATION ;

#line 17665
typedef struct _HAL_PROFILE_SOURCE_INTERVAL ;

#line 17671
typedef enum _HAL_DISPLAY_BIOS_INFORMATION ;

#line 17678
typedef struct _HAL_POWER_INFORMATION ;

#line 17683
typedef struct _HAL_PROCESSOR_SPEED_INFO ;

#line 17688
typedef struct _HAL_CALLBACKS ;

#line 17694
typedef struct _HAL_PROCESSOR_FEATURE ;

#line 17706
typedef union _MCI_ADDR ;

#line 17716
typedef enum  {
	HAL_MCE_RECORD,
	HAL_MCA_RECORD
} ;

#line 17726
typedef struct _MCA_EXCEPTION ;

#line 17752
typedef void ;

#line 17762
typedef struct _MCA_DRIVER_INFO ;

#line 17772
typedef struct _SCATTER_GATHER_ELEMENT ;

#line 17778

#pragma warning(disable:4200)
#line 17779
typedef struct _SCATTER_GATHER_LIST ;

#line 17784

#pragma warning(default:4200)
#line 17788
typedef struct _DMA_OPERATIONS ;

typedef struct _DMA_ADAPTER ;

#line 17797
typedef void ;

#line 17801
typedef PVOID ;

#line 17808
typedef void ;

#line 17816
typedef NTSTATUS ;

#line 17824
typedef BOOLEAN ;

#line 17833
typedef void ;

#line 17837
typedef void ;

#line 17843
typedef PHYSICAL_ADDRESS ;

#line 17852
typedef ULONG ;

#line 17856
typedef ULONG ;

#line 17860
typedef void ;

#line 17868
typedef NTSTATUS ;

#line 17880
typedef void ;

#line 17887
typedef struct _DMA_OPERATIONS ;

#line 18235
typedef void ;

#line 18321
typedef struct _OBJECT_HANDLE_INFORMATION ;

#line 18402
typedef struct _PCI_SLOT_NUMBER ;

#line 18418
typedef struct _PCI_COMMON_CONFIG ;

#line 18591
typedef struct _PCI_CAPABILITIES_HEADER ;

#line 18600
typedef struct _PCI_PMC ;

#line 18618
typedef struct _PCI_PMCSR ;

#line 18628
typedef struct _PCI_PMCSR_BSE ;

#line 18635
typedef struct _PCI_PM_CAPABILITY ;

#line 18679
typedef struct _PCI_AGP_CAPABILITY ;

#line 18720
typedef struct _PCI_MSI_CAPABILITY ;

#line 18946
typedef void ;

#line 18954
typedef void ;

#line 18963
typedef void ;

#line 18975
typedef struct _PCIBUSDATA ;

#line 18986
typedef ULONG ;

#line 18995
typedef void ;

#line 19000
typedef void ;

#line 19006
typedef struct _PCI_BUS_INTERFACE_STANDARD ;

#line 19028
typedef BOOLEAN ;

#line 19043
typedef struct _PCI_DEVICE_PRESENT_INTERFACE ;

#line 127 "C:/NTDDK/inc/ntddser.h"
typedef struct _SERIALPERF_STATS ;

#line 136
typedef struct _SERIALCONFIG ;

#line 154
typedef struct _SERIAL_LINE_CONTROL ;

#line 160
typedef struct _SERIAL_TIMEOUTS ;

#line 175
typedef struct _SERIAL_QUEUE_SIZE ;

#line 185
typedef struct _SERIAL_BAUD_RATE ;

#line 247
typedef struct _SERIAL_CHARS ;

#line 284
typedef struct _SERIAL_HANDFLOW ;

#line 340
typedef struct _SERIAL_BASIC_SETTINGS ;

#line 353
typedef struct _SERIAL_STATUS ;

#line 433
typedef struct _SERIAL_XOFF_COUNTER ;

#line 539
typedef struct _SERIAL_COMMPROP ;

#line 631
typedef struct _SERENUM_PORT_DESC ;

#line 652
typedef UCHAR ;

#line 658
typedef void ;

#line 665
typedef enum _SERENUM_PORTION ;

#line 671
typedef struct _SERENUM_PORT_PARAMETERS ;

#line 28 "C:/NTDDK/inc/ddk/wdm/wmilib.h"

#pragma once
#line 38
typedef struct  {
	LPCGUID Guid ;
	ULONG InstanceCount ;
	ULONG Flags ;
} ;

#line 45
typedef NTSTATUS ;

#line 101
typedef NTSTATUS ;

#line 162
typedef NTSTATUS ;

#line 206
typedef NTSTATUS ;

#line 253
typedef NTSTATUS ;

#line 306
typedef enum  {
	WmiEventControl,
	WmiDataBlockControl
} ;

#line 312
typedef NTSTATUS ;

#line 355
typedef struct _WMILIB_CONTEXT ;

#line 411
typedef enum  {
	IrpProcessed,
	IrpNotCompleted,
	IrpNotWmi,
	IrpForward
} ;

#line 13 "C:/NTDDK/inc/wmidata.h"
typedef struct _MSWmi_MofData ;

#line 51
typedef struct _MSWmi_ProviderInfo ;

#line 66
typedef struct _MSWmi_PnPDeviceId ;

#line 83
typedef struct _MSWmi_PnPInstanceNames ;

#line 105
typedef struct _MSSmBios_RawSMBiosTables ;

#line 147
typedef struct _MSPower_DeviceEnable ;

#line 165
typedef struct _MSPower_DeviceWakeEnable ;

#line 182
typedef struct _MSNdis_NetworkAddress ;

#line 199
typedef struct _MSNdis_NetworkShortAddress ;

#line 216
typedef struct _MSNdis_NetworkLinkSpeed ;

#line 239
typedef struct _MSNdis_EnumerateAdapter ;

#line 256
typedef struct _MSNdis_NotifyAdapterRemoval ;

#line 273
typedef struct _MSNdis_NotifyAdapterArrival ;

#line 291
typedef struct _MSNdis_NdisEnumerateVc ;

#line 307
typedef struct _MSNdis_NotifyVcRemoval ;

#line 323
typedef struct _MSNdis_NotifyVcArrival ;

#line 338
typedef struct _MSNdis_HardwareStatus ;

#line 356
typedef struct _MSNdis_MediaSupported ;

#line 378
typedef struct _MSNdis_MediaInUse ;

#line 400
typedef struct _MSNdis_MaximumLookahead ;

#line 418
typedef struct _MSNdis_MaximumFrameSize ;

#line 436
typedef struct _MSNdis_LinkSpeed ;

#line 454
typedef struct _MSNdis_TransmitBufferSpace ;

#line 472
typedef struct _MSNdis_ReceiveBufferSpace ;

#line 490
typedef struct _MSNdis_TransmitBlockSize ;

#line 508
typedef struct _MSNdis_ReceiveBlockSize ;

#line 526
typedef struct _MSNdis_VendorID ;

#line 544
typedef struct _MSNdis_VendorDescription ;

#line 561
typedef struct _MSNdis_CurrentPacketFilter ;

#line 579
typedef struct _MSNdis_CurrentLookahead ;

#line 597
typedef struct _MSNdis_DriverVersion ;

#line 615
typedef struct _MSNdis_MaximumTotalSize ;

#line 633
typedef struct _MSNdis_MacOptions ;

#line 651
typedef struct _MSNdis_MediaConnectStatus ;

#line 669
typedef struct _MSNdis_MaximumSendPackets ;

#line 687
typedef struct _MSNdis_VendorDriverVersion ;

#line 705
typedef struct _MSNdis_TransmitsOk ;

#line 723
typedef struct _MSNdis_ReceivesOk ;

#line 741
typedef struct _MSNdis_TransmitsError ;

#line 759
typedef struct _MSNdis_ReceiveError ;

#line 777
typedef struct _MSNdis_ReceiveNoBuffer ;

#line 795
typedef struct _MSNdis_CoHardwareStatus ;

#line 813
typedef struct _MSNdis_CoMediaSupported ;

#line 835
typedef struct _MSNdis_CoMediaInUse ;

#line 857
typedef struct _MSNdis_CoLinkSpeed ;

#line 875
typedef struct _MSNdis_CoVendorId ;

#line 893
typedef struct _MSNdis_CoVendorDescription ;

#line 910
typedef struct _MSNdis_CoDriverVersion ;

#line 928
typedef struct _MSNdis_CoMacOptions ;

#line 946
typedef struct _MSNdis_CoMediaConnectStatus ;

#line 964
typedef struct _MSNdis_CoVendorDriverVersion ;

#line 982
typedef struct _MSNdis_CoMinimumLinkSpeed ;

#line 1000
typedef struct _MSNdis_CoTransmitPdusOk ;

#line 1018
typedef struct _MSNdis_CoReceivePdusOk ;

#line 1036
typedef struct _MSNdis_CoTransmitPduErrors ;

#line 1054
typedef struct _MSNdis_CoReceivePduErrors ;

#line 1072
typedef struct _MSNdis_CoReceivePdusNoBuffer ;

#line 1090
typedef struct _MSNdis_AtmSupportedVcRates ;

#line 1113
typedef struct _MSNdis_AtmSupportedServiceCategory ;

#line 1131
typedef struct _MSNdis_AtmSupportedAalTypes ;

#line 1149
typedef struct _MSNdis_AtmHardwareCurrentAddress ;

#line 1167
typedef struct _MSNdis_AtmMaxActiveVcs ;

#line 1185
typedef struct _MSNdis_AtmMaxActiveVciBits ;

#line 1203
typedef struct _MSNdis_AtmMaxActiveVpiBits ;

#line 1221
typedef struct _MSNdis_AtmMaxAal0PacketSize ;

#line 1239
typedef struct _MSNdis_AtmMaxAal1PacketSize ;

#line 1257
typedef struct _MSNdis_AtmMaxAal34PacketSize ;

#line 1275
typedef struct _MSNdis_AtmMaxAal5PacketSize ;

#line 1293
typedef struct _MSNdis_AtmReceiveCellsOk ;

#line 1311
typedef struct _MSNdis_AtmTransmitCellsOk ;

#line 1329
typedef struct _MSNdis_AtmReceiveCellsDropped ;

#line 1347
typedef struct _MSNdis_EthernetPermanentAddress ;

#line 1365
typedef struct _MSNdis_EthernetCurrentAddress ;

#line 1383
typedef struct _MSNdis_EthernetMulticastList ;

#line 1405
typedef struct _MSNdis_EthernetMaximumMulticastListSize ;

#line 1423
typedef struct _MSNdis_EthernetMacOptions ;

#line 1441
typedef struct _MSNdis_EthernetReceiveErrorAlignment ;

#line 1459
typedef struct _MSNdis_EthernetOneTransmitCollision ;

#line 1477
typedef struct _MSNdis_EthernetMoreTransmitCollisions ;

#line 1495
typedef struct _MSNdis_TokenRingPermanentAddress ;

#line 1513
typedef struct _MSNdis_TokenRingCurrentAddress ;

#line 1531
typedef struct _MSNdis_TokenRingCurrentFunctional ;

#line 1549
typedef struct _MSNdis_TokenRingCurrentGroup ;

#line 1567
typedef struct _MSNdis_TokenRingLastOpenStatus ;

#line 1585
typedef struct _MSNdis_TokenRingCurrentRingStatus ;

#line 1603
typedef struct _MSNdis_TokenRingCurrentRingState ;

#line 1621
typedef struct _MSNdis_TokenRingLineErrors ;

#line 1639
typedef struct _MSNdis_TokenRingLostFrames ;

#line 1657
typedef struct _MSNdis_FddiLongPermanentAddress ;

#line 1675
typedef struct _MSNdis_FddiLongCurrentAddress ;

#line 1693
typedef struct _MSNdis_FddiLongMulticastList ;

#line 1715
typedef struct _MSNdis_FddiLongMaximumListSize ;

#line 1733
typedef struct _MSNdis_FddiShortPermanentAddress ;

#line 1751
typedef struct _MSNdis_FddiShortCurrentAddress ;

#line 1769
typedef struct _MSNdis_FddiShortMulticastList ;

#line 1791
typedef struct _MSNdis_FddiShortMaximumListSize ;

#line 1809
typedef struct _MSNdis_FddiAttachmentType ;

#line 1827
typedef struct _MSNdis_FddiUpstreamNodeLong ;

#line 1845
typedef struct _MSNdis_FddiDownstreamNodeLong ;

#line 1863
typedef struct _MSNdis_FddiFrameErrors ;

#line 1881
typedef struct _MSNdis_FddiFramesLost ;

#line 1899
typedef struct _MSNdis_FddiRingManagmentState ;

#line 1917
typedef struct _MSNdis_FddiLctFailures ;

#line 1935
typedef struct _MSNdis_FddiLemRejects ;

#line 1953
typedef struct _MSNdis_FddiLConnectionState ;

#line 1972
typedef struct _MSNdis_StatusResetStart ;

#line 1988
typedef struct _MSNdis_StatusResetEnd ;

#line 2004
typedef struct _MSNdis_StatusMediaConnect ;

#line 2020
typedef struct _MSNdis_StatusMediaDisconnect ;

#line 2035
typedef struct _MSNdis_StatusMediaSpecificIndication ;

#line 2057
typedef struct _MSNdis_StatusLinkSpeedChange ;

#line 2075
typedef struct _MSNdis_StatusProtocolBind ;

#line 2092
typedef struct _MSNdis_StatusProtocolUnbind ;

#line 2109
typedef struct _KEYBOARD_PORT_WMI_STD_DATA ;

#line 2152
typedef struct _POINTER_PORT_WMI_STD_DATA ;

#line 2205
typedef struct _MSMouse_ClassInformation ;

#line 2223
typedef struct _MSKeyboard_ClassInformation ;

#line 2241
typedef struct _MSAcpi_ThermalZoneTemperature ;

#line 2304
typedef struct _WMI_DISK_GEOMETRY ;

#line 2342
typedef struct _WMI_DISK_PERFORMANCE ;

#line 2415
typedef struct _MSDiskDriver_Performance ;

#line 2437
typedef struct _STORAGE_FAILURE_PREDICT_STATUS ;

#line 2460
typedef struct _STORAGE_FAILURE_PREDICT_DATA ;

#line 2483
typedef struct _STORAGE_FAILURE_PREDICT_EVENT ;

#line 2513
typedef struct _STORAGE_FAILURE_PREDICT_FUNCTION ;

#line 2528
typedef struct _MSIde_PortDeviceInfo ;

#line 2556
typedef struct _MSSerial_PortName ;

#line 2573
typedef struct _SERIAL_WMI_COMM_DATA ;

#line 2723
typedef struct _SERIAL_WMI_HW_DATA ;

#line 2770
typedef struct _SERIAL_WMI_PERF_DATA ;

#line 2813
typedef struct _SERIAL_WMI_COMMPROP ;

#line 2920
typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS ;

#line 2943
typedef struct _PARALLEL_WMI_LOG_INFO ;

#line 3041
typedef struct _REDBOOK_WMI_STD_DATA ;

#line 3094
typedef struct _REDBOOK_WMI_PERF_DATA ;

#line 3137
typedef struct _RegisteredGuids ;

#line 475 "serial.h"
typedef struct _CONFIG_DATA ;

#line 509
typedef struct _SERIAL_CISR_SW ;

#line 520
typedef struct _SERIAL_FIRMWARE_DATA ;

#line 576
typedef struct _SERIAL_DEVICE_STATE ;

#line 646
typedef struct _SERIAL_DEVICE_EXTENSION ;

#line 1808
typedef struct _SERIAL_MULTIPORT_DISPATCH ;

#line 2157
typedef enum _SERIAL_MEM_COMPARES ;

#line 2164
typedef struct _SERIAL_LIST_DATA ;

#line 2169
typedef struct _SERIAL_GLOBALS ;

#line 2180
typedef struct _SERIAL_USER_DATA ;

#line 2206
typedef struct _SERIAL_PTR_CTX ;

#line 20 "serialp.h"
typedef NTSTATUS ;

#line 26
typedef void ;

#line 835
typedef struct _SERIAL_UPDATE_CHAR ;

#line 846
typedef struct _SERIAL_IOCTL_SYNC ;

#line 26 "immediat.c"
void SerialGetNextImmediate(PIRP *  CurrentOpIrp , PLIST_ENTRY QueueToProcess ,
	PIRP *  NewIrp , BOOLEAN CompleteCurrent , PSERIAL_DEVICE_EXTENSION
	Extension ) ;
#line 35
void SerialCancelImmediate(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 41
BOOLEAN SerialGiveImmediateToIsr(PVOID Context ) ;
#line 46
BOOLEAN SerialGrabImmediateFromIsr(PVOID Context ) ;

#line 63

#pragma alloc_text(PAGESER, SerialStartImmediate)
#line 64

#pragma alloc_text(PAGESER, SerialGetNextImmediate)
#line 65

#pragma alloc_text(PAGESER, SerialCancelImmediate)
#line 66

#pragma alloc_text(PAGESER, SerialGiveImmediateToIsr)
#line 67

#pragma alloc_text(PAGESER, SerialGrabImmediateFromIsr)
#line 71
void SerialStartImmediate(PSERIAL_DEVICE_EXTENSION Extension )
{
	#line 96
	KIRQL OldIrql ;
	LARGE_INTEGER TotalTime ;
	BOOLEAN UseATimer ;
	SERIAL_TIMEOUTS Timeouts ;
	#line 101
	;
	#line 104
	do
	{
		#line 104
		;
	}
	while(0);
	UseATimer = 0;
	((Extension->CurrentImmediateIrp)->IoStatus).Status = (NTSTATUS
		)0x00000103L;
	#line 109
	if(pending == 0)
		#line 109
		pending = 1;
	else
		#line 109
		errorFn();
	((((Extension->CurrentImmediateIrp)->Tail).Overlay).CurrentStackLocation
		)->Control |= 0x01;
	#line 123
	* & OldIrql = KfAcquireSpinLock(& Extension->ControlLock);
	#line 125
	Timeouts = Extension->Timeouts;
	#line 130
	KfReleaseSpinLock(& Extension->ControlLock, OldIrql);
	#line 132
	if(Timeouts.WriteTotalTimeoutConstant ||
		Timeouts.WriteTotalTimeoutMultiplier)
	{
		UseATimer = 1;
		#line 141
		TotalTime.QuadPart = (LONGLONG )((ULONG
			)Timeouts.WriteTotalTimeoutMultiplier);
		TotalTime.QuadPart += Timeouts.WriteTotalTimeoutConstant;
		#line 145
		TotalTime.QuadPart *= - 10000;
	}
	{
		#line 154
		;
		#line 154
		((((((Extension->CurrentImmediateIrp)->Tail).Overlay).CurrentStackLocation
			)->Parameters).Others).Argument4 = (void *  )0;
	}
	#line 154
	;
	#line 160
	IoAcquireCancelSpinLock(& OldIrql);
	if((Extension->CurrentImmediateIrp)->Cancel)
	{
		PIRP OldIrp = Extension->CurrentImmediateIrp;
		#line 165
		Extension->CurrentImmediateIrp = (void *  )0;
		IoReleaseCancelSpinLock(OldIrql);
		#line 168
		(OldIrp->IoStatus).Status = (NTSTATUS )0xC0000120L;
		(OldIrp->IoStatus).Information = 0;
		#line 174
		do
		{
			#line 174
			;
		}
		while(0);
		{
			#line 175
			IofCompleteRequest(OldIrp, 0);
			#line 175
			SerialIRPEpilogue(Extension);
		}
		#line 175
		;
	}
	else
	{
		#line 188
		(PDRIVER_CANCEL )((PVOID )InterlockedExchange((PLONG )((PVOID * 
			)(& (Extension->CurrentImmediateIrp)->CancelRoutine)),
			(LONG )((PVOID )SerialCancelImmediate)));
		#line 198
		do
		{
			#line 198
			LONG _refType = 0x00000002;
			#line 198
			PULONG_PTR _arg4 = (PVOID )(&
				((((((Extension->CurrentImmediateIrp)->Tail).Overlay
				).CurrentStackLocation)->Parameters).Others).Argument4
				);
			#line 198
			;
			#line 198
			* _arg4 |= _refType;
		}
		while(0);
		#line 200
		if(UseATimer)
		{
			SerialSetTimer(& Extension->ImmediateTotalTimer,
				TotalTime, &
				Extension->TotalImmediateTimeoutDpc, Extension);
			#line 217
			do
			{
				#line 217
				LONG _refType = 0x00000004;
				#line 217
				PULONG_PTR _arg4 = (PVOID )(&
					((((((Extension->CurrentImmediateIrp)->Tail
					).Overlay).CurrentStackLocation)->Parameters
					).Others).Argument4);
				#line 217
				;
				#line 217
				* _arg4 |= _refType;
			}
			while(0);
		}
		KeSynchronizeExecution(Extension->Interrupt,
			SerialGiveImmediateToIsr, Extension);
		#line 227
		IoReleaseCancelSpinLock(OldIrql);
	}
}

#line 233
void SerialCompleteImmediate(PKDPC Dpc , PVOID DeferredContext , PVOID
	SystemContext1 , PVOID SystemContext2 )
{
	#line 243
	PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
	KIRQL OldIrql ;
	#line 246
	SystemContext1;
	SystemContext2;
	#line 250
	do
	{
		#line 250
		;
	}
	while(0);
	#line 252
	IoAcquireCancelSpinLock(& OldIrql);
	#line 254
	SerialTryToCompleteCurrent(Extension, (void *  )0, OldIrql, (NTSTATUS
		)0x00000000L, & Extension->CurrentImmediateIrp, (void *  )0,
		(void *  )0, & Extension->ImmediateTotalTimer, (void *  )0,
		SerialGetNextImmediate, 0x00000001);
	#line 268
	SerialDpcEpilogue(Extension, Dpc);
}

#line 272
void SerialTimeoutImmediate(PKDPC Dpc , PVOID DeferredContext , PVOID
	SystemContext1 , PVOID SystemContext2 )
{
	#line 282
	PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
	KIRQL OldIrql ;
	#line 285
	SystemContext1;
	SystemContext2;
	#line 289
	do
	{
		#line 289
		;
	}
	while(0);
	#line 291
	IoAcquireCancelSpinLock(& OldIrql);
	#line 293
	SerialTryToCompleteCurrent(Extension, SerialGrabImmediateFromIsr,
		OldIrql, (NTSTATUS )0x00000102L, &
		Extension->CurrentImmediateIrp, (void *  )0, (void *  )0, &
		Extension->ImmediateTotalTimer, (void *  )0,
		SerialGetNextImmediate, 0x00000004);
	#line 307
	SerialDpcEpilogue(Extension, Dpc);
}

void SerialGetNextImmediate(PIRP *  CurrentOpIrp , PLIST_ENTRY QueueToProcess ,
	PIRP *  NewIrp , BOOLEAN CompleteCurrent , PSERIAL_DEVICE_EXTENSION
	Extension )
{
	#line 350
	KIRQL OldIrql ;
	#line 356
	PIRP OldIrp = * CurrentOpIrp;
	#line 358
	QueueToProcess;
	CompleteCurrent;
	;
	#line 362
	IoAcquireCancelSpinLock(& OldIrql);
	#line 364
	;
	Extension->TotalCharsQueued--;
	#line 367
	* CurrentOpIrp = (void *  )0;
	* NewIrp = (void *  )0;
	KeSynchronizeExecution(Extension->Interrupt, SerialProcessEmptyTransmit,
		Extension);
	#line 374
	IoReleaseCancelSpinLock(OldIrql);
	#line 379
	do
	{
		#line 379
		;
	}
	while(0);
	{
		#line 381
		IofCompleteRequest(OldIrp, 2);
		#line 381
		SerialIRPEpilogue(Extension);
	}
	#line 381
	;
}

void SerialCancelImmediate(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
	#line 411
	PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
	;
	#line 414
	SerialTryToCompleteCurrent(Extension, SerialGrabImmediateFromIsr,
		Irp->CancelIrql, (NTSTATUS )0xC0000120L, &
		Extension->CurrentImmediateIrp, (void *  )0, (void *  )0, &
		Extension->ImmediateTotalTimer, (void *  )0,
		SerialGetNextImmediate, 0x00000002);
}

#line 430
BOOLEAN SerialGiveImmediateToIsr(PVOID Context )
{
	#line 462
	PSERIAL_DEVICE_EXTENSION Extension = Context;
	;
	#line 465
	Extension->TransmitImmediate = 1;
	Extension->ImmediateChar = * (UCHAR * 
		)((Extension->CurrentImmediateIrp)->AssociatedIrp).SystemBuffer;
	#line 477
	do
	{
		#line 477
		LONG _refType = 0x00000001;
		#line 477
		PULONG_PTR _arg4 = (PVOID )(&
			((((((Extension->CurrentImmediateIrp)->Tail).Overlay).CurrentStackLocation
			)->Parameters).Others).Argument4);
		#line 477
		;
		#line 477
		* _arg4 |= _refType;
	}
	while(0);
	#line 484
	if(! Extension->WriteLength)
	{
		#line 500
		if(Extension->HoldingEmpty)
		{
			do
			{
				#line 502
				do
				{
					#line 502
					WRITE_PORT_UCHAR(Extension->Controller +
						(ULONG )(0x01 * 1), 0);
				}
				while(0);
			}
			while(0);
			#line 503
			do
			{
				#line 503
				do
				{
					#line 503
					WRITE_PORT_UCHAR(Extension->Controller +
						(ULONG )(0x01 * 1), (UCHAR
						)(0x01 | 0x02 | 0x04 | 0x08));
				}
				while(0);
			}
			while(0);
		}
	}
	#line 509
	return 0;
}

#line 513
BOOLEAN SerialGrabImmediateFromIsr(PVOID Context )
{
	#line 543
	PSERIAL_DEVICE_EXTENSION Extension = Context;
	;
	#line 546
	if(Extension->TransmitImmediate)
	{
		Extension->TransmitImmediate = 0;
		#line 558
		do
		{
			#line 558
			LONG _refType = 0x00000001;
			#line 558
			PULONG_PTR _arg4 = (PVOID )(&
				((((((Extension->CurrentImmediateIrp)->Tail).Overlay
				).CurrentStackLocation)->Parameters).Others).Argument4
				);
			#line 558
			;
			#line 558
			* _arg4 &= ~ _refType;
		}
		while(0);
	}
	return 0;
}

#line 16 "C:/NTDDK/inc/stddef.h"

#pragma once
#line 77
typedef int ;

#line 86
typedef unsigned int ;

#line 95
typedef int ;

#line 105
typedef unsigned int ;

#line 112
typedef unsigned short ;

#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"

#pragma once
#line 32

#pragma pack(push, 8)
#line 72
typedef enum _EXCEPTION_DISPOSITION ;

#line 89
struct _EXCEPTION_RECORD ;

#line 90
struct _CONTEXT ;

#line 155

#pragma pack(pop)
#line 25 "C:/NTDDK/inc/ntdef.h"

#pragma once
#line 15 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"

#pragma once
#line 66
typedef wchar_t ;

#line 67
typedef wchar_t ;

#line 127 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long ;

#line 25 "C:/NTDDK/inc/basetsd.h"

#pragma once
#line 36
typedef int ;

#line 37
typedef int ;

#line 43
typedef unsigned int ;

#line 44
typedef unsigned int ;

#line 45
typedef unsigned int ;

#line 84
typedef int ;

#line 85
typedef unsigned int ;

typedef long ;

#line 88
typedef unsigned long ;

#line 248
typedef unsigned short ;

#line 249
typedef short ;

#line 250
typedef unsigned long ;

#line 288
typedef ULONG_PTR ;

#line 289
typedef LONG_PTR ;

#line 295
typedef ULONG_PTR ;

#line 301
typedef __int64 ;

#line 302
typedef __int64 ;

#line 309
typedef unsigned __int64 ;

#line 310
typedef unsigned __int64 ;

#line 311
typedef unsigned __int64 ;

#line 217 "C:/NTDDK/inc/ntdef.h"
typedef void ;

#line 218
typedef void ;

#line 266
typedef char ;

#line 267
typedef short ;

#line 268
typedef long ;

#line 276
typedef wchar_t ;

#line 282
typedef WCHAR ;

#line 283
typedef WCHAR ;

#line 284
typedef const WCHAR ;

#line 285
typedef WCHAR ;

#line 286
typedef WCHAR ;

typedef const WCHAR ;

#line 293
typedef CHAR ;

#line 294
typedef CHAR ;

typedef const CHAR ;

#line 297
typedef CHAR ;

#line 298
typedef CHAR ;

#line 299
typedef const CHAR ;

#line 321
typedef char ;

#line 322
typedef unsigned char ;

#line 326
typedef LPSTR ;

#line 327
typedef LPSTR ;

#line 328
typedef LPCSTR ;

#line 337
typedef double ;

typedef struct _QUAD ;

#line 349
typedef SHORT ;

#line 350
typedef LONG ;

#line 351
typedef QUAD ;

#line 360
typedef unsigned char ;

#line 361
typedef unsigned short ;

#line 362
typedef unsigned long ;

#line 363
typedef QUAD ;

#line 369
typedef UCHAR ;

#line 370
typedef USHORT ;

#line 371
typedef ULONG ;

#line 372
typedef UQUAD ;

#line 378
typedef signed char ;

#line 379
typedef SCHAR ;

#line 394
typedef void ;

#line 400
typedef HANDLE ;

#line 406
typedef UCHAR ;

#line 407
typedef USHORT ;

#line 408
typedef ULONG ;

#line 414
typedef LONG ;

#line 478
typedef char ;

#line 479
typedef short ;

#line 480
typedef ULONG ;

typedef CCHAR ;

#line 483
typedef CSHORT ;

#line 484
typedef CLONG ;

#line 492
typedef ULONG ;

#line 493
typedef PULONG ;

#line 494
typedef USHORT ;

#line 500
typedef ULONG ;

#line 501
typedef ULONG ;

#line 508
typedef LONG ;

typedef NTSTATUS ;

#line 602
typedef struct _FLOAT128 ;

#line 607
typedef FLOAT128 ;

#line 621
typedef __int64 ;

#line 622
typedef unsigned __int64 ;

#line 639
typedef LONGLONG ;

#line 640
typedef ULONGLONG ;

#line 644
typedef LONGLONG ;

#line 649
typedef union _LARGE_INTEGER ;

#line 662
typedef LARGE_INTEGER ;

#line 668
typedef union _ULARGE_INTEGER ;

#line 681
typedef ULARGE_INTEGER ;

#line 690
typedef struct _LUID ;

#line 696
typedef ULONGLONG ;

#line 697
typedef DWORDLONG ;

#line 707
typedef LARGE_INTEGER ;

#line 831

#pragma warning(push)

#pragma warning(disable:4035)
__inline ULONGLONG __stdcall Int64ShllMod32___3(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 842
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    
		};
}

#line 845
__inline LONGLONG __stdcall Int64ShraMod32___3(LONGLONG Value , ULONG ShiftCount
	)
{
	#line 852
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    
		};
}

#line 855
__inline ULONGLONG __stdcall Int64ShrlMod32___3(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 862
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    
		};
}


#pragma warning(pop)
#line 956
typedef enum _EVENT_TYPE ;

#line 965
typedef enum _TIMER_TYPE ;

#line 974
typedef enum _WAIT_TYPE ;

#line 983
typedef CHAR ;

#line 984
typedef const char ;

#line 991
typedef struct _STRING ;

#line 999
typedef STRING ;

typedef STRING ;

#line 1002
typedef PSTRING ;

typedef STRING ;

#line 1005
typedef PSTRING ;

#line 1011
typedef struct _CSTRING ;

#line 1016
typedef CSTRING ;

#line 1019
typedef STRING ;

#line 1020
typedef PSTRING ;

#line 1027
typedef struct _UNICODE_STRING ;

#line 1036
typedef UNICODE_STRING ;

#line 1037
typedef const UNICODE_STRING ;

#line 1046
typedef UCHAR ;

#line 1047
typedef BOOLEAN ;

#line 1057
typedef struct _LIST_ENTRY ;

#line 1067
typedef struct _SINGLE_LIST_ENTRY ;

#line 1078
typedef struct LIST_ENTRY32 ;

#line 1082
typedef LIST_ENTRY32 ;

typedef struct LIST_ENTRY64 ;

#line 1088
typedef LIST_ENTRY64 ;

#line 1127
typedef struct _STRING32 ;

#line 1132
typedef STRING32 ;

typedef STRING32 ;

#line 1135
typedef UNICODE_STRING32 ;

typedef STRING32 ;

#line 1138
typedef ANSI_STRING32 ;

#line 1141
typedef struct _STRING64 ;

#line 1146
typedef STRING64 ;

typedef STRING64 ;

#line 1149
typedef UNICODE_STRING64 ;

typedef STRING64 ;

#line 1152
typedef ANSI_STRING64 ;

#line 1173
typedef struct _OBJECT_ATTRIBUTES ;

#line 1181
typedef OBJECT_ATTRIBUTES ;

#line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID ;

#line 70
typedef GUID ;

#line 75
typedef const GUID ;

#line 81
typedef GUID ;

#line 82
typedef IID ;

#line 85
typedef GUID ;

#line 86
typedef CLSID ;

#line 89
typedef GUID ;

#line 90
typedef FMTID ;

#line 16 "C:/NTDDK/inc/string.h"

#pragma once
#line 1233 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECTID ;

#line 1288
struct _CONTEXT ;

#line 1289
struct _EXCEPTION_RECORD ;

typedef EXCEPTION_DISPOSITION ;

#line 1306
typedef UCHAR ;

typedef KIRQL ;

#line 1316
typedef enum _NT_PRODUCT_TYPE ;

#line 1329
typedef enum _SUITE_TYPE ;

#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD ;

#line 76
typedef struct _ETHREAD ;

#line 77
typedef struct _EPROCESS ;

#line 78
typedef struct _PEB ;

#line 79
typedef struct _KINTERRUPT ;

#line 80
typedef struct _IO_TIMER ;

#line 81
typedef struct _OBJECT_TYPE ;

#line 82
typedef struct _CALLBACK_OBJECT ;

#line 83
typedef struct _DEVICE_HANDLER_OBJECT ;

#line 84
typedef struct _BUS_HANDLER ;

#line 143
typedef union _SLIST_HEADER ;

#line 204
typedef CCHAR ;

typedef enum _MODE ;

#line 222
struct _KAPC ;

typedef void ;

#line 232
typedef void ;

#line 242
typedef void ;

#line 248
typedef BOOLEAN ;

#line 254
typedef BOOLEAN ;

#line 265
typedef struct _KAPC ;

#line 292
struct _KDPC ;

typedef void ;

#line 351
typedef enum _KDPC_IMPORTANCE ;

#line 361
typedef struct _KDPC ;

#line 377
typedef PVOID ;

typedef void ;

#line 392
typedef struct _KIPI_COUNTS ;

#line 443
typedef struct _MDL ;

#line 532
typedef PVOID ;

#line 538
typedef PVOID ;

#line 544
typedef PVOID ;

typedef ULONG ;

#line 547
typedef ACCESS_MASK ;

#line 597
typedef struct _GENERIC_MAPPING ;

#line 603
typedef GENERIC_MAPPING ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES ;

#line 622
typedef LUID_AND_ATTRIBUTES ;

#line 623
typedef LUID_AND_ATTRIBUTES_ARRAY ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 642 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACL ;

#line 649
typedef ACL ;

#line 681
typedef struct _PRIVILEGE_SET ;

#line 735
typedef enum _SECURITY_IMPERSONATION_LEVEL ;

#line 753
typedef BOOLEAN ;

#line 762
typedef struct _SECURITY_QUALITY_OF_SERVICE ;

#line 774
typedef struct _SE_IMPERSONATION_STATE ;

#line 782
typedef ULONG ;

#line 809
typedef ULONG ;

#line 810
typedef KAFFINITY ;

#line 816
typedef LONG ;

#line 824
typedef ULONG_PTR ;

#line 825
typedef KSPIN_LOCK ;

#line 833
typedef void ;

#line 842
typedef enum _KPROFILE_SOURCE ;

#line 1079
typedef NTSTATUS ;

#line 1088
typedef struct _RTL_QUERY_REGISTRY_TABLE ;

#line 1952

#pragma warning(push)

#pragma warning(disable:4035)
#line 2019

#pragma warning(pop)
#line 2214
typedef struct _TIME_FIELDS ;

#line 2224
typedef TIME_FIELDS ;

#line 2499
typedef struct _RTL_BITMAP ;

#line 2503
typedef RTL_BITMAP ;

#line 2627
typedef struct _RTL_BITMAP_RUN ;

#line 2633
typedef RTL_BITMAP_RUN ;

#line 2886
typedef struct _RTL_RANGE ;

#line 2924
typedef struct _RTL_RANGE_LIST ;

#line 2950
typedef struct _RANGE_LIST_ITERATOR ;

#line 3019
typedef BOOLEAN ;

#line 3155
typedef struct _OSVERSIONINFOA ;

#line 3164
typedef struct _OSVERSIONINFOW ;

#line 3177
typedef OSVERSIONINFOA ;

#line 3178
typedef POSVERSIONINFOA ;

#line 3179
typedef LPOSVERSIONINFOA ;

#line 3182
typedef struct _OSVERSIONINFOEXA ;

#line 3195
typedef struct _OSVERSIONINFOEXW ;

#line 3213
typedef OSVERSIONINFOEXA ;

#line 3214
typedef POSVERSIONINFOEXA ;

#line 3215
typedef LPOSVERSIONINFOEXA ;

#line 3648
typedef struct _IO_STATUS_BLOCK ;

#line 3669
typedef void ;

#line 3685
typedef enum _FILE_INFORMATION_CLASS ;

#line 3731
typedef struct _FILE_BASIC_INFORMATION ;

#line 3739
typedef struct _FILE_STANDARD_INFORMATION ;

#line 3747
typedef struct _FILE_POSITION_INFORMATION ;

#line 3751
typedef struct _FILE_ALIGNMENT_INFORMATION ;

#line 3755
typedef struct _FILE_NAME_INFORMATION ;

#line 3760
typedef struct _FILE_NETWORK_OPEN_INFORMATION ;

#line 3770
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION ;

#line 3775
typedef struct _FILE_DISPOSITION_INFORMATION ;

#line 3779
typedef struct _FILE_END_OF_FILE_INFORMATION ;

#line 3784
typedef struct _FILE_FULL_EA_INFORMATION ;

#line 3798
typedef enum _FSINFOCLASS ;

#line 3810
typedef struct _FILE_FS_DEVICE_INFORMATION ;

#line 3820
typedef union _FILE_SEGMENT_ELEMENT ;

#line 3829
typedef enum _INTERFACE_TYPE ;

#line 3854
typedef enum _DMA_WIDTH ;

#line 3865
typedef enum _DMA_SPEED ;

#line 3879
typedef void ;

#line 3880
typedef void ;

#line 3888
typedef enum _BUS_DATA_TYPE ;

#line 3910
typedef struct _IO_ERROR_LOG_PACKET ;

#line 3931
typedef struct _IO_ERROR_LOG_MESSAGE ;

#line 4074
typedef struct _KEY_BASIC_INFORMATION ;

#line 4081
typedef struct _KEY_NODE_INFORMATION ;

#line 4091
typedef struct _KEY_FULL_INFORMATION ;

#line 4106
typedef struct _KEY_NAME_INFORMATION ;

#line 4112
typedef enum _KEY_INFORMATION_CLASS ;

#line 4122
typedef struct _KEY_WRITE_TIME_INFORMATION ;

#line 4126
typedef enum _KEY_SET_INFORMATION_CLASS ;

#line 4134
typedef struct _KEY_VALUE_BASIC_INFORMATION ;

#line 4141
typedef struct _KEY_VALUE_FULL_INFORMATION ;

#line 4151
typedef struct _KEY_VALUE_PARTIAL_INFORMATION ;

#line 4158
typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ;

#line 4164
typedef struct _KEY_VALUE_ENTRY ;

#line 4171
typedef enum _KEY_VALUE_INFORMATION_CLASS ;

#line 4210
typedef struct _OBJECT_NAME_INFORMATION ;

#line 4221
typedef enum _SECTION_INHERIT ;

#line 4294
typedef struct _CLIENT_ID ;

#line 4298
typedef CLIENT_ID ;

#line 4315
typedef struct _NT_TIB ;

#line 4327
typedef NT_TIB ;

#line 4332
typedef enum _PROCESSINFOCLASS ;

#line 4366
typedef enum _THREADINFOCLASS ;

#line 4395
typedef struct _PROCESS_WS_WATCH_INFORMATION ;

#line 4405
typedef struct _PROCESS_BASIC_INFORMATION ;

#line 4413
typedef PROCESS_BASIC_INFORMATION ;

#line 4422
typedef struct _PROCESS_DEVICEMAP_INFORMATION ;

#line 4440
typedef struct _PROCESS_SESSION_INFORMATION ;

#line 4454
typedef struct _QUOTA_LIMITS ;

#line 4462
typedef QUOTA_LIMITS ;

#line 4472
typedef struct _IO_COUNTERS ;

#line 4480
typedef IO_COUNTERS ;

#line 4488
typedef struct _VM_COUNTERS ;

#line 4501
typedef VM_COUNTERS ;

#line 4508
typedef struct _POOLED_USAGE_AND_LIMITS ;

#line 4519
typedef POOLED_USAGE_AND_LIMITS ;

#line 4528
typedef struct _PROCESS_ACCESS_TOKEN ;

#line 4555
typedef struct _KERNEL_USER_TIMES ;

#line 4561
typedef KERNEL_USER_TIMES ;

#line 4587
typedef enum _SYSTEM_POWER_STATE ;

#line 4598
typedef enum  {
	PowerActionNone = 0,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
} ;

typedef enum _DEVICE_POWER_STATE ;

#line 4618
typedef union _POWER_STATE ;

#line 4623
typedef enum _POWER_STATE_TYPE ;

#line 4654
typedef ULONG ;

typedef enum  {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
} ;

#line 4663
typedef enum  {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation
} ;

#line 4690
typedef ULONG ;

typedef LONG ;

#line 4693
typedef ULONG ;

#line 4719
typedef union _MCI_STATS ;

#line 4978
typedef struct _KPCR ;

#line 5006
typedef KPCR ;

#line 5012
typedef struct _KFLOATING_SAVE ;

#line 5153
typedef enum _INTERLOCKED_RESULT ;

#line 5252

#pragma warning(disable:4035)
#line 6994
typedef struct _KSYSTEM_TIME ;

#line 7014

#pragma warning(push)

#pragma warning(disable:4164)
#line 7019

#pragma function(_enable)
#line 7020

#pragma function(_disable)
#line 7024

#pragma warning(pop)
#line 7085
typedef struct _FLOATING_SAVE_AREA ;

#line 7097
typedef FLOATING_SAVE_AREA ;

#line 7109
typedef struct _CONTEXT ;

#line 7197
typedef CONTEXT ;

#line 7826
typedef void ;

#line 7850
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ;

#line 7899
typedef struct _KUSER_SHARED_DATA ;

#line 8123
typedef enum _CM_SERVICE_NODE_TYPE ;

#line 8132
typedef enum _CM_SERVICE_LOAD_TYPE ;

#line 8140
typedef enum _CM_ERROR_CONTROL_TYPE ;

#line 8172
typedef int ;

#line 8198
typedef enum _CM_SHARE_DISPOSITION ;

#line 8211
typedef PVOID ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST ;

#line 8443
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR ;

#line 8454
typedef struct _CM_RESOURCE_LIST ;

#line 8471
typedef struct _DEVICE_FLAGS ;

#line 8485
typedef struct _CM_COMPONENT_INFORMATION ;

#line 8503
typedef struct _CM_ROM_BLOCK ;

#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 8518 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_INT13_DRIVE_PARAMETER ;

#line 8532
typedef struct _CM_MCA_POS_DATA ;

#line 8544
typedef struct _EISA_MEMORY_TYPE ;

#line 8554
typedef struct _EISA_MEMORY_CONFIGURATION ;

#line 8567
typedef struct _EISA_IRQ_DESCRIPTOR ;

#line 8575
typedef struct _EISA_IRQ_CONFIGURATION ;

#line 8585
typedef struct _DMA_CONFIGURATION_BYTE0 ;

#line 8592
typedef struct _DMA_CONFIGURATION_BYTE1 ;

#line 8599
typedef struct _EISA_DMA_CONFIGURATION ;

#line 8609
typedef struct _EISA_PORT_DESCRIPTOR ;

#line 8616
typedef struct _EISA_PORT_CONFIGURATION ;

#line 8628
typedef struct _CM_EISA_SLOT_INFORMATION ;

#line 8644
typedef struct _CM_EISA_FUNCTION_INFORMATION ;

#line 8678
typedef struct _CM_PNP_BIOS_DEVICE_NODE ;

#line 8692
typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8761 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_SCSI_DEVICE_DATA ;

#line 8775
typedef struct _CM_VIDEO_DEVICE_DATA ;

#line 8785
typedef struct _CM_SONIC_DEVICE_DATA ;

#line 8796
typedef struct _CM_SERIAL_DEVICE_DATA ;

#line 8810
typedef struct _CM_MONITOR_DEVICE_DATA ;

#line 8844
typedef struct _CM_FLOPPY_DEVICE_DATA ;

#line 8881
typedef struct _CM_KEYBOARD_DEVICE_DATA ;

#line 8893
typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA ;

#line 8905
typedef struct _CM_PCCARD_DEVICE_DATA ;

#line 8944
typedef struct _IO_RESOURCE_DESCRIPTOR ;

#line 9027
typedef struct _IO_RESOURCE_LIST ;

#line 9036
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST ;

#line 9065
typedef struct _EXCEPTION_RECORD ;

#line 9074
typedef EXCEPTION_RECORD ;

typedef struct _EXCEPTION_RECORD32 ;

#line 9085
typedef struct _EXCEPTION_RECORD64 ;

#line 9099
typedef struct _EXCEPTION_POINTERS ;

#line 9111
typedef enum _CONFIGURATION_TYPE ;

#line 9161
typedef enum _KINTERRUPT_MODE ;

#line 9170
typedef enum _KWAIT_REASON ;

#line 9207
typedef struct _DISPATCHER_HEADER ;

#line 9217
typedef struct _KWAIT_BLOCK ;

#line 9230
typedef void ;

#line 9244
typedef struct _KDEVICE_QUEUE ;

#line 9252
typedef struct _KDEVICE_QUEUE_ENTRY ;

#line 9263
typedef struct _KEVENT ;

#line 9271
typedef BOOLEAN ;

#line 9281
typedef struct _KMUTANT ;

#line 9294
typedef struct _KSEMAPHORE ;

#line 9304
typedef struct _KTIMER ;

#line 9899
typedef enum _KBUGCHECK_BUFFER_DUMP_STATE ;

#line 9907
typedef void ;

#line 9914
typedef struct _KBUGCHECK_CALLBACK_RECORD ;

#line 10002
typedef void ;

#line 10020
typedef LOGICAL ;

#line 10037
typedef void ;

#line 10053
typedef enum _MEMORY_CACHING_TYPE_ORIG ;

#line 10057
typedef enum _MEMORY_CACHING_TYPE ;

#line 10087
typedef struct _DBGKD_DEBUG_DATA_HEADER64 ;

#line 10115
typedef enum _POOL_TYPE ;

#line 10195
typedef enum _EX_POOL_PRIORITY ;

#line 10247
typedef struct _FAST_MUTEX ;

#line 10574
typedef PVOID ;

#line 10582
typedef void ;

#line 10588
typedef struct _GENERAL_LOOKASIDE ;

#line 10619
typedef struct _NPAGED_LOOKASIDE_LIST ;

#line 10729
typedef struct _PAGED_LOOKASIDE_LIST ;

#line 10882
typedef enum _WORK_QUEUE_TYPE ;

#line 10889
typedef void ;

#line 10895
typedef struct _WORK_QUEUE_ITEM ;

#line 10926
typedef struct _ZONE_SEGMENT_HEADER ;

#line 10931
typedef struct _ZONE_HEADER ;

#line 11156
typedef ULONG_PTR ;

#line 11157
typedef ERESOURCE_THREAD ;

typedef struct _OWNER_ENTRY ;

#line 11168
typedef struct _ERESOURCE ;

#line 11197
typedef struct _RESOURCE_HASH_ENTRY ;

#line 11204
typedef struct _RESOURCE_PERFORMANCE_DATA ;

#line 11429
typedef struct _CALLBACK_OBJECT ;

typedef void ;

#line 11474
typedef GUID ;

#line 11862
typedef enum _MM_SYSTEM_SIZE ;

#line 11884
typedef enum _LOCK_OPERATION ;

#line 11970
typedef enum _MM_PAGE_PRIORITY ;

#line 11999
typedef struct _PHYSICAL_MEMORY_RANGE ;

#line 12385
typedef NTSTATUS ;

#line 12389
typedef NTSTATUS ;

#line 12399
struct _DRIVER_OBJECT ;

#line 12411
typedef enum _SECURITY_OPERATION_CODE ;

#line 12426
typedef struct _SECURITY_SUBJECT_CONTEXT ;

#line 12448
typedef struct _INITIAL_PRIVILEGE_SET ;

#line 12462
typedef struct _ACCESS_STATE ;

#line 12571
typedef void ;

#line 12585
typedef void ;

#line 12602
typedef struct _IMAGE_INFO ;

#line 12620
typedef void ;

#line 12859
typedef NTSTATUS ;

#line 12878
typedef enum _IO_QUERY_DEVICE_DATA_FORMAT ;

#line 12890
typedef enum _CREATE_FILE_TYPE ;

#line 12905
struct _DEVICE_DESCRIPTION ;

#line 12906
struct _DEVICE_OBJECT ;

#line 12907
struct _DMA_ADAPTER ;

#line 12908
struct _DRIVER_OBJECT ;

#line 12909
struct _DRIVE_LAYOUT_INFORMATION ;

#line 12910
struct _DISK_PARTITION ;

#line 12911
struct _FILE_OBJECT ;

#line 12912
struct _IRP ;

#line 12913
struct _SCSI_REQUEST_BLOCK ;

#line 12919
typedef void ;

#line 12932
typedef void ;

#line 12943
typedef NTSTATUS ;

#line 12955
typedef void ;

#line 12968
typedef void ;

#line 12979
typedef NTSTATUS ;

#line 12990
typedef void ;

#line 13001
typedef void ;

#line 13011
typedef NTSTATUS ;

#line 13025
typedef BOOLEAN ;

#line 13038
typedef BOOLEAN ;

#line 13051
typedef BOOLEAN ;

#line 13068
typedef BOOLEAN ;

#line 13078
typedef BOOLEAN ;

#line 13092
typedef BOOLEAN ;

#line 13106
typedef BOOLEAN ;

#line 13118
typedef BOOLEAN ;

#line 13127
typedef BOOLEAN ;

#line 13141
typedef BOOLEAN ;

#line 13161
typedef void ;

#line 13167
typedef void ;

#line 13179
typedef void ;

#line 13193
typedef BOOLEAN ;

#line 13207
typedef BOOLEAN ;

#line 13219
typedef BOOLEAN ;

#line 13227
typedef BOOLEAN ;

#line 13239
typedef BOOLEAN ;

#line 13253
typedef NTSTATUS ;

#line 13262
typedef NTSTATUS ;

#line 13275
typedef NTSTATUS ;

#line 13282
typedef NTSTATUS ;

#line 13289
typedef BOOLEAN ;

#line 13304
typedef BOOLEAN ;

#line 13319
typedef BOOLEAN ;

#line 13327
typedef BOOLEAN ;

#line 13336
typedef BOOLEAN ;

#line 13350
typedef struct _FAST_IO_DISPATCH ;

#line 13386
typedef enum _IO_ALLOCATION_ACTION ;

#line 13396
typedef IO_ALLOCATION_ACTION ;

#line 13410
typedef struct _IO_SECURITY_CONTEXT ;

#line 13434
typedef struct _VPB ;

#line 13482
typedef struct _ADAPTER_OBJECT ;

#line 13491
typedef struct _WAIT_CONTEXT_BLOCK ;

#line 13503
typedef struct _CONTROLLER_OBJECT ;

#line 13537
typedef struct _DEVICE_OBJECT ;

#line 13575
typedef struct _DEVICE_OBJECT ;

#line 13578
struct _DEVICE_OBJECT_POWER_EXTENSION ;

typedef struct _DEVOBJ_EXTENSION ;

#line 13608
typedef struct _DRIVER_EXTENSION ;

#line 13645
typedef struct _DRIVER_OBJECT ;

#line 13706
typedef struct _DRIVER_OBJECT ;

#line 13715
typedef struct _SECTION_OBJECT_POINTERS ;

#line 13720
typedef SECTION_OBJECT_POINTERS ;

#line 13726
typedef struct _IO_COMPLETION_CONTEXT ;

#line 13759
typedef struct _FILE_OBJECT ;

#line 13788
typedef struct _FILE_OBJECT ;

#line 13828
typedef struct _IRP ;

#line 14078
typedef NTSTATUS ;

#line 14163
typedef enum _DEVICE_RELATION_TYPE ;

#line 14171
typedef struct _DEVICE_RELATIONS ;

#line 14176
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE ;

#line 14185
typedef struct _INTERFACE ;

#line 14196
typedef struct _DEVICE_CAPABILITIES ;

#line 14229
typedef struct _POWER_SEQUENCE ;

#line 14235
typedef enum  {
	BusQueryDeviceID = 0,
	BusQueryHardwareIDs = 1,
	BusQueryCompatibleIDs = 2,
	BusQueryInstanceID = 3,
	BusQueryDeviceSerialNumber = 4
} ;

typedef ULONG ;

#line 14252
typedef enum  {
	DeviceTextDescription = 0,
	DeviceTextLocationInformation = 1
} ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 14615 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SHARE_ACCESS ;

#line 14635
typedef struct _CONFIGURATION_INFORMATION ;

#line 14848
typedef struct _BOOTDISK_INFORMATION ;

#line 15754
typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK ;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK ;

#line 15764
typedef struct _IO_REMOVE_LOCK_DBG_BLOCK ;

#line 15777
typedef struct _IO_REMOVE_LOCK ;

#line 16009
typedef struct _IO_WORKITEM ;

typedef void ;

#line 16100
typedef enum  {
	DevicePropertyDeviceDescription,
	DevicePropertyHardwareID,
	DevicePropertyCompatibleIDs,
	DevicePropertyBootConfiguration,
	DevicePropertyBootConfigurationTranslated,
	DevicePropertyClassName,
	DevicePropertyClassGuid,
	DevicePropertyDriverKeyName,
	DevicePropertyManufacturer,
	DevicePropertyFriendlyName,
	DevicePropertyLocationInformation,
	DevicePropertyPhysicalDeviceObjectName,
	DevicePropertyBusTypeGuid,
	DevicePropertyLegacyBusType,
	DevicePropertyBusNumber,
	DevicePropertyEnumeratorName,
	DevicePropertyAddress,
	DevicePropertyUINumber
} ;

typedef BOOLEAN ;

#line 16129
typedef struct _DMA_ADAPTER ;

#line 16135
typedef ULONG ;

#line 16148
typedef struct _PNP_BUS_INFORMATION ;

#line 16162
typedef struct _LEGACY_BUS_INFORMATION ;

#line 16168
typedef struct _BUS_INTERFACE_STANDARD ;

#line 16190
typedef BOOLEAN ;

#line 16194
typedef NTSTATUS ;

#line 16203
typedef NTSTATUS ;

#line 16206
typedef NTSTATUS ;

#line 16210
typedef NTSTATUS ;

#line 16214
typedef NTSTATUS ;

#line 16218
typedef void ;

#line 16222
typedef NTSTATUS ;

#line 16227
typedef void ;

#line 16231
typedef struct _ACPI_INTERFACE_STANDARD ;

#line 16255
typedef enum _ACPI_REG_TYPE ;

#line 16268
typedef USHORT ;

#line 16272
typedef void ;

#line 16278
typedef struct ACPI_REGS_INTERFACE_STANDARD ;

#line 16300
typedef struct  {
	PVOID LinkNode ;
	ULONG StaticVector ;
	UCHAR Flags ;
} ;

#line 16314
typedef NTSTATUS ;

#line 16329
typedef NTSTATUS ;

#line 16336
typedef void ;

#line 16343
typedef struct _INT_ROUTE_INTERFACE_STANDARD ;

#line 16366
typedef struct _IO_ASSIGNED_RESOURCES ;

#line 16490
typedef enum _IO_NOTIFICATION_EVENT_CATEGORY ;

#line 16504
typedef NTSTATUS ;

#line 16537
typedef void ;

#line 16573
typedef enum _ARBITER_ACTION ;

#line 16586
typedef struct _ARBITER_CONFLICT_INFO ;

#line 16608
typedef struct _ARBITER_PARAMETERS ;

#line 16719
typedef enum _ARBITER_REQUEST_SOURCE ;

#line 16731
typedef enum _ARBITER_RESULT ;

#line 16761
typedef struct _ARBITER_LIST_ENTRY ;

#line 16832
typedef NTSTATUS ;

#line 16853
typedef struct _ARBITER_INTERFACE ;

#line 16880
typedef enum _RESOURCE_TRANSLATION_DIRECTION ;

#line 16889
typedef NTSTATUS ;

#line 16901
typedef NTSTATUS ;

#line 16915
typedef struct _TRANSLATOR_INTERFACE ;

#line 16931
typedef NTSTATUS ;

#line 16945
typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE ;

#line 16959
typedef struct _PLUGPLAY_NOTIFICATION_HEADER ;

#line 16972
typedef struct _HWPROFILE_CHANGE_NOTIFICATION ;

#line 16986
typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION ;

#line 17006
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION ;

#line 17026
typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION ;

#line 17054
typedef struct _DEVICE_DESCRIPTION ;

#line 17086
typedef BOOLEAN ;

#line 17333
typedef void ;

#line 17339
typedef struct _DEVICE_CONTROL_CONTEXT ;

#line 17349
typedef PBUS_HANDLER ;

#line 17355
typedef void ;

#line 17365
typedef enum _HAL_QUERY_INFORMATION_CLASS ;

#line 17381
typedef enum _HAL_SET_INFORMATION_CLASS ;

#line 17388
typedef NTSTATUS ;

#line 17405
typedef NTSTATUS ;

#line 17420
typedef void ;

#line 17429
typedef void ;

#line 17438
typedef NTSTATUS ;

#line 17447
typedef NTSTATUS ;

#line 17456
typedef NTSTATUS ;

#line 17466
typedef NTSTATUS ;

#line 17475
typedef NTSTATUS ;

#line 17486
typedef struct _PM_DISPATCH_TABLE ;

#line 17492
typedef NTSTATUS ;

#line 17505
typedef struct _DMA_ADAPTER ;

#line 17520
typedef NTSTATUS ;

#line 17543
typedef BOOLEAN ;

#line 17553
typedef NTSTATUS ;

#line 17566
typedef void ;

#line 17572
typedef void ;

#line 17578
typedef BOOLEAN ;

#line 17588
typedef struct  {
	ULONG Version ;
	pHalQuerySystemInformation HalQuerySystemInformation ;
	pHalSetSystemInformation HalSetSystemInformation ;
	pHalQueryBusSlots HalQueryBusSlots ;
	ULONG Spare1 ;
	pHalExamineMBR HalExamineMBR ;
	pHalIoAssignDriveLetters HalIoAssignDriveLetters ;
	pHalIoReadPartitionTable HalIoReadPartitionTable ;
	pHalIoSetPartitionInformation HalIoSetPartitionInformation ;
	pHalIoWritePartitionTable HalIoWritePartitionTable ;
	pHalHandlerForBus HalReferenceHandlerForBus ;
	pHalReferenceBusHandler HalReferenceBusHandler ;
	pHalReferenceBusHandler HalDereferenceBusHandler ;
	pHalInitPnpDriver HalInitPnpDriver ;
	pHalInitPowerManagement HalInitPowerManagement ;
	pHalGetDmaAdapter HalGetDmaAdapter ;
	pHalGetInterruptTranslator HalGetInterruptTranslator ;
} ;

#line 17650
typedef struct _HAL_BUS_INFORMATION ;

#line 17658
typedef struct _HAL_PROFILE_SOURCE_INFORMATION ;

#line 17665
typedef struct _HAL_PROFILE_SOURCE_INTERVAL ;

#line 17671
typedef enum _HAL_DISPLAY_BIOS_INFORMATION ;

#line 17678
typedef struct _HAL_POWER_INFORMATION ;

#line 17683
typedef struct _HAL_PROCESSOR_SPEED_INFO ;

#line 17688
typedef struct _HAL_CALLBACKS ;

#line 17694
typedef struct _HAL_PROCESSOR_FEATURE ;

#line 17706
typedef union _MCI_ADDR ;

#line 17716
typedef enum  {
	HAL_MCE_RECORD,
	HAL_MCA_RECORD
} ;

#line 17726
typedef struct _MCA_EXCEPTION ;

#line 17752
typedef void ;

#line 17762
typedef struct _MCA_DRIVER_INFO ;

#line 17772
typedef struct _SCATTER_GATHER_ELEMENT ;

#line 17778

#pragma warning(disable:4200)
#line 17779
typedef struct _SCATTER_GATHER_LIST ;

#line 17784

#pragma warning(default:4200)
#line 17788
typedef struct _DMA_OPERATIONS ;

typedef struct _DMA_ADAPTER ;

#line 17797
typedef void ;

#line 17801
typedef PVOID ;

#line 17808
typedef void ;

#line 17816
typedef NTSTATUS ;

#line 17824
typedef BOOLEAN ;

#line 17833
typedef void ;

#line 17837
typedef void ;

#line 17843
typedef PHYSICAL_ADDRESS ;

#line 17852
typedef ULONG ;

#line 17856
typedef ULONG ;

#line 17860
typedef void ;

#line 17868
typedef NTSTATUS ;

#line 17880
typedef void ;

#line 17887
typedef struct _DMA_OPERATIONS ;

#line 18235
typedef void ;

#line 18321
typedef struct _OBJECT_HANDLE_INFORMATION ;

#line 18402
typedef struct _PCI_SLOT_NUMBER ;

#line 18418
typedef struct _PCI_COMMON_CONFIG ;

#line 18591
typedef struct _PCI_CAPABILITIES_HEADER ;

#line 18600
typedef struct _PCI_PMC ;

#line 18618
typedef struct _PCI_PMCSR ;

#line 18628
typedef struct _PCI_PMCSR_BSE ;

#line 18635
typedef struct _PCI_PM_CAPABILITY ;

#line 18679
typedef struct _PCI_AGP_CAPABILITY ;

#line 18720
typedef struct _PCI_MSI_CAPABILITY ;

#line 18946
typedef void ;

#line 18954
typedef void ;

#line 18963
typedef void ;

#line 18975
typedef struct _PCIBUSDATA ;

#line 18986
typedef ULONG ;

#line 18995
typedef void ;

#line 19000
typedef void ;

#line 19006
typedef struct _PCI_BUS_INTERFACE_STANDARD ;

#line 19028
typedef BOOLEAN ;

#line 19043
typedef struct _PCI_DEVICE_PRESENT_INTERFACE ;

#line 127 "C:/NTDDK/inc/ntddser.h"
typedef struct _SERIALPERF_STATS ;

#line 136
typedef struct _SERIALCONFIG ;

#line 154
typedef struct _SERIAL_LINE_CONTROL ;

#line 160
typedef struct _SERIAL_TIMEOUTS ;

#line 175
typedef struct _SERIAL_QUEUE_SIZE ;

#line 185
typedef struct _SERIAL_BAUD_RATE ;

#line 247
typedef struct _SERIAL_CHARS ;

#line 284
typedef struct _SERIAL_HANDFLOW ;

#line 340
typedef struct _SERIAL_BASIC_SETTINGS ;

#line 353
typedef struct _SERIAL_STATUS ;

#line 433
typedef struct _SERIAL_XOFF_COUNTER ;

#line 539
typedef struct _SERIAL_COMMPROP ;

#line 631
typedef struct _SERENUM_PORT_DESC ;

#line 652
typedef UCHAR ;

#line 658
typedef void ;

#line 665
typedef enum _SERENUM_PORTION ;

#line 671
typedef struct _SERENUM_PORT_PARAMETERS ;

#line 28 "C:/NTDDK/inc/ddk/wdm/wmilib.h"

#pragma once
#line 38
typedef struct  {
	LPCGUID Guid ;
	ULONG InstanceCount ;
	ULONG Flags ;
} ;

#line 45
typedef NTSTATUS ;

#line 101
typedef NTSTATUS ;

#line 162
typedef NTSTATUS ;

#line 206
typedef NTSTATUS ;

#line 253
typedef NTSTATUS ;

#line 306
typedef enum  {
	WmiEventControl,
	WmiDataBlockControl
} ;

#line 312
typedef NTSTATUS ;

#line 355
typedef struct _WMILIB_CONTEXT ;

#line 411
typedef enum  {
	IrpProcessed,
	IrpNotCompleted,
	IrpNotWmi,
	IrpForward
} ;

#line 13 "C:/NTDDK/inc/wmidata.h"
typedef struct _MSWmi_MofData ;

#line 51
typedef struct _MSWmi_ProviderInfo ;

#line 66
typedef struct _MSWmi_PnPDeviceId ;

#line 83
typedef struct _MSWmi_PnPInstanceNames ;

#line 105
typedef struct _MSSmBios_RawSMBiosTables ;

#line 147
typedef struct _MSPower_DeviceEnable ;

#line 165
typedef struct _MSPower_DeviceWakeEnable ;

#line 182
typedef struct _MSNdis_NetworkAddress ;

#line 199
typedef struct _MSNdis_NetworkShortAddress ;

#line 216
typedef struct _MSNdis_NetworkLinkSpeed ;

#line 239
typedef struct _MSNdis_EnumerateAdapter ;

#line 256
typedef struct _MSNdis_NotifyAdapterRemoval ;

#line 273
typedef struct _MSNdis_NotifyAdapterArrival ;

#line 291
typedef struct _MSNdis_NdisEnumerateVc ;

#line 307
typedef struct _MSNdis_NotifyVcRemoval ;

#line 323
typedef struct _MSNdis_NotifyVcArrival ;

#line 338
typedef struct _MSNdis_HardwareStatus ;

#line 356
typedef struct _MSNdis_MediaSupported ;

#line 378
typedef struct _MSNdis_MediaInUse ;

#line 400
typedef struct _MSNdis_MaximumLookahead ;

#line 418
typedef struct _MSNdis_MaximumFrameSize ;

#line 436
typedef struct _MSNdis_LinkSpeed ;

#line 454
typedef struct _MSNdis_TransmitBufferSpace ;

#line 472
typedef struct _MSNdis_ReceiveBufferSpace ;

#line 490
typedef struct _MSNdis_TransmitBlockSize ;

#line 508
typedef struct _MSNdis_ReceiveBlockSize ;

#line 526
typedef struct _MSNdis_VendorID ;

#line 544
typedef struct _MSNdis_VendorDescription ;

#line 561
typedef struct _MSNdis_CurrentPacketFilter ;

#line 579
typedef struct _MSNdis_CurrentLookahead ;

#line 597
typedef struct _MSNdis_DriverVersion ;

#line 615
typedef struct _MSNdis_MaximumTotalSize ;

#line 633
typedef struct _MSNdis_MacOptions ;

#line 651
typedef struct _MSNdis_MediaConnectStatus ;

#line 669
typedef struct _MSNdis_MaximumSendPackets ;

#line 687
typedef struct _MSNdis_VendorDriverVersion ;

#line 705
typedef struct _MSNdis_TransmitsOk ;

#line 723
typedef struct _MSNdis_ReceivesOk ;

#line 741
typedef struct _MSNdis_TransmitsError ;

#line 759
typedef struct _MSNdis_ReceiveError ;

#line 777
typedef struct _MSNdis_ReceiveNoBuffer ;

#line 795
typedef struct _MSNdis_CoHardwareStatus ;

#line 813
typedef struct _MSNdis_CoMediaSupported ;

#line 835
typedef struct _MSNdis_CoMediaInUse ;

#line 857
typedef struct _MSNdis_CoLinkSpeed ;

#line 875
typedef struct _MSNdis_CoVendorId ;

#line 893
typedef struct _MSNdis_CoVendorDescription ;

#line 910
typedef struct _MSNdis_CoDriverVersion ;

#line 928
typedef struct _MSNdis_CoMacOptions ;

#line 946
typedef struct _MSNdis_CoMediaConnectStatus ;

#line 964
typedef struct _MSNdis_CoVendorDriverVersion ;

#line 982
typedef struct _MSNdis_CoMinimumLinkSpeed ;

#line 1000
typedef struct _MSNdis_CoTransmitPdusOk ;

#line 1018
typedef struct _MSNdis_CoReceivePdusOk ;

#line 1036
typedef struct _MSNdis_CoTransmitPduErrors ;

#line 1054
typedef struct _MSNdis_CoReceivePduErrors ;

#line 1072
typedef struct _MSNdis_CoReceivePdusNoBuffer ;

#line 1090
typedef struct _MSNdis_AtmSupportedVcRates ;

#line 1113
typedef struct _MSNdis_AtmSupportedServiceCategory ;

#line 1131
typedef struct _MSNdis_AtmSupportedAalTypes ;

#line 1149
typedef struct _MSNdis_AtmHardwareCurrentAddress ;

#line 1167
typedef struct _MSNdis_AtmMaxActiveVcs ;

#line 1185
typedef struct _MSNdis_AtmMaxActiveVciBits ;

#line 1203
typedef struct _MSNdis_AtmMaxActiveVpiBits ;

#line 1221
typedef struct _MSNdis_AtmMaxAal0PacketSize ;

#line 1239
typedef struct _MSNdis_AtmMaxAal1PacketSize ;

#line 1257
typedef struct _MSNdis_AtmMaxAal34PacketSize ;

#line 1275
typedef struct _MSNdis_AtmMaxAal5PacketSize ;

#line 1293
typedef struct _MSNdis_AtmReceiveCellsOk ;

#line 1311
typedef struct _MSNdis_AtmTransmitCellsOk ;

#line 1329
typedef struct _MSNdis_AtmReceiveCellsDropped ;

#line 1347
typedef struct _MSNdis_EthernetPermanentAddress ;

#line 1365
typedef struct _MSNdis_EthernetCurrentAddress ;

#line 1383
typedef struct _MSNdis_EthernetMulticastList ;

#line 1405
typedef struct _MSNdis_EthernetMaximumMulticastListSize ;

#line 1423
typedef struct _MSNdis_EthernetMacOptions ;

#line 1441
typedef struct _MSNdis_EthernetReceiveErrorAlignment ;

#line 1459
typedef struct _MSNdis_EthernetOneTransmitCollision ;

#line 1477
typedef struct _MSNdis_EthernetMoreTransmitCollisions ;

#line 1495
typedef struct _MSNdis_TokenRingPermanentAddress ;

#line 1513
typedef struct _MSNdis_TokenRingCurrentAddress ;

#line 1531
typedef struct _MSNdis_TokenRingCurrentFunctional ;

#line 1549
typedef struct _MSNdis_TokenRingCurrentGroup ;

#line 1567
typedef struct _MSNdis_TokenRingLastOpenStatus ;

#line 1585
typedef struct _MSNdis_TokenRingCurrentRingStatus ;

#line 1603
typedef struct _MSNdis_TokenRingCurrentRingState ;

#line 1621
typedef struct _MSNdis_TokenRingLineErrors ;

#line 1639
typedef struct _MSNdis_TokenRingLostFrames ;

#line 1657
typedef struct _MSNdis_FddiLongPermanentAddress ;

#line 1675
typedef struct _MSNdis_FddiLongCurrentAddress ;

#line 1693
typedef struct _MSNdis_FddiLongMulticastList ;

#line 1715
typedef struct _MSNdis_FddiLongMaximumListSize ;

#line 1733
typedef struct _MSNdis_FddiShortPermanentAddress ;

#line 1751
typedef struct _MSNdis_FddiShortCurrentAddress ;

#line 1769
typedef struct _MSNdis_FddiShortMulticastList ;

#line 1791
typedef struct _MSNdis_FddiShortMaximumListSize ;

#line 1809
typedef struct _MSNdis_FddiAttachmentType ;

#line 1827
typedef struct _MSNdis_FddiUpstreamNodeLong ;

#line 1845
typedef struct _MSNdis_FddiDownstreamNodeLong ;

#line 1863
typedef struct _MSNdis_FddiFrameErrors ;

#line 1881
typedef struct _MSNdis_FddiFramesLost ;

#line 1899
typedef struct _MSNdis_FddiRingManagmentState ;

#line 1917
typedef struct _MSNdis_FddiLctFailures ;

#line 1935
typedef struct _MSNdis_FddiLemRejects ;

#line 1953
typedef struct _MSNdis_FddiLConnectionState ;

#line 1972
typedef struct _MSNdis_StatusResetStart ;

#line 1988
typedef struct _MSNdis_StatusResetEnd ;

#line 2004
typedef struct _MSNdis_StatusMediaConnect ;

#line 2020
typedef struct _MSNdis_StatusMediaDisconnect ;

#line 2035
typedef struct _MSNdis_StatusMediaSpecificIndication ;

#line 2057
typedef struct _MSNdis_StatusLinkSpeedChange ;

#line 2075
typedef struct _MSNdis_StatusProtocolBind ;

#line 2092
typedef struct _MSNdis_StatusProtocolUnbind ;

#line 2109
typedef struct _KEYBOARD_PORT_WMI_STD_DATA ;

#line 2152
typedef struct _POINTER_PORT_WMI_STD_DATA ;

#line 2205
typedef struct _MSMouse_ClassInformation ;

#line 2223
typedef struct _MSKeyboard_ClassInformation ;

#line 2241
typedef struct _MSAcpi_ThermalZoneTemperature ;

#line 2304
typedef struct _WMI_DISK_GEOMETRY ;

#line 2342
typedef struct _WMI_DISK_PERFORMANCE ;

#line 2415
typedef struct _MSDiskDriver_Performance ;

#line 2437
typedef struct _STORAGE_FAILURE_PREDICT_STATUS ;

#line 2460
typedef struct _STORAGE_FAILURE_PREDICT_DATA ;

#line 2483
typedef struct _STORAGE_FAILURE_PREDICT_EVENT ;

#line 2513
typedef struct _STORAGE_FAILURE_PREDICT_FUNCTION ;

#line 2528
typedef struct _MSIde_PortDeviceInfo ;

#line 2556
typedef struct _MSSerial_PortName ;

#line 2573
typedef struct _SERIAL_WMI_COMM_DATA ;

#line 2723
typedef struct _SERIAL_WMI_HW_DATA ;

#line 2770
typedef struct _SERIAL_WMI_PERF_DATA ;

#line 2813
typedef struct _SERIAL_WMI_COMMPROP ;

#line 2920
typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS ;

#line 2943
typedef struct _PARALLEL_WMI_LOG_INFO ;

#line 3041
typedef struct _REDBOOK_WMI_STD_DATA ;

#line 3094
typedef struct _REDBOOK_WMI_PERF_DATA ;

#line 3137
typedef struct _RegisteredGuids ;

#line 475 "serial.h"
typedef struct _CONFIG_DATA ;

#line 509
typedef struct _SERIAL_CISR_SW ;

#line 520
typedef struct _SERIAL_FIRMWARE_DATA ;

#line 576
typedef struct _SERIAL_DEVICE_STATE ;

#line 646
typedef struct _SERIAL_DEVICE_EXTENSION ;

#line 1808
typedef struct _SERIAL_MULTIPORT_DISPATCH ;

#line 2157
typedef enum _SERIAL_MEM_COMPARES ;

#line 2164
typedef struct _SERIAL_LIST_DATA ;

#line 2169
typedef struct _SERIAL_GLOBALS ;

#line 2180
typedef struct _SERIAL_USER_DATA ;

#line 2206
typedef struct _SERIAL_PTR_CTX ;

#line 20 "serialp.h"
typedef NTSTATUS ;

#line 26
typedef void ;

#line 835
typedef struct _SERIAL_UPDATE_CHAR ;

#line 846
typedef struct _SERIAL_IOCTL_SYNC ;

#line 39 "initunlo.c"
SERIAL_GLOBALS SerialGlobals ;
#line 41
static const LARGE_INTEGER SerialPhysicalZero = {0};
#line 48
SERIAL_FIRMWARE_DATA driverDefaults ;

#line 73

#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGESRP0, SerialInitMultiPort)
#line 76

#pragma alloc_text(PAGESRP0, SerialInitOneController)
#line 77

#pragma alloc_text(PAGESRP0, SerialInitController)
#line 78

#pragma alloc_text(PAGESRP0, SerialFindInitController)
#line 79

#pragma alloc_text(PAGESRP0, SerialGetMappedAddress)
#line 80

#pragma alloc_text(PAGESRP0, SerialRemoveDevObj)
#line 81

#pragma alloc_text(PAGESRP0, SerialReleaseResources)
#line 82

#pragma alloc_text(PAGESRP0, SerialUnload)
#line 83

#pragma alloc_text(PAGESRP0, SerialMemCompare)
#line 91

#pragma alloc_text(PAGESER, SerialGetDivisorFromBaud)
#line 92

#pragma alloc_text(PAGESER, SerialReset)
#line 96
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject , PUNICODE_STRING RegistryPath
	)
{
	#line 131
	RTL_QUERY_REGISTRY_TABLE jensenTable[2] = {0};
	UNICODE_STRING jensenData ;
	UNICODE_STRING jensenValue ;
	BOOLEAN jensenDetected ;
	PUCHAR jensenBuffer ;
	#line 141
	PVOID lockPtr = MmLockPagableDataSection(SerialReset);
	#line 143
	;
	#line 146
	;
	#line 151
	SerialGlobals.PAGESER_Handle = lockPtr;
	#line 153
	(SerialGlobals.RegistryPath).MaximumLength =
		RegistryPath->MaximumLength;
	#line 154
	(SerialGlobals.RegistryPath).Length = RegistryPath->Length;
	(SerialGlobals.RegistryPath).Buffer = ExAllocatePoolWithTag(PagedPool,
		(SerialGlobals.RegistryPath).MaximumLength, 'XMOC');
	#line 158
	if((SerialGlobals.RegistryPath).Buffer == (void *  )0)
	{
		#line 159
		MmUnlockPagableImageSection(lockPtr);
		return (NTSTATUS )0xC000009AL;
	}
	#line 164
	memset((SerialGlobals.RegistryPath).Buffer, 0,
		(SerialGlobals.RegistryPath).MaximumLength);
	memmove((SerialGlobals.RegistryPath).Buffer, RegistryPath->Buffer,
		RegistryPath->Length);
	#line 172
	(& SerialGlobals.AllDevObjs)->Flink = ((&
		SerialGlobals.AllDevObjs)->Blink = & SerialGlobals.AllDevObjs);
	#line 179
	SerialGetConfigDefaults(& driverDefaults, RegistryPath);
	#line 192
	if(driverDefaults.ShouldBreakOnEntry)
	{
		#line 193
		DbgBreakPoint();
	}
	#line 202
	do
	{
		#line 202
		;
	}
	while(0);
	#line 209
	DriverObject->DriverUnload = SerialUnload;
	(DriverObject->DriverExtension)->AddDevice = SerialAddDevice;
	#line 212
	(DriverObject->MajorFunction)[0x09] = SerialFlush;
	(DriverObject->MajorFunction)[0x04] = SerialWrite;
	(DriverObject->MajorFunction)[0x03] = SerialRead;
	(DriverObject->MajorFunction)[0x0e] = SerialIoControl;
	(DriverObject->MajorFunction)[0x0f] = SerialInternalIoControl;
	#line 218
	(DriverObject->MajorFunction)[0x00] = SerialCreateOpen;
	(DriverObject->MajorFunction)[0x02] = SerialClose;
	(DriverObject->MajorFunction)[0x12] = SerialCleanup;
	(DriverObject->MajorFunction)[0x1b] = SerialPnpDispatch;
	(DriverObject->MajorFunction)[0x16] = SerialPowerDispatch;
	#line 224
	(DriverObject->MajorFunction)[0x05] = SerialQueryInformationFile;
	#line 226
	(DriverObject->MajorFunction)[0x06] = SerialSetInformationFile;
	#line 229
	(DriverObject->MajorFunction)[0x17] = SerialSystemControlDispatch;
	#line 232
	if(! (jensenBuffer = ExAllocatePoolWithTag(PagedPool, 512, 'XMOC')))
	{
		#line 243
		jensenDetected = 0;
	}
	else
	{
		#line 252
		jensenData.Length = 0;
		jensenData.MaximumLength = 512;
		jensenData.Buffer = (PWCHAR )(& jensenBuffer[0]);
		RtlInitUnicodeString(& jensenValue, "J\0e\0n\0s\0e\0n\0");
		#line 259
		(jensenTable[0]).Flags = 0x00000020 | 0x00000004;
		#line 261
		(jensenTable[0]).Name = "I\0d\0e\0n\0t\0i\0f\0i\0e\0r\0";
		(jensenTable[0]).EntryContext = & jensenData;
		#line 264
		if(! ((NTSTATUS )RtlQueryRegistryValues(0 | 0x80000000,
			"\134\0R\0E\0G\0I\0S\0T\0R\0Y\0\134\0M\0A\0C\0H\0I\0N\0E\0\134\0H\0A\0R\0D\0W\0A\0R\0E\0\134\0D\0E\0S\0C\0R\0I\0P\0T\0I\0O\0N\0\134\0S\0Y\0S\0T\0E\0M\0",
			& jensenTable[0], (void *  )0, (void *  )0) >= 0))
		{
			#line 274
			jensenDetected = 0;
		}
		else
		{
			#line 283
			if(jensenData.Length <= sizeof(WCHAR ) * 6)
			{
				jensenDetected = 0;
			}
			else
			{
				jensenData.Length -= sizeof(WCHAR ) * 6;
				jensenData.MaximumLength -= sizeof(WCHAR ) * 6;
				jensenData.Buffer = (PWCHAR )(&
					jensenBuffer[sizeof(WCHAR ) * 6]);
				#line 292
				jensenDetected = RtlEqualUnicodeString(&
					jensenData, & jensenValue, 0);
			}
		}
		#line 301
		ExFreePool(jensenBuffer);
	}
	#line 305
	if(jensenDetected)
	{
		#line 310
		do
		{
			#line 310
			;
		}
		while(0);
	}
	driverDefaults.JensenDetected = jensenDetected;
	#line 325
	if(~ 0)
	{
		#line 329
		(void )SerialEnumerateLegacy(DriverObject, RegistryPath, &
			driverDefaults);
	}
	#line 339
	MmUnlockPagableImageSection(lockPtr);
	#line 341
	return (NTSTATUS )0x00000000L;
}

#line 347
BOOLEAN SerialCleanLists(PVOID Context )
{
	#line 367
	PSERIAL_DEVICE_EXTENSION pDevExt = (PSERIAL_DEVICE_EXTENSION )Context;
	#line 373
	if(pDevExt->PortOnAMultiportCard)
	{
		#line 374
		PSERIAL_MULTIPORT_DISPATCH pDispatch
			= (PSERIAL_MULTIPORT_DISPATCH )pDevExt->OurIsrContext;
		#line 377
		do
		{
			#line 377
			;
		}
		while(0);
		#line 379
		(pDispatch->Extensions)[pDevExt->PortIndex - 1] = (void *  )0;
		#line 381
		if(pDevExt->Indexed == 0)
		{
			#line 382
			pDispatch->UsablePortMask &= ~ (1 << pDevExt->PortIndex
				- 1);
			#line 383
			pDispatch->MaskInverted &= ~ pDevExt->NewMaskInverted;
		}
	}
	#line 387
	if(! ((& pDevExt->TopLevelSharers)->Flink == &
		pDevExt->TopLevelSharers))
	{
		#line 389
		do
		{
			#line 389
			;
		}
		while(0);
		#line 395
		if(! ((& pDevExt->MultiportSiblings)->Flink == &
			pDevExt->MultiportSiblings))
		{
			#line 396
			PSERIAL_DEVICE_EXTENSION pNewRoot ;
			#line 398
			do
			{
				#line 398
				;
			}
			while(0);
			#line 400
			pNewRoot = (SERIAL_DEVICE_EXTENSION *  )((PCHAR
				)(pDevExt->MultiportSiblings).Flink - (ULONG_PTR
				)(& ((SERIAL_DEVICE_EXTENSION * 
				)0)->MultiportSiblings));
			#line 408
			;
			{
				#line 409
				PLIST_ENTRY _EX_Blink ;
				#line 409
				PLIST_ENTRY _EX_ListHead ;
				#line 409
				_EX_ListHead = & pDevExt->TopLevelSharers;
				#line 409
				_EX_Blink = _EX_ListHead->Blink;
				#line 409
				(& pNewRoot->TopLevelSharers)->Flink =
					_EX_ListHead;
				#line 409
				(& pNewRoot->TopLevelSharers)->Blink =
					_EX_Blink;
				#line 409
				_EX_Blink->Flink = & pNewRoot->TopLevelSharers;
				#line 409
				_EX_ListHead->Blink = &
					pNewRoot->TopLevelSharers;
			}
			#line 409
			;
		}
		{
			#line 417
			PLIST_ENTRY _EX_Blink ;
			#line 417
			PLIST_ENTRY _EX_Flink ;
			#line 417
			_EX_Flink = (& pDevExt->TopLevelSharers)->Flink;
			#line 417
			_EX_Blink = (& pDevExt->TopLevelSharers)->Blink;
			#line 417
			_EX_Blink->Flink = _EX_Flink;
			#line 417
			_EX_Flink->Blink = _EX_Blink;
		}
		#line 417
		;
		(& pDevExt->TopLevelSharers)->Flink = ((&
			pDevExt->TopLevelSharers)->Blink = &
			pDevExt->TopLevelSharers);
		#line 424
		if(! ((& (pDevExt->CIsrSw)->SharerList)->Flink == &
			(pDevExt->CIsrSw)->SharerList))
		{
			#line 430
			pDevExt->Interrupt = (void *  )0;
		}
	}
	#line 439
	if(! ((& pDevExt->MultiportSiblings)->Flink == &
		pDevExt->MultiportSiblings))
	{
		#line 440
		do
		{
			#line 440
			;
		}
		while(0);
		{
			#line 441
			PLIST_ENTRY _EX_Blink ;
			#line 441
			PLIST_ENTRY _EX_Flink ;
			#line 441
			_EX_Flink = (& pDevExt->MultiportSiblings)->Flink;
			#line 441
			_EX_Blink = (& pDevExt->MultiportSiblings)->Blink;
			#line 441
			_EX_Blink->Flink = _EX_Flink;
			#line 441
			_EX_Flink->Blink = _EX_Blink;
		}
		#line 441
		;
		(& pDevExt->MultiportSiblings)->Flink = ((&
			pDevExt->MultiportSiblings)->Blink = &
			pDevExt->MultiportSiblings);
	}
	if(! ((& pDevExt->CommonInterruptObject)->Flink == &
		pDevExt->CommonInterruptObject))
	{
		#line 448
		do
		{
			#line 448
			;
		}
		while(0);
		{
			#line 450
			PLIST_ENTRY _EX_Blink ;
			#line 450
			PLIST_ENTRY _EX_Flink ;
			#line 450
			_EX_Flink = (& pDevExt->CommonInterruptObject)->Flink;
			#line 450
			_EX_Blink = (& pDevExt->CommonInterruptObject)->Blink;
			#line 450
			_EX_Blink->Flink = _EX_Flink;
			#line 450
			_EX_Flink->Blink = _EX_Blink;
		}
		#line 450
		;
		(& pDevExt->CommonInterruptObject)->Flink = ((&
			pDevExt->CommonInterruptObject)->Blink = &
			pDevExt->CommonInterruptObject);
		#line 458
		pDevExt->Interrupt = (void *  )0;
	}
	#line 465
	;
	{
		PLIST_ENTRY _EX_Blink ;
		#line 467
		PLIST_ENTRY _EX_Flink ;
		#line 467
		_EX_Flink = (& pDevExt->AllDevObjs)->Flink;
		#line 467
		_EX_Blink = (& pDevExt->AllDevObjs)->Blink;
		#line 467
		_EX_Blink->Flink = _EX_Flink;
		#line 467
		_EX_Flink->Blink = _EX_Blink;
	}
	#line 467
	;
	(& pDevExt->AllDevObjs)->Flink = ((& pDevExt->AllDevObjs)->Blink = &
		pDevExt->AllDevObjs);
	return 1;
}

#line 475
void SerialReleaseResources(PSERIAL_DEVICE_EXTENSION PDevExt )
{
	#line 493
	;
	#line 495
	do
	{
		#line 495
		;
	}
	while(0);
	#line 501
	if(PDevExt->Interrupt != (void *  )0)
	{
		#line 502
		KeSynchronizeExecution(PDevExt->Interrupt, SerialCleanLists,
			PDevExt);
	}
	#line 509
	if(PDevExt->Interrupt != (void *  )0)
	{
		#line 516
		do
		{
			#line 516
			;
		}
		while(0);
		#line 518
		IoDisconnectInterrupt(PDevExt->Interrupt);
		PDevExt->Interrupt = (void *  )0;
		#line 521
		if(PDevExt->CIsrSw != (void *  )0)
		{
			#line 522
			ExFreePool(PDevExt->CIsrSw);
			PDevExt->CIsrSw = (void *  )0;
		}
	}
	#line 527
	if(PDevExt->PortOnAMultiportCard)
	{
		#line 528
		ULONG i ;
		__BLAST_NONDET ;
		#line 534
		//BLAST forloop for(i = 0; i < 16; i++)
		for(i = 0; i < __BLAST_NONDET; i++)
		{
			#line 535
			if((((PSERIAL_MULTIPORT_DISPATCH
				)PDevExt->OurIsrContext)->Extensions)[i] !=
				(void *  )0)
			{
				#line 537
				break;
			}
		}
		#line 541
		if(i == 16)
		{
			#line 542
			do
			{
				#line 542
				;
			}
			while(0);
			#line 543
			ExFreePool(PDevExt->OurIsrContext);
		}
	}
	#line 552
	SerialCancelTimer(& PDevExt->ReadRequestTotalTimer, PDevExt);
	SerialCancelTimer(& PDevExt->ReadRequestIntervalTimer, PDevExt);
	SerialCancelTimer(& PDevExt->WriteRequestTotalTimer, PDevExt);
	SerialCancelTimer(& PDevExt->ImmediateTotalTimer, PDevExt);
	SerialCancelTimer(& PDevExt->XoffCountTimer, PDevExt);
	SerialCancelTimer(& PDevExt->LowerRTSTimer, PDevExt);
	{
		#line 563
		if(KeRemoveQueueDpc(& PDevExt->CompleteWriteDpc))
		{
			#line 563
			InterlockedDecrement(& PDevExt->DpcCount);
		}
	}
	#line 563
	;
	{
		#line 564
		if(KeRemoveQueueDpc(& PDevExt->CompleteReadDpc))
		{
			#line 564
			InterlockedDecrement(& PDevExt->DpcCount);
		}
	}
	#line 564
	;
	{
		#line 565
		if(KeRemoveQueueDpc(& PDevExt->TotalReadTimeoutDpc))
		{
			#line 565
			InterlockedDecrement(& PDevExt->DpcCount);
		}
	}
	#line 565
	;
	{
		#line 566
		if(KeRemoveQueueDpc(& PDevExt->IntervalReadTimeoutDpc))
		{
			#line 566
			InterlockedDecrement(& PDevExt->DpcCount);
		}
	}
	#line 566
	;
	{
		#line 567
		if(KeRemoveQueueDpc(& PDevExt->TotalWriteTimeoutDpc))
		{
			#line 567
			InterlockedDecrement(& PDevExt->DpcCount);
		}
	}
	#line 567
	;
	{
		#line 568
		if(KeRemoveQueueDpc(& PDevExt->CommErrorDpc))
		{
			#line 568
			InterlockedDecrement(& PDevExt->DpcCount);
		}
	}
	#line 568
	;
	{
		#line 569
		if(KeRemoveQueueDpc(& PDevExt->CompleteImmediateDpc))
		{
			#line 569
			InterlockedDecrement(& PDevExt->DpcCount);
		}
	}
	#line 569
	;
	{
		#line 570
		if(KeRemoveQueueDpc(& PDevExt->TotalImmediateTimeoutDpc))
		{
			#line 570
			InterlockedDecrement(& PDevExt->DpcCount);
		}
	}
	#line 570
	;
	{
		#line 571
		if(KeRemoveQueueDpc(& PDevExt->CommWaitDpc))
		{
			#line 571
			InterlockedDecrement(& PDevExt->DpcCount);
		}
	}
	#line 571
	;
	{
		#line 572
		if(KeRemoveQueueDpc(& PDevExt->XoffCountTimeoutDpc))
		{
			#line 572
			InterlockedDecrement(& PDevExt->DpcCount);
		}
	}
	#line 572
	;
	{
		#line 573
		if(KeRemoveQueueDpc(& PDevExt->XoffCountCompleteDpc))
		{
			#line 573
			InterlockedDecrement(& PDevExt->DpcCount);
		}
	}
	#line 573
	;
	{
		#line 574
		if(KeRemoveQueueDpc(& PDevExt->StartTimerLowerRTSDpc))
		{
			#line 574
			InterlockedDecrement(& PDevExt->DpcCount);
		}
	}
	#line 574
	;
	{
		#line 575
		if(KeRemoveQueueDpc(& PDevExt->PerhapsLowerRTSDpc))
		{
			#line 575
			InterlockedDecrement(& PDevExt->DpcCount);
		}
	}
	#line 575
	;
	#line 583
	if(PDevExt->UnMapRegisters)
	{
		#line 584
		MmUnmapIoSpace(PDevExt->Controller, PDevExt->SpanOfController);
	}
	#line 587
	if(PDevExt->UnMapStatus)
	{
		#line 588
		MmUnmapIoSpace(PDevExt->InterruptStatus,
			PDevExt->SpanOfInterruptStatus);
	}
	#line 592
	do
	{
		#line 592
		;
	}
	while(0);
}

NTSTATUS SerialPrepareRemove(PDEVICE_OBJECT PDevObj )
{
	#line 615
	PSERIAL_DEVICE_EXTENSION pDevExt = (PSERIAL_DEVICE_EXTENSION
		)PDevObj->DeviceExtension;
	POWER_STATE state ;
	ULONG pendingIRPs ;
	#line 620
	;
	#line 622
	do
	{
		#line 622
		;
	}
	while(0);
	#line 628
	SerialSetDeviceFlags(pDevExt, & pDevExt->DevicePNPAccept, 0x1L, 1);
	#line 634
	SerialKillPendingIrps(PDevObj);
	#line 640
	pendingIRPs = InterlockedDecrement(& pDevExt->PendingIRPCnt);
	#line 642
	if(pendingIRPs)
	{
		#line 643
		KeWaitForSingleObject(& pDevExt->PendingIRPEvent, Executive,
			KernelMode, 0, (void *  )0);
	}
	#line 647
	state.DeviceState = PowerDeviceD3;
	#line 649
	PoSetPowerState(PDevObj, DevicePowerState, state);
	#line 651
	return 1;
}

#line 655
void SerialDisableInterfacesResources(PDEVICE_OBJECT PDevObj , BOOLEAN
	DisableUART )
{
	#line 659
	PSERIAL_DEVICE_EXTENSION pDevExt = (PSERIAL_DEVICE_EXTENSION
		)PDevObj->DeviceExtension;
	#line 662
	;
	#line 664
	do
	{
		#line 664
		;
	}
	while(0);
	#line 671
	if(pDevExt->Flags & 0x1L)
	{
		#line 672
		if(! (pDevExt->Flags & 0x2L))
		{
			if(DisableUART)
			{
				#line 679
				do
				{
					#line 679
					do
					{
						#line 679
						WRITE_PORT_UCHAR(pDevExt->Controller
							+ (ULONG )(0x01 * 1),
							0);
					}
					while(0);
				}
				while(0);
			}
			#line 682
			SerialReleaseResources(pDevExt);
		}
		#line 689
		IoWMIRegistrationControl(PDevObj, 2);
	}
	#line 696
	SerialUndoExternalNaming(pDevExt);
	#line 698
	do
	{
		#line 698
		;
	}
	while(0);
}

#line 702
NTSTATUS SerialRemoveDevObj(PDEVICE_OBJECT PDevObj )
{
	#line 720
	PSERIAL_DEVICE_EXTENSION pDevExt = (PSERIAL_DEVICE_EXTENSION
		)PDevObj->DeviceExtension;
	#line 723
	;
	#line 725
	do
	{
		#line 725
		;
	}
	while(0);
	#line 727
	if(! (pDevExt->DevicePNPAccept & 0x8L))
	{
		#line 732
		SerialDisableInterfacesResources(PDevObj, 1);
	}
	#line 735
	IoDetachDevice(pDevExt->LowerDeviceObject);
	#line 741
	if((pDevExt->NtNameForPort).Buffer != (void *  )0)
	{
		#line 742
		ExFreePool((pDevExt->NtNameForPort).Buffer);
	}
	#line 745
	if((pDevExt->DeviceName).Buffer != (void *  )0)
	{
		#line 746
		ExFreePool((pDevExt->DeviceName).Buffer);
	}
	#line 749
	if((pDevExt->SymbolicLinkName).Buffer != (void *  )0)
	{
		#line 750
		ExFreePool((pDevExt->SymbolicLinkName).Buffer);
	}
	#line 753
	if((pDevExt->DosName).Buffer != (void *  )0)
	{
		#line 754
		ExFreePool((pDevExt->DosName).Buffer);
	}
	#line 757
	if((pDevExt->ObjectDirectory).Buffer)
	{
		#line 758
		ExFreePool((pDevExt->ObjectDirectory).Buffer);
	}
	#line 765
	IoDeleteDevice(PDevObj);
	#line 768
	do
	{
		#line 768
		;
	}
	while(0);
	#line 770
	return (NTSTATUS )0x00000000L;
}

#line 774
void SerialKillPendingIrps(PDEVICE_OBJECT PDevObj )
{
	#line 792
	PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
	KIRQL oldIrql ;
	#line 795
	do
	{
		#line 795
		;
	}
	while(0);
	#line 801
	SerialKillAllReadsOrWrites(PDevObj, & pDevExt->WriteQueue, &
		pDevExt->CurrentWriteIrp);
	#line 804
	SerialKillAllReadsOrWrites(PDevObj, & pDevExt->ReadQueue, &
		pDevExt->CurrentReadIrp);
	#line 811
	SerialKillAllReadsOrWrites(PDevObj, & pDevExt->PurgeQueue, &
		pDevExt->CurrentPurgeIrp);
	#line 818
	SerialKillAllReadsOrWrites(PDevObj, & pDevExt->MaskQueue, &
		pDevExt->CurrentMaskIrp);
	#line 825
	IoAcquireCancelSpinLock(& oldIrql);
	#line 827
	if(pDevExt->CurrentWaitIrp)
	{
		PDRIVER_CANCEL cancelRoutine ;
		#line 831
		cancelRoutine = (pDevExt->CurrentWaitIrp)->CancelRoutine;
		(pDevExt->CurrentWaitIrp)->Cancel = 1;
		#line 834
		if(cancelRoutine)
		{
			(pDevExt->CurrentWaitIrp)->CancelIrql = oldIrql;
			(pDevExt->CurrentWaitIrp)->CancelRoutine = (void *  )0;
			#line 839
			cancelRoutine(PDevObj, pDevExt->CurrentWaitIrp);
		}
	}
	else
	{
		#line 845
		IoReleaseCancelSpinLock(oldIrql);
	}
	#line 853
	if(pDevExt->PendingWakeIrp != (void *  )0)
	{
		#line 854
		IoCancelIrp(pDevExt->PendingWakeIrp);
		pDevExt->PendingWakeIrp = (void *  )0;
	}
	#line 862
	SerialKillAllStalled(PDevObj);
	#line 865
	do
	{
		#line 865
		;
	}
	while(0);
}

#line 869
BOOLEAN SerialSingleToMulti(PVOID Context )
{
	#line 889
	PSERIAL_DEVICE_EXTENSION pDevExt = (PSERIAL_DEVICE_EXTENSION )Context;
	PSERIAL_MULTIPORT_DISPATCH pOurIsrContext ;
	PSERIAL_MULTIPORT_DISPATCH pNewIsrContext = (PSERIAL_MULTIPORT_DISPATCH
		)pDevExt->NewExtension;
	PVOID isrFunc ;
	#line 895
	do
	{
		#line 895
		;
	}
	while(0);
	#line 903
	pOurIsrContext = (pDevExt->OurIsrContext =
		(pDevExt->TopLevelOurIsrContext = pNewIsrContext));
	#line 910
	pDevExt->PortOnAMultiportCard = 1;
	#line 916
	(pOurIsrContext->Extensions)[pDevExt->PortIndex - 1] = pDevExt;
	pOurIsrContext->InterruptStatus = pDevExt->InterruptStatus;
	#line 926
	if(pDevExt->Indexed == 0)
	{
		#line 927
		pOurIsrContext->UsablePortMask = 1 << pDevExt->PortIndex - 1;
		pOurIsrContext->MaskInverted = pDevExt->MaskInverted;
		isrFunc = SerialBitMappedMultiportIsr;
	}
	else
	{
		#line 931
		isrFunc = SerialIndexedMultiportIsr;
	}
	#line 934
	pDevExt->OurIsr = isrFunc;
	pDevExt->TopLevelOurIsr = isrFunc;
	#line 937
	if((pDevExt->CIsrSw)->IsrFunc != SerialSharerIsr)
	{
		#line 938
		(pDevExt->CIsrSw)->IsrFunc = isrFunc;
		(pDevExt->CIsrSw)->Context = pOurIsrContext;
	}
	#line 942
	do
	{
		#line 942
		;
	}
	while(0);
	#line 943
	return 1;
}

#line 947
BOOLEAN SerialAddToMulti(PVOID Context )
{
	#line 967
	PSERIAL_DEVICE_EXTENSION pDevExt = (PSERIAL_DEVICE_EXTENSION )Context;
	PSERIAL_MULTIPORT_DISPATCH pOurIsrContext = (PSERIAL_MULTIPORT_DISPATCH
		)pDevExt->OurIsrContext;
	PSERIAL_DEVICE_EXTENSION pNewExt = (PSERIAL_DEVICE_EXTENSION
		)pDevExt->NewExtension;
	#line 974
	do
	{
		#line 974
		;
	}
	while(0);
	#line 976
	if(pDevExt->Indexed == 0)
	{
		#line 977
		pOurIsrContext->UsablePortMask |= 1 << pDevExt->NewPortIndex -
			1;
		#line 978
		pOurIsrContext->MaskInverted |= pDevExt->NewMaskInverted;
	}
	#line 987
	if((& pNewExt->CommonInterruptObject)->Flink == &
		pNewExt->CommonInterruptObject)
	{
		{
			#line 989
			PLIST_ENTRY _EX_Blink ;
			#line 989
			PLIST_ENTRY _EX_ListHead ;
			#line 989
			_EX_ListHead = & pDevExt->CommonInterruptObject;
			#line 989
			_EX_Blink = _EX_ListHead->Blink;
			#line 989
			(& pNewExt->CommonInterruptObject)->Flink =
				_EX_ListHead;
			#line 989
			(& pNewExt->CommonInterruptObject)->Blink = _EX_Blink;
			#line 989
			_EX_Blink->Flink = & pNewExt->CommonInterruptObject;
			#line 989
			_EX_ListHead->Blink = & pNewExt->CommonInterruptObject;
		}
		#line 989
		;
	}
	#line 996
	pNewExt->OurIsrContext = pOurIsrContext;
	{
		#line 1002
		PLIST_ENTRY _EX_Blink ;
		#line 1002
		PLIST_ENTRY _EX_ListHead ;
		#line 1002
		_EX_ListHead = & pDevExt->MultiportSiblings;
		#line 1002
		_EX_Blink = _EX_ListHead->Blink;
		#line 1002
		(& pNewExt->MultiportSiblings)->Flink = _EX_ListHead;
		#line 1002
		(& pNewExt->MultiportSiblings)->Blink = _EX_Blink;
		#line 1002
		_EX_Blink->Flink = & pNewExt->MultiportSiblings;
		#line 1002
		_EX_ListHead->Blink = & pNewExt->MultiportSiblings;
	}
	#line 1002
	;
	#line 1004
	do
	{
		#line 1004
		;
	}
	while(0);
	#line 1005
	do
	{
		#line 1005
		;
	}
	while(0);
	#line 1011
	(pOurIsrContext->Extensions)[pDevExt->NewPortIndex - 1] =
		pDevExt->NewExtension;
	#line 1014
	pNewExt->TopLevelOurIsr = pDevExt->TopLevelOurIsr;
	pNewExt->TopLevelOurIsrContext = pDevExt->TopLevelOurIsrContext;
	#line 1017
	do
	{
		#line 1017
		;
	}
	while(0);
	#line 1018
	return 1;
}

#line 1023
NTSTATUS SerialInitMultiPort(PSERIAL_DEVICE_EXTENSION PDevExt , PCONFIG_DATA
	PConfigData , PDEVICE_OBJECT PDevObj )
{
	#line 1048
	PSERIAL_DEVICE_EXTENSION pOurIsrContext = (PSERIAL_DEVICE_EXTENSION
		)PDevExt->OurIsrContext;
	PSERIAL_DEVICE_EXTENSION pNewExt = (PSERIAL_DEVICE_EXTENSION
		)PDevObj->DeviceExtension;
	NTSTATUS status ;
	PSERIAL_MULTIPORT_DISPATCH pDispatch ;
	#line 1055
	;
	#line 1058
	do
	{
		#line 1058
		;
	}
	while(0);
	#line 1064
	pNewExt->CIsrSw = PDevExt->CIsrSw;
	pNewExt->Interrupt = PDevExt->Interrupt;
	#line 1071
	status = SerialInitOneController(PDevObj, PConfigData);
	#line 1073
	if(! ((NTSTATUS )status >= 0))
	{
		#line 1074
		do
		{
			#line 1074
			;
		}
		while(0);
		#line 1075
		return status;
	}
	#line 1083
	if(PDevExt->PortOnAMultiportCard != 1)
	{
		pDispatch = (PDevExt->NewExtension =
			ExAllocatePoolWithTag(NonPagedPool,
			sizeof(SERIAL_MULTIPORT_DISPATCH ), 'XMOC'));
		if(pDispatch == (void *  )0)
		{
			do
			{
				#line 1090
				;
			}
			while(0);
			#line 1091
			return (NTSTATUS )0xC000009AL;
		}
		#line 1094
		memset(pDispatch, 0, sizeof(* pDispatch));
		KeSynchronizeExecution(PDevExt->Interrupt, SerialSingleToMulti,
			PDevExt);
	}
	#line 1102
	((PSERIAL_DEVICE_EXTENSION
		)PDevObj->DeviceExtension)->PortOnAMultiportCard = 1;
	((PSERIAL_DEVICE_EXTENSION )PDevObj->DeviceExtension)->OurIsr = (void * 
		)0;
	#line 1107
	PDevExt->NewPortIndex = PConfigData->PortIndex;
	PDevExt->NewMaskInverted = PConfigData->MaskInverted;
	PDevExt->NewExtension = PDevObj->DeviceExtension;
	#line 1116
	KeSynchronizeExecution(PDevExt->Interrupt, SerialAddToMulti, PDevExt);
	#line 1118
	do
	{
		#line 1118
		;
	}
	while(0);
	#line 1119
	return (NTSTATUS )0x00000000L;
}

#line 1124
NTSTATUS SerialInitController(PDEVICE_OBJECT PDevObj , PCONFIG_DATA PConfigData
	)
{
	#line 1150
	PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
	#line 1157
	UNICODE_STRING uniNameString ;
	#line 1164
	NTSTATUS status = (NTSTATUS )0x00000000L;
	#line 1171
	BOOLEAN conflictDetected = 0;
	#line 1177
	BOOLEAN allocedISRSw = 0;
	#line 1179
	;
	#line 1186
	do
	{
		#line 1186
		;
	}
	while(0);
	#line 1193
	if(* KdComPortInUse == (PUCHAR )(PConfigData->Controller).LowPart)
	{
		#line 1197
		do
		{
			#line 1197
			;
		}
		while(0);
		#line 1199
		SerialLogError(PDevObj->DriverObject, (void *  )0,
			PConfigData->TrController, SerialPhysicalZero, 0, 0, 0,
			3, (NTSTATUS )0x00000000L, (NTSTATUS )0x40060001L,
			(pDevExt->DeviceName).Length + sizeof(WCHAR ),
			(pDevExt->DeviceName).Buffer, 0, (void *  )0);
		#line 1216
		return (NTSTATUS )0xC000009AL;
	}
	#line 1220
	if(pDevExt->CIsrSw == (void *  )0)
	{
		#line 1221
		if((pDevExt->CIsrSw = ExAllocatePoolWithTag(NonPagedPool,
			sizeof(SERIAL_CISR_SW ), 'XMOC')) == (void *  )0)
		{
			#line 1223
			return (NTSTATUS )0xC000009AL;
		}
		#line 1226
		(& (pDevExt->CIsrSw)->SharerList)->Flink = ((&
			(pDevExt->CIsrSw)->SharerList)->Blink = &
			(pDevExt->CIsrSw)->SharerList);
		#line 1228
		allocedISRSw = 1;
	}
	#line 1235
	pDevExt->Jensen = PConfigData->Jensen;
	#line 1243
	KeInitializeSpinLock(& pDevExt->ControlLock);
	KeInitializeSpinLock(& pDevExt->FlagsLock);
	#line 1251
	KeInitializeTimer(& pDevExt->ReadRequestTotalTimer);
	KeInitializeTimer(& pDevExt->ReadRequestIntervalTimer);
	KeInitializeTimer(& pDevExt->WriteRequestTotalTimer);
	KeInitializeTimer(& pDevExt->ImmediateTotalTimer);
	KeInitializeTimer(& pDevExt->XoffCountTimer);
	KeInitializeTimer(& pDevExt->LowerRTSTimer);
	#line 1264
	KeInitializeDpc(& pDevExt->CompleteWriteDpc, SerialCompleteWrite,
		pDevExt);
	#line 1265
	KeInitializeDpc(& pDevExt->CompleteReadDpc, SerialCompleteRead,
		pDevExt);
	#line 1266
	KeInitializeDpc(& pDevExt->TotalReadTimeoutDpc, SerialReadTimeout,
		pDevExt);
	#line 1267
	KeInitializeDpc(& pDevExt->IntervalReadTimeoutDpc,
		SerialIntervalReadTimeout, pDevExt);
	KeInitializeDpc(& pDevExt->TotalWriteTimeoutDpc, SerialWriteTimeout,
		pDevExt);
	#line 1270
	KeInitializeDpc(& pDevExt->CommErrorDpc, SerialCommError, pDevExt);
	KeInitializeDpc(& pDevExt->CompleteImmediateDpc,
		SerialCompleteImmediate, pDevExt);
	KeInitializeDpc(& pDevExt->TotalImmediateTimeoutDpc,
		SerialTimeoutImmediate, pDevExt);
	KeInitializeDpc(& pDevExt->CommWaitDpc, SerialCompleteWait, pDevExt);
	KeInitializeDpc(& pDevExt->XoffCountTimeoutDpc, SerialTimeoutXoff,
		pDevExt);
	#line 1277
	KeInitializeDpc(& pDevExt->XoffCountCompleteDpc, SerialCompleteXoff,
		pDevExt);
	#line 1278
	KeInitializeDpc(& pDevExt->StartTimerLowerRTSDpc,
		SerialStartTimerLowerRTS, pDevExt);
	KeInitializeDpc(& pDevExt->PerhapsLowerRTSDpc,
		SerialInvokePerhapsLowerRTS, pDevExt);
	KeInitializeDpc(& pDevExt->IsrUnlockPagesDpc, SerialUnlockPages,
		pDevExt);
	#line 1306
	if(! (PConfigData->ClockRate == 1843200 || PConfigData->ClockRate ==
		3072000 || PConfigData->ClockRate == 4233600 ||
		PConfigData->ClockRate == 8000000))
	{
		#line 1311
		SerialLogError(PDevObj->DriverObject, PDevObj,
			PConfigData->TrController, SerialPhysicalZero, 0, 0, 0,
			6, (NTSTATUS )0x00000000L, (NTSTATUS )0xC0060009L,
			(pDevExt->DeviceName).Length + sizeof(WCHAR ),
			(pDevExt->DeviceName).Buffer, 0, (void *  )0);
		#line 1332
		do
		{
			#line 1332
			;
		}
		while(0);
		#line 1334
		status = (NTSTATUS )0xC0000150L;
		goto ExtensionCleanup;
	}
	#line 1345
	pDevExt->ClockRate = PConfigData->ClockRate;
	#line 1355
	pDevExt->Controller = SerialGetMappedAddress(PConfigData->InterfaceType,
		PConfigData->BusNumber, PConfigData->TrController,
		PConfigData->SpanOfController, (BOOLEAN
		)PConfigData->AddressSpace, & pDevExt->UnMapRegisters);
	#line 1363
	if(! pDevExt->Controller)
	{
		SerialLogError(PDevObj->DriverObject, pDevExt->DeviceObject,
			PConfigData->TrController, SerialPhysicalZero, 0, 0, 0,
			7, (NTSTATUS )0x00000000L, (NTSTATUS )0xC006000AL,
			(pDevExt->DeviceName).Length + sizeof(WCHAR ),
			(pDevExt->DeviceName).Buffer, 0, (void *  )0);
		#line 1386
		do
		{
			#line 1386
			;
		}
		while(0);
		#line 1388
		pDevExt->UnMapRegisters = 0;
		status = (NTSTATUS )0xC0000073L;
		goto ExtensionCleanup;
	}
	#line 1394
	pDevExt->AddressSpace = PConfigData->AddressSpace;
	pDevExt->OriginalController = PConfigData->Controller;
	pDevExt->SpanOfController = PConfigData->SpanOfController;
	#line 1403
	pDevExt->InterruptStatus = (PUCHAR
		)(PConfigData->TrInterruptStatus).QuadPart;
	#line 1406
	if(pDevExt->InterruptStatus)
	{
		pDevExt->InterruptStatus =
			SerialGetMappedAddress(PConfigData->InterfaceType,
			PConfigData->BusNumber, PConfigData->TrInterruptStatus,
			PConfigData->SpanOfInterruptStatus, (BOOLEAN
			)PConfigData->AddressSpace, & pDevExt->UnMapStatus);
		#line 1417
		if(! pDevExt->InterruptStatus)
		{
			SerialLogError(PDevObj->DriverObject, PDevObj,
				PConfigData->TrController, SerialPhysicalZero,
				0, 0, 0, 8, (NTSTATUS )0x00000000L, (NTSTATUS
				)0xC006000AL, (pDevExt->DeviceName).Length +
				sizeof(WCHAR ), (pDevExt->DeviceName).Buffer, 0,
				(void *  )0);
			#line 1438
			do
			{
				#line 1438
				;
			}
			while(0);
			#line 1444
			if(pDevExt->UnMapRegisters)
			{
				#line 1445
				MmUnmapIoSpace((PVOID
					)(PConfigData->TrController).QuadPart,
					PConfigData->SpanOfController);
			}
			pDevExt->UnMapRegisters = 0;
			pDevExt->UnMapStatus = 0;
			status = (NTSTATUS )0xC0000073L;
			goto ExtensionCleanup;
		}
		#line 1456
		pDevExt->OriginalInterruptStatus = PConfigData->InterruptStatus;
		pDevExt->SpanOfInterruptStatus =
			PConfigData->SpanOfInterruptStatus;
	}
	#line 1467
	if((BOOLEAN )PConfigData->PermitSystemWideShare)
	{
		#line 1468
		pDevExt->InterruptShareable = 1;
	}
	#line 1475
	pDevExt->InterfaceType = PConfigData->InterfaceType;
	pDevExt->BusNumber = PConfigData->BusNumber;
	#line 1478
	pDevExt->PortIndex = PConfigData->PortIndex;
	pDevExt->Indexed = (BOOLEAN )PConfigData->Indexed;
	pDevExt->MaskInverted = PConfigData->MaskInverted;
	#line 1486
	pDevExt->OriginalIrql = PConfigData->OriginalIrql;
	pDevExt->OriginalVector = PConfigData->OriginalVector;
	#line 1495
	pDevExt->Vector = PConfigData->TrVector;
	pDevExt->Irql = (UCHAR )PConfigData->TrIrql;
	#line 1502
	pDevExt->OurIsr = SerialISR;
	pDevExt->OurIsrContext = pDevExt;
	#line 1511
	pDevExt->PermitShare = PConfigData->PermitShare;
	#line 1521
	switch(PConfigData->RxFIFO)
	{
	case 1:
			#line 1523
			;
		#line 1525
		pDevExt->RxFifoTrigger = (UCHAR )0x00;
		break;
		#line 1528
	case 4:
			#line 1528
			;
		#line 1530
		pDevExt->RxFifoTrigger = (UCHAR )0x40;
		break;
		#line 1533
	case 8:
			#line 1533
			;
		#line 1535
		pDevExt->RxFifoTrigger = (UCHAR )0x80;
		break;
		#line 1538
	case 14:
			#line 1538
			;
		#line 1540
		pDevExt->RxFifoTrigger = (UCHAR )0xc0;
		break;
		#line 1543
	default :
			#line 1543
			;
		#line 1545
		pDevExt->RxFifoTrigger = (UCHAR )0x00;
		break;
	}
	#line 1551
	if(PConfigData->TxFIFO > 16 || PConfigData->TxFIFO < 1)
	{
		#line 1554
		pDevExt->TxFifoAmount = 1;
	}
	else
	{
		pDevExt->TxFifoAmount = PConfigData->TxFIFO;
	}
	#line 1563
	if(! SerialDoesPortExist(pDevExt, & pDevExt->DeviceName,
		PConfigData->ForceFifoEnable, PConfigData->LogFifo))
	{
		#line 1580
		do
		{
			#line 1580
			;
		}
		while(0);
		#line 1582
		status = (NTSTATUS )0xC000000EL;
		goto ExtensionCleanup;
	}
	#line 1593
	if(PConfigData->DisablePort)
	{
		#line 1599
		do
		{
			#line 1599
			;
		}
		while(0);
		#line 1601
		status = (NTSTATUS )0xC000000EL;
		#line 1603
		SerialLogError(PDevObj->DriverObject, PDevObj,
			PConfigData->Controller, SerialPhysicalZero, 0, 0, 0,
			57, (NTSTATUS )0x00000000L, (NTSTATUS )0x40060022L,
			(pDevExt->DeviceName).Length + sizeof(WCHAR ),
			(pDevExt->DeviceName).Buffer, 0, (void *  )0);
		#line 1620
		goto ExtensionCleanup;
	}
	#line 1633
	(pDevExt->SpecialChars).XonChar = 0x11;
	(pDevExt->SpecialChars).XoffChar = 0x13;
	(pDevExt->HandFlow).ControlHandShake = (ULONG )0x01;
	(pDevExt->HandFlow).FlowReplace = (ULONG )0x40;
	#line 1647
	pDevExt->LineControl = (UCHAR )0x02 | (UCHAR )0x18 | (UCHAR )0x00;
	#line 1651
	pDevExt->ValidDataMask = 0x7f;
	pDevExt->CurrentBaud = 1200;
	#line 1662
	(pDevExt->HandFlow).XoffLimit = pDevExt->BufferSize >> 3;
	(pDevExt->HandFlow).XonLimit = pDevExt->BufferSize >> 1;
	#line 1665
	pDevExt->BufferSizePt8 = 3 * (pDevExt->BufferSize >> 2) +
		(pDevExt->BufferSize >> 4);
	#line 1678
	do
	{
		#line 1678
		;
	}
	while(0);
	#line 1686
	pDevExt->SupportedBauds = (ULONG )0x10000000;
	{
		#line 1690
		SHORT junk ;
		#line 1692
		if(! ((ULONG )SerialGetDivisorFromBaud(pDevExt->ClockRate, (LONG
			)75, & junk) >> 30 == 3))
		{
			#line 1698
			pDevExt->SupportedBauds |= (ULONG )0x00000001;
		}
		#line 1702
		if(! ((ULONG )SerialGetDivisorFromBaud(pDevExt->ClockRate, (LONG
			)110, & junk) >> 30 == 3))
		{
			#line 1708
			pDevExt->SupportedBauds |= (ULONG )0x00000002;
		}
		#line 1712
		if(! ((ULONG )SerialGetDivisorFromBaud(pDevExt->ClockRate, (LONG
			)135, & junk) >> 30 == 3))
		{
			#line 1718
			pDevExt->SupportedBauds |= (ULONG )0x00000004;
		}
		#line 1722
		if(! ((ULONG )SerialGetDivisorFromBaud(pDevExt->ClockRate, (LONG
			)150, & junk) >> 30 == 3))
		{
			#line 1728
			pDevExt->SupportedBauds |= (ULONG )0x00000008;
		}
		#line 1732
		if(! ((ULONG )SerialGetDivisorFromBaud(pDevExt->ClockRate, (LONG
			)300, & junk) >> 30 == 3))
		{
			#line 1738
			pDevExt->SupportedBauds |= (ULONG )0x00000010;
		}
		#line 1742
		if(! ((ULONG )SerialGetDivisorFromBaud(pDevExt->ClockRate, (LONG
			)600, & junk) >> 30 == 3))
		{
			#line 1748
			pDevExt->SupportedBauds |= (ULONG )0x00000020;
		}
		#line 1752
		if(! ((ULONG )SerialGetDivisorFromBaud(pDevExt->ClockRate, (LONG
			)1200, & junk) >> 30 == 3))
		{
			#line 1758
			pDevExt->SupportedBauds |= (ULONG )0x00000040;
		}
		#line 1762
		if(! ((ULONG )SerialGetDivisorFromBaud(pDevExt->ClockRate, (LONG
			)1800, & junk) >> 30 == 3))
		{
			#line 1768
			pDevExt->SupportedBauds |= (ULONG )0x00000080;
		}
		#line 1772
		if(! ((ULONG )SerialGetDivisorFromBaud(pDevExt->ClockRate, (LONG
			)2400, & junk) >> 30 == 3))
		{
			#line 1778
			pDevExt->SupportedBauds |= (ULONG )0x00000100;
		}
		#line 1782
		if(! ((ULONG )SerialGetDivisorFromBaud(pDevExt->ClockRate, (LONG
			)4800, & junk) >> 30 == 3))
		{
			#line 1788
			pDevExt->SupportedBauds |= (ULONG )0x00000200;
		}
		#line 1792
		if(! ((ULONG )SerialGetDivisorFromBaud(pDevExt->ClockRate, (LONG
			)7200, & junk) >> 30 == 3))
		{
			#line 1798
			pDevExt->SupportedBauds |= (ULONG )0x00000400;
		}
		#line 1802
		if(! ((ULONG )SerialGetDivisorFromBaud(pDevExt->ClockRate, (LONG
			)9600, & junk) >> 30 == 3))
		{
			#line 1808
			pDevExt->SupportedBauds |= (ULONG )0x00000800;
		}
		#line 1812
		if(! ((ULONG )SerialGetDivisorFromBaud(pDevExt->ClockRate, (LONG
			)14400, & junk) >> 30 == 3))
		{
			#line 1818
			pDevExt->SupportedBauds |= (ULONG )0x00001000;
		}
		#line 1822
		if(! ((ULONG )SerialGetDivisorFromBaud(pDevExt->ClockRate, (LONG
			)19200, & junk) >> 30 == 3))
		{
			#line 1828
			pDevExt->SupportedBauds |= (ULONG )0x00002000;
		}
		#line 1832
		if(! ((ULONG )SerialGetDivisorFromBaud(pDevExt->ClockRate, (LONG
			)38400, & junk) >> 30 == 3))
		{
			#line 1838
			pDevExt->SupportedBauds |= (ULONG )0x00004000;
		}
		#line 1842
		if(! ((ULONG )SerialGetDivisorFromBaud(pDevExt->ClockRate, (LONG
			)56000, & junk) >> 30 == 3))
		{
			#line 1848
			pDevExt->SupportedBauds |= (ULONG )0x00008000;
		}
		#line 1851
		if(! ((ULONG )SerialGetDivisorFromBaud(pDevExt->ClockRate, (LONG
			)57600, & junk) >> 30 == 3))
		{
			#line 1857
			pDevExt->SupportedBauds |= (ULONG )0x00040000;
		}
		#line 1860
		if(! ((ULONG )SerialGetDivisorFromBaud(pDevExt->ClockRate, (LONG
			)115200, & junk) >> 30 == 3))
		{
			#line 1866
			pDevExt->SupportedBauds |= (ULONG )0x00020000;
		}
		#line 1870
		if(! ((ULONG )SerialGetDivisorFromBaud(pDevExt->ClockRate, (LONG
			)128000, & junk) >> 30 == 3))
		{
			#line 1876
			pDevExt->SupportedBauds |= (ULONG )0x00010000;
		}
	}
	#line 1889
	pDevExt->DeviceIsOpened = 0;
	#line 1902
	(pDevExt->ShortIntervalAmount).QuadPart = - 1;
	(pDevExt->LongIntervalAmount).QuadPart = - 10000000;
	(pDevExt->CutOverAmount).QuadPart = 200000000;
	#line 1913
	ExtensionCleanup:
		#line 1913
		;
	if(! ((NTSTATUS )status >= 0))
	{
		#line 1915
		if(allocedISRSw)
		{
			#line 1916
			ExFreePool(pDevExt->CIsrSw);
			pDevExt->CIsrSw = (void *  )0;
		}
		#line 1920
		if(pDevExt->UnMapRegisters)
		{
			#line 1921
			MmUnmapIoSpace(pDevExt->Controller,
				pDevExt->SpanOfController);
		}
		if(pDevExt->UnMapStatus)
		{
			#line 1925
			MmUnmapIoSpace(pDevExt->InterruptStatus,
				pDevExt->SpanOfInterruptStatus);
		}
	}
	#line 1931
	return status;
}

#line 1937
NTSTATUS SerialInitOneController(PDEVICE_OBJECT PDevObj , PCONFIG_DATA
	PConfigData )
{
	#line 1958
	NTSTATUS status ;
	PSERIAL_DEVICE_EXTENSION pDevExt ;
	#line 1961
	;
	#line 1963
	status = SerialInitController(PDevObj, PConfigData);
	#line 1965
	if((NTSTATUS )status >= 0)
	{
		pDevExt = PDevObj->DeviceExtension;
		#line 1975
		pDevExt->OurIsr = SerialISR;
		pDevExt->OurIsrContext = pDevExt;
		pDevExt->TopLevelOurIsr = SerialISR;
		pDevExt->TopLevelOurIsrContext = pDevExt;
	}
	#line 1982
	return status;
}

#line 1987
BOOLEAN SerialDoesPortExist(PSERIAL_DEVICE_EXTENSION Extension , PUNICODE_STRING
	InsertString , ULONG ForceFifo , ULONG LogFifo )
{
	#line 2037
	UCHAR regContents ;
	BOOLEAN returnValue = 1;
	UCHAR oldIERContents ;
	UCHAR oldLCRContents ;
	USHORT value1 ;
	USHORT value2 ;
	KIRQL oldIrql ;
	#line 2049
	oldLCRContents = READ_PORT_UCHAR(Extension->Controller + (ULONG )(0x03 *
		1));
	#line 2058
	do
	{
		#line 2058
		WRITE_PORT_UCHAR(Extension->Controller + (ULONG )(0x03 * 1),
			(UCHAR )(oldLCRContents & ~ 0x80));
	}
	while(0);
	#line 2060
	oldIERContents = READ_PORT_UCHAR(Extension->Controller + (ULONG )(0x01 *
		1));
	#line 2070
	* & oldIrql = KfRaiseIrql(30);
	#line 2075
	do
	{
		#line 2075
		WRITE_PORT_UCHAR(Extension->Controller + (ULONG )(0x01 * 1),
			0x0f);
	}
	while(0);
	#line 2077
	value1 = READ_PORT_UCHAR(Extension->Controller + (ULONG )(0x01 * 1));
	value1 = value1 << 8;
	value1 |= READ_PORT_UCHAR(Extension->Controller + (ULONG )(0x00 * 1));
	#line 2084
	do
	{
		#line 2084
		PUCHAR Address = Extension->Controller;
		#line 2084
		PSHORT PDivisor = & value2;
		#line 2084
		UCHAR LineControl ;
		#line 2084
		UCHAR Lsb ;
		#line 2084
		UCHAR Msb ;
		#line 2084
		LineControl = READ_PORT_UCHAR(Address + (ULONG )(0x03 * 1));
		#line 2084
		WRITE_PORT_UCHAR(Address + (ULONG )(0x03 * 1), (UCHAR
			)(LineControl | 0x80));
		#line 2084
		Lsb = READ_PORT_UCHAR(Address + (ULONG )(0x00 * 1));
		#line 2084
		Msb = READ_PORT_UCHAR(Address + (ULONG )(0x01 * 1));
		#line 2084
		* PDivisor = Lsb;
		#line 2084
		* PDivisor = * PDivisor | (USHORT )Msb << 8;
		#line 2084
		WRITE_PORT_UCHAR(Address + (ULONG )(0x03 * 1), LineControl);
	}
	while(0);
	#line 2089
	do
	{
		#line 2089
		WRITE_PORT_UCHAR(Extension->Controller + (ULONG )(0x03 * 1),
			oldLCRContents);
	}
	while(0);
	#line 2101
	do
	{
		#line 2101
		WRITE_PORT_UCHAR(Extension->Controller + (ULONG )(0x01 * 1),
			oldIERContents);
	}
	while(0);
	#line 2103
	KfLowerIrql(oldIrql);
	#line 2105
	if(value1 == value2)
	{
		SerialLogError((Extension->DeviceObject)->DriverObject,
			Extension->DeviceObject, Extension->OriginalController,
			SerialPhysicalZero, 0, 0, 0, 62, (NTSTATUS )0x00000000L,
			(NTSTATUS )0xC0060024L, InsertString->Length +
			sizeof(WCHAR ), InsertString->Buffer, 0, (void *  )0);
		#line 2123
		returnValue = 0;
		goto AllDone;
	}
	#line 2128
	AllDone:
		#line 2128
		;
	#line 2136
	if(returnValue)
	{
		#line 2148
		do
		{
			#line 2148
			do
			{
				#line 2148
				WRITE_PORT_UCHAR(Extension->Controller + (ULONG
					)(0x01 * 1), 0);
			}
			while(0);
		}
		while(0);
		#line 2150
		if(Extension->Jensen)
		{
			#line 2155
			do
			{
				#line 2155
				WRITE_PORT_UCHAR(Extension->Controller + (ULONG
					)(0x04 * 1), (UCHAR )0x08);
			}
			while(0);
		}
		else
		{
			do
			{
				#line 2162
				WRITE_PORT_UCHAR(Extension->Controller + (ULONG
					)(0x04 * 1), (UCHAR )0);
			}
			while(0);
		}
		#line 2177
		do
		{
			#line 2177
			WRITE_PORT_UCHAR(Extension->Controller + (ULONG )(0x02 *
				1), (UCHAR )0x01);
		}
		while(0);
		#line 2179
		regContents = READ_PORT_UCHAR(Extension->Controller + (ULONG
			)(0x02 * 1));
		if(regContents & 0xc0)
		{
			#line 2187
			Extension->FifoPresent = 1;
			#line 2201
			do
			{
				#line 2201
				WRITE_PORT_UCHAR(Extension->Controller + (ULONG
					)(0x02 * 1), (UCHAR )0);
			}
			while(0);
			#line 2203
			READ_PORT_UCHAR(Extension->Controller + (ULONG )(0x00 *
				1));
			#line 2214
			do
			{
				#line 2214
				WRITE_PORT_UCHAR(Extension->Controller + (ULONG
					)(0x02 * 1), (UCHAR )((UCHAR )0x01 |
					Extension->RxFifoTrigger | (UCHAR )0x02
					| (UCHAR )0x04));
			}
			while(0);
		}
		#line 2224
		if(! ForceFifo || ! Extension->FifoPresent)
		{
			Extension->FifoPresent = 0;
			#line 2230
			do
			{
				#line 2230
				WRITE_PORT_UCHAR(Extension->Controller + (ULONG
					)(0x02 * 1), (UCHAR )0);
			}
			while(0);
		}
		#line 2234
		if(Extension->FifoPresent)
		{
			if(LogFifo)
			{
				SerialLogError((Extension->DeviceObject)->DriverObject
					, Extension->DeviceObject,
					Extension->OriginalController,
					SerialPhysicalZero, 0, 0, 0, 15,
					(NTSTATUS )0x00000000L, (NTSTATUS
					)0x40060002L, InsertString->Length +
					sizeof(WCHAR ), InsertString->Buffer, 0,
					(void *  )0);
			}
			#line 2261
			do
			{
				#line 2261
				;
			}
			while(0);
		}
		#line 2271
		if(Extension->InterruptStatus)
		{
			#line 2272
			if(Extension->Indexed)
			{
				#line 2273
				WRITE_PORT_UCHAR(Extension->InterruptStatus,
					(UCHAR )0xFF);
			}
			else
			{
				#line 2279
				if(Extension->OurIsrContext == Extension)
				{
					#line 2284
					WRITE_PORT_UCHAR(Extension->InterruptStatus
						, (UCHAR )(1 <<
						Extension->PortIndex - 1));
				}
				else
				{
					#line 2291
					WRITE_PORT_UCHAR(Extension->InterruptStatus
						, (UCHAR
						)((PSERIAL_MULTIPORT_DISPATCH
						)Extension->OurIsrContext)->UsablePortMask
						);
				}
			}
		}
	}
	return returnValue;
}

#line 2305
BOOLEAN SerialReset(PVOID Context )
{
	#line 2332
	PSERIAL_DEVICE_EXTENSION extension = Context;
	UCHAR regContents ;
	UCHAR oldModemControl ;
	ULONG i ;
	;
	#line 2343
	oldModemControl = READ_PORT_UCHAR(extension->Controller + (ULONG )(0x04
		* 1));
	if(extension->Jensen)
	{
		#line 2350
		do
		{
			#line 2350
			WRITE_PORT_UCHAR(extension->Controller + (ULONG )(0x04 *
				1), (UCHAR )(oldModemControl | 0x08));
		}
		while(0);
	}
	else
	{
		#line 2358
		do
		{
			#line 2358
			WRITE_PORT_UCHAR(extension->Controller + (ULONG )(0x04 *
				1), (UCHAR )(oldModemControl & ~ 0x08));
		}
		while(0);
	}
	#line 2366
	if(extension->FifoPresent)
	{
		#line 2381
		do
		{
			#line 2381
			WRITE_PORT_UCHAR(extension->Controller + (ULONG )(0x02 *
				1), (UCHAR )0);
		}
		while(0);
		#line 2383
		READ_PORT_UCHAR(extension->Controller + (ULONG )(0x00 * 1));
		#line 2389
		do
		{
			#line 2389
			WRITE_PORT_UCHAR(extension->Controller + (ULONG )(0x02 *
				1), (UCHAR )((UCHAR )0x01 |
				extension->RxFifoTrigger | (UCHAR )0x02 | (UCHAR
				)0x04));
		}
		while(0);
	}
	#line 2402
	regContents = READ_PORT_UCHAR(extension->Controller + (ULONG )(0x03 *
		1));
	#line 2403
	regContents &= ~ (0x80 | 0x40);
	#line 2408
	do
	{
		#line 2408
		WRITE_PORT_UCHAR(extension->Controller + (ULONG )(0x03 * 1),
			regContents);
	}
	while(0);
	#line 2415
	//BLAST forloop for(i = 0; i < 5; i++)
	for(i = 0; i < __BLAST_NONDET; i++)
	{
		#line 2420
		if(((KUSER_SHARED_DATA * const
			)0xffdf0000)->AlternativeArchitecture != NEC98x86)
		{
			#line 2421
			READ_PORT_UCHAR(extension->Controller + (ULONG )(0x00 *
				1));
			#line 2422
			if(! (READ_PORT_UCHAR(extension->Controller + (ULONG
				)(0x05 * 1)) & 1))
			{
				#line 2424
				break;
			}
		}
		else
		{
			#line 2432
			if(! (READ_PORT_UCHAR(extension->Controller + (ULONG
				)(0x05 * 1)) & 1))
			{
				#line 2434
				break;
			}
			#line 2437
			READ_PORT_UCHAR(extension->Controller + (ULONG )(0x00 *
				1));
		}
	}
	#line 2447
	//BLAST forloop for(i = 0; i < 1000; i++)
	for(i = 0; i < __BLAST_NONDET ; i++)
	{
		#line 2452
		if(! (READ_PORT_UCHAR(extension->Controller + (ULONG )(0x06 *
			1)) & 0x0f))
		{
			#line 2454
			break;
		}
	}
	#line 2465
	SerialSetLineControl(extension);
	#line 2467
	SerialSetupNewHandFlow(extension, & extension->HandFlow);
	#line 2472
	SerialHandleModemUpdate(extension, 0);
	{
		#line 2478
		SHORT appropriateDivisor ;
		SERIAL_IOCTL_SYNC s ;
		#line 2481
		SerialGetDivisorFromBaud(extension->ClockRate,
			extension->CurrentBaud, & appropriateDivisor);
		#line 2486
		s.Extension = extension;
		s.Data = (PVOID )appropriateDivisor;
		SerialSetBaud(& s);
	}
	#line 2499
	do
	{
		#line 2499
		do
		{
			#line 2499
			WRITE_PORT_UCHAR(extension->Controller + (ULONG )(0x01 *
				1), (UCHAR )(0x01 | 0x02 | 0x04 | 0x08));
		}
		while(0);
	}
	while(0);
	#line 2506
	//BLAST forloop for(i = 0; i < 5; i++)
	for(i = 0; i < __BLAST_NONDET; i++)
	{
		#line 2511
		if(READ_PORT_UCHAR(extension->Controller + (ULONG )(0x02 * 1)) &
			0x01)
		{
			#line 2513
			break;
		}
	}
	#line 2524
	extension->HoldingEmpty = 1;
	#line 2526
	return 0;
}

#line 2530
NTSTATUS SerialGetDivisorFromBaud(ULONG ClockRate , LONG DesiredBaud , PSHORT
	AppropriateDivisor )
{
	#line 2565
	NTSTATUS status = (NTSTATUS )0x00000000L;
	SHORT calculatedDivisor ;
	ULONG denominator ;
	ULONG remainder ;
	#line 2574
	ULONG maxRemain18 = 18432;
	ULONG maxRemain30 = 30720;
	ULONG maxRemain42 = 42336;
	ULONG maxRemain80 = 80000;
	ULONG maxRemain ;
	#line 2580
	;
	#line 2586
	denominator = DesiredBaud * (ULONG )16;
	#line 2588
	if(DesiredBaud <= 0)
	{
		* AppropriateDivisor = - 1;
	}
	else
	{
		#line 2592
		if((LONG )denominator < DesiredBaud)
		{
			#line 2599
			* AppropriateDivisor = - 1;
		}
		else
		{
			if(ClockRate == 1843200)
			{
				#line 2604
				maxRemain = maxRemain18;
			}
			else
			{
				#line 2605
				if(ClockRate == 3072000)
				{
					#line 2606
					maxRemain = maxRemain30;
				}
				else
				{
					#line 2607
					if(ClockRate == 4233600)
					{
						#line 2608
						maxRemain = maxRemain42;
					}
					else
					{
						#line 2610
						maxRemain = maxRemain80;
					}
				}
			}
			#line 2613
			calculatedDivisor = (SHORT )(ClockRate / denominator);
			remainder = ClockRate % denominator;
			#line 2620
			if(remainder * 2 > ClockRate && DesiredBaud != 110)
			{
				calculatedDivisor++;
			}
			#line 2631
			if(DesiredBaud >= 9600)
			{
				#line 2640
				if(remainder >= maxRemain && remainder +
					maxRemain < ClockRate)
				{
					#line 2641
					calculatedDivisor = - 1;
				}
			}
			#line 2651
			if(denominator > ClockRate)
			{
				calculatedDivisor = - 1;
			}
			#line 2662
			if(ClockRate == 1843200)
			{
				if(DesiredBaud == 56000)
				{
					#line 2665
					calculatedDivisor = 2;
				}
			}
			else
			{
				#line 2668
				if(ClockRate == 3072000)
				{
					if(DesiredBaud == 14400)
					{
						#line 2671
						calculatedDivisor = 13;
					}
				}
				else
				{
					#line 2674
					if(ClockRate == 4233600)
					{
						if(DesiredBaud == 9600)
						{
							#line 2677
							calculatedDivisor = 28;
						}
						else
						{
							#line 2678
							if(DesiredBaud == 14400)
							{
	#line 2679
	calculatedDivisor = 18;
							}
							else
							{
	#line 2680
	if(DesiredBaud == 19200)
	{
		#line 2681
		calculatedDivisor = 14;
	}
	else
	{
		#line 2682
		if(DesiredBaud == 38400)
		{
			#line 2683
			calculatedDivisor = 7;
		}
		else
		{
			#line 2684
			if(DesiredBaud == 56000)
			{
				#line 2685
				calculatedDivisor = 5;
			}
		}
	}
							}
						}
					}
					else
					{
						#line 2688
						if(ClockRate == 8000000)
						{
							if(DesiredBaud == 14400)
							{
	#line 2691
	calculatedDivisor = 35;
							}
							else
							{
	#line 2692
	if(DesiredBaud == 56000)
	{
		#line 2693
		calculatedDivisor = 9;
	}
							}
						}
					}
				}
			}
			#line 2698
			* AppropriateDivisor = calculatedDivisor;
		}
	}
	#line 2703
	if(* AppropriateDivisor == - 1)
	{
		status = (NTSTATUS )0xC000000DL;
	}
	#line 2709
	return status;
}

#line 2714
void SerialUnload(PDRIVER_OBJECT DriverObject )
{
	#line 2738
	PVOID lockPtr ;
	#line 2740
	;
	#line 2742
	lockPtr = MmLockPagableDataSection(SerialUnload);
	#line 2748
	SerialGlobals.PAGESER_Handle = (void *  )0;
	#line 2750
	if((SerialGlobals.RegistryPath).Buffer != (void *  )0)
	{
		#line 2751
		ExFreePool((SerialGlobals.RegistryPath).Buffer);
		(SerialGlobals.RegistryPath).Buffer = (void *  )0;
	}
	#line 2762
	do
	{
		#line 2762
		;
	}
	while(0);
	#line 2764
	MmUnlockPagableImageSection(lockPtr);
}

#line 2772
PVOID SerialGetMappedAddress(INTERFACE_TYPE BusType , ULONG BusNumber ,
	LARGE_INTEGER IoAddress , ULONG NumberOfBytes , ULONG AddressSpace ,
	PBOOLEAN MappedAddress )
{
	#line 2806
	LARGE_INTEGER cardAddress ;
	PVOID address ;
	#line 2809
	;
	#line 2816
	if(! AddressSpace)
	{
		address = MmMapIoSpace(IoAddress, NumberOfBytes, 0);
		#line 2824
		* MappedAddress = (BOOLEAN )(address ? 1 : 0);
	}
	else
	{
		#line 2829
		address = (PVOID )IoAddress.LowPart;
		* MappedAddress = 0;
	}
	#line 2834
	return address;
}

#line 2839
SERIAL_MEM_COMPARES SerialMemCompare(LARGE_INTEGER A , ULONG SpanOfA ,
	LARGE_INTEGER B , ULONG SpanOfB )
{
	#line 2872
	LARGE_INTEGER a ;
	LARGE_INTEGER b ;
	#line 2875
	LARGE_INTEGER lower ;
	ULONG lowerSpan ;
	LARGE_INTEGER higher ;
	#line 2879
	;
	#line 2881
	a = A;
	b = B;
	#line 2884
	if(a.QuadPart == b.QuadPart)
	{
		return AddressesAreEqual;
	}
	#line 2890
	if(a.QuadPart > b.QuadPart)
	{
		higher = a;
		lower = b;
		lowerSpan = SpanOfB;
	}
	else
	{
		higher = b;
		lower = a;
		lowerSpan = SpanOfA;
	}
	#line 2904
	if(higher.QuadPart - lower.QuadPart >= lowerSpan)
	{
		return AddressesAreDisjoint;
	}
	#line 2910
	return AddressesOverlap;
}

#line 2916
BOOLEAN SerialBecomeSharer(PVOID Context )
{
	#line 2936
	PSERIAL_DEVICE_EXTENSION pDevExt = (PSERIAL_DEVICE_EXTENSION )Context;
	PSERIAL_DEVICE_EXTENSION pNewExt = (PSERIAL_DEVICE_EXTENSION
		)pDevExt->NewExtension;
	PSERIAL_CISR_SW pCIsrSw = pDevExt->CIsrSw;
	#line 2946
	if((& pCIsrSw->SharerList)->Flink == & pCIsrSw->SharerList)
	{
		#line 2947
		pCIsrSw->IsrFunc = SerialSharerIsr;
		pCIsrSw->Context = & pCIsrSw->SharerList;
		{
			#line 2949
			PLIST_ENTRY _EX_Blink ;
			#line 2949
			PLIST_ENTRY _EX_ListHead ;
			#line 2949
			_EX_ListHead = & pCIsrSw->SharerList;
			#line 2949
			_EX_Blink = _EX_ListHead->Blink;
			#line 2949
			(& pDevExt->TopLevelSharers)->Flink = _EX_ListHead;
			#line 2949
			(& pDevExt->TopLevelSharers)->Blink = _EX_Blink;
			#line 2949
			_EX_Blink->Flink = & pDevExt->TopLevelSharers;
			#line 2949
			_EX_ListHead->Blink = & pDevExt->TopLevelSharers;
		}
		#line 2949
		;
	}
	#line 2956
	pNewExt->Interrupt = pDevExt->Interrupt;
	pNewExt->CIsrSw = pDevExt->CIsrSw;
	{
		#line 2963
		PLIST_ENTRY _EX_Blink ;
		#line 2963
		PLIST_ENTRY _EX_ListHead ;
		#line 2963
		_EX_ListHead = & pCIsrSw->SharerList;
		#line 2963
		_EX_Blink = _EX_ListHead->Blink;
		#line 2963
		(& pNewExt->TopLevelSharers)->Flink = _EX_ListHead;
		#line 2963
		(& pNewExt->TopLevelSharers)->Blink = _EX_Blink;
		#line 2963
		_EX_Blink->Flink = & pNewExt->TopLevelSharers;
		#line 2963
		_EX_ListHead->Blink = & pNewExt->TopLevelSharers;
	}
	#line 2963
	;
	#line 2970
	if((& pNewExt->CommonInterruptObject)->Flink == &
		pNewExt->CommonInterruptObject)
	{
		{
			#line 2972
			PLIST_ENTRY _EX_Blink ;
			#line 2972
			PLIST_ENTRY _EX_ListHead ;
			#line 2972
			_EX_ListHead = & pDevExt->CommonInterruptObject;
			#line 2972
			_EX_Blink = _EX_ListHead->Blink;
			#line 2972
			(& pNewExt->CommonInterruptObject)->Flink =
				_EX_ListHead;
			#line 2972
			(& pNewExt->CommonInterruptObject)->Blink = _EX_Blink;
			#line 2972
			_EX_Blink->Flink = & pNewExt->CommonInterruptObject;
			#line 2972
			_EX_ListHead->Blink = & pNewExt->CommonInterruptObject;
		}
		#line 2972
		;
	}
	#line 2976
	return 1;
}

#line 2981
NTSTATUS SerialFindInitController(PDEVICE_OBJECT PDevObj , PCONFIG_DATA PConfig
	)
{
	#line 3004
	PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
	PDEVICE_OBJECT pDeviceObject ;
	PSERIAL_DEVICE_EXTENSION pExtension ;
	LARGE_INTEGER serialPhysicalMax ;
	SERIAL_LIST_DATA listAddition ;
	BOOLEAN didInit = 0;
	PLIST_ENTRY pCurDevObj ;
	NTSTATUS status ;
	#line 3013
	;
	#line 3016
	do
	{
		#line 3016
		;
	}
	while(0);
	#line 3018
	serialPhysicalMax.LowPart = (ULONG )(~ 0);
	serialPhysicalMax.HighPart = ~ 0;
	#line 3035
	do
	{
		#line 3035
		;
	}
	while(0);
	#line 3042
	if(SerialMemCompare(PConfig->Controller, PConfig->SpanOfController,
		serialPhysicalMax, (ULONG )0) != AddressesAreDisjoint)
	{
		#line 3049
		SerialLogError(PDevObj->DriverObject, (void *  )0,
			PConfig->Controller, SerialPhysicalZero, 0, 0, 0, 43,
			(NTSTATUS )0x00000000L, (NTSTATUS )0xC006001AL,
			(pDevExt->SymbolicLinkName).Length + sizeof(WCHAR ),
			(pDevExt->SymbolicLinkName).Buffer, 0, (void *  )0);
		#line 3071
		do
		{
			#line 3071
			;
		}
		while(0);
		#line 3073
		return (NTSTATUS )0xC000000EL;
	}
	#line 3078
	if(SerialMemCompare(PConfig->InterruptStatus,
		PConfig->SpanOfInterruptStatus, serialPhysicalMax, (ULONG )0) !=
		AddressesAreDisjoint)
	{
		#line 3085
		SerialLogError(PDevObj->DriverObject, (void *  )0,
			PConfig->Controller, SerialPhysicalZero, 0, 0, 0, 44,
			(NTSTATUS )0x00000000L, (NTSTATUS )0xC006001BL,
			(pDevExt->SymbolicLinkName).Length + sizeof(WCHAR ),
			(pDevExt->SymbolicLinkName).Buffer, 0, (void *  )0);
		#line 3108
		do
		{
			#line 3108
			;
		}
		while(0);
		#line 3110
		return (NTSTATUS )0xC000000EL;
	}
	#line 3119
	if(SerialMemCompare(PConfig->InterruptStatus,
		PConfig->SpanOfInterruptStatus, SerialPhysicalZero, (ULONG )0)
		!= AddressesAreEqual)
	{
		#line 3126
		if(SerialMemCompare(PConfig->InterruptStatus,
			PConfig->SpanOfInterruptStatus, PConfig->Controller,
			PConfig->SpanOfController) != AddressesAreDisjoint)
		{
			#line 3133
			SerialLogError(PDevObj->DriverObject, (void *  )0,
				PConfig->Controller, PConfig->InterruptStatus,
				0, 0, 0, 45, (NTSTATUS )0x00000000L, (NTSTATUS
				)0xC006001CL, (pDevExt->SymbolicLinkName).Length
				+ sizeof(WCHAR ),
				(pDevExt->SymbolicLinkName).Buffer, 0, (void * 
				)0);
			#line 3155
			do
			{
				#line 3155
				;
			}
			while(0);
			#line 3157
			return (NTSTATUS )0xC000000EL;
		}
	}
	#line 3167
	if(! ((& SerialGlobals.AllDevObjs)->Flink == &
		SerialGlobals.AllDevObjs))
	{
		#line 3168
		pCurDevObj = (SerialGlobals.AllDevObjs).Flink;
		pExtension = (SERIAL_DEVICE_EXTENSION *  )((PCHAR )pCurDevObj -
			(ULONG_PTR )(& ((SERIAL_DEVICE_EXTENSION * 
			)0)->AllDevObjs));
	}
	else
	{
		#line 3172
		pCurDevObj = (void *  )0;
		pExtension = (void *  )0;
	}
	#line 3177
	while(pCurDevObj != (void *  )0 && pCurDevObj != &
		SerialGlobals.AllDevObjs)
	{
		#line 3184
		if(pExtension->InterfaceType == PConfig->InterfaceType &&
			pExtension->AddressSpace == PConfig->AddressSpace &&
			pExtension->BusNumber == PConfig->BusNumber)
		{
			#line 3204
			do
			{
				#line 3204
				;
			}
			while(0);
			#line 3210
			if(SerialMemCompare(PConfig->Controller,
				PConfig->SpanOfController,
				pExtension->OriginalController,
				pExtension->SpanOfController) !=
				AddressesAreDisjoint)
			{
				#line 3229
				do
				{
					#line 3229
					;
				}
				while(0);
				#line 3231
				return (NTSTATUS )0xC000000EL;
			}
			#line 3241
			if(SerialMemCompare(PConfig->InterruptStatus,
				PConfig->SpanOfInterruptStatus,
				SerialPhysicalZero, (ULONG )0) !=
				AddressesAreEqual)
			{
				#line 3252
				if(SerialMemCompare(PConfig->InterruptStatus,
					PConfig->SpanOfInterruptStatus,
					pExtension->OriginalController,
					pExtension->SpanOfController) !=
					AddressesAreDisjoint)
				{
					#line 3259
					SerialLogError(PDevObj->DriverObject,
						(void *  )0,
						PConfig->Controller,
						pExtension->OriginalController,
						0, 0, 0, 47, (NTSTATUS
						)0x00000000L, (NTSTATUS
						)0xC006001EL,
						(pDevExt->SymbolicLinkName).Length
						+ sizeof(WCHAR ),
						(pDevExt->SymbolicLinkName).Buffer
						,
						(pExtension->SymbolicLinkName).Length
						+ sizeof(WCHAR ),
						(pExtension->SymbolicLinkName).Buffer
						);
					#line 3282
					do
					{
						#line 3282
						;
					}
					while(0);
					#line 3284
					return (NTSTATUS )0xC000000EL;
				}
				#line 3292
				if(SerialMemCompare(PConfig->InterruptStatus,
					PConfig->SpanOfInterruptStatus,
					SerialPhysicalZero, (ULONG )0) !=
					AddressesAreEqual)
				{
					#line 3299
					if(SerialMemCompare(PConfig->InterruptStatus
						,
						PConfig->SpanOfInterruptStatus,
						pExtension->OriginalInterruptStatus
						,
						pExtension->SpanOfInterruptStatus)
						== AddressesOverlap)
					{
						#line 3306
						SerialLogError(PDevObj->DriverObject
							, (void *  )0,
							PConfig->Controller,
							pExtension->OriginalController
							, 0, 0, 0, 48, (NTSTATUS
							)0x00000000L, (NTSTATUS
							)0xC006001FL,
							(pDevExt->SymbolicLinkName)
							.Length + sizeof(WCHAR
							),
							(pDevExt->SymbolicLinkName)
							.Buffer,
							(pExtension->SymbolicLinkName)
							.Length + sizeof(WCHAR
							),
							(pExtension->SymbolicLinkName)
							.Buffer);
						#line 3330
						do
						{
							#line 3330
							;
						}
						while(0);
						#line 3332
						return (NTSTATUS )0xC000000EL;
					}
				}
			}
			#line 3345
			if(SerialMemCompare(pExtension->OriginalInterruptStatus,
				pExtension->SpanOfInterruptStatus,
				SerialPhysicalZero, (ULONG )0) !=
				AddressesAreEqual)
			{
				#line 3352
				if(SerialMemCompare(PConfig->Controller,
					PConfig->SpanOfController,
					pExtension->OriginalInterruptStatus,
					pExtension->SpanOfInterruptStatus) ==
					AddressesOverlap)
				{
					#line 3359
					SerialLogError(PDevObj->DriverObject,
						(void *  )0,
						PConfig->Controller,
						pExtension->OriginalController,
						0, 0, 0, 49, (NTSTATUS
						)0x00000000L, (NTSTATUS
						)0xC0060020L,
						(pDevExt->SymbolicLinkName).Length
						+ sizeof(WCHAR ),
						(pDevExt->SymbolicLinkName).Buffer
						,
						(pExtension->SymbolicLinkName).Length
						+ sizeof(WCHAR ),
						(pExtension->SymbolicLinkName).Buffer
						);
					#line 3383
					do
					{
						#line 3383
						;
					}
					while(0);
					#line 3385
					return (NTSTATUS )0xC000000EL;
				}
			}
		}
		#line 3390
		pCurDevObj = pCurDevObj->Flink;
		#line 3392
		if(pCurDevObj != (void *  )0)
		{
			#line 3393
			pExtension = (SERIAL_DEVICE_EXTENSION *  )((PCHAR
				)pCurDevObj - (ULONG_PTR )(&
				((SERIAL_DEVICE_EXTENSION *  )0)->AllDevObjs));
		}
	}
	#line 3409
	if(! ((& SerialGlobals.AllDevObjs)->Flink == &
		SerialGlobals.AllDevObjs))
	{
		#line 3410
		pCurDevObj = (SerialGlobals.AllDevObjs).Flink;
		pExtension = (SERIAL_DEVICE_EXTENSION *  )((PCHAR )pCurDevObj -
			(ULONG_PTR )(& ((SERIAL_DEVICE_EXTENSION * 
			)0)->AllDevObjs));
	}
	else
	{
		#line 3414
		pCurDevObj = (void *  )0;
		pExtension = (void *  )0;
	}
	#line 3426
	if(SerialMemCompare(PConfig->InterruptStatus,
		PConfig->SpanOfInterruptStatus, SerialPhysicalZero, (ULONG )0)
		!= AddressesAreEqual && pCurDevObj != (void *  )0)
	{
		#line 3434
		;
		#line 3441
		do
		{
			#line 3453
			if(pExtension->InterfaceType == PConfig->InterfaceType
				&& pExtension->AddressSpace ==
				PConfig->AddressSpace && pExtension->BusNumber
				== PConfig->BusNumber)
			{
				#line 3461
				if(SerialMemCompare(pExtension->OriginalInterruptStatus
					, pExtension->SpanOfInterruptStatus,
					PConfig->InterruptStatus,
					PConfig->SpanOfInterruptStatus) ==
					AddressesAreEqual)
				{
					#line 3473
					if(PConfig->TrIrql != pExtension->Irql
						|| PConfig->TrVector !=
						pExtension->Vector)
					{
						#line 3480
						SerialLogError(PDevObj->DriverObject
							, (void *  )0,
							PConfig->Controller,
							pExtension->OriginalController
							, 0, 0, 0, 50, (NTSTATUS
							)0x00000000L, (NTSTATUS
							)0xC0060021L,
							(pDevExt->SymbolicLinkName)
							.Length + sizeof(WCHAR
							),
							(pDevExt->SymbolicLinkName)
							.Buffer,
							(pExtension->SymbolicLinkName)
							.Length + sizeof(WCHAR
							),
							(pExtension->SymbolicLinkName)
							.Buffer);
						#line 3503
						do
						{
							#line 3503
							;
						}
						while(0);
						#line 3504
						return (NTSTATUS )0xC000000EL;
					}
					#line 3513
					;
					#line 3520
					do
					{
						#line 3520
						;
					}
					while(0);
					#line 3521
					do
					{
						#line 3521
						;
					}
					while(0);
					#line 3523
					status = SerialInitMultiPort(pExtension,
						PConfig, PDevObj);
					#line 3536
					return status;
				}
			}
			#line 3544
			pCurDevObj = pCurDevObj->Flink;
			if(pCurDevObj != (void *  )0)
			{
				#line 3546
				pExtension = (SERIAL_DEVICE_EXTENSION * 
					)((PCHAR )pCurDevObj - (ULONG_PTR )(&
					((SERIAL_DEVICE_EXTENSION * 
					)0)->AllDevObjs));
			}
		}
		while(pCurDevObj != (void *  )0 && pCurDevObj != &
			SerialGlobals.AllDevObjs);
	}
	do
	{
		#line 3555
		;
	}
	while(0);
	#line 3556
	status = SerialInitOneController(PDevObj, PConfig);
	#line 3558
	if(! ((NTSTATUS )status >= 0))
	{
		#line 3559
		return status;
	}
	#line 3572
	if(! ((& SerialGlobals.AllDevObjs)->Flink == &
		SerialGlobals.AllDevObjs))
	{
		#line 3573
		pCurDevObj = (SerialGlobals.AllDevObjs).Flink;
		pExtension = (SERIAL_DEVICE_EXTENSION *  )((PCHAR )pCurDevObj -
			(ULONG_PTR )(& ((SERIAL_DEVICE_EXTENSION * 
			)0)->AllDevObjs));
	}
	else
	{
		#line 3577
		pCurDevObj = (void *  )0;
		pExtension = (void *  )0;
	}
	#line 3587
	if(! PConfig->Jensen && pCurDevObj != (void *  )0)
	{
		#line 3588
		do
		{
			#line 3595
			if(pExtension->Irql == PConfig->TrIrql &&
				pExtension->Vector == PConfig->TrVector)
			{
				#line 3597
				pExtension->NewExtension = pDevExt;
				#line 3605
				ExFreePool(pDevExt->CIsrSw);
				#line 3609
				do
				{
					#line 3609
					;
				}
				while(0);
				#line 3611
				KeSynchronizeExecution(pExtension->Interrupt,
					SerialBecomeSharer, pExtension);
				#line 3614
				return (NTSTATUS )0x00000000L;
			}
			#line 3623
			pCurDevObj = pCurDevObj->Flink;
			#line 3625
			if(pCurDevObj != (void *  )0)
			{
				#line 3626
				pExtension = (SERIAL_DEVICE_EXTENSION * 
					)((PCHAR )pCurDevObj - (ULONG_PTR )(&
					((SERIAL_DEVICE_EXTENSION * 
					)0)->AllDevObjs));
			}
		}
		while(pCurDevObj != (void *  )0 && pCurDevObj != &
			SerialGlobals.AllDevObjs);
	}
	#line 3633
	return (NTSTATUS )0x00000000L;
}

#line 16 "C:/NTDDK/inc/stddef.h"

#pragma once
#line 77
typedef int ;

#line 86
typedef unsigned int ;

#line 95
typedef int ;

#line 105
typedef unsigned int ;

#line 112
typedef unsigned short ;

#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"

#pragma once
#line 32

#pragma pack(push, 8)
#line 72
typedef enum _EXCEPTION_DISPOSITION ;

#line 89
struct _EXCEPTION_RECORD ;

#line 90
struct _CONTEXT ;

#line 155

#pragma pack(pop)
#line 25 "C:/NTDDK/inc/ntdef.h"

#pragma once
#line 15 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"

#pragma once
#line 66
typedef wchar_t ;

#line 67
typedef wchar_t ;

#line 127 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long ;

#line 25 "C:/NTDDK/inc/basetsd.h"

#pragma once
#line 36
typedef int ;

#line 37
typedef int ;

#line 43
typedef unsigned int ;

#line 44
typedef unsigned int ;

#line 45
typedef unsigned int ;

#line 84
typedef int ;

#line 85
typedef unsigned int ;

typedef long ;

#line 88
typedef unsigned long ;

#line 248
typedef unsigned short ;

#line 249
typedef short ;

#line 250
typedef unsigned long ;

#line 288
typedef ULONG_PTR ;

#line 289
typedef LONG_PTR ;

#line 295
typedef ULONG_PTR ;

#line 301
typedef __int64 ;

#line 302
typedef __int64 ;

#line 309
typedef unsigned __int64 ;

#line 310
typedef unsigned __int64 ;

#line 311
typedef unsigned __int64 ;

#line 217 "C:/NTDDK/inc/ntdef.h"
typedef void ;

#line 218
typedef void ;

#line 266
typedef char ;

#line 267
typedef short ;

#line 268
typedef long ;

#line 276
typedef wchar_t ;

#line 282
typedef WCHAR ;

#line 283
typedef WCHAR ;

#line 284
typedef const WCHAR ;

#line 285
typedef WCHAR ;

#line 286
typedef WCHAR ;

typedef const WCHAR ;

#line 293
typedef CHAR ;

#line 294
typedef CHAR ;

typedef const CHAR ;

#line 297
typedef CHAR ;

#line 298
typedef CHAR ;

#line 299
typedef const CHAR ;

#line 321
typedef char ;

#line 322
typedef unsigned char ;

#line 326
typedef LPSTR ;

#line 327
typedef LPSTR ;

#line 328
typedef LPCSTR ;

#line 337
typedef double ;

typedef struct _QUAD ;

#line 349
typedef SHORT ;

#line 350
typedef LONG ;

#line 351
typedef QUAD ;

#line 360
typedef unsigned char ;

#line 361
typedef unsigned short ;

#line 362
typedef unsigned long ;

#line 363
typedef QUAD ;

#line 369
typedef UCHAR ;

#line 370
typedef USHORT ;

#line 371
typedef ULONG ;

#line 372
typedef UQUAD ;

#line 378
typedef signed char ;

#line 379
typedef SCHAR ;

#line 394
typedef void ;

#line 400
typedef HANDLE ;

#line 406
typedef UCHAR ;

#line 407
typedef USHORT ;

#line 408
typedef ULONG ;

#line 414
typedef LONG ;

#line 478
typedef char ;

#line 479
typedef short ;

#line 480
typedef ULONG ;

typedef CCHAR ;

#line 483
typedef CSHORT ;

#line 484
typedef CLONG ;

#line 492
typedef ULONG ;

#line 493
typedef PULONG ;

#line 494
typedef USHORT ;

#line 500
typedef ULONG ;

#line 501
typedef ULONG ;

#line 508
typedef LONG ;

typedef NTSTATUS ;

#line 602
typedef struct _FLOAT128 ;

#line 607
typedef FLOAT128 ;

#line 621
typedef __int64 ;

#line 622
typedef unsigned __int64 ;

#line 639
typedef LONGLONG ;

#line 640
typedef ULONGLONG ;

#line 644
typedef LONGLONG ;

#line 649
typedef union _LARGE_INTEGER ;

#line 662
typedef LARGE_INTEGER ;

#line 668
typedef union _ULARGE_INTEGER ;

#line 681
typedef ULARGE_INTEGER ;

#line 690
typedef struct _LUID ;

#line 696
typedef ULONGLONG ;

#line 697
typedef DWORDLONG ;

#line 707
typedef LARGE_INTEGER ;

#line 831

#pragma warning(push)

#pragma warning(disable:4035)
__inline ULONGLONG __stdcall Int64ShllMod32___4(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 842
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    
		};
}

#line 845
__inline LONGLONG __stdcall Int64ShraMod32___4(LONGLONG Value , ULONG ShiftCount
	)
{
	#line 852
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    
		};
}

#line 855
__inline ULONGLONG __stdcall Int64ShrlMod32___4(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 862
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    
		};
}


#pragma warning(pop)
#line 956
typedef enum _EVENT_TYPE ;

#line 965
typedef enum _TIMER_TYPE ;

#line 974
typedef enum _WAIT_TYPE ;

#line 983
typedef CHAR ;

#line 984
typedef const char ;

#line 991
typedef struct _STRING ;

#line 999
typedef STRING ;

typedef STRING ;

#line 1002
typedef PSTRING ;

typedef STRING ;

#line 1005
typedef PSTRING ;

#line 1011
typedef struct _CSTRING ;

#line 1016
typedef CSTRING ;

#line 1019
typedef STRING ;

#line 1020
typedef PSTRING ;

#line 1027
typedef struct _UNICODE_STRING ;

#line 1036
typedef UNICODE_STRING ;

#line 1037
typedef const UNICODE_STRING ;

#line 1046
typedef UCHAR ;

#line 1047
typedef BOOLEAN ;

#line 1057
typedef struct _LIST_ENTRY ;

#line 1067
typedef struct _SINGLE_LIST_ENTRY ;

#line 1078
typedef struct LIST_ENTRY32 ;

#line 1082
typedef LIST_ENTRY32 ;

typedef struct LIST_ENTRY64 ;

#line 1088
typedef LIST_ENTRY64 ;

#line 1127
typedef struct _STRING32 ;

#line 1132
typedef STRING32 ;

typedef STRING32 ;

#line 1135
typedef UNICODE_STRING32 ;

typedef STRING32 ;

#line 1138
typedef ANSI_STRING32 ;

#line 1141
typedef struct _STRING64 ;

#line 1146
typedef STRING64 ;

typedef STRING64 ;

#line 1149
typedef UNICODE_STRING64 ;

typedef STRING64 ;

#line 1152
typedef ANSI_STRING64 ;

#line 1173
typedef struct _OBJECT_ATTRIBUTES ;

#line 1181
typedef OBJECT_ATTRIBUTES ;

#line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID ;

#line 70
typedef GUID ;

#line 75
typedef const GUID ;

#line 81
typedef GUID ;

#line 82
typedef IID ;

#line 85
typedef GUID ;

#line 86
typedef CLSID ;

#line 89
typedef GUID ;

#line 90
typedef FMTID ;

#line 16 "C:/NTDDK/inc/string.h"

#pragma once
#line 1233 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECTID ;

#line 1288
struct _CONTEXT ;

#line 1289
struct _EXCEPTION_RECORD ;

typedef EXCEPTION_DISPOSITION ;

#line 1306
typedef UCHAR ;

typedef KIRQL ;

#line 1316
typedef enum _NT_PRODUCT_TYPE ;

#line 1329
typedef enum _SUITE_TYPE ;

#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD ;

#line 76
typedef struct _ETHREAD ;

#line 77
typedef struct _EPROCESS ;

#line 78
typedef struct _PEB ;

#line 79
typedef struct _KINTERRUPT ;

#line 80
typedef struct _IO_TIMER ;

#line 81
typedef struct _OBJECT_TYPE ;

#line 82
typedef struct _CALLBACK_OBJECT ;

#line 83
typedef struct _DEVICE_HANDLER_OBJECT ;

#line 84
typedef struct _BUS_HANDLER ;

#line 143
typedef union _SLIST_HEADER ;

#line 204
typedef CCHAR ;

typedef enum _MODE ;

#line 222
struct _KAPC ;

typedef void ;

#line 232
typedef void ;

#line 242
typedef void ;

#line 248
typedef BOOLEAN ;

#line 254
typedef BOOLEAN ;

#line 265
typedef struct _KAPC ;

#line 292
struct _KDPC ;

typedef void ;

#line 351
typedef enum _KDPC_IMPORTANCE ;

#line 361
typedef struct _KDPC ;

#line 377
typedef PVOID ;

typedef void ;

#line 392
typedef struct _KIPI_COUNTS ;

#line 443
typedef struct _MDL ;

#line 532
typedef PVOID ;

#line 538
typedef PVOID ;

#line 544
typedef PVOID ;

typedef ULONG ;

#line 547
typedef ACCESS_MASK ;

#line 597
typedef struct _GENERIC_MAPPING ;

#line 603
typedef GENERIC_MAPPING ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES ;

#line 622
typedef LUID_AND_ATTRIBUTES ;

#line 623
typedef LUID_AND_ATTRIBUTES_ARRAY ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 642 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACL ;

#line 649
typedef ACL ;

#line 681
typedef struct _PRIVILEGE_SET ;

#line 735
typedef enum _SECURITY_IMPERSONATION_LEVEL ;

#line 753
typedef BOOLEAN ;

#line 762
typedef struct _SECURITY_QUALITY_OF_SERVICE ;

#line 774
typedef struct _SE_IMPERSONATION_STATE ;

#line 782
typedef ULONG ;

#line 809
typedef ULONG ;

#line 810
typedef KAFFINITY ;

#line 816
typedef LONG ;

#line 824
typedef ULONG_PTR ;

#line 825
typedef KSPIN_LOCK ;

#line 833
typedef void ;

#line 842
typedef enum _KPROFILE_SOURCE ;

#line 1079
typedef NTSTATUS ;

#line 1088
typedef struct _RTL_QUERY_REGISTRY_TABLE ;

#line 1952

#pragma warning(push)

#pragma warning(disable:4035)
#line 2019

#pragma warning(pop)
#line 2214
typedef struct _TIME_FIELDS ;

#line 2224
typedef TIME_FIELDS ;

#line 2499
typedef struct _RTL_BITMAP ;

#line 2503
typedef RTL_BITMAP ;

#line 2627
typedef struct _RTL_BITMAP_RUN ;

#line 2633
typedef RTL_BITMAP_RUN ;

#line 2886
typedef struct _RTL_RANGE ;

#line 2924
typedef struct _RTL_RANGE_LIST ;

#line 2950
typedef struct _RANGE_LIST_ITERATOR ;

#line 3019
typedef BOOLEAN ;

#line 3155
typedef struct _OSVERSIONINFOA ;

#line 3164
typedef struct _OSVERSIONINFOW ;

#line 3177
typedef OSVERSIONINFOA ;

#line 3178
typedef POSVERSIONINFOA ;

#line 3179
typedef LPOSVERSIONINFOA ;

#line 3182
typedef struct _OSVERSIONINFOEXA ;

#line 3195
typedef struct _OSVERSIONINFOEXW ;

#line 3213
typedef OSVERSIONINFOEXA ;

#line 3214
typedef POSVERSIONINFOEXA ;

#line 3215
typedef LPOSVERSIONINFOEXA ;

#line 3648
typedef struct _IO_STATUS_BLOCK ;

#line 3669
typedef void ;

#line 3685
typedef enum _FILE_INFORMATION_CLASS ;

#line 3731
typedef struct _FILE_BASIC_INFORMATION ;

#line 3739
typedef struct _FILE_STANDARD_INFORMATION ;

#line 3747
typedef struct _FILE_POSITION_INFORMATION ;

#line 3751
typedef struct _FILE_ALIGNMENT_INFORMATION ;

#line 3755
typedef struct _FILE_NAME_INFORMATION ;

#line 3760
typedef struct _FILE_NETWORK_OPEN_INFORMATION ;

#line 3770
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION ;

#line 3775
typedef struct _FILE_DISPOSITION_INFORMATION ;

#line 3779
typedef struct _FILE_END_OF_FILE_INFORMATION ;

#line 3784
typedef struct _FILE_FULL_EA_INFORMATION ;

#line 3798
typedef enum _FSINFOCLASS ;

#line 3810
typedef struct _FILE_FS_DEVICE_INFORMATION ;

#line 3820
typedef union _FILE_SEGMENT_ELEMENT ;

#line 3829
typedef enum _INTERFACE_TYPE ;

#line 3854
typedef enum _DMA_WIDTH ;

#line 3865
typedef enum _DMA_SPEED ;

#line 3879
typedef void ;

#line 3880
typedef void ;

#line 3888
typedef enum _BUS_DATA_TYPE ;

#line 3910
typedef struct _IO_ERROR_LOG_PACKET ;

#line 3931
typedef struct _IO_ERROR_LOG_MESSAGE ;

#line 4074
typedef struct _KEY_BASIC_INFORMATION ;

#line 4081
typedef struct _KEY_NODE_INFORMATION ;

#line 4091
typedef struct _KEY_FULL_INFORMATION ;

#line 4106
typedef struct _KEY_NAME_INFORMATION ;

#line 4112
typedef enum _KEY_INFORMATION_CLASS ;

#line 4122
typedef struct _KEY_WRITE_TIME_INFORMATION ;

#line 4126
typedef enum _KEY_SET_INFORMATION_CLASS ;

#line 4134
typedef struct _KEY_VALUE_BASIC_INFORMATION ;

#line 4141
typedef struct _KEY_VALUE_FULL_INFORMATION ;

#line 4151
typedef struct _KEY_VALUE_PARTIAL_INFORMATION ;

#line 4158
typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ;

#line 4164
typedef struct _KEY_VALUE_ENTRY ;

#line 4171
typedef enum _KEY_VALUE_INFORMATION_CLASS ;

#line 4210
typedef struct _OBJECT_NAME_INFORMATION ;

#line 4221
typedef enum _SECTION_INHERIT ;

#line 4294
typedef struct _CLIENT_ID ;

#line 4298
typedef CLIENT_ID ;

#line 4315
typedef struct _NT_TIB ;

#line 4327
typedef NT_TIB ;

#line 4332
typedef enum _PROCESSINFOCLASS ;

#line 4366
typedef enum _THREADINFOCLASS ;

#line 4395
typedef struct _PROCESS_WS_WATCH_INFORMATION ;

#line 4405
typedef struct _PROCESS_BASIC_INFORMATION ;

#line 4413
typedef PROCESS_BASIC_INFORMATION ;

#line 4422
typedef struct _PROCESS_DEVICEMAP_INFORMATION ;

#line 4440
typedef struct _PROCESS_SESSION_INFORMATION ;

#line 4454
typedef struct _QUOTA_LIMITS ;

#line 4462
typedef QUOTA_LIMITS ;

#line 4472
typedef struct _IO_COUNTERS ;

#line 4480
typedef IO_COUNTERS ;

#line 4488
typedef struct _VM_COUNTERS ;

#line 4501
typedef VM_COUNTERS ;

#line 4508
typedef struct _POOLED_USAGE_AND_LIMITS ;

#line 4519
typedef POOLED_USAGE_AND_LIMITS ;

#line 4528
typedef struct _PROCESS_ACCESS_TOKEN ;

#line 4555
typedef struct _KERNEL_USER_TIMES ;

#line 4561
typedef KERNEL_USER_TIMES ;

#line 4587
typedef enum _SYSTEM_POWER_STATE ;

#line 4598
typedef enum  {
	PowerActionNone = 0,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
} ;

typedef enum _DEVICE_POWER_STATE ;

#line 4618
typedef union _POWER_STATE ;

#line 4623
typedef enum _POWER_STATE_TYPE ;

#line 4654
typedef ULONG ;

typedef enum  {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
} ;

#line 4663
typedef enum  {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation
} ;

#line 4690
typedef ULONG ;

typedef LONG ;

#line 4693
typedef ULONG ;

#line 4719
typedef union _MCI_STATS ;

#line 4978
typedef struct _KPCR ;

#line 5006
typedef KPCR ;

#line 5012
typedef struct _KFLOATING_SAVE ;

#line 5153
typedef enum _INTERLOCKED_RESULT ;

#line 5252

#pragma warning(disable:4035)
#line 6994
typedef struct _KSYSTEM_TIME ;

#line 7014

#pragma warning(push)

#pragma warning(disable:4164)
#line 7019

#pragma function(_enable)
#line 7020

#pragma function(_disable)
#line 7024

#pragma warning(pop)
#line 7085
typedef struct _FLOATING_SAVE_AREA ;

#line 7097
typedef FLOATING_SAVE_AREA ;

#line 7109
typedef struct _CONTEXT ;

#line 7197
typedef CONTEXT ;

#line 7826
typedef void ;

#line 7850
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ;

#line 7899
typedef struct _KUSER_SHARED_DATA ;

#line 8123
typedef enum _CM_SERVICE_NODE_TYPE ;

#line 8132
typedef enum _CM_SERVICE_LOAD_TYPE ;

#line 8140
typedef enum _CM_ERROR_CONTROL_TYPE ;

#line 8172
typedef int ;

#line 8198
typedef enum _CM_SHARE_DISPOSITION ;

#line 8211
typedef PVOID ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST ;

#line 8443
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR ;

#line 8454
typedef struct _CM_RESOURCE_LIST ;

#line 8471
typedef struct _DEVICE_FLAGS ;

#line 8485
typedef struct _CM_COMPONENT_INFORMATION ;

#line 8503
typedef struct _CM_ROM_BLOCK ;

#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 8518 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_INT13_DRIVE_PARAMETER ;

#line 8532
typedef struct _CM_MCA_POS_DATA ;

#line 8544
typedef struct _EISA_MEMORY_TYPE ;

#line 8554
typedef struct _EISA_MEMORY_CONFIGURATION ;

#line 8567
typedef struct _EISA_IRQ_DESCRIPTOR ;

#line 8575
typedef struct _EISA_IRQ_CONFIGURATION ;

#line 8585
typedef struct _DMA_CONFIGURATION_BYTE0 ;

#line 8592
typedef struct _DMA_CONFIGURATION_BYTE1 ;

#line 8599
typedef struct _EISA_DMA_CONFIGURATION ;

#line 8609
typedef struct _EISA_PORT_DESCRIPTOR ;

#line 8616
typedef struct _EISA_PORT_CONFIGURATION ;

#line 8628
typedef struct _CM_EISA_SLOT_INFORMATION ;

#line 8644
typedef struct _CM_EISA_FUNCTION_INFORMATION ;

#line 8678
typedef struct _CM_PNP_BIOS_DEVICE_NODE ;

#line 8692
typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8761 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_SCSI_DEVICE_DATA ;

#line 8775
typedef struct _CM_VIDEO_DEVICE_DATA ;

#line 8785
typedef struct _CM_SONIC_DEVICE_DATA ;

#line 8796
typedef struct _CM_SERIAL_DEVICE_DATA ;

#line 8810
typedef struct _CM_MONITOR_DEVICE_DATA ;

#line 8844
typedef struct _CM_FLOPPY_DEVICE_DATA ;

#line 8881
typedef struct _CM_KEYBOARD_DEVICE_DATA ;

#line 8893
typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA ;

#line 8905
typedef struct _CM_PCCARD_DEVICE_DATA ;

#line 8944
typedef struct _IO_RESOURCE_DESCRIPTOR ;

#line 9027
typedef struct _IO_RESOURCE_LIST ;

#line 9036
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST ;

#line 9065
typedef struct _EXCEPTION_RECORD ;

#line 9074
typedef EXCEPTION_RECORD ;

typedef struct _EXCEPTION_RECORD32 ;

#line 9085
typedef struct _EXCEPTION_RECORD64 ;

#line 9099
typedef struct _EXCEPTION_POINTERS ;

#line 9111
typedef enum _CONFIGURATION_TYPE ;

#line 9161
typedef enum _KINTERRUPT_MODE ;

#line 9170
typedef enum _KWAIT_REASON ;

#line 9207
typedef struct _DISPATCHER_HEADER ;

#line 9217
typedef struct _KWAIT_BLOCK ;

#line 9230
typedef void ;

#line 9244
typedef struct _KDEVICE_QUEUE ;

#line 9252
typedef struct _KDEVICE_QUEUE_ENTRY ;

#line 9263
typedef struct _KEVENT ;

#line 9271
typedef BOOLEAN ;

#line 9281
typedef struct _KMUTANT ;

#line 9294
typedef struct _KSEMAPHORE ;

#line 9304
typedef struct _KTIMER ;

#line 9899
typedef enum _KBUGCHECK_BUFFER_DUMP_STATE ;

#line 9907
typedef void ;

#line 9914
typedef struct _KBUGCHECK_CALLBACK_RECORD ;

#line 10002
typedef void ;

#line 10020
typedef LOGICAL ;

#line 10037
typedef void ;

#line 10053
typedef enum _MEMORY_CACHING_TYPE_ORIG ;

#line 10057
typedef enum _MEMORY_CACHING_TYPE ;

#line 10087
typedef struct _DBGKD_DEBUG_DATA_HEADER64 ;

#line 10115
typedef enum _POOL_TYPE ;

#line 10195
typedef enum _EX_POOL_PRIORITY ;

#line 10247
typedef struct _FAST_MUTEX ;

#line 10574
typedef PVOID ;

#line 10582
typedef void ;

#line 10588
typedef struct _GENERAL_LOOKASIDE ;

#line 10619
typedef struct _NPAGED_LOOKASIDE_LIST ;

#line 10729
typedef struct _PAGED_LOOKASIDE_LIST ;

#line 10882
typedef enum _WORK_QUEUE_TYPE ;

#line 10889
typedef void ;

#line 10895
typedef struct _WORK_QUEUE_ITEM ;

#line 10926
typedef struct _ZONE_SEGMENT_HEADER ;

#line 10931
typedef struct _ZONE_HEADER ;

#line 11156
typedef ULONG_PTR ;

#line 11157
typedef ERESOURCE_THREAD ;

typedef struct _OWNER_ENTRY ;

#line 11168
typedef struct _ERESOURCE ;

#line 11197
typedef struct _RESOURCE_HASH_ENTRY ;

#line 11204
typedef struct _RESOURCE_PERFORMANCE_DATA ;

#line 11429
typedef struct _CALLBACK_OBJECT ;

typedef void ;

#line 11474
typedef GUID ;

#line 11862
typedef enum _MM_SYSTEM_SIZE ;

#line 11884
typedef enum _LOCK_OPERATION ;

#line 11970
typedef enum _MM_PAGE_PRIORITY ;

#line 11999
typedef struct _PHYSICAL_MEMORY_RANGE ;

#line 12385
typedef NTSTATUS ;

#line 12389
typedef NTSTATUS ;

#line 12399
struct _DRIVER_OBJECT ;

#line 12411
typedef enum _SECURITY_OPERATION_CODE ;

#line 12426
typedef struct _SECURITY_SUBJECT_CONTEXT ;

#line 12448
typedef struct _INITIAL_PRIVILEGE_SET ;

#line 12462
typedef struct _ACCESS_STATE ;

#line 12571
typedef void ;

#line 12585
typedef void ;

#line 12602
typedef struct _IMAGE_INFO ;

#line 12620
typedef void ;

#line 12859
typedef NTSTATUS ;

#line 12878
typedef enum _IO_QUERY_DEVICE_DATA_FORMAT ;

#line 12890
typedef enum _CREATE_FILE_TYPE ;

#line 12905
struct _DEVICE_DESCRIPTION ;

#line 12906
struct _DEVICE_OBJECT ;

#line 12907
struct _DMA_ADAPTER ;

#line 12908
struct _DRIVER_OBJECT ;

#line 12909
struct _DRIVE_LAYOUT_INFORMATION ;

#line 12910
struct _DISK_PARTITION ;

#line 12911
struct _FILE_OBJECT ;

#line 12912
struct _IRP ;

#line 12913
struct _SCSI_REQUEST_BLOCK ;

#line 12919
typedef void ;

#line 12932
typedef void ;

#line 12943
typedef NTSTATUS ;

#line 12955
typedef void ;

#line 12968
typedef void ;

#line 12979
typedef NTSTATUS ;

#line 12990
typedef void ;

#line 13001
typedef void ;

#line 13011
typedef NTSTATUS ;

#line 13025
typedef BOOLEAN ;

#line 13038
typedef BOOLEAN ;

#line 13051
typedef BOOLEAN ;

#line 13068
typedef BOOLEAN ;

#line 13078
typedef BOOLEAN ;

#line 13092
typedef BOOLEAN ;

#line 13106
typedef BOOLEAN ;

#line 13118
typedef BOOLEAN ;

#line 13127
typedef BOOLEAN ;

#line 13141
typedef BOOLEAN ;

#line 13161
typedef void ;

#line 13167
typedef void ;

#line 13179
typedef void ;

#line 13193
typedef BOOLEAN ;

#line 13207
typedef BOOLEAN ;

#line 13219
typedef BOOLEAN ;

#line 13227
typedef BOOLEAN ;

#line 13239
typedef BOOLEAN ;

#line 13253
typedef NTSTATUS ;

#line 13262
typedef NTSTATUS ;

#line 13275
typedef NTSTATUS ;

#line 13282
typedef NTSTATUS ;

#line 13289
typedef BOOLEAN ;

#line 13304
typedef BOOLEAN ;

#line 13319
typedef BOOLEAN ;

#line 13327
typedef BOOLEAN ;

#line 13336
typedef BOOLEAN ;

#line 13350
typedef struct _FAST_IO_DISPATCH ;

#line 13386
typedef enum _IO_ALLOCATION_ACTION ;

#line 13396
typedef IO_ALLOCATION_ACTION ;

#line 13410
typedef struct _IO_SECURITY_CONTEXT ;

#line 13434
typedef struct _VPB ;

#line 13482
typedef struct _ADAPTER_OBJECT ;

#line 13491
typedef struct _WAIT_CONTEXT_BLOCK ;

#line 13503
typedef struct _CONTROLLER_OBJECT ;

#line 13537
typedef struct _DEVICE_OBJECT ;

#line 13575
typedef struct _DEVICE_OBJECT ;

#line 13578
struct _DEVICE_OBJECT_POWER_EXTENSION ;

typedef struct _DEVOBJ_EXTENSION ;

#line 13608
typedef struct _DRIVER_EXTENSION ;

#line 13645
typedef struct _DRIVER_OBJECT ;

#line 13706
typedef struct _DRIVER_OBJECT ;

#line 13715
typedef struct _SECTION_OBJECT_POINTERS ;

#line 13720
typedef SECTION_OBJECT_POINTERS ;

#line 13726
typedef struct _IO_COMPLETION_CONTEXT ;

#line 13759
typedef struct _FILE_OBJECT ;

#line 13788
typedef struct _FILE_OBJECT ;

#line 13828
typedef struct _IRP ;

#line 14078
typedef NTSTATUS ;

#line 14163
typedef enum _DEVICE_RELATION_TYPE ;

#line 14171
typedef struct _DEVICE_RELATIONS ;

#line 14176
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE ;

#line 14185
typedef struct _INTERFACE ;

#line 14196
typedef struct _DEVICE_CAPABILITIES ;

#line 14229
typedef struct _POWER_SEQUENCE ;

#line 14235
typedef enum  {
	BusQueryDeviceID = 0,
	BusQueryHardwareIDs = 1,
	BusQueryCompatibleIDs = 2,
	BusQueryInstanceID = 3,
	BusQueryDeviceSerialNumber = 4
} ;

typedef ULONG ;

#line 14252
typedef enum  {
	DeviceTextDescription = 0,
	DeviceTextLocationInformation = 1
} ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 14615 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SHARE_ACCESS ;

#line 14635
typedef struct _CONFIGURATION_INFORMATION ;

#line 14848
typedef struct _BOOTDISK_INFORMATION ;

#line 15754
typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK ;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK ;

#line 15764
typedef struct _IO_REMOVE_LOCK_DBG_BLOCK ;

#line 15777
typedef struct _IO_REMOVE_LOCK ;

#line 16009
typedef struct _IO_WORKITEM ;

typedef void ;

#line 16100
typedef enum  {
	DevicePropertyDeviceDescription,
	DevicePropertyHardwareID,
	DevicePropertyCompatibleIDs,
	DevicePropertyBootConfiguration,
	DevicePropertyBootConfigurationTranslated,
	DevicePropertyClassName,
	DevicePropertyClassGuid,
	DevicePropertyDriverKeyName,
	DevicePropertyManufacturer,
	DevicePropertyFriendlyName,
	DevicePropertyLocationInformation,
	DevicePropertyPhysicalDeviceObjectName,
	DevicePropertyBusTypeGuid,
	DevicePropertyLegacyBusType,
	DevicePropertyBusNumber,
	DevicePropertyEnumeratorName,
	DevicePropertyAddress,
	DevicePropertyUINumber
} ;

typedef BOOLEAN ;

#line 16129
typedef struct _DMA_ADAPTER ;

#line 16135
typedef ULONG ;

#line 16148
typedef struct _PNP_BUS_INFORMATION ;

#line 16162
typedef struct _LEGACY_BUS_INFORMATION ;

#line 16168
typedef struct _BUS_INTERFACE_STANDARD ;

#line 16190
typedef BOOLEAN ;

#line 16194
typedef NTSTATUS ;

#line 16203
typedef NTSTATUS ;

#line 16206
typedef NTSTATUS ;

#line 16210
typedef NTSTATUS ;

#line 16214
typedef NTSTATUS ;

#line 16218
typedef void ;

#line 16222
typedef NTSTATUS ;

#line 16227
typedef void ;

#line 16231
typedef struct _ACPI_INTERFACE_STANDARD ;

#line 16255
typedef enum _ACPI_REG_TYPE ;

#line 16268
typedef USHORT ;

#line 16272
typedef void ;

#line 16278
typedef struct ACPI_REGS_INTERFACE_STANDARD ;

#line 16300
typedef struct  {
	PVOID LinkNode ;
	ULONG StaticVector ;
	UCHAR Flags ;
} ;

#line 16314
typedef NTSTATUS ;

#line 16329
typedef NTSTATUS ;

#line 16336
typedef void ;

#line 16343
typedef struct _INT_ROUTE_INTERFACE_STANDARD ;

#line 16366
typedef struct _IO_ASSIGNED_RESOURCES ;

#line 16490
typedef enum _IO_NOTIFICATION_EVENT_CATEGORY ;

#line 16504
typedef NTSTATUS ;

#line 16537
typedef void ;

#line 16573
typedef enum _ARBITER_ACTION ;

#line 16586
typedef struct _ARBITER_CONFLICT_INFO ;

#line 16608
typedef struct _ARBITER_PARAMETERS ;

#line 16719
typedef enum _ARBITER_REQUEST_SOURCE ;

#line 16731
typedef enum _ARBITER_RESULT ;

#line 16761
typedef struct _ARBITER_LIST_ENTRY ;

#line 16832
typedef NTSTATUS ;

#line 16853
typedef struct _ARBITER_INTERFACE ;

#line 16880
typedef enum _RESOURCE_TRANSLATION_DIRECTION ;

#line 16889
typedef NTSTATUS ;

#line 16901
typedef NTSTATUS ;

#line 16915
typedef struct _TRANSLATOR_INTERFACE ;

#line 16931
typedef NTSTATUS ;

#line 16945
typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE ;

#line 16959
typedef struct _PLUGPLAY_NOTIFICATION_HEADER ;

#line 16972
typedef struct _HWPROFILE_CHANGE_NOTIFICATION ;

#line 16986
typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION ;

#line 17006
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION ;

#line 17026
typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION ;

#line 17054
typedef struct _DEVICE_DESCRIPTION ;

#line 17086
typedef BOOLEAN ;

#line 17333
typedef void ;

#line 17339
typedef struct _DEVICE_CONTROL_CONTEXT ;

#line 17349
typedef PBUS_HANDLER ;

#line 17355
typedef void ;

#line 17365
typedef enum _HAL_QUERY_INFORMATION_CLASS ;

#line 17381
typedef enum _HAL_SET_INFORMATION_CLASS ;

#line 17388
typedef NTSTATUS ;

#line 17405
typedef NTSTATUS ;

#line 17420
typedef void ;

#line 17429
typedef void ;

#line 17438
typedef NTSTATUS ;

#line 17447
typedef NTSTATUS ;

#line 17456
typedef NTSTATUS ;

#line 17466
typedef NTSTATUS ;

#line 17475
typedef NTSTATUS ;

#line 17486
typedef struct _PM_DISPATCH_TABLE ;

#line 17492
typedef NTSTATUS ;

#line 17505
typedef struct _DMA_ADAPTER ;

#line 17520
typedef NTSTATUS ;

#line 17543
typedef BOOLEAN ;

#line 17553
typedef NTSTATUS ;

#line 17566
typedef void ;

#line 17572
typedef void ;

#line 17578
typedef BOOLEAN ;

#line 17588
typedef struct  {
	ULONG Version ;
	pHalQuerySystemInformation HalQuerySystemInformation ;
	pHalSetSystemInformation HalSetSystemInformation ;
	pHalQueryBusSlots HalQueryBusSlots ;
	ULONG Spare1 ;
	pHalExamineMBR HalExamineMBR ;
	pHalIoAssignDriveLetters HalIoAssignDriveLetters ;
	pHalIoReadPartitionTable HalIoReadPartitionTable ;
	pHalIoSetPartitionInformation HalIoSetPartitionInformation ;
	pHalIoWritePartitionTable HalIoWritePartitionTable ;
	pHalHandlerForBus HalReferenceHandlerForBus ;
	pHalReferenceBusHandler HalReferenceBusHandler ;
	pHalReferenceBusHandler HalDereferenceBusHandler ;
	pHalInitPnpDriver HalInitPnpDriver ;
	pHalInitPowerManagement HalInitPowerManagement ;
	pHalGetDmaAdapter HalGetDmaAdapter ;
	pHalGetInterruptTranslator HalGetInterruptTranslator ;
} ;

#line 17650
typedef struct _HAL_BUS_INFORMATION ;

#line 17658
typedef struct _HAL_PROFILE_SOURCE_INFORMATION ;

#line 17665
typedef struct _HAL_PROFILE_SOURCE_INTERVAL ;

#line 17671
typedef enum _HAL_DISPLAY_BIOS_INFORMATION ;

#line 17678
typedef struct _HAL_POWER_INFORMATION ;

#line 17683
typedef struct _HAL_PROCESSOR_SPEED_INFO ;

#line 17688
typedef struct _HAL_CALLBACKS ;

#line 17694
typedef struct _HAL_PROCESSOR_FEATURE ;

#line 17706
typedef union _MCI_ADDR ;

#line 17716
typedef enum  {
	HAL_MCE_RECORD,
	HAL_MCA_RECORD
} ;

#line 17726
typedef struct _MCA_EXCEPTION ;

#line 17752
typedef void ;

#line 17762
typedef struct _MCA_DRIVER_INFO ;

#line 17772
typedef struct _SCATTER_GATHER_ELEMENT ;

#line 17778

#pragma warning(disable:4200)
#line 17779
typedef struct _SCATTER_GATHER_LIST ;

#line 17784

#pragma warning(default:4200)
#line 17788
typedef struct _DMA_OPERATIONS ;

typedef struct _DMA_ADAPTER ;

#line 17797
typedef void ;

#line 17801
typedef PVOID ;

#line 17808
typedef void ;

#line 17816
typedef NTSTATUS ;

#line 17824
typedef BOOLEAN ;

#line 17833
typedef void ;

#line 17837
typedef void ;

#line 17843
typedef PHYSICAL_ADDRESS ;

#line 17852
typedef ULONG ;

#line 17856
typedef ULONG ;

#line 17860
typedef void ;

#line 17868
typedef NTSTATUS ;

#line 17880
typedef void ;

#line 17887
typedef struct _DMA_OPERATIONS ;

#line 18235
typedef void ;

#line 18321
typedef struct _OBJECT_HANDLE_INFORMATION ;

#line 18402
typedef struct _PCI_SLOT_NUMBER ;

#line 18418
typedef struct _PCI_COMMON_CONFIG ;

#line 18591
typedef struct _PCI_CAPABILITIES_HEADER ;

#line 18600
typedef struct _PCI_PMC ;

#line 18618
typedef struct _PCI_PMCSR ;

#line 18628
typedef struct _PCI_PMCSR_BSE ;

#line 18635
typedef struct _PCI_PM_CAPABILITY ;

#line 18679
typedef struct _PCI_AGP_CAPABILITY ;

#line 18720
typedef struct _PCI_MSI_CAPABILITY ;

#line 18946
typedef void ;

#line 18954
typedef void ;

#line 18963
typedef void ;

#line 18975
typedef struct _PCIBUSDATA ;

#line 18986
typedef ULONG ;

#line 18995
typedef void ;

#line 19000
typedef void ;

#line 19006
typedef struct _PCI_BUS_INTERFACE_STANDARD ;

#line 19028
typedef BOOLEAN ;

#line 19043
typedef struct _PCI_DEVICE_PRESENT_INTERFACE ;

#line 127 "C:/NTDDK/inc/ntddser.h"
typedef struct _SERIALPERF_STATS ;

#line 136
typedef struct _SERIALCONFIG ;

#line 154
typedef struct _SERIAL_LINE_CONTROL ;

#line 160
typedef struct _SERIAL_TIMEOUTS ;

#line 175
typedef struct _SERIAL_QUEUE_SIZE ;

#line 185
typedef struct _SERIAL_BAUD_RATE ;

#line 247
typedef struct _SERIAL_CHARS ;

#line 284
typedef struct _SERIAL_HANDFLOW ;

#line 340
typedef struct _SERIAL_BASIC_SETTINGS ;

#line 353
typedef struct _SERIAL_STATUS ;

#line 433
typedef struct _SERIAL_XOFF_COUNTER ;

#line 539
typedef struct _SERIAL_COMMPROP ;

#line 631
typedef struct _SERENUM_PORT_DESC ;

#line 652
typedef UCHAR ;

#line 658
typedef void ;

#line 665
typedef enum _SERENUM_PORTION ;

#line 671
typedef struct _SERENUM_PORT_PARAMETERS ;

#line 28 "C:/NTDDK/inc/ddk/wdm/wmilib.h"

#pragma once
#line 38
typedef struct  {
	LPCGUID Guid ;
	ULONG InstanceCount ;
	ULONG Flags ;
} ;

#line 45
typedef NTSTATUS ;

#line 101
typedef NTSTATUS ;

#line 162
typedef NTSTATUS ;

#line 206
typedef NTSTATUS ;

#line 253
typedef NTSTATUS ;

#line 306
typedef enum  {
	WmiEventControl,
	WmiDataBlockControl
} ;

#line 312
typedef NTSTATUS ;

#line 355
typedef struct _WMILIB_CONTEXT ;

#line 411
typedef enum  {
	IrpProcessed,
	IrpNotCompleted,
	IrpNotWmi,
	IrpForward
} ;

#line 13 "C:/NTDDK/inc/wmidata.h"
typedef struct _MSWmi_MofData ;

#line 51
typedef struct _MSWmi_ProviderInfo ;

#line 66
typedef struct _MSWmi_PnPDeviceId ;

#line 83
typedef struct _MSWmi_PnPInstanceNames ;

#line 105
typedef struct _MSSmBios_RawSMBiosTables ;

#line 147
typedef struct _MSPower_DeviceEnable ;

#line 165
typedef struct _MSPower_DeviceWakeEnable ;

#line 182
typedef struct _MSNdis_NetworkAddress ;

#line 199
typedef struct _MSNdis_NetworkShortAddress ;

#line 216
typedef struct _MSNdis_NetworkLinkSpeed ;

#line 239
typedef struct _MSNdis_EnumerateAdapter ;

#line 256
typedef struct _MSNdis_NotifyAdapterRemoval ;

#line 273
typedef struct _MSNdis_NotifyAdapterArrival ;

#line 291
typedef struct _MSNdis_NdisEnumerateVc ;

#line 307
typedef struct _MSNdis_NotifyVcRemoval ;

#line 323
typedef struct _MSNdis_NotifyVcArrival ;

#line 338
typedef struct _MSNdis_HardwareStatus ;

#line 356
typedef struct _MSNdis_MediaSupported ;

#line 378
typedef struct _MSNdis_MediaInUse ;

#line 400
typedef struct _MSNdis_MaximumLookahead ;

#line 418
typedef struct _MSNdis_MaximumFrameSize ;

#line 436
typedef struct _MSNdis_LinkSpeed ;

#line 454
typedef struct _MSNdis_TransmitBufferSpace ;

#line 472
typedef struct _MSNdis_ReceiveBufferSpace ;

#line 490
typedef struct _MSNdis_TransmitBlockSize ;

#line 508
typedef struct _MSNdis_ReceiveBlockSize ;

#line 526
typedef struct _MSNdis_VendorID ;

#line 544
typedef struct _MSNdis_VendorDescription ;

#line 561
typedef struct _MSNdis_CurrentPacketFilter ;

#line 579
typedef struct _MSNdis_CurrentLookahead ;

#line 597
typedef struct _MSNdis_DriverVersion ;

#line 615
typedef struct _MSNdis_MaximumTotalSize ;

#line 633
typedef struct _MSNdis_MacOptions ;

#line 651
typedef struct _MSNdis_MediaConnectStatus ;

#line 669
typedef struct _MSNdis_MaximumSendPackets ;

#line 687
typedef struct _MSNdis_VendorDriverVersion ;

#line 705
typedef struct _MSNdis_TransmitsOk ;

#line 723
typedef struct _MSNdis_ReceivesOk ;

#line 741
typedef struct _MSNdis_TransmitsError ;

#line 759
typedef struct _MSNdis_ReceiveError ;

#line 777
typedef struct _MSNdis_ReceiveNoBuffer ;

#line 795
typedef struct _MSNdis_CoHardwareStatus ;

#line 813
typedef struct _MSNdis_CoMediaSupported ;

#line 835
typedef struct _MSNdis_CoMediaInUse ;

#line 857
typedef struct _MSNdis_CoLinkSpeed ;

#line 875
typedef struct _MSNdis_CoVendorId ;

#line 893
typedef struct _MSNdis_CoVendorDescription ;

#line 910
typedef struct _MSNdis_CoDriverVersion ;

#line 928
typedef struct _MSNdis_CoMacOptions ;

#line 946
typedef struct _MSNdis_CoMediaConnectStatus ;

#line 964
typedef struct _MSNdis_CoVendorDriverVersion ;

#line 982
typedef struct _MSNdis_CoMinimumLinkSpeed ;

#line 1000
typedef struct _MSNdis_CoTransmitPdusOk ;

#line 1018
typedef struct _MSNdis_CoReceivePdusOk ;

#line 1036
typedef struct _MSNdis_CoTransmitPduErrors ;

#line 1054
typedef struct _MSNdis_CoReceivePduErrors ;

#line 1072
typedef struct _MSNdis_CoReceivePdusNoBuffer ;

#line 1090
typedef struct _MSNdis_AtmSupportedVcRates ;

#line 1113
typedef struct _MSNdis_AtmSupportedServiceCategory ;

#line 1131
typedef struct _MSNdis_AtmSupportedAalTypes ;

#line 1149
typedef struct _MSNdis_AtmHardwareCurrentAddress ;

#line 1167
typedef struct _MSNdis_AtmMaxActiveVcs ;

#line 1185
typedef struct _MSNdis_AtmMaxActiveVciBits ;

#line 1203
typedef struct _MSNdis_AtmMaxActiveVpiBits ;

#line 1221
typedef struct _MSNdis_AtmMaxAal0PacketSize ;

#line 1239
typedef struct _MSNdis_AtmMaxAal1PacketSize ;

#line 1257
typedef struct _MSNdis_AtmMaxAal34PacketSize ;

#line 1275
typedef struct _MSNdis_AtmMaxAal5PacketSize ;

#line 1293
typedef struct _MSNdis_AtmReceiveCellsOk ;

#line 1311
typedef struct _MSNdis_AtmTransmitCellsOk ;

#line 1329
typedef struct _MSNdis_AtmReceiveCellsDropped ;

#line 1347
typedef struct _MSNdis_EthernetPermanentAddress ;

#line 1365
typedef struct _MSNdis_EthernetCurrentAddress ;

#line 1383
typedef struct _MSNdis_EthernetMulticastList ;

#line 1405
typedef struct _MSNdis_EthernetMaximumMulticastListSize ;

#line 1423
typedef struct _MSNdis_EthernetMacOptions ;

#line 1441
typedef struct _MSNdis_EthernetReceiveErrorAlignment ;

#line 1459
typedef struct _MSNdis_EthernetOneTransmitCollision ;

#line 1477
typedef struct _MSNdis_EthernetMoreTransmitCollisions ;

#line 1495
typedef struct _MSNdis_TokenRingPermanentAddress ;

#line 1513
typedef struct _MSNdis_TokenRingCurrentAddress ;

#line 1531
typedef struct _MSNdis_TokenRingCurrentFunctional ;

#line 1549
typedef struct _MSNdis_TokenRingCurrentGroup ;

#line 1567
typedef struct _MSNdis_TokenRingLastOpenStatus ;

#line 1585
typedef struct _MSNdis_TokenRingCurrentRingStatus ;

#line 1603
typedef struct _MSNdis_TokenRingCurrentRingState ;

#line 1621
typedef struct _MSNdis_TokenRingLineErrors ;

#line 1639
typedef struct _MSNdis_TokenRingLostFrames ;

#line 1657
typedef struct _MSNdis_FddiLongPermanentAddress ;

#line 1675
typedef struct _MSNdis_FddiLongCurrentAddress ;

#line 1693
typedef struct _MSNdis_FddiLongMulticastList ;

#line 1715
typedef struct _MSNdis_FddiLongMaximumListSize ;

#line 1733
typedef struct _MSNdis_FddiShortPermanentAddress ;

#line 1751
typedef struct _MSNdis_FddiShortCurrentAddress ;

#line 1769
typedef struct _MSNdis_FddiShortMulticastList ;

#line 1791
typedef struct _MSNdis_FddiShortMaximumListSize ;

#line 1809
typedef struct _MSNdis_FddiAttachmentType ;

#line 1827
typedef struct _MSNdis_FddiUpstreamNodeLong ;

#line 1845
typedef struct _MSNdis_FddiDownstreamNodeLong ;

#line 1863
typedef struct _MSNdis_FddiFrameErrors ;

#line 1881
typedef struct _MSNdis_FddiFramesLost ;

#line 1899
typedef struct _MSNdis_FddiRingManagmentState ;

#line 1917
typedef struct _MSNdis_FddiLctFailures ;

#line 1935
typedef struct _MSNdis_FddiLemRejects ;

#line 1953
typedef struct _MSNdis_FddiLConnectionState ;

#line 1972
typedef struct _MSNdis_StatusResetStart ;

#line 1988
typedef struct _MSNdis_StatusResetEnd ;

#line 2004
typedef struct _MSNdis_StatusMediaConnect ;

#line 2020
typedef struct _MSNdis_StatusMediaDisconnect ;

#line 2035
typedef struct _MSNdis_StatusMediaSpecificIndication ;

#line 2057
typedef struct _MSNdis_StatusLinkSpeedChange ;

#line 2075
typedef struct _MSNdis_StatusProtocolBind ;

#line 2092
typedef struct _MSNdis_StatusProtocolUnbind ;

#line 2109
typedef struct _KEYBOARD_PORT_WMI_STD_DATA ;

#line 2152
typedef struct _POINTER_PORT_WMI_STD_DATA ;

#line 2205
typedef struct _MSMouse_ClassInformation ;

#line 2223
typedef struct _MSKeyboard_ClassInformation ;

#line 2241
typedef struct _MSAcpi_ThermalZoneTemperature ;

#line 2304
typedef struct _WMI_DISK_GEOMETRY ;

#line 2342
typedef struct _WMI_DISK_PERFORMANCE ;

#line 2415
typedef struct _MSDiskDriver_Performance ;

#line 2437
typedef struct _STORAGE_FAILURE_PREDICT_STATUS ;

#line 2460
typedef struct _STORAGE_FAILURE_PREDICT_DATA ;

#line 2483
typedef struct _STORAGE_FAILURE_PREDICT_EVENT ;

#line 2513
typedef struct _STORAGE_FAILURE_PREDICT_FUNCTION ;

#line 2528
typedef struct _MSIde_PortDeviceInfo ;

#line 2556
typedef struct _MSSerial_PortName ;

#line 2573
typedef struct _SERIAL_WMI_COMM_DATA ;

#line 2723
typedef struct _SERIAL_WMI_HW_DATA ;

#line 2770
typedef struct _SERIAL_WMI_PERF_DATA ;

#line 2813
typedef struct _SERIAL_WMI_COMMPROP ;

#line 2920
typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS ;

#line 2943
typedef struct _PARALLEL_WMI_LOG_INFO ;

#line 3041
typedef struct _REDBOOK_WMI_STD_DATA ;

#line 3094
typedef struct _REDBOOK_WMI_PERF_DATA ;

#line 3137
typedef struct _RegisteredGuids ;

#line 475 "serial.h"
typedef struct _CONFIG_DATA ;

#line 509
typedef struct _SERIAL_CISR_SW ;

#line 520
typedef struct _SERIAL_FIRMWARE_DATA ;

#line 576
typedef struct _SERIAL_DEVICE_STATE ;

#line 646
typedef struct _SERIAL_DEVICE_EXTENSION ;

#line 1808
typedef struct _SERIAL_MULTIPORT_DISPATCH ;

#line 2157
typedef enum _SERIAL_MEM_COMPARES ;

#line 2164
typedef struct _SERIAL_LIST_DATA ;

#line 2169
typedef struct _SERIAL_GLOBALS ;

#line 2180
typedef struct _SERIAL_USER_DATA ;

#line 2206
typedef struct _SERIAL_PTR_CTX ;

#line 20 "serialp.h"
typedef NTSTATUS ;

#line 26
typedef void ;

#line 835
typedef struct _SERIAL_UPDATE_CHAR ;

#line 846
typedef struct _SERIAL_IOCTL_SYNC ;

#line 27 "ioctl.c"
BOOLEAN SerialGetModemUpdate(PVOID Context ) ;
#line 32
BOOLEAN SerialGetCommStatus(PVOID Context ) ;
#line 43
BOOLEAN SerialSetEscapeChar(PVOID Context ) ;

#line 53

#pragma alloc_text(PAGESER, SerialSetBaud)
#line 54

#pragma alloc_text(PAGESER, SerialSetLineControl)
#line 55

#pragma alloc_text(PAGESER, SerialIoControl)
#line 56

#pragma alloc_text(PAGESER, SerialSetChars)
#line 57

#pragma alloc_text(PAGESER, SerialGetModemUpdate)
#line 58

#pragma alloc_text(PAGESER, SerialGetCommStatus)
#line 59

#pragma alloc_text(PAGESER, SerialGetProperties)
#line 60

#pragma alloc_text(PAGESER, SerialSetEscapeChar)
#line 61

#pragma alloc_text(PAGESER, SerialGetStats)
#line 62

#pragma alloc_text(PAGESER, SerialClearStats)
#line 63

#pragma alloc_text(PAGESER, SerialSetMCRContents)
#line 64

#pragma alloc_text(PAGESER, SerialGetMCRContents)
#line 65

#pragma alloc_text(PAGESER, SerialSetFCRContents)
#line 66

#pragma alloc_text(PAGESER, SerialInternalIoControl)
#line 70
BOOLEAN SerialGetStats(PVOID Context )
{
	#line 95
	PIO_STACK_LOCATION irpSp = ((((PIRP
		)Context)->Tail).Overlay).CurrentStackLocation;
	#line 96
	PSERIAL_DEVICE_EXTENSION extension
		= (irpSp->DeviceObject)->DeviceExtension;
	#line 97
	PSERIALPERF_STATS sp = (((PIRP )Context)->AssociatedIrp).SystemBuffer;
	#line 99
	;
	#line 101
	* sp = extension->PerfStats;
	return 0;
}

#line 106
BOOLEAN SerialClearStats(PVOID Context )
{
	#line 130
	;
	#line 135
	memset(& ((PSERIAL_DEVICE_EXTENSION )Context)->PerfStats, 0,
		sizeof(SERIALPERF_STATS ));
	#line 138
	memset(& ((PSERIAL_DEVICE_EXTENSION )Context)->WmiPerfData, 0,
		sizeof(SERIAL_WMI_PERF_DATA ));
	#line 139
	return 0;
}

#line 144
BOOLEAN SerialSetChars(PVOID Context )
{
	#line 170
	(((PSERIAL_IOCTL_SYNC )Context)->Extension)->SpecialChars = *
		(PSERIAL_CHARS )((PSERIAL_IOCTL_SYNC )Context)->Data;
	#line 173
	;
	#line 175
	return 0;
}

#line 179
BOOLEAN SerialSetBaud(PVOID Context )
{
	#line 204
	PSERIAL_DEVICE_EXTENSION Extension = ((PSERIAL_IOCTL_SYNC
		)Context)->Extension;
	#line 205
	USHORT Appropriate = (unsigned short )((ULONG_PTR )((PSERIAL_IOCTL_SYNC
		)Context)->Data);
	;
	#line 213
	do
	{
		#line 213
		PUCHAR Address = Extension->Controller;
		#line 213
		SHORT Divisor = Appropriate;
		#line 213
		UCHAR LineControl ;
		#line 213
		LineControl = READ_PORT_UCHAR(Address + (ULONG )(0x03 * 1));
		#line 213
		WRITE_PORT_UCHAR(Address + (ULONG )(0x03 * 1), (UCHAR
			)(LineControl | 0x80));
		#line 213
		WRITE_PORT_UCHAR(Address + (ULONG )(0x00 * 1), (UCHAR )(Divisor
			& 0xff));
		#line 213
		WRITE_PORT_UCHAR(Address + (ULONG )(0x01 * 1), (UCHAR )((Divisor
			& 0xff00) >> 8));
		#line 213
		WRITE_PORT_UCHAR(Address + (ULONG )(0x03 * 1), LineControl);
	}
	while(0);
	#line 215
	return 0;
}

#line 219
BOOLEAN SerialSetLineControl(PVOID Context )
{
	#line 242
	PSERIAL_DEVICE_EXTENSION Extension = Context;
	#line 244
	;
	#line 249
	do
	{
		#line 249
		WRITE_PORT_UCHAR(Extension->Controller + (ULONG )(0x03 * 1),
			Extension->LineControl);
	}
	while(0);
	#line 251
	return 0;
}

#line 255
BOOLEAN SerialGetModemUpdate(PVOID Context )
{
	#line 280
	PSERIAL_DEVICE_EXTENSION Extension = ((PSERIAL_IOCTL_SYNC
		)Context)->Extension;
	#line 281
	ULONG *  Result = (ULONG *  )((PSERIAL_IOCTL_SYNC )Context)->Data;
	#line 283
	;
	#line 286
	* Result = SerialHandleModemUpdate(Extension, 0);
	#line 291
	return 0;
}

#line 296
BOOLEAN SerialSetMCRContents(PVOID Context )
{
	#line 315
	PSERIAL_DEVICE_EXTENSION Extension = ((PSERIAL_IOCTL_SYNC
		)Context)->Extension;
	#line 316
	ULONG *  Result = (ULONG *  )((PSERIAL_IOCTL_SYNC )Context)->Data;
	#line 318
	;
	#line 324
	do
	{
		#line 324
		WRITE_PORT_UCHAR(Extension->Controller + (ULONG )(0x04 * 1),
			(UCHAR )((ULONG )((ULONG_PTR )Result)));
	}
	while(0);
	#line 325
	return 0;
}

#line 330
BOOLEAN SerialGetMCRContents(PVOID Context )
{
	#line 352
	PSERIAL_DEVICE_EXTENSION Extension = ((PSERIAL_IOCTL_SYNC
		)Context)->Extension;
	#line 353
	ULONG *  Result = (ULONG *  )((PSERIAL_IOCTL_SYNC )Context)->Data;
	#line 355
	;
	#line 357
	* Result = READ_PORT_UCHAR(Extension->Controller + (ULONG )(0x04 * 1));
	return 0;
}

#line 364
BOOLEAN SerialSetFCRContents(PVOID Context )
{
	#line 383
	PSERIAL_DEVICE_EXTENSION Extension = ((PSERIAL_IOCTL_SYNC
		)Context)->Extension;
	#line 384
	ULONG *  Result = (ULONG *  )((PSERIAL_IOCTL_SYNC )Context)->Data;
	#line 386
	;
	#line 392
	do
	{
		#line 392
		WRITE_PORT_UCHAR(Extension->Controller + (ULONG )(0x02 * 1),
			(UCHAR )(* Result));
	}
	while(0);
	#line 393
	return 0;
}

#line 397
BOOLEAN SerialGetCommStatus(PVOID Context )
{
	#line 422
	PSERIAL_DEVICE_EXTENSION Extension = ((PSERIAL_IOCTL_SYNC
		)Context)->Extension;
	#line 423
	PSERIAL_STATUS Stat = ((PSERIAL_IOCTL_SYNC )Context)->Data;
	#line 425
	;
	#line 428
	Stat->Errors = Extension->ErrorWord;
	Extension->ErrorWord = 0;
	#line 434
	Stat->EofReceived = 0;
	#line 436
	Stat->AmountInInQueue = Extension->CharsInInterruptBuffer;
	#line 438
	Stat->AmountInOutQueue = Extension->TotalCharsQueued;
	#line 440
	if(Extension->WriteLength)
	{
		#line 447
		;
		;
		#line 450
		Stat->AmountInOutQueue -=
			((((((Extension->CurrentWriteIrp)->Tail).Overlay).CurrentStackLocation
			)->Parameters).Write).Length - Extension->WriteLength;
	}
	#line 456
	Stat->WaitForImmediate = Extension->TransmitImmediate;
	#line 458
	Stat->HoldReasons = 0;
	if(Extension->TXHolding)
	{
		if(Extension->TXHolding & (ULONG )0x01)
		{
			Stat->HoldReasons |= (ULONG )0x00000001;
		}
		#line 467
		if(Extension->TXHolding & (ULONG )0x02)
		{
			Stat->HoldReasons |= (ULONG )0x00000002;
		}
		#line 473
		if(Extension->TXHolding & (ULONG )0x04)
		{
			Stat->HoldReasons |= (ULONG )0x00000004;
		}
		#line 479
		if(Extension->TXHolding & (ULONG )0x08)
		{
			Stat->HoldReasons |= (ULONG )0x00000008;
		}
		#line 485
		if(Extension->TXHolding & (ULONG )0x10)
		{
			Stat->HoldReasons |= (ULONG )0x00000020;
		}
	}
	#line 493
	if(Extension->RXHolding & (ULONG )0x08)
	{
		Stat->HoldReasons |= (ULONG )0x00000040;
	}
	#line 499
	if(Extension->RXHolding & (ULONG )0x02)
	{
		Stat->HoldReasons |= (ULONG )0x00000010;
	}
	#line 505
	return 0;
}

#line 509
BOOLEAN SerialSetEscapeChar(PVOID Context )
{
	#line 536
	PSERIAL_DEVICE_EXTENSION extension = ((((((PIRP
		)Context)->Tail).Overlay).CurrentStackLocation)->DeviceObject)->DeviceExtension
		;
	#line 541
	extension->EscapeChar = * (PUCHAR )(((PIRP
		)Context)->AssociatedIrp).SystemBuffer;
	#line 544
	return 0;
}

#line 549
NTSTATUS SerialIoControl(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
	#line 579
	NTSTATUS Status ;
	#line 585
	PIO_STACK_LOCATION IrpSp ;
	#line 591
	PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
	#line 597
	KIRQL OldIrql ;
	#line 599
	NTSTATUS prologueStatus ;
	#line 601
	;
	#line 608
	if(Extension->DeviceIsOpened != 1)
	{
		#line 609
		(Irp->IoStatus).Status = (NTSTATUS )0xC0000010L;
		IofCompleteRequest(Irp, 0);
		return (NTSTATUS )0xC0000010L;
	}
	#line 615
	if((prologueStatus = SerialIRPPrologue(Irp, Extension)) != (NTSTATUS
		)0x00000000L)
	{
		#line 617
		(Irp->IoStatus).Status = prologueStatus;
		{
			#line 618
			IofCompleteRequest(Irp, 0);
			#line 618
			SerialIRPEpilogue(Extension);
		}
		#line 618
		;
		return prologueStatus;
	}
	#line 625
	do
	{
		#line 625
		;
	}
	while(0);
	#line 626
	if(SerialCompleteIfError(DeviceObject, Irp) != (NTSTATUS )0x00000000L)
	{
		#line 631
		return (NTSTATUS )0xC0000120L;
	}
	#line 634
	IrpSp = ((Irp->Tail).Overlay).CurrentStackLocation;
	(Irp->IoStatus).Information = 0L;
	Status = (NTSTATUS )0x00000000L;
	switch(((IrpSp->Parameters).DeviceIoControl).IoControlCode)
	{
	case 0x0000001b << 16 | 0 << 14 | 1 << 2 | 0:
			#line 639
			;
		{
			ULONG BaudRate ;
			#line 659
			SHORT AppropriateDivisor ;
			#line 661
			if(((IrpSp->Parameters).DeviceIoControl).InputBufferLength
				< sizeof(SERIAL_BAUD_RATE ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			else
			{
				BaudRate = ((PSERIAL_BAUD_RATE
					)(Irp->AssociatedIrp).SystemBuffer)->BaudRate
					;
			}
			#line 678
			Status = SerialGetDivisorFromBaud(Extension->ClockRate,
				BaudRate, & AppropriateDivisor);
			#line 688
			if((NTSTATUS )Status >= 0)
			{
				#line 689
				if(Extension->PowerState != PowerDeviceD0)
				{
					#line 690
					Status =
						SerialGotoPowerState(Extension->Pdo,
						Extension, PowerDeviceD0);
					#line 692
					if(! ((NTSTATUS )Status >= 0))
					{
						#line 693
						break;
					}
				}
			}
			#line 701
			* & OldIrql = KfAcquireSpinLock(&
				Extension->ControlLock);
			if((NTSTATUS )Status >= 0)
			{
				SERIAL_IOCTL_SYNC S ;
				#line 708
				Extension->CurrentBaud = BaudRate;
				(Extension->WmiCommData).BaudRate = BaudRate;
				#line 711
				S.Extension = Extension;
				S.Data = (PVOID )AppropriateDivisor;
				KeSynchronizeExecution(Extension->Interrupt,
					SerialSetBaud, & S);
			}
			#line 724
			KfReleaseSpinLock(& Extension->ControlLock, OldIrql);
			#line 726
			break;
		}
	case 0x0000001b << 16 | 0 << 14 | 20 << 2 | 0:
			#line 728
			;
		{
			PSERIAL_BAUD_RATE Br = (PSERIAL_BAUD_RATE
				)(Irp->AssociatedIrp).SystemBuffer;
			#line 731
			if(((IrpSp->Parameters).DeviceIoControl).OutputBufferLength
				< sizeof(SERIAL_BAUD_RATE ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 742
			* & OldIrql = KfAcquireSpinLock(&
				Extension->ControlLock);
			Br->BaudRate = Extension->CurrentBaud;
			#line 749
			KfReleaseSpinLock(& Extension->ControlLock, OldIrql);
			#line 751
			(Irp->IoStatus).Information = sizeof(SERIAL_BAUD_RATE );
			#line 753
			break;
		}
		#line 757
	case 0x0000001b << 16 | 0 << 14 | 37 << 2 | 0:
			#line 757
			;
		{
			#line 758
			SERIAL_IOCTL_SYNC S ;
			#line 760
			if(((IrpSp->Parameters).DeviceIoControl).OutputBufferLength
				< sizeof(ULONG ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 768
			(Irp->IoStatus).Information = sizeof(ULONG );
			#line 770
			S.Extension = Extension;
			S.Data = (Irp->AssociatedIrp).SystemBuffer;
			#line 776
			* & OldIrql = KfAcquireSpinLock(&
				Extension->ControlLock);
			KeSynchronizeExecution(Extension->Interrupt,
				SerialGetMCRContents, & S);
			#line 787
			KfReleaseSpinLock(& Extension->ControlLock, OldIrql);
			#line 789
			break;
		}
	case 0x0000001b << 16 | 0 << 14 | 38 << 2 | 0:
			#line 791
			;
		{
			#line 792
			SERIAL_IOCTL_SYNC S ;
			#line 794
			if(((IrpSp->Parameters).DeviceIoControl).InputBufferLength
				< sizeof(ULONG ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 802
			S.Extension = Extension;
			S.Data = (Irp->AssociatedIrp).SystemBuffer;
			#line 809
			if(Extension->PowerState != PowerDeviceD0)
			{
				#line 810
				Status = SerialGotoPowerState(Extension->Pdo,
					Extension, PowerDeviceD0);
				if(! ((NTSTATUS )Status >= 0))
				{
					#line 813
					break;
				}
			}
			#line 820
			* & OldIrql = KfAcquireSpinLock(&
				Extension->ControlLock);
			KeSynchronizeExecution(Extension->Interrupt,
				SerialSetMCRContents, & S);
			#line 831
			KfReleaseSpinLock(& Extension->ControlLock, OldIrql);
			#line 833
			break;
		}
	case 0x0000001b << 16 | 0 << 14 | 39 << 2 | 0:
			#line 835
			;
		{
			#line 836
			SERIAL_IOCTL_SYNC S ;
			#line 838
			if(((IrpSp->Parameters).DeviceIoControl).InputBufferLength
				< sizeof(ULONG ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 846
			S.Extension = Extension;
			S.Data = (Irp->AssociatedIrp).SystemBuffer;
			#line 853
			if(Extension->PowerState != PowerDeviceD0)
			{
				#line 854
				Status = SerialGotoPowerState(Extension->Pdo,
					Extension, PowerDeviceD0);
				if(! ((NTSTATUS )Status >= 0))
				{
					#line 857
					break;
				}
			}
			#line 864
			* & OldIrql = KfAcquireSpinLock(&
				Extension->ControlLock);
			KeSynchronizeExecution(Extension->Interrupt,
				SerialSetFCRContents, & S);
			#line 875
			KfReleaseSpinLock(& Extension->ControlLock, OldIrql);
			#line 877
			break;
		}
	case 0x0000001b << 16 | 0 << 14 | 3 << 2 | 0:
			#line 879
			;
		{
			#line 884
			PSERIAL_LINE_CONTROL Lc = (PSERIAL_LINE_CONTROL
				)(Irp->AssociatedIrp).SystemBuffer;
			#line 887
			UCHAR LData ;
			UCHAR LStop ;
			UCHAR LParity ;
			UCHAR Mask = 0xff;
			#line 892
			if(((IrpSp->Parameters).DeviceIoControl).InputBufferLength
				< sizeof(SERIAL_LINE_CONTROL ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 904
			if(Extension->PowerState != PowerDeviceD0)
			{
				#line 905
				Status = SerialGotoPowerState(Extension->Pdo,
					Extension, PowerDeviceD0);
				if(! ((NTSTATUS )Status >= 0))
				{
					#line 908
					break;
				}
			}
			#line 912
			switch(Lc->WordLength)
			{
				#line 913
			case 5:
					#line 913
					;
				{
					LData = (UCHAR )0x00;
					Mask = 0x1f;
					break;
				}
				#line 920
			case 6:
					#line 920
					;
				{
					LData = (UCHAR )0x01;
					Mask = 0x3f;
					break;
				}
				#line 927
			case 7:
					#line 927
					;
				{
					LData = (UCHAR )0x02;
					Mask = 0x7f;
					break;
				}
				#line 934
			case 8:
					#line 934
					;
				{
					LData = (UCHAR )0x03;
					break;
				}
				#line 940
			default :
					#line 940
					;
				{
					Status = (NTSTATUS )0xC000000DL;
					goto DoneWithIoctl;
				}
			}
			#line 949
			(Extension->WmiCommData).BitsPerByte = Lc->WordLength;
			#line 951
			switch(Lc->Parity)
			{
			case 0:
					#line 953
					;
				{
					#line 954
					(Extension->WmiCommData).Parity = 0;
					LParity = (UCHAR )0x00;
					break;
				}
				#line 959
			case 2:
					#line 959
					;
				{
					#line 960
					(Extension->WmiCommData).Parity = 2;
					LParity = (UCHAR )0x18;
					break;
				}
				#line 965
			case 1:
					#line 965
					;
				{
					#line 966
					(Extension->WmiCommData).Parity = 1;
					LParity = (UCHAR )0x08;
					break;
				}
				#line 971
			case 4:
					#line 971
					;
				{
					#line 972
					(Extension->WmiCommData).Parity = 3;
					LParity = (UCHAR )0x38;
					break;
				}
				#line 977
			case 3:
					#line 977
					;
				{
					#line 978
					(Extension->WmiCommData).Parity = 4;
					LParity = (UCHAR )0x28;
					break;
				}
				#line 983
			default :
					#line 983
					;
				{
					Status = (NTSTATUS )0xC000000DL;
					goto DoneWithIoctl;
					break;
				}
			}
			#line 992
			switch(Lc->StopBits)
			{
			case 0:
					#line 994
					;
				{
					#line 995
					(Extension->WmiCommData).StopBits = 0;
					LStop = (UCHAR )0x00;
					break;
				}
			case 1:
					#line 999
					;
				{
					if(LData != (UCHAR )0x00)
					{
						Status = (NTSTATUS )0xC000000DL;
						goto DoneWithIoctl;
					}
					(Extension->WmiCommData).StopBits = 1;
					LStop = (UCHAR )0x04;
					break;
				}
				#line 1011
			case 2:
					#line 1011
					;
				{
					if(LData == (UCHAR )0x00)
					{
						Status = (NTSTATUS )0xC000000DL;
						goto DoneWithIoctl;
					}
					(Extension->WmiCommData).StopBits = 2;
					LStop = (UCHAR )0x04;
					break;
				}
				#line 1023
			default :
					#line 1023
					;
				{
					Status = (NTSTATUS )0xC000000DL;
					goto DoneWithIoctl;
				}
			}
			#line 1034
			* & OldIrql = KfAcquireSpinLock(&
				Extension->ControlLock);
			Extension->LineControl = (UCHAR )(Extension->LineControl
				& 0x40 | (LData | LParity | LStop));
			#line 1039
			Extension->ValidDataMask = Mask;
			#line 1041
			KeSynchronizeExecution(Extension->Interrupt,
				SerialSetLineControl, Extension);
			#line 1050
			KfReleaseSpinLock(& Extension->ControlLock, OldIrql);
			#line 1052
			break;
		}
	case 0x0000001b << 16 | 0 << 14 | 21 << 2 | 0:
			#line 1054
			;
		{
			PSERIAL_LINE_CONTROL Lc = (PSERIAL_LINE_CONTROL
				)(Irp->AssociatedIrp).SystemBuffer;
			if(((IrpSp->Parameters).DeviceIoControl).OutputBufferLength
				< sizeof(SERIAL_LINE_CONTROL ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 1069
			* & OldIrql = KfAcquireSpinLock(&
				Extension->ControlLock);
			if((Extension->LineControl & (UCHAR )0x03) == (UCHAR
				)0x00)
			{
				#line 1072
				Lc->WordLength = 5;
			}
			else
			{
				#line 1073
				if((Extension->LineControl & (UCHAR )0x03) ==
					(UCHAR )0x01)
				{
					#line 1075
					Lc->WordLength = 6;
				}
				else
				{
					#line 1076
					if((Extension->LineControl & (UCHAR
						)0x03) == (UCHAR )0x02)
					{
						#line 1078
						Lc->WordLength = 7;
					}
					else
					{
						#line 1079
						if((Extension->LineControl &
							(UCHAR )0x03) == (UCHAR
							)0x03)
						{
							#line 1081
							Lc->WordLength = 8;
						}
					}
				}
			}
			#line 1084
			if((Extension->LineControl & (UCHAR )0x38) == (UCHAR
				)0x00)
			{
				#line 1086
				Lc->Parity = 0;
			}
			else
			{
				#line 1087
				if((Extension->LineControl & (UCHAR )0x38) ==
					(UCHAR )0x08)
				{
					#line 1089
					Lc->Parity = 1;
				}
				else
				{
					#line 1090
					if((Extension->LineControl & (UCHAR
						)0x38) == (UCHAR )0x18)
					{
						#line 1092
						Lc->Parity = 2;
					}
					else
					{
						#line 1093
						if((Extension->LineControl &
							(UCHAR )0x38) == (UCHAR
							)0x28)
						{
							#line 1095
							Lc->Parity = 3;
						}
						else
						{
							#line 1096
							if((Extension->LineControl
								& (UCHAR )0x38)
								== (UCHAR )0x38)
							{
	#line 1098
	Lc->Parity = 4;
							}
						}
					}
				}
			}
			#line 1101
			if(Extension->LineControl & (UCHAR )0x04)
			{
				#line 1102
				if(Lc->WordLength == 5)
				{
					#line 1103
					Lc->StopBits = 1;
				}
				else
				{
					#line 1105
					Lc->StopBits = 2;
				}
			}
			else
			{
				#line 1108
				Lc->StopBits = 0;
			}
			#line 1111
			(Irp->IoStatus).Information = sizeof(SERIAL_LINE_CONTROL
				);
			#line 1116
			KfReleaseSpinLock(& Extension->ControlLock, OldIrql);
			#line 1118
			break;
		}
	case 0x0000001b << 16 | 0 << 14 | 7 << 2 | 0:
			#line 1120
			;
		{
			PSERIAL_TIMEOUTS NewTimeouts = (PSERIAL_TIMEOUTS
				)(Irp->AssociatedIrp).SystemBuffer;
			#line 1126
			if(((IrpSp->Parameters).DeviceIoControl).InputBufferLength
				< sizeof(SERIAL_TIMEOUTS ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 1134
			if(NewTimeouts->ReadIntervalTimeout == 0xffffffff &&
				NewTimeouts->ReadTotalTimeoutMultiplier ==
				0xffffffff &&
				NewTimeouts->ReadTotalTimeoutConstant ==
				0xffffffff)
			{
				#line 1138
				Status = (NTSTATUS )0xC000000DL;
				break;
			}
			#line 1146
			* & OldIrql = KfAcquireSpinLock(&
				Extension->ControlLock);
			(Extension->Timeouts).ReadIntervalTimeout =
				NewTimeouts->ReadIntervalTimeout;
			#line 1151
			(Extension->Timeouts).ReadTotalTimeoutMultiplier =
				NewTimeouts->ReadTotalTimeoutMultiplier;
			#line 1154
			(Extension->Timeouts).ReadTotalTimeoutConstant =
				NewTimeouts->ReadTotalTimeoutConstant;
			#line 1157
			(Extension->Timeouts).WriteTotalTimeoutMultiplier =
				NewTimeouts->WriteTotalTimeoutMultiplier;
			#line 1160
			(Extension->Timeouts).WriteTotalTimeoutConstant =
				NewTimeouts->WriteTotalTimeoutConstant;
			#line 1166
			KfReleaseSpinLock(& Extension->ControlLock, OldIrql);
			#line 1168
			break;
		}
	case 0x0000001b << 16 | 0 << 14 | 8 << 2 | 0:
			#line 1170
			;
		{
			if(((IrpSp->Parameters).DeviceIoControl).OutputBufferLength
				< sizeof(SERIAL_TIMEOUTS ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 1183
			* & OldIrql = KfAcquireSpinLock(&
				Extension->ControlLock);
			* (PSERIAL_TIMEOUTS )(Irp->AssociatedIrp).SystemBuffer =
				Extension->Timeouts;
			#line 1186
			(Irp->IoStatus).Information = sizeof(SERIAL_TIMEOUTS );
			#line 1191
			KfReleaseSpinLock(& Extension->ControlLock, OldIrql);
			#line 1193
			break;
		}
	case 0x0000001b << 16 | 0 << 14 | 23 << 2 | 0:
			#line 1195
			;
		{
			SERIAL_IOCTL_SYNC S ;
			PSERIAL_CHARS NewChars = (PSERIAL_CHARS
				)(Irp->AssociatedIrp).SystemBuffer;
			#line 1202
			if(((IrpSp->Parameters).DeviceIoControl).InputBufferLength
				< sizeof(SERIAL_CHARS ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 1232
			S.Extension = Extension;
			S.Data = NewChars;
			#line 1238
			* & OldIrql = KfAcquireSpinLock(&
				Extension->ControlLock);
			#line 1246
			if(Extension->EscapeChar)
			{
				if(Extension->EscapeChar == NewChars->XonChar ||
					Extension->EscapeChar ==
					NewChars->XoffChar)
				{
					#line 1251
					Status = (NTSTATUS )0xC000000DL;
					#line 1255
					KfReleaseSpinLock(&
						Extension->ControlLock,
						OldIrql);
					#line 1256
					break;
				}
			}
			#line 1262
			(Extension->WmiCommData).XonCharacter =
				NewChars->XonChar;
			#line 1263
			(Extension->WmiCommData).XoffCharacter =
				NewChars->XoffChar;
			KeSynchronizeExecution(Extension->Interrupt,
				SerialSetChars, & S);
			#line 1274
			KfReleaseSpinLock(& Extension->ControlLock, OldIrql);
			#line 1276
			break;
		}
		#line 1279
	case 0x0000001b << 16 | 0 << 14 | 22 << 2 | 0:
			#line 1279
			;
		{
			if(((IrpSp->Parameters).DeviceIoControl).OutputBufferLength
				< sizeof(SERIAL_CHARS ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 1292
			* & OldIrql = KfAcquireSpinLock(&
				Extension->ControlLock);
			* (PSERIAL_CHARS )(Irp->AssociatedIrp).SystemBuffer =
				Extension->SpecialChars;
			#line 1295
			(Irp->IoStatus).Information = sizeof(SERIAL_CHARS );
			#line 1300
			KfReleaseSpinLock(& Extension->ControlLock, OldIrql);
			#line 1302
			break;
		}
	case 0x0000001b << 16 | 0 << 14 | 9 << 2 | 0:
			#line 1304
			;
	case 0x0000001b << 16 | 0 << 14 | 10 << 2 | 0:
			#line 1305
			;
		{
			#line 1311
			if(Extension->PowerState != PowerDeviceD0)
			{
				#line 1312
				Status = SerialGotoPowerState(Extension->Pdo,
					Extension, PowerDeviceD0);
				if(! ((NTSTATUS )Status >= 0))
				{
					#line 1315
					break;
				}
			}
			#line 1329
			* & OldIrql = KfAcquireSpinLock(&
				Extension->ControlLock);
			if(((Extension->HandFlow).ControlHandShake & (ULONG
				)0x03) == (ULONG )0x02)
			{
				Status = (NTSTATUS )0xC000000DL;
			}
			else
			{
				KeSynchronizeExecution(Extension->Interrupt,
					((IrpSp->Parameters).DeviceIoControl).IoControlCode
					== (0x0000001b << 16 | 0 << 14 | 9 << 2
					| 0) ? SerialSetDTR : SerialClrDTR,
					Extension);
			}
			#line 1351
			KfReleaseSpinLock(& Extension->ControlLock, OldIrql);
			#line 1353
			break;
		}
	case 0x0000001b << 16 | 0 << 14 | 11 << 2 | 0:
			#line 1355
			;
		{
			break;
		}
	case 0x0000001b << 16 | 0 << 14 | 12 << 2 | 0:
			#line 1359
			;
	case 0x0000001b << 16 | 0 << 14 | 13 << 2 | 0:
			#line 1360
			;
		{
			#line 1365
			if(Extension->PowerState != PowerDeviceD0)
			{
				#line 1366
				Status = SerialGotoPowerState(Extension->Pdo,
					Extension, PowerDeviceD0);
				if(! ((NTSTATUS )Status >= 0))
				{
					#line 1369
					break;
				}
			}
			#line 1384
			* & OldIrql = KfAcquireSpinLock(&
				Extension->ControlLock);
			if(((Extension->HandFlow).FlowReplace & (ULONG )0xc0) ==
				(ULONG )0x80 ||
				((Extension->HandFlow).FlowReplace & (ULONG
				)0xc0) == (ULONG )0xc0)
			{
				Status = (NTSTATUS )0xC000000DL;
			}
			else
			{
				KeSynchronizeExecution(Extension->Interrupt,
					((IrpSp->Parameters).DeviceIoControl).IoControlCode
					== (0x0000001b << 16 | 0 << 14 | 12 << 2
					| 0) ? SerialSetRTS : SerialClrRTS,
					Extension);
			}
			#line 1408
			KfReleaseSpinLock(& Extension->ControlLock, OldIrql);
			#line 1410
			break;
		}
		#line 1413
	case 0x0000001b << 16 | 0 << 14 | 14 << 2 | 0:
			#line 1413
			;
		{
			KeSynchronizeExecution(Extension->Interrupt,
				SerialPretendXoff, Extension);
			#line 1421
			break;
		}
		#line 1424
	case 0x0000001b << 16 | 0 << 14 | 15 << 2 | 0:
			#line 1424
			;
		{
			KeSynchronizeExecution(Extension->Interrupt,
				SerialPretendXon, Extension);
			#line 1432
			break;
		}
		#line 1435
	case 0x0000001b << 16 | 0 << 14 | 4 << 2 | 0:
			#line 1435
			;
		{
			#line 1440
			if(Extension->PowerState != PowerDeviceD0)
			{
				#line 1441
				Status = SerialGotoPowerState(Extension->Pdo,
					Extension, PowerDeviceD0);
				if(! ((NTSTATUS )Status >= 0))
				{
					#line 1444
					break;
				}
			}
			#line 1448
			KeSynchronizeExecution(Extension->Interrupt,
				SerialTurnOnBreak, Extension);
			#line 1454
			break;
		}
	case 0x0000001b << 16 | 0 << 14 | 5 << 2 | 0:
			#line 1456
			;
		{
			#line 1461
			if(Extension->PowerState != PowerDeviceD0)
			{
				#line 1462
				Status = SerialGotoPowerState(Extension->Pdo,
					Extension, PowerDeviceD0);
				if(! ((NTSTATUS )Status >= 0))
				{
					#line 1465
					break;
				}
			}
			#line 1469
			KeSynchronizeExecution(Extension->Interrupt,
				SerialTurnOffBreak, Extension);
			#line 1475
			break;
		}
	case 0x0000001b << 16 | 0 << 14 | 2 << 2 | 0:
			#line 1477
			;
		{
			#line 1485
			PSERIAL_QUEUE_SIZE Rs = (PSERIAL_QUEUE_SIZE
				)(Irp->AssociatedIrp).SystemBuffer;
			#line 1488
			if(((IrpSp->Parameters).DeviceIoControl).InputBufferLength
				< sizeof(SERIAL_QUEUE_SIZE ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 1506
			if(Rs->InSize <= Extension->BufferSize)
			{
				Status = (NTSTATUS )0x00000000L;
				break;
			}
			#line 1515
			((IrpSp->Parameters).DeviceIoControl).Type3InputBuffer =
				ExAllocatePoolWithQuotaTag(NonPagedPool,
				Rs->InSize, 'XMOC');
			#line 1530
			if(!
				((IrpSp->Parameters).DeviceIoControl).Type3InputBuffer)
			{
				#line 1532
				break;
			}
			#line 1549
			return SerialStartOrQueue(Extension, Irp, &
				Extension->ReadQueue, &
				Extension->CurrentReadIrp, SerialStartRead);
			#line 1557
			break;
		}
		#line 1560
	case 0x0000001b << 16 | 0 << 14 | 16 << 2 | 0:
			#line 1560
			;
		{
			if(((IrpSp->Parameters).DeviceIoControl).OutputBufferLength
				< sizeof(ULONG ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 1574
			(Irp->IoStatus).Information = sizeof(ULONG );
			#line 1576
			* (ULONG *  )(Irp->AssociatedIrp).SystemBuffer =
				Extension->IsrWaitMask;
			break;
		}
		#line 1581
	case 0x0000001b << 16 | 0 << 14 | 17 << 2 | 0:
			#line 1581
			;
		{
			ULONG NewMask ;
			#line 1588
			do
			{
				#line 1588
				;
			}
			while(0);
			#line 1589
			if(((IrpSp->Parameters).DeviceIoControl).InputBufferLength
				< sizeof(ULONG ))
			{
				#line 1596
				do
				{
					#line 1596
					;
				}
				while(0);
				#line 1597
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			else
			{
				NewMask = * (ULONG * 
					)(Irp->AssociatedIrp).SystemBuffer;
			}
			#line 1611
			if(NewMask & ~ (0x0001 | 0x0002 | 0x0004 | 0x0008 |
				0x0010 | 0x0020 | 0x0040 | 0x0080 | 0x0100 |
				0x0200 | 0x0400 | 0x0800 | 0x1000))
			{
				#line 1628
				do
				{
					#line 1628
					;
				}
				while(0);
				#line 1629
				Status = (NTSTATUS )0xC000000DL;
				break;
			}
			#line 1642
			do
			{
				#line 1642
				;
			}
			while(0);
			#line 1643
			return SerialStartOrQueue(Extension, Irp, &
				Extension->MaskQueue, &
				Extension->CurrentMaskIrp, SerialStartMask);
		}
		#line 1652
	case 0x0000001b << 16 | 0 << 14 | 18 << 2 | 0:
			#line 1652
			;
		{
			#line 1657
			do
			{
				#line 1657
				;
			}
			while(0);
			#line 1658
			if(((IrpSp->Parameters).DeviceIoControl).OutputBufferLength
				< sizeof(ULONG ))
			{
				#line 1665
				do
				{
					#line 1665
					;
				}
				while(0);
				#line 1666
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 1679
			do
			{
				#line 1679
				;
			}
			while(0);
			#line 1680
			return SerialStartOrQueue(Extension, Irp, &
				Extension->MaskQueue, &
				Extension->CurrentMaskIrp, SerialStartMask);
		}
		#line 1689
	case 0x0000001b << 16 | 0 << 14 | 6 << 2 | 0:
			#line 1689
			;
		{
			KIRQL OldIrql ;
			#line 1693
			if(((IrpSp->Parameters).DeviceIoControl).InputBufferLength
				< sizeof(UCHAR ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 1701
			IoAcquireCancelSpinLock(& OldIrql);
			if(Extension->CurrentImmediateIrp)
			{
				Status = (NTSTATUS )0xC000000DL;
				IoReleaseCancelSpinLock(OldIrql);
			}
			else
			{
				#line 1716
				if(Irp->Cancel)
				{
					IoReleaseCancelSpinLock(OldIrql);
					Status = (NTSTATUS )0xC0000120L;
				}
				else
				{
					Extension->CurrentImmediateIrp = Irp;
					Extension->TotalCharsQueued++;
					IoReleaseCancelSpinLock(OldIrql);
					SerialStartImmediate(Extension);
					#line 1728
					return (NTSTATUS )0x00000103L;
				}
			}
			#line 1734
			break;
		}
		#line 1737
	case 0x0000001b << 16 | 0 << 14 | 19 << 2 | 0:
			#line 1737
			;
		{
			ULONG Mask ;
			#line 1741
			if(((IrpSp->Parameters).DeviceIoControl).InputBufferLength
				< sizeof(ULONG ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 1753
			Mask = * (ULONG *  )(Irp->AssociatedIrp).SystemBuffer;
			#line 1755
			if(! Mask || Mask & ~ (0x00000001 | 0x00000002 |
				0x00000004 | 0x00000008))
			{
				#line 1763
				Status = (NTSTATUS )0xC000000DL;
				break;
			}
			#line 1773
			return SerialStartOrQueue(Extension, Irp, &
				Extension->PurgeQueue, &
				Extension->CurrentPurgeIrp, SerialStartPurge);
		}
		#line 1782
	case 0x0000001b << 16 | 0 << 14 | 24 << 2 | 0:
			#line 1782
			;
		{
			if(((IrpSp->Parameters).DeviceIoControl).OutputBufferLength
				< sizeof(SERIAL_HANDFLOW ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 1792
			(Irp->IoStatus).Information = sizeof(SERIAL_HANDFLOW );
			#line 1797
			* & OldIrql = KfAcquireSpinLock(&
				Extension->ControlLock);
			* (PSERIAL_HANDFLOW )(Irp->AssociatedIrp).SystemBuffer =
				Extension->HandFlow;
			#line 1805
			KfReleaseSpinLock(& Extension->ControlLock, OldIrql);
			#line 1807
			break;
		}
		#line 1810
	case 0x0000001b << 16 | 0 << 14 | 25 << 2 | 0:
			#line 1810
			;
		{
			SERIAL_IOCTL_SYNC S ;
			PSERIAL_HANDFLOW HandFlow
				= (Irp->AssociatedIrp).SystemBuffer;
			#line 1820
			if(((IrpSp->Parameters).DeviceIoControl).InputBufferLength
				< sizeof(SERIAL_HANDFLOW ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 1833
			if(HandFlow->ControlHandShake & (ULONG )0x7fffff84)
			{
				Status = (NTSTATUS )0xC000000DL;
				break;
			}
			#line 1840
			if(HandFlow->FlowReplace & (ULONG )0x7fffff20)
			{
				Status = (NTSTATUS )0xC000000DL;
				break;
			}
			#line 1851
			if((HandFlow->ControlHandShake & (ULONG )0x03) == (ULONG
				)0x03)
			{
				Status = (NTSTATUS )0xC000000DL;
				break;
			}
			#line 1864
			if(HandFlow->XonLimit < 0 || (ULONG )HandFlow->XonLimit
				> Extension->BufferSize)
			{
				Status = (NTSTATUS )0xC000000DL;
				break;
			}
			#line 1872
			if(HandFlow->XoffLimit < 0 || (ULONG
				)HandFlow->XoffLimit > Extension->BufferSize)
			{
				Status = (NTSTATUS )0xC000000DL;
				break;
			}
			#line 1880
			S.Extension = Extension;
			S.Data = HandFlow;
			#line 1886
			* & OldIrql = KfAcquireSpinLock(&
				Extension->ControlLock);
			#line 1894
			if(Extension->EscapeChar)
			{
				if(HandFlow->FlowReplace & (ULONG )0x04)
				{
					Status = (NTSTATUS )0xC000000DL;
					#line 1902
					KfReleaseSpinLock(&
						Extension->ControlLock,
						OldIrql);
					#line 1903
					break;
				}
			}
			#line 1909
			KeSynchronizeExecution(Extension->Interrupt,
				SerialSetHandFlow, & S);
			#line 1918
			KfReleaseSpinLock(& Extension->ControlLock, OldIrql);
			#line 1920
			break;
		}
		#line 1923
	case 0x0000001b << 16 | 0 << 14 | 26 << 2 | 0:
			#line 1923
			;
		{
			SERIAL_IOCTL_SYNC S ;
			#line 1927
			if(((IrpSp->Parameters).DeviceIoControl).OutputBufferLength
				< sizeof(ULONG ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 1935
			(Irp->IoStatus).Information = sizeof(ULONG );
			#line 1937
			S.Extension = Extension;
			S.Data = (Irp->AssociatedIrp).SystemBuffer;
			#line 1943
			* & OldIrql = KfAcquireSpinLock(&
				Extension->ControlLock);
			KeSynchronizeExecution(Extension->Interrupt,
				SerialGetModemUpdate, & S);
			#line 1954
			KfReleaseSpinLock(& Extension->ControlLock, OldIrql);
			#line 1956
			break;
		}
		#line 1959
	case 0x0000001b << 16 | 0 << 14 | 30 << 2 | 0:
			#line 1959
			;
		{
			ULONG ModemControl ;
			if(((IrpSp->Parameters).DeviceIoControl).OutputBufferLength
				< sizeof(ULONG ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 1970
			(Irp->IoStatus).Information = sizeof(ULONG );
			(Irp->IoStatus).Status = (NTSTATUS )0x00000000L;
			#line 1977
			ModemControl = READ_PORT_UCHAR(Extension->Controller +
				(ULONG )(0x04 * 1));
			ModemControl &= (ULONG )0x00000001 | (ULONG )0x00000002;
			#line 1981
			* (PULONG )(Irp->AssociatedIrp).SystemBuffer =
				ModemControl;
			break;
		}
		#line 1986
	case 0x0000001b << 16 | 0 << 14 | 27 << 2 | 0:
			#line 1986
			;
		{
			SERIAL_IOCTL_SYNC S ;
			#line 1990
			if(((IrpSp->Parameters).DeviceIoControl).OutputBufferLength
				< sizeof(SERIAL_STATUS ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 1998
			(Irp->IoStatus).Information = sizeof(SERIAL_STATUS );
			#line 2000
			S.Extension = Extension;
			S.Data = (Irp->AssociatedIrp).SystemBuffer;
			#line 2008
			IoAcquireCancelSpinLock(& OldIrql);
			#line 2010
			KeSynchronizeExecution(Extension->Interrupt,
				SerialGetCommStatus, & S);
			#line 2016
			IoReleaseCancelSpinLock(OldIrql);
			#line 2018
			break;
		}
		#line 2021
	case 0x0000001b << 16 | 0 << 14 | 29 << 2 | 0:
			#line 2021
			;
		{
			#line 2024
			if(((IrpSp->Parameters).DeviceIoControl).OutputBufferLength
				< sizeof(SERIAL_COMMPROP ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 2037
			SerialGetProperties(Extension,
				(Irp->AssociatedIrp).SystemBuffer);
			#line 2042
			(Irp->IoStatus).Information = sizeof(SERIAL_COMMPROP );
			(Irp->IoStatus).Status = (NTSTATUS )0x00000000L;
			#line 2045
			break;
		}
	case 0x0000001b << 16 | 0 << 14 | 28 << 2 | 0:
			#line 2047
			;
		{
			PSERIAL_XOFF_COUNTER Xc
				= (Irp->AssociatedIrp).SystemBuffer;
			if(((IrpSp->Parameters).DeviceIoControl).InputBufferLength
				< sizeof(SERIAL_XOFF_COUNTER ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 2059
			if(Xc->Counter <= 0)
			{
				Status = (NTSTATUS )0xC000000DL;
				break;
			}
			#line 2070
			(Irp->IoStatus).Information = 0;
			#line 2076
			return SerialStartOrQueue(Extension, Irp, &
				Extension->WriteQueue, &
				Extension->CurrentWriteIrp, SerialStartWrite);
		}
		#line 2085
	case 0x0000001b << 16 | 0 << 14 | 31 << 2 | 0:
			#line 2085
			;
		{
			PUCHAR escapeChar = (Irp->AssociatedIrp).SystemBuffer;
			SERIAL_IOCTL_SYNC S ;
			#line 2094
			if(((IrpSp->Parameters).DeviceIoControl).InputBufferLength
				< sizeof(UCHAR ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 2105
			* & OldIrql = KfAcquireSpinLock(&
				Extension->ControlLock);
			if(* escapeChar)
			{
				#line 2115
				if(* escapeChar ==
					(Extension->SpecialChars).XoffChar || *
					escapeChar ==
					(Extension->SpecialChars).XonChar ||
					(Extension->HandFlow).FlowReplace &
					(ULONG )0x04)
				{
					#line 2119
					Status = (NTSTATUS )0xC000000DL;
					#line 2124
					KfReleaseSpinLock(&
						Extension->ControlLock,
						OldIrql);
					#line 2125
					break;
				}
			}
			#line 2131
			S.Extension = Extension;
			S.Data = (Irp->AssociatedIrp).SystemBuffer;
			#line 2134
			KeSynchronizeExecution(Extension->Interrupt,
				SerialSetEscapeChar, Irp);
			#line 2143
			KfReleaseSpinLock(& Extension->ControlLock, OldIrql);
			#line 2145
			break;
		}
		#line 2148
	case 0x0000001b << 16 | 0 << 14 | 32 << 2 | 0:
			#line 2148
			;
		{
			if(((IrpSp->Parameters).DeviceIoControl).OutputBufferLength
				< sizeof(ULONG ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 2158
			(Irp->IoStatus).Information = sizeof(ULONG );
			(Irp->IoStatus).Status = (NTSTATUS )0x00000000L;
			#line 2161
			* (PULONG )(Irp->AssociatedIrp).SystemBuffer = 0;
			#line 2163
			break;
		}
	case 0x0000001b << 16 | 0 << 14 | 35 << 2 | 0:
			#line 2165
			;
		{
			if(((IrpSp->Parameters).DeviceIoControl).OutputBufferLength
				< sizeof(SERIALPERF_STATS ))
			{
				Status = (NTSTATUS )0xC0000023L;
				break;
			}
			#line 2174
			(Irp->IoStatus).Information = sizeof(SERIALPERF_STATS );
			(Irp->IoStatus).Status = (NTSTATUS )0x00000000L;
			#line 2177
			KeSynchronizeExecution(Extension->Interrupt,
				SerialGetStats, Irp);
			#line 2183
			break;
		}
	case 0x0000001b << 16 | 0 << 14 | 36 << 2 | 0:
			#line 2185
			;
		{
			KeSynchronizeExecution(Extension->Interrupt,
				SerialClearStats, Extension);
			#line 2192
			break;
		}
	default :
			#line 2194
			;
		{
			Status = (NTSTATUS )0xC000000DL;
			break;
		}
	}
	#line 2201
	DoneWithIoctl:
		#line 2201
		;
	#line 2203
	(Irp->IoStatus).Status = Status;
	#line 2208
	do
	{
		#line 2208
		;
	}
	while(0);
	{
		#line 2210
		IofCompleteRequest(Irp, 0);
		#line 2210
		SerialIRPEpilogue(Extension);
	}
	#line 2210
	;
	#line 2212
	return Status;
}

#line 2216
void SerialGetProperties(PSERIAL_DEVICE_EXTENSION Extension , PSERIAL_COMMPROP
	Properties )
{
	#line 2242
	;
	#line 2247
	memset(Properties, 0, sizeof(SERIAL_COMMPROP ));
	#line 2249
	Properties->PacketLength = sizeof(SERIAL_COMMPROP );
	Properties->PacketVersion = 2;
	Properties->ServiceMask = (ULONG )0x00000001;
	Properties->MaxTxQueue = 0;
	Properties->MaxRxQueue = 0;
	#line 2255
	Properties->MaxBaud = (ULONG )0x10000000;
	Properties->SettableBaud = Extension->SupportedBauds;
	#line 2258
	Properties->ProvSubType = (ULONG )0x00000001;
	Properties->ProvCapabilities = (ULONG )0x0001 | (ULONG )0x0002 | (ULONG
		)0x0004 | (ULONG )0x0008 | (ULONG )0x0010 | (ULONG )0x0020 |
		(ULONG )0x0040 | (ULONG )0x0080;
	#line 2267
	Properties->SettableParams = (ULONG )0x0001 | (ULONG )0x0002 | (ULONG
		)0x0004 | (ULONG )0x0008 | (ULONG )0x0010 | (ULONG )0x0020 |
		(ULONG )0x0040;
	#line 2276
	Properties->SettableData = (USHORT )0x0001 | (USHORT )0x0002 | (USHORT
		)0x0004 | (USHORT )0x0008;
	#line 2280
	Properties->SettableStopParity = (USHORT )0x0001 | (USHORT )0x0002 |
		(USHORT )0x0004 | (USHORT )0x0100 | (USHORT )0x0200 | (USHORT
		)0x0400 | (USHORT )0x0800 | (USHORT )0x1000;
	#line 2288
	Properties->CurrentTxQueue = 0;
	Properties->CurrentRxQueue = Extension->BufferSize;
}

#line 2294
NTSTATUS SerialInternalIoControl(PDEVICE_OBJECT PDevObj , PIRP PIrp )
{
	#line 2321
	NTSTATUS status ;
	#line 2327
	PIO_STACK_LOCATION pIrpStack ;
	#line 2333
	PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
	#line 2339
	KIRQL OldIrql ;
	#line 2341
	NTSTATUS prologueStatus ;
	#line 2343
	SYSTEM_POWER_STATE cap ;
	#line 2345
	;
	#line 2348
	if((prologueStatus = SerialIRPPrologue(PIrp, pDevExt)) != (NTSTATUS
		)0x00000000L)
	{
		{
			#line 2350
			IofCompleteRequest(PIrp, 0);
			#line 2350
			SerialIRPEpilogue(pDevExt);
		}
		#line 2350
		;
		return prologueStatus;
	}
	#line 2354
	do
	{
		#line 2354
		;
	}
	while(0);
	#line 2356
	if(SerialCompleteIfError(PDevObj, PIrp) != (NTSTATUS )0x00000000L)
	{
		#line 2357
		return (NTSTATUS )0xC0000120L;
	}
	#line 2360
	pIrpStack = ((PIrp->Tail).Overlay).CurrentStackLocation;
	(PIrp->IoStatus).Information = 0L;
	status = (NTSTATUS )0x00000000L;
	#line 2364
	switch(((pIrpStack->Parameters).DeviceIoControl).IoControlCode)
	{
		#line 2370
	case 0x0000001b << 16 | 0 << 14 | 1 << 2 | 0:
			#line 2370
			;
		#line 2375
		for(cap = PowerSystemSleeping1; cap < PowerSystemMaximum; cap++)
		{
			#line 2376
			if((pDevExt->DeviceStateMap)[cap] >= PowerDeviceD0 &&
				(pDevExt->DeviceStateMap)[cap] <=
				pDevExt->DeviceWake)
			{
				#line 2378
				break;
			}
		}
		#line 2382
		if(cap < PowerSystemMaximum)
		{
			#line 2383
			pDevExt->SendWaitWake = 1;
			status = (NTSTATUS )0x00000000L;
		}
		else
		{
			#line 2386
			status = (NTSTATUS )0xC00000BBL;
		}
		break;
		#line 2390
	case 0x0000001b << 16 | 0 << 14 | 2 << 2 | 0:
			#line 2390
			;
		pDevExt->SendWaitWake = 0;
		#line 2393
		if(pDevExt->PendingWakeIrp != (void *  )0)
		{
			#line 2394
			IoCancelIrp(pDevExt->PendingWakeIrp);
		}
		#line 2397
		status = (NTSTATUS )0x00000000L;
		break;
		#line 2411
	case 0x0000001b << 16 | 0 << 14 | 3 << 2 | 0:
			#line 2411
			;
	case 0x0000001b << 16 | 0 << 14 | 4 << 2 | 0:
			#line 2412
			;
		{
			#line 2413
			SERIAL_BASIC_SETTINGS basic ;
			PSERIAL_BASIC_SETTINGS pBasic ;
			SHORT AppropriateDivisor ;
			SERIAL_IOCTL_SYNC S ;
			#line 2418
			if(((pIrpStack->Parameters).DeviceIoControl).IoControlCode
				== (0x0000001b << 16 | 0 << 14 | 3 << 2 | 0))
			{
				#line 2426
				if(((pIrpStack->Parameters).DeviceIoControl).OutputBufferLength
					< sizeof(SERIAL_BASIC_SETTINGS ))
				{
					#line 2428
					status = (NTSTATUS )0xC0000023L;
					break;
				}
				#line 2438
				memset(& basic, 0, sizeof(SERIAL_BASIC_SETTINGS
					));
				basic.TxFifo = 1;
				basic.RxFifo = (UCHAR )0x00;
				#line 2443
				(PIrp->IoStatus).Information =
					sizeof(SERIAL_BASIC_SETTINGS );
				#line 2444
				pBasic = (PSERIAL_BASIC_SETTINGS
					)(PIrp->AssociatedIrp).SystemBuffer;
				#line 2451
				memcpy(& pBasic->Timeouts, & pDevExt->Timeouts,
					sizeof(SERIAL_TIMEOUTS ));
				#line 2454
				memcpy(& pBasic->HandFlow, & pDevExt->HandFlow,
					sizeof(SERIAL_HANDFLOW ));
				pBasic->RxFifo = pDevExt->RxFifoTrigger;
				pBasic->TxFifo = pDevExt->TxFifoAmount;
				#line 2463
				pBasic = & basic;
			}
			else
			{
				#line 2465
				if(((pIrpStack->Parameters).DeviceIoControl).InputBufferLength
					< sizeof(SERIAL_BASIC_SETTINGS ))
				{
					#line 2467
					status = (NTSTATUS )0xC0000023L;
					break;
				}
				#line 2471
				pBasic = (PSERIAL_BASIC_SETTINGS
					)(PIrp->AssociatedIrp).SystemBuffer;
			}
			* & OldIrql = KfAcquireSpinLock(& pDevExt->ControlLock);
			#line 2481
			memcpy(& pDevExt->Timeouts, & pBasic->Timeouts,
				sizeof(SERIAL_TIMEOUTS ));
			#line 2487
			S.Extension = pDevExt;
			S.Data = & pBasic->HandFlow;
			KeSynchronizeExecution(pDevExt->Interrupt,
				SerialSetHandFlow, & S);
			#line 2492
			if(pDevExt->FifoPresent)
			{
				#line 2493
				pDevExt->TxFifoAmount = pBasic->TxFifo;
				pDevExt->RxFifoTrigger = (UCHAR )pBasic->RxFifo;
				#line 2496
				do
				{
					#line 2496
					WRITE_PORT_UCHAR(pDevExt->Controller +
						(ULONG )(0x02 * 1), (UCHAR )0);
				}
				while(0);
				#line 2497
				READ_PORT_UCHAR(pDevExt->Controller + (ULONG
					)(0x00 * 1));
				#line 2501
				do
				{
					#line 2501
					WRITE_PORT_UCHAR(pDevExt->Controller +
						(ULONG )(0x02 * 1), (UCHAR
						)((UCHAR )0x01 |
						pDevExt->RxFifoTrigger | (UCHAR
						)0x02 | (UCHAR )0x04));
				}
				while(0);
			}
			else
			{
				#line 2503
				pDevExt->TxFifoAmount = (pDevExt->RxFifoTrigger
					= 0);
				#line 2504
				do
				{
					#line 2504
					WRITE_PORT_UCHAR(pDevExt->Controller +
						(ULONG )(0x02 * 1), (UCHAR )0);
				}
				while(0);
			}
			#line 2508
			KfReleaseSpinLock(& pDevExt->ControlLock, OldIrql);
			#line 2511
			break;
		}
		#line 2514
	default :
			#line 2514
			;
		status = (NTSTATUS )0xC000000DL;
		break;
	}
	#line 2520
	(PIrp->IoStatus).Status = status;
	#line 2522
	do
	{
		#line 2522
		;
	}
	while(0);
	{
		#line 2523
		IofCompleteRequest(PIrp, 0);
		#line 2523
		SerialIRPEpilogue(pDevExt);
	}
	#line 2523
	;
	#line 2525
	return status;
}

#line 16 "C:/NTDDK/inc/stddef.h"

#pragma once
#line 77
typedef int ;

#line 86
typedef unsigned int ;

#line 95
typedef int ;

#line 105
typedef unsigned int ;

#line 112
typedef unsigned short ;

#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"

#pragma once
#line 32

#pragma pack(push, 8)
#line 72
typedef enum _EXCEPTION_DISPOSITION ;

#line 89
struct _EXCEPTION_RECORD ;

#line 90
struct _CONTEXT ;

#line 155

#pragma pack(pop)
#line 25 "C:/NTDDK/inc/ntdef.h"

#pragma once
#line 15 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"

#pragma once
#line 66
typedef wchar_t ;

#line 67
typedef wchar_t ;

#line 127 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long ;

#line 25 "C:/NTDDK/inc/basetsd.h"

#pragma once
#line 36
typedef int ;

#line 37
typedef int ;

#line 43
typedef unsigned int ;

#line 44
typedef unsigned int ;

#line 45
typedef unsigned int ;

#line 84
typedef int ;

#line 85
typedef unsigned int ;

typedef long ;

#line 88
typedef unsigned long ;

#line 248
typedef unsigned short ;

#line 249
typedef short ;

#line 250
typedef unsigned long ;

#line 288
typedef ULONG_PTR ;

#line 289
typedef LONG_PTR ;

#line 295
typedef ULONG_PTR ;

#line 301
typedef __int64 ;

#line 302
typedef __int64 ;

#line 309
typedef unsigned __int64 ;

#line 310
typedef unsigned __int64 ;

#line 311
typedef unsigned __int64 ;

#line 217 "C:/NTDDK/inc/ntdef.h"
typedef void ;

#line 218
typedef void ;

#line 266
typedef char ;

#line 267
typedef short ;

#line 268
typedef long ;

#line 276
typedef wchar_t ;

#line 282
typedef WCHAR ;

#line 283
typedef WCHAR ;

#line 284
typedef const WCHAR ;

#line 285
typedef WCHAR ;

#line 286
typedef WCHAR ;

typedef const WCHAR ;

#line 293
typedef CHAR ;

#line 294
typedef CHAR ;

typedef const CHAR ;

#line 297
typedef CHAR ;

#line 298
typedef CHAR ;

#line 299
typedef const CHAR ;

#line 321
typedef char ;

#line 322
typedef unsigned char ;

#line 326
typedef LPSTR ;

#line 327
typedef LPSTR ;

#line 328
typedef LPCSTR ;

#line 337
typedef double ;

typedef struct _QUAD ;

#line 349
typedef SHORT ;

#line 350
typedef LONG ;

#line 351
typedef QUAD ;

#line 360
typedef unsigned char ;

#line 361
typedef unsigned short ;

#line 362
typedef unsigned long ;

#line 363
typedef QUAD ;

#line 369
typedef UCHAR ;

#line 370
typedef USHORT ;

#line 371
typedef ULONG ;

#line 372
typedef UQUAD ;

#line 378
typedef signed char ;

#line 379
typedef SCHAR ;

#line 394
typedef void ;

#line 400
typedef HANDLE ;

#line 406
typedef UCHAR ;

#line 407
typedef USHORT ;

#line 408
typedef ULONG ;

#line 414
typedef LONG ;

#line 478
typedef char ;

#line 479
typedef short ;

#line 480
typedef ULONG ;

typedef CCHAR ;

#line 483
typedef CSHORT ;

#line 484
typedef CLONG ;

#line 492
typedef ULONG ;

#line 493
typedef PULONG ;

#line 494
typedef USHORT ;

#line 500
typedef ULONG ;

#line 501
typedef ULONG ;

#line 508
typedef LONG ;

typedef NTSTATUS ;

#line 602
typedef struct _FLOAT128 ;

#line 607
typedef FLOAT128 ;

#line 621
typedef __int64 ;

#line 622
typedef unsigned __int64 ;

#line 639
typedef LONGLONG ;

#line 640
typedef ULONGLONG ;

#line 644
typedef LONGLONG ;

#line 649
typedef union _LARGE_INTEGER ;

#line 662
typedef LARGE_INTEGER ;

#line 668
typedef union _ULARGE_INTEGER ;

#line 681
typedef ULARGE_INTEGER ;

#line 690
typedef struct _LUID ;

#line 696
typedef ULONGLONG ;

#line 697
typedef DWORDLONG ;

#line 707
typedef LARGE_INTEGER ;

#line 831

#pragma warning(push)

#pragma warning(disable:4035)
__inline ULONGLONG __stdcall Int64ShllMod32___5(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 842
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    
		};
}

#line 845
__inline LONGLONG __stdcall Int64ShraMod32___5(LONGLONG Value , ULONG ShiftCount
	)
{
	#line 852
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    
		};
}

#line 855
__inline ULONGLONG __stdcall Int64ShrlMod32___5(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 862
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    
		};
}


#pragma warning(pop)
#line 956
typedef enum _EVENT_TYPE ;

#line 965
typedef enum _TIMER_TYPE ;

#line 974
typedef enum _WAIT_TYPE ;

#line 983
typedef CHAR ;

#line 984
typedef const char ;

#line 991
typedef struct _STRING ;

#line 999
typedef STRING ;

typedef STRING ;

#line 1002
typedef PSTRING ;

typedef STRING ;

#line 1005
typedef PSTRING ;

#line 1011
typedef struct _CSTRING ;

#line 1016
typedef CSTRING ;

#line 1019
typedef STRING ;

#line 1020
typedef PSTRING ;

#line 1027
typedef struct _UNICODE_STRING ;

#line 1036
typedef UNICODE_STRING ;

#line 1037
typedef const UNICODE_STRING ;

#line 1046
typedef UCHAR ;

#line 1047
typedef BOOLEAN ;

#line 1057
typedef struct _LIST_ENTRY ;

#line 1067
typedef struct _SINGLE_LIST_ENTRY ;

#line 1078
typedef struct LIST_ENTRY32 ;

#line 1082
typedef LIST_ENTRY32 ;

typedef struct LIST_ENTRY64 ;

#line 1088
typedef LIST_ENTRY64 ;

#line 1127
typedef struct _STRING32 ;

#line 1132
typedef STRING32 ;

typedef STRING32 ;

#line 1135
typedef UNICODE_STRING32 ;

typedef STRING32 ;

#line 1138
typedef ANSI_STRING32 ;

#line 1141
typedef struct _STRING64 ;

#line 1146
typedef STRING64 ;

typedef STRING64 ;

#line 1149
typedef UNICODE_STRING64 ;

typedef STRING64 ;

#line 1152
typedef ANSI_STRING64 ;

#line 1173
typedef struct _OBJECT_ATTRIBUTES ;

#line 1181
typedef OBJECT_ATTRIBUTES ;

#line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID ;

#line 70
typedef GUID ;

#line 75
typedef const GUID ;

#line 81
typedef GUID ;

#line 82
typedef IID ;

#line 85
typedef GUID ;

#line 86
typedef CLSID ;

#line 89
typedef GUID ;

#line 90
typedef FMTID ;

#line 16 "C:/NTDDK/inc/string.h"

#pragma once
#line 1233 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECTID ;

#line 1288
struct _CONTEXT ;

#line 1289
struct _EXCEPTION_RECORD ;

typedef EXCEPTION_DISPOSITION ;

#line 1306
typedef UCHAR ;

typedef KIRQL ;

#line 1316
typedef enum _NT_PRODUCT_TYPE ;

#line 1329
typedef enum _SUITE_TYPE ;

#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD ;

#line 76
typedef struct _ETHREAD ;

#line 77
typedef struct _EPROCESS ;

#line 78
typedef struct _PEB ;

#line 79
typedef struct _KINTERRUPT ;

#line 80
typedef struct _IO_TIMER ;

#line 81
typedef struct _OBJECT_TYPE ;

#line 82
typedef struct _CALLBACK_OBJECT ;

#line 83
typedef struct _DEVICE_HANDLER_OBJECT ;

#line 84
typedef struct _BUS_HANDLER ;

#line 143
typedef union _SLIST_HEADER ;

#line 204
typedef CCHAR ;

typedef enum _MODE ;

#line 222
struct _KAPC ;

typedef void ;

#line 232
typedef void ;

#line 242
typedef void ;

#line 248
typedef BOOLEAN ;

#line 254
typedef BOOLEAN ;

#line 265
typedef struct _KAPC ;

#line 292
struct _KDPC ;

typedef void ;

#line 351
typedef enum _KDPC_IMPORTANCE ;

#line 361
typedef struct _KDPC ;

#line 377
typedef PVOID ;

typedef void ;

#line 392
typedef struct _KIPI_COUNTS ;

#line 443
typedef struct _MDL ;

#line 532
typedef PVOID ;

#line 538
typedef PVOID ;

#line 544
typedef PVOID ;

typedef ULONG ;

#line 547
typedef ACCESS_MASK ;

#line 597
typedef struct _GENERIC_MAPPING ;

#line 603
typedef GENERIC_MAPPING ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES ;

#line 622
typedef LUID_AND_ATTRIBUTES ;

#line 623
typedef LUID_AND_ATTRIBUTES_ARRAY ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 642 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACL ;

#line 649
typedef ACL ;

#line 681
typedef struct _PRIVILEGE_SET ;

#line 735
typedef enum _SECURITY_IMPERSONATION_LEVEL ;

#line 753
typedef BOOLEAN ;

#line 762
typedef struct _SECURITY_QUALITY_OF_SERVICE ;

#line 774
typedef struct _SE_IMPERSONATION_STATE ;

#line 782
typedef ULONG ;

#line 809
typedef ULONG ;

#line 810
typedef KAFFINITY ;

#line 816
typedef LONG ;

#line 824
typedef ULONG_PTR ;

#line 825
typedef KSPIN_LOCK ;

#line 833
typedef void ;

#line 842
typedef enum _KPROFILE_SOURCE ;

#line 1079
typedef NTSTATUS ;

#line 1088
typedef struct _RTL_QUERY_REGISTRY_TABLE ;

#line 1952

#pragma warning(push)

#pragma warning(disable:4035)
#line 2019

#pragma warning(pop)
#line 2214
typedef struct _TIME_FIELDS ;

#line 2224
typedef TIME_FIELDS ;

#line 2499
typedef struct _RTL_BITMAP ;

#line 2503
typedef RTL_BITMAP ;

#line 2627
typedef struct _RTL_BITMAP_RUN ;

#line 2633
typedef RTL_BITMAP_RUN ;

#line 2886
typedef struct _RTL_RANGE ;

#line 2924
typedef struct _RTL_RANGE_LIST ;

#line 2950
typedef struct _RANGE_LIST_ITERATOR ;

#line 3019
typedef BOOLEAN ;

#line 3155
typedef struct _OSVERSIONINFOA ;

#line 3164
typedef struct _OSVERSIONINFOW ;

#line 3177
typedef OSVERSIONINFOA ;

#line 3178
typedef POSVERSIONINFOA ;

#line 3179
typedef LPOSVERSIONINFOA ;

#line 3182
typedef struct _OSVERSIONINFOEXA ;

#line 3195
typedef struct _OSVERSIONINFOEXW ;

#line 3213
typedef OSVERSIONINFOEXA ;

#line 3214
typedef POSVERSIONINFOEXA ;

#line 3215
typedef LPOSVERSIONINFOEXA ;

#line 3648
typedef struct _IO_STATUS_BLOCK ;

#line 3669
typedef void ;

#line 3685
typedef enum _FILE_INFORMATION_CLASS ;

#line 3731
typedef struct _FILE_BASIC_INFORMATION ;

#line 3739
typedef struct _FILE_STANDARD_INFORMATION ;

#line 3747
typedef struct _FILE_POSITION_INFORMATION ;

#line 3751
typedef struct _FILE_ALIGNMENT_INFORMATION ;

#line 3755
typedef struct _FILE_NAME_INFORMATION ;

#line 3760
typedef struct _FILE_NETWORK_OPEN_INFORMATION ;

#line 3770
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION ;

#line 3775
typedef struct _FILE_DISPOSITION_INFORMATION ;

#line 3779
typedef struct _FILE_END_OF_FILE_INFORMATION ;

#line 3784
typedef struct _FILE_FULL_EA_INFORMATION ;

#line 3798
typedef enum _FSINFOCLASS ;

#line 3810
typedef struct _FILE_FS_DEVICE_INFORMATION ;

#line 3820
typedef union _FILE_SEGMENT_ELEMENT ;

#line 3829
typedef enum _INTERFACE_TYPE ;

#line 3854
typedef enum _DMA_WIDTH ;

#line 3865
typedef enum _DMA_SPEED ;

#line 3879
typedef void ;

#line 3880
typedef void ;

#line 3888
typedef enum _BUS_DATA_TYPE ;

#line 3910
typedef struct _IO_ERROR_LOG_PACKET ;

#line 3931
typedef struct _IO_ERROR_LOG_MESSAGE ;

#line 4074
typedef struct _KEY_BASIC_INFORMATION ;

#line 4081
typedef struct _KEY_NODE_INFORMATION ;

#line 4091
typedef struct _KEY_FULL_INFORMATION ;

#line 4106
typedef struct _KEY_NAME_INFORMATION ;

#line 4112
typedef enum _KEY_INFORMATION_CLASS ;

#line 4122
typedef struct _KEY_WRITE_TIME_INFORMATION ;

#line 4126
typedef enum _KEY_SET_INFORMATION_CLASS ;

#line 4134
typedef struct _KEY_VALUE_BASIC_INFORMATION ;

#line 4141
typedef struct _KEY_VALUE_FULL_INFORMATION ;

#line 4151
typedef struct _KEY_VALUE_PARTIAL_INFORMATION ;

#line 4158
typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ;

#line 4164
typedef struct _KEY_VALUE_ENTRY ;

#line 4171
typedef enum _KEY_VALUE_INFORMATION_CLASS ;

#line 4210
typedef struct _OBJECT_NAME_INFORMATION ;

#line 4221
typedef enum _SECTION_INHERIT ;

#line 4294
typedef struct _CLIENT_ID ;

#line 4298
typedef CLIENT_ID ;

#line 4315
typedef struct _NT_TIB ;

#line 4327
typedef NT_TIB ;

#line 4332
typedef enum _PROCESSINFOCLASS ;

#line 4366
typedef enum _THREADINFOCLASS ;

#line 4395
typedef struct _PROCESS_WS_WATCH_INFORMATION ;

#line 4405
typedef struct _PROCESS_BASIC_INFORMATION ;

#line 4413
typedef PROCESS_BASIC_INFORMATION ;

#line 4422
typedef struct _PROCESS_DEVICEMAP_INFORMATION ;

#line 4440
typedef struct _PROCESS_SESSION_INFORMATION ;

#line 4454
typedef struct _QUOTA_LIMITS ;

#line 4462
typedef QUOTA_LIMITS ;

#line 4472
typedef struct _IO_COUNTERS ;

#line 4480
typedef IO_COUNTERS ;

#line 4488
typedef struct _VM_COUNTERS ;

#line 4501
typedef VM_COUNTERS ;

#line 4508
typedef struct _POOLED_USAGE_AND_LIMITS ;

#line 4519
typedef POOLED_USAGE_AND_LIMITS ;

#line 4528
typedef struct _PROCESS_ACCESS_TOKEN ;

#line 4555
typedef struct _KERNEL_USER_TIMES ;

#line 4561
typedef KERNEL_USER_TIMES ;

#line 4587
typedef enum _SYSTEM_POWER_STATE ;

#line 4598
typedef enum  {
	PowerActionNone = 0,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
} ;

typedef enum _DEVICE_POWER_STATE ;

#line 4618
typedef union _POWER_STATE ;

#line 4623
typedef enum _POWER_STATE_TYPE ;

#line 4654
typedef ULONG ;

typedef enum  {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
} ;

#line 4663
typedef enum  {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation
} ;

#line 4690
typedef ULONG ;

typedef LONG ;

#line 4693
typedef ULONG ;

#line 4719
typedef union _MCI_STATS ;

#line 4978
typedef struct _KPCR ;

#line 5006
typedef KPCR ;

#line 5012
typedef struct _KFLOATING_SAVE ;

#line 5153
typedef enum _INTERLOCKED_RESULT ;

#line 5252

#pragma warning(disable:4035)
#line 6994
typedef struct _KSYSTEM_TIME ;

#line 7014

#pragma warning(push)

#pragma warning(disable:4164)
#line 7019

#pragma function(_enable)
#line 7020

#pragma function(_disable)
#line 7024

#pragma warning(pop)
#line 7085
typedef struct _FLOATING_SAVE_AREA ;

#line 7097
typedef FLOATING_SAVE_AREA ;

#line 7109
typedef struct _CONTEXT ;

#line 7197
typedef CONTEXT ;

#line 7826
typedef void ;

#line 7850
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ;

#line 7899
typedef struct _KUSER_SHARED_DATA ;

#line 8123
typedef enum _CM_SERVICE_NODE_TYPE ;

#line 8132
typedef enum _CM_SERVICE_LOAD_TYPE ;

#line 8140
typedef enum _CM_ERROR_CONTROL_TYPE ;

#line 8172
typedef int ;

#line 8198
typedef enum _CM_SHARE_DISPOSITION ;

#line 8211
typedef PVOID ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST ;

#line 8443
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR ;

#line 8454
typedef struct _CM_RESOURCE_LIST ;

#line 8471
typedef struct _DEVICE_FLAGS ;

#line 8485
typedef struct _CM_COMPONENT_INFORMATION ;

#line 8503
typedef struct _CM_ROM_BLOCK ;

#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 8518 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_INT13_DRIVE_PARAMETER ;

#line 8532
typedef struct _CM_MCA_POS_DATA ;

#line 8544
typedef struct _EISA_MEMORY_TYPE ;

#line 8554
typedef struct _EISA_MEMORY_CONFIGURATION ;

#line 8567
typedef struct _EISA_IRQ_DESCRIPTOR ;

#line 8575
typedef struct _EISA_IRQ_CONFIGURATION ;

#line 8585
typedef struct _DMA_CONFIGURATION_BYTE0 ;

#line 8592
typedef struct _DMA_CONFIGURATION_BYTE1 ;

#line 8599
typedef struct _EISA_DMA_CONFIGURATION ;

#line 8609
typedef struct _EISA_PORT_DESCRIPTOR ;

#line 8616
typedef struct _EISA_PORT_CONFIGURATION ;

#line 8628
typedef struct _CM_EISA_SLOT_INFORMATION ;

#line 8644
typedef struct _CM_EISA_FUNCTION_INFORMATION ;

#line 8678
typedef struct _CM_PNP_BIOS_DEVICE_NODE ;

#line 8692
typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8761 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_SCSI_DEVICE_DATA ;

#line 8775
typedef struct _CM_VIDEO_DEVICE_DATA ;

#line 8785
typedef struct _CM_SONIC_DEVICE_DATA ;

#line 8796
typedef struct _CM_SERIAL_DEVICE_DATA ;

#line 8810
typedef struct _CM_MONITOR_DEVICE_DATA ;

#line 8844
typedef struct _CM_FLOPPY_DEVICE_DATA ;

#line 8881
typedef struct _CM_KEYBOARD_DEVICE_DATA ;

#line 8893
typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA ;

#line 8905
typedef struct _CM_PCCARD_DEVICE_DATA ;

#line 8944
typedef struct _IO_RESOURCE_DESCRIPTOR ;

#line 9027
typedef struct _IO_RESOURCE_LIST ;

#line 9036
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST ;

#line 9065
typedef struct _EXCEPTION_RECORD ;

#line 9074
typedef EXCEPTION_RECORD ;

typedef struct _EXCEPTION_RECORD32 ;

#line 9085
typedef struct _EXCEPTION_RECORD64 ;

#line 9099
typedef struct _EXCEPTION_POINTERS ;

#line 9111
typedef enum _CONFIGURATION_TYPE ;

#line 9161
typedef enum _KINTERRUPT_MODE ;

#line 9170
typedef enum _KWAIT_REASON ;

#line 9207
typedef struct _DISPATCHER_HEADER ;

#line 9217
typedef struct _KWAIT_BLOCK ;

#line 9230
typedef void ;

#line 9244
typedef struct _KDEVICE_QUEUE ;

#line 9252
typedef struct _KDEVICE_QUEUE_ENTRY ;

#line 9263
typedef struct _KEVENT ;

#line 9271
typedef BOOLEAN ;

#line 9281
typedef struct _KMUTANT ;

#line 9294
typedef struct _KSEMAPHORE ;

#line 9304
typedef struct _KTIMER ;

#line 9899
typedef enum _KBUGCHECK_BUFFER_DUMP_STATE ;

#line 9907
typedef void ;

#line 9914
typedef struct _KBUGCHECK_CALLBACK_RECORD ;

#line 10002
typedef void ;

#line 10020
typedef LOGICAL ;

#line 10037
typedef void ;

#line 10053
typedef enum _MEMORY_CACHING_TYPE_ORIG ;

#line 10057
typedef enum _MEMORY_CACHING_TYPE ;

#line 10087
typedef struct _DBGKD_DEBUG_DATA_HEADER64 ;

#line 10115
typedef enum _POOL_TYPE ;

#line 10195
typedef enum _EX_POOL_PRIORITY ;

#line 10247
typedef struct _FAST_MUTEX ;

#line 10574
typedef PVOID ;

#line 10582
typedef void ;

#line 10588
typedef struct _GENERAL_LOOKASIDE ;

#line 10619
typedef struct _NPAGED_LOOKASIDE_LIST ;

#line 10729
typedef struct _PAGED_LOOKASIDE_LIST ;

#line 10882
typedef enum _WORK_QUEUE_TYPE ;

#line 10889
typedef void ;

#line 10895
typedef struct _WORK_QUEUE_ITEM ;

#line 10926
typedef struct _ZONE_SEGMENT_HEADER ;

#line 10931
typedef struct _ZONE_HEADER ;

#line 11156
typedef ULONG_PTR ;

#line 11157
typedef ERESOURCE_THREAD ;

typedef struct _OWNER_ENTRY ;

#line 11168
typedef struct _ERESOURCE ;

#line 11197
typedef struct _RESOURCE_HASH_ENTRY ;

#line 11204
typedef struct _RESOURCE_PERFORMANCE_DATA ;

#line 11429
typedef struct _CALLBACK_OBJECT ;

typedef void ;

#line 11474
typedef GUID ;

#line 11862
typedef enum _MM_SYSTEM_SIZE ;

#line 11884
typedef enum _LOCK_OPERATION ;

#line 11970
typedef enum _MM_PAGE_PRIORITY ;

#line 11999
typedef struct _PHYSICAL_MEMORY_RANGE ;

#line 12385
typedef NTSTATUS ;

#line 12389
typedef NTSTATUS ;

#line 12399
struct _DRIVER_OBJECT ;

#line 12411
typedef enum _SECURITY_OPERATION_CODE ;

#line 12426
typedef struct _SECURITY_SUBJECT_CONTEXT ;

#line 12448
typedef struct _INITIAL_PRIVILEGE_SET ;

#line 12462
typedef struct _ACCESS_STATE ;

#line 12571
typedef void ;

#line 12585
typedef void ;

#line 12602
typedef struct _IMAGE_INFO ;

#line 12620
typedef void ;

#line 12859
typedef NTSTATUS ;

#line 12878
typedef enum _IO_QUERY_DEVICE_DATA_FORMAT ;

#line 12890
typedef enum _CREATE_FILE_TYPE ;

#line 12905
struct _DEVICE_DESCRIPTION ;

#line 12906
struct _DEVICE_OBJECT ;

#line 12907
struct _DMA_ADAPTER ;

#line 12908
struct _DRIVER_OBJECT ;

#line 12909
struct _DRIVE_LAYOUT_INFORMATION ;

#line 12910
struct _DISK_PARTITION ;

#line 12911
struct _FILE_OBJECT ;

#line 12912
struct _IRP ;

#line 12913
struct _SCSI_REQUEST_BLOCK ;

#line 12919
typedef void ;

#line 12932
typedef void ;

#line 12943
typedef NTSTATUS ;

#line 12955
typedef void ;

#line 12968
typedef void ;

#line 12979
typedef NTSTATUS ;

#line 12990
typedef void ;

#line 13001
typedef void ;

#line 13011
typedef NTSTATUS ;

#line 13025
typedef BOOLEAN ;

#line 13038
typedef BOOLEAN ;

#line 13051
typedef BOOLEAN ;

#line 13068
typedef BOOLEAN ;

#line 13078
typedef BOOLEAN ;

#line 13092
typedef BOOLEAN ;

#line 13106
typedef BOOLEAN ;

#line 13118
typedef BOOLEAN ;

#line 13127
typedef BOOLEAN ;

#line 13141
typedef BOOLEAN ;

#line 13161
typedef void ;

#line 13167
typedef void ;

#line 13179
typedef void ;

#line 13193
typedef BOOLEAN ;

#line 13207
typedef BOOLEAN ;

#line 13219
typedef BOOLEAN ;

#line 13227
typedef BOOLEAN ;

#line 13239
typedef BOOLEAN ;

#line 13253
typedef NTSTATUS ;

#line 13262
typedef NTSTATUS ;

#line 13275
typedef NTSTATUS ;

#line 13282
typedef NTSTATUS ;

#line 13289
typedef BOOLEAN ;

#line 13304
typedef BOOLEAN ;

#line 13319
typedef BOOLEAN ;

#line 13327
typedef BOOLEAN ;

#line 13336
typedef BOOLEAN ;

#line 13350
typedef struct _FAST_IO_DISPATCH ;

#line 13386
typedef enum _IO_ALLOCATION_ACTION ;

#line 13396
typedef IO_ALLOCATION_ACTION ;

#line 13410
typedef struct _IO_SECURITY_CONTEXT ;

#line 13434
typedef struct _VPB ;

#line 13482
typedef struct _ADAPTER_OBJECT ;

#line 13491
typedef struct _WAIT_CONTEXT_BLOCK ;

#line 13503
typedef struct _CONTROLLER_OBJECT ;

#line 13537
typedef struct _DEVICE_OBJECT ;

#line 13575
typedef struct _DEVICE_OBJECT ;

#line 13578
struct _DEVICE_OBJECT_POWER_EXTENSION ;

typedef struct _DEVOBJ_EXTENSION ;

#line 13608
typedef struct _DRIVER_EXTENSION ;

#line 13645
typedef struct _DRIVER_OBJECT ;

#line 13706
typedef struct _DRIVER_OBJECT ;

#line 13715
typedef struct _SECTION_OBJECT_POINTERS ;

#line 13720
typedef SECTION_OBJECT_POINTERS ;

#line 13726
typedef struct _IO_COMPLETION_CONTEXT ;

#line 13759
typedef struct _FILE_OBJECT ;

#line 13788
typedef struct _FILE_OBJECT ;

#line 13828
typedef struct _IRP ;

#line 14078
typedef NTSTATUS ;

#line 14163
typedef enum _DEVICE_RELATION_TYPE ;

#line 14171
typedef struct _DEVICE_RELATIONS ;

#line 14176
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE ;

#line 14185
typedef struct _INTERFACE ;

#line 14196
typedef struct _DEVICE_CAPABILITIES ;

#line 14229
typedef struct _POWER_SEQUENCE ;

#line 14235
typedef enum  {
	BusQueryDeviceID = 0,
	BusQueryHardwareIDs = 1,
	BusQueryCompatibleIDs = 2,
	BusQueryInstanceID = 3,
	BusQueryDeviceSerialNumber = 4
} ;

typedef ULONG ;

#line 14252
typedef enum  {
	DeviceTextDescription = 0,
	DeviceTextLocationInformation = 1
} ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 14615 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SHARE_ACCESS ;

#line 14635
typedef struct _CONFIGURATION_INFORMATION ;

#line 14848
typedef struct _BOOTDISK_INFORMATION ;

#line 15754
typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK ;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK ;

#line 15764
typedef struct _IO_REMOVE_LOCK_DBG_BLOCK ;

#line 15777
typedef struct _IO_REMOVE_LOCK ;

#line 16009
typedef struct _IO_WORKITEM ;

typedef void ;

#line 16100
typedef enum  {
	DevicePropertyDeviceDescription,
	DevicePropertyHardwareID,
	DevicePropertyCompatibleIDs,
	DevicePropertyBootConfiguration,
	DevicePropertyBootConfigurationTranslated,
	DevicePropertyClassName,
	DevicePropertyClassGuid,
	DevicePropertyDriverKeyName,
	DevicePropertyManufacturer,
	DevicePropertyFriendlyName,
	DevicePropertyLocationInformation,
	DevicePropertyPhysicalDeviceObjectName,
	DevicePropertyBusTypeGuid,
	DevicePropertyLegacyBusType,
	DevicePropertyBusNumber,
	DevicePropertyEnumeratorName,
	DevicePropertyAddress,
	DevicePropertyUINumber
} ;

typedef BOOLEAN ;

#line 16129
typedef struct _DMA_ADAPTER ;

#line 16135
typedef ULONG ;

#line 16148
typedef struct _PNP_BUS_INFORMATION ;

#line 16162
typedef struct _LEGACY_BUS_INFORMATION ;

#line 16168
typedef struct _BUS_INTERFACE_STANDARD ;

#line 16190
typedef BOOLEAN ;

#line 16194
typedef NTSTATUS ;

#line 16203
typedef NTSTATUS ;

#line 16206
typedef NTSTATUS ;

#line 16210
typedef NTSTATUS ;

#line 16214
typedef NTSTATUS ;

#line 16218
typedef void ;

#line 16222
typedef NTSTATUS ;

#line 16227
typedef void ;

#line 16231
typedef struct _ACPI_INTERFACE_STANDARD ;

#line 16255
typedef enum _ACPI_REG_TYPE ;

#line 16268
typedef USHORT ;

#line 16272
typedef void ;

#line 16278
typedef struct ACPI_REGS_INTERFACE_STANDARD ;

#line 16300
typedef struct  {
	PVOID LinkNode ;
	ULONG StaticVector ;
	UCHAR Flags ;
} ;

#line 16314
typedef NTSTATUS ;

#line 16329
typedef NTSTATUS ;

#line 16336
typedef void ;

#line 16343
typedef struct _INT_ROUTE_INTERFACE_STANDARD ;

#line 16366
typedef struct _IO_ASSIGNED_RESOURCES ;

#line 16490
typedef enum _IO_NOTIFICATION_EVENT_CATEGORY ;

#line 16504
typedef NTSTATUS ;

#line 16537
typedef void ;

#line 16573
typedef enum _ARBITER_ACTION ;

#line 16586
typedef struct _ARBITER_CONFLICT_INFO ;

#line 16608
typedef struct _ARBITER_PARAMETERS ;

#line 16719
typedef enum _ARBITER_REQUEST_SOURCE ;

#line 16731
typedef enum _ARBITER_RESULT ;

#line 16761
typedef struct _ARBITER_LIST_ENTRY ;

#line 16832
typedef NTSTATUS ;

#line 16853
typedef struct _ARBITER_INTERFACE ;

#line 16880
typedef enum _RESOURCE_TRANSLATION_DIRECTION ;

#line 16889
typedef NTSTATUS ;

#line 16901
typedef NTSTATUS ;

#line 16915
typedef struct _TRANSLATOR_INTERFACE ;

#line 16931
typedef NTSTATUS ;

#line 16945
typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE ;

#line 16959
typedef struct _PLUGPLAY_NOTIFICATION_HEADER ;

#line 16972
typedef struct _HWPROFILE_CHANGE_NOTIFICATION ;

#line 16986
typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION ;

#line 17006
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION ;

#line 17026
typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION ;

#line 17054
typedef struct _DEVICE_DESCRIPTION ;

#line 17086
typedef BOOLEAN ;

#line 17333
typedef void ;

#line 17339
typedef struct _DEVICE_CONTROL_CONTEXT ;

#line 17349
typedef PBUS_HANDLER ;

#line 17355
typedef void ;

#line 17365
typedef enum _HAL_QUERY_INFORMATION_CLASS ;

#line 17381
typedef enum _HAL_SET_INFORMATION_CLASS ;

#line 17388
typedef NTSTATUS ;

#line 17405
typedef NTSTATUS ;

#line 17420
typedef void ;

#line 17429
typedef void ;

#line 17438
typedef NTSTATUS ;

#line 17447
typedef NTSTATUS ;

#line 17456
typedef NTSTATUS ;

#line 17466
typedef NTSTATUS ;

#line 17475
typedef NTSTATUS ;

#line 17486
typedef struct _PM_DISPATCH_TABLE ;

#line 17492
typedef NTSTATUS ;

#line 17505
typedef struct _DMA_ADAPTER ;

#line 17520
typedef NTSTATUS ;

#line 17543
typedef BOOLEAN ;

#line 17553
typedef NTSTATUS ;

#line 17566
typedef void ;

#line 17572
typedef void ;

#line 17578
typedef BOOLEAN ;

#line 17588
typedef struct  {
	ULONG Version ;
	pHalQuerySystemInformation HalQuerySystemInformation ;
	pHalSetSystemInformation HalSetSystemInformation ;
	pHalQueryBusSlots HalQueryBusSlots ;
	ULONG Spare1 ;
	pHalExamineMBR HalExamineMBR ;
	pHalIoAssignDriveLetters HalIoAssignDriveLetters ;
	pHalIoReadPartitionTable HalIoReadPartitionTable ;
	pHalIoSetPartitionInformation HalIoSetPartitionInformation ;
	pHalIoWritePartitionTable HalIoWritePartitionTable ;
	pHalHandlerForBus HalReferenceHandlerForBus ;
	pHalReferenceBusHandler HalReferenceBusHandler ;
	pHalReferenceBusHandler HalDereferenceBusHandler ;
	pHalInitPnpDriver HalInitPnpDriver ;
	pHalInitPowerManagement HalInitPowerManagement ;
	pHalGetDmaAdapter HalGetDmaAdapter ;
	pHalGetInterruptTranslator HalGetInterruptTranslator ;
} ;

#line 17650
typedef struct _HAL_BUS_INFORMATION ;

#line 17658
typedef struct _HAL_PROFILE_SOURCE_INFORMATION ;

#line 17665
typedef struct _HAL_PROFILE_SOURCE_INTERVAL ;

#line 17671
typedef enum _HAL_DISPLAY_BIOS_INFORMATION ;

#line 17678
typedef struct _HAL_POWER_INFORMATION ;

#line 17683
typedef struct _HAL_PROCESSOR_SPEED_INFO ;

#line 17688
typedef struct _HAL_CALLBACKS ;

#line 17694
typedef struct _HAL_PROCESSOR_FEATURE ;

#line 17706
typedef union _MCI_ADDR ;

#line 17716
typedef enum  {
	HAL_MCE_RECORD,
	HAL_MCA_RECORD
} ;

#line 17726
typedef struct _MCA_EXCEPTION ;

#line 17752
typedef void ;

#line 17762
typedef struct _MCA_DRIVER_INFO ;

#line 17772
typedef struct _SCATTER_GATHER_ELEMENT ;

#line 17778

#pragma warning(disable:4200)
#line 17779
typedef struct _SCATTER_GATHER_LIST ;

#line 17784

#pragma warning(default:4200)
#line 17788
typedef struct _DMA_OPERATIONS ;

typedef struct _DMA_ADAPTER ;

#line 17797
typedef void ;

#line 17801
typedef PVOID ;

#line 17808
typedef void ;

#line 17816
typedef NTSTATUS ;

#line 17824
typedef BOOLEAN ;

#line 17833
typedef void ;

#line 17837
typedef void ;

#line 17843
typedef PHYSICAL_ADDRESS ;

#line 17852
typedef ULONG ;

#line 17856
typedef ULONG ;

#line 17860
typedef void ;

#line 17868
typedef NTSTATUS ;

#line 17880
typedef void ;

#line 17887
typedef struct _DMA_OPERATIONS ;

#line 18235
typedef void ;

#line 18321
typedef struct _OBJECT_HANDLE_INFORMATION ;

#line 18402
typedef struct _PCI_SLOT_NUMBER ;

#line 18418
typedef struct _PCI_COMMON_CONFIG ;

#line 18591
typedef struct _PCI_CAPABILITIES_HEADER ;

#line 18600
typedef struct _PCI_PMC ;

#line 18618
typedef struct _PCI_PMCSR ;

#line 18628
typedef struct _PCI_PMCSR_BSE ;

#line 18635
typedef struct _PCI_PM_CAPABILITY ;

#line 18679
typedef struct _PCI_AGP_CAPABILITY ;

#line 18720
typedef struct _PCI_MSI_CAPABILITY ;

#line 18946
typedef void ;

#line 18954
typedef void ;

#line 18963
typedef void ;

#line 18975
typedef struct _PCIBUSDATA ;

#line 18986
typedef ULONG ;

#line 18995
typedef void ;

#line 19000
typedef void ;

#line 19006
typedef struct _PCI_BUS_INTERFACE_STANDARD ;

#line 19028
typedef BOOLEAN ;

#line 19043
typedef struct _PCI_DEVICE_PRESENT_INTERFACE ;

#line 127 "C:/NTDDK/inc/ntddser.h"
typedef struct _SERIALPERF_STATS ;

#line 136
typedef struct _SERIALCONFIG ;

#line 154
typedef struct _SERIAL_LINE_CONTROL ;

#line 160
typedef struct _SERIAL_TIMEOUTS ;

#line 175
typedef struct _SERIAL_QUEUE_SIZE ;

#line 185
typedef struct _SERIAL_BAUD_RATE ;

#line 247
typedef struct _SERIAL_CHARS ;

#line 284
typedef struct _SERIAL_HANDFLOW ;

#line 340
typedef struct _SERIAL_BASIC_SETTINGS ;

#line 353
typedef struct _SERIAL_STATUS ;

#line 433
typedef struct _SERIAL_XOFF_COUNTER ;

#line 539
typedef struct _SERIAL_COMMPROP ;

#line 631
typedef struct _SERENUM_PORT_DESC ;

#line 652
typedef UCHAR ;

#line 658
typedef void ;

#line 665
typedef enum _SERENUM_PORTION ;

#line 671
typedef struct _SERENUM_PORT_PARAMETERS ;

#line 28 "C:/NTDDK/inc/ddk/wdm/wmilib.h"

#pragma once
#line 38
typedef struct  {
	LPCGUID Guid ;
	ULONG InstanceCount ;
	ULONG Flags ;
} ;

#line 45
typedef NTSTATUS ;

#line 101
typedef NTSTATUS ;

#line 162
typedef NTSTATUS ;

#line 206
typedef NTSTATUS ;

#line 253
typedef NTSTATUS ;

#line 306
typedef enum  {
	WmiEventControl,
	WmiDataBlockControl
} ;

#line 312
typedef NTSTATUS ;

#line 355
typedef struct _WMILIB_CONTEXT ;

#line 411
typedef enum  {
	IrpProcessed,
	IrpNotCompleted,
	IrpNotWmi,
	IrpForward
} ;

#line 13 "C:/NTDDK/inc/wmidata.h"
typedef struct _MSWmi_MofData ;

#line 51
typedef struct _MSWmi_ProviderInfo ;

#line 66
typedef struct _MSWmi_PnPDeviceId ;

#line 83
typedef struct _MSWmi_PnPInstanceNames ;

#line 105
typedef struct _MSSmBios_RawSMBiosTables ;

#line 147
typedef struct _MSPower_DeviceEnable ;

#line 165
typedef struct _MSPower_DeviceWakeEnable ;

#line 182
typedef struct _MSNdis_NetworkAddress ;

#line 199
typedef struct _MSNdis_NetworkShortAddress ;

#line 216
typedef struct _MSNdis_NetworkLinkSpeed ;

#line 239
typedef struct _MSNdis_EnumerateAdapter ;

#line 256
typedef struct _MSNdis_NotifyAdapterRemoval ;

#line 273
typedef struct _MSNdis_NotifyAdapterArrival ;

#line 291
typedef struct _MSNdis_NdisEnumerateVc ;

#line 307
typedef struct _MSNdis_NotifyVcRemoval ;

#line 323
typedef struct _MSNdis_NotifyVcArrival ;

#line 338
typedef struct _MSNdis_HardwareStatus ;

#line 356
typedef struct _MSNdis_MediaSupported ;

#line 378
typedef struct _MSNdis_MediaInUse ;

#line 400
typedef struct _MSNdis_MaximumLookahead ;

#line 418
typedef struct _MSNdis_MaximumFrameSize ;

#line 436
typedef struct _MSNdis_LinkSpeed ;

#line 454
typedef struct _MSNdis_TransmitBufferSpace ;

#line 472
typedef struct _MSNdis_ReceiveBufferSpace ;

#line 490
typedef struct _MSNdis_TransmitBlockSize ;

#line 508
typedef struct _MSNdis_ReceiveBlockSize ;

#line 526
typedef struct _MSNdis_VendorID ;

#line 544
typedef struct _MSNdis_VendorDescription ;

#line 561
typedef struct _MSNdis_CurrentPacketFilter ;

#line 579
typedef struct _MSNdis_CurrentLookahead ;

#line 597
typedef struct _MSNdis_DriverVersion ;

#line 615
typedef struct _MSNdis_MaximumTotalSize ;

#line 633
typedef struct _MSNdis_MacOptions ;

#line 651
typedef struct _MSNdis_MediaConnectStatus ;

#line 669
typedef struct _MSNdis_MaximumSendPackets ;

#line 687
typedef struct _MSNdis_VendorDriverVersion ;

#line 705
typedef struct _MSNdis_TransmitsOk ;

#line 723
typedef struct _MSNdis_ReceivesOk ;

#line 741
typedef struct _MSNdis_TransmitsError ;

#line 759
typedef struct _MSNdis_ReceiveError ;

#line 777
typedef struct _MSNdis_ReceiveNoBuffer ;

#line 795
typedef struct _MSNdis_CoHardwareStatus ;

#line 813
typedef struct _MSNdis_CoMediaSupported ;

#line 835
typedef struct _MSNdis_CoMediaInUse ;

#line 857
typedef struct _MSNdis_CoLinkSpeed ;

#line 875
typedef struct _MSNdis_CoVendorId ;

#line 893
typedef struct _MSNdis_CoVendorDescription ;

#line 910
typedef struct _MSNdis_CoDriverVersion ;

#line 928
typedef struct _MSNdis_CoMacOptions ;

#line 946
typedef struct _MSNdis_CoMediaConnectStatus ;

#line 964
typedef struct _MSNdis_CoVendorDriverVersion ;

#line 982
typedef struct _MSNdis_CoMinimumLinkSpeed ;

#line 1000
typedef struct _MSNdis_CoTransmitPdusOk ;

#line 1018
typedef struct _MSNdis_CoReceivePdusOk ;

#line 1036
typedef struct _MSNdis_CoTransmitPduErrors ;

#line 1054
typedef struct _MSNdis_CoReceivePduErrors ;

#line 1072
typedef struct _MSNdis_CoReceivePdusNoBuffer ;

#line 1090
typedef struct _MSNdis_AtmSupportedVcRates ;

#line 1113
typedef struct _MSNdis_AtmSupportedServiceCategory ;

#line 1131
typedef struct _MSNdis_AtmSupportedAalTypes ;

#line 1149
typedef struct _MSNdis_AtmHardwareCurrentAddress ;

#line 1167
typedef struct _MSNdis_AtmMaxActiveVcs ;

#line 1185
typedef struct _MSNdis_AtmMaxActiveVciBits ;

#line 1203
typedef struct _MSNdis_AtmMaxActiveVpiBits ;

#line 1221
typedef struct _MSNdis_AtmMaxAal0PacketSize ;

#line 1239
typedef struct _MSNdis_AtmMaxAal1PacketSize ;

#line 1257
typedef struct _MSNdis_AtmMaxAal34PacketSize ;

#line 1275
typedef struct _MSNdis_AtmMaxAal5PacketSize ;

#line 1293
typedef struct _MSNdis_AtmReceiveCellsOk ;

#line 1311
typedef struct _MSNdis_AtmTransmitCellsOk ;

#line 1329
typedef struct _MSNdis_AtmReceiveCellsDropped ;

#line 1347
typedef struct _MSNdis_EthernetPermanentAddress ;

#line 1365
typedef struct _MSNdis_EthernetCurrentAddress ;

#line 1383
typedef struct _MSNdis_EthernetMulticastList ;

#line 1405
typedef struct _MSNdis_EthernetMaximumMulticastListSize ;

#line 1423
typedef struct _MSNdis_EthernetMacOptions ;

#line 1441
typedef struct _MSNdis_EthernetReceiveErrorAlignment ;

#line 1459
typedef struct _MSNdis_EthernetOneTransmitCollision ;

#line 1477
typedef struct _MSNdis_EthernetMoreTransmitCollisions ;

#line 1495
typedef struct _MSNdis_TokenRingPermanentAddress ;

#line 1513
typedef struct _MSNdis_TokenRingCurrentAddress ;

#line 1531
typedef struct _MSNdis_TokenRingCurrentFunctional ;

#line 1549
typedef struct _MSNdis_TokenRingCurrentGroup ;

#line 1567
typedef struct _MSNdis_TokenRingLastOpenStatus ;

#line 1585
typedef struct _MSNdis_TokenRingCurrentRingStatus ;

#line 1603
typedef struct _MSNdis_TokenRingCurrentRingState ;

#line 1621
typedef struct _MSNdis_TokenRingLineErrors ;

#line 1639
typedef struct _MSNdis_TokenRingLostFrames ;

#line 1657
typedef struct _MSNdis_FddiLongPermanentAddress ;

#line 1675
typedef struct _MSNdis_FddiLongCurrentAddress ;

#line 1693
typedef struct _MSNdis_FddiLongMulticastList ;

#line 1715
typedef struct _MSNdis_FddiLongMaximumListSize ;

#line 1733
typedef struct _MSNdis_FddiShortPermanentAddress ;

#line 1751
typedef struct _MSNdis_FddiShortCurrentAddress ;

#line 1769
typedef struct _MSNdis_FddiShortMulticastList ;

#line 1791
typedef struct _MSNdis_FddiShortMaximumListSize ;

#line 1809
typedef struct _MSNdis_FddiAttachmentType ;

#line 1827
typedef struct _MSNdis_FddiUpstreamNodeLong ;

#line 1845
typedef struct _MSNdis_FddiDownstreamNodeLong ;

#line 1863
typedef struct _MSNdis_FddiFrameErrors ;

#line 1881
typedef struct _MSNdis_FddiFramesLost ;

#line 1899
typedef struct _MSNdis_FddiRingManagmentState ;

#line 1917
typedef struct _MSNdis_FddiLctFailures ;

#line 1935
typedef struct _MSNdis_FddiLemRejects ;

#line 1953
typedef struct _MSNdis_FddiLConnectionState ;

#line 1972
typedef struct _MSNdis_StatusResetStart ;

#line 1988
typedef struct _MSNdis_StatusResetEnd ;

#line 2004
typedef struct _MSNdis_StatusMediaConnect ;

#line 2020
typedef struct _MSNdis_StatusMediaDisconnect ;

#line 2035
typedef struct _MSNdis_StatusMediaSpecificIndication ;

#line 2057
typedef struct _MSNdis_StatusLinkSpeedChange ;

#line 2075
typedef struct _MSNdis_StatusProtocolBind ;

#line 2092
typedef struct _MSNdis_StatusProtocolUnbind ;

#line 2109
typedef struct _KEYBOARD_PORT_WMI_STD_DATA ;

#line 2152
typedef struct _POINTER_PORT_WMI_STD_DATA ;

#line 2205
typedef struct _MSMouse_ClassInformation ;

#line 2223
typedef struct _MSKeyboard_ClassInformation ;

#line 2241
typedef struct _MSAcpi_ThermalZoneTemperature ;

#line 2304
typedef struct _WMI_DISK_GEOMETRY ;

#line 2342
typedef struct _WMI_DISK_PERFORMANCE ;

#line 2415
typedef struct _MSDiskDriver_Performance ;

#line 2437
typedef struct _STORAGE_FAILURE_PREDICT_STATUS ;

#line 2460
typedef struct _STORAGE_FAILURE_PREDICT_DATA ;

#line 2483
typedef struct _STORAGE_FAILURE_PREDICT_EVENT ;

#line 2513
typedef struct _STORAGE_FAILURE_PREDICT_FUNCTION ;

#line 2528
typedef struct _MSIde_PortDeviceInfo ;

#line 2556
typedef struct _MSSerial_PortName ;

#line 2573
typedef struct _SERIAL_WMI_COMM_DATA ;

#line 2723
typedef struct _SERIAL_WMI_HW_DATA ;

#line 2770
typedef struct _SERIAL_WMI_PERF_DATA ;

#line 2813
typedef struct _SERIAL_WMI_COMMPROP ;

#line 2920
typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS ;

#line 2943
typedef struct _PARALLEL_WMI_LOG_INFO ;

#line 3041
typedef struct _REDBOOK_WMI_STD_DATA ;

#line 3094
typedef struct _REDBOOK_WMI_PERF_DATA ;

#line 3137
typedef struct _RegisteredGuids ;

#line 475 "serial.h"
typedef struct _CONFIG_DATA ;

#line 509
typedef struct _SERIAL_CISR_SW ;

#line 520
typedef struct _SERIAL_FIRMWARE_DATA ;

#line 576
typedef struct _SERIAL_DEVICE_STATE ;

#line 646
typedef struct _SERIAL_DEVICE_EXTENSION ;

#line 1808
typedef struct _SERIAL_MULTIPORT_DISPATCH ;

#line 2157
typedef enum _SERIAL_MEM_COMPARES ;

#line 2164
typedef struct _SERIAL_LIST_DATA ;

#line 2169
typedef struct _SERIAL_GLOBALS ;

#line 2180
typedef struct _SERIAL_USER_DATA ;

#line 2206
typedef struct _SERIAL_PTR_CTX ;

#line 20 "serialp.h"
typedef NTSTATUS ;

#line 26
typedef void ;

#line 835
typedef struct _SERIAL_UPDATE_CHAR ;

#line 846
typedef struct _SERIAL_IOCTL_SYNC ;

#line 28 "isr.c"

#pragma alloc_text(PAGESER, SerialPutChar)
#line 29

#pragma alloc_text(PAGESER, SerialProcessLSR)
#line 33
BOOLEAN SerialCIsrSw(PKINTERRUPT InterruptObject , PVOID Context )
{
	#line 59
	PSERIAL_CISR_SW csw = (PSERIAL_CISR_SW )Context;
	#line 61
	return (* csw->IsrFunc)(InterruptObject, csw->Context);
}

#line 66
BOOLEAN SerialSharerIsr(PKINTERRUPT InterruptObject , PVOID Context )
{
	#line 100
	BOOLEAN servicedAnInterrupt = 0;
	BOOLEAN thisPassServiced ;
	PLIST_ENTRY interruptEntry = ((PLIST_ENTRY )Context)->Flink;
	PLIST_ENTRY firstInterruptEntry = Context;
	#line 105
	if(firstInterruptEntry->Flink == firstInterruptEntry)
	{
		#line 106
		return 0;
	}
	#line 109
	do
	{
		thisPassServiced = 0;
		do
		{
			PSERIAL_DEVICE_EXTENSION extension
				= (SERIAL_DEVICE_EXTENSION *  )((PCHAR
				)interruptEntry - (ULONG_PTR )(&
				((SERIAL_DEVICE_EXTENSION * 
				)0)->TopLevelSharers));
			#line 120
			thisPassServiced |=
				(extension->TopLevelOurIsr)(InterruptObject,
				extension->TopLevelOurIsrContext);
			#line 125
			servicedAnInterrupt |= thisPassServiced;
			interruptEntry = interruptEntry->Flink;
		}
		while(interruptEntry != firstInterruptEntry);
	}
	while(thisPassServiced);
	#line 132
	return servicedAnInterrupt;
}

#line 136
BOOLEAN SerialIndexedMultiportIsr(PKINTERRUPT InterruptObject , PVOID Context )
{
	#line 171
	BOOLEAN servicedAnInterrupt = 0;
	BOOLEAN thisStatusReadServiced ;
	PSERIAL_MULTIPORT_DISPATCH dispatch = Context;
	ULONG whichPort ;
	UCHAR statusRegister ;
	#line 177
	do
	{
		thisStatusReadServiced = 0;
		statusRegister = READ_PORT_UCHAR(dispatch->InterruptStatus);
		#line 184
		whichPort = statusRegister & 0x07;
		#line 193
		if(statusRegister != 0xff)
		{
			if((dispatch->Extensions)[whichPort])
			{
				thisStatusReadServiced =
					SerialISR(InterruptObject,
					(dispatch->Extensions)[whichPort]);
				#line 202
				servicedAnInterrupt |= thisStatusReadServiced;
			}
		}
	}
	while(thisStatusReadServiced);
	#line 210
	return servicedAnInterrupt;
}

#line 214
BOOLEAN SerialBitMappedMultiportIsr(PKINTERRUPT InterruptObject , PVOID Context
	)
{
	#line 250
	BOOLEAN servicedAnInterrupt = 0;
	PSERIAL_MULTIPORT_DISPATCH dispatch = Context;
	ULONG whichPort ;
	UCHAR statusRegister ;
	#line 255
	do
	{
		statusRegister = READ_PORT_UCHAR(dispatch->InterruptStatus);
		#line 260
		if(dispatch->MaskInverted)
		{
			#line 261
			statusRegister = ~ statusRegister;
		}
		statusRegister &= dispatch->UsablePortMask;
		#line 265
		if(statusRegister)
		{
			if(statusRegister & 0x0f)
			{
				if(statusRegister & 0x03)
				{
					if(statusRegister & 1)
					{
						whichPort = 0;
					}
					else
					{
						whichPort = 1;
					}
				}
				else
				{
					#line 283
					if(statusRegister & 0x04)
					{
						whichPort = 2;
					}
					else
					{
						whichPort = 3;
					}
				}
			}
			else
			{
				#line 297
				if(statusRegister & 0x30)
				{
					if(statusRegister & 0x10)
					{
						whichPort = 4;
					}
					else
					{
						whichPort = 5;
					}
				}
				else
				{
					#line 311
					if(statusRegister & 0x40)
					{
						whichPort = 6;
					}
					else
					{
						whichPort = 7;
					}
				}
			}
			#line 325
			if((dispatch->Extensions)[whichPort])
			{
				if(SerialISR(InterruptObject,
					(dispatch->Extensions)[whichPort]))
				{
					#line 332
					servicedAnInterrupt = 1;
				}
			}
		}
	}
	while(statusRegister);
	#line 342
	return servicedAnInterrupt;
}

#line 346
BOOLEAN SerialISR(PKINTERRUPT InterruptObject , PVOID Context )
{
	#line 382
	PSERIAL_DEVICE_EXTENSION Extension = Context;
	#line 389
	UCHAR InterruptIdReg ;
	#line 395
	BOOLEAN ServicedAnInterrupt ;
	#line 397
	UCHAR tempLSR ;
	#line 399
	InterruptObject;
	#line 409
	InterruptIdReg = READ_PORT_UCHAR(Extension->Controller + (ULONG )(0x02 *
		1));
	#line 416
	InterlockedIncrement(& Extension->DpcCount);
	;
	#line 419
	if(InterruptIdReg & 0x01)
	{
		ServicedAnInterrupt = 0;
	}
	else
	{
		#line 423
		if(! Extension->DeviceIsOpened || Extension->PowerState !=
			PowerDeviceD0)
		{
			#line 434
			ServicedAnInterrupt = 1;
			do
			{
				InterruptIdReg &= ~ 0xc0;
				switch(InterruptIdReg)
				{
				case 0x06:
						#line 440
						;
					{
						READ_PORT_UCHAR(Extension->Controller
							+ (ULONG )(0x05 * 1));
						#line 443
						break;
					}
					#line 447
				case 0x04:
						#line 447
						;
				case 0x0c:
						#line 448
						;
					{
						#line 451
						READ_PORT_UCHAR(Extension->Controller
							+ (ULONG )(0x00 * 1));
						#line 452
						break;
					}
					#line 456
				case 0x02:
						#line 456
						;
					{
						#line 465
						Extension->HoldingEmpty = 1;
						break;
					}
					#line 470
				case 0x00:
						#line 470
						;
					{
						READ_PORT_UCHAR(Extension->Controller
							+ (ULONG )(0x06 * 1));
						#line 473
						break;
					}
					#line 477
				default :
						#line 477
						;
					{
						;
						break;
					}
				}
			}
			while(! ((InterruptIdReg =
				READ_PORT_UCHAR(Extension->Controller + (ULONG
				)(0x02 * 1))) & 0x01));
		}
		else
		{
			#line 491
			ServicedAnInterrupt = 1;
			do
			{
				#line 498
				InterruptIdReg &= 0x06 | 0x04 | 0x0c | 0x02 |
					0x00;
				#line 511
				switch(InterruptIdReg)
				{
				case 0x06:
						#line 513
						;
					{
						SerialProcessLSR(Extension);
						#line 517
						break;
					}
					#line 521
				case 0x04:
						#line 521
						;
				case 0x0c:
						#line 522
						;
					{
						#line 531
						UCHAR ReceivedChar ;
						#line 533
						do
						{
							ReceivedChar =
								READ_PORT_UCHAR(
								Extension->Controller
								+ (ULONG )(0x00
								* 1));
							#line 537
							(Extension->PerfStats).ReceivedCount
								++;
							#line 538
							(Extension->WmiPerfData)
								.ReceivedCount++
								;
							#line 540
							ReceivedChar &=
								Extension->ValidDataMask
								;
							#line 542
							if(! ReceivedChar &&
								(Extension->HandFlow
								).FlowReplace &
								(ULONG )0x08)
							{
	#line 552
	goto ReceiveDoLineStatus;
							}
							#line 556
							if((Extension->HandFlow)
								.FlowReplace &
								(ULONG )0x01 &&
								(ReceivedChar ==
								(Extension->SpecialChars
								).XonChar ||
								ReceivedChar ==
								(Extension->SpecialChars
								).XoffChar))
							{
	#line 568
	if(ReceivedChar == (Extension->SpecialChars).XoffChar)
	{
		#line 571
		Extension->TXHolding |= (ULONG )0x08;
		#line 573
		if(((Extension->HandFlow).FlowReplace & (ULONG )0xc0) == (ULONG
			)0xc0)
		{
			#line 577
			SerialInsertQueueDpc(& Extension->StartTimerLowerRTSDpc,
				(void *  )0, (void *  )0, Extension)
				? Extension->CountOfTryingToLowerRTS++ : 0;
		}
	}
	else
	{
		#line 589
		if(Extension->TXHolding & (ULONG )0x08)
		{
			#line 602
			Extension->TXHolding &= ~ (ULONG )0x08;
		}
	}
	#line 608
	goto ReceiveDoLineStatus;
							}
							#line 618
							if(Extension->IsrWaitMask
								)
							{
	#line 620
	if(Extension->IsrWaitMask & 0x0001)
	{
		#line 623
		Extension->HistoryMask |= 0x0001;
	}
	#line 627
	if(Extension->IsrWaitMask & 0x0002 &&
		(Extension->SpecialChars).EventChar == ReceivedChar)
	{
		#line 632
		Extension->HistoryMask |= 0x0002;
	}
	#line 636
	if(Extension->IrpMaskLocation && Extension->HistoryMask)
	{
		#line 639
		* Extension->IrpMaskLocation = Extension->HistoryMask;
		#line 641
		Extension->IrpMaskLocation = (void *  )0;
		Extension->HistoryMask = 0;
		#line 644
		((Extension->CurrentWaitIrp)->IoStatus).Information =
			sizeof(ULONG );
		SerialInsertQueueDpc(& Extension->CommWaitDpc, (void *  )0,
			(void *  )0, Extension);
	}
							}
							#line 657
							SerialPutChar(Extension,
								ReceivedChar);
							#line 671
							if(Extension->EscapeChar
								&&
								Extension->EscapeChar
								== ReceivedChar)
							{
	#line 675
	SerialPutChar(Extension, (UCHAR )0x00);
							}
							#line 683
							ReceiveDoLineStatus:
	#line 683
	;
							#line 685
							if(! ((tempLSR =
								SerialProcessLSR(
								Extension)) &
								0x01))
							{
	#line 693
	break;
							}
							#line 697
							if(tempLSR & ~ (0x20 |
								0x40 | 0x01) &&
								Extension->EscapeChar
								)
							{
	#line 706
	break;
							}
						}
						while(1);
						#line 711
						break;
					}
					#line 715
				case 0x02:
						#line 715
						;
					{
						doTrasmitStuff:
							#line 717
							;
						Extension->HoldingEmpty = 1;
						#line 720
						if(Extension->WriteLength ||
							Extension->TransmitImmediate
							||
							Extension->SendXoffChar
							||
							Extension->SendXonChar)
						{
							#line 745
							Extension->EmptiedTransmit
								= 1;
							#line 755
							if((Extension->HandFlow)
								.ControlHandShake
								& (ULONG )0x38)
							{
	#line 758
	SerialHandleModemUpdate(Extension, 1);
							}
							#line 773
							if(Extension->SendXonChar
								&& !
								(Extension->TXHolding
								& ~ (ULONG
								)0x08))
							{
	#line 776
	if(((Extension->HandFlow).FlowReplace & (ULONG )0xc0) == (ULONG )0xc0)
	{
		#line 785
		SerialSetRTS(Extension);
		#line 787
		(Extension->PerfStats).TransmittedCount++;
		(Extension->WmiPerfData).TransmittedCount++;
		#line 792
		do
		{
			#line 792
			WRITE_PORT_UCHAR(Extension->Controller + (ULONG )(0x00 *
				1), (Extension->SpecialChars).XonChar);
		}
		while(0);
		#line 794
		SerialInsertQueueDpc(& Extension->StartTimerLowerRTSDpc,
			(void *  )0, (void *  )0, Extension)
			? Extension->CountOfTryingToLowerRTS++ : 0;
	}
	else
	{
		#line 804
		(Extension->PerfStats).TransmittedCount++;
		(Extension->WmiPerfData).TransmittedCount++;
		#line 809
		do
		{
			#line 809
			WRITE_PORT_UCHAR(Extension->Controller + (ULONG )(0x00 *
				1), (Extension->SpecialChars).XonChar);
		}
		while(0);
	}
	Extension->SendXonChar = 0;
	Extension->HoldingEmpty = 0;
	#line 822
	Extension->TXHolding &= ~ (ULONG )0x08;
	#line 830
	Extension->RXHolding &= ~ (ULONG )0x02;
							}
							else
							{
	#line 832
	if(Extension->SendXoffChar && ! Extension->TXHolding)
	{
		#line 835
		if(((Extension->HandFlow).FlowReplace & (ULONG )0xc0) == (ULONG
			)0xc0)
		{
			#line 844
			SerialSetRTS(Extension);
			#line 846
			(Extension->PerfStats).TransmittedCount++;
			(Extension->WmiPerfData).TransmittedCount++;
			#line 851
			do
			{
				#line 851
				WRITE_PORT_UCHAR(Extension->Controller + (ULONG
					)(0x00 * 1),
					(Extension->SpecialChars).XoffChar);
			}
			while(0);
			#line 853
			SerialInsertQueueDpc(& Extension->StartTimerLowerRTSDpc,
				(void *  )0, (void *  )0, Extension)
				? Extension->CountOfTryingToLowerRTS++ : 0;
		}
		else
		{
			#line 862
			(Extension->PerfStats).TransmittedCount++;
			(Extension->WmiPerfData).TransmittedCount++;
			#line 867
			do
			{
				#line 867
				WRITE_PORT_UCHAR(Extension->Controller + (ULONG
					)(0x00 * 1),
					(Extension->SpecialChars).XoffChar);
			}
			while(0);
		}
		#line 885
		if(! ((Extension->HandFlow).FlowReplace & (ULONG )0x80000000))
		{
			#line 888
			Extension->TXHolding |= (ULONG )0x08;
			#line 890
			if(((Extension->HandFlow).FlowReplace & (ULONG )0xc0) ==
				(ULONG )0xc0)
			{
				#line 894
				SerialInsertQueueDpc(&
					Extension->StartTimerLowerRTSDpc,
					(void *  )0, (void *  )0, Extension)
					? Extension->CountOfTryingToLowerRTS++
					: 0;
			}
		}
		#line 905
		Extension->SendXoffChar = 0;
		Extension->HoldingEmpty = 0;
	}
	else
	{
		#line 915
		if(Extension->TransmitImmediate && (! Extension->TXHolding ||
			Extension->TXHolding == (ULONG )0x08))
		{
			#line 920
			Extension->TransmitImmediate = 0;
			#line 922
			if(((Extension->HandFlow).FlowReplace & (ULONG )0xc0) ==
				(ULONG )0xc0)
			{
				#line 931
				SerialSetRTS(Extension);
				#line 933
				(Extension->PerfStats).TransmittedCount++;
				(Extension->WmiPerfData).TransmittedCount++;
				#line 938
				do
				{
					#line 938
					WRITE_PORT_UCHAR(Extension->Controller +
						(ULONG )(0x00 * 1),
						Extension->ImmediateChar);
				}
				while(0);
				#line 940
				SerialInsertQueueDpc(&
					Extension->StartTimerLowerRTSDpc,
					(void *  )0, (void *  )0, Extension)
					? Extension->CountOfTryingToLowerRTS++
					: 0;
			}
			else
			{
				#line 949
				(Extension->PerfStats).TransmittedCount++;
				(Extension->WmiPerfData).TransmittedCount++;
				#line 954
				do
				{
					#line 954
					WRITE_PORT_UCHAR(Extension->Controller +
						(ULONG )(0x00 * 1),
						Extension->ImmediateChar);
				}
				while(0);
			}
			#line 958
			Extension->HoldingEmpty = 0;
			#line 960
			SerialInsertQueueDpc(& Extension->CompleteImmediateDpc,
				(void *  )0, (void *  )0, Extension);
		}
		else
		{
			#line 967
			if(! Extension->TXHolding)
			{
				ULONG amountToWrite ;
				#line 971
				if(Extension->FifoPresent)
				{
					amountToWrite = Extension->TxFifoAmount
						< Extension->WriteLength
						? Extension->TxFifoAmount
						: Extension->WriteLength;
				}
				else
				{
					amountToWrite = 1;
				}
				#line 983
				if(((Extension->HandFlow).FlowReplace & (ULONG
					)0xc0) == (ULONG )0xc0)
				{
					#line 992
					SerialSetRTS(Extension);
					#line 994
					if(amountToWrite == 1)
					{
						(Extension->PerfStats).TransmittedCount
							++;
						#line 997
						(Extension->WmiPerfData).TransmittedCount
							++;
						#line 1001
						do
						{
							#line 1001
							WRITE_PORT_UCHAR(Extension
								->Controller +
								(ULONG )(0x00 *
								1), *
								Extension->WriteCurrentChar)
								;
						}
						while(0);
					}
					else
					{
						#line 1005
						(Extension->PerfStats).TransmittedCount
							+= amountToWrite;
						(Extension->WmiPerfData).TransmittedCount
							+= amountToWrite;
						#line 1013
						do
						{
							#line 1013
							WRITE_PORT_BUFFER_UCHAR(
								Extension->Controller
								+ (ULONG )(0x00
								* 1),
								Extension->WriteCurrentChar,
								amountToWrite);
						}
						while(0);
					}
					#line 1017
					SerialInsertQueueDpc(&
						Extension->StartTimerLowerRTSDpc,
						(void *  )0, (void *  )0,
						Extension)
						? Extension->CountOfTryingToLowerRTS++
						: 0;
				}
				else
				{
					if(amountToWrite == 1)
					{
						(Extension->PerfStats).TransmittedCount
							++;
						#line 1029
						(Extension->WmiPerfData).TransmittedCount
							++;
						#line 1033
						do
						{
							#line 1033
							WRITE_PORT_UCHAR(Extension
								->Controller +
								(ULONG )(0x00 *
								1), *
								Extension->WriteCurrentChar)
								;
						}
						while(0);
					}
					else
					{
						#line 1037
						(Extension->PerfStats).TransmittedCount
							+= amountToWrite;
						(Extension->WmiPerfData).TransmittedCount
							+= amountToWrite;
						#line 1045
						do
						{
							#line 1045
							WRITE_PORT_BUFFER_UCHAR(
								Extension->Controller
								+ (ULONG )(0x00
								* 1),
								Extension->WriteCurrentChar,
								amountToWrite);
						}
						while(0);
					}
				}
				#line 1051
				Extension->HoldingEmpty = 0;
				Extension->WriteCurrentChar += amountToWrite;
				Extension->WriteLength -= amountToWrite;
				#line 1055
				if(! Extension->WriteLength)
				{
					PIO_STACK_LOCATION IrpSp ;
					#line 1066
					IrpSp =
						(((Extension->CurrentWriteIrp)->Tail)
						.Overlay).CurrentStackLocation;
					#line 1070
					((Extension->CurrentWriteIrp)->IoStatus)
						.Information =
						IrpSp->MajorFunction == 0x04
						? ((IrpSp->Parameters).Write).Length
						: 1;
					#line 1076
					SerialInsertQueueDpc(&
						Extension->CompleteWriteDpc,
						(void *  )0, (void *  )0,
						Extension);
				}
			}
		}
	}
							}
						}
						#line 1089
						break;
					}
					#line 1093
				case 0x00:
						#line 1093
						;
					{
						SerialHandleModemUpdate(Extension
							, 0);
						#line 1100
						break;
					}
				}
			}
			while(! ((InterruptIdReg =
				READ_PORT_UCHAR(Extension->Controller + (ULONG
				)(0x02 * 1))) & 0x01));
			#line 1116
			if(SerialProcessLSR(Extension) & 0x20)
			{
				if(! Extension->TXHolding &&
					(Extension->WriteLength ||
					Extension->TransmitImmediate))
				{
					goto doTrasmitStuff;
				}
			}
		}
	}
	{
		#line 1136
		LONG pendingCnt ;
		#line 1144
		retryDPCFiring:
			#line 1144
			;
		#line 1146
		InterlockedIncrement(& Extension->DpcCount);
		;
		#line 1153
		pendingCnt = InterlockedDecrement(& Extension->DpcCount);
		#line 1156
		if(pendingCnt == 1)
		{
			#line 1157
			KeInsertQueueDpc(& Extension->IsrUnlockPagesDpc,
				(void *  )0, (void *  )0);
		}
		else
		{
			#line 1159
			if(InterlockedDecrement(& Extension->DpcCount) == 0)
			{
				#line 1168
				InterlockedIncrement(& Extension->DpcCount);
				#line 1170
				;
				goto retryDPCFiring;
			}
		}
	}
	#line 1176
	return ServicedAnInterrupt;
}

#line 1180
void SerialPutChar(PSERIAL_DEVICE_EXTENSION Extension , UCHAR CharToPut )
{
	#line 1204
	;
	#line 1212
	if((Extension->HandFlow).ControlHandShake & (ULONG )0x40)
	{
		#line 1215
		SerialHandleModemUpdate(Extension, 0);
		#line 1220
		if(Extension->RXHolding & (ULONG )0x08)
		{
			#line 1228
			return;
		}
	}
	#line 1239
	if(Extension->CountSinceXoff)
	{
		Extension->CountSinceXoff--;
		#line 1243
		if(! Extension->CountSinceXoff)
		{
			((Extension->CurrentXoffIrp)->IoStatus).Status =
				(NTSTATUS )0x00000000L;
			#line 1246
			((Extension->CurrentXoffIrp)->IoStatus).Information = 0;
			SerialInsertQueueDpc(& Extension->XoffCountCompleteDpc,
				(void *  )0, (void *  )0, Extension);
		}
	}
	#line 1273
	if(Extension->ReadBufferBase != Extension->InterruptReadBuffer)
	{
		#line 1283
		Extension->ReadByIsr++;
		#line 1291
		* Extension->CurrentCharSlot = CharToPut;
		#line 1293
		if(Extension->CurrentCharSlot == Extension->LastCharSlot)
		{
			#line 1306
			Extension->ReadBufferBase =
				Extension->InterruptReadBuffer;
			Extension->CurrentCharSlot =
				Extension->InterruptReadBuffer;
			Extension->FirstReadableChar =
				Extension->InterruptReadBuffer;
			Extension->LastCharSlot = Extension->InterruptReadBuffer
				+ (Extension->BufferSize - 1);
			#line 1315
			Extension->CharsInInterruptBuffer = 0;
			#line 1317
			((Extension->CurrentReadIrp)->IoStatus).Information =
				((((((Extension->CurrentReadIrp)->Tail).Overlay)
				.CurrentStackLocation)->Parameters).Read).Length
				;
			#line 1322
			SerialInsertQueueDpc(& Extension->CompleteReadDpc,
				(void *  )0, (void *  )0, Extension);
		}
		else
		{
			#line 1335
			Extension->CurrentCharSlot++;
		}
	}
	else
	{
		#line 1354
		if(((Extension->HandFlow).ControlHandShake & (ULONG )0x03) ==
			(ULONG )0x02)
		{
			#line 1364
			if(! (Extension->RXHolding & (ULONG )0x01))
			{
				#line 1367
				if(Extension->BufferSize -
					(Extension->HandFlow).XoffLimit <=
					Extension->CharsInInterruptBuffer + 1)
				{
					Extension->RXHolding |= (ULONG )0x01;
					#line 1373
					SerialClrDTR(Extension);
				}
			}
		}
		#line 1381
		if(((Extension->HandFlow).FlowReplace & (ULONG )0xc0) == (ULONG
			)0x80)
		{
			#line 1391
			if(! (Extension->RXHolding & (ULONG )0x04))
			{
				#line 1394
				if(Extension->BufferSize -
					(Extension->HandFlow).XoffLimit <=
					Extension->CharsInInterruptBuffer + 1)
				{
					Extension->RXHolding |= (ULONG )0x04;
					#line 1400
					SerialClrRTS(Extension);
				}
			}
		}
		#line 1408
		if((Extension->HandFlow).FlowReplace & (ULONG )0x02)
		{
			#line 1417
			if(! (Extension->RXHolding & (ULONG )0x02))
			{
				#line 1420
				if(Extension->BufferSize -
					(Extension->HandFlow).XoffLimit <=
					Extension->CharsInInterruptBuffer + 1)
				{
					Extension->RXHolding |= (ULONG )0x02;
					#line 1431
					SerialProdXonXoff(Extension, 0);
				}
			}
		}
		#line 1442
		if(Extension->CharsInInterruptBuffer < Extension->BufferSize)
		{
			#line 1445
			* Extension->CurrentCharSlot = CharToPut;
			Extension->CharsInInterruptBuffer++;
			#line 1453
			if(Extension->CharsInInterruptBuffer ==
				Extension->BufferSizePt8)
			{
				if(Extension->IsrWaitMask & 0x0400)
				{
					#line 1459
					Extension->HistoryMask |= 0x0400;
					#line 1461
					if(Extension->IrpMaskLocation)
					{
						* Extension->IrpMaskLocation =
							Extension->HistoryMask;
						Extension->IrpMaskLocation =
							(void *  )0;
						#line 1466
						Extension->HistoryMask = 0;
						#line 1468
						((Extension->CurrentWaitIrp)->IoStatus
							).Information =
							sizeof(ULONG );
						#line 1470
						SerialInsertQueueDpc(&
							Extension->CommWaitDpc,
							(void *  )0, (void * 
							)0, Extension);
					}
				}
			}
			#line 1492
			if(Extension->CurrentCharSlot ==
				Extension->LastCharSlot)
			{
				Extension->CurrentCharSlot =
					Extension->InterruptReadBuffer;
			}
			else
			{
				Extension->CurrentCharSlot++;
			}
		}
		else
		{
			#line 1510
			(Extension->PerfStats).BufferOverrunErrorCount++;
			(Extension->WmiPerfData).BufferOverrunErrorCount++;
			Extension->ErrorWord |= (ULONG )0x00000008;
			#line 1514
			if((Extension->HandFlow).FlowReplace & (ULONG )0x04)
			{
				#line 1523
				if(Extension->CurrentCharSlot ==
					Extension->InterruptReadBuffer)
				{
					* (Extension->InterruptReadBuffer +
						(Extension->BufferSize - 1)) =
						(Extension->SpecialChars).ErrorChar
						;
				}
				else
				{
					#line 1532
					* (Extension->CurrentCharSlot - 1) =
						(Extension->SpecialChars).ErrorChar
						;
				}
			}
			#line 1544
			if((Extension->HandFlow).ControlHandShake & (ULONG
				)0x80000000)
			{
				SerialInsertQueueDpc(& Extension->CommErrorDpc,
					(void *  )0, (void *  )0, Extension);
			}
		}
	}
}

#line 1562
UCHAR SerialProcessLSR(PSERIAL_DEVICE_EXTENSION Extension )
{
	#line 1587
	UCHAR LineStatus = READ_PORT_UCHAR(Extension->Controller + (ULONG )(0x05
		* 1));
	;
	Extension->HoldingEmpty = ! ! (LineStatus & 0x20);
	#line 1599
	if(LineStatus & ~ (0x20 | 0x40 | 0x01))
	{
		#line 1613
		if(Extension->EscapeChar)
		{
			SerialPutChar(Extension, Extension->EscapeChar);
			#line 1620
			SerialPutChar(Extension, (UCHAR )(LineStatus & 0x01
				? (UCHAR )0x01 : (UCHAR )0x02));
			#line 1626
			SerialPutChar(Extension, LineStatus);
			#line 1631
			if(LineStatus & 0x01)
			{
				(Extension->PerfStats).ReceivedCount++;
				(Extension->WmiPerfData).ReceivedCount++;
				SerialPutChar(Extension,
					READ_PORT_UCHAR(Extension->Controller +
					(ULONG )(0x00 * 1)));
			}
		}
		#line 1644
		if(LineStatus & 0x02)
		{
			(Extension->PerfStats).SerialOverrunErrorCount++;
			(Extension->WmiPerfData).SerialOverrunErrorCount++;
			Extension->ErrorWord |= (ULONG )0x00000004;
			#line 1650
			if((Extension->HandFlow).FlowReplace & (ULONG )0x04)
			{
				#line 1653
				SerialPutChar(Extension,
					(Extension->SpecialChars).ErrorChar);
				#line 1658
				if(LineStatus & 0x01)
				{
					(Extension->PerfStats).ReceivedCount++;
					(Extension->WmiPerfData).ReceivedCount++
						;
					#line 1662
					READ_PORT_UCHAR(Extension->Controller +
						(ULONG )(0x00 * 1));
				}
			}
			else
			{
				if(LineStatus & 0x01)
				{
					(Extension->PerfStats).ReceivedCount++;
					(Extension->WmiPerfData).ReceivedCount++
						;
					#line 1672
					SerialPutChar(Extension,
						READ_PORT_UCHAR(Extension->Controller
						+ (ULONG )(0x00 * 1)));
				}
			}
		}
		#line 1685
		if(LineStatus & 0x10)
		{
			Extension->ErrorWord |= (ULONG )0x00000001;
			#line 1689
			if((Extension->HandFlow).FlowReplace & (ULONG )0x10)
			{
				#line 1692
				SerialPutChar(Extension,
					(Extension->SpecialChars).BreakChar);
			}
		}
		else
		{
			#line 1707
			if(LineStatus & 0x04)
			{
				(Extension->PerfStats).ParityErrorCount++;
				(Extension->WmiPerfData).ParityErrorCount++;
				Extension->ErrorWord |= (ULONG )0x00000010;
				#line 1713
				if((Extension->HandFlow).FlowReplace & (ULONG
					)0x04)
				{
					SerialPutChar(Extension,
						(Extension->SpecialChars).ErrorChar
						);
					#line 1721
					if(LineStatus & 0x01)
					{
						(Extension->PerfStats).ReceivedCount
							++;
						#line 1724
						(Extension->WmiPerfData).ReceivedCount
							++;
						#line 1725
						READ_PORT_UCHAR(Extension->Controller
							+ (ULONG )(0x00 * 1));
					}
				}
			}
			#line 1733
			if(LineStatus & 0x08)
			{
				(Extension->PerfStats).FrameErrorCount++;
				(Extension->WmiPerfData).FrameErrorCount++;
				Extension->ErrorWord |= (ULONG )0x00000002;
				#line 1739
				if((Extension->HandFlow).FlowReplace & (ULONG
					)0x04)
				{
					SerialPutChar(Extension,
						(Extension->SpecialChars).ErrorChar
						);
					#line 1746
					if(LineStatus & 0x01)
					{
						(Extension->PerfStats).ReceivedCount
							++;
						#line 1749
						(Extension->WmiPerfData).ReceivedCount
							++;
						#line 1750
						READ_PORT_UCHAR(Extension->Controller
							+ (ULONG )(0x00 * 1));
					}
				}
			}
		}
		#line 1766
		if((Extension->HandFlow).ControlHandShake & (ULONG )0x80000000)
		{
			#line 1769
			SerialInsertQueueDpc(& Extension->CommErrorDpc, (void * 
				)0, (void *  )0, Extension);
		}
		#line 1785
		if(Extension->IsrWaitMask)
		{
			if(Extension->IsrWaitMask & 0x0080 && LineStatus & (0x02
				| 0x04 | 0x08))
			{
				#line 1792
				Extension->HistoryMask |= 0x0080;
			}
			#line 1796
			if(Extension->IsrWaitMask & 0x0040 && LineStatus & 0x10)
			{
				#line 1799
				Extension->HistoryMask |= 0x0040;
			}
			#line 1803
			if(Extension->IrpMaskLocation && Extension->HistoryMask)
			{
				#line 1806
				* Extension->IrpMaskLocation =
					Extension->HistoryMask;
				Extension->IrpMaskLocation = (void *  )0;
				Extension->HistoryMask = 0;
				#line 1811
				((Extension->CurrentWaitIrp)->IoStatus).Information
					= sizeof(ULONG );
				SerialInsertQueueDpc(& Extension->CommWaitDpc,
					(void *  )0, (void *  )0, Extension);
			}
		}
		#line 1824
		if(LineStatus & 0x20)
		{
			#line 1843
			if(Extension->WriteLength |
				Extension->TransmitImmediate)
			{
				#line 1848
				do
				{
					#line 1848
					do
					{
						#line 1848
						WRITE_PORT_UCHAR(Extension->Controller
							+ (ULONG )(0x01 * 1),
							0);
					}
					while(0);
				}
				while(0);
				#line 1851
				do
				{
					#line 1851
					do
					{
						#line 1851
						WRITE_PORT_UCHAR(Extension->Controller
							+ (ULONG )(0x01 * 1),
							(UCHAR )(0x01 | 0x02 |
							0x04 | 0x08));
					}
					while(0);
				}
				while(0);
			}
		}
	}
	#line 1859
	return LineStatus;
}

#line 16 "C:/NTDDK/inc/stddef.h"

#pragma once
#line 77
typedef int ;

#line 86
typedef unsigned int ;

#line 95
typedef int ;

#line 105
typedef unsigned int ;

#line 112
typedef unsigned short ;

#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"

#pragma once
#line 32

#pragma pack(push, 8)
#line 72
typedef enum _EXCEPTION_DISPOSITION ;

#line 89
struct _EXCEPTION_RECORD ;

#line 90
struct _CONTEXT ;

#line 155

#pragma pack(pop)
#line 25 "C:/NTDDK/inc/ntdef.h"

#pragma once
#line 15 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"

#pragma once
#line 66
typedef wchar_t ;

#line 67
typedef wchar_t ;

#line 127 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long ;

#line 25 "C:/NTDDK/inc/basetsd.h"

#pragma once
#line 36
typedef int ;

#line 37
typedef int ;

#line 43
typedef unsigned int ;

#line 44
typedef unsigned int ;

#line 45
typedef unsigned int ;

#line 84
typedef int ;

#line 85
typedef unsigned int ;

typedef long ;

#line 88
typedef unsigned long ;

#line 248
typedef unsigned short ;

#line 249
typedef short ;

#line 250
typedef unsigned long ;

#line 288
typedef ULONG_PTR ;

#line 289
typedef LONG_PTR ;

#line 295
typedef ULONG_PTR ;

#line 301
typedef __int64 ;

#line 302
typedef __int64 ;

#line 309
typedef unsigned __int64 ;

#line 310
typedef unsigned __int64 ;

#line 311
typedef unsigned __int64 ;

#line 217 "C:/NTDDK/inc/ntdef.h"
typedef void ;

#line 218
typedef void ;

#line 266
typedef char ;

#line 267
typedef short ;

#line 268
typedef long ;

#line 276
typedef wchar_t ;

#line 282
typedef WCHAR ;

#line 283
typedef WCHAR ;

#line 284
typedef const WCHAR ;

#line 285
typedef WCHAR ;

#line 286
typedef WCHAR ;

typedef const WCHAR ;

#line 293
typedef CHAR ;

#line 294
typedef CHAR ;

typedef const CHAR ;

#line 297
typedef CHAR ;

#line 298
typedef CHAR ;

#line 299
typedef const CHAR ;

#line 321
typedef char ;

#line 322
typedef unsigned char ;

#line 326
typedef LPSTR ;

#line 327
typedef LPSTR ;

#line 328
typedef LPCSTR ;

#line 337
typedef double ;

typedef struct _QUAD ;

#line 349
typedef SHORT ;

#line 350
typedef LONG ;

#line 351
typedef QUAD ;

#line 360
typedef unsigned char ;

#line 361
typedef unsigned short ;

#line 362
typedef unsigned long ;

#line 363
typedef QUAD ;

#line 369
typedef UCHAR ;

#line 370
typedef USHORT ;

#line 371
typedef ULONG ;

#line 372
typedef UQUAD ;

#line 378
typedef signed char ;

#line 379
typedef SCHAR ;

#line 394
typedef void ;

#line 400
typedef HANDLE ;

#line 406
typedef UCHAR ;

#line 407
typedef USHORT ;

#line 408
typedef ULONG ;

#line 414
typedef LONG ;

#line 478
typedef char ;

#line 479
typedef short ;

#line 480
typedef ULONG ;

typedef CCHAR ;

#line 483
typedef CSHORT ;

#line 484
typedef CLONG ;

#line 492
typedef ULONG ;

#line 493
typedef PULONG ;

#line 494
typedef USHORT ;

#line 500
typedef ULONG ;

#line 501
typedef ULONG ;

#line 508
typedef LONG ;

typedef NTSTATUS ;

#line 602
typedef struct _FLOAT128 ;

#line 607
typedef FLOAT128 ;

#line 621
typedef __int64 ;

#line 622
typedef unsigned __int64 ;

#line 639
typedef LONGLONG ;

#line 640
typedef ULONGLONG ;

#line 644
typedef LONGLONG ;

#line 649
typedef union _LARGE_INTEGER ;

#line 662
typedef LARGE_INTEGER ;

#line 668
typedef union _ULARGE_INTEGER ;

#line 681
typedef ULARGE_INTEGER ;

#line 690
typedef struct _LUID ;

#line 696
typedef ULONGLONG ;

#line 697
typedef DWORDLONG ;

#line 707
typedef LARGE_INTEGER ;

#line 831

#pragma warning(push)

#pragma warning(disable:4035)
__inline ULONGLONG __stdcall Int64ShllMod32___6(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 842
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    
		};
}

#line 845
__inline LONGLONG __stdcall Int64ShraMod32___6(LONGLONG Value , ULONG ShiftCount
	)
{
	#line 852
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    
		};
}

#line 855
__inline ULONGLONG __stdcall Int64ShrlMod32___6(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 862
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    
		};
}


#pragma warning(pop)
#line 956
typedef enum _EVENT_TYPE ;

#line 965
typedef enum _TIMER_TYPE ;

#line 974
typedef enum _WAIT_TYPE ;

#line 983
typedef CHAR ;

#line 984
typedef const char ;

#line 991
typedef struct _STRING ;

#line 999
typedef STRING ;

typedef STRING ;

#line 1002
typedef PSTRING ;

typedef STRING ;

#line 1005
typedef PSTRING ;

#line 1011
typedef struct _CSTRING ;

#line 1016
typedef CSTRING ;

#line 1019
typedef STRING ;

#line 1020
typedef PSTRING ;

#line 1027
typedef struct _UNICODE_STRING ;

#line 1036
typedef UNICODE_STRING ;

#line 1037
typedef const UNICODE_STRING ;

#line 1046
typedef UCHAR ;

#line 1047
typedef BOOLEAN ;

#line 1057
typedef struct _LIST_ENTRY ;

#line 1067
typedef struct _SINGLE_LIST_ENTRY ;

#line 1078
typedef struct LIST_ENTRY32 ;

#line 1082
typedef LIST_ENTRY32 ;

typedef struct LIST_ENTRY64 ;

#line 1088
typedef LIST_ENTRY64 ;

#line 1127
typedef struct _STRING32 ;

#line 1132
typedef STRING32 ;

typedef STRING32 ;

#line 1135
typedef UNICODE_STRING32 ;

typedef STRING32 ;

#line 1138
typedef ANSI_STRING32 ;

#line 1141
typedef struct _STRING64 ;

#line 1146
typedef STRING64 ;

typedef STRING64 ;

#line 1149
typedef UNICODE_STRING64 ;

typedef STRING64 ;

#line 1152
typedef ANSI_STRING64 ;

#line 1173
typedef struct _OBJECT_ATTRIBUTES ;

#line 1181
typedef OBJECT_ATTRIBUTES ;

#line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID ;

#line 70
typedef GUID ;

#line 75
typedef const GUID ;

#line 81
typedef GUID ;

#line 82
typedef IID ;

#line 85
typedef GUID ;

#line 86
typedef CLSID ;

#line 89
typedef GUID ;

#line 90
typedef FMTID ;

#line 16 "C:/NTDDK/inc/string.h"

#pragma once
#line 1233 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECTID ;

#line 1288
struct _CONTEXT ;

#line 1289
struct _EXCEPTION_RECORD ;

typedef EXCEPTION_DISPOSITION ;

#line 1306
typedef UCHAR ;

typedef KIRQL ;

#line 1316
typedef enum _NT_PRODUCT_TYPE ;

#line 1329
typedef enum _SUITE_TYPE ;

#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD ;

#line 76
typedef struct _ETHREAD ;

#line 77
typedef struct _EPROCESS ;

#line 78
typedef struct _PEB ;

#line 79
typedef struct _KINTERRUPT ;

#line 80
typedef struct _IO_TIMER ;

#line 81
typedef struct _OBJECT_TYPE ;

#line 82
typedef struct _CALLBACK_OBJECT ;

#line 83
typedef struct _DEVICE_HANDLER_OBJECT ;

#line 84
typedef struct _BUS_HANDLER ;

#line 143
typedef union _SLIST_HEADER ;

#line 204
typedef CCHAR ;

typedef enum _MODE ;

#line 222
struct _KAPC ;

typedef void ;

#line 232
typedef void ;

#line 242
typedef void ;

#line 248
typedef BOOLEAN ;

#line 254
typedef BOOLEAN ;

#line 265
typedef struct _KAPC ;

#line 292
struct _KDPC ;

typedef void ;

#line 351
typedef enum _KDPC_IMPORTANCE ;

#line 361
typedef struct _KDPC ;

#line 377
typedef PVOID ;

typedef void ;

#line 392
typedef struct _KIPI_COUNTS ;

#line 443
typedef struct _MDL ;

#line 532
typedef PVOID ;

#line 538
typedef PVOID ;

#line 544
typedef PVOID ;

typedef ULONG ;

#line 547
typedef ACCESS_MASK ;

#line 597
typedef struct _GENERIC_MAPPING ;

#line 603
typedef GENERIC_MAPPING ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES ;

#line 622
typedef LUID_AND_ATTRIBUTES ;

#line 623
typedef LUID_AND_ATTRIBUTES_ARRAY ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 642 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACL ;

#line 649
typedef ACL ;

#line 681
typedef struct _PRIVILEGE_SET ;

#line 735
typedef enum _SECURITY_IMPERSONATION_LEVEL ;

#line 753
typedef BOOLEAN ;

#line 762
typedef struct _SECURITY_QUALITY_OF_SERVICE ;

#line 774
typedef struct _SE_IMPERSONATION_STATE ;

#line 782
typedef ULONG ;

#line 809
typedef ULONG ;

#line 810
typedef KAFFINITY ;

#line 816
typedef LONG ;

#line 824
typedef ULONG_PTR ;

#line 825
typedef KSPIN_LOCK ;

#line 833
typedef void ;

#line 842
typedef enum _KPROFILE_SOURCE ;

#line 1079
typedef NTSTATUS ;

#line 1088
typedef struct _RTL_QUERY_REGISTRY_TABLE ;

#line 1952

#pragma warning(push)

#pragma warning(disable:4035)
#line 2019

#pragma warning(pop)
#line 2214
typedef struct _TIME_FIELDS ;

#line 2224
typedef TIME_FIELDS ;

#line 2499
typedef struct _RTL_BITMAP ;

#line 2503
typedef RTL_BITMAP ;

#line 2627
typedef struct _RTL_BITMAP_RUN ;

#line 2633
typedef RTL_BITMAP_RUN ;

#line 2886
typedef struct _RTL_RANGE ;

#line 2924
typedef struct _RTL_RANGE_LIST ;

#line 2950
typedef struct _RANGE_LIST_ITERATOR ;

#line 3019
typedef BOOLEAN ;

#line 3155
typedef struct _OSVERSIONINFOA ;

#line 3164
typedef struct _OSVERSIONINFOW ;

#line 3177
typedef OSVERSIONINFOA ;

#line 3178
typedef POSVERSIONINFOA ;

#line 3179
typedef LPOSVERSIONINFOA ;

#line 3182
typedef struct _OSVERSIONINFOEXA ;

#line 3195
typedef struct _OSVERSIONINFOEXW ;

#line 3213
typedef OSVERSIONINFOEXA ;

#line 3214
typedef POSVERSIONINFOEXA ;

#line 3215
typedef LPOSVERSIONINFOEXA ;

#line 3648
typedef struct _IO_STATUS_BLOCK ;

#line 3669
typedef void ;

#line 3685
typedef enum _FILE_INFORMATION_CLASS ;

#line 3731
typedef struct _FILE_BASIC_INFORMATION ;

#line 3739
typedef struct _FILE_STANDARD_INFORMATION ;

#line 3747
typedef struct _FILE_POSITION_INFORMATION ;

#line 3751
typedef struct _FILE_ALIGNMENT_INFORMATION ;

#line 3755
typedef struct _FILE_NAME_INFORMATION ;

#line 3760
typedef struct _FILE_NETWORK_OPEN_INFORMATION ;

#line 3770
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION ;

#line 3775
typedef struct _FILE_DISPOSITION_INFORMATION ;

#line 3779
typedef struct _FILE_END_OF_FILE_INFORMATION ;

#line 3784
typedef struct _FILE_FULL_EA_INFORMATION ;

#line 3798
typedef enum _FSINFOCLASS ;

#line 3810
typedef struct _FILE_FS_DEVICE_INFORMATION ;

#line 3820
typedef union _FILE_SEGMENT_ELEMENT ;

#line 3829
typedef enum _INTERFACE_TYPE ;

#line 3854
typedef enum _DMA_WIDTH ;

#line 3865
typedef enum _DMA_SPEED ;

#line 3879
typedef void ;

#line 3880
typedef void ;

#line 3888
typedef enum _BUS_DATA_TYPE ;

#line 3910
typedef struct _IO_ERROR_LOG_PACKET ;

#line 3931
typedef struct _IO_ERROR_LOG_MESSAGE ;

#line 4074
typedef struct _KEY_BASIC_INFORMATION ;

#line 4081
typedef struct _KEY_NODE_INFORMATION ;

#line 4091
typedef struct _KEY_FULL_INFORMATION ;

#line 4106
typedef struct _KEY_NAME_INFORMATION ;

#line 4112
typedef enum _KEY_INFORMATION_CLASS ;

#line 4122
typedef struct _KEY_WRITE_TIME_INFORMATION ;

#line 4126
typedef enum _KEY_SET_INFORMATION_CLASS ;

#line 4134
typedef struct _KEY_VALUE_BASIC_INFORMATION ;

#line 4141
typedef struct _KEY_VALUE_FULL_INFORMATION ;

#line 4151
typedef struct _KEY_VALUE_PARTIAL_INFORMATION ;

#line 4158
typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ;

#line 4164
typedef struct _KEY_VALUE_ENTRY ;

#line 4171
typedef enum _KEY_VALUE_INFORMATION_CLASS ;

#line 4210
typedef struct _OBJECT_NAME_INFORMATION ;

#line 4221
typedef enum _SECTION_INHERIT ;

#line 4294
typedef struct _CLIENT_ID ;

#line 4298
typedef CLIENT_ID ;

#line 4315
typedef struct _NT_TIB ;

#line 4327
typedef NT_TIB ;

#line 4332
typedef enum _PROCESSINFOCLASS ;

#line 4366
typedef enum _THREADINFOCLASS ;

#line 4395
typedef struct _PROCESS_WS_WATCH_INFORMATION ;

#line 4405
typedef struct _PROCESS_BASIC_INFORMATION ;

#line 4413
typedef PROCESS_BASIC_INFORMATION ;

#line 4422
typedef struct _PROCESS_DEVICEMAP_INFORMATION ;

#line 4440
typedef struct _PROCESS_SESSION_INFORMATION ;

#line 4454
typedef struct _QUOTA_LIMITS ;

#line 4462
typedef QUOTA_LIMITS ;

#line 4472
typedef struct _IO_COUNTERS ;

#line 4480
typedef IO_COUNTERS ;

#line 4488
typedef struct _VM_COUNTERS ;

#line 4501
typedef VM_COUNTERS ;

#line 4508
typedef struct _POOLED_USAGE_AND_LIMITS ;

#line 4519
typedef POOLED_USAGE_AND_LIMITS ;

#line 4528
typedef struct _PROCESS_ACCESS_TOKEN ;

#line 4555
typedef struct _KERNEL_USER_TIMES ;

#line 4561
typedef KERNEL_USER_TIMES ;

#line 4587
typedef enum _SYSTEM_POWER_STATE ;

#line 4598
typedef enum  {
	PowerActionNone = 0,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
} ;

typedef enum _DEVICE_POWER_STATE ;

#line 4618
typedef union _POWER_STATE ;

#line 4623
typedef enum _POWER_STATE_TYPE ;

#line 4654
typedef ULONG ;

typedef enum  {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
} ;

#line 4663
typedef enum  {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation
} ;

#line 4690
typedef ULONG ;

typedef LONG ;

#line 4693
typedef ULONG ;

#line 4719
typedef union _MCI_STATS ;

#line 4978
typedef struct _KPCR ;

#line 5006
typedef KPCR ;

#line 5012
typedef struct _KFLOATING_SAVE ;

#line 5153
typedef enum _INTERLOCKED_RESULT ;

#line 5252

#pragma warning(disable:4035)
#line 6994
typedef struct _KSYSTEM_TIME ;

#line 7014

#pragma warning(push)

#pragma warning(disable:4164)
#line 7019

#pragma function(_enable)
#line 7020

#pragma function(_disable)
#line 7024

#pragma warning(pop)
#line 7085
typedef struct _FLOATING_SAVE_AREA ;

#line 7097
typedef FLOATING_SAVE_AREA ;

#line 7109
typedef struct _CONTEXT ;

#line 7197
typedef CONTEXT ;

#line 7826
typedef void ;

#line 7850
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ;

#line 7899
typedef struct _KUSER_SHARED_DATA ;

#line 8123
typedef enum _CM_SERVICE_NODE_TYPE ;

#line 8132
typedef enum _CM_SERVICE_LOAD_TYPE ;

#line 8140
typedef enum _CM_ERROR_CONTROL_TYPE ;

#line 8172
typedef int ;

#line 8198
typedef enum _CM_SHARE_DISPOSITION ;

#line 8211
typedef PVOID ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST ;

#line 8443
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR ;

#line 8454
typedef struct _CM_RESOURCE_LIST ;

#line 8471
typedef struct _DEVICE_FLAGS ;

#line 8485
typedef struct _CM_COMPONENT_INFORMATION ;

#line 8503
typedef struct _CM_ROM_BLOCK ;

#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 8518 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_INT13_DRIVE_PARAMETER ;

#line 8532
typedef struct _CM_MCA_POS_DATA ;

#line 8544
typedef struct _EISA_MEMORY_TYPE ;

#line 8554
typedef struct _EISA_MEMORY_CONFIGURATION ;

#line 8567
typedef struct _EISA_IRQ_DESCRIPTOR ;

#line 8575
typedef struct _EISA_IRQ_CONFIGURATION ;

#line 8585
typedef struct _DMA_CONFIGURATION_BYTE0 ;

#line 8592
typedef struct _DMA_CONFIGURATION_BYTE1 ;

#line 8599
typedef struct _EISA_DMA_CONFIGURATION ;

#line 8609
typedef struct _EISA_PORT_DESCRIPTOR ;

#line 8616
typedef struct _EISA_PORT_CONFIGURATION ;

#line 8628
typedef struct _CM_EISA_SLOT_INFORMATION ;

#line 8644
typedef struct _CM_EISA_FUNCTION_INFORMATION ;

#line 8678
typedef struct _CM_PNP_BIOS_DEVICE_NODE ;

#line 8692
typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8761 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_SCSI_DEVICE_DATA ;

#line 8775
typedef struct _CM_VIDEO_DEVICE_DATA ;

#line 8785
typedef struct _CM_SONIC_DEVICE_DATA ;

#line 8796
typedef struct _CM_SERIAL_DEVICE_DATA ;

#line 8810
typedef struct _CM_MONITOR_DEVICE_DATA ;

#line 8844
typedef struct _CM_FLOPPY_DEVICE_DATA ;

#line 8881
typedef struct _CM_KEYBOARD_DEVICE_DATA ;

#line 8893
typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA ;

#line 8905
typedef struct _CM_PCCARD_DEVICE_DATA ;

#line 8944
typedef struct _IO_RESOURCE_DESCRIPTOR ;

#line 9027
typedef struct _IO_RESOURCE_LIST ;

#line 9036
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST ;

#line 9065
typedef struct _EXCEPTION_RECORD ;

#line 9074
typedef EXCEPTION_RECORD ;

typedef struct _EXCEPTION_RECORD32 ;

#line 9085
typedef struct _EXCEPTION_RECORD64 ;

#line 9099
typedef struct _EXCEPTION_POINTERS ;

#line 9111
typedef enum _CONFIGURATION_TYPE ;

#line 9161
typedef enum _KINTERRUPT_MODE ;

#line 9170
typedef enum _KWAIT_REASON ;

#line 9207
typedef struct _DISPATCHER_HEADER ;

#line 9217
typedef struct _KWAIT_BLOCK ;

#line 9230
typedef void ;

#line 9244
typedef struct _KDEVICE_QUEUE ;

#line 9252
typedef struct _KDEVICE_QUEUE_ENTRY ;

#line 9263
typedef struct _KEVENT ;

#line 9271
typedef BOOLEAN ;

#line 9281
typedef struct _KMUTANT ;

#line 9294
typedef struct _KSEMAPHORE ;

#line 9304
typedef struct _KTIMER ;

#line 9899
typedef enum _KBUGCHECK_BUFFER_DUMP_STATE ;

#line 9907
typedef void ;

#line 9914
typedef struct _KBUGCHECK_CALLBACK_RECORD ;

#line 10002
typedef void ;

#line 10020
typedef LOGICAL ;

#line 10037
typedef void ;

#line 10053
typedef enum _MEMORY_CACHING_TYPE_ORIG ;

#line 10057
typedef enum _MEMORY_CACHING_TYPE ;

#line 10087
typedef struct _DBGKD_DEBUG_DATA_HEADER64 ;

#line 10115
typedef enum _POOL_TYPE ;

#line 10195
typedef enum _EX_POOL_PRIORITY ;

#line 10247
typedef struct _FAST_MUTEX ;

#line 10574
typedef PVOID ;

#line 10582
typedef void ;

#line 10588
typedef struct _GENERAL_LOOKASIDE ;

#line 10619
typedef struct _NPAGED_LOOKASIDE_LIST ;

#line 10729
typedef struct _PAGED_LOOKASIDE_LIST ;

#line 10882
typedef enum _WORK_QUEUE_TYPE ;

#line 10889
typedef void ;

#line 10895
typedef struct _WORK_QUEUE_ITEM ;

#line 10926
typedef struct _ZONE_SEGMENT_HEADER ;

#line 10931
typedef struct _ZONE_HEADER ;

#line 11156
typedef ULONG_PTR ;

#line 11157
typedef ERESOURCE_THREAD ;

typedef struct _OWNER_ENTRY ;

#line 11168
typedef struct _ERESOURCE ;

#line 11197
typedef struct _RESOURCE_HASH_ENTRY ;

#line 11204
typedef struct _RESOURCE_PERFORMANCE_DATA ;

#line 11429
typedef struct _CALLBACK_OBJECT ;

typedef void ;

#line 11474
typedef GUID ;

#line 11862
typedef enum _MM_SYSTEM_SIZE ;

#line 11884
typedef enum _LOCK_OPERATION ;

#line 11970
typedef enum _MM_PAGE_PRIORITY ;

#line 11999
typedef struct _PHYSICAL_MEMORY_RANGE ;

#line 12385
typedef NTSTATUS ;

#line 12389
typedef NTSTATUS ;

#line 12399
struct _DRIVER_OBJECT ;

#line 12411
typedef enum _SECURITY_OPERATION_CODE ;

#line 12426
typedef struct _SECURITY_SUBJECT_CONTEXT ;

#line 12448
typedef struct _INITIAL_PRIVILEGE_SET ;

#line 12462
typedef struct _ACCESS_STATE ;

#line 12571
typedef void ;

#line 12585
typedef void ;

#line 12602
typedef struct _IMAGE_INFO ;

#line 12620
typedef void ;

#line 12859
typedef NTSTATUS ;

#line 12878
typedef enum _IO_QUERY_DEVICE_DATA_FORMAT ;

#line 12890
typedef enum _CREATE_FILE_TYPE ;

#line 12905
struct _DEVICE_DESCRIPTION ;

#line 12906
struct _DEVICE_OBJECT ;

#line 12907
struct _DMA_ADAPTER ;

#line 12908
struct _DRIVER_OBJECT ;

#line 12909
struct _DRIVE_LAYOUT_INFORMATION ;

#line 12910
struct _DISK_PARTITION ;

#line 12911
struct _FILE_OBJECT ;

#line 12912
struct _IRP ;

#line 12913
struct _SCSI_REQUEST_BLOCK ;

#line 12919
typedef void ;

#line 12932
typedef void ;

#line 12943
typedef NTSTATUS ;

#line 12955
typedef void ;

#line 12968
typedef void ;

#line 12979
typedef NTSTATUS ;

#line 12990
typedef void ;

#line 13001
typedef void ;

#line 13011
typedef NTSTATUS ;

#line 13025
typedef BOOLEAN ;

#line 13038
typedef BOOLEAN ;

#line 13051
typedef BOOLEAN ;

#line 13068
typedef BOOLEAN ;

#line 13078
typedef BOOLEAN ;

#line 13092
typedef BOOLEAN ;

#line 13106
typedef BOOLEAN ;

#line 13118
typedef BOOLEAN ;

#line 13127
typedef BOOLEAN ;

#line 13141
typedef BOOLEAN ;

#line 13161
typedef void ;

#line 13167
typedef void ;

#line 13179
typedef void ;

#line 13193
typedef BOOLEAN ;

#line 13207
typedef BOOLEAN ;

#line 13219
typedef BOOLEAN ;

#line 13227
typedef BOOLEAN ;

#line 13239
typedef BOOLEAN ;

#line 13253
typedef NTSTATUS ;

#line 13262
typedef NTSTATUS ;

#line 13275
typedef NTSTATUS ;

#line 13282
typedef NTSTATUS ;

#line 13289
typedef BOOLEAN ;

#line 13304
typedef BOOLEAN ;

#line 13319
typedef BOOLEAN ;

#line 13327
typedef BOOLEAN ;

#line 13336
typedef BOOLEAN ;

#line 13350
typedef struct _FAST_IO_DISPATCH ;

#line 13386
typedef enum _IO_ALLOCATION_ACTION ;

#line 13396
typedef IO_ALLOCATION_ACTION ;

#line 13410
typedef struct _IO_SECURITY_CONTEXT ;

#line 13434
typedef struct _VPB ;

#line 13482
typedef struct _ADAPTER_OBJECT ;

#line 13491
typedef struct _WAIT_CONTEXT_BLOCK ;

#line 13503
typedef struct _CONTROLLER_OBJECT ;

#line 13537
typedef struct _DEVICE_OBJECT ;

#line 13575
typedef struct _DEVICE_OBJECT ;

#line 13578
struct _DEVICE_OBJECT_POWER_EXTENSION ;

typedef struct _DEVOBJ_EXTENSION ;

#line 13608
typedef struct _DRIVER_EXTENSION ;

#line 13645
typedef struct _DRIVER_OBJECT ;

#line 13706
typedef struct _DRIVER_OBJECT ;

#line 13715
typedef struct _SECTION_OBJECT_POINTERS ;

#line 13720
typedef SECTION_OBJECT_POINTERS ;

#line 13726
typedef struct _IO_COMPLETION_CONTEXT ;

#line 13759
typedef struct _FILE_OBJECT ;

#line 13788
typedef struct _FILE_OBJECT ;

#line 13828
typedef struct _IRP ;

#line 14078
typedef NTSTATUS ;

#line 14163
typedef enum _DEVICE_RELATION_TYPE ;

#line 14171
typedef struct _DEVICE_RELATIONS ;

#line 14176
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE ;

#line 14185
typedef struct _INTERFACE ;

#line 14196
typedef struct _DEVICE_CAPABILITIES ;

#line 14229
typedef struct _POWER_SEQUENCE ;

#line 14235
typedef enum  {
	BusQueryDeviceID = 0,
	BusQueryHardwareIDs = 1,
	BusQueryCompatibleIDs = 2,
	BusQueryInstanceID = 3,
	BusQueryDeviceSerialNumber = 4
} ;

typedef ULONG ;

#line 14252
typedef enum  {
	DeviceTextDescription = 0,
	DeviceTextLocationInformation = 1
} ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 14615 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SHARE_ACCESS ;

#line 14635
typedef struct _CONFIGURATION_INFORMATION ;

#line 14848
typedef struct _BOOTDISK_INFORMATION ;

#line 15754
typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK ;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK ;

#line 15764
typedef struct _IO_REMOVE_LOCK_DBG_BLOCK ;

#line 15777
typedef struct _IO_REMOVE_LOCK ;

#line 16009
typedef struct _IO_WORKITEM ;

typedef void ;

#line 16100
typedef enum  {
	DevicePropertyDeviceDescription,
	DevicePropertyHardwareID,
	DevicePropertyCompatibleIDs,
	DevicePropertyBootConfiguration,
	DevicePropertyBootConfigurationTranslated,
	DevicePropertyClassName,
	DevicePropertyClassGuid,
	DevicePropertyDriverKeyName,
	DevicePropertyManufacturer,
	DevicePropertyFriendlyName,
	DevicePropertyLocationInformation,
	DevicePropertyPhysicalDeviceObjectName,
	DevicePropertyBusTypeGuid,
	DevicePropertyLegacyBusType,
	DevicePropertyBusNumber,
	DevicePropertyEnumeratorName,
	DevicePropertyAddress,
	DevicePropertyUINumber
} ;

typedef BOOLEAN ;

#line 16129
typedef struct _DMA_ADAPTER ;

#line 16135
typedef ULONG ;

#line 16148
typedef struct _PNP_BUS_INFORMATION ;

#line 16162
typedef struct _LEGACY_BUS_INFORMATION ;

#line 16168
typedef struct _BUS_INTERFACE_STANDARD ;

#line 16190
typedef BOOLEAN ;

#line 16194
typedef NTSTATUS ;

#line 16203
typedef NTSTATUS ;

#line 16206
typedef NTSTATUS ;

#line 16210
typedef NTSTATUS ;

#line 16214
typedef NTSTATUS ;

#line 16218
typedef void ;

#line 16222
typedef NTSTATUS ;

#line 16227
typedef void ;

#line 16231
typedef struct _ACPI_INTERFACE_STANDARD ;

#line 16255
typedef enum _ACPI_REG_TYPE ;

#line 16268
typedef USHORT ;

#line 16272
typedef void ;

#line 16278
typedef struct ACPI_REGS_INTERFACE_STANDARD ;

#line 16300
typedef struct  {
	PVOID LinkNode ;
	ULONG StaticVector ;
	UCHAR Flags ;
} ;

#line 16314
typedef NTSTATUS ;

#line 16329
typedef NTSTATUS ;

#line 16336
typedef void ;

#line 16343
typedef struct _INT_ROUTE_INTERFACE_STANDARD ;

#line 16366
typedef struct _IO_ASSIGNED_RESOURCES ;

#line 16490
typedef enum _IO_NOTIFICATION_EVENT_CATEGORY ;

#line 16504
typedef NTSTATUS ;

#line 16537
typedef void ;

#line 16573
typedef enum _ARBITER_ACTION ;

#line 16586
typedef struct _ARBITER_CONFLICT_INFO ;

#line 16608
typedef struct _ARBITER_PARAMETERS ;

#line 16719
typedef enum _ARBITER_REQUEST_SOURCE ;

#line 16731
typedef enum _ARBITER_RESULT ;

#line 16761
typedef struct _ARBITER_LIST_ENTRY ;

#line 16832
typedef NTSTATUS ;

#line 16853
typedef struct _ARBITER_INTERFACE ;

#line 16880
typedef enum _RESOURCE_TRANSLATION_DIRECTION ;

#line 16889
typedef NTSTATUS ;

#line 16901
typedef NTSTATUS ;

#line 16915
typedef struct _TRANSLATOR_INTERFACE ;

#line 16931
typedef NTSTATUS ;

#line 16945
typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE ;

#line 16959
typedef struct _PLUGPLAY_NOTIFICATION_HEADER ;

#line 16972
typedef struct _HWPROFILE_CHANGE_NOTIFICATION ;

#line 16986
typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION ;

#line 17006
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION ;

#line 17026
typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION ;

#line 17054
typedef struct _DEVICE_DESCRIPTION ;

#line 17086
typedef BOOLEAN ;

#line 17333
typedef void ;

#line 17339
typedef struct _DEVICE_CONTROL_CONTEXT ;

#line 17349
typedef PBUS_HANDLER ;

#line 17355
typedef void ;

#line 17365
typedef enum _HAL_QUERY_INFORMATION_CLASS ;

#line 17381
typedef enum _HAL_SET_INFORMATION_CLASS ;

#line 17388
typedef NTSTATUS ;

#line 17405
typedef NTSTATUS ;

#line 17420
typedef void ;

#line 17429
typedef void ;

#line 17438
typedef NTSTATUS ;

#line 17447
typedef NTSTATUS ;

#line 17456
typedef NTSTATUS ;

#line 17466
typedef NTSTATUS ;

#line 17475
typedef NTSTATUS ;

#line 17486
typedef struct _PM_DISPATCH_TABLE ;

#line 17492
typedef NTSTATUS ;

#line 17505
typedef struct _DMA_ADAPTER ;

#line 17520
typedef NTSTATUS ;

#line 17543
typedef BOOLEAN ;

#line 17553
typedef NTSTATUS ;

#line 17566
typedef void ;

#line 17572
typedef void ;

#line 17578
typedef BOOLEAN ;

#line 17588
typedef struct  {
	ULONG Version ;
	pHalQuerySystemInformation HalQuerySystemInformation ;
	pHalSetSystemInformation HalSetSystemInformation ;
	pHalQueryBusSlots HalQueryBusSlots ;
	ULONG Spare1 ;
	pHalExamineMBR HalExamineMBR ;
	pHalIoAssignDriveLetters HalIoAssignDriveLetters ;
	pHalIoReadPartitionTable HalIoReadPartitionTable ;
	pHalIoSetPartitionInformation HalIoSetPartitionInformation ;
	pHalIoWritePartitionTable HalIoWritePartitionTable ;
	pHalHandlerForBus HalReferenceHandlerForBus ;
	pHalReferenceBusHandler HalReferenceBusHandler ;
	pHalReferenceBusHandler HalDereferenceBusHandler ;
	pHalInitPnpDriver HalInitPnpDriver ;
	pHalInitPowerManagement HalInitPowerManagement ;
	pHalGetDmaAdapter HalGetDmaAdapter ;
	pHalGetInterruptTranslator HalGetInterruptTranslator ;
} ;

#line 17650
typedef struct _HAL_BUS_INFORMATION ;

#line 17658
typedef struct _HAL_PROFILE_SOURCE_INFORMATION ;

#line 17665
typedef struct _HAL_PROFILE_SOURCE_INTERVAL ;

#line 17671
typedef enum _HAL_DISPLAY_BIOS_INFORMATION ;

#line 17678
typedef struct _HAL_POWER_INFORMATION ;

#line 17683
typedef struct _HAL_PROCESSOR_SPEED_INFO ;

#line 17688
typedef struct _HAL_CALLBACKS ;

#line 17694
typedef struct _HAL_PROCESSOR_FEATURE ;

#line 17706
typedef union _MCI_ADDR ;

#line 17716
typedef enum  {
	HAL_MCE_RECORD,
	HAL_MCA_RECORD
} ;

#line 17726
typedef struct _MCA_EXCEPTION ;

#line 17752
typedef void ;

#line 17762
typedef struct _MCA_DRIVER_INFO ;

#line 17772
typedef struct _SCATTER_GATHER_ELEMENT ;

#line 17778

#pragma warning(disable:4200)
#line 17779
typedef struct _SCATTER_GATHER_LIST ;

#line 17784

#pragma warning(default:4200)
#line 17788
typedef struct _DMA_OPERATIONS ;

typedef struct _DMA_ADAPTER ;

#line 17797
typedef void ;

#line 17801
typedef PVOID ;

#line 17808
typedef void ;

#line 17816
typedef NTSTATUS ;

#line 17824
typedef BOOLEAN ;

#line 17833
typedef void ;

#line 17837
typedef void ;

#line 17843
typedef PHYSICAL_ADDRESS ;

#line 17852
typedef ULONG ;

#line 17856
typedef ULONG ;

#line 17860
typedef void ;

#line 17868
typedef NTSTATUS ;

#line 17880
typedef void ;

#line 17887
typedef struct _DMA_OPERATIONS ;

#line 18235
typedef void ;

#line 18321
typedef struct _OBJECT_HANDLE_INFORMATION ;

#line 18402
typedef struct _PCI_SLOT_NUMBER ;

#line 18418
typedef struct _PCI_COMMON_CONFIG ;

#line 18591
typedef struct _PCI_CAPABILITIES_HEADER ;

#line 18600
typedef struct _PCI_PMC ;

#line 18618
typedef struct _PCI_PMCSR ;

#line 18628
typedef struct _PCI_PMCSR_BSE ;

#line 18635
typedef struct _PCI_PM_CAPABILITY ;

#line 18679
typedef struct _PCI_AGP_CAPABILITY ;

#line 18720
typedef struct _PCI_MSI_CAPABILITY ;

#line 18946
typedef void ;

#line 18954
typedef void ;

#line 18963
typedef void ;

#line 18975
typedef struct _PCIBUSDATA ;

#line 18986
typedef ULONG ;

#line 18995
typedef void ;

#line 19000
typedef void ;

#line 19006
typedef struct _PCI_BUS_INTERFACE_STANDARD ;

#line 19028
typedef BOOLEAN ;

#line 19043
typedef struct _PCI_DEVICE_PRESENT_INTERFACE ;

#line 127 "C:/NTDDK/inc/ntddser.h"
typedef struct _SERIALPERF_STATS ;

#line 136
typedef struct _SERIALCONFIG ;

#line 154
typedef struct _SERIAL_LINE_CONTROL ;

#line 160
typedef struct _SERIAL_TIMEOUTS ;

#line 175
typedef struct _SERIAL_QUEUE_SIZE ;

#line 185
typedef struct _SERIAL_BAUD_RATE ;

#line 247
typedef struct _SERIAL_CHARS ;

#line 284
typedef struct _SERIAL_HANDFLOW ;

#line 340
typedef struct _SERIAL_BASIC_SETTINGS ;

#line 353
typedef struct _SERIAL_STATUS ;

#line 433
typedef struct _SERIAL_XOFF_COUNTER ;

#line 539
typedef struct _SERIAL_COMMPROP ;

#line 631
typedef struct _SERENUM_PORT_DESC ;

#line 652
typedef UCHAR ;

#line 658
typedef void ;

#line 665
typedef enum _SERENUM_PORTION ;

#line 671
typedef struct _SERENUM_PORT_PARAMETERS ;

#line 28 "C:/NTDDK/inc/ddk/wdm/wmilib.h"

#pragma once
#line 38
typedef struct  {
	LPCGUID Guid ;
	ULONG InstanceCount ;
	ULONG Flags ;
} ;

#line 45
typedef NTSTATUS ;

#line 101
typedef NTSTATUS ;

#line 162
typedef NTSTATUS ;

#line 206
typedef NTSTATUS ;

#line 253
typedef NTSTATUS ;

#line 306
typedef enum  {
	WmiEventControl,
	WmiDataBlockControl
} ;

#line 312
typedef NTSTATUS ;

#line 355
typedef struct _WMILIB_CONTEXT ;

#line 411
typedef enum  {
	IrpProcessed,
	IrpNotCompleted,
	IrpNotWmi,
	IrpForward
} ;

#line 13 "C:/NTDDK/inc/wmidata.h"
typedef struct _MSWmi_MofData ;

#line 51
typedef struct _MSWmi_ProviderInfo ;

#line 66
typedef struct _MSWmi_PnPDeviceId ;

#line 83
typedef struct _MSWmi_PnPInstanceNames ;

#line 105
typedef struct _MSSmBios_RawSMBiosTables ;

#line 147
typedef struct _MSPower_DeviceEnable ;

#line 165
typedef struct _MSPower_DeviceWakeEnable ;

#line 182
typedef struct _MSNdis_NetworkAddress ;

#line 199
typedef struct _MSNdis_NetworkShortAddress ;

#line 216
typedef struct _MSNdis_NetworkLinkSpeed ;

#line 239
typedef struct _MSNdis_EnumerateAdapter ;

#line 256
typedef struct _MSNdis_NotifyAdapterRemoval ;

#line 273
typedef struct _MSNdis_NotifyAdapterArrival ;

#line 291
typedef struct _MSNdis_NdisEnumerateVc ;

#line 307
typedef struct _MSNdis_NotifyVcRemoval ;

#line 323
typedef struct _MSNdis_NotifyVcArrival ;

#line 338
typedef struct _MSNdis_HardwareStatus ;

#line 356
typedef struct _MSNdis_MediaSupported ;

#line 378
typedef struct _MSNdis_MediaInUse ;

#line 400
typedef struct _MSNdis_MaximumLookahead ;

#line 418
typedef struct _MSNdis_MaximumFrameSize ;

#line 436
typedef struct _MSNdis_LinkSpeed ;

#line 454
typedef struct _MSNdis_TransmitBufferSpace ;

#line 472
typedef struct _MSNdis_ReceiveBufferSpace ;

#line 490
typedef struct _MSNdis_TransmitBlockSize ;

#line 508
typedef struct _MSNdis_ReceiveBlockSize ;

#line 526
typedef struct _MSNdis_VendorID ;

#line 544
typedef struct _MSNdis_VendorDescription ;

#line 561
typedef struct _MSNdis_CurrentPacketFilter ;

#line 579
typedef struct _MSNdis_CurrentLookahead ;

#line 597
typedef struct _MSNdis_DriverVersion ;

#line 615
typedef struct _MSNdis_MaximumTotalSize ;

#line 633
typedef struct _MSNdis_MacOptions ;

#line 651
typedef struct _MSNdis_MediaConnectStatus ;

#line 669
typedef struct _MSNdis_MaximumSendPackets ;

#line 687
typedef struct _MSNdis_VendorDriverVersion ;

#line 705
typedef struct _MSNdis_TransmitsOk ;

#line 723
typedef struct _MSNdis_ReceivesOk ;

#line 741
typedef struct _MSNdis_TransmitsError ;

#line 759
typedef struct _MSNdis_ReceiveError ;

#line 777
typedef struct _MSNdis_ReceiveNoBuffer ;

#line 795
typedef struct _MSNdis_CoHardwareStatus ;

#line 813
typedef struct _MSNdis_CoMediaSupported ;

#line 835
typedef struct _MSNdis_CoMediaInUse ;

#line 857
typedef struct _MSNdis_CoLinkSpeed ;

#line 875
typedef struct _MSNdis_CoVendorId ;

#line 893
typedef struct _MSNdis_CoVendorDescription ;

#line 910
typedef struct _MSNdis_CoDriverVersion ;

#line 928
typedef struct _MSNdis_CoMacOptions ;

#line 946
typedef struct _MSNdis_CoMediaConnectStatus ;

#line 964
typedef struct _MSNdis_CoVendorDriverVersion ;

#line 982
typedef struct _MSNdis_CoMinimumLinkSpeed ;

#line 1000
typedef struct _MSNdis_CoTransmitPdusOk ;

#line 1018
typedef struct _MSNdis_CoReceivePdusOk ;

#line 1036
typedef struct _MSNdis_CoTransmitPduErrors ;

#line 1054
typedef struct _MSNdis_CoReceivePduErrors ;

#line 1072
typedef struct _MSNdis_CoReceivePdusNoBuffer ;

#line 1090
typedef struct _MSNdis_AtmSupportedVcRates ;

#line 1113
typedef struct _MSNdis_AtmSupportedServiceCategory ;

#line 1131
typedef struct _MSNdis_AtmSupportedAalTypes ;

#line 1149
typedef struct _MSNdis_AtmHardwareCurrentAddress ;

#line 1167
typedef struct _MSNdis_AtmMaxActiveVcs ;

#line 1185
typedef struct _MSNdis_AtmMaxActiveVciBits ;

#line 1203
typedef struct _MSNdis_AtmMaxActiveVpiBits ;

#line 1221
typedef struct _MSNdis_AtmMaxAal0PacketSize ;

#line 1239
typedef struct _MSNdis_AtmMaxAal1PacketSize ;

#line 1257
typedef struct _MSNdis_AtmMaxAal34PacketSize ;

#line 1275
typedef struct _MSNdis_AtmMaxAal5PacketSize ;

#line 1293
typedef struct _MSNdis_AtmReceiveCellsOk ;

#line 1311
typedef struct _MSNdis_AtmTransmitCellsOk ;

#line 1329
typedef struct _MSNdis_AtmReceiveCellsDropped ;

#line 1347
typedef struct _MSNdis_EthernetPermanentAddress ;

#line 1365
typedef struct _MSNdis_EthernetCurrentAddress ;

#line 1383
typedef struct _MSNdis_EthernetMulticastList ;

#line 1405
typedef struct _MSNdis_EthernetMaximumMulticastListSize ;

#line 1423
typedef struct _MSNdis_EthernetMacOptions ;

#line 1441
typedef struct _MSNdis_EthernetReceiveErrorAlignment ;

#line 1459
typedef struct _MSNdis_EthernetOneTransmitCollision ;

#line 1477
typedef struct _MSNdis_EthernetMoreTransmitCollisions ;

#line 1495
typedef struct _MSNdis_TokenRingPermanentAddress ;

#line 1513
typedef struct _MSNdis_TokenRingCurrentAddress ;

#line 1531
typedef struct _MSNdis_TokenRingCurrentFunctional ;

#line 1549
typedef struct _MSNdis_TokenRingCurrentGroup ;

#line 1567
typedef struct _MSNdis_TokenRingLastOpenStatus ;

#line 1585
typedef struct _MSNdis_TokenRingCurrentRingStatus ;

#line 1603
typedef struct _MSNdis_TokenRingCurrentRingState ;

#line 1621
typedef struct _MSNdis_TokenRingLineErrors ;

#line 1639
typedef struct _MSNdis_TokenRingLostFrames ;

#line 1657
typedef struct _MSNdis_FddiLongPermanentAddress ;

#line 1675
typedef struct _MSNdis_FddiLongCurrentAddress ;

#line 1693
typedef struct _MSNdis_FddiLongMulticastList ;

#line 1715
typedef struct _MSNdis_FddiLongMaximumListSize ;

#line 1733
typedef struct _MSNdis_FddiShortPermanentAddress ;

#line 1751
typedef struct _MSNdis_FddiShortCurrentAddress ;

#line 1769
typedef struct _MSNdis_FddiShortMulticastList ;

#line 1791
typedef struct _MSNdis_FddiShortMaximumListSize ;

#line 1809
typedef struct _MSNdis_FddiAttachmentType ;

#line 1827
typedef struct _MSNdis_FddiUpstreamNodeLong ;

#line 1845
typedef struct _MSNdis_FddiDownstreamNodeLong ;

#line 1863
typedef struct _MSNdis_FddiFrameErrors ;

#line 1881
typedef struct _MSNdis_FddiFramesLost ;

#line 1899
typedef struct _MSNdis_FddiRingManagmentState ;

#line 1917
typedef struct _MSNdis_FddiLctFailures ;

#line 1935
typedef struct _MSNdis_FddiLemRejects ;

#line 1953
typedef struct _MSNdis_FddiLConnectionState ;

#line 1972
typedef struct _MSNdis_StatusResetStart ;

#line 1988
typedef struct _MSNdis_StatusResetEnd ;

#line 2004
typedef struct _MSNdis_StatusMediaConnect ;

#line 2020
typedef struct _MSNdis_StatusMediaDisconnect ;

#line 2035
typedef struct _MSNdis_StatusMediaSpecificIndication ;

#line 2057
typedef struct _MSNdis_StatusLinkSpeedChange ;

#line 2075
typedef struct _MSNdis_StatusProtocolBind ;

#line 2092
typedef struct _MSNdis_StatusProtocolUnbind ;

#line 2109
typedef struct _KEYBOARD_PORT_WMI_STD_DATA ;

#line 2152
typedef struct _POINTER_PORT_WMI_STD_DATA ;

#line 2205
typedef struct _MSMouse_ClassInformation ;

#line 2223
typedef struct _MSKeyboard_ClassInformation ;

#line 2241
typedef struct _MSAcpi_ThermalZoneTemperature ;

#line 2304
typedef struct _WMI_DISK_GEOMETRY ;

#line 2342
typedef struct _WMI_DISK_PERFORMANCE ;

#line 2415
typedef struct _MSDiskDriver_Performance ;

#line 2437
typedef struct _STORAGE_FAILURE_PREDICT_STATUS ;

#line 2460
typedef struct _STORAGE_FAILURE_PREDICT_DATA ;

#line 2483
typedef struct _STORAGE_FAILURE_PREDICT_EVENT ;

#line 2513
typedef struct _STORAGE_FAILURE_PREDICT_FUNCTION ;

#line 2528
typedef struct _MSIde_PortDeviceInfo ;

#line 2556
typedef struct _MSSerial_PortName ;

#line 2573
typedef struct _SERIAL_WMI_COMM_DATA ;

#line 2723
typedef struct _SERIAL_WMI_HW_DATA ;

#line 2770
typedef struct _SERIAL_WMI_PERF_DATA ;

#line 2813
typedef struct _SERIAL_WMI_COMMPROP ;

#line 2920
typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS ;

#line 2943
typedef struct _PARALLEL_WMI_LOG_INFO ;

#line 3041
typedef struct _REDBOOK_WMI_STD_DATA ;

#line 3094
typedef struct _REDBOOK_WMI_PERF_DATA ;

#line 3137
typedef struct _RegisteredGuids ;

#line 475 "serial.h"
typedef struct _CONFIG_DATA ;

#line 509
typedef struct _SERIAL_CISR_SW ;

#line 520
typedef struct _SERIAL_FIRMWARE_DATA ;

#line 576
typedef struct _SERIAL_DEVICE_STATE ;

#line 646
typedef struct _SERIAL_DEVICE_EXTENSION ;

#line 1808
typedef struct _SERIAL_MULTIPORT_DISPATCH ;

#line 2157
typedef enum _SERIAL_MEM_COMPARES ;

#line 2164
typedef struct _SERIAL_LIST_DATA ;

#line 2169
typedef struct _SERIAL_GLOBALS ;

#line 2180
typedef struct _SERIAL_USER_DATA ;

#line 2206
typedef struct _SERIAL_PTR_CTX ;

#line 20 "serialp.h"
typedef NTSTATUS ;

#line 26
typedef void ;

#line 835
typedef struct _SERIAL_UPDATE_CHAR ;

#line 846
typedef struct _SERIAL_IOCTL_SYNC ;

#line 32 "modmflow.c"
BOOLEAN SerialDecrementRTSCounter(PVOID Context ) ;

#line 59
BOOLEAN SerialSetDTR(PVOID Context )
{
	#line 83
	PSERIAL_DEVICE_EXTENSION Extension = Context;
	UCHAR ModemControl ;
	#line 86
	ModemControl = READ_PORT_UCHAR(Extension->Controller + (ULONG )(0x04 *
		1));
	ModemControl |= 0x01;
	#line 94
	do
	{
		#line 94
		;
	}
	while(0);
	#line 98
	do
	{
		#line 98
		WRITE_PORT_UCHAR(Extension->Controller + (ULONG )(0x04 * 1),
			ModemControl);
	}
	while(0);
	#line 100
	return 0;
}

#line 104
BOOLEAN SerialClrDTR(PVOID Context )
{
	#line 128
	PSERIAL_DEVICE_EXTENSION Extension = Context;
	UCHAR ModemControl ;
	#line 131
	ModemControl = READ_PORT_UCHAR(Extension->Controller + (ULONG )(0x04 *
		1));
	ModemControl &= ~ 0x01;
	#line 139
	do
	{
		#line 139
		;
	}
	while(0);
	#line 143
	do
	{
		#line 143
		WRITE_PORT_UCHAR(Extension->Controller + (ULONG )(0x04 * 1),
			ModemControl);
	}
	while(0);
	#line 145
	return 0;
}

#line 149
BOOLEAN SerialSetRTS(PVOID Context )
{
	#line 173
	PSERIAL_DEVICE_EXTENSION Extension = Context;
	UCHAR ModemControl ;
	#line 176
	ModemControl = READ_PORT_UCHAR(Extension->Controller + (ULONG )(0x04 *
		1));
	ModemControl |= 0x02;
	#line 184
	do
	{
		#line 184
		;
	}
	while(0);
	#line 188
	do
	{
		#line 188
		WRITE_PORT_UCHAR(Extension->Controller + (ULONG )(0x04 * 1),
			ModemControl);
	}
	while(0);
	#line 190
	return 0;
}

#line 194
BOOLEAN SerialClrRTS(PVOID Context )
{
	#line 218
	PSERIAL_DEVICE_EXTENSION Extension = Context;
	UCHAR ModemControl ;
	#line 221
	ModemControl = READ_PORT_UCHAR(Extension->Controller + (ULONG )(0x04 *
		1));
	ModemControl &= ~ 0x02;
	#line 229
	do
	{
		#line 229
		;
	}
	while(0);
	#line 233
	do
	{
		#line 233
		WRITE_PORT_UCHAR(Extension->Controller + (ULONG )(0x04 * 1),
			ModemControl);
	}
	while(0);
	#line 235
	return 0;
}

#line 239
BOOLEAN SerialSetupNewHandFlow(PSERIAL_DEVICE_EXTENSION Extension ,
	PSERIAL_HANDFLOW NewHandFlow )
{
	#line 268
	SERIAL_HANDFLOW New = * NewHandFlow;
	#line 282
	if(! Extension->DeviceIsOpened ||
		((Extension->HandFlow).ControlHandShake & (ULONG )0x03) !=
		(New.ControlHandShake & (ULONG )0x03))
	{
		#line 290
		do
		{
			#line 290
			;
		}
		while(0);
		#line 292
		if(New.ControlHandShake & (ULONG )0x03)
		{
			#line 305
			if((New.ControlHandShake & (ULONG )0x03) == (ULONG
				)0x02)
			{
				if(Extension->BufferSize - New.XoffLimit >
					Extension->CharsInInterruptBuffer)
				{
					#line 317
					if(Extension->RXHolding & (ULONG )0x01)
					{
						#line 323
						if(Extension->CharsInInterruptBuffer
							> (ULONG )New.XonLimit)
						{
							#line 330
							do
							{
	#line 330
	;
							}
							while(0);
							#line 331
							Extension->RXHolding &=
								~ (ULONG )0x01;
							#line 332
							SerialSetDTR(Extension);
						}
					}
					else
					{
						#line 338
						SerialSetDTR(Extension);
					}
				}
				else
				{
					#line 348
					do
					{
						#line 348
						;
					}
					while(0);
					#line 349
					Extension->RXHolding |= (ULONG )0x01;
					SerialClrDTR(Extension);
				}
			}
			else
			{
				#line 364
				if(Extension->RXHolding & (ULONG )0x01)
				{
					#line 370
					do
					{
						#line 370
						;
					}
					while(0);
					#line 371
					Extension->RXHolding &= ~ (ULONG )0x01;
				}
				#line 375
				SerialSetDTR(Extension);
			}
		}
		else
		{
			#line 389
			if(Extension->RXHolding & (ULONG )0x01)
			{
				#line 395
				do
				{
					#line 395
					;
				}
				while(0);
				#line 396
				Extension->RXHolding &= ~ (ULONG )0x01;
			}
			#line 400
			SerialClrDTR(Extension);
		}
	}
	#line 412
	if(! Extension->DeviceIsOpened || ((Extension->HandFlow).FlowReplace &
		(ULONG )0xc0) != (New.FlowReplace & (ULONG )0xc0))
	{
		#line 420
		do
		{
			#line 420
			;
		}
		while(0);
		#line 422
		if((New.FlowReplace & (ULONG )0xc0) == (ULONG )0x80)
		{
			#line 436
			if(Extension->BufferSize - New.XoffLimit >
				Extension->CharsInInterruptBuffer)
			{
				#line 445
				if(Extension->RXHolding & (ULONG )0x04)
				{
					#line 451
					if(Extension->CharsInInterruptBuffer >
						(ULONG )New.XonLimit)
					{
						#line 458
						do
						{
							#line 458
							;
						}
						while(0);
						#line 459
						Extension->RXHolding &= ~ (ULONG
							)0x04;
						#line 460
						SerialSetRTS(Extension);
					}
				}
				else
				{
					#line 466
					SerialSetRTS(Extension);
				}
			}
			else
			{
				#line 476
				do
				{
					#line 476
					;
				}
				while(0);
				#line 477
				Extension->RXHolding |= (ULONG )0x04;
				SerialClrRTS(Extension);
			}
		}
		else
		{
			#line 482
			if((New.FlowReplace & (ULONG )0xc0) == (ULONG )0x40)
			{
				#line 493
				if(Extension->RXHolding & (ULONG )0x04)
				{
					#line 499
					do
					{
						#line 499
						;
					}
					while(0);
					#line 500
					Extension->RXHolding &= ~ (ULONG )0x04;
				}
				#line 504
				SerialSetRTS(Extension);
			}
			else
			{
				#line 506
				if((New.FlowReplace & (ULONG )0xc0) == (ULONG
					)0xc0)
				{
					#line 515
					if(Extension->RXHolding & (ULONG )0x04)
					{
						#line 521
						do
						{
							#line 521
							;
						}
						while(0);
						#line 522
						Extension->RXHolding &= ~ (ULONG
							)0x04;
					}
					#line 536
					(Extension->HandFlow).FlowReplace &= ~
						(ULONG )0xc0;
					#line 537
					(Extension->HandFlow).FlowReplace |=
						(ULONG )0xc0;
					#line 551
					if(Extension->TXHolding & (ULONG )0x10
						|| (SerialProcessLSR(Extension)
						& (0x20 | 0x40)) != (0x20 |
						0x40) ||
						(Extension->CurrentWriteIrp ||
						Extension->TransmitImmediate ||
						! ((&
						Extension->WriteQueue)->Flink ==
						& Extension->WriteQueue) && !
						Extension->TXHolding))
					{
						#line 560
						SerialSetRTS(Extension);
					}
					else
					{
						#line 572
						Extension->CountOfTryingToLowerRTS
							++;
						#line 573
						SerialPerhapsLowerRTS(Extension)
							;
					}
				}
				else
				{
					#line 587
					if(Extension->RXHolding & (ULONG )0x04)
					{
						#line 593
						do
						{
							#line 593
							;
						}
						while(0);
						#line 594
						Extension->RXHolding &= ~ (ULONG
							)0x04;
					}
					#line 598
					SerialClrRTS(Extension);
				}
			}
		}
	}
	#line 609
	if(! Extension->DeviceIsOpened || ((Extension->HandFlow).FlowReplace &
		(ULONG )0x02) != (New.FlowReplace & (ULONG )0x02))
	{
		#line 613
		if(New.FlowReplace & (ULONG )0x02)
		{
			#line 628
			if(Extension->BufferSize - New.XoffLimit <=
				Extension->CharsInInterruptBuffer)
			{
				#line 635
				Extension->RXHolding |= (ULONG )0x02;
				#line 637
				SerialProdXonXoff(Extension, 0);
			}
		}
		else
		{
			#line 654
			if(Extension->RXHolding & (ULONG )0x02)
			{
				Extension->RXHolding &= ~ (ULONG )0x02;
				#line 662
				SerialProdXonXoff(Extension, 1);
			}
		}
	}
	#line 678
	if(! Extension->DeviceIsOpened || ((Extension->HandFlow).FlowReplace &
		(ULONG )0x01) != (New.FlowReplace & (ULONG )0x01))
	{
		#line 682
		if(New.FlowReplace & (ULONG )0x01)
		{
			#line 695
			;
		}
		else
		{
			#line 707
			if(Extension->TXHolding & (ULONG )0x08)
			{
				Extension->TXHolding &= ~ (ULONG )0x08;
				#line 715
				SerialProdXonXoff(Extension, 1);
			}
		}
	}
	#line 731
	Extension->HandFlow = New;
	#line 733
	return 0;
}

#line 737
BOOLEAN SerialSetHandFlow(PVOID Context )
{
	#line 763
	PSERIAL_IOCTL_SYNC S = Context;
	PSERIAL_DEVICE_EXTENSION Extension = S->Extension;
	PSERIAL_HANDFLOW HandFlow = S->Data;
	#line 767
	SerialSetupNewHandFlow(Extension, HandFlow);
	#line 772
	SerialHandleModemUpdate(Extension, 0);
	#line 777
	return 0;
}

#line 781
BOOLEAN SerialTurnOnBreak(PVOID Context )
{
	#line 806
	PSERIAL_DEVICE_EXTENSION Extension = Context;
	#line 808
	UCHAR OldLineControl ;
	#line 810
	if(((Extension->HandFlow).FlowReplace & (ULONG )0xc0) == (ULONG )0xc0)
	{
		#line 813
		SerialSetRTS(Extension);
	}
	#line 817
	OldLineControl = READ_PORT_UCHAR(Extension->Controller + (ULONG )(0x03 *
		1));
	OldLineControl |= 0x40;
	#line 824
	do
	{
		#line 824
		WRITE_PORT_UCHAR(Extension->Controller + (ULONG )(0x03 * 1),
			OldLineControl);
	}
	while(0);
	#line 826
	Extension->TXHolding |= (ULONG )0x10;
	#line 828
	return 0;
}

#line 832
BOOLEAN SerialTurnOffBreak(PVOID Context )
{
	#line 857
	PSERIAL_DEVICE_EXTENSION Extension = Context;
	#line 859
	UCHAR OldLineControl ;
	#line 861
	if(Extension->TXHolding & (ULONG )0x10)
	{
		#line 878
		OldLineControl = READ_PORT_UCHAR(Extension->Controller + (ULONG
			)(0x03 * 1));
		OldLineControl &= ~ 0x40;
		#line 885
		do
		{
			#line 885
			WRITE_PORT_UCHAR(Extension->Controller + (ULONG )(0x03 *
				1), OldLineControl);
		}
		while(0);
		#line 887
		Extension->TXHolding &= ~ (ULONG )0x10;
		#line 889
		if(! Extension->TXHolding && (Extension->TransmitImmediate ||
			Extension->WriteLength) && Extension->HoldingEmpty)
		{
			#line 894
			do
			{
				#line 894
				do
				{
					#line 894
					WRITE_PORT_UCHAR(Extension->Controller +
						(ULONG )(0x01 * 1), 0);
				}
				while(0);
			}
			while(0);
			#line 895
			do
			{
				#line 895
				do
				{
					#line 895
					WRITE_PORT_UCHAR(Extension->Controller +
						(ULONG )(0x01 * 1), (UCHAR
						)(0x01 | 0x02 | 0x04 | 0x08));
				}
				while(0);
			}
			while(0);
		}
		else
		{
			Extension->CountOfTryingToLowerRTS++;
			SerialPerhapsLowerRTS(Extension);
		}
	}
	#line 912
	return 0;
}

#line 916
BOOLEAN SerialPretendXoff(PVOID Context )
{
	#line 948
	PSERIAL_DEVICE_EXTENSION Extension = Context;
	#line 950
	Extension->TXHolding |= (ULONG )0x08;
	#line 952
	if(((Extension->HandFlow).FlowReplace & (ULONG )0xc0) == (ULONG )0xc0)
	{
		#line 955
		SerialInsertQueueDpc(& Extension->StartTimerLowerRTSDpc,
			(void *  )0, (void *  )0, Extension)
			? Extension->CountOfTryingToLowerRTS++ : 0;
	}
	#line 964
	return 0;
}

#line 968
BOOLEAN SerialPretendXon(PVOID Context )
{
	#line 996
	PSERIAL_DEVICE_EXTENSION Extension = Context;
	#line 998
	if(Extension->TXHolding)
	{
		#line 1015
		Extension->TXHolding &= ~ (ULONG )0x08;
		#line 1017
		if(! Extension->TXHolding && (Extension->TransmitImmediate ||
			Extension->WriteLength) && Extension->HoldingEmpty)
		{
			#line 1022
			do
			{
				#line 1022
				do
				{
					#line 1022
					WRITE_PORT_UCHAR(Extension->Controller +
						(ULONG )(0x01 * 1), 0);
				}
				while(0);
			}
			while(0);
			#line 1023
			do
			{
				#line 1023
				do
				{
					#line 1023
					WRITE_PORT_UCHAR(Extension->Controller +
						(ULONG )(0x01 * 1), (UCHAR
						)(0x01 | 0x02 | 0x04 | 0x08));
				}
				while(0);
			}
			while(0);
		}
	}
	#line 1029
	return 0;
}

#line 1033
void SerialHandleReducedIntBuffer(PSERIAL_DEVICE_EXTENSION Extension )
{
	#line 1069
	if(Extension->RXHolding)
	{
		if(Extension->CharsInInterruptBuffer <= (ULONG
			)(Extension->HandFlow).XonLimit)
		{
			if(Extension->RXHolding & (ULONG )0x01)
			{
				Extension->RXHolding &= ~ (ULONG )0x01;
				SerialSetDTR(Extension);
			}
			#line 1081
			if(Extension->RXHolding & (ULONG )0x04)
			{
				Extension->RXHolding &= ~ (ULONG )0x04;
				SerialSetRTS(Extension);
			}
			#line 1088
			if(Extension->RXHolding & (ULONG )0x02)
			{
				#line 1094
				SerialProdXonXoff(Extension, 1);
			}
		}
	}
}

#line 1107
void SerialProdXonXoff(PSERIAL_DEVICE_EXTENSION Extension , BOOLEAN SendXon )
{
	#line 1149
	if(! Extension->SendXonChar && ! Extension->SendXoffChar &&
		Extension->HoldingEmpty)
	{
		do
		{
			#line 1152
			do
			{
				#line 1152
				WRITE_PORT_UCHAR(Extension->Controller + (ULONG
					)(0x01 * 1), 0);
			}
			while(0);
		}
		while(0);
		#line 1153
		do
		{
			#line 1153
			do
			{
				#line 1153
				WRITE_PORT_UCHAR(Extension->Controller + (ULONG
					)(0x01 * 1), (UCHAR )(0x01 | 0x02 | 0x04
					| 0x08));
			}
			while(0);
		}
		while(0);
	}
	#line 1157
	if(SendXon)
	{
		Extension->SendXonChar = 1;
		Extension->SendXoffChar = 0;
	}
	else
	{
		Extension->SendXonChar = 0;
		Extension->SendXoffChar = 1;
	}
}

#line 1171
ULONG SerialHandleModemUpdate(PSERIAL_DEVICE_EXTENSION Extension , BOOLEAN
	DoingTX )
{
	#line 1214
	ULONG OldTXHolding = Extension->TXHolding;
	#line 1219
	UCHAR ModemStatus ;
	#line 1221
	ModemStatus = READ_PORT_UCHAR(Extension->Controller + (ULONG )(0x06 *
		1));
	#line 1229
	if(Extension->EscapeChar)
	{
		if(ModemStatus & (0x01 | 0x02 | 0x04 | 0x08))
		{
			#line 1236
			SerialPutChar(Extension, Extension->EscapeChar);
			#line 1240
			SerialPutChar(Extension, (UCHAR )0x03);
			#line 1244
			SerialPutChar(Extension, ModemStatus);
		}
	}
	#line 1264
	if((Extension->HandFlow).ControlHandShake & (ULONG )0x40)
	{
		if(ModemStatus & 0x20)
		{
			#line 1273
			Extension->RXHolding &= ~ (ULONG )0x08;
		}
		else
		{
			Extension->RXHolding |= (ULONG )0x08;
		}
	}
	else
	{
		#line 1289
		Extension->RXHolding &= ~ (ULONG )0x08;
	}
	#line 1300
	if(Extension->IsrWaitMask)
	{
		if(Extension->IsrWaitMask & 0x0008 && ModemStatus & 0x01)
		{
			#line 1305
			Extension->HistoryMask |= 0x0008;
		}
		#line 1309
		if(Extension->IsrWaitMask & 0x0010 && ModemStatus & 0x02)
		{
			#line 1312
			Extension->HistoryMask |= 0x0010;
		}
		#line 1316
		if(Extension->IsrWaitMask & 0x0100 && ModemStatus & 0x04)
		{
			#line 1319
			Extension->HistoryMask |= 0x0100;
		}
		#line 1323
		if(Extension->IsrWaitMask & 0x0020 && ModemStatus & 0x08)
		{
			#line 1326
			Extension->HistoryMask |= 0x0020;
		}
		#line 1330
		if(Extension->IrpMaskLocation && Extension->HistoryMask)
		{
			#line 1333
			* Extension->IrpMaskLocation = Extension->HistoryMask;
			#line 1335
			Extension->IrpMaskLocation = (void *  )0;
			Extension->HistoryMask = 0;
			#line 1338
			((Extension->CurrentWaitIrp)->IoStatus).Information =
				sizeof(ULONG );
			SerialInsertQueueDpc(& Extension->CommWaitDpc, (void * 
				)0, (void *  )0, Extension);
		}
	}
	#line 1356
	if((Extension->HandFlow).ControlHandShake & (ULONG )0x38)
	{
		#line 1359
		if((Extension->HandFlow).ControlHandShake & (ULONG )0x08)
		{
			#line 1362
			if(ModemStatus & 0x10)
			{
				Extension->TXHolding &= ~ (ULONG )0x01;
			}
			else
			{
				Extension->TXHolding |= (ULONG )0x01;
			}
		}
		else
		{
			#line 1374
			Extension->TXHolding &= ~ (ULONG )0x01;
		}
		#line 1378
		if((Extension->HandFlow).ControlHandShake & (ULONG )0x10)
		{
			#line 1381
			if(ModemStatus & 0x20)
			{
				Extension->TXHolding &= ~ (ULONG )0x02;
			}
			else
			{
				Extension->TXHolding |= (ULONG )0x02;
			}
		}
		else
		{
			#line 1393
			Extension->TXHolding &= ~ (ULONG )0x02;
		}
		#line 1397
		if((Extension->HandFlow).ControlHandShake & (ULONG )0x20)
		{
			#line 1400
			if(ModemStatus & 0x80)
			{
				Extension->TXHolding &= ~ (ULONG )0x04;
			}
			else
			{
				Extension->TXHolding |= (ULONG )0x04;
			}
		}
		else
		{
			#line 1412
			Extension->TXHolding &= ~ (ULONG )0x04;
		}
		#line 1422
		if(! OldTXHolding && Extension->TXHolding &&
			((Extension->HandFlow).FlowReplace & (ULONG )0xc0) ==
			(ULONG )0xc0)
		{
			SerialInsertQueueDpc(& Extension->StartTimerLowerRTSDpc,
				(void *  )0, (void *  )0, Extension)
				? Extension->CountOfTryingToLowerRTS++ : 0;
		}
		#line 1444
		if(! DoingTX && OldTXHolding && ! Extension->TXHolding)
		{
			if(! Extension->TXHolding &&
				(Extension->TransmitImmediate ||
				Extension->WriteLength) &&
				Extension->HoldingEmpty)
			{
				do
				{
					#line 1451
					do
					{
						#line 1451
						WRITE_PORT_UCHAR(Extension->Controller
							+ (ULONG )(0x01 * 1),
							0);
					}
					while(0);
				}
				while(0);
				#line 1452
				do
				{
					#line 1452
					do
					{
						#line 1452
						WRITE_PORT_UCHAR(Extension->Controller
							+ (ULONG )(0x01 * 1),
							(UCHAR )(0x01 | 0x02 |
							0x04 | 0x08));
					}
					while(0);
				}
				while(0);
			}
		}
	}
	else
	{
		#line 1471
		if(Extension->TXHolding & ((ULONG )0x04 | (ULONG )0x02 | (ULONG
			)0x01))
		{
			#line 1475
			Extension->TXHolding &= ~ ((ULONG )0x04 | (ULONG )0x02 |
				(ULONG )0x01);
			#line 1480
			if(! DoingTX && OldTXHolding && ! Extension->TXHolding)
			{
				if(! Extension->TXHolding &&
					(Extension->TransmitImmediate ||
					Extension->WriteLength) &&
					Extension->HoldingEmpty)
				{
					do
					{
						#line 1487
						do
						{
							#line 1487
							WRITE_PORT_UCHAR(Extension
								->Controller +
								(ULONG )(0x01 *
								1), 0);
						}
						while(0);
					}
					while(0);
					#line 1488
					do
					{
						#line 1488
						do
						{
							#line 1488
							WRITE_PORT_UCHAR(Extension
								->Controller +
								(ULONG )(0x01 *
								1), (UCHAR
								)(0x01 | 0x02 |
								0x04 | 0x08));
						}
						while(0);
					}
					while(0);
				}
			}
		}
	}
	#line 1498
	return (ULONG )ModemStatus;
}

BOOLEAN SerialPerhapsLowerRTS(PVOID Context )
{
	#line 1534
	PSERIAL_DEVICE_EXTENSION Extension = Context;
	#line 1543
	if(((Extension->HandFlow).FlowReplace & (ULONG )0xc0) == (ULONG )0xc0)
	{
		#line 1561
		if(Extension->TXHolding & (ULONG )0x10 ||
			(Extension->CurrentWriteIrp ||
			Extension->TransmitImmediate || ! ((&
			Extension->WriteQueue)->Flink == &
			Extension->WriteQueue) && ! Extension->TXHolding))
		{
			#line 1566
			;
		}
		else
		{
			#line 1581
			if((SerialProcessLSR(Extension) & (0x20 | 0x40)) !=
				(0x20 | 0x40))
			{
				#line 1589
				SerialInsertQueueDpc(&
					Extension->StartTimerLowerRTSDpc,
					(void *  )0, (void *  )0, Extension)
					? Extension->CountOfTryingToLowerRTS++
					: 0;
			}
			else
			{
				#line 1603
				SerialClrRTS(Extension);
			}
		}
	}
	#line 1618
	Extension->CountOfTryingToLowerRTS--;
	#line 1620
	return 0;
}

void SerialStartTimerLowerRTS(PKDPC Dpc , PVOID DeferredContext , PVOID
	SystemContext1 , PVOID SystemContext2 )
{
	#line 1657
	PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
	LARGE_INTEGER CharTime ;
	KIRQL OldIrql ;
	#line 1661
	Dpc;
	SystemContext1;
	SystemContext2;
	#line 1666
	do
	{
		#line 1666
		;
	}
	while(0);
	#line 1678
	* & OldIrql = KfAcquireSpinLock(& Extension->ControlLock);
	#line 1680
	CharTime = SerialGetCharTime(Extension);
	#line 1685
	KfReleaseSpinLock(& Extension->ControlLock, OldIrql);
	#line 1687
	CharTime.QuadPart = - CharTime.QuadPart;
	#line 1689
	if(SerialSetTimer(& Extension->LowerRTSTimer, CharTime, &
		Extension->PerhapsLowerRTSDpc, Extension))
	{
		#line 1703
		KeSynchronizeExecution(Extension->Interrupt,
			SerialDecrementRTSCounter, Extension);
	}
	#line 1711
	SerialDpcEpilogue(Extension, Dpc);
}

#line 1715
void SerialInvokePerhapsLowerRTS(PKDPC Dpc , PVOID DeferredContext , PVOID
	SystemContext1 , PVOID SystemContext2 )
{
	#line 1749
	PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
	#line 1751
	Dpc;
	SystemContext1;
	SystemContext2;
	#line 1755
	KeSynchronizeExecution(Extension->Interrupt, SerialPerhapsLowerRTS,
		Extension);
	#line 1761
	SerialDpcEpilogue(Extension, Dpc);
}

BOOLEAN SerialDecrementRTSCounter(PVOID Context )
{
	#line 1797
	PSERIAL_DEVICE_EXTENSION Extension = Context;
	#line 1799
	Extension->CountOfTryingToLowerRTS--;
	#line 1801
	return 0;
}

#line 16 "C:/NTDDK/inc/stddef.h"

#pragma once
#line 77
typedef int ;

#line 86
typedef unsigned int ;

#line 95
typedef int ;

#line 105
typedef unsigned int ;

#line 112
typedef unsigned short ;

#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"

#pragma once
#line 32

#pragma pack(push, 8)
#line 72
typedef enum _EXCEPTION_DISPOSITION ;

#line 89
struct _EXCEPTION_RECORD ;

#line 90
struct _CONTEXT ;

#line 155

#pragma pack(pop)
#line 25 "C:/NTDDK/inc/ntdef.h"

#pragma once
#line 15 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"

#pragma once
#line 66
typedef wchar_t ;

#line 67
typedef wchar_t ;

#line 127 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long ;

#line 25 "C:/NTDDK/inc/basetsd.h"

#pragma once
#line 36
typedef int ;

#line 37
typedef int ;

#line 43
typedef unsigned int ;

#line 44
typedef unsigned int ;

#line 45
typedef unsigned int ;

#line 84
typedef int ;

#line 85
typedef unsigned int ;

typedef long ;

#line 88
typedef unsigned long ;

#line 248
typedef unsigned short ;

#line 249
typedef short ;

#line 250
typedef unsigned long ;

#line 288
typedef ULONG_PTR ;

#line 289
typedef LONG_PTR ;

#line 295
typedef ULONG_PTR ;

#line 301
typedef __int64 ;

#line 302
typedef __int64 ;

#line 309
typedef unsigned __int64 ;

#line 310
typedef unsigned __int64 ;

#line 311
typedef unsigned __int64 ;

#line 217 "C:/NTDDK/inc/ntdef.h"
typedef void ;

#line 218
typedef void ;

#line 266
typedef char ;

#line 267
typedef short ;

#line 268
typedef long ;

#line 276
typedef wchar_t ;

#line 282
typedef WCHAR ;

#line 283
typedef WCHAR ;

#line 284
typedef const WCHAR ;

#line 285
typedef WCHAR ;

#line 286
typedef WCHAR ;

typedef const WCHAR ;

#line 293
typedef CHAR ;

#line 294
typedef CHAR ;

typedef const CHAR ;

#line 297
typedef CHAR ;

#line 298
typedef CHAR ;

#line 299
typedef const CHAR ;

#line 321
typedef char ;

#line 322
typedef unsigned char ;

#line 326
typedef LPSTR ;

#line 327
typedef LPSTR ;

#line 328
typedef LPCSTR ;

#line 337
typedef double ;

typedef struct _QUAD ;

#line 349
typedef SHORT ;

#line 350
typedef LONG ;

#line 351
typedef QUAD ;

#line 360
typedef unsigned char ;

#line 361
typedef unsigned short ;

#line 362
typedef unsigned long ;

#line 363
typedef QUAD ;

#line 369
typedef UCHAR ;

#line 370
typedef USHORT ;

#line 371
typedef ULONG ;

#line 372
typedef UQUAD ;

#line 378
typedef signed char ;

#line 379
typedef SCHAR ;

#line 394
typedef void ;

#line 400
typedef HANDLE ;

#line 406
typedef UCHAR ;

#line 407
typedef USHORT ;

#line 408
typedef ULONG ;

#line 414
typedef LONG ;

#line 478
typedef char ;

#line 479
typedef short ;

#line 480
typedef ULONG ;

typedef CCHAR ;

#line 483
typedef CSHORT ;

#line 484
typedef CLONG ;

#line 492
typedef ULONG ;

#line 493
typedef PULONG ;

#line 494
typedef USHORT ;

#line 500
typedef ULONG ;

#line 501
typedef ULONG ;

#line 508
typedef LONG ;

typedef NTSTATUS ;

#line 602
typedef struct _FLOAT128 ;

#line 607
typedef FLOAT128 ;

#line 621
typedef __int64 ;

#line 622
typedef unsigned __int64 ;

#line 639
typedef LONGLONG ;

#line 640
typedef ULONGLONG ;

#line 644
typedef LONGLONG ;

#line 649
typedef union _LARGE_INTEGER ;

#line 662
typedef LARGE_INTEGER ;

#line 668
typedef union _ULARGE_INTEGER ;

#line 681
typedef ULARGE_INTEGER ;

#line 690
typedef struct _LUID ;

#line 696
typedef ULONGLONG ;

#line 697
typedef DWORDLONG ;

#line 707
typedef LARGE_INTEGER ;

#line 831

#pragma warning(push)

#pragma warning(disable:4035)
__inline ULONGLONG __stdcall Int64ShllMod32___7(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 842
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    
		};
}

#line 845
__inline LONGLONG __stdcall Int64ShraMod32___7(LONGLONG Value , ULONG ShiftCount
	)
{
	#line 852
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    
		};
}

#line 855
__inline ULONGLONG __stdcall Int64ShrlMod32___7(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 862
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    
		};
}


#pragma warning(pop)
#line 956
typedef enum _EVENT_TYPE ;

#line 965
typedef enum _TIMER_TYPE ;

#line 974
typedef enum _WAIT_TYPE ;

#line 983
typedef CHAR ;

#line 984
typedef const char ;

#line 991
typedef struct _STRING ;

#line 999
typedef STRING ;

typedef STRING ;

#line 1002
typedef PSTRING ;

typedef STRING ;

#line 1005
typedef PSTRING ;

#line 1011
typedef struct _CSTRING ;

#line 1016
typedef CSTRING ;

#line 1019
typedef STRING ;

#line 1020
typedef PSTRING ;

#line 1027
typedef struct _UNICODE_STRING ;

#line 1036
typedef UNICODE_STRING ;

#line 1037
typedef const UNICODE_STRING ;

#line 1046
typedef UCHAR ;

#line 1047
typedef BOOLEAN ;

#line 1057
typedef struct _LIST_ENTRY ;

#line 1067
typedef struct _SINGLE_LIST_ENTRY ;

#line 1078
typedef struct LIST_ENTRY32 ;

#line 1082
typedef LIST_ENTRY32 ;

typedef struct LIST_ENTRY64 ;

#line 1088
typedef LIST_ENTRY64 ;

#line 1127
typedef struct _STRING32 ;

#line 1132
typedef STRING32 ;

typedef STRING32 ;

#line 1135
typedef UNICODE_STRING32 ;

typedef STRING32 ;

#line 1138
typedef ANSI_STRING32 ;

#line 1141
typedef struct _STRING64 ;

#line 1146
typedef STRING64 ;

typedef STRING64 ;

#line 1149
typedef UNICODE_STRING64 ;

typedef STRING64 ;

#line 1152
typedef ANSI_STRING64 ;

#line 1173
typedef struct _OBJECT_ATTRIBUTES ;

#line 1181
typedef OBJECT_ATTRIBUTES ;

#line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID ;

#line 70
typedef GUID ;

#line 75
typedef const GUID ;

#line 81
typedef GUID ;

#line 82
typedef IID ;

#line 85
typedef GUID ;

#line 86
typedef CLSID ;

#line 89
typedef GUID ;

#line 90
typedef FMTID ;

#line 16 "C:/NTDDK/inc/string.h"

#pragma once
#line 1233 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECTID ;

#line 1288
struct _CONTEXT ;

#line 1289
struct _EXCEPTION_RECORD ;

typedef EXCEPTION_DISPOSITION ;

#line 1306
typedef UCHAR ;

typedef KIRQL ;

#line 1316
typedef enum _NT_PRODUCT_TYPE ;

#line 1329
typedef enum _SUITE_TYPE ;

#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD ;

#line 76
typedef struct _ETHREAD ;

#line 77
typedef struct _EPROCESS ;

#line 78
typedef struct _PEB ;

#line 79
typedef struct _KINTERRUPT ;

#line 80
typedef struct _IO_TIMER ;

#line 81
typedef struct _OBJECT_TYPE ;

#line 82
typedef struct _CALLBACK_OBJECT ;

#line 83
typedef struct _DEVICE_HANDLER_OBJECT ;

#line 84
typedef struct _BUS_HANDLER ;

#line 143
typedef union _SLIST_HEADER ;

#line 204
typedef CCHAR ;

typedef enum _MODE ;

#line 222
struct _KAPC ;

typedef void ;

#line 232
typedef void ;

#line 242
typedef void ;

#line 248
typedef BOOLEAN ;

#line 254
typedef BOOLEAN ;

#line 265
typedef struct _KAPC ;

#line 292
struct _KDPC ;

typedef void ;

#line 351
typedef enum _KDPC_IMPORTANCE ;

#line 361
typedef struct _KDPC ;

#line 377
typedef PVOID ;

typedef void ;

#line 392
typedef struct _KIPI_COUNTS ;

#line 443
typedef struct _MDL ;

#line 532
typedef PVOID ;

#line 538
typedef PVOID ;

#line 544
typedef PVOID ;

typedef ULONG ;

#line 547
typedef ACCESS_MASK ;

#line 597
typedef struct _GENERIC_MAPPING ;

#line 603
typedef GENERIC_MAPPING ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES ;

#line 622
typedef LUID_AND_ATTRIBUTES ;

#line 623
typedef LUID_AND_ATTRIBUTES_ARRAY ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 642 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACL ;

#line 649
typedef ACL ;

#line 681
typedef struct _PRIVILEGE_SET ;

#line 735
typedef enum _SECURITY_IMPERSONATION_LEVEL ;

#line 753
typedef BOOLEAN ;

#line 762
typedef struct _SECURITY_QUALITY_OF_SERVICE ;

#line 774
typedef struct _SE_IMPERSONATION_STATE ;

#line 782
typedef ULONG ;

#line 809
typedef ULONG ;

#line 810
typedef KAFFINITY ;

#line 816
typedef LONG ;

#line 824
typedef ULONG_PTR ;

#line 825
typedef KSPIN_LOCK ;

#line 833
typedef void ;

#line 842
typedef enum _KPROFILE_SOURCE ;

#line 1079
typedef NTSTATUS ;

#line 1088
typedef struct _RTL_QUERY_REGISTRY_TABLE ;

#line 1952

#pragma warning(push)

#pragma warning(disable:4035)
#line 2019

#pragma warning(pop)
#line 2214
typedef struct _TIME_FIELDS ;

#line 2224
typedef TIME_FIELDS ;

#line 2499
typedef struct _RTL_BITMAP ;

#line 2503
typedef RTL_BITMAP ;

#line 2627
typedef struct _RTL_BITMAP_RUN ;

#line 2633
typedef RTL_BITMAP_RUN ;

#line 2886
typedef struct _RTL_RANGE ;

#line 2924
typedef struct _RTL_RANGE_LIST ;

#line 2950
typedef struct _RANGE_LIST_ITERATOR ;

#line 3019
typedef BOOLEAN ;

#line 3155
typedef struct _OSVERSIONINFOA ;

#line 3164
typedef struct _OSVERSIONINFOW ;

#line 3177
typedef OSVERSIONINFOA ;

#line 3178
typedef POSVERSIONINFOA ;

#line 3179
typedef LPOSVERSIONINFOA ;

#line 3182
typedef struct _OSVERSIONINFOEXA ;

#line 3195
typedef struct _OSVERSIONINFOEXW ;

#line 3213
typedef OSVERSIONINFOEXA ;

#line 3214
typedef POSVERSIONINFOEXA ;

#line 3215
typedef LPOSVERSIONINFOEXA ;

#line 3648
typedef struct _IO_STATUS_BLOCK ;

#line 3669
typedef void ;

#line 3685
typedef enum _FILE_INFORMATION_CLASS ;

#line 3731
typedef struct _FILE_BASIC_INFORMATION ;

#line 3739
typedef struct _FILE_STANDARD_INFORMATION ;

#line 3747
typedef struct _FILE_POSITION_INFORMATION ;

#line 3751
typedef struct _FILE_ALIGNMENT_INFORMATION ;

#line 3755
typedef struct _FILE_NAME_INFORMATION ;

#line 3760
typedef struct _FILE_NETWORK_OPEN_INFORMATION ;

#line 3770
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION ;

#line 3775
typedef struct _FILE_DISPOSITION_INFORMATION ;

#line 3779
typedef struct _FILE_END_OF_FILE_INFORMATION ;

#line 3784
typedef struct _FILE_FULL_EA_INFORMATION ;

#line 3798
typedef enum _FSINFOCLASS ;

#line 3810
typedef struct _FILE_FS_DEVICE_INFORMATION ;

#line 3820
typedef union _FILE_SEGMENT_ELEMENT ;

#line 3829
typedef enum _INTERFACE_TYPE ;

#line 3854
typedef enum _DMA_WIDTH ;

#line 3865
typedef enum _DMA_SPEED ;

#line 3879
typedef void ;

#line 3880
typedef void ;

#line 3888
typedef enum _BUS_DATA_TYPE ;

#line 3910
typedef struct _IO_ERROR_LOG_PACKET ;

#line 3931
typedef struct _IO_ERROR_LOG_MESSAGE ;

#line 4074
typedef struct _KEY_BASIC_INFORMATION ;

#line 4081
typedef struct _KEY_NODE_INFORMATION ;

#line 4091
typedef struct _KEY_FULL_INFORMATION ;

#line 4106
typedef struct _KEY_NAME_INFORMATION ;

#line 4112
typedef enum _KEY_INFORMATION_CLASS ;

#line 4122
typedef struct _KEY_WRITE_TIME_INFORMATION ;

#line 4126
typedef enum _KEY_SET_INFORMATION_CLASS ;

#line 4134
typedef struct _KEY_VALUE_BASIC_INFORMATION ;

#line 4141
typedef struct _KEY_VALUE_FULL_INFORMATION ;

#line 4151
typedef struct _KEY_VALUE_PARTIAL_INFORMATION ;

#line 4158
typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ;

#line 4164
typedef struct _KEY_VALUE_ENTRY ;

#line 4171
typedef enum _KEY_VALUE_INFORMATION_CLASS ;

#line 4210
typedef struct _OBJECT_NAME_INFORMATION ;

#line 4221
typedef enum _SECTION_INHERIT ;

#line 4294
typedef struct _CLIENT_ID ;

#line 4298
typedef CLIENT_ID ;

#line 4315
typedef struct _NT_TIB ;

#line 4327
typedef NT_TIB ;

#line 4332
typedef enum _PROCESSINFOCLASS ;

#line 4366
typedef enum _THREADINFOCLASS ;

#line 4395
typedef struct _PROCESS_WS_WATCH_INFORMATION ;

#line 4405
typedef struct _PROCESS_BASIC_INFORMATION ;

#line 4413
typedef PROCESS_BASIC_INFORMATION ;

#line 4422
typedef struct _PROCESS_DEVICEMAP_INFORMATION ;

#line 4440
typedef struct _PROCESS_SESSION_INFORMATION ;

#line 4454
typedef struct _QUOTA_LIMITS ;

#line 4462
typedef QUOTA_LIMITS ;

#line 4472
typedef struct _IO_COUNTERS ;

#line 4480
typedef IO_COUNTERS ;

#line 4488
typedef struct _VM_COUNTERS ;

#line 4501
typedef VM_COUNTERS ;

#line 4508
typedef struct _POOLED_USAGE_AND_LIMITS ;

#line 4519
typedef POOLED_USAGE_AND_LIMITS ;

#line 4528
typedef struct _PROCESS_ACCESS_TOKEN ;

#line 4555
typedef struct _KERNEL_USER_TIMES ;

#line 4561
typedef KERNEL_USER_TIMES ;

#line 4587
typedef enum _SYSTEM_POWER_STATE ;

#line 4598
typedef enum  {
	PowerActionNone = 0,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
} ;

typedef enum _DEVICE_POWER_STATE ;

#line 4618
typedef union _POWER_STATE ;

#line 4623
typedef enum _POWER_STATE_TYPE ;

#line 4654
typedef ULONG ;

typedef enum  {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
} ;

#line 4663
typedef enum  {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation
} ;

#line 4690
typedef ULONG ;

typedef LONG ;

#line 4693
typedef ULONG ;

#line 4719
typedef union _MCI_STATS ;

#line 4978
typedef struct _KPCR ;

#line 5006
typedef KPCR ;

#line 5012
typedef struct _KFLOATING_SAVE ;

#line 5153
typedef enum _INTERLOCKED_RESULT ;

#line 5252

#pragma warning(disable:4035)
#line 6994
typedef struct _KSYSTEM_TIME ;

#line 7014

#pragma warning(push)

#pragma warning(disable:4164)
#line 7019

#pragma function(_enable)
#line 7020

#pragma function(_disable)
#line 7024

#pragma warning(pop)
#line 7085
typedef struct _FLOATING_SAVE_AREA ;

#line 7097
typedef FLOATING_SAVE_AREA ;

#line 7109
typedef struct _CONTEXT ;

#line 7197
typedef CONTEXT ;

#line 7826
typedef void ;

#line 7850
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ;

#line 7899
typedef struct _KUSER_SHARED_DATA ;

#line 8123
typedef enum _CM_SERVICE_NODE_TYPE ;

#line 8132
typedef enum _CM_SERVICE_LOAD_TYPE ;

#line 8140
typedef enum _CM_ERROR_CONTROL_TYPE ;

#line 8172
typedef int ;

#line 8198
typedef enum _CM_SHARE_DISPOSITION ;

#line 8211
typedef PVOID ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST ;

#line 8443
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR ;

#line 8454
typedef struct _CM_RESOURCE_LIST ;

#line 8471
typedef struct _DEVICE_FLAGS ;

#line 8485
typedef struct _CM_COMPONENT_INFORMATION ;

#line 8503
typedef struct _CM_ROM_BLOCK ;

#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 8518 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_INT13_DRIVE_PARAMETER ;

#line 8532
typedef struct _CM_MCA_POS_DATA ;

#line 8544
typedef struct _EISA_MEMORY_TYPE ;

#line 8554
typedef struct _EISA_MEMORY_CONFIGURATION ;

#line 8567
typedef struct _EISA_IRQ_DESCRIPTOR ;

#line 8575
typedef struct _EISA_IRQ_CONFIGURATION ;

#line 8585
typedef struct _DMA_CONFIGURATION_BYTE0 ;

#line 8592
typedef struct _DMA_CONFIGURATION_BYTE1 ;

#line 8599
typedef struct _EISA_DMA_CONFIGURATION ;

#line 8609
typedef struct _EISA_PORT_DESCRIPTOR ;

#line 8616
typedef struct _EISA_PORT_CONFIGURATION ;

#line 8628
typedef struct _CM_EISA_SLOT_INFORMATION ;

#line 8644
typedef struct _CM_EISA_FUNCTION_INFORMATION ;

#line 8678
typedef struct _CM_PNP_BIOS_DEVICE_NODE ;

#line 8692
typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8761 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_SCSI_DEVICE_DATA ;

#line 8775
typedef struct _CM_VIDEO_DEVICE_DATA ;

#line 8785
typedef struct _CM_SONIC_DEVICE_DATA ;

#line 8796
typedef struct _CM_SERIAL_DEVICE_DATA ;

#line 8810
typedef struct _CM_MONITOR_DEVICE_DATA ;

#line 8844
typedef struct _CM_FLOPPY_DEVICE_DATA ;

#line 8881
typedef struct _CM_KEYBOARD_DEVICE_DATA ;

#line 8893
typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA ;

#line 8905
typedef struct _CM_PCCARD_DEVICE_DATA ;

#line 8944
typedef struct _IO_RESOURCE_DESCRIPTOR ;

#line 9027
typedef struct _IO_RESOURCE_LIST ;

#line 9036
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST ;

#line 9065
typedef struct _EXCEPTION_RECORD ;

#line 9074
typedef EXCEPTION_RECORD ;

typedef struct _EXCEPTION_RECORD32 ;

#line 9085
typedef struct _EXCEPTION_RECORD64 ;

#line 9099
typedef struct _EXCEPTION_POINTERS ;

#line 9111
typedef enum _CONFIGURATION_TYPE ;

#line 9161
typedef enum _KINTERRUPT_MODE ;

#line 9170
typedef enum _KWAIT_REASON ;

#line 9207
typedef struct _DISPATCHER_HEADER ;

#line 9217
typedef struct _KWAIT_BLOCK ;

#line 9230
typedef void ;

#line 9244
typedef struct _KDEVICE_QUEUE ;

#line 9252
typedef struct _KDEVICE_QUEUE_ENTRY ;

#line 9263
typedef struct _KEVENT ;

#line 9271
typedef BOOLEAN ;

#line 9281
typedef struct _KMUTANT ;

#line 9294
typedef struct _KSEMAPHORE ;

#line 9304
typedef struct _KTIMER ;

#line 9899
typedef enum _KBUGCHECK_BUFFER_DUMP_STATE ;

#line 9907
typedef void ;

#line 9914
typedef struct _KBUGCHECK_CALLBACK_RECORD ;

#line 10002
typedef void ;

#line 10020
typedef LOGICAL ;

#line 10037
typedef void ;

#line 10053
typedef enum _MEMORY_CACHING_TYPE_ORIG ;

#line 10057
typedef enum _MEMORY_CACHING_TYPE ;

#line 10087
typedef struct _DBGKD_DEBUG_DATA_HEADER64 ;

#line 10115
typedef enum _POOL_TYPE ;

#line 10195
typedef enum _EX_POOL_PRIORITY ;

#line 10247
typedef struct _FAST_MUTEX ;

#line 10574
typedef PVOID ;

#line 10582
typedef void ;

#line 10588
typedef struct _GENERAL_LOOKASIDE ;

#line 10619
typedef struct _NPAGED_LOOKASIDE_LIST ;

#line 10729
typedef struct _PAGED_LOOKASIDE_LIST ;

#line 10882
typedef enum _WORK_QUEUE_TYPE ;

#line 10889
typedef void ;

#line 10895
typedef struct _WORK_QUEUE_ITEM ;

#line 10926
typedef struct _ZONE_SEGMENT_HEADER ;

#line 10931
typedef struct _ZONE_HEADER ;

#line 11156
typedef ULONG_PTR ;

#line 11157
typedef ERESOURCE_THREAD ;

typedef struct _OWNER_ENTRY ;

#line 11168
typedef struct _ERESOURCE ;

#line 11197
typedef struct _RESOURCE_HASH_ENTRY ;

#line 11204
typedef struct _RESOURCE_PERFORMANCE_DATA ;

#line 11429
typedef struct _CALLBACK_OBJECT ;

typedef void ;

#line 11474
typedef GUID ;

#line 11862
typedef enum _MM_SYSTEM_SIZE ;

#line 11884
typedef enum _LOCK_OPERATION ;

#line 11970
typedef enum _MM_PAGE_PRIORITY ;

#line 11999
typedef struct _PHYSICAL_MEMORY_RANGE ;

#line 12385
typedef NTSTATUS ;

#line 12389
typedef NTSTATUS ;

#line 12399
struct _DRIVER_OBJECT ;

#line 12411
typedef enum _SECURITY_OPERATION_CODE ;

#line 12426
typedef struct _SECURITY_SUBJECT_CONTEXT ;

#line 12448
typedef struct _INITIAL_PRIVILEGE_SET ;

#line 12462
typedef struct _ACCESS_STATE ;

#line 12571
typedef void ;

#line 12585
typedef void ;

#line 12602
typedef struct _IMAGE_INFO ;

#line 12620
typedef void ;

#line 12859
typedef NTSTATUS ;

#line 12878
typedef enum _IO_QUERY_DEVICE_DATA_FORMAT ;

#line 12890
typedef enum _CREATE_FILE_TYPE ;

#line 12905
struct _DEVICE_DESCRIPTION ;

#line 12906
struct _DEVICE_OBJECT ;

#line 12907
struct _DMA_ADAPTER ;

#line 12908
struct _DRIVER_OBJECT ;

#line 12909
struct _DRIVE_LAYOUT_INFORMATION ;

#line 12910
struct _DISK_PARTITION ;

#line 12911
struct _FILE_OBJECT ;

#line 12912
struct _IRP ;

#line 12913
struct _SCSI_REQUEST_BLOCK ;

#line 12919
typedef void ;

#line 12932
typedef void ;

#line 12943
typedef NTSTATUS ;

#line 12955
typedef void ;

#line 12968
typedef void ;

#line 12979
typedef NTSTATUS ;

#line 12990
typedef void ;

#line 13001
typedef void ;

#line 13011
typedef NTSTATUS ;

#line 13025
typedef BOOLEAN ;

#line 13038
typedef BOOLEAN ;

#line 13051
typedef BOOLEAN ;

#line 13068
typedef BOOLEAN ;

#line 13078
typedef BOOLEAN ;

#line 13092
typedef BOOLEAN ;

#line 13106
typedef BOOLEAN ;

#line 13118
typedef BOOLEAN ;

#line 13127
typedef BOOLEAN ;

#line 13141
typedef BOOLEAN ;

#line 13161
typedef void ;

#line 13167
typedef void ;

#line 13179
typedef void ;

#line 13193
typedef BOOLEAN ;

#line 13207
typedef BOOLEAN ;

#line 13219
typedef BOOLEAN ;

#line 13227
typedef BOOLEAN ;

#line 13239
typedef BOOLEAN ;

#line 13253
typedef NTSTATUS ;

#line 13262
typedef NTSTATUS ;

#line 13275
typedef NTSTATUS ;

#line 13282
typedef NTSTATUS ;

#line 13289
typedef BOOLEAN ;

#line 13304
typedef BOOLEAN ;

#line 13319
typedef BOOLEAN ;

#line 13327
typedef BOOLEAN ;

#line 13336
typedef BOOLEAN ;

#line 13350
typedef struct _FAST_IO_DISPATCH ;

#line 13386
typedef enum _IO_ALLOCATION_ACTION ;

#line 13396
typedef IO_ALLOCATION_ACTION ;

#line 13410
typedef struct _IO_SECURITY_CONTEXT ;

#line 13434
typedef struct _VPB ;

#line 13482
typedef struct _ADAPTER_OBJECT ;

#line 13491
typedef struct _WAIT_CONTEXT_BLOCK ;

#line 13503
typedef struct _CONTROLLER_OBJECT ;

#line 13537
typedef struct _DEVICE_OBJECT ;

#line 13575
typedef struct _DEVICE_OBJECT ;

#line 13578
struct _DEVICE_OBJECT_POWER_EXTENSION ;

typedef struct _DEVOBJ_EXTENSION ;

#line 13608
typedef struct _DRIVER_EXTENSION ;

#line 13645
typedef struct _DRIVER_OBJECT ;

#line 13706
typedef struct _DRIVER_OBJECT ;

#line 13715
typedef struct _SECTION_OBJECT_POINTERS ;

#line 13720
typedef SECTION_OBJECT_POINTERS ;

#line 13726
typedef struct _IO_COMPLETION_CONTEXT ;

#line 13759
typedef struct _FILE_OBJECT ;

#line 13788
typedef struct _FILE_OBJECT ;

#line 13828
typedef struct _IRP ;

#line 14078
typedef NTSTATUS ;

#line 14163
typedef enum _DEVICE_RELATION_TYPE ;

#line 14171
typedef struct _DEVICE_RELATIONS ;

#line 14176
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE ;

#line 14185
typedef struct _INTERFACE ;

#line 14196
typedef struct _DEVICE_CAPABILITIES ;

#line 14229
typedef struct _POWER_SEQUENCE ;

#line 14235
typedef enum  {
	BusQueryDeviceID = 0,
	BusQueryHardwareIDs = 1,
	BusQueryCompatibleIDs = 2,
	BusQueryInstanceID = 3,
	BusQueryDeviceSerialNumber = 4
} ;

typedef ULONG ;

#line 14252
typedef enum  {
	DeviceTextDescription = 0,
	DeviceTextLocationInformation = 1
} ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 14615 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SHARE_ACCESS ;

#line 14635
typedef struct _CONFIGURATION_INFORMATION ;

#line 14848
typedef struct _BOOTDISK_INFORMATION ;

#line 15754
typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK ;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK ;

#line 15764
typedef struct _IO_REMOVE_LOCK_DBG_BLOCK ;

#line 15777
typedef struct _IO_REMOVE_LOCK ;

#line 16009
typedef struct _IO_WORKITEM ;

typedef void ;

#line 16100
typedef enum  {
	DevicePropertyDeviceDescription,
	DevicePropertyHardwareID,
	DevicePropertyCompatibleIDs,
	DevicePropertyBootConfiguration,
	DevicePropertyBootConfigurationTranslated,
	DevicePropertyClassName,
	DevicePropertyClassGuid,
	DevicePropertyDriverKeyName,
	DevicePropertyManufacturer,
	DevicePropertyFriendlyName,
	DevicePropertyLocationInformation,
	DevicePropertyPhysicalDeviceObjectName,
	DevicePropertyBusTypeGuid,
	DevicePropertyLegacyBusType,
	DevicePropertyBusNumber,
	DevicePropertyEnumeratorName,
	DevicePropertyAddress,
	DevicePropertyUINumber
} ;

typedef BOOLEAN ;

#line 16129
typedef struct _DMA_ADAPTER ;

#line 16135
typedef ULONG ;

#line 16148
typedef struct _PNP_BUS_INFORMATION ;

#line 16162
typedef struct _LEGACY_BUS_INFORMATION ;

#line 16168
typedef struct _BUS_INTERFACE_STANDARD ;

#line 16190
typedef BOOLEAN ;

#line 16194
typedef NTSTATUS ;

#line 16203
typedef NTSTATUS ;

#line 16206
typedef NTSTATUS ;

#line 16210
typedef NTSTATUS ;

#line 16214
typedef NTSTATUS ;

#line 16218
typedef void ;

#line 16222
typedef NTSTATUS ;

#line 16227
typedef void ;

#line 16231
typedef struct _ACPI_INTERFACE_STANDARD ;

#line 16255
typedef enum _ACPI_REG_TYPE ;

#line 16268
typedef USHORT ;

#line 16272
typedef void ;

#line 16278
typedef struct ACPI_REGS_INTERFACE_STANDARD ;

#line 16300
typedef struct  {
	PVOID LinkNode ;
	ULONG StaticVector ;
	UCHAR Flags ;
} ;

#line 16314
typedef NTSTATUS ;

#line 16329
typedef NTSTATUS ;

#line 16336
typedef void ;

#line 16343
typedef struct _INT_ROUTE_INTERFACE_STANDARD ;

#line 16366
typedef struct _IO_ASSIGNED_RESOURCES ;

#line 16490
typedef enum _IO_NOTIFICATION_EVENT_CATEGORY ;

#line 16504
typedef NTSTATUS ;

#line 16537
typedef void ;

#line 16573
typedef enum _ARBITER_ACTION ;

#line 16586
typedef struct _ARBITER_CONFLICT_INFO ;

#line 16608
typedef struct _ARBITER_PARAMETERS ;

#line 16719
typedef enum _ARBITER_REQUEST_SOURCE ;

#line 16731
typedef enum _ARBITER_RESULT ;

#line 16761
typedef struct _ARBITER_LIST_ENTRY ;

#line 16832
typedef NTSTATUS ;

#line 16853
typedef struct _ARBITER_INTERFACE ;

#line 16880
typedef enum _RESOURCE_TRANSLATION_DIRECTION ;

#line 16889
typedef NTSTATUS ;

#line 16901
typedef NTSTATUS ;

#line 16915
typedef struct _TRANSLATOR_INTERFACE ;

#line 16931
typedef NTSTATUS ;

#line 16945
typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE ;

#line 16959
typedef struct _PLUGPLAY_NOTIFICATION_HEADER ;

#line 16972
typedef struct _HWPROFILE_CHANGE_NOTIFICATION ;

#line 16986
typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION ;

#line 17006
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION ;

#line 17026
typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION ;

#line 17054
typedef struct _DEVICE_DESCRIPTION ;

#line 17086
typedef BOOLEAN ;

#line 17333
typedef void ;

#line 17339
typedef struct _DEVICE_CONTROL_CONTEXT ;

#line 17349
typedef PBUS_HANDLER ;

#line 17355
typedef void ;

#line 17365
typedef enum _HAL_QUERY_INFORMATION_CLASS ;

#line 17381
typedef enum _HAL_SET_INFORMATION_CLASS ;

#line 17388
typedef NTSTATUS ;

#line 17405
typedef NTSTATUS ;

#line 17420
typedef void ;

#line 17429
typedef void ;

#line 17438
typedef NTSTATUS ;

#line 17447
typedef NTSTATUS ;

#line 17456
typedef NTSTATUS ;

#line 17466
typedef NTSTATUS ;

#line 17475
typedef NTSTATUS ;

#line 17486
typedef struct _PM_DISPATCH_TABLE ;

#line 17492
typedef NTSTATUS ;

#line 17505
typedef struct _DMA_ADAPTER ;

#line 17520
typedef NTSTATUS ;

#line 17543
typedef BOOLEAN ;

#line 17553
typedef NTSTATUS ;

#line 17566
typedef void ;

#line 17572
typedef void ;

#line 17578
typedef BOOLEAN ;

#line 17588
typedef struct  {
	ULONG Version ;
	pHalQuerySystemInformation HalQuerySystemInformation ;
	pHalSetSystemInformation HalSetSystemInformation ;
	pHalQueryBusSlots HalQueryBusSlots ;
	ULONG Spare1 ;
	pHalExamineMBR HalExamineMBR ;
	pHalIoAssignDriveLetters HalIoAssignDriveLetters ;
	pHalIoReadPartitionTable HalIoReadPartitionTable ;
	pHalIoSetPartitionInformation HalIoSetPartitionInformation ;
	pHalIoWritePartitionTable HalIoWritePartitionTable ;
	pHalHandlerForBus HalReferenceHandlerForBus ;
	pHalReferenceBusHandler HalReferenceBusHandler ;
	pHalReferenceBusHandler HalDereferenceBusHandler ;
	pHalInitPnpDriver HalInitPnpDriver ;
	pHalInitPowerManagement HalInitPowerManagement ;
	pHalGetDmaAdapter HalGetDmaAdapter ;
	pHalGetInterruptTranslator HalGetInterruptTranslator ;
} ;

#line 17650
typedef struct _HAL_BUS_INFORMATION ;

#line 17658
typedef struct _HAL_PROFILE_SOURCE_INFORMATION ;

#line 17665
typedef struct _HAL_PROFILE_SOURCE_INTERVAL ;

#line 17671
typedef enum _HAL_DISPLAY_BIOS_INFORMATION ;

#line 17678
typedef struct _HAL_POWER_INFORMATION ;

#line 17683
typedef struct _HAL_PROCESSOR_SPEED_INFO ;

#line 17688
typedef struct _HAL_CALLBACKS ;

#line 17694
typedef struct _HAL_PROCESSOR_FEATURE ;

#line 17706
typedef union _MCI_ADDR ;

#line 17716
typedef enum  {
	HAL_MCE_RECORD,
	HAL_MCA_RECORD
} ;

#line 17726
typedef struct _MCA_EXCEPTION ;

#line 17752
typedef void ;

#line 17762
typedef struct _MCA_DRIVER_INFO ;

#line 17772
typedef struct _SCATTER_GATHER_ELEMENT ;

#line 17778

#pragma warning(disable:4200)
#line 17779
typedef struct _SCATTER_GATHER_LIST ;

#line 17784

#pragma warning(default:4200)
#line 17788
typedef struct _DMA_OPERATIONS ;

typedef struct _DMA_ADAPTER ;

#line 17797
typedef void ;

#line 17801
typedef PVOID ;

#line 17808
typedef void ;

#line 17816
typedef NTSTATUS ;

#line 17824
typedef BOOLEAN ;

#line 17833
typedef void ;

#line 17837
typedef void ;

#line 17843
typedef PHYSICAL_ADDRESS ;

#line 17852
typedef ULONG ;

#line 17856
typedef ULONG ;

#line 17860
typedef void ;

#line 17868
typedef NTSTATUS ;

#line 17880
typedef void ;

#line 17887
typedef struct _DMA_OPERATIONS ;

#line 18235
typedef void ;

#line 18321
typedef struct _OBJECT_HANDLE_INFORMATION ;

#line 18402
typedef struct _PCI_SLOT_NUMBER ;

#line 18418
typedef struct _PCI_COMMON_CONFIG ;

#line 18591
typedef struct _PCI_CAPABILITIES_HEADER ;

#line 18600
typedef struct _PCI_PMC ;

#line 18618
typedef struct _PCI_PMCSR ;

#line 18628
typedef struct _PCI_PMCSR_BSE ;

#line 18635
typedef struct _PCI_PM_CAPABILITY ;

#line 18679
typedef struct _PCI_AGP_CAPABILITY ;

#line 18720
typedef struct _PCI_MSI_CAPABILITY ;

#line 18946
typedef void ;

#line 18954
typedef void ;

#line 18963
typedef void ;

#line 18975
typedef struct _PCIBUSDATA ;

#line 18986
typedef ULONG ;

#line 18995
typedef void ;

#line 19000
typedef void ;

#line 19006
typedef struct _PCI_BUS_INTERFACE_STANDARD ;

#line 19028
typedef BOOLEAN ;

#line 19043
typedef struct _PCI_DEVICE_PRESENT_INTERFACE ;

#line 127 "C:/NTDDK/inc/ntddser.h"
typedef struct _SERIALPERF_STATS ;

#line 136
typedef struct _SERIALCONFIG ;

#line 154
typedef struct _SERIAL_LINE_CONTROL ;

#line 160
typedef struct _SERIAL_TIMEOUTS ;

#line 175
typedef struct _SERIAL_QUEUE_SIZE ;

#line 185
typedef struct _SERIAL_BAUD_RATE ;

#line 247
typedef struct _SERIAL_CHARS ;

#line 284
typedef struct _SERIAL_HANDFLOW ;

#line 340
typedef struct _SERIAL_BASIC_SETTINGS ;

#line 353
typedef struct _SERIAL_STATUS ;

#line 433
typedef struct _SERIAL_XOFF_COUNTER ;

#line 539
typedef struct _SERIAL_COMMPROP ;

#line 631
typedef struct _SERENUM_PORT_DESC ;

#line 652
typedef UCHAR ;

#line 658
typedef void ;

#line 665
typedef enum _SERENUM_PORTION ;

#line 671
typedef struct _SERENUM_PORT_PARAMETERS ;

#line 28 "C:/NTDDK/inc/ddk/wdm/wmilib.h"

#pragma once
#line 38
typedef struct  {
	LPCGUID Guid ;
	ULONG InstanceCount ;
	ULONG Flags ;
} ;

#line 45
typedef NTSTATUS ;

#line 101
typedef NTSTATUS ;

#line 162
typedef NTSTATUS ;

#line 206
typedef NTSTATUS ;

#line 253
typedef NTSTATUS ;

#line 306
typedef enum  {
	WmiEventControl,
	WmiDataBlockControl
} ;

#line 312
typedef NTSTATUS ;

#line 355
typedef struct _WMILIB_CONTEXT ;

#line 411
typedef enum  {
	IrpProcessed,
	IrpNotCompleted,
	IrpNotWmi,
	IrpForward
} ;

#line 13 "C:/NTDDK/inc/wmidata.h"
typedef struct _MSWmi_MofData ;

#line 51
typedef struct _MSWmi_ProviderInfo ;

#line 66
typedef struct _MSWmi_PnPDeviceId ;

#line 83
typedef struct _MSWmi_PnPInstanceNames ;

#line 105
typedef struct _MSSmBios_RawSMBiosTables ;

#line 147
typedef struct _MSPower_DeviceEnable ;

#line 165
typedef struct _MSPower_DeviceWakeEnable ;

#line 182
typedef struct _MSNdis_NetworkAddress ;

#line 199
typedef struct _MSNdis_NetworkShortAddress ;

#line 216
typedef struct _MSNdis_NetworkLinkSpeed ;

#line 239
typedef struct _MSNdis_EnumerateAdapter ;

#line 256
typedef struct _MSNdis_NotifyAdapterRemoval ;

#line 273
typedef struct _MSNdis_NotifyAdapterArrival ;

#line 291
typedef struct _MSNdis_NdisEnumerateVc ;

#line 307
typedef struct _MSNdis_NotifyVcRemoval ;

#line 323
typedef struct _MSNdis_NotifyVcArrival ;

#line 338
typedef struct _MSNdis_HardwareStatus ;

#line 356
typedef struct _MSNdis_MediaSupported ;

#line 378
typedef struct _MSNdis_MediaInUse ;

#line 400
typedef struct _MSNdis_MaximumLookahead ;

#line 418
typedef struct _MSNdis_MaximumFrameSize ;

#line 436
typedef struct _MSNdis_LinkSpeed ;

#line 454
typedef struct _MSNdis_TransmitBufferSpace ;

#line 472
typedef struct _MSNdis_ReceiveBufferSpace ;

#line 490
typedef struct _MSNdis_TransmitBlockSize ;

#line 508
typedef struct _MSNdis_ReceiveBlockSize ;

#line 526
typedef struct _MSNdis_VendorID ;

#line 544
typedef struct _MSNdis_VendorDescription ;

#line 561
typedef struct _MSNdis_CurrentPacketFilter ;

#line 579
typedef struct _MSNdis_CurrentLookahead ;

#line 597
typedef struct _MSNdis_DriverVersion ;

#line 615
typedef struct _MSNdis_MaximumTotalSize ;

#line 633
typedef struct _MSNdis_MacOptions ;

#line 651
typedef struct _MSNdis_MediaConnectStatus ;

#line 669
typedef struct _MSNdis_MaximumSendPackets ;

#line 687
typedef struct _MSNdis_VendorDriverVersion ;

#line 705
typedef struct _MSNdis_TransmitsOk ;

#line 723
typedef struct _MSNdis_ReceivesOk ;

#line 741
typedef struct _MSNdis_TransmitsError ;

#line 759
typedef struct _MSNdis_ReceiveError ;

#line 777
typedef struct _MSNdis_ReceiveNoBuffer ;

#line 795
typedef struct _MSNdis_CoHardwareStatus ;

#line 813
typedef struct _MSNdis_CoMediaSupported ;

#line 835
typedef struct _MSNdis_CoMediaInUse ;

#line 857
typedef struct _MSNdis_CoLinkSpeed ;

#line 875
typedef struct _MSNdis_CoVendorId ;

#line 893
typedef struct _MSNdis_CoVendorDescription ;

#line 910
typedef struct _MSNdis_CoDriverVersion ;

#line 928
typedef struct _MSNdis_CoMacOptions ;

#line 946
typedef struct _MSNdis_CoMediaConnectStatus ;

#line 964
typedef struct _MSNdis_CoVendorDriverVersion ;

#line 982
typedef struct _MSNdis_CoMinimumLinkSpeed ;

#line 1000
typedef struct _MSNdis_CoTransmitPdusOk ;

#line 1018
typedef struct _MSNdis_CoReceivePdusOk ;

#line 1036
typedef struct _MSNdis_CoTransmitPduErrors ;

#line 1054
typedef struct _MSNdis_CoReceivePduErrors ;

#line 1072
typedef struct _MSNdis_CoReceivePdusNoBuffer ;

#line 1090
typedef struct _MSNdis_AtmSupportedVcRates ;

#line 1113
typedef struct _MSNdis_AtmSupportedServiceCategory ;

#line 1131
typedef struct _MSNdis_AtmSupportedAalTypes ;

#line 1149
typedef struct _MSNdis_AtmHardwareCurrentAddress ;

#line 1167
typedef struct _MSNdis_AtmMaxActiveVcs ;

#line 1185
typedef struct _MSNdis_AtmMaxActiveVciBits ;

#line 1203
typedef struct _MSNdis_AtmMaxActiveVpiBits ;

#line 1221
typedef struct _MSNdis_AtmMaxAal0PacketSize ;

#line 1239
typedef struct _MSNdis_AtmMaxAal1PacketSize ;

#line 1257
typedef struct _MSNdis_AtmMaxAal34PacketSize ;

#line 1275
typedef struct _MSNdis_AtmMaxAal5PacketSize ;

#line 1293
typedef struct _MSNdis_AtmReceiveCellsOk ;

#line 1311
typedef struct _MSNdis_AtmTransmitCellsOk ;

#line 1329
typedef struct _MSNdis_AtmReceiveCellsDropped ;

#line 1347
typedef struct _MSNdis_EthernetPermanentAddress ;

#line 1365
typedef struct _MSNdis_EthernetCurrentAddress ;

#line 1383
typedef struct _MSNdis_EthernetMulticastList ;

#line 1405
typedef struct _MSNdis_EthernetMaximumMulticastListSize ;

#line 1423
typedef struct _MSNdis_EthernetMacOptions ;

#line 1441
typedef struct _MSNdis_EthernetReceiveErrorAlignment ;

#line 1459
typedef struct _MSNdis_EthernetOneTransmitCollision ;

#line 1477
typedef struct _MSNdis_EthernetMoreTransmitCollisions ;

#line 1495
typedef struct _MSNdis_TokenRingPermanentAddress ;

#line 1513
typedef struct _MSNdis_TokenRingCurrentAddress ;

#line 1531
typedef struct _MSNdis_TokenRingCurrentFunctional ;

#line 1549
typedef struct _MSNdis_TokenRingCurrentGroup ;

#line 1567
typedef struct _MSNdis_TokenRingLastOpenStatus ;

#line 1585
typedef struct _MSNdis_TokenRingCurrentRingStatus ;

#line 1603
typedef struct _MSNdis_TokenRingCurrentRingState ;

#line 1621
typedef struct _MSNdis_TokenRingLineErrors ;

#line 1639
typedef struct _MSNdis_TokenRingLostFrames ;

#line 1657
typedef struct _MSNdis_FddiLongPermanentAddress ;

#line 1675
typedef struct _MSNdis_FddiLongCurrentAddress ;

#line 1693
typedef struct _MSNdis_FddiLongMulticastList ;

#line 1715
typedef struct _MSNdis_FddiLongMaximumListSize ;

#line 1733
typedef struct _MSNdis_FddiShortPermanentAddress ;

#line 1751
typedef struct _MSNdis_FddiShortCurrentAddress ;

#line 1769
typedef struct _MSNdis_FddiShortMulticastList ;

#line 1791
typedef struct _MSNdis_FddiShortMaximumListSize ;

#line 1809
typedef struct _MSNdis_FddiAttachmentType ;

#line 1827
typedef struct _MSNdis_FddiUpstreamNodeLong ;

#line 1845
typedef struct _MSNdis_FddiDownstreamNodeLong ;

#line 1863
typedef struct _MSNdis_FddiFrameErrors ;

#line 1881
typedef struct _MSNdis_FddiFramesLost ;

#line 1899
typedef struct _MSNdis_FddiRingManagmentState ;

#line 1917
typedef struct _MSNdis_FddiLctFailures ;

#line 1935
typedef struct _MSNdis_FddiLemRejects ;

#line 1953
typedef struct _MSNdis_FddiLConnectionState ;

#line 1972
typedef struct _MSNdis_StatusResetStart ;

#line 1988
typedef struct _MSNdis_StatusResetEnd ;

#line 2004
typedef struct _MSNdis_StatusMediaConnect ;

#line 2020
typedef struct _MSNdis_StatusMediaDisconnect ;

#line 2035
typedef struct _MSNdis_StatusMediaSpecificIndication ;

#line 2057
typedef struct _MSNdis_StatusLinkSpeedChange ;

#line 2075
typedef struct _MSNdis_StatusProtocolBind ;

#line 2092
typedef struct _MSNdis_StatusProtocolUnbind ;

#line 2109
typedef struct _KEYBOARD_PORT_WMI_STD_DATA ;

#line 2152
typedef struct _POINTER_PORT_WMI_STD_DATA ;

#line 2205
typedef struct _MSMouse_ClassInformation ;

#line 2223
typedef struct _MSKeyboard_ClassInformation ;

#line 2241
typedef struct _MSAcpi_ThermalZoneTemperature ;

#line 2304
typedef struct _WMI_DISK_GEOMETRY ;

#line 2342
typedef struct _WMI_DISK_PERFORMANCE ;

#line 2415
typedef struct _MSDiskDriver_Performance ;

#line 2437
typedef struct _STORAGE_FAILURE_PREDICT_STATUS ;

#line 2460
typedef struct _STORAGE_FAILURE_PREDICT_DATA ;

#line 2483
typedef struct _STORAGE_FAILURE_PREDICT_EVENT ;

#line 2513
typedef struct _STORAGE_FAILURE_PREDICT_FUNCTION ;

#line 2528
typedef struct _MSIde_PortDeviceInfo ;

#line 2556
typedef struct _MSSerial_PortName ;

#line 2573
typedef struct _SERIAL_WMI_COMM_DATA ;

#line 2723
typedef struct _SERIAL_WMI_HW_DATA ;

#line 2770
typedef struct _SERIAL_WMI_PERF_DATA ;

#line 2813
typedef struct _SERIAL_WMI_COMMPROP ;

#line 2920
typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS ;

#line 2943
typedef struct _PARALLEL_WMI_LOG_INFO ;

#line 3041
typedef struct _REDBOOK_WMI_STD_DATA ;

#line 3094
typedef struct _REDBOOK_WMI_PERF_DATA ;

#line 3137
typedef struct _RegisteredGuids ;

#line 475 "serial.h"
typedef struct _CONFIG_DATA ;

#line 509
typedef struct _SERIAL_CISR_SW ;

#line 520
typedef struct _SERIAL_FIRMWARE_DATA ;

#line 576
typedef struct _SERIAL_DEVICE_STATE ;

#line 646
typedef struct _SERIAL_DEVICE_EXTENSION ;

#line 1808
typedef struct _SERIAL_MULTIPORT_DISPATCH ;

#line 2157
typedef enum _SERIAL_MEM_COMPARES ;

#line 2164
typedef struct _SERIAL_LIST_DATA ;

#line 2169
typedef struct _SERIAL_GLOBALS ;

#line 2180
typedef struct _SERIAL_USER_DATA ;

#line 2206
typedef struct _SERIAL_PTR_CTX ;

#line 20 "serialp.h"
typedef NTSTATUS ;

#line 26
typedef void ;

#line 835
typedef struct _SERIAL_UPDATE_CHAR ;

#line 846
typedef struct _SERIAL_IOCTL_SYNC ;

#line 27 "openclos.c"
BOOLEAN SerialMarkOpen(PVOID Context ) ;
#line 32
BOOLEAN SerialCheckOpen(PVOID Context ) ;
#line 37
BOOLEAN SerialNullSynch(PVOID Context ) ;

#line 55

#pragma alloc_text(PAGESER, SerialGetCharTime)
#line 56

#pragma alloc_text(PAGESER, SerialCleanup)
#line 57

#pragma alloc_text(PAGESER, SerialClose)
#line 58

#pragma alloc_text(PAGESER, SerialCheckOpen)
#line 59

#pragma alloc_text(PAGESER, SerialMarkOpen)
#line 65

#pragma alloc_text(PAGESRP0, SerialCreateOpen)
#line 66

#pragma alloc_text(PAGESRP0, SerialDrainUART)
#line 69
typedef struct _SERIAL_CHECK_OPEN {
	PSERIAL_DEVICE_EXTENSION Extension ;
	NTSTATUS *  StatusOfOpen ;
} SERIAL_CHECK_OPEN , *  PSERIAL_CHECK_OPEN ;

#line 79
BOOLEAN SerialNullSynch(PVOID Context )
{
	#line 84
	Context;
	return 0;
}

NTSTATUS SerialCreateOpen(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
	#line 115
	PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
	SERIAL_CHECK_OPEN checkOpen ;
	NTSTATUS localStatus ;
	#line 119
	;
	#line 121
	if(extension->PNPState != 0x1L)
	{
		#line 122
		(Irp->IoStatus).Status = (NTSTATUS )0xC000009AL;
		IofCompleteRequest(Irp, 0);
		return (NTSTATUS )0xC000009AL;
	}
	#line 131
	ExAcquireFastMutex(& extension->OpenMutex);
	#line 133
	if((localStatus = SerialIRPPrologue(Irp, extension)) != (NTSTATUS
		)0x00000000L)
	{
		#line 134
		ExReleaseFastMutex(& extension->OpenMutex);
		{
			#line 135
			IofCompleteRequest(Irp, 0);
			#line 135
			SerialIRPEpilogue(extension);
		}
		#line 135
		;
		return localStatus;
	}
	#line 139
	if(InterlockedIncrement(& extension->OpenCount) != 1)
	{
		#line 140
		ExReleaseFastMutex(& extension->OpenMutex);
		InterlockedDecrement(& extension->OpenCount);
		(Irp->IoStatus).Status = (NTSTATUS )0xC0000022L;
		{
			#line 143
			IofCompleteRequest(Irp, 0);
			#line 143
			SerialIRPEpilogue(extension);
		}
		#line 143
		;
		return (NTSTATUS )0xC0000022L;
	}
	#line 150
	do
	{
		#line 150
		;
	}
	while(0);
	#line 154
	do
	{
		#line 154
		;
	}
	while(0);
	#line 161
	if((((((Irp->Tail).Overlay).CurrentStackLocation)->Parameters).Create).Options
		& 0x00000001)
	{
		#line 163
		ExReleaseFastMutex(& extension->OpenMutex);
		#line 165
		(Irp->IoStatus).Status = (NTSTATUS )0xC0000103L;
		(Irp->IoStatus).Information = 0;
		#line 171
		do
		{
			#line 171
			;
		}
		while(0);
		#line 175
		InterlockedDecrement(& extension->OpenCount);
		{
			#line 176
			IofCompleteRequest(Irp, 0);
			#line 176
			SerialIRPEpilogue(extension);
		}
		#line 176
		;
		#line 178
		return (NTSTATUS )0xC0000103L;
	}
	#line 186
	extension->InterruptReadBuffer = (void *  )0;
	extension->BufferSize = 0;
	#line 189
	switch(MmQuerySystemSize())
	{
	case MmLargeSystem:
			#line 191
			;
		{
			extension->BufferSize = 4096;
			extension->InterruptReadBuffer =
				ExAllocatePoolWithTag(NonPagedPool,
				extension->BufferSize, 'XMOC');
			#line 199
			if(extension->InterruptReadBuffer)
			{
				break;
			}
		}
		#line 207
	case MmMediumSystem:
			#line 207
			;
		{
			extension->BufferSize = 1024;
			extension->InterruptReadBuffer =
				ExAllocatePoolWithTag(NonPagedPool,
				extension->BufferSize, 'XMOC');
			#line 215
			if(extension->InterruptReadBuffer)
			{
				break;
			}
		}
		#line 223
	case MmSmallSystem:
			#line 223
			;
		{
			extension->BufferSize = 128;
			extension->InterruptReadBuffer =
				ExAllocatePoolWithTag(NonPagedPool,
				extension->BufferSize, 'XMOC');
		}
	}
	#line 235
	if(! extension->InterruptReadBuffer)
	{
		#line 236
		ExReleaseFastMutex(& extension->OpenMutex);
		#line 238
		extension->BufferSize = 0;
		(Irp->IoStatus).Status = (NTSTATUS )0xC000009AL;
		(Irp->IoStatus).Information = 0;
		#line 245
		do
		{
			#line 245
			;
		}
		while(0);
		#line 247
		InterlockedDecrement(& extension->OpenCount);
		{
			#line 248
			IofCompleteRequest(Irp, 0);
			#line 248
			SerialIRPEpilogue(extension);
		}
		#line 248
		;
		#line 250
		return (NTSTATUS )0xC000009AL;
	}
	{
		#line 258
		MmLockPagableSectionByHandle(SerialGlobals.PAGESER_Handle);
	}
	#line 258
	;
	#line 264
	(void )SerialGotoPowerState(DeviceObject, extension, PowerDeviceD0);
	#line 270
	extension->SendWaitWake = 0;
	#line 277
	extension->CharsInInterruptBuffer = 0;
	extension->LastCharSlot = extension->InterruptReadBuffer +
		(extension->BufferSize - 1);
	#line 281
	extension->ReadBufferBase = extension->InterruptReadBuffer;
	extension->CurrentCharSlot = extension->InterruptReadBuffer;
	extension->FirstReadableChar = extension->InterruptReadBuffer;
	#line 285
	extension->TotalCharsQueued = 0;
	#line 291
	(extension->HandFlow).XoffLimit = extension->BufferSize >> 3;
	(extension->HandFlow).XonLimit = extension->BufferSize >> 1;
	#line 294
	(extension->WmiCommData).XoffXmitThreshold =
		(extension->HandFlow).XoffLimit;
	#line 295
	(extension->WmiCommData).XonXmitThreshold =
		(extension->HandFlow).XonLimit;
	extension->BufferSizePt8 = 3 * (extension->BufferSize >> 2) +
		(extension->BufferSize >> 4);
	#line 304
	(extension->WmiCommData).IsBusy = 1;
	#line 306
	extension->IrpMaskLocation = (void *  )0;
	extension->HistoryMask = 0;
	extension->IsrWaitMask = 0;
	#line 310
	extension->SendXonChar = 0;
	extension->SendXoffChar = 0;
	#line 318
	KeSynchronizeExecution(extension->Interrupt, SerialClearStats,
		extension);
	#line 329
	extension->EscapeChar = 0;
	#line 331
	if(! extension->PermitShare)
	{
		if(! extension->InterruptShareable)
		{
			checkOpen.Extension = extension;
			checkOpen.StatusOfOpen = & (Irp->IoStatus).Status;
			#line 338
			KeSynchronizeExecution(extension->Interrupt,
				SerialCheckOpen, & checkOpen);
		}
		else
		{
			#line 346
			KeSynchronizeExecution(extension->Interrupt,
				SerialMarkOpen, extension);
			#line 352
			(Irp->IoStatus).Status = (NTSTATUS )0x00000000L;
		}
	}
	else
	{
		#line 363
		KeSynchronizeExecution(extension->Interrupt, SerialMarkOpen,
			extension);
		#line 369
		(Irp->IoStatus).Status = (NTSTATUS )0x00000000L;
	}
	#line 377
	ExReleaseFastMutex(& extension->OpenMutex);
	#line 379
	localStatus = (Irp->IoStatus).Status;
	(Irp->IoStatus).Information = 0L;
	#line 385
	do
	{
		#line 385
		;
	}
	while(0);
	#line 387
	if(! ((NTSTATUS )localStatus >= 0))
	{
		#line 388
		if(extension->InterruptReadBuffer != (void *  )0)
		{
			#line 389
			ExFreePool(extension->InterruptReadBuffer);
			extension->InterruptReadBuffer = (void *  )0;
		}
		#line 393
		InterlockedDecrement(& extension->OpenCount);
	}
	{
		IofCompleteRequest(Irp, 0);
		#line 396
		SerialIRPEpilogue(extension);
	}
	#line 396
	;
	#line 398
	return localStatus;
}

#line 402
void SerialDrainUART(PSERIAL_DEVICE_EXTENSION PDevExt , PLARGE_INTEGER
	PDrainTime )
{
	#line 406
	;
	#line 412
	while((READ_PORT_UCHAR(PDevExt->Controller + (ULONG )(0x05 * 1)) & (0x20
		| 0x40)) != (0x20 | 0x40))
	{
		#line 416
		KeDelayExecutionThread(KernelMode, 0, PDrainTime);
	}
}

#line 421
NTSTATUS SerialClose(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
	#line 452
	LARGE_INTEGER tenCharDelay ;
	#line 457
	LARGE_INTEGER charTime ;
	#line 463
	PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
	#line 465
	NTSTATUS status ;
	#line 471
	LONG openCount ;
	#line 477
	ULONG pendingDPCs ;
	#line 479
	ULONG flushCount ;
	#line 485
	ExAcquireFastMutex(& extension->CloseMutex);
	#line 492
	if((status = SerialIRPPrologue(Irp, extension)) != (NTSTATUS
		)0x00000000L)
	{
		#line 493
		do
		{
			#line 493
			;
		}
		while(0);
		#line 494
		if(status == (NTSTATUS )0xC0000056L)
		{
			#line 495
			extension->BufferSize = 0;
			ExFreePool(extension->InterruptReadBuffer);
			extension->InterruptReadBuffer = (void *  )0;
			status = ((Irp->IoStatus).Status = (NTSTATUS
				)0x00000000L);
		}
		{
			#line 501
			IofCompleteRequest(Irp, 0);
			#line 501
			SerialIRPEpilogue(extension);
		}
		#line 501
		;
		openCount = InterlockedDecrement(& extension->OpenCount);
		;
		ExReleaseFastMutex(& extension->CloseMutex);
		return status;
	}
	#line 508
	;
	#line 510
	if(extension->OpenCount != 1)
	{
		#line 511
		do
		{
			#line 511
			;
		}
		while(0);
		#line 513
		do
		{
			#line 513
			;
		}
		while(0);
		#line 514
		ExReleaseFastMutex(& extension->CloseMutex);
		(Irp->IoStatus).Status = (NTSTATUS )0xC0000010L;
		{
			#line 516
			IofCompleteRequest(Irp, 0);
			#line 516
			SerialIRPEpilogue(extension);
		}
		#line 516
		;
		return (NTSTATUS )0xC0000010L;
	}
	#line 523
	do
	{
		#line 523
		;
	}
	while(0);
	#line 527
	do
	{
		#line 527
		;
	}
	while(0);
	#line 529
	charTime.QuadPart = - (SerialGetCharTime(extension)).QuadPart;
	#line 536
	extension->DeviceIsOpened = 0;
	#line 543
	KeSynchronizeExecution(extension->Interrupt, SerialTurnOffBreak,
		extension);
	#line 554
	//BLAST forloop for(flushCount = 20 * 16; flushCount != 0; flushCount--)
	for(flushCount = __BLAST_NONDET; flushCount != 0; flushCount--)
	{
		#line 555
		if((READ_PORT_UCHAR(extension->Controller + (ULONG )(0x05 * 1))
			& (0x20 | 0x40)) != (0x20 | 0x40))
		{
			#line 559
			KeDelayExecutionThread(KernelMode, 0, & charTime);
		}
		else
		{
			#line 561
			break;
		}
	}
	#line 565
	if(flushCount == 0)
	{
		#line 566
		SerialMarkHardwareBroken(extension);
	}
	#line 574
	KeSynchronizeExecution(extension->Interrupt, SerialMarkClose,
		extension);
	#line 587
	if(extension->RXHolding & (ULONG )0x02)
	{
		#line 593
		while(! (READ_PORT_UCHAR(extension->Controller + (ULONG )(0x05 *
			1)) & 0x20))
		{
			KeDelayExecutionThread(KernelMode, 0, & charTime);
		}
		#line 607
		do
		{
			#line 607
			WRITE_PORT_UCHAR(extension->Controller + (ULONG )(0x00 *
				1), (extension->SpecialChars).XonChar);
		}
		while(0);
		#line 614
		//BLAST forloop for(flushCount = 20 * 16; flushCount != 0; flushCount--)
		for(flushCount = __BLAST_NONDET; flushCount != 0; flushCount--)
		{
			#line 615
			if((READ_PORT_UCHAR(extension->Controller + (ULONG
				)(0x05 * 1)) & (0x20 | 0x40)) != (0x20 | 0x40))
			{
				#line 619
				KeDelayExecutionThread(KernelMode, 0, &
					charTime);
			}
			else
			{
				#line 621
				break;
			}
		}
		#line 625
		if(flushCount == 0)
		{
			#line 626
			SerialMarkHardwareBroken(extension);
		}
	}
	#line 636
	tenCharDelay.QuadPart = charTime.QuadPart * 10;
	#line 638
	KeDelayExecutionThread(KernelMode, 1, & tenCharDelay);
	#line 644
	SerialClrDTR(extension);
	#line 662
	if(extension->CountOfTryingToLowerRTS)
	{
		do
		{
			KeDelayExecutionThread(KernelMode, 0, & charTime);
		}
		while(extension->CountOfTryingToLowerRTS);
		#line 674
		KeSynchronizeExecution(extension->Interrupt, SerialNullSynch,
			(void *  )0);
	}
	#line 689
	SerialClrRTS(extension);
	#line 695
	extension->RXHolding = 0;
	extension->TXHolding = 0;
	#line 702
	(extension->WmiCommData).IsBusy = 0;
	#line 709
	extension->BufferSize = 0;
	if(extension->InterruptReadBuffer != (void *  )0)
	{
		#line 711
		ExFreePool(extension->InterruptReadBuffer);
	}
	extension->InterruptReadBuffer = (void *  )0;
	#line 719
	extension->SendWaitWake = 0;
	#line 721
	if(extension->PendingWakeIrp != (void *  )0)
	{
		#line 722
		IoCancelIrp(extension->PendingWakeIrp);
	}
	#line 729
	(void )SerialGotoPowerState(DeviceObject, extension, PowerDeviceD3);
	#line 731
	(Irp->IoStatus).Status = (NTSTATUS )0x00000000L;
	(Irp->IoStatus).Information = 0L;
	#line 737
	do
	{
		#line 737
		;
	}
	while(0);
	{
		#line 738
		IofCompleteRequest(Irp, 0);
		#line 738
		SerialIRPEpilogue(extension);
	}
	#line 738
	;
	#line 750
	pendingDPCs = InterlockedDecrement(& extension->DpcCount);
	;
	#line 753
	if(pendingDPCs)
	{
		#line 754
		do
		{
			#line 754
			;
		}
		while(0);
		#line 755
		KeWaitForSingleObject(& extension->PendingDpcEvent, Executive,
			KernelMode, 0, (void *  )0);
	}
	#line 760
	do
	{
		#line 760
		;
	}
	while(0);
	#line 769
	ExReleaseFastMutex(& extension->CloseMutex);
	#line 775
	InterlockedIncrement(& extension->DpcCount);
	;
	#line 778
	openCount = InterlockedDecrement(& extension->OpenCount);
	#line 780
	;
	{
		#line 781
		MmUnlockPagableImageSection(SerialGlobals.PAGESER_Handle);
	}
	#line 781
	;
	#line 783
	return (NTSTATUS )0x00000000L;
}

#line 788
BOOLEAN SerialCheckOpen(PVOID Context )
{
	#line 835
	PSERIAL_DEVICE_EXTENSION extensionToOpen = ((PSERIAL_CHECK_OPEN
		)Context)->Extension;
	NTSTATUS *  status = ((PSERIAL_CHECK_OPEN )Context)->StatusOfOpen;
	PLIST_ENTRY firstEntry = & extensionToOpen->CommonInterruptObject;
	PLIST_ENTRY currentEntry = firstEntry;
	PSERIAL_DEVICE_EXTENSION currentExtension ;
	#line 842
	do
	{
		currentExtension = (SERIAL_DEVICE_EXTENSION *  )((PCHAR
			)currentEntry - (ULONG_PTR )(& ((SERIAL_DEVICE_EXTENSION
			*  )0)->CommonInterruptObject));
		#line 850
		if(currentExtension->DeviceIsOpened)
		{
			break;
		}
		#line 856
		currentEntry = (currentExtension->CommonInterruptObject).Flink;
	}
	while(currentEntry != firstEntry);
	#line 860
	if(currentEntry == firstEntry)
	{
		#line 868
		* status = (NTSTATUS )0x00000000L;
		SerialMarkOpen(extensionToOpen);
	}
	else
	{
		if(! extensionToOpen->PortOnAMultiportCard)
		{
			* status = (NTSTATUS )0xC000016CL;
		}
		else
		{
			if(! currentExtension->PortOnAMultiportCard)
			{
				* status = (NTSTATUS )0xC000016CL;
			}
			else
			{
				* status = (NTSTATUS )0x00000000L;
				SerialMarkOpen(extensionToOpen);
			}
		}
	}
	#line 894
	return 0;
}

#line 898
BOOLEAN SerialMarkOpen(PVOID Context )
{
	#line 923
	PSERIAL_DEVICE_EXTENSION extension = Context;
	#line 925
	SerialReset(extension);
	#line 940
	do
	{
		#line 940
		WRITE_PORT_UCHAR(extension->Controller + (ULONG )(0x04 * 1),
			(UCHAR )(READ_PORT_UCHAR(extension->Controller + (ULONG
			)(0x04 * 1)) | 0x08));
	}
	while(0);
	#line 942
	extension->DeviceIsOpened = 1;
	extension->ErrorWord = 0;
	#line 945
	return 0;
}

#line 950
void SerialDisableUART(PVOID Context )
{
	#line 971
	PSERIAL_DEVICE_EXTENSION extension = Context;
	#line 983
	if(! extension->Jensen)
	{
		#line 986
		do
		{
			#line 986
			WRITE_PORT_UCHAR(extension->Controller + (ULONG )(0x04 *
				1), (UCHAR
				)(READ_PORT_UCHAR(extension->Controller + (ULONG
				)(0x04 * 1)) & ~ 0x08));
		}
		while(0);
	}
	#line 989
	if(extension->FifoPresent)
	{
		#line 990
		do
		{
			#line 990
			WRITE_PORT_UCHAR(extension->Controller + (ULONG )(0x02 *
				1), (UCHAR )0);
		}
		while(0);
	}
}

#line 995
BOOLEAN SerialMarkClose(PVOID Context )
{
	#line 1020
	PSERIAL_DEVICE_EXTENSION extension = Context;
	#line 1022
	SerialDisableUART(Context);
	extension->DeviceIsOpened = 0;
	#line 1025
	return 0;
}

#line 1030
NTSTATUS SerialCleanup(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
	#line 1056
	PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
	NTSTATUS status ;
	#line 1060
	;
	#line 1066
	if((status = SerialIRPPrologue(Irp, extension)) != (NTSTATUS
		)0x00000000L)
	{
		#line 1067
		if(status == (NTSTATUS )0xC0000056L)
		{
			#line 1068
			status = ((Irp->IoStatus).Status = (NTSTATUS
				)0x00000000L);
		}
		{
			#line 1070
			IofCompleteRequest(Irp, 0);
			#line 1070
			SerialIRPEpilogue(extension);
		}
		#line 1070
		;
		return status;
	}
	#line 1077
	do
	{
		#line 1077
		;
	}
	while(0);
	#line 1079
	SerialKillPendingIrps(DeviceObject);
	#line 1081
	(Irp->IoStatus).Status = (NTSTATUS )0x00000000L;
	(Irp->IoStatus).Information = 0L;
	#line 1087
	do
	{
		#line 1087
		;
	}
	while(0);
	{
		#line 1088
		IofCompleteRequest(Irp, 0);
		#line 1088
		SerialIRPEpilogue(extension);
	}
	#line 1088
	;
	#line 1090
	return (NTSTATUS )0x00000000L;
}

#line 1094
LARGE_INTEGER SerialGetCharTime(PSERIAL_DEVICE_EXTENSION Extension )
{
	#line 1119
	ULONG dataSize ;
	ULONG paritySize ;
	ULONG stopSize ;
	ULONG charTime ;
	ULONG bitTime ;
	LARGE_INTEGER tmp ;
	#line 1127
	if((Extension->LineControl & (UCHAR )0x03) == (UCHAR )0x00)
	{
		#line 1128
		dataSize = 5;
	}
	else
	{
		#line 1129
		if((Extension->LineControl & (UCHAR )0x03) == (UCHAR )0x01)
		{
			dataSize = 6;
		}
		else
		{
			#line 1132
			if((Extension->LineControl & (UCHAR )0x03) == (UCHAR
				)0x02)
			{
				#line 1134
				dataSize = 7;
			}
			else
			{
				#line 1135
				if((Extension->LineControl & (UCHAR )0x03) ==
					(UCHAR )0x03)
				{
					#line 1137
					dataSize = 8;
				}
			}
		}
	}
	#line 1140
	paritySize = 1;
	if((Extension->LineControl & (UCHAR )0x38) == (UCHAR )0x00)
	{
		#line 1144
		paritySize = 0;
	}
	#line 1148
	if(Extension->LineControl & (UCHAR )0x04)
	{
		#line 1155
		stopSize = 2;
	}
	else
	{
		stopSize = 1;
	}
	#line 1168
	bitTime = (10000000 + (Extension->CurrentBaud - 1)) /
		Extension->CurrentBaud;
	#line 1169
	charTime = bitTime + (dataSize + paritySize + stopSize) * bitTime;
	#line 1171
	tmp.QuadPart = charTime;
	return tmp;
}

#line 16 "C:/NTDDK/inc/stddef.h"

#pragma once
#line 77
typedef int ;

#line 86
typedef unsigned int ;

#line 95
typedef int ;

#line 105
typedef unsigned int ;

#line 112
typedef unsigned short ;

#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"

#pragma once
#line 32

#pragma pack(push, 8)
#line 72
typedef enum _EXCEPTION_DISPOSITION ;

#line 89
struct _EXCEPTION_RECORD ;

#line 90
struct _CONTEXT ;

#line 155

#pragma pack(pop)
#line 25 "C:/NTDDK/inc/ntdef.h"

#pragma once
#line 15 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"

#pragma once
#line 66
typedef wchar_t ;

#line 67
typedef wchar_t ;

#line 127 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long ;

#line 25 "C:/NTDDK/inc/basetsd.h"

#pragma once
#line 36
typedef int ;

#line 37
typedef int ;

#line 43
typedef unsigned int ;

#line 44
typedef unsigned int ;

#line 45
typedef unsigned int ;

#line 84
typedef int ;

#line 85
typedef unsigned int ;

typedef long ;

#line 88
typedef unsigned long ;

#line 248
typedef unsigned short ;

#line 249
typedef short ;

#line 250
typedef unsigned long ;

#line 288
typedef ULONG_PTR ;

#line 289
typedef LONG_PTR ;

#line 295
typedef ULONG_PTR ;

#line 301
typedef __int64 ;

#line 302
typedef __int64 ;

#line 309
typedef unsigned __int64 ;

#line 310
typedef unsigned __int64 ;

#line 311
typedef unsigned __int64 ;

#line 217 "C:/NTDDK/inc/ntdef.h"
typedef void ;

#line 218
typedef void ;

#line 266
typedef char ;

#line 267
typedef short ;

#line 268
typedef long ;

#line 276
typedef wchar_t ;

#line 282
typedef WCHAR ;

#line 283
typedef WCHAR ;

#line 284
typedef const WCHAR ;

#line 285
typedef WCHAR ;

#line 286
typedef WCHAR ;

typedef const WCHAR ;

#line 293
typedef CHAR ;

#line 294
typedef CHAR ;

typedef const CHAR ;

#line 297
typedef CHAR ;

#line 298
typedef CHAR ;

#line 299
typedef const CHAR ;

#line 321
typedef char ;

#line 322
typedef unsigned char ;

#line 326
typedef LPSTR ;

#line 327
typedef LPSTR ;

#line 328
typedef LPCSTR ;

#line 337
typedef double ;

typedef struct _QUAD ;

#line 349
typedef SHORT ;

#line 350
typedef LONG ;

#line 351
typedef QUAD ;

#line 360
typedef unsigned char ;

#line 361
typedef unsigned short ;

#line 362
typedef unsigned long ;

#line 363
typedef QUAD ;

#line 369
typedef UCHAR ;

#line 370
typedef USHORT ;

#line 371
typedef ULONG ;

#line 372
typedef UQUAD ;

#line 378
typedef signed char ;

#line 379
typedef SCHAR ;

#line 394
typedef void ;

#line 400
typedef HANDLE ;

#line 406
typedef UCHAR ;

#line 407
typedef USHORT ;

#line 408
typedef ULONG ;

#line 414
typedef LONG ;

#line 478
typedef char ;

#line 479
typedef short ;

#line 480
typedef ULONG ;

typedef CCHAR ;

#line 483
typedef CSHORT ;

#line 484
typedef CLONG ;

#line 492
typedef ULONG ;

#line 493
typedef PULONG ;

#line 494
typedef USHORT ;

#line 500
typedef ULONG ;

#line 501
typedef ULONG ;

#line 508
typedef LONG ;

typedef NTSTATUS ;

#line 602
typedef struct _FLOAT128 ;

#line 607
typedef FLOAT128 ;

#line 621
typedef __int64 ;

#line 622
typedef unsigned __int64 ;

#line 639
typedef LONGLONG ;

#line 640
typedef ULONGLONG ;

#line 644
typedef LONGLONG ;

#line 649
typedef union _LARGE_INTEGER ;

#line 662
typedef LARGE_INTEGER ;

#line 668
typedef union _ULARGE_INTEGER ;

#line 681
typedef ULARGE_INTEGER ;

#line 690
typedef struct _LUID ;

#line 696
typedef ULONGLONG ;

#line 697
typedef DWORDLONG ;

#line 707
typedef LARGE_INTEGER ;

#line 831

#pragma warning(push)

#pragma warning(disable:4035)
__inline ULONGLONG __stdcall Int64ShllMod32___8(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 842
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    
		};
}

#line 845
__inline LONGLONG __stdcall Int64ShraMod32___8(LONGLONG Value , ULONG ShiftCount
	)
{
	#line 852
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    
		};
}

#line 855
__inline ULONGLONG __stdcall Int64ShrlMod32___8(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 862
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    
		};
}


#pragma warning(pop)
#line 956
typedef enum _EVENT_TYPE ;

#line 965
typedef enum _TIMER_TYPE ;

#line 974
typedef enum _WAIT_TYPE ;

#line 983
typedef CHAR ;

#line 984
typedef const char ;

#line 991
typedef struct _STRING ;

#line 999
typedef STRING ;

typedef STRING ;

#line 1002
typedef PSTRING ;

typedef STRING ;

#line 1005
typedef PSTRING ;

#line 1011
typedef struct _CSTRING ;

#line 1016
typedef CSTRING ;

#line 1019
typedef STRING ;

#line 1020
typedef PSTRING ;

#line 1027
typedef struct _UNICODE_STRING ;

#line 1036
typedef UNICODE_STRING ;

#line 1037
typedef const UNICODE_STRING ;

#line 1046
typedef UCHAR ;

#line 1047
typedef BOOLEAN ;

#line 1057
typedef struct _LIST_ENTRY ;

#line 1067
typedef struct _SINGLE_LIST_ENTRY ;

#line 1078
typedef struct LIST_ENTRY32 ;

#line 1082
typedef LIST_ENTRY32 ;

typedef struct LIST_ENTRY64 ;

#line 1088
typedef LIST_ENTRY64 ;

#line 1127
typedef struct _STRING32 ;

#line 1132
typedef STRING32 ;

typedef STRING32 ;

#line 1135
typedef UNICODE_STRING32 ;

typedef STRING32 ;

#line 1138
typedef ANSI_STRING32 ;

#line 1141
typedef struct _STRING64 ;

#line 1146
typedef STRING64 ;

typedef STRING64 ;

#line 1149
typedef UNICODE_STRING64 ;

typedef STRING64 ;

#line 1152
typedef ANSI_STRING64 ;

#line 1173
typedef struct _OBJECT_ATTRIBUTES ;

#line 1181
typedef OBJECT_ATTRIBUTES ;

#line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID ;

#line 70
typedef GUID ;

#line 75
typedef const GUID ;

#line 81
typedef GUID ;

#line 82
typedef IID ;

#line 85
typedef GUID ;

#line 86
typedef CLSID ;

#line 89
typedef GUID ;

#line 90
typedef FMTID ;

#line 16 "C:/NTDDK/inc/string.h"

#pragma once
#line 1233 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECTID ;

#line 1288
struct _CONTEXT ;

#line 1289
struct _EXCEPTION_RECORD ;

typedef EXCEPTION_DISPOSITION ;

#line 1306
typedef UCHAR ;

typedef KIRQL ;

#line 1316
typedef enum _NT_PRODUCT_TYPE ;

#line 1329
typedef enum _SUITE_TYPE ;

#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD ;

#line 76
typedef struct _ETHREAD ;

#line 77
typedef struct _EPROCESS ;

#line 78
typedef struct _PEB ;

#line 79
typedef struct _KINTERRUPT ;

#line 80
typedef struct _IO_TIMER ;

#line 81
typedef struct _OBJECT_TYPE ;

#line 82
typedef struct _CALLBACK_OBJECT ;

#line 83
typedef struct _DEVICE_HANDLER_OBJECT ;

#line 84
typedef struct _BUS_HANDLER ;

#line 143
typedef union _SLIST_HEADER ;

#line 204
typedef CCHAR ;

typedef enum _MODE ;

#line 222
struct _KAPC ;

typedef void ;

#line 232
typedef void ;

#line 242
typedef void ;

#line 248
typedef BOOLEAN ;

#line 254
typedef BOOLEAN ;

#line 265
typedef struct _KAPC ;

#line 292
struct _KDPC ;

typedef void ;

#line 351
typedef enum _KDPC_IMPORTANCE ;

#line 361
typedef struct _KDPC ;

#line 377
typedef PVOID ;

typedef void ;

#line 392
typedef struct _KIPI_COUNTS ;

#line 443
typedef struct _MDL ;

#line 532
typedef PVOID ;

#line 538
typedef PVOID ;

#line 544
typedef PVOID ;

typedef ULONG ;

#line 547
typedef ACCESS_MASK ;

#line 597
typedef struct _GENERIC_MAPPING ;

#line 603
typedef GENERIC_MAPPING ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES ;

#line 622
typedef LUID_AND_ATTRIBUTES ;

#line 623
typedef LUID_AND_ATTRIBUTES_ARRAY ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 642 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACL ;

#line 649
typedef ACL ;

#line 681
typedef struct _PRIVILEGE_SET ;

#line 735
typedef enum _SECURITY_IMPERSONATION_LEVEL ;

#line 753
typedef BOOLEAN ;

#line 762
typedef struct _SECURITY_QUALITY_OF_SERVICE ;

#line 774
typedef struct _SE_IMPERSONATION_STATE ;

#line 782
typedef ULONG ;

#line 809
typedef ULONG ;

#line 810
typedef KAFFINITY ;

#line 816
typedef LONG ;

#line 824
typedef ULONG_PTR ;

#line 825
typedef KSPIN_LOCK ;

#line 833
typedef void ;

#line 842
typedef enum _KPROFILE_SOURCE ;

#line 1079
typedef NTSTATUS ;

#line 1088
typedef struct _RTL_QUERY_REGISTRY_TABLE ;

#line 1952

#pragma warning(push)

#pragma warning(disable:4035)
#line 2019

#pragma warning(pop)
#line 2214
typedef struct _TIME_FIELDS ;

#line 2224
typedef TIME_FIELDS ;

#line 2499
typedef struct _RTL_BITMAP ;

#line 2503
typedef RTL_BITMAP ;

#line 2627
typedef struct _RTL_BITMAP_RUN ;

#line 2633
typedef RTL_BITMAP_RUN ;

#line 2886
typedef struct _RTL_RANGE ;

#line 2924
typedef struct _RTL_RANGE_LIST ;

#line 2950
typedef struct _RANGE_LIST_ITERATOR ;

#line 3019
typedef BOOLEAN ;

#line 3155
typedef struct _OSVERSIONINFOA ;

#line 3164
typedef struct _OSVERSIONINFOW ;

#line 3177
typedef OSVERSIONINFOA ;

#line 3178
typedef POSVERSIONINFOA ;

#line 3179
typedef LPOSVERSIONINFOA ;

#line 3182
typedef struct _OSVERSIONINFOEXA ;

#line 3195
typedef struct _OSVERSIONINFOEXW ;

#line 3213
typedef OSVERSIONINFOEXA ;

#line 3214
typedef POSVERSIONINFOEXA ;

#line 3215
typedef LPOSVERSIONINFOEXA ;

#line 3648
typedef struct _IO_STATUS_BLOCK ;

#line 3669
typedef void ;

#line 3685
typedef enum _FILE_INFORMATION_CLASS ;

#line 3731
typedef struct _FILE_BASIC_INFORMATION ;

#line 3739
typedef struct _FILE_STANDARD_INFORMATION ;

#line 3747
typedef struct _FILE_POSITION_INFORMATION ;

#line 3751
typedef struct _FILE_ALIGNMENT_INFORMATION ;

#line 3755
typedef struct _FILE_NAME_INFORMATION ;

#line 3760
typedef struct _FILE_NETWORK_OPEN_INFORMATION ;

#line 3770
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION ;

#line 3775
typedef struct _FILE_DISPOSITION_INFORMATION ;

#line 3779
typedef struct _FILE_END_OF_FILE_INFORMATION ;

#line 3784
typedef struct _FILE_FULL_EA_INFORMATION ;

#line 3798
typedef enum _FSINFOCLASS ;

#line 3810
typedef struct _FILE_FS_DEVICE_INFORMATION ;

#line 3820
typedef union _FILE_SEGMENT_ELEMENT ;

#line 3829
typedef enum _INTERFACE_TYPE ;

#line 3854
typedef enum _DMA_WIDTH ;

#line 3865
typedef enum _DMA_SPEED ;

#line 3879
typedef void ;

#line 3880
typedef void ;

#line 3888
typedef enum _BUS_DATA_TYPE ;

#line 3910
typedef struct _IO_ERROR_LOG_PACKET ;

#line 3931
typedef struct _IO_ERROR_LOG_MESSAGE ;

#line 4074
typedef struct _KEY_BASIC_INFORMATION ;

#line 4081
typedef struct _KEY_NODE_INFORMATION ;

#line 4091
typedef struct _KEY_FULL_INFORMATION ;

#line 4106
typedef struct _KEY_NAME_INFORMATION ;

#line 4112
typedef enum _KEY_INFORMATION_CLASS ;

#line 4122
typedef struct _KEY_WRITE_TIME_INFORMATION ;

#line 4126
typedef enum _KEY_SET_INFORMATION_CLASS ;

#line 4134
typedef struct _KEY_VALUE_BASIC_INFORMATION ;

#line 4141
typedef struct _KEY_VALUE_FULL_INFORMATION ;

#line 4151
typedef struct _KEY_VALUE_PARTIAL_INFORMATION ;

#line 4158
typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ;

#line 4164
typedef struct _KEY_VALUE_ENTRY ;

#line 4171
typedef enum _KEY_VALUE_INFORMATION_CLASS ;

#line 4210
typedef struct _OBJECT_NAME_INFORMATION ;

#line 4221
typedef enum _SECTION_INHERIT ;

#line 4294
typedef struct _CLIENT_ID ;

#line 4298
typedef CLIENT_ID ;

#line 4315
typedef struct _NT_TIB ;

#line 4327
typedef NT_TIB ;

#line 4332
typedef enum _PROCESSINFOCLASS ;

#line 4366
typedef enum _THREADINFOCLASS ;

#line 4395
typedef struct _PROCESS_WS_WATCH_INFORMATION ;

#line 4405
typedef struct _PROCESS_BASIC_INFORMATION ;

#line 4413
typedef PROCESS_BASIC_INFORMATION ;

#line 4422
typedef struct _PROCESS_DEVICEMAP_INFORMATION ;

#line 4440
typedef struct _PROCESS_SESSION_INFORMATION ;

#line 4454
typedef struct _QUOTA_LIMITS ;

#line 4462
typedef QUOTA_LIMITS ;

#line 4472
typedef struct _IO_COUNTERS ;

#line 4480
typedef IO_COUNTERS ;

#line 4488
typedef struct _VM_COUNTERS ;

#line 4501
typedef VM_COUNTERS ;

#line 4508
typedef struct _POOLED_USAGE_AND_LIMITS ;

#line 4519
typedef POOLED_USAGE_AND_LIMITS ;

#line 4528
typedef struct _PROCESS_ACCESS_TOKEN ;

#line 4555
typedef struct _KERNEL_USER_TIMES ;

#line 4561
typedef KERNEL_USER_TIMES ;

#line 4587
typedef enum _SYSTEM_POWER_STATE ;

#line 4598
typedef enum  {
	PowerActionNone = 0,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
} ;

typedef enum _DEVICE_POWER_STATE ;

#line 4618
typedef union _POWER_STATE ;

#line 4623
typedef enum _POWER_STATE_TYPE ;

#line 4654
typedef ULONG ;

typedef enum  {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
} ;

#line 4663
typedef enum  {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation
} ;

#line 4690
typedef ULONG ;

typedef LONG ;

#line 4693
typedef ULONG ;

#line 4719
typedef union _MCI_STATS ;

#line 4978
typedef struct _KPCR ;

#line 5006
typedef KPCR ;

#line 5012
typedef struct _KFLOATING_SAVE ;

#line 5153
typedef enum _INTERLOCKED_RESULT ;

#line 5252

#pragma warning(disable:4035)
#line 6994
typedef struct _KSYSTEM_TIME ;

#line 7014

#pragma warning(push)

#pragma warning(disable:4164)
#line 7019

#pragma function(_enable)
#line 7020

#pragma function(_disable)
#line 7024

#pragma warning(pop)
#line 7085
typedef struct _FLOATING_SAVE_AREA ;

#line 7097
typedef FLOATING_SAVE_AREA ;

#line 7109
typedef struct _CONTEXT ;

#line 7197
typedef CONTEXT ;

#line 7826
typedef void ;

#line 7850
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ;

#line 7899
typedef struct _KUSER_SHARED_DATA ;

#line 8123
typedef enum _CM_SERVICE_NODE_TYPE ;

#line 8132
typedef enum _CM_SERVICE_LOAD_TYPE ;

#line 8140
typedef enum _CM_ERROR_CONTROL_TYPE ;

#line 8172
typedef int ;

#line 8198
typedef enum _CM_SHARE_DISPOSITION ;

#line 8211
typedef PVOID ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST ;

#line 8443
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR ;

#line 8454
typedef struct _CM_RESOURCE_LIST ;

#line 8471
typedef struct _DEVICE_FLAGS ;

#line 8485
typedef struct _CM_COMPONENT_INFORMATION ;

#line 8503
typedef struct _CM_ROM_BLOCK ;

#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 8518 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_INT13_DRIVE_PARAMETER ;

#line 8532
typedef struct _CM_MCA_POS_DATA ;

#line 8544
typedef struct _EISA_MEMORY_TYPE ;

#line 8554
typedef struct _EISA_MEMORY_CONFIGURATION ;

#line 8567
typedef struct _EISA_IRQ_DESCRIPTOR ;

#line 8575
typedef struct _EISA_IRQ_CONFIGURATION ;

#line 8585
typedef struct _DMA_CONFIGURATION_BYTE0 ;

#line 8592
typedef struct _DMA_CONFIGURATION_BYTE1 ;

#line 8599
typedef struct _EISA_DMA_CONFIGURATION ;

#line 8609
typedef struct _EISA_PORT_DESCRIPTOR ;

#line 8616
typedef struct _EISA_PORT_CONFIGURATION ;

#line 8628
typedef struct _CM_EISA_SLOT_INFORMATION ;

#line 8644
typedef struct _CM_EISA_FUNCTION_INFORMATION ;

#line 8678
typedef struct _CM_PNP_BIOS_DEVICE_NODE ;

#line 8692
typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8761 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_SCSI_DEVICE_DATA ;

#line 8775
typedef struct _CM_VIDEO_DEVICE_DATA ;

#line 8785
typedef struct _CM_SONIC_DEVICE_DATA ;

#line 8796
typedef struct _CM_SERIAL_DEVICE_DATA ;

#line 8810
typedef struct _CM_MONITOR_DEVICE_DATA ;

#line 8844
typedef struct _CM_FLOPPY_DEVICE_DATA ;

#line 8881
typedef struct _CM_KEYBOARD_DEVICE_DATA ;

#line 8893
typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA ;

#line 8905
typedef struct _CM_PCCARD_DEVICE_DATA ;

#line 8944
typedef struct _IO_RESOURCE_DESCRIPTOR ;

#line 9027
typedef struct _IO_RESOURCE_LIST ;

#line 9036
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST ;

#line 9065
typedef struct _EXCEPTION_RECORD ;

#line 9074
typedef EXCEPTION_RECORD ;

typedef struct _EXCEPTION_RECORD32 ;

#line 9085
typedef struct _EXCEPTION_RECORD64 ;

#line 9099
typedef struct _EXCEPTION_POINTERS ;

#line 9111
typedef enum _CONFIGURATION_TYPE ;

#line 9161
typedef enum _KINTERRUPT_MODE ;

#line 9170
typedef enum _KWAIT_REASON ;

#line 9207
typedef struct _DISPATCHER_HEADER ;

#line 9217
typedef struct _KWAIT_BLOCK ;

#line 9230
typedef void ;

#line 9244
typedef struct _KDEVICE_QUEUE ;

#line 9252
typedef struct _KDEVICE_QUEUE_ENTRY ;

#line 9263
typedef struct _KEVENT ;

#line 9271
typedef BOOLEAN ;

#line 9281
typedef struct _KMUTANT ;

#line 9294
typedef struct _KSEMAPHORE ;

#line 9304
typedef struct _KTIMER ;

#line 9899
typedef enum _KBUGCHECK_BUFFER_DUMP_STATE ;

#line 9907
typedef void ;

#line 9914
typedef struct _KBUGCHECK_CALLBACK_RECORD ;

#line 10002
typedef void ;

#line 10020
typedef LOGICAL ;

#line 10037
typedef void ;

#line 10053
typedef enum _MEMORY_CACHING_TYPE_ORIG ;

#line 10057
typedef enum _MEMORY_CACHING_TYPE ;

#line 10087
typedef struct _DBGKD_DEBUG_DATA_HEADER64 ;

#line 10115
typedef enum _POOL_TYPE ;

#line 10195
typedef enum _EX_POOL_PRIORITY ;

#line 10247
typedef struct _FAST_MUTEX ;

#line 10574
typedef PVOID ;

#line 10582
typedef void ;

#line 10588
typedef struct _GENERAL_LOOKASIDE ;

#line 10619
typedef struct _NPAGED_LOOKASIDE_LIST ;

#line 10729
typedef struct _PAGED_LOOKASIDE_LIST ;

#line 10882
typedef enum _WORK_QUEUE_TYPE ;

#line 10889
typedef void ;

#line 10895
typedef struct _WORK_QUEUE_ITEM ;

#line 10926
typedef struct _ZONE_SEGMENT_HEADER ;

#line 10931
typedef struct _ZONE_HEADER ;

#line 11156
typedef ULONG_PTR ;

#line 11157
typedef ERESOURCE_THREAD ;

typedef struct _OWNER_ENTRY ;

#line 11168
typedef struct _ERESOURCE ;

#line 11197
typedef struct _RESOURCE_HASH_ENTRY ;

#line 11204
typedef struct _RESOURCE_PERFORMANCE_DATA ;

#line 11429
typedef struct _CALLBACK_OBJECT ;

typedef void ;

#line 11474
typedef GUID ;

#line 11862
typedef enum _MM_SYSTEM_SIZE ;

#line 11884
typedef enum _LOCK_OPERATION ;

#line 11970
typedef enum _MM_PAGE_PRIORITY ;

#line 11999
typedef struct _PHYSICAL_MEMORY_RANGE ;

#line 12385
typedef NTSTATUS ;

#line 12389
typedef NTSTATUS ;

#line 12399
struct _DRIVER_OBJECT ;

#line 12411
typedef enum _SECURITY_OPERATION_CODE ;

#line 12426
typedef struct _SECURITY_SUBJECT_CONTEXT ;

#line 12448
typedef struct _INITIAL_PRIVILEGE_SET ;

#line 12462
typedef struct _ACCESS_STATE ;

#line 12571
typedef void ;

#line 12585
typedef void ;

#line 12602
typedef struct _IMAGE_INFO ;

#line 12620
typedef void ;

#line 12859
typedef NTSTATUS ;

#line 12878
typedef enum _IO_QUERY_DEVICE_DATA_FORMAT ;

#line 12890
typedef enum _CREATE_FILE_TYPE ;

#line 12905
struct _DEVICE_DESCRIPTION ;

#line 12906
struct _DEVICE_OBJECT ;

#line 12907
struct _DMA_ADAPTER ;

#line 12908
struct _DRIVER_OBJECT ;

#line 12909
struct _DRIVE_LAYOUT_INFORMATION ;

#line 12910
struct _DISK_PARTITION ;

#line 12911
struct _FILE_OBJECT ;

#line 12912
struct _IRP ;

#line 12913
struct _SCSI_REQUEST_BLOCK ;

#line 12919
typedef void ;

#line 12932
typedef void ;

#line 12943
typedef NTSTATUS ;

#line 12955
typedef void ;

#line 12968
typedef void ;

#line 12979
typedef NTSTATUS ;

#line 12990
typedef void ;

#line 13001
typedef void ;

#line 13011
typedef NTSTATUS ;

#line 13025
typedef BOOLEAN ;

#line 13038
typedef BOOLEAN ;

#line 13051
typedef BOOLEAN ;

#line 13068
typedef BOOLEAN ;

#line 13078
typedef BOOLEAN ;

#line 13092
typedef BOOLEAN ;

#line 13106
typedef BOOLEAN ;

#line 13118
typedef BOOLEAN ;

#line 13127
typedef BOOLEAN ;

#line 13141
typedef BOOLEAN ;

#line 13161
typedef void ;

#line 13167
typedef void ;

#line 13179
typedef void ;

#line 13193
typedef BOOLEAN ;

#line 13207
typedef BOOLEAN ;

#line 13219
typedef BOOLEAN ;

#line 13227
typedef BOOLEAN ;

#line 13239
typedef BOOLEAN ;

#line 13253
typedef NTSTATUS ;

#line 13262
typedef NTSTATUS ;

#line 13275
typedef NTSTATUS ;

#line 13282
typedef NTSTATUS ;

#line 13289
typedef BOOLEAN ;

#line 13304
typedef BOOLEAN ;

#line 13319
typedef BOOLEAN ;

#line 13327
typedef BOOLEAN ;

#line 13336
typedef BOOLEAN ;

#line 13350
typedef struct _FAST_IO_DISPATCH ;

#line 13386
typedef enum _IO_ALLOCATION_ACTION ;

#line 13396
typedef IO_ALLOCATION_ACTION ;

#line 13410
typedef struct _IO_SECURITY_CONTEXT ;

#line 13434
typedef struct _VPB ;

#line 13482
typedef struct _ADAPTER_OBJECT ;

#line 13491
typedef struct _WAIT_CONTEXT_BLOCK ;

#line 13503
typedef struct _CONTROLLER_OBJECT ;

#line 13537
typedef struct _DEVICE_OBJECT ;

#line 13575
typedef struct _DEVICE_OBJECT ;

#line 13578
struct _DEVICE_OBJECT_POWER_EXTENSION ;

typedef struct _DEVOBJ_EXTENSION ;

#line 13608
typedef struct _DRIVER_EXTENSION ;

#line 13645
typedef struct _DRIVER_OBJECT ;

#line 13706
typedef struct _DRIVER_OBJECT ;

#line 13715
typedef struct _SECTION_OBJECT_POINTERS ;

#line 13720
typedef SECTION_OBJECT_POINTERS ;

#line 13726
typedef struct _IO_COMPLETION_CONTEXT ;

#line 13759
typedef struct _FILE_OBJECT ;

#line 13788
typedef struct _FILE_OBJECT ;

#line 13828
typedef struct _IRP ;

#line 14078
typedef NTSTATUS ;

#line 14163
typedef enum _DEVICE_RELATION_TYPE ;

#line 14171
typedef struct _DEVICE_RELATIONS ;

#line 14176
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE ;

#line 14185
typedef struct _INTERFACE ;

#line 14196
typedef struct _DEVICE_CAPABILITIES ;

#line 14229
typedef struct _POWER_SEQUENCE ;

#line 14235
typedef enum  {
	BusQueryDeviceID = 0,
	BusQueryHardwareIDs = 1,
	BusQueryCompatibleIDs = 2,
	BusQueryInstanceID = 3,
	BusQueryDeviceSerialNumber = 4
} ;

typedef ULONG ;

#line 14252
typedef enum  {
	DeviceTextDescription = 0,
	DeviceTextLocationInformation = 1
} ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 14615 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SHARE_ACCESS ;

#line 14635
typedef struct _CONFIGURATION_INFORMATION ;

#line 14848
typedef struct _BOOTDISK_INFORMATION ;

#line 15754
typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK ;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK ;

#line 15764
typedef struct _IO_REMOVE_LOCK_DBG_BLOCK ;

#line 15777
typedef struct _IO_REMOVE_LOCK ;

#line 16009
typedef struct _IO_WORKITEM ;

typedef void ;

#line 16100
typedef enum  {
	DevicePropertyDeviceDescription,
	DevicePropertyHardwareID,
	DevicePropertyCompatibleIDs,
	DevicePropertyBootConfiguration,
	DevicePropertyBootConfigurationTranslated,
	DevicePropertyClassName,
	DevicePropertyClassGuid,
	DevicePropertyDriverKeyName,
	DevicePropertyManufacturer,
	DevicePropertyFriendlyName,
	DevicePropertyLocationInformation,
	DevicePropertyPhysicalDeviceObjectName,
	DevicePropertyBusTypeGuid,
	DevicePropertyLegacyBusType,
	DevicePropertyBusNumber,
	DevicePropertyEnumeratorName,
	DevicePropertyAddress,
	DevicePropertyUINumber
} ;

typedef BOOLEAN ;

#line 16129
typedef struct _DMA_ADAPTER ;

#line 16135
typedef ULONG ;

#line 16148
typedef struct _PNP_BUS_INFORMATION ;

#line 16162
typedef struct _LEGACY_BUS_INFORMATION ;

#line 16168
typedef struct _BUS_INTERFACE_STANDARD ;

#line 16190
typedef BOOLEAN ;

#line 16194
typedef NTSTATUS ;

#line 16203
typedef NTSTATUS ;

#line 16206
typedef NTSTATUS ;

#line 16210
typedef NTSTATUS ;

#line 16214
typedef NTSTATUS ;

#line 16218
typedef void ;

#line 16222
typedef NTSTATUS ;

#line 16227
typedef void ;

#line 16231
typedef struct _ACPI_INTERFACE_STANDARD ;

#line 16255
typedef enum _ACPI_REG_TYPE ;

#line 16268
typedef USHORT ;

#line 16272
typedef void ;

#line 16278
typedef struct ACPI_REGS_INTERFACE_STANDARD ;

#line 16300
typedef struct  {
	PVOID LinkNode ;
	ULONG StaticVector ;
	UCHAR Flags ;
} ;

#line 16314
typedef NTSTATUS ;

#line 16329
typedef NTSTATUS ;

#line 16336
typedef void ;

#line 16343
typedef struct _INT_ROUTE_INTERFACE_STANDARD ;

#line 16366
typedef struct _IO_ASSIGNED_RESOURCES ;

#line 16490
typedef enum _IO_NOTIFICATION_EVENT_CATEGORY ;

#line 16504
typedef NTSTATUS ;

#line 16537
typedef void ;

#line 16573
typedef enum _ARBITER_ACTION ;

#line 16586
typedef struct _ARBITER_CONFLICT_INFO ;

#line 16608
typedef struct _ARBITER_PARAMETERS ;

#line 16719
typedef enum _ARBITER_REQUEST_SOURCE ;

#line 16731
typedef enum _ARBITER_RESULT ;

#line 16761
typedef struct _ARBITER_LIST_ENTRY ;

#line 16832
typedef NTSTATUS ;

#line 16853
typedef struct _ARBITER_INTERFACE ;

#line 16880
typedef enum _RESOURCE_TRANSLATION_DIRECTION ;

#line 16889
typedef NTSTATUS ;

#line 16901
typedef NTSTATUS ;

#line 16915
typedef struct _TRANSLATOR_INTERFACE ;

#line 16931
typedef NTSTATUS ;

#line 16945
typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE ;

#line 16959
typedef struct _PLUGPLAY_NOTIFICATION_HEADER ;

#line 16972
typedef struct _HWPROFILE_CHANGE_NOTIFICATION ;

#line 16986
typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION ;

#line 17006
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION ;

#line 17026
typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION ;

#line 17054
typedef struct _DEVICE_DESCRIPTION ;

#line 17086
typedef BOOLEAN ;

#line 17333
typedef void ;

#line 17339
typedef struct _DEVICE_CONTROL_CONTEXT ;

#line 17349
typedef PBUS_HANDLER ;

#line 17355
typedef void ;

#line 17365
typedef enum _HAL_QUERY_INFORMATION_CLASS ;

#line 17381
typedef enum _HAL_SET_INFORMATION_CLASS ;

#line 17388
typedef NTSTATUS ;

#line 17405
typedef NTSTATUS ;

#line 17420
typedef void ;

#line 17429
typedef void ;

#line 17438
typedef NTSTATUS ;

#line 17447
typedef NTSTATUS ;

#line 17456
typedef NTSTATUS ;

#line 17466
typedef NTSTATUS ;

#line 17475
typedef NTSTATUS ;

#line 17486
typedef struct _PM_DISPATCH_TABLE ;

#line 17492
typedef NTSTATUS ;

#line 17505
typedef struct _DMA_ADAPTER ;

#line 17520
typedef NTSTATUS ;

#line 17543
typedef BOOLEAN ;

#line 17553
typedef NTSTATUS ;

#line 17566
typedef void ;

#line 17572
typedef void ;

#line 17578
typedef BOOLEAN ;

#line 17588
typedef struct  {
	ULONG Version ;
	pHalQuerySystemInformation HalQuerySystemInformation ;
	pHalSetSystemInformation HalSetSystemInformation ;
	pHalQueryBusSlots HalQueryBusSlots ;
	ULONG Spare1 ;
	pHalExamineMBR HalExamineMBR ;
	pHalIoAssignDriveLetters HalIoAssignDriveLetters ;
	pHalIoReadPartitionTable HalIoReadPartitionTable ;
	pHalIoSetPartitionInformation HalIoSetPartitionInformation ;
	pHalIoWritePartitionTable HalIoWritePartitionTable ;
	pHalHandlerForBus HalReferenceHandlerForBus ;
	pHalReferenceBusHandler HalReferenceBusHandler ;
	pHalReferenceBusHandler HalDereferenceBusHandler ;
	pHalInitPnpDriver HalInitPnpDriver ;
	pHalInitPowerManagement HalInitPowerManagement ;
	pHalGetDmaAdapter HalGetDmaAdapter ;
	pHalGetInterruptTranslator HalGetInterruptTranslator ;
} ;

#line 17650
typedef struct _HAL_BUS_INFORMATION ;

#line 17658
typedef struct _HAL_PROFILE_SOURCE_INFORMATION ;

#line 17665
typedef struct _HAL_PROFILE_SOURCE_INTERVAL ;

#line 17671
typedef enum _HAL_DISPLAY_BIOS_INFORMATION ;

#line 17678
typedef struct _HAL_POWER_INFORMATION ;

#line 17683
typedef struct _HAL_PROCESSOR_SPEED_INFO ;

#line 17688
typedef struct _HAL_CALLBACKS ;

#line 17694
typedef struct _HAL_PROCESSOR_FEATURE ;

#line 17706
typedef union _MCI_ADDR ;

#line 17716
typedef enum  {
	HAL_MCE_RECORD,
	HAL_MCA_RECORD
} ;

#line 17726
typedef struct _MCA_EXCEPTION ;

#line 17752
typedef void ;

#line 17762
typedef struct _MCA_DRIVER_INFO ;

#line 17772
typedef struct _SCATTER_GATHER_ELEMENT ;

#line 17778

#pragma warning(disable:4200)
#line 17779
typedef struct _SCATTER_GATHER_LIST ;

#line 17784

#pragma warning(default:4200)
#line 17788
typedef struct _DMA_OPERATIONS ;

typedef struct _DMA_ADAPTER ;

#line 17797
typedef void ;

#line 17801
typedef PVOID ;

#line 17808
typedef void ;

#line 17816
typedef NTSTATUS ;

#line 17824
typedef BOOLEAN ;

#line 17833
typedef void ;

#line 17837
typedef void ;

#line 17843
typedef PHYSICAL_ADDRESS ;

#line 17852
typedef ULONG ;

#line 17856
typedef ULONG ;

#line 17860
typedef void ;

#line 17868
typedef NTSTATUS ;

#line 17880
typedef void ;

#line 17887
typedef struct _DMA_OPERATIONS ;

#line 18235
typedef void ;

#line 18321
typedef struct _OBJECT_HANDLE_INFORMATION ;

#line 18402
typedef struct _PCI_SLOT_NUMBER ;

#line 18418
typedef struct _PCI_COMMON_CONFIG ;

#line 18591
typedef struct _PCI_CAPABILITIES_HEADER ;

#line 18600
typedef struct _PCI_PMC ;

#line 18618
typedef struct _PCI_PMCSR ;

#line 18628
typedef struct _PCI_PMCSR_BSE ;

#line 18635
typedef struct _PCI_PM_CAPABILITY ;

#line 18679
typedef struct _PCI_AGP_CAPABILITY ;

#line 18720
typedef struct _PCI_MSI_CAPABILITY ;

#line 18946
typedef void ;

#line 18954
typedef void ;

#line 18963
typedef void ;

#line 18975
typedef struct _PCIBUSDATA ;

#line 18986
typedef ULONG ;

#line 18995
typedef void ;

#line 19000
typedef void ;

#line 19006
typedef struct _PCI_BUS_INTERFACE_STANDARD ;

#line 19028
typedef BOOLEAN ;

#line 19043
typedef struct _PCI_DEVICE_PRESENT_INTERFACE ;

#line 127 "C:/NTDDK/inc/ntddser.h"
typedef struct _SERIALPERF_STATS ;

#line 136
typedef struct _SERIALCONFIG ;

#line 154
typedef struct _SERIAL_LINE_CONTROL ;

#line 160
typedef struct _SERIAL_TIMEOUTS ;

#line 175
typedef struct _SERIAL_QUEUE_SIZE ;

#line 185
typedef struct _SERIAL_BAUD_RATE ;

#line 247
typedef struct _SERIAL_CHARS ;

#line 284
typedef struct _SERIAL_HANDFLOW ;

#line 340
typedef struct _SERIAL_BASIC_SETTINGS ;

#line 353
typedef struct _SERIAL_STATUS ;

#line 433
typedef struct _SERIAL_XOFF_COUNTER ;

#line 539
typedef struct _SERIAL_COMMPROP ;

#line 631
typedef struct _SERENUM_PORT_DESC ;

#line 652
typedef UCHAR ;

#line 658
typedef void ;

#line 665
typedef enum _SERENUM_PORTION ;

#line 671
typedef struct _SERENUM_PORT_PARAMETERS ;

#line 28 "C:/NTDDK/inc/ddk/wdm/wmilib.h"

#pragma once
#line 38
typedef struct  {
	LPCGUID Guid ;
	ULONG InstanceCount ;
	ULONG Flags ;
} ;

#line 45
typedef NTSTATUS ;

#line 101
typedef NTSTATUS ;

#line 162
typedef NTSTATUS ;

#line 206
typedef NTSTATUS ;

#line 253
typedef NTSTATUS ;

#line 306
typedef enum  {
	WmiEventControl,
	WmiDataBlockControl
} ;

#line 312
typedef NTSTATUS ;

#line 355
typedef struct _WMILIB_CONTEXT ;

#line 411
typedef enum  {
	IrpProcessed,
	IrpNotCompleted,
	IrpNotWmi,
	IrpForward
} ;

#line 13 "C:/NTDDK/inc/wmidata.h"
typedef struct _MSWmi_MofData ;

#line 51
typedef struct _MSWmi_ProviderInfo ;

#line 66
typedef struct _MSWmi_PnPDeviceId ;

#line 83
typedef struct _MSWmi_PnPInstanceNames ;

#line 105
typedef struct _MSSmBios_RawSMBiosTables ;

#line 147
typedef struct _MSPower_DeviceEnable ;

#line 165
typedef struct _MSPower_DeviceWakeEnable ;

#line 182
typedef struct _MSNdis_NetworkAddress ;

#line 199
typedef struct _MSNdis_NetworkShortAddress ;

#line 216
typedef struct _MSNdis_NetworkLinkSpeed ;

#line 239
typedef struct _MSNdis_EnumerateAdapter ;

#line 256
typedef struct _MSNdis_NotifyAdapterRemoval ;

#line 273
typedef struct _MSNdis_NotifyAdapterArrival ;

#line 291
typedef struct _MSNdis_NdisEnumerateVc ;

#line 307
typedef struct _MSNdis_NotifyVcRemoval ;

#line 323
typedef struct _MSNdis_NotifyVcArrival ;

#line 338
typedef struct _MSNdis_HardwareStatus ;

#line 356
typedef struct _MSNdis_MediaSupported ;

#line 378
typedef struct _MSNdis_MediaInUse ;

#line 400
typedef struct _MSNdis_MaximumLookahead ;

#line 418
typedef struct _MSNdis_MaximumFrameSize ;

#line 436
typedef struct _MSNdis_LinkSpeed ;

#line 454
typedef struct _MSNdis_TransmitBufferSpace ;

#line 472
typedef struct _MSNdis_ReceiveBufferSpace ;

#line 490
typedef struct _MSNdis_TransmitBlockSize ;

#line 508
typedef struct _MSNdis_ReceiveBlockSize ;

#line 526
typedef struct _MSNdis_VendorID ;

#line 544
typedef struct _MSNdis_VendorDescription ;

#line 561
typedef struct _MSNdis_CurrentPacketFilter ;

#line 579
typedef struct _MSNdis_CurrentLookahead ;

#line 597
typedef struct _MSNdis_DriverVersion ;

#line 615
typedef struct _MSNdis_MaximumTotalSize ;

#line 633
typedef struct _MSNdis_MacOptions ;

#line 651
typedef struct _MSNdis_MediaConnectStatus ;

#line 669
typedef struct _MSNdis_MaximumSendPackets ;

#line 687
typedef struct _MSNdis_VendorDriverVersion ;

#line 705
typedef struct _MSNdis_TransmitsOk ;

#line 723
typedef struct _MSNdis_ReceivesOk ;

#line 741
typedef struct _MSNdis_TransmitsError ;

#line 759
typedef struct _MSNdis_ReceiveError ;

#line 777
typedef struct _MSNdis_ReceiveNoBuffer ;

#line 795
typedef struct _MSNdis_CoHardwareStatus ;

#line 813
typedef struct _MSNdis_CoMediaSupported ;

#line 835
typedef struct _MSNdis_CoMediaInUse ;

#line 857
typedef struct _MSNdis_CoLinkSpeed ;

#line 875
typedef struct _MSNdis_CoVendorId ;

#line 893
typedef struct _MSNdis_CoVendorDescription ;

#line 910
typedef struct _MSNdis_CoDriverVersion ;

#line 928
typedef struct _MSNdis_CoMacOptions ;

#line 946
typedef struct _MSNdis_CoMediaConnectStatus ;

#line 964
typedef struct _MSNdis_CoVendorDriverVersion ;

#line 982
typedef struct _MSNdis_CoMinimumLinkSpeed ;

#line 1000
typedef struct _MSNdis_CoTransmitPdusOk ;

#line 1018
typedef struct _MSNdis_CoReceivePdusOk ;

#line 1036
typedef struct _MSNdis_CoTransmitPduErrors ;

#line 1054
typedef struct _MSNdis_CoReceivePduErrors ;

#line 1072
typedef struct _MSNdis_CoReceivePdusNoBuffer ;

#line 1090
typedef struct _MSNdis_AtmSupportedVcRates ;

#line 1113
typedef struct _MSNdis_AtmSupportedServiceCategory ;

#line 1131
typedef struct _MSNdis_AtmSupportedAalTypes ;

#line 1149
typedef struct _MSNdis_AtmHardwareCurrentAddress ;

#line 1167
typedef struct _MSNdis_AtmMaxActiveVcs ;

#line 1185
typedef struct _MSNdis_AtmMaxActiveVciBits ;

#line 1203
typedef struct _MSNdis_AtmMaxActiveVpiBits ;

#line 1221
typedef struct _MSNdis_AtmMaxAal0PacketSize ;

#line 1239
typedef struct _MSNdis_AtmMaxAal1PacketSize ;

#line 1257
typedef struct _MSNdis_AtmMaxAal34PacketSize ;

#line 1275
typedef struct _MSNdis_AtmMaxAal5PacketSize ;

#line 1293
typedef struct _MSNdis_AtmReceiveCellsOk ;

#line 1311
typedef struct _MSNdis_AtmTransmitCellsOk ;

#line 1329
typedef struct _MSNdis_AtmReceiveCellsDropped ;

#line 1347
typedef struct _MSNdis_EthernetPermanentAddress ;

#line 1365
typedef struct _MSNdis_EthernetCurrentAddress ;

#line 1383
typedef struct _MSNdis_EthernetMulticastList ;

#line 1405
typedef struct _MSNdis_EthernetMaximumMulticastListSize ;

#line 1423
typedef struct _MSNdis_EthernetMacOptions ;

#line 1441
typedef struct _MSNdis_EthernetReceiveErrorAlignment ;

#line 1459
typedef struct _MSNdis_EthernetOneTransmitCollision ;

#line 1477
typedef struct _MSNdis_EthernetMoreTransmitCollisions ;

#line 1495
typedef struct _MSNdis_TokenRingPermanentAddress ;

#line 1513
typedef struct _MSNdis_TokenRingCurrentAddress ;

#line 1531
typedef struct _MSNdis_TokenRingCurrentFunctional ;

#line 1549
typedef struct _MSNdis_TokenRingCurrentGroup ;

#line 1567
typedef struct _MSNdis_TokenRingLastOpenStatus ;

#line 1585
typedef struct _MSNdis_TokenRingCurrentRingStatus ;

#line 1603
typedef struct _MSNdis_TokenRingCurrentRingState ;

#line 1621
typedef struct _MSNdis_TokenRingLineErrors ;

#line 1639
typedef struct _MSNdis_TokenRingLostFrames ;

#line 1657
typedef struct _MSNdis_FddiLongPermanentAddress ;

#line 1675
typedef struct _MSNdis_FddiLongCurrentAddress ;

#line 1693
typedef struct _MSNdis_FddiLongMulticastList ;

#line 1715
typedef struct _MSNdis_FddiLongMaximumListSize ;

#line 1733
typedef struct _MSNdis_FddiShortPermanentAddress ;

#line 1751
typedef struct _MSNdis_FddiShortCurrentAddress ;

#line 1769
typedef struct _MSNdis_FddiShortMulticastList ;

#line 1791
typedef struct _MSNdis_FddiShortMaximumListSize ;

#line 1809
typedef struct _MSNdis_FddiAttachmentType ;

#line 1827
typedef struct _MSNdis_FddiUpstreamNodeLong ;

#line 1845
typedef struct _MSNdis_FddiDownstreamNodeLong ;

#line 1863
typedef struct _MSNdis_FddiFrameErrors ;

#line 1881
typedef struct _MSNdis_FddiFramesLost ;

#line 1899
typedef struct _MSNdis_FddiRingManagmentState ;

#line 1917
typedef struct _MSNdis_FddiLctFailures ;

#line 1935
typedef struct _MSNdis_FddiLemRejects ;

#line 1953
typedef struct _MSNdis_FddiLConnectionState ;

#line 1972
typedef struct _MSNdis_StatusResetStart ;

#line 1988
typedef struct _MSNdis_StatusResetEnd ;

#line 2004
typedef struct _MSNdis_StatusMediaConnect ;

#line 2020
typedef struct _MSNdis_StatusMediaDisconnect ;

#line 2035
typedef struct _MSNdis_StatusMediaSpecificIndication ;

#line 2057
typedef struct _MSNdis_StatusLinkSpeedChange ;

#line 2075
typedef struct _MSNdis_StatusProtocolBind ;

#line 2092
typedef struct _MSNdis_StatusProtocolUnbind ;

#line 2109
typedef struct _KEYBOARD_PORT_WMI_STD_DATA ;

#line 2152
typedef struct _POINTER_PORT_WMI_STD_DATA ;

#line 2205
typedef struct _MSMouse_ClassInformation ;

#line 2223
typedef struct _MSKeyboard_ClassInformation ;

#line 2241
typedef struct _MSAcpi_ThermalZoneTemperature ;

#line 2304
typedef struct _WMI_DISK_GEOMETRY ;

#line 2342
typedef struct _WMI_DISK_PERFORMANCE ;

#line 2415
typedef struct _MSDiskDriver_Performance ;

#line 2437
typedef struct _STORAGE_FAILURE_PREDICT_STATUS ;

#line 2460
typedef struct _STORAGE_FAILURE_PREDICT_DATA ;

#line 2483
typedef struct _STORAGE_FAILURE_PREDICT_EVENT ;

#line 2513
typedef struct _STORAGE_FAILURE_PREDICT_FUNCTION ;

#line 2528
typedef struct _MSIde_PortDeviceInfo ;

#line 2556
typedef struct _MSSerial_PortName ;

#line 2573
typedef struct _SERIAL_WMI_COMM_DATA ;

#line 2723
typedef struct _SERIAL_WMI_HW_DATA ;

#line 2770
typedef struct _SERIAL_WMI_PERF_DATA ;

#line 2813
typedef struct _SERIAL_WMI_COMMPROP ;

#line 2920
typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS ;

#line 2943
typedef struct _PARALLEL_WMI_LOG_INFO ;

#line 3041
typedef struct _REDBOOK_WMI_STD_DATA ;

#line 3094
typedef struct _REDBOOK_WMI_PERF_DATA ;

#line 3137
typedef struct _RegisteredGuids ;

#line 475 "serial.h"
typedef struct _CONFIG_DATA ;

#line 509
typedef struct _SERIAL_CISR_SW ;

#line 520
typedef struct _SERIAL_FIRMWARE_DATA ;

#line 576
typedef struct _SERIAL_DEVICE_STATE ;

#line 646
typedef struct _SERIAL_DEVICE_EXTENSION ;

#line 1808
typedef struct _SERIAL_MULTIPORT_DISPATCH ;

#line 2157
typedef enum _SERIAL_MEM_COMPARES ;

#line 2164
typedef struct _SERIAL_LIST_DATA ;

#line 2169
typedef struct _SERIAL_GLOBALS ;

#line 2180
typedef struct _SERIAL_USER_DATA ;

#line 2206
typedef struct _SERIAL_PTR_CTX ;

#line 20 "serialp.h"
typedef NTSTATUS ;

#line 26
typedef void ;

#line 835
typedef struct _SERIAL_UPDATE_CHAR ;

#line 846
typedef struct _SERIAL_IOCTL_SYNC ;

#line 29 "purge.c"

#pragma alloc_text(PAGESER, SerialStartPurge)
#line 30

#pragma alloc_text(PAGESER, SerialPurgeInterruptBuff)
#line 34
NTSTATUS SerialStartPurge(PSERIAL_DEVICE_EXTENSION Extension )
{
	#line 61
	PIRP NewIrp ;
	#line 63
	;
	#line 65
	do
	{
		ULONG Mask ;
		#line 69
		Mask = * (ULONG * 
			)((Extension->CurrentPurgeIrp)->AssociatedIrp).SystemBuffer
			;
		if(Mask & 0x00000001)
		{
			SerialKillAllReadsOrWrites(Extension->DeviceObject, &
				Extension->WriteQueue, &
				Extension->CurrentWriteIrp);
			#line 80
			SerialKillAllReadsOrWrites(Extension->DeviceObject, &
				Extension->WriteQueue, &
				Extension->CurrentXoffIrp);
		}
		#line 88
		if(Mask & 0x00000002)
		{
			SerialKillAllReadsOrWrites(Extension->DeviceObject, &
				Extension->ReadQueue, &
				Extension->CurrentReadIrp);
		}
		#line 98
		if(Mask & 0x00000008)
		{
			KIRQL OldIrql ;
			#line 114
			* & OldIrql = KfAcquireSpinLock(&
				Extension->ControlLock);
			KeSynchronizeExecution(Extension->Interrupt,
				SerialPurgeInterruptBuff, Extension);
			#line 125
			KfReleaseSpinLock(& Extension->ControlLock, OldIrql);
		}
		#line 129
		((Extension->CurrentPurgeIrp)->IoStatus).Status = (NTSTATUS
			)0x00000000L;
		#line 130
		((Extension->CurrentPurgeIrp)->IoStatus).Information = 0;
		#line 132
		SerialGetNextIrp(& Extension->CurrentPurgeIrp, &
			Extension->PurgeQueue, & NewIrp, 1, Extension);
	}
	while(NewIrp);
	#line 142
	return (NTSTATUS )0x00000000L;
}

#line 146
BOOLEAN SerialPurgeInterruptBuff(PVOID Context )
{
	#line 171
	PSERIAL_DEVICE_EXTENSION Extension = Context;
	;
	#line 180
	if(Extension->ReadBufferBase == Extension->InterruptReadBuffer)
	{
		Extension->CurrentCharSlot = Extension->InterruptReadBuffer;
		Extension->FirstReadableChar = Extension->InterruptReadBuffer;
		Extension->LastCharSlot = Extension->InterruptReadBuffer +
			(Extension->BufferSize - 1);
		Extension->CharsInInterruptBuffer = 0;
		#line 188
		SerialHandleReducedIntBuffer(Extension);
	}
	#line 192
	return 0;
}

#line 16 "C:/NTDDK/inc/stddef.h"

#pragma once
#line 77
typedef int ;

#line 86
typedef unsigned int ;

#line 95
typedef int ;

#line 105
typedef unsigned int ;

#line 112
typedef unsigned short ;

#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"

#pragma once
#line 32

#pragma pack(push, 8)
#line 72
typedef enum _EXCEPTION_DISPOSITION ;

#line 89
struct _EXCEPTION_RECORD ;

#line 90
struct _CONTEXT ;

#line 155

#pragma pack(pop)
#line 25 "C:/NTDDK/inc/ntdef.h"

#pragma once
#line 15 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"

#pragma once
#line 66
typedef wchar_t ;

#line 67
typedef wchar_t ;

#line 127 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long ;

#line 25 "C:/NTDDK/inc/basetsd.h"

#pragma once
#line 36
typedef int ;

#line 37
typedef int ;

#line 43
typedef unsigned int ;

#line 44
typedef unsigned int ;

#line 45
typedef unsigned int ;

#line 84
typedef int ;

#line 85
typedef unsigned int ;

typedef long ;

#line 88
typedef unsigned long ;

#line 248
typedef unsigned short ;

#line 249
typedef short ;

#line 250
typedef unsigned long ;

#line 288
typedef ULONG_PTR ;

#line 289
typedef LONG_PTR ;

#line 295
typedef ULONG_PTR ;

#line 301
typedef __int64 ;

#line 302
typedef __int64 ;

#line 309
typedef unsigned __int64 ;

#line 310
typedef unsigned __int64 ;

#line 311
typedef unsigned __int64 ;

#line 217 "C:/NTDDK/inc/ntdef.h"
typedef void ;

#line 218
typedef void ;

#line 266
typedef char ;

#line 267
typedef short ;

#line 268
typedef long ;

#line 276
typedef wchar_t ;

#line 282
typedef WCHAR ;

#line 283
typedef WCHAR ;

#line 284
typedef const WCHAR ;

#line 285
typedef WCHAR ;

#line 286
typedef WCHAR ;

typedef const WCHAR ;

#line 293
typedef CHAR ;

#line 294
typedef CHAR ;

typedef const CHAR ;

#line 297
typedef CHAR ;

#line 298
typedef CHAR ;

#line 299
typedef const CHAR ;

#line 321
typedef char ;

#line 322
typedef unsigned char ;

#line 326
typedef LPSTR ;

#line 327
typedef LPSTR ;

#line 328
typedef LPCSTR ;

#line 337
typedef double ;

typedef struct _QUAD ;

#line 349
typedef SHORT ;

#line 350
typedef LONG ;

#line 351
typedef QUAD ;

#line 360
typedef unsigned char ;

#line 361
typedef unsigned short ;

#line 362
typedef unsigned long ;

#line 363
typedef QUAD ;

#line 369
typedef UCHAR ;

#line 370
typedef USHORT ;

#line 371
typedef ULONG ;

#line 372
typedef UQUAD ;

#line 378
typedef signed char ;

#line 379
typedef SCHAR ;

#line 394
typedef void ;

#line 400
typedef HANDLE ;

#line 406
typedef UCHAR ;

#line 407
typedef USHORT ;

#line 408
typedef ULONG ;

#line 414
typedef LONG ;

#line 478
typedef char ;

#line 479
typedef short ;

#line 480
typedef ULONG ;

typedef CCHAR ;

#line 483
typedef CSHORT ;

#line 484
typedef CLONG ;

#line 492
typedef ULONG ;

#line 493
typedef PULONG ;

#line 494
typedef USHORT ;

#line 500
typedef ULONG ;

#line 501
typedef ULONG ;

#line 508
typedef LONG ;

typedef NTSTATUS ;

#line 602
typedef struct _FLOAT128 ;

#line 607
typedef FLOAT128 ;

#line 621
typedef __int64 ;

#line 622
typedef unsigned __int64 ;

#line 639
typedef LONGLONG ;

#line 640
typedef ULONGLONG ;

#line 644
typedef LONGLONG ;

#line 649
typedef union _LARGE_INTEGER ;

#line 662
typedef LARGE_INTEGER ;

#line 668
typedef union _ULARGE_INTEGER ;

#line 681
typedef ULARGE_INTEGER ;

#line 690
typedef struct _LUID ;

#line 696
typedef ULONGLONG ;

#line 697
typedef DWORDLONG ;

#line 707
typedef LARGE_INTEGER ;

#line 831

#pragma warning(push)

#pragma warning(disable:4035)
__inline ULONGLONG __stdcall Int64ShllMod32___9(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 842
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    
		};
}

#line 845
__inline LONGLONG __stdcall Int64ShraMod32___9(LONGLONG Value , ULONG ShiftCount
	)
{
	#line 852
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    
		};
}

#line 855
__inline ULONGLONG __stdcall Int64ShrlMod32___9(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 862
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    
		};
}


#pragma warning(pop)
#line 956
typedef enum _EVENT_TYPE ;

#line 965
typedef enum _TIMER_TYPE ;

#line 974
typedef enum _WAIT_TYPE ;

#line 983
typedef CHAR ;

#line 984
typedef const char ;

#line 991
typedef struct _STRING ;

#line 999
typedef STRING ;

typedef STRING ;

#line 1002
typedef PSTRING ;

typedef STRING ;

#line 1005
typedef PSTRING ;

#line 1011
typedef struct _CSTRING ;

#line 1016
typedef CSTRING ;

#line 1019
typedef STRING ;

#line 1020
typedef PSTRING ;

#line 1027
typedef struct _UNICODE_STRING ;

#line 1036
typedef UNICODE_STRING ;

#line 1037
typedef const UNICODE_STRING ;

#line 1046
typedef UCHAR ;

#line 1047
typedef BOOLEAN ;

#line 1057
typedef struct _LIST_ENTRY ;

#line 1067
typedef struct _SINGLE_LIST_ENTRY ;

#line 1078
typedef struct LIST_ENTRY32 ;

#line 1082
typedef LIST_ENTRY32 ;

typedef struct LIST_ENTRY64 ;

#line 1088
typedef LIST_ENTRY64 ;

#line 1127
typedef struct _STRING32 ;

#line 1132
typedef STRING32 ;

typedef STRING32 ;

#line 1135
typedef UNICODE_STRING32 ;

typedef STRING32 ;

#line 1138
typedef ANSI_STRING32 ;

#line 1141
typedef struct _STRING64 ;

#line 1146
typedef STRING64 ;

typedef STRING64 ;

#line 1149
typedef UNICODE_STRING64 ;

typedef STRING64 ;

#line 1152
typedef ANSI_STRING64 ;

#line 1173
typedef struct _OBJECT_ATTRIBUTES ;

#line 1181
typedef OBJECT_ATTRIBUTES ;

#line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID ;

#line 70
typedef GUID ;

#line 75
typedef const GUID ;

#line 81
typedef GUID ;

#line 82
typedef IID ;

#line 85
typedef GUID ;

#line 86
typedef CLSID ;

#line 89
typedef GUID ;

#line 90
typedef FMTID ;

#line 16 "C:/NTDDK/inc/string.h"

#pragma once
#line 1233 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECTID ;

#line 1288
struct _CONTEXT ;

#line 1289
struct _EXCEPTION_RECORD ;

typedef EXCEPTION_DISPOSITION ;

#line 1306
typedef UCHAR ;

typedef KIRQL ;

#line 1316
typedef enum _NT_PRODUCT_TYPE ;

#line 1329
typedef enum _SUITE_TYPE ;

#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD ;

#line 76
typedef struct _ETHREAD ;

#line 77
typedef struct _EPROCESS ;

#line 78
typedef struct _PEB ;

#line 79
typedef struct _KINTERRUPT ;

#line 80
typedef struct _IO_TIMER ;

#line 81
typedef struct _OBJECT_TYPE ;

#line 82
typedef struct _CALLBACK_OBJECT ;

#line 83
typedef struct _DEVICE_HANDLER_OBJECT ;

#line 84
typedef struct _BUS_HANDLER ;

#line 143
typedef union _SLIST_HEADER ;

#line 204
typedef CCHAR ;

typedef enum _MODE ;

#line 222
struct _KAPC ;

typedef void ;

#line 232
typedef void ;

#line 242
typedef void ;

#line 248
typedef BOOLEAN ;

#line 254
typedef BOOLEAN ;

#line 265
typedef struct _KAPC ;

#line 292
struct _KDPC ;

typedef void ;

#line 351
typedef enum _KDPC_IMPORTANCE ;

#line 361
typedef struct _KDPC ;

#line 377
typedef PVOID ;

typedef void ;

#line 392
typedef struct _KIPI_COUNTS ;

#line 443
typedef struct _MDL ;

#line 532
typedef PVOID ;

#line 538
typedef PVOID ;

#line 544
typedef PVOID ;

typedef ULONG ;

#line 547
typedef ACCESS_MASK ;

#line 597
typedef struct _GENERIC_MAPPING ;

#line 603
typedef GENERIC_MAPPING ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES ;

#line 622
typedef LUID_AND_ATTRIBUTES ;

#line 623
typedef LUID_AND_ATTRIBUTES_ARRAY ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 642 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACL ;

#line 649
typedef ACL ;

#line 681
typedef struct _PRIVILEGE_SET ;

#line 735
typedef enum _SECURITY_IMPERSONATION_LEVEL ;

#line 753
typedef BOOLEAN ;

#line 762
typedef struct _SECURITY_QUALITY_OF_SERVICE ;

#line 774
typedef struct _SE_IMPERSONATION_STATE ;

#line 782
typedef ULONG ;

#line 809
typedef ULONG ;

#line 810
typedef KAFFINITY ;

#line 816
typedef LONG ;

#line 824
typedef ULONG_PTR ;

#line 825
typedef KSPIN_LOCK ;

#line 833
typedef void ;

#line 842
typedef enum _KPROFILE_SOURCE ;

#line 1079
typedef NTSTATUS ;

#line 1088
typedef struct _RTL_QUERY_REGISTRY_TABLE ;

#line 1952

#pragma warning(push)

#pragma warning(disable:4035)
#line 2019

#pragma warning(pop)
#line 2214
typedef struct _TIME_FIELDS ;

#line 2224
typedef TIME_FIELDS ;

#line 2499
typedef struct _RTL_BITMAP ;

#line 2503
typedef RTL_BITMAP ;

#line 2627
typedef struct _RTL_BITMAP_RUN ;

#line 2633
typedef RTL_BITMAP_RUN ;

#line 2886
typedef struct _RTL_RANGE ;

#line 2924
typedef struct _RTL_RANGE_LIST ;

#line 2950
typedef struct _RANGE_LIST_ITERATOR ;

#line 3019
typedef BOOLEAN ;

#line 3155
typedef struct _OSVERSIONINFOA ;

#line 3164
typedef struct _OSVERSIONINFOW ;

#line 3177
typedef OSVERSIONINFOA ;

#line 3178
typedef POSVERSIONINFOA ;

#line 3179
typedef LPOSVERSIONINFOA ;

#line 3182
typedef struct _OSVERSIONINFOEXA ;

#line 3195
typedef struct _OSVERSIONINFOEXW ;

#line 3213
typedef OSVERSIONINFOEXA ;

#line 3214
typedef POSVERSIONINFOEXA ;

#line 3215
typedef LPOSVERSIONINFOEXA ;

#line 3648
typedef struct _IO_STATUS_BLOCK ;

#line 3669
typedef void ;

#line 3685
typedef enum _FILE_INFORMATION_CLASS ;

#line 3731
typedef struct _FILE_BASIC_INFORMATION ;

#line 3739
typedef struct _FILE_STANDARD_INFORMATION ;

#line 3747
typedef struct _FILE_POSITION_INFORMATION ;

#line 3751
typedef struct _FILE_ALIGNMENT_INFORMATION ;

#line 3755
typedef struct _FILE_NAME_INFORMATION ;

#line 3760
typedef struct _FILE_NETWORK_OPEN_INFORMATION ;

#line 3770
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION ;

#line 3775
typedef struct _FILE_DISPOSITION_INFORMATION ;

#line 3779
typedef struct _FILE_END_OF_FILE_INFORMATION ;

#line 3784
typedef struct _FILE_FULL_EA_INFORMATION ;

#line 3798
typedef enum _FSINFOCLASS ;

#line 3810
typedef struct _FILE_FS_DEVICE_INFORMATION ;

#line 3820
typedef union _FILE_SEGMENT_ELEMENT ;

#line 3829
typedef enum _INTERFACE_TYPE ;

#line 3854
typedef enum _DMA_WIDTH ;

#line 3865
typedef enum _DMA_SPEED ;

#line 3879
typedef void ;

#line 3880
typedef void ;

#line 3888
typedef enum _BUS_DATA_TYPE ;

#line 3910
typedef struct _IO_ERROR_LOG_PACKET ;

#line 3931
typedef struct _IO_ERROR_LOG_MESSAGE ;

#line 4074
typedef struct _KEY_BASIC_INFORMATION ;

#line 4081
typedef struct _KEY_NODE_INFORMATION ;

#line 4091
typedef struct _KEY_FULL_INFORMATION ;

#line 4106
typedef struct _KEY_NAME_INFORMATION ;

#line 4112
typedef enum _KEY_INFORMATION_CLASS ;

#line 4122
typedef struct _KEY_WRITE_TIME_INFORMATION ;

#line 4126
typedef enum _KEY_SET_INFORMATION_CLASS ;

#line 4134
typedef struct _KEY_VALUE_BASIC_INFORMATION ;

#line 4141
typedef struct _KEY_VALUE_FULL_INFORMATION ;

#line 4151
typedef struct _KEY_VALUE_PARTIAL_INFORMATION ;

#line 4158
typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ;

#line 4164
typedef struct _KEY_VALUE_ENTRY ;

#line 4171
typedef enum _KEY_VALUE_INFORMATION_CLASS ;

#line 4210
typedef struct _OBJECT_NAME_INFORMATION ;

#line 4221
typedef enum _SECTION_INHERIT ;

#line 4294
typedef struct _CLIENT_ID ;

#line 4298
typedef CLIENT_ID ;

#line 4315
typedef struct _NT_TIB ;

#line 4327
typedef NT_TIB ;

#line 4332
typedef enum _PROCESSINFOCLASS ;

#line 4366
typedef enum _THREADINFOCLASS ;

#line 4395
typedef struct _PROCESS_WS_WATCH_INFORMATION ;

#line 4405
typedef struct _PROCESS_BASIC_INFORMATION ;

#line 4413
typedef PROCESS_BASIC_INFORMATION ;

#line 4422
typedef struct _PROCESS_DEVICEMAP_INFORMATION ;

#line 4440
typedef struct _PROCESS_SESSION_INFORMATION ;

#line 4454
typedef struct _QUOTA_LIMITS ;

#line 4462
typedef QUOTA_LIMITS ;

#line 4472
typedef struct _IO_COUNTERS ;

#line 4480
typedef IO_COUNTERS ;

#line 4488
typedef struct _VM_COUNTERS ;

#line 4501
typedef VM_COUNTERS ;

#line 4508
typedef struct _POOLED_USAGE_AND_LIMITS ;

#line 4519
typedef POOLED_USAGE_AND_LIMITS ;

#line 4528
typedef struct _PROCESS_ACCESS_TOKEN ;

#line 4555
typedef struct _KERNEL_USER_TIMES ;

#line 4561
typedef KERNEL_USER_TIMES ;

#line 4587
typedef enum _SYSTEM_POWER_STATE ;

#line 4598
typedef enum  {
	PowerActionNone = 0,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
} ;

typedef enum _DEVICE_POWER_STATE ;

#line 4618
typedef union _POWER_STATE ;

#line 4623
typedef enum _POWER_STATE_TYPE ;

#line 4654
typedef ULONG ;

typedef enum  {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
} ;

#line 4663
typedef enum  {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation
} ;

#line 4690
typedef ULONG ;

typedef LONG ;

#line 4693
typedef ULONG ;

#line 4719
typedef union _MCI_STATS ;

#line 4978
typedef struct _KPCR ;

#line 5006
typedef KPCR ;

#line 5012
typedef struct _KFLOATING_SAVE ;

#line 5153
typedef enum _INTERLOCKED_RESULT ;

#line 5252

#pragma warning(disable:4035)
#line 6994
typedef struct _KSYSTEM_TIME ;

#line 7014

#pragma warning(push)

#pragma warning(disable:4164)
#line 7019

#pragma function(_enable)
#line 7020

#pragma function(_disable)
#line 7024

#pragma warning(pop)
#line 7085
typedef struct _FLOATING_SAVE_AREA ;

#line 7097
typedef FLOATING_SAVE_AREA ;

#line 7109
typedef struct _CONTEXT ;

#line 7197
typedef CONTEXT ;

#line 7826
typedef void ;

#line 7850
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ;

#line 7899
typedef struct _KUSER_SHARED_DATA ;

#line 8123
typedef enum _CM_SERVICE_NODE_TYPE ;

#line 8132
typedef enum _CM_SERVICE_LOAD_TYPE ;

#line 8140
typedef enum _CM_ERROR_CONTROL_TYPE ;

#line 8172
typedef int ;

#line 8198
typedef enum _CM_SHARE_DISPOSITION ;

#line 8211
typedef PVOID ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST ;

#line 8443
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR ;

#line 8454
typedef struct _CM_RESOURCE_LIST ;

#line 8471
typedef struct _DEVICE_FLAGS ;

#line 8485
typedef struct _CM_COMPONENT_INFORMATION ;

#line 8503
typedef struct _CM_ROM_BLOCK ;

#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 8518 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_INT13_DRIVE_PARAMETER ;

#line 8532
typedef struct _CM_MCA_POS_DATA ;

#line 8544
typedef struct _EISA_MEMORY_TYPE ;

#line 8554
typedef struct _EISA_MEMORY_CONFIGURATION ;

#line 8567
typedef struct _EISA_IRQ_DESCRIPTOR ;

#line 8575
typedef struct _EISA_IRQ_CONFIGURATION ;

#line 8585
typedef struct _DMA_CONFIGURATION_BYTE0 ;

#line 8592
typedef struct _DMA_CONFIGURATION_BYTE1 ;

#line 8599
typedef struct _EISA_DMA_CONFIGURATION ;

#line 8609
typedef struct _EISA_PORT_DESCRIPTOR ;

#line 8616
typedef struct _EISA_PORT_CONFIGURATION ;

#line 8628
typedef struct _CM_EISA_SLOT_INFORMATION ;

#line 8644
typedef struct _CM_EISA_FUNCTION_INFORMATION ;

#line 8678
typedef struct _CM_PNP_BIOS_DEVICE_NODE ;

#line 8692
typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8761 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_SCSI_DEVICE_DATA ;

#line 8775
typedef struct _CM_VIDEO_DEVICE_DATA ;

#line 8785
typedef struct _CM_SONIC_DEVICE_DATA ;

#line 8796
typedef struct _CM_SERIAL_DEVICE_DATA ;

#line 8810
typedef struct _CM_MONITOR_DEVICE_DATA ;

#line 8844
typedef struct _CM_FLOPPY_DEVICE_DATA ;

#line 8881
typedef struct _CM_KEYBOARD_DEVICE_DATA ;

#line 8893
typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA ;

#line 8905
typedef struct _CM_PCCARD_DEVICE_DATA ;

#line 8944
typedef struct _IO_RESOURCE_DESCRIPTOR ;

#line 9027
typedef struct _IO_RESOURCE_LIST ;

#line 9036
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST ;

#line 9065
typedef struct _EXCEPTION_RECORD ;

#line 9074
typedef EXCEPTION_RECORD ;

typedef struct _EXCEPTION_RECORD32 ;

#line 9085
typedef struct _EXCEPTION_RECORD64 ;

#line 9099
typedef struct _EXCEPTION_POINTERS ;

#line 9111
typedef enum _CONFIGURATION_TYPE ;

#line 9161
typedef enum _KINTERRUPT_MODE ;

#line 9170
typedef enum _KWAIT_REASON ;

#line 9207
typedef struct _DISPATCHER_HEADER ;

#line 9217
typedef struct _KWAIT_BLOCK ;

#line 9230
typedef void ;

#line 9244
typedef struct _KDEVICE_QUEUE ;

#line 9252
typedef struct _KDEVICE_QUEUE_ENTRY ;

#line 9263
typedef struct _KEVENT ;

#line 9271
typedef BOOLEAN ;

#line 9281
typedef struct _KMUTANT ;

#line 9294
typedef struct _KSEMAPHORE ;

#line 9304
typedef struct _KTIMER ;

#line 9899
typedef enum _KBUGCHECK_BUFFER_DUMP_STATE ;

#line 9907
typedef void ;

#line 9914
typedef struct _KBUGCHECK_CALLBACK_RECORD ;

#line 10002
typedef void ;

#line 10020
typedef LOGICAL ;

#line 10037
typedef void ;

#line 10053
typedef enum _MEMORY_CACHING_TYPE_ORIG ;

#line 10057
typedef enum _MEMORY_CACHING_TYPE ;

#line 10087
typedef struct _DBGKD_DEBUG_DATA_HEADER64 ;

#line 10115
typedef enum _POOL_TYPE ;

#line 10195
typedef enum _EX_POOL_PRIORITY ;

#line 10247
typedef struct _FAST_MUTEX ;

#line 10574
typedef PVOID ;

#line 10582
typedef void ;

#line 10588
typedef struct _GENERAL_LOOKASIDE ;

#line 10619
typedef struct _NPAGED_LOOKASIDE_LIST ;

#line 10729
typedef struct _PAGED_LOOKASIDE_LIST ;

#line 10882
typedef enum _WORK_QUEUE_TYPE ;

#line 10889
typedef void ;

#line 10895
typedef struct _WORK_QUEUE_ITEM ;

#line 10926
typedef struct _ZONE_SEGMENT_HEADER ;

#line 10931
typedef struct _ZONE_HEADER ;

#line 11156
typedef ULONG_PTR ;

#line 11157
typedef ERESOURCE_THREAD ;

typedef struct _OWNER_ENTRY ;

#line 11168
typedef struct _ERESOURCE ;

#line 11197
typedef struct _RESOURCE_HASH_ENTRY ;

#line 11204
typedef struct _RESOURCE_PERFORMANCE_DATA ;

#line 11429
typedef struct _CALLBACK_OBJECT ;

typedef void ;

#line 11474
typedef GUID ;

#line 11862
typedef enum _MM_SYSTEM_SIZE ;

#line 11884
typedef enum _LOCK_OPERATION ;

#line 11970
typedef enum _MM_PAGE_PRIORITY ;

#line 11999
typedef struct _PHYSICAL_MEMORY_RANGE ;

#line 12385
typedef NTSTATUS ;

#line 12389
typedef NTSTATUS ;

#line 12399
struct _DRIVER_OBJECT ;

#line 12411
typedef enum _SECURITY_OPERATION_CODE ;

#line 12426
typedef struct _SECURITY_SUBJECT_CONTEXT ;

#line 12448
typedef struct _INITIAL_PRIVILEGE_SET ;

#line 12462
typedef struct _ACCESS_STATE ;

#line 12571
typedef void ;

#line 12585
typedef void ;

#line 12602
typedef struct _IMAGE_INFO ;

#line 12620
typedef void ;

#line 12859
typedef NTSTATUS ;

#line 12878
typedef enum _IO_QUERY_DEVICE_DATA_FORMAT ;

#line 12890
typedef enum _CREATE_FILE_TYPE ;

#line 12905
struct _DEVICE_DESCRIPTION ;

#line 12906
struct _DEVICE_OBJECT ;

#line 12907
struct _DMA_ADAPTER ;

#line 12908
struct _DRIVER_OBJECT ;

#line 12909
struct _DRIVE_LAYOUT_INFORMATION ;

#line 12910
struct _DISK_PARTITION ;

#line 12911
struct _FILE_OBJECT ;

#line 12912
struct _IRP ;

#line 12913
struct _SCSI_REQUEST_BLOCK ;

#line 12919
typedef void ;

#line 12932
typedef void ;

#line 12943
typedef NTSTATUS ;

#line 12955
typedef void ;

#line 12968
typedef void ;

#line 12979
typedef NTSTATUS ;

#line 12990
typedef void ;

#line 13001
typedef void ;

#line 13011
typedef NTSTATUS ;

#line 13025
typedef BOOLEAN ;

#line 13038
typedef BOOLEAN ;

#line 13051
typedef BOOLEAN ;

#line 13068
typedef BOOLEAN ;

#line 13078
typedef BOOLEAN ;

#line 13092
typedef BOOLEAN ;

#line 13106
typedef BOOLEAN ;

#line 13118
typedef BOOLEAN ;

#line 13127
typedef BOOLEAN ;

#line 13141
typedef BOOLEAN ;

#line 13161
typedef void ;

#line 13167
typedef void ;

#line 13179
typedef void ;

#line 13193
typedef BOOLEAN ;

#line 13207
typedef BOOLEAN ;

#line 13219
typedef BOOLEAN ;

#line 13227
typedef BOOLEAN ;

#line 13239
typedef BOOLEAN ;

#line 13253
typedef NTSTATUS ;

#line 13262
typedef NTSTATUS ;

#line 13275
typedef NTSTATUS ;

#line 13282
typedef NTSTATUS ;

#line 13289
typedef BOOLEAN ;

#line 13304
typedef BOOLEAN ;

#line 13319
typedef BOOLEAN ;

#line 13327
typedef BOOLEAN ;

#line 13336
typedef BOOLEAN ;

#line 13350
typedef struct _FAST_IO_DISPATCH ;

#line 13386
typedef enum _IO_ALLOCATION_ACTION ;

#line 13396
typedef IO_ALLOCATION_ACTION ;

#line 13410
typedef struct _IO_SECURITY_CONTEXT ;

#line 13434
typedef struct _VPB ;

#line 13482
typedef struct _ADAPTER_OBJECT ;

#line 13491
typedef struct _WAIT_CONTEXT_BLOCK ;

#line 13503
typedef struct _CONTROLLER_OBJECT ;

#line 13537
typedef struct _DEVICE_OBJECT ;

#line 13575
typedef struct _DEVICE_OBJECT ;

#line 13578
struct _DEVICE_OBJECT_POWER_EXTENSION ;

typedef struct _DEVOBJ_EXTENSION ;

#line 13608
typedef struct _DRIVER_EXTENSION ;

#line 13645
typedef struct _DRIVER_OBJECT ;

#line 13706
typedef struct _DRIVER_OBJECT ;

#line 13715
typedef struct _SECTION_OBJECT_POINTERS ;

#line 13720
typedef SECTION_OBJECT_POINTERS ;

#line 13726
typedef struct _IO_COMPLETION_CONTEXT ;

#line 13759
typedef struct _FILE_OBJECT ;

#line 13788
typedef struct _FILE_OBJECT ;

#line 13828
typedef struct _IRP ;

#line 14078
typedef NTSTATUS ;

#line 14163
typedef enum _DEVICE_RELATION_TYPE ;

#line 14171
typedef struct _DEVICE_RELATIONS ;

#line 14176
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE ;

#line 14185
typedef struct _INTERFACE ;

#line 14196
typedef struct _DEVICE_CAPABILITIES ;

#line 14229
typedef struct _POWER_SEQUENCE ;

#line 14235
typedef enum  {
	BusQueryDeviceID = 0,
	BusQueryHardwareIDs = 1,
	BusQueryCompatibleIDs = 2,
	BusQueryInstanceID = 3,
	BusQueryDeviceSerialNumber = 4
} ;

typedef ULONG ;

#line 14252
typedef enum  {
	DeviceTextDescription = 0,
	DeviceTextLocationInformation = 1
} ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 14615 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SHARE_ACCESS ;

#line 14635
typedef struct _CONFIGURATION_INFORMATION ;

#line 14848
typedef struct _BOOTDISK_INFORMATION ;

#line 15754
typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK ;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK ;

#line 15764
typedef struct _IO_REMOVE_LOCK_DBG_BLOCK ;

#line 15777
typedef struct _IO_REMOVE_LOCK ;

#line 16009
typedef struct _IO_WORKITEM ;

typedef void ;

#line 16100
typedef enum  {
	DevicePropertyDeviceDescription,
	DevicePropertyHardwareID,
	DevicePropertyCompatibleIDs,
	DevicePropertyBootConfiguration,
	DevicePropertyBootConfigurationTranslated,
	DevicePropertyClassName,
	DevicePropertyClassGuid,
	DevicePropertyDriverKeyName,
	DevicePropertyManufacturer,
	DevicePropertyFriendlyName,
	DevicePropertyLocationInformation,
	DevicePropertyPhysicalDeviceObjectName,
	DevicePropertyBusTypeGuid,
	DevicePropertyLegacyBusType,
	DevicePropertyBusNumber,
	DevicePropertyEnumeratorName,
	DevicePropertyAddress,
	DevicePropertyUINumber
} ;

typedef BOOLEAN ;

#line 16129
typedef struct _DMA_ADAPTER ;

#line 16135
typedef ULONG ;

#line 16148
typedef struct _PNP_BUS_INFORMATION ;

#line 16162
typedef struct _LEGACY_BUS_INFORMATION ;

#line 16168
typedef struct _BUS_INTERFACE_STANDARD ;

#line 16190
typedef BOOLEAN ;

#line 16194
typedef NTSTATUS ;

#line 16203
typedef NTSTATUS ;

#line 16206
typedef NTSTATUS ;

#line 16210
typedef NTSTATUS ;

#line 16214
typedef NTSTATUS ;

#line 16218
typedef void ;

#line 16222
typedef NTSTATUS ;

#line 16227
typedef void ;

#line 16231
typedef struct _ACPI_INTERFACE_STANDARD ;

#line 16255
typedef enum _ACPI_REG_TYPE ;

#line 16268
typedef USHORT ;

#line 16272
typedef void ;

#line 16278
typedef struct ACPI_REGS_INTERFACE_STANDARD ;

#line 16300
typedef struct  {
	PVOID LinkNode ;
	ULONG StaticVector ;
	UCHAR Flags ;
} ;

#line 16314
typedef NTSTATUS ;

#line 16329
typedef NTSTATUS ;

#line 16336
typedef void ;

#line 16343
typedef struct _INT_ROUTE_INTERFACE_STANDARD ;

#line 16366
typedef struct _IO_ASSIGNED_RESOURCES ;

#line 16490
typedef enum _IO_NOTIFICATION_EVENT_CATEGORY ;

#line 16504
typedef NTSTATUS ;

#line 16537
typedef void ;

#line 16573
typedef enum _ARBITER_ACTION ;

#line 16586
typedef struct _ARBITER_CONFLICT_INFO ;

#line 16608
typedef struct _ARBITER_PARAMETERS ;

#line 16719
typedef enum _ARBITER_REQUEST_SOURCE ;

#line 16731
typedef enum _ARBITER_RESULT ;

#line 16761
typedef struct _ARBITER_LIST_ENTRY ;

#line 16832
typedef NTSTATUS ;

#line 16853
typedef struct _ARBITER_INTERFACE ;

#line 16880
typedef enum _RESOURCE_TRANSLATION_DIRECTION ;

#line 16889
typedef NTSTATUS ;

#line 16901
typedef NTSTATUS ;

#line 16915
typedef struct _TRANSLATOR_INTERFACE ;

#line 16931
typedef NTSTATUS ;

#line 16945
typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE ;

#line 16959
typedef struct _PLUGPLAY_NOTIFICATION_HEADER ;

#line 16972
typedef struct _HWPROFILE_CHANGE_NOTIFICATION ;

#line 16986
typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION ;

#line 17006
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION ;

#line 17026
typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION ;

#line 17054
typedef struct _DEVICE_DESCRIPTION ;

#line 17086
typedef BOOLEAN ;

#line 17333
typedef void ;

#line 17339
typedef struct _DEVICE_CONTROL_CONTEXT ;

#line 17349
typedef PBUS_HANDLER ;

#line 17355
typedef void ;

#line 17365
typedef enum _HAL_QUERY_INFORMATION_CLASS ;

#line 17381
typedef enum _HAL_SET_INFORMATION_CLASS ;

#line 17388
typedef NTSTATUS ;

#line 17405
typedef NTSTATUS ;

#line 17420
typedef void ;

#line 17429
typedef void ;

#line 17438
typedef NTSTATUS ;

#line 17447
typedef NTSTATUS ;

#line 17456
typedef NTSTATUS ;

#line 17466
typedef NTSTATUS ;

#line 17475
typedef NTSTATUS ;

#line 17486
typedef struct _PM_DISPATCH_TABLE ;

#line 17492
typedef NTSTATUS ;

#line 17505
typedef struct _DMA_ADAPTER ;

#line 17520
typedef NTSTATUS ;

#line 17543
typedef BOOLEAN ;

#line 17553
typedef NTSTATUS ;

#line 17566
typedef void ;

#line 17572
typedef void ;

#line 17578
typedef BOOLEAN ;

#line 17588
typedef struct  {
	ULONG Version ;
	pHalQuerySystemInformation HalQuerySystemInformation ;
	pHalSetSystemInformation HalSetSystemInformation ;
	pHalQueryBusSlots HalQueryBusSlots ;
	ULONG Spare1 ;
	pHalExamineMBR HalExamineMBR ;
	pHalIoAssignDriveLetters HalIoAssignDriveLetters ;
	pHalIoReadPartitionTable HalIoReadPartitionTable ;
	pHalIoSetPartitionInformation HalIoSetPartitionInformation ;
	pHalIoWritePartitionTable HalIoWritePartitionTable ;
	pHalHandlerForBus HalReferenceHandlerForBus ;
	pHalReferenceBusHandler HalReferenceBusHandler ;
	pHalReferenceBusHandler HalDereferenceBusHandler ;
	pHalInitPnpDriver HalInitPnpDriver ;
	pHalInitPowerManagement HalInitPowerManagement ;
	pHalGetDmaAdapter HalGetDmaAdapter ;
	pHalGetInterruptTranslator HalGetInterruptTranslator ;
} ;

#line 17650
typedef struct _HAL_BUS_INFORMATION ;

#line 17658
typedef struct _HAL_PROFILE_SOURCE_INFORMATION ;

#line 17665
typedef struct _HAL_PROFILE_SOURCE_INTERVAL ;

#line 17671
typedef enum _HAL_DISPLAY_BIOS_INFORMATION ;

#line 17678
typedef struct _HAL_POWER_INFORMATION ;

#line 17683
typedef struct _HAL_PROCESSOR_SPEED_INFO ;

#line 17688
typedef struct _HAL_CALLBACKS ;

#line 17694
typedef struct _HAL_PROCESSOR_FEATURE ;

#line 17706
typedef union _MCI_ADDR ;

#line 17716
typedef enum  {
	HAL_MCE_RECORD,
	HAL_MCA_RECORD
} ;

#line 17726
typedef struct _MCA_EXCEPTION ;

#line 17752
typedef void ;

#line 17762
typedef struct _MCA_DRIVER_INFO ;

#line 17772
typedef struct _SCATTER_GATHER_ELEMENT ;

#line 17778

#pragma warning(disable:4200)
#line 17779
typedef struct _SCATTER_GATHER_LIST ;

#line 17784

#pragma warning(default:4200)
#line 17788
typedef struct _DMA_OPERATIONS ;

typedef struct _DMA_ADAPTER ;

#line 17797
typedef void ;

#line 17801
typedef PVOID ;

#line 17808
typedef void ;

#line 17816
typedef NTSTATUS ;

#line 17824
typedef BOOLEAN ;

#line 17833
typedef void ;

#line 17837
typedef void ;

#line 17843
typedef PHYSICAL_ADDRESS ;

#line 17852
typedef ULONG ;

#line 17856
typedef ULONG ;

#line 17860
typedef void ;

#line 17868
typedef NTSTATUS ;

#line 17880
typedef void ;

#line 17887
typedef struct _DMA_OPERATIONS ;

#line 18235
typedef void ;

#line 18321
typedef struct _OBJECT_HANDLE_INFORMATION ;

#line 18402
typedef struct _PCI_SLOT_NUMBER ;

#line 18418
typedef struct _PCI_COMMON_CONFIG ;

#line 18591
typedef struct _PCI_CAPABILITIES_HEADER ;

#line 18600
typedef struct _PCI_PMC ;

#line 18618
typedef struct _PCI_PMCSR ;

#line 18628
typedef struct _PCI_PMCSR_BSE ;

#line 18635
typedef struct _PCI_PM_CAPABILITY ;

#line 18679
typedef struct _PCI_AGP_CAPABILITY ;

#line 18720
typedef struct _PCI_MSI_CAPABILITY ;

#line 18946
typedef void ;

#line 18954
typedef void ;

#line 18963
typedef void ;

#line 18975
typedef struct _PCIBUSDATA ;

#line 18986
typedef ULONG ;

#line 18995
typedef void ;

#line 19000
typedef void ;

#line 19006
typedef struct _PCI_BUS_INTERFACE_STANDARD ;

#line 19028
typedef BOOLEAN ;

#line 19043
typedef struct _PCI_DEVICE_PRESENT_INTERFACE ;

#line 127 "C:/NTDDK/inc/ntddser.h"
typedef struct _SERIALPERF_STATS ;

#line 136
typedef struct _SERIALCONFIG ;

#line 154
typedef struct _SERIAL_LINE_CONTROL ;

#line 160
typedef struct _SERIAL_TIMEOUTS ;

#line 175
typedef struct _SERIAL_QUEUE_SIZE ;

#line 185
typedef struct _SERIAL_BAUD_RATE ;

#line 247
typedef struct _SERIAL_CHARS ;

#line 284
typedef struct _SERIAL_HANDFLOW ;

#line 340
typedef struct _SERIAL_BASIC_SETTINGS ;

#line 353
typedef struct _SERIAL_STATUS ;

#line 433
typedef struct _SERIAL_XOFF_COUNTER ;

#line 539
typedef struct _SERIAL_COMMPROP ;

#line 631
typedef struct _SERENUM_PORT_DESC ;

#line 652
typedef UCHAR ;

#line 658
typedef void ;

#line 665
typedef enum _SERENUM_PORTION ;

#line 671
typedef struct _SERENUM_PORT_PARAMETERS ;

#line 28 "C:/NTDDK/inc/ddk/wdm/wmilib.h"

#pragma once
#line 38
typedef struct  {
	LPCGUID Guid ;
	ULONG InstanceCount ;
	ULONG Flags ;
} ;

#line 45
typedef NTSTATUS ;

#line 101
typedef NTSTATUS ;

#line 162
typedef NTSTATUS ;

#line 206
typedef NTSTATUS ;

#line 253
typedef NTSTATUS ;

#line 306
typedef enum  {
	WmiEventControl,
	WmiDataBlockControl
} ;

#line 312
typedef NTSTATUS ;

#line 355
typedef struct _WMILIB_CONTEXT ;

#line 411
typedef enum  {
	IrpProcessed,
	IrpNotCompleted,
	IrpNotWmi,
	IrpForward
} ;

#line 13 "C:/NTDDK/inc/wmidata.h"
typedef struct _MSWmi_MofData ;

#line 51
typedef struct _MSWmi_ProviderInfo ;

#line 66
typedef struct _MSWmi_PnPDeviceId ;

#line 83
typedef struct _MSWmi_PnPInstanceNames ;

#line 105
typedef struct _MSSmBios_RawSMBiosTables ;

#line 147
typedef struct _MSPower_DeviceEnable ;

#line 165
typedef struct _MSPower_DeviceWakeEnable ;

#line 182
typedef struct _MSNdis_NetworkAddress ;

#line 199
typedef struct _MSNdis_NetworkShortAddress ;

#line 216
typedef struct _MSNdis_NetworkLinkSpeed ;

#line 239
typedef struct _MSNdis_EnumerateAdapter ;

#line 256
typedef struct _MSNdis_NotifyAdapterRemoval ;

#line 273
typedef struct _MSNdis_NotifyAdapterArrival ;

#line 291
typedef struct _MSNdis_NdisEnumerateVc ;

#line 307
typedef struct _MSNdis_NotifyVcRemoval ;

#line 323
typedef struct _MSNdis_NotifyVcArrival ;

#line 338
typedef struct _MSNdis_HardwareStatus ;

#line 356
typedef struct _MSNdis_MediaSupported ;

#line 378
typedef struct _MSNdis_MediaInUse ;

#line 400
typedef struct _MSNdis_MaximumLookahead ;

#line 418
typedef struct _MSNdis_MaximumFrameSize ;

#line 436
typedef struct _MSNdis_LinkSpeed ;

#line 454
typedef struct _MSNdis_TransmitBufferSpace ;

#line 472
typedef struct _MSNdis_ReceiveBufferSpace ;

#line 490
typedef struct _MSNdis_TransmitBlockSize ;

#line 508
typedef struct _MSNdis_ReceiveBlockSize ;

#line 526
typedef struct _MSNdis_VendorID ;

#line 544
typedef struct _MSNdis_VendorDescription ;

#line 561
typedef struct _MSNdis_CurrentPacketFilter ;

#line 579
typedef struct _MSNdis_CurrentLookahead ;

#line 597
typedef struct _MSNdis_DriverVersion ;

#line 615
typedef struct _MSNdis_MaximumTotalSize ;

#line 633
typedef struct _MSNdis_MacOptions ;

#line 651
typedef struct _MSNdis_MediaConnectStatus ;

#line 669
typedef struct _MSNdis_MaximumSendPackets ;

#line 687
typedef struct _MSNdis_VendorDriverVersion ;

#line 705
typedef struct _MSNdis_TransmitsOk ;

#line 723
typedef struct _MSNdis_ReceivesOk ;

#line 741
typedef struct _MSNdis_TransmitsError ;

#line 759
typedef struct _MSNdis_ReceiveError ;

#line 777
typedef struct _MSNdis_ReceiveNoBuffer ;

#line 795
typedef struct _MSNdis_CoHardwareStatus ;

#line 813
typedef struct _MSNdis_CoMediaSupported ;

#line 835
typedef struct _MSNdis_CoMediaInUse ;

#line 857
typedef struct _MSNdis_CoLinkSpeed ;

#line 875
typedef struct _MSNdis_CoVendorId ;

#line 893
typedef struct _MSNdis_CoVendorDescription ;

#line 910
typedef struct _MSNdis_CoDriverVersion ;

#line 928
typedef struct _MSNdis_CoMacOptions ;

#line 946
typedef struct _MSNdis_CoMediaConnectStatus ;

#line 964
typedef struct _MSNdis_CoVendorDriverVersion ;

#line 982
typedef struct _MSNdis_CoMinimumLinkSpeed ;

#line 1000
typedef struct _MSNdis_CoTransmitPdusOk ;

#line 1018
typedef struct _MSNdis_CoReceivePdusOk ;

#line 1036
typedef struct _MSNdis_CoTransmitPduErrors ;

#line 1054
typedef struct _MSNdis_CoReceivePduErrors ;

#line 1072
typedef struct _MSNdis_CoReceivePdusNoBuffer ;

#line 1090
typedef struct _MSNdis_AtmSupportedVcRates ;

#line 1113
typedef struct _MSNdis_AtmSupportedServiceCategory ;

#line 1131
typedef struct _MSNdis_AtmSupportedAalTypes ;

#line 1149
typedef struct _MSNdis_AtmHardwareCurrentAddress ;

#line 1167
typedef struct _MSNdis_AtmMaxActiveVcs ;

#line 1185
typedef struct _MSNdis_AtmMaxActiveVciBits ;

#line 1203
typedef struct _MSNdis_AtmMaxActiveVpiBits ;

#line 1221
typedef struct _MSNdis_AtmMaxAal0PacketSize ;

#line 1239
typedef struct _MSNdis_AtmMaxAal1PacketSize ;

#line 1257
typedef struct _MSNdis_AtmMaxAal34PacketSize ;

#line 1275
typedef struct _MSNdis_AtmMaxAal5PacketSize ;

#line 1293
typedef struct _MSNdis_AtmReceiveCellsOk ;

#line 1311
typedef struct _MSNdis_AtmTransmitCellsOk ;

#line 1329
typedef struct _MSNdis_AtmReceiveCellsDropped ;

#line 1347
typedef struct _MSNdis_EthernetPermanentAddress ;

#line 1365
typedef struct _MSNdis_EthernetCurrentAddress ;

#line 1383
typedef struct _MSNdis_EthernetMulticastList ;

#line 1405
typedef struct _MSNdis_EthernetMaximumMulticastListSize ;

#line 1423
typedef struct _MSNdis_EthernetMacOptions ;

#line 1441
typedef struct _MSNdis_EthernetReceiveErrorAlignment ;

#line 1459
typedef struct _MSNdis_EthernetOneTransmitCollision ;

#line 1477
typedef struct _MSNdis_EthernetMoreTransmitCollisions ;

#line 1495
typedef struct _MSNdis_TokenRingPermanentAddress ;

#line 1513
typedef struct _MSNdis_TokenRingCurrentAddress ;

#line 1531
typedef struct _MSNdis_TokenRingCurrentFunctional ;

#line 1549
typedef struct _MSNdis_TokenRingCurrentGroup ;

#line 1567
typedef struct _MSNdis_TokenRingLastOpenStatus ;

#line 1585
typedef struct _MSNdis_TokenRingCurrentRingStatus ;

#line 1603
typedef struct _MSNdis_TokenRingCurrentRingState ;

#line 1621
typedef struct _MSNdis_TokenRingLineErrors ;

#line 1639
typedef struct _MSNdis_TokenRingLostFrames ;

#line 1657
typedef struct _MSNdis_FddiLongPermanentAddress ;

#line 1675
typedef struct _MSNdis_FddiLongCurrentAddress ;

#line 1693
typedef struct _MSNdis_FddiLongMulticastList ;

#line 1715
typedef struct _MSNdis_FddiLongMaximumListSize ;

#line 1733
typedef struct _MSNdis_FddiShortPermanentAddress ;

#line 1751
typedef struct _MSNdis_FddiShortCurrentAddress ;

#line 1769
typedef struct _MSNdis_FddiShortMulticastList ;

#line 1791
typedef struct _MSNdis_FddiShortMaximumListSize ;

#line 1809
typedef struct _MSNdis_FddiAttachmentType ;

#line 1827
typedef struct _MSNdis_FddiUpstreamNodeLong ;

#line 1845
typedef struct _MSNdis_FddiDownstreamNodeLong ;

#line 1863
typedef struct _MSNdis_FddiFrameErrors ;

#line 1881
typedef struct _MSNdis_FddiFramesLost ;

#line 1899
typedef struct _MSNdis_FddiRingManagmentState ;

#line 1917
typedef struct _MSNdis_FddiLctFailures ;

#line 1935
typedef struct _MSNdis_FddiLemRejects ;

#line 1953
typedef struct _MSNdis_FddiLConnectionState ;

#line 1972
typedef struct _MSNdis_StatusResetStart ;

#line 1988
typedef struct _MSNdis_StatusResetEnd ;

#line 2004
typedef struct _MSNdis_StatusMediaConnect ;

#line 2020
typedef struct _MSNdis_StatusMediaDisconnect ;

#line 2035
typedef struct _MSNdis_StatusMediaSpecificIndication ;

#line 2057
typedef struct _MSNdis_StatusLinkSpeedChange ;

#line 2075
typedef struct _MSNdis_StatusProtocolBind ;

#line 2092
typedef struct _MSNdis_StatusProtocolUnbind ;

#line 2109
typedef struct _KEYBOARD_PORT_WMI_STD_DATA ;

#line 2152
typedef struct _POINTER_PORT_WMI_STD_DATA ;

#line 2205
typedef struct _MSMouse_ClassInformation ;

#line 2223
typedef struct _MSKeyboard_ClassInformation ;

#line 2241
typedef struct _MSAcpi_ThermalZoneTemperature ;

#line 2304
typedef struct _WMI_DISK_GEOMETRY ;

#line 2342
typedef struct _WMI_DISK_PERFORMANCE ;

#line 2415
typedef struct _MSDiskDriver_Performance ;

#line 2437
typedef struct _STORAGE_FAILURE_PREDICT_STATUS ;

#line 2460
typedef struct _STORAGE_FAILURE_PREDICT_DATA ;

#line 2483
typedef struct _STORAGE_FAILURE_PREDICT_EVENT ;

#line 2513
typedef struct _STORAGE_FAILURE_PREDICT_FUNCTION ;

#line 2528
typedef struct _MSIde_PortDeviceInfo ;

#line 2556
typedef struct _MSSerial_PortName ;

#line 2573
typedef struct _SERIAL_WMI_COMM_DATA ;

#line 2723
typedef struct _SERIAL_WMI_HW_DATA ;

#line 2770
typedef struct _SERIAL_WMI_PERF_DATA ;

#line 2813
typedef struct _SERIAL_WMI_COMMPROP ;

#line 2920
typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS ;

#line 2943
typedef struct _PARALLEL_WMI_LOG_INFO ;

#line 3041
typedef struct _REDBOOK_WMI_STD_DATA ;

#line 3094
typedef struct _REDBOOK_WMI_PERF_DATA ;

#line 3137
typedef struct _RegisteredGuids ;

#line 475 "serial.h"
typedef struct _CONFIG_DATA ;

#line 509
typedef struct _SERIAL_CISR_SW ;

#line 520
typedef struct _SERIAL_FIRMWARE_DATA ;

#line 576
typedef struct _SERIAL_DEVICE_STATE ;

#line 646
typedef struct _SERIAL_DEVICE_EXTENSION ;

#line 1808
typedef struct _SERIAL_MULTIPORT_DISPATCH ;

#line 2157
typedef enum _SERIAL_MEM_COMPARES ;

#line 2164
typedef struct _SERIAL_LIST_DATA ;

#line 2169
typedef struct _SERIAL_GLOBALS ;

#line 2180
typedef struct _SERIAL_USER_DATA ;

#line 2206
typedef struct _SERIAL_PTR_CTX ;

#line 20 "serialp.h"
typedef NTSTATUS ;

#line 26
typedef void ;

#line 835
typedef struct _SERIAL_UPDATE_CHAR ;

#line 846
typedef struct _SERIAL_IOCTL_SYNC ;

#line 27 "qsfile.c"

#pragma alloc_text(PAGESRP0, SerialQueryInformationFile)
#line 28

#pragma alloc_text(PAGESRP0, SerialSetInformationFile)
#line 32
NTSTATUS SerialQueryInformationFile(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
	#line 65
	NTSTATUS Status ;
	#line 71
	PIO_STACK_LOCATION IrpSp ;
	#line 73
	NTSTATUS status ;
	#line 75
	DeviceObject;
	#line 77
	;
	#line 79
	if((status = SerialIRPPrologue(Irp, (PSERIAL_DEVICE_EXTENSION
		)DeviceObject->DeviceExtension)) != (NTSTATUS )0x00000000L)
	{
		{
			IofCompleteRequest(Irp, 0);
			#line 83
			SerialIRPEpilogue((PSERIAL_DEVICE_EXTENSION
				)DeviceObject->DeviceExtension);
		}
		#line 83
		;
		return status;
	}
	#line 90
	do
	{
		#line 90
		;
	}
	while(0);
	#line 91
	if(SerialCompleteIfError(DeviceObject, Irp) != (NTSTATUS )0x00000000L)
	{
		#line 96
		return (NTSTATUS )0xC0000120L;
	}
	#line 99
	IrpSp = ((Irp->Tail).Overlay).CurrentStackLocation;
	(Irp->IoStatus).Information = 0L;
	Status = (NTSTATUS )0x00000000L;
	if(((IrpSp->Parameters).QueryFile).FileInformationClass ==
		FileStandardInformation)
	{
		PFILE_STANDARD_INFORMATION Buf
			= (Irp->AssociatedIrp).SystemBuffer;
		(Buf->AllocationSize).QuadPart = 0;
		Buf->EndOfFile = Buf->AllocationSize;
		Buf->NumberOfLinks = 0;
		Buf->DeletePending = 0;
		Buf->Directory = 0;
		(Irp->IoStatus).Information = sizeof(FILE_STANDARD_INFORMATION
			);
	}
	else
	{
		#line 114
		if(((IrpSp->Parameters).QueryFile).FileInformationClass ==
			FilePositionInformation)
		{
			(((PFILE_POSITION_INFORMATION
				)(Irp->AssociatedIrp).SystemBuffer)->CurrentByteOffset
				).QuadPart = 0;
			#line 119
			(Irp->IoStatus).Information =
				sizeof(FILE_POSITION_INFORMATION );
		}
		else
		{
			#line 122
			Status = (NTSTATUS )0xC000000DL;
			(Irp->IoStatus).Status = (NTSTATUS )0xC000000DL;
		}
	}
	#line 129
	do
	{
		#line 129
		;
	}
	while(0);
	{
		#line 131
		IofCompleteRequest(Irp, 0);
		#line 131
		SerialIRPEpilogue((PSERIAL_DEVICE_EXTENSION
			)DeviceObject->DeviceExtension);
	}
	#line 131
	;
	return Status;
}

#line 136
NTSTATUS SerialSetInformationFile(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
	#line 170
	NTSTATUS Status ;
	#line 172
	DeviceObject;
	#line 174
	;
	#line 176
	if((Status = SerialIRPPrologue(Irp, (PSERIAL_DEVICE_EXTENSION
		)DeviceObject->DeviceExtension)) != (NTSTATUS )0x00000000L)
	{
		{
			IofCompleteRequest(Irp, 0);
			#line 180
			SerialIRPEpilogue((PSERIAL_DEVICE_EXTENSION
				)DeviceObject->DeviceExtension);
		}
		#line 180
		;
		return Status;
	}
	#line 187
	do
	{
		#line 187
		;
	}
	while(0);
	#line 188
	if(SerialCompleteIfError(DeviceObject, Irp) != (NTSTATUS )0x00000000L)
	{
		#line 193
		return (NTSTATUS )0xC0000120L;
	}
	#line 196
	(Irp->IoStatus).Information = 0L;
	if((((((Irp->Tail).Overlay).CurrentStackLocation)->Parameters).SetFile).FileInformationClass
		== FileEndOfFileInformation ||
		(((((Irp->Tail).Overlay).CurrentStackLocation)->Parameters).SetFile
		).FileInformationClass == FileAllocationInformation)
	{
		#line 204
		Status = (NTSTATUS )0x00000000L;
	}
	else
	{
		Status = (NTSTATUS )0xC000000DL;
	}
	#line 212
	(Irp->IoStatus).Status = Status;
	#line 217
	do
	{
		#line 217
		;
	}
	while(0);
	{
		#line 219
		IofCompleteRequest(Irp, 0);
		#line 219
		SerialIRPEpilogue((PSERIAL_DEVICE_EXTENSION
			)DeviceObject->DeviceExtension);
	}
	#line 219
	;
	#line 221
	return Status;
}

#line 16 "C:/NTDDK/inc/stddef.h"

#pragma once
#line 77
typedef int ;

#line 86
typedef unsigned int ;

#line 95
typedef int ;

#line 105
typedef unsigned int ;

#line 112
typedef unsigned short ;

#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"

#pragma once
#line 32

#pragma pack(push, 8)
#line 72
typedef enum _EXCEPTION_DISPOSITION ;

#line 89
struct _EXCEPTION_RECORD ;

#line 90
struct _CONTEXT ;

#line 155

#pragma pack(pop)
#line 25 "C:/NTDDK/inc/ntdef.h"

#pragma once
#line 15 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"

#pragma once
#line 66
typedef wchar_t ;

#line 67
typedef wchar_t ;

#line 127 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long ;

#line 25 "C:/NTDDK/inc/basetsd.h"

#pragma once
#line 36
typedef int ;

#line 37
typedef int ;

#line 43
typedef unsigned int ;

#line 44
typedef unsigned int ;

#line 45
typedef unsigned int ;

#line 84
typedef int ;

#line 85
typedef unsigned int ;

typedef long ;

#line 88
typedef unsigned long ;

#line 248
typedef unsigned short ;

#line 249
typedef short ;

#line 250
typedef unsigned long ;

#line 288
typedef ULONG_PTR ;

#line 289
typedef LONG_PTR ;

#line 295
typedef ULONG_PTR ;

#line 301
typedef __int64 ;

#line 302
typedef __int64 ;

#line 309
typedef unsigned __int64 ;

#line 310
typedef unsigned __int64 ;

#line 311
typedef unsigned __int64 ;

#line 217 "C:/NTDDK/inc/ntdef.h"
typedef void ;

#line 218
typedef void ;

#line 266
typedef char ;

#line 267
typedef short ;

#line 268
typedef long ;

#line 276
typedef wchar_t ;

#line 282
typedef WCHAR ;

#line 283
typedef WCHAR ;

#line 284
typedef const WCHAR ;

#line 285
typedef WCHAR ;

#line 286
typedef WCHAR ;

typedef const WCHAR ;

#line 293
typedef CHAR ;

#line 294
typedef CHAR ;

typedef const CHAR ;

#line 297
typedef CHAR ;

#line 298
typedef CHAR ;

#line 299
typedef const CHAR ;

#line 321
typedef char ;

#line 322
typedef unsigned char ;

#line 326
typedef LPSTR ;

#line 327
typedef LPSTR ;

#line 328
typedef LPCSTR ;

#line 337
typedef double ;

typedef struct _QUAD ;

#line 349
typedef SHORT ;

#line 350
typedef LONG ;

#line 351
typedef QUAD ;

#line 360
typedef unsigned char ;

#line 361
typedef unsigned short ;

#line 362
typedef unsigned long ;

#line 363
typedef QUAD ;

#line 369
typedef UCHAR ;

#line 370
typedef USHORT ;

#line 371
typedef ULONG ;

#line 372
typedef UQUAD ;

#line 378
typedef signed char ;

#line 379
typedef SCHAR ;

#line 394
typedef void ;

#line 400
typedef HANDLE ;

#line 406
typedef UCHAR ;

#line 407
typedef USHORT ;

#line 408
typedef ULONG ;

#line 414
typedef LONG ;

#line 478
typedef char ;

#line 479
typedef short ;

#line 480
typedef ULONG ;

typedef CCHAR ;

#line 483
typedef CSHORT ;

#line 484
typedef CLONG ;

#line 492
typedef ULONG ;

#line 493
typedef PULONG ;

#line 494
typedef USHORT ;

#line 500
typedef ULONG ;

#line 501
typedef ULONG ;

#line 508
typedef LONG ;

typedef NTSTATUS ;

#line 602
typedef struct _FLOAT128 ;

#line 607
typedef FLOAT128 ;

#line 621
typedef __int64 ;

#line 622
typedef unsigned __int64 ;

#line 639
typedef LONGLONG ;

#line 640
typedef ULONGLONG ;

#line 644
typedef LONGLONG ;

#line 649
typedef union _LARGE_INTEGER ;

#line 662
typedef LARGE_INTEGER ;

#line 668
typedef union _ULARGE_INTEGER ;

#line 681
typedef ULARGE_INTEGER ;

#line 690
typedef struct _LUID ;

#line 696
typedef ULONGLONG ;

#line 697
typedef DWORDLONG ;

#line 707
typedef LARGE_INTEGER ;

#line 831

#pragma warning(push)

#pragma warning(disable:4035)
__inline ULONGLONG __stdcall Int64ShllMod32___10(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 842
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    
		};
}

#line 845
__inline LONGLONG __stdcall Int64ShraMod32___10(LONGLONG Value , ULONG
	ShiftCount )
{
	#line 852
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    
		};
}

#line 855
__inline ULONGLONG __stdcall Int64ShrlMod32___10(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 862
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    
		};
}


#pragma warning(pop)
#line 956
typedef enum _EVENT_TYPE ;

#line 965
typedef enum _TIMER_TYPE ;

#line 974
typedef enum _WAIT_TYPE ;

#line 983
typedef CHAR ;

#line 984
typedef const char ;

#line 991
typedef struct _STRING ;

#line 999
typedef STRING ;

typedef STRING ;

#line 1002
typedef PSTRING ;

typedef STRING ;

#line 1005
typedef PSTRING ;

#line 1011
typedef struct _CSTRING ;

#line 1016
typedef CSTRING ;

#line 1019
typedef STRING ;

#line 1020
typedef PSTRING ;

#line 1027
typedef struct _UNICODE_STRING ;

#line 1036
typedef UNICODE_STRING ;

#line 1037
typedef const UNICODE_STRING ;

#line 1046
typedef UCHAR ;

#line 1047
typedef BOOLEAN ;

#line 1057
typedef struct _LIST_ENTRY ;

#line 1067
typedef struct _SINGLE_LIST_ENTRY ;

#line 1078
typedef struct LIST_ENTRY32 ;

#line 1082
typedef LIST_ENTRY32 ;

typedef struct LIST_ENTRY64 ;

#line 1088
typedef LIST_ENTRY64 ;

#line 1127
typedef struct _STRING32 ;

#line 1132
typedef STRING32 ;

typedef STRING32 ;

#line 1135
typedef UNICODE_STRING32 ;

typedef STRING32 ;

#line 1138
typedef ANSI_STRING32 ;

#line 1141
typedef struct _STRING64 ;

#line 1146
typedef STRING64 ;

typedef STRING64 ;

#line 1149
typedef UNICODE_STRING64 ;

typedef STRING64 ;

#line 1152
typedef ANSI_STRING64 ;

#line 1173
typedef struct _OBJECT_ATTRIBUTES ;

#line 1181
typedef OBJECT_ATTRIBUTES ;

#line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID ;

#line 70
typedef GUID ;

#line 75
typedef const GUID ;

#line 81
typedef GUID ;

#line 82
typedef IID ;

#line 85
typedef GUID ;

#line 86
typedef CLSID ;

#line 89
typedef GUID ;

#line 90
typedef FMTID ;

#line 16 "C:/NTDDK/inc/string.h"

#pragma once
#line 1233 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECTID ;

#line 1288
struct _CONTEXT ;

#line 1289
struct _EXCEPTION_RECORD ;

typedef EXCEPTION_DISPOSITION ;

#line 1306
typedef UCHAR ;

typedef KIRQL ;

#line 1316
typedef enum _NT_PRODUCT_TYPE ;

#line 1329
typedef enum _SUITE_TYPE ;

#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD ;

#line 76
typedef struct _ETHREAD ;

#line 77
typedef struct _EPROCESS ;

#line 78
typedef struct _PEB ;

#line 79
typedef struct _KINTERRUPT ;

#line 80
typedef struct _IO_TIMER ;

#line 81
typedef struct _OBJECT_TYPE ;

#line 82
typedef struct _CALLBACK_OBJECT ;

#line 83
typedef struct _DEVICE_HANDLER_OBJECT ;

#line 84
typedef struct _BUS_HANDLER ;

#line 143
typedef union _SLIST_HEADER ;

#line 204
typedef CCHAR ;

typedef enum _MODE ;

#line 222
struct _KAPC ;

typedef void ;

#line 232
typedef void ;

#line 242
typedef void ;

#line 248
typedef BOOLEAN ;

#line 254
typedef BOOLEAN ;

#line 265
typedef struct _KAPC ;

#line 292
struct _KDPC ;

typedef void ;

#line 351
typedef enum _KDPC_IMPORTANCE ;

#line 361
typedef struct _KDPC ;

#line 377
typedef PVOID ;

typedef void ;

#line 392
typedef struct _KIPI_COUNTS ;

#line 443
typedef struct _MDL ;

#line 532
typedef PVOID ;

#line 538
typedef PVOID ;

#line 544
typedef PVOID ;

typedef ULONG ;

#line 547
typedef ACCESS_MASK ;

#line 597
typedef struct _GENERIC_MAPPING ;

#line 603
typedef GENERIC_MAPPING ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES ;

#line 622
typedef LUID_AND_ATTRIBUTES ;

#line 623
typedef LUID_AND_ATTRIBUTES_ARRAY ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 642 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACL ;

#line 649
typedef ACL ;

#line 681
typedef struct _PRIVILEGE_SET ;

#line 735
typedef enum _SECURITY_IMPERSONATION_LEVEL ;

#line 753
typedef BOOLEAN ;

#line 762
typedef struct _SECURITY_QUALITY_OF_SERVICE ;

#line 774
typedef struct _SE_IMPERSONATION_STATE ;

#line 782
typedef ULONG ;

#line 809
typedef ULONG ;

#line 810
typedef KAFFINITY ;

#line 816
typedef LONG ;

#line 824
typedef ULONG_PTR ;

#line 825
typedef KSPIN_LOCK ;

#line 833
typedef void ;

#line 842
typedef enum _KPROFILE_SOURCE ;

#line 1079
typedef NTSTATUS ;

#line 1088
typedef struct _RTL_QUERY_REGISTRY_TABLE ;

#line 1952

#pragma warning(push)

#pragma warning(disable:4035)
#line 2019

#pragma warning(pop)
#line 2214
typedef struct _TIME_FIELDS ;

#line 2224
typedef TIME_FIELDS ;

#line 2499
typedef struct _RTL_BITMAP ;

#line 2503
typedef RTL_BITMAP ;

#line 2627
typedef struct _RTL_BITMAP_RUN ;

#line 2633
typedef RTL_BITMAP_RUN ;

#line 2886
typedef struct _RTL_RANGE ;

#line 2924
typedef struct _RTL_RANGE_LIST ;

#line 2950
typedef struct _RANGE_LIST_ITERATOR ;

#line 3019
typedef BOOLEAN ;

#line 3155
typedef struct _OSVERSIONINFOA ;

#line 3164
typedef struct _OSVERSIONINFOW ;

#line 3177
typedef OSVERSIONINFOA ;

#line 3178
typedef POSVERSIONINFOA ;

#line 3179
typedef LPOSVERSIONINFOA ;

#line 3182
typedef struct _OSVERSIONINFOEXA ;

#line 3195
typedef struct _OSVERSIONINFOEXW ;

#line 3213
typedef OSVERSIONINFOEXA ;

#line 3214
typedef POSVERSIONINFOEXA ;

#line 3215
typedef LPOSVERSIONINFOEXA ;

#line 3648
typedef struct _IO_STATUS_BLOCK ;

#line 3669
typedef void ;

#line 3685
typedef enum _FILE_INFORMATION_CLASS ;

#line 3731
typedef struct _FILE_BASIC_INFORMATION ;

#line 3739
typedef struct _FILE_STANDARD_INFORMATION ;

#line 3747
typedef struct _FILE_POSITION_INFORMATION ;

#line 3751
typedef struct _FILE_ALIGNMENT_INFORMATION ;

#line 3755
typedef struct _FILE_NAME_INFORMATION ;

#line 3760
typedef struct _FILE_NETWORK_OPEN_INFORMATION ;

#line 3770
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION ;

#line 3775
typedef struct _FILE_DISPOSITION_INFORMATION ;

#line 3779
typedef struct _FILE_END_OF_FILE_INFORMATION ;

#line 3784
typedef struct _FILE_FULL_EA_INFORMATION ;

#line 3798
typedef enum _FSINFOCLASS ;

#line 3810
typedef struct _FILE_FS_DEVICE_INFORMATION ;

#line 3820
typedef union _FILE_SEGMENT_ELEMENT ;

#line 3829
typedef enum _INTERFACE_TYPE ;

#line 3854
typedef enum _DMA_WIDTH ;

#line 3865
typedef enum _DMA_SPEED ;

#line 3879
typedef void ;

#line 3880
typedef void ;

#line 3888
typedef enum _BUS_DATA_TYPE ;

#line 3910
typedef struct _IO_ERROR_LOG_PACKET ;

#line 3931
typedef struct _IO_ERROR_LOG_MESSAGE ;

#line 4074
typedef struct _KEY_BASIC_INFORMATION ;

#line 4081
typedef struct _KEY_NODE_INFORMATION ;

#line 4091
typedef struct _KEY_FULL_INFORMATION ;

#line 4106
typedef struct _KEY_NAME_INFORMATION ;

#line 4112
typedef enum _KEY_INFORMATION_CLASS ;

#line 4122
typedef struct _KEY_WRITE_TIME_INFORMATION ;

#line 4126
typedef enum _KEY_SET_INFORMATION_CLASS ;

#line 4134
typedef struct _KEY_VALUE_BASIC_INFORMATION ;

#line 4141
typedef struct _KEY_VALUE_FULL_INFORMATION ;

#line 4151
typedef struct _KEY_VALUE_PARTIAL_INFORMATION ;

#line 4158
typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ;

#line 4164
typedef struct _KEY_VALUE_ENTRY ;

#line 4171
typedef enum _KEY_VALUE_INFORMATION_CLASS ;

#line 4210
typedef struct _OBJECT_NAME_INFORMATION ;

#line 4221
typedef enum _SECTION_INHERIT ;

#line 4294
typedef struct _CLIENT_ID ;

#line 4298
typedef CLIENT_ID ;

#line 4315
typedef struct _NT_TIB ;

#line 4327
typedef NT_TIB ;

#line 4332
typedef enum _PROCESSINFOCLASS ;

#line 4366
typedef enum _THREADINFOCLASS ;

#line 4395
typedef struct _PROCESS_WS_WATCH_INFORMATION ;

#line 4405
typedef struct _PROCESS_BASIC_INFORMATION ;

#line 4413
typedef PROCESS_BASIC_INFORMATION ;

#line 4422
typedef struct _PROCESS_DEVICEMAP_INFORMATION ;

#line 4440
typedef struct _PROCESS_SESSION_INFORMATION ;

#line 4454
typedef struct _QUOTA_LIMITS ;

#line 4462
typedef QUOTA_LIMITS ;

#line 4472
typedef struct _IO_COUNTERS ;

#line 4480
typedef IO_COUNTERS ;

#line 4488
typedef struct _VM_COUNTERS ;

#line 4501
typedef VM_COUNTERS ;

#line 4508
typedef struct _POOLED_USAGE_AND_LIMITS ;

#line 4519
typedef POOLED_USAGE_AND_LIMITS ;

#line 4528
typedef struct _PROCESS_ACCESS_TOKEN ;

#line 4555
typedef struct _KERNEL_USER_TIMES ;

#line 4561
typedef KERNEL_USER_TIMES ;

#line 4587
typedef enum _SYSTEM_POWER_STATE ;

#line 4598
typedef enum  {
	PowerActionNone = 0,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
} ;

typedef enum _DEVICE_POWER_STATE ;

#line 4618
typedef union _POWER_STATE ;

#line 4623
typedef enum _POWER_STATE_TYPE ;

#line 4654
typedef ULONG ;

typedef enum  {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
} ;

#line 4663
typedef enum  {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation
} ;

#line 4690
typedef ULONG ;

typedef LONG ;

#line 4693
typedef ULONG ;

#line 4719
typedef union _MCI_STATS ;

#line 4978
typedef struct _KPCR ;

#line 5006
typedef KPCR ;

#line 5012
typedef struct _KFLOATING_SAVE ;

#line 5153
typedef enum _INTERLOCKED_RESULT ;

#line 5252

#pragma warning(disable:4035)
#line 6994
typedef struct _KSYSTEM_TIME ;

#line 7014

#pragma warning(push)

#pragma warning(disable:4164)
#line 7019

#pragma function(_enable)
#line 7020

#pragma function(_disable)
#line 7024

#pragma warning(pop)
#line 7085
typedef struct _FLOATING_SAVE_AREA ;

#line 7097
typedef FLOATING_SAVE_AREA ;

#line 7109
typedef struct _CONTEXT ;

#line 7197
typedef CONTEXT ;

#line 7826
typedef void ;

#line 7850
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ;

#line 7899
typedef struct _KUSER_SHARED_DATA ;

#line 8123
typedef enum _CM_SERVICE_NODE_TYPE ;

#line 8132
typedef enum _CM_SERVICE_LOAD_TYPE ;

#line 8140
typedef enum _CM_ERROR_CONTROL_TYPE ;

#line 8172
typedef int ;

#line 8198
typedef enum _CM_SHARE_DISPOSITION ;

#line 8211
typedef PVOID ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST ;

#line 8443
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR ;

#line 8454
typedef struct _CM_RESOURCE_LIST ;

#line 8471
typedef struct _DEVICE_FLAGS ;

#line 8485
typedef struct _CM_COMPONENT_INFORMATION ;

#line 8503
typedef struct _CM_ROM_BLOCK ;

#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 8518 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_INT13_DRIVE_PARAMETER ;

#line 8532
typedef struct _CM_MCA_POS_DATA ;

#line 8544
typedef struct _EISA_MEMORY_TYPE ;

#line 8554
typedef struct _EISA_MEMORY_CONFIGURATION ;

#line 8567
typedef struct _EISA_IRQ_DESCRIPTOR ;

#line 8575
typedef struct _EISA_IRQ_CONFIGURATION ;

#line 8585
typedef struct _DMA_CONFIGURATION_BYTE0 ;

#line 8592
typedef struct _DMA_CONFIGURATION_BYTE1 ;

#line 8599
typedef struct _EISA_DMA_CONFIGURATION ;

#line 8609
typedef struct _EISA_PORT_DESCRIPTOR ;

#line 8616
typedef struct _EISA_PORT_CONFIGURATION ;

#line 8628
typedef struct _CM_EISA_SLOT_INFORMATION ;

#line 8644
typedef struct _CM_EISA_FUNCTION_INFORMATION ;

#line 8678
typedef struct _CM_PNP_BIOS_DEVICE_NODE ;

#line 8692
typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8761 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_SCSI_DEVICE_DATA ;

#line 8775
typedef struct _CM_VIDEO_DEVICE_DATA ;

#line 8785
typedef struct _CM_SONIC_DEVICE_DATA ;

#line 8796
typedef struct _CM_SERIAL_DEVICE_DATA ;

#line 8810
typedef struct _CM_MONITOR_DEVICE_DATA ;

#line 8844
typedef struct _CM_FLOPPY_DEVICE_DATA ;

#line 8881
typedef struct _CM_KEYBOARD_DEVICE_DATA ;

#line 8893
typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA ;

#line 8905
typedef struct _CM_PCCARD_DEVICE_DATA ;

#line 8944
typedef struct _IO_RESOURCE_DESCRIPTOR ;

#line 9027
typedef struct _IO_RESOURCE_LIST ;

#line 9036
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST ;

#line 9065
typedef struct _EXCEPTION_RECORD ;

#line 9074
typedef EXCEPTION_RECORD ;

typedef struct _EXCEPTION_RECORD32 ;

#line 9085
typedef struct _EXCEPTION_RECORD64 ;

#line 9099
typedef struct _EXCEPTION_POINTERS ;

#line 9111
typedef enum _CONFIGURATION_TYPE ;

#line 9161
typedef enum _KINTERRUPT_MODE ;

#line 9170
typedef enum _KWAIT_REASON ;

#line 9207
typedef struct _DISPATCHER_HEADER ;

#line 9217
typedef struct _KWAIT_BLOCK ;

#line 9230
typedef void ;

#line 9244
typedef struct _KDEVICE_QUEUE ;

#line 9252
typedef struct _KDEVICE_QUEUE_ENTRY ;

#line 9263
typedef struct _KEVENT ;

#line 9271
typedef BOOLEAN ;

#line 9281
typedef struct _KMUTANT ;

#line 9294
typedef struct _KSEMAPHORE ;

#line 9304
typedef struct _KTIMER ;

#line 9899
typedef enum _KBUGCHECK_BUFFER_DUMP_STATE ;

#line 9907
typedef void ;

#line 9914
typedef struct _KBUGCHECK_CALLBACK_RECORD ;

#line 10002
typedef void ;

#line 10020
typedef LOGICAL ;

#line 10037
typedef void ;

#line 10053
typedef enum _MEMORY_CACHING_TYPE_ORIG ;

#line 10057
typedef enum _MEMORY_CACHING_TYPE ;

#line 10087
typedef struct _DBGKD_DEBUG_DATA_HEADER64 ;

#line 10115
typedef enum _POOL_TYPE ;

#line 10195
typedef enum _EX_POOL_PRIORITY ;

#line 10247
typedef struct _FAST_MUTEX ;

#line 10574
typedef PVOID ;

#line 10582
typedef void ;

#line 10588
typedef struct _GENERAL_LOOKASIDE ;

#line 10619
typedef struct _NPAGED_LOOKASIDE_LIST ;

#line 10729
typedef struct _PAGED_LOOKASIDE_LIST ;

#line 10882
typedef enum _WORK_QUEUE_TYPE ;

#line 10889
typedef void ;

#line 10895
typedef struct _WORK_QUEUE_ITEM ;

#line 10926
typedef struct _ZONE_SEGMENT_HEADER ;

#line 10931
typedef struct _ZONE_HEADER ;

#line 11156
typedef ULONG_PTR ;

#line 11157
typedef ERESOURCE_THREAD ;

typedef struct _OWNER_ENTRY ;

#line 11168
typedef struct _ERESOURCE ;

#line 11197
typedef struct _RESOURCE_HASH_ENTRY ;

#line 11204
typedef struct _RESOURCE_PERFORMANCE_DATA ;

#line 11429
typedef struct _CALLBACK_OBJECT ;

typedef void ;

#line 11474
typedef GUID ;

#line 11862
typedef enum _MM_SYSTEM_SIZE ;

#line 11884
typedef enum _LOCK_OPERATION ;

#line 11970
typedef enum _MM_PAGE_PRIORITY ;

#line 11999
typedef struct _PHYSICAL_MEMORY_RANGE ;

#line 12385
typedef NTSTATUS ;

#line 12389
typedef NTSTATUS ;

#line 12399
struct _DRIVER_OBJECT ;

#line 12411
typedef enum _SECURITY_OPERATION_CODE ;

#line 12426
typedef struct _SECURITY_SUBJECT_CONTEXT ;

#line 12448
typedef struct _INITIAL_PRIVILEGE_SET ;

#line 12462
typedef struct _ACCESS_STATE ;

#line 12571
typedef void ;

#line 12585
typedef void ;

#line 12602
typedef struct _IMAGE_INFO ;

#line 12620
typedef void ;

#line 12859
typedef NTSTATUS ;

#line 12878
typedef enum _IO_QUERY_DEVICE_DATA_FORMAT ;

#line 12890
typedef enum _CREATE_FILE_TYPE ;

#line 12905
struct _DEVICE_DESCRIPTION ;

#line 12906
struct _DEVICE_OBJECT ;

#line 12907
struct _DMA_ADAPTER ;

#line 12908
struct _DRIVER_OBJECT ;

#line 12909
struct _DRIVE_LAYOUT_INFORMATION ;

#line 12910
struct _DISK_PARTITION ;

#line 12911
struct _FILE_OBJECT ;

#line 12912
struct _IRP ;

#line 12913
struct _SCSI_REQUEST_BLOCK ;

#line 12919
typedef void ;

#line 12932
typedef void ;

#line 12943
typedef NTSTATUS ;

#line 12955
typedef void ;

#line 12968
typedef void ;

#line 12979
typedef NTSTATUS ;

#line 12990
typedef void ;

#line 13001
typedef void ;

#line 13011
typedef NTSTATUS ;

#line 13025
typedef BOOLEAN ;

#line 13038
typedef BOOLEAN ;

#line 13051
typedef BOOLEAN ;

#line 13068
typedef BOOLEAN ;

#line 13078
typedef BOOLEAN ;

#line 13092
typedef BOOLEAN ;

#line 13106
typedef BOOLEAN ;

#line 13118
typedef BOOLEAN ;

#line 13127
typedef BOOLEAN ;

#line 13141
typedef BOOLEAN ;

#line 13161
typedef void ;

#line 13167
typedef void ;

#line 13179
typedef void ;

#line 13193
typedef BOOLEAN ;

#line 13207
typedef BOOLEAN ;

#line 13219
typedef BOOLEAN ;

#line 13227
typedef BOOLEAN ;

#line 13239
typedef BOOLEAN ;

#line 13253
typedef NTSTATUS ;

#line 13262
typedef NTSTATUS ;

#line 13275
typedef NTSTATUS ;

#line 13282
typedef NTSTATUS ;

#line 13289
typedef BOOLEAN ;

#line 13304
typedef BOOLEAN ;

#line 13319
typedef BOOLEAN ;

#line 13327
typedef BOOLEAN ;

#line 13336
typedef BOOLEAN ;

#line 13350
typedef struct _FAST_IO_DISPATCH ;

#line 13386
typedef enum _IO_ALLOCATION_ACTION ;

#line 13396
typedef IO_ALLOCATION_ACTION ;

#line 13410
typedef struct _IO_SECURITY_CONTEXT ;

#line 13434
typedef struct _VPB ;

#line 13482
typedef struct _ADAPTER_OBJECT ;

#line 13491
typedef struct _WAIT_CONTEXT_BLOCK ;

#line 13503
typedef struct _CONTROLLER_OBJECT ;

#line 13537
typedef struct _DEVICE_OBJECT ;

#line 13575
typedef struct _DEVICE_OBJECT ;

#line 13578
struct _DEVICE_OBJECT_POWER_EXTENSION ;

typedef struct _DEVOBJ_EXTENSION ;

#line 13608
typedef struct _DRIVER_EXTENSION ;

#line 13645
typedef struct _DRIVER_OBJECT ;

#line 13706
typedef struct _DRIVER_OBJECT ;

#line 13715
typedef struct _SECTION_OBJECT_POINTERS ;

#line 13720
typedef SECTION_OBJECT_POINTERS ;

#line 13726
typedef struct _IO_COMPLETION_CONTEXT ;

#line 13759
typedef struct _FILE_OBJECT ;

#line 13788
typedef struct _FILE_OBJECT ;

#line 13828
typedef struct _IRP ;

#line 14078
typedef NTSTATUS ;

#line 14163
typedef enum _DEVICE_RELATION_TYPE ;

#line 14171
typedef struct _DEVICE_RELATIONS ;

#line 14176
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE ;

#line 14185
typedef struct _INTERFACE ;

#line 14196
typedef struct _DEVICE_CAPABILITIES ;

#line 14229
typedef struct _POWER_SEQUENCE ;

#line 14235
typedef enum  {
	BusQueryDeviceID = 0,
	BusQueryHardwareIDs = 1,
	BusQueryCompatibleIDs = 2,
	BusQueryInstanceID = 3,
	BusQueryDeviceSerialNumber = 4
} ;

typedef ULONG ;

#line 14252
typedef enum  {
	DeviceTextDescription = 0,
	DeviceTextLocationInformation = 1
} ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 14615 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SHARE_ACCESS ;

#line 14635
typedef struct _CONFIGURATION_INFORMATION ;

#line 14848
typedef struct _BOOTDISK_INFORMATION ;

#line 15754
typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK ;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK ;

#line 15764
typedef struct _IO_REMOVE_LOCK_DBG_BLOCK ;

#line 15777
typedef struct _IO_REMOVE_LOCK ;

#line 16009
typedef struct _IO_WORKITEM ;

typedef void ;

#line 16100
typedef enum  {
	DevicePropertyDeviceDescription,
	DevicePropertyHardwareID,
	DevicePropertyCompatibleIDs,
	DevicePropertyBootConfiguration,
	DevicePropertyBootConfigurationTranslated,
	DevicePropertyClassName,
	DevicePropertyClassGuid,
	DevicePropertyDriverKeyName,
	DevicePropertyManufacturer,
	DevicePropertyFriendlyName,
	DevicePropertyLocationInformation,
	DevicePropertyPhysicalDeviceObjectName,
	DevicePropertyBusTypeGuid,
	DevicePropertyLegacyBusType,
	DevicePropertyBusNumber,
	DevicePropertyEnumeratorName,
	DevicePropertyAddress,
	DevicePropertyUINumber
} ;

typedef BOOLEAN ;

#line 16129
typedef struct _DMA_ADAPTER ;

#line 16135
typedef ULONG ;

#line 16148
typedef struct _PNP_BUS_INFORMATION ;

#line 16162
typedef struct _LEGACY_BUS_INFORMATION ;

#line 16168
typedef struct _BUS_INTERFACE_STANDARD ;

#line 16190
typedef BOOLEAN ;

#line 16194
typedef NTSTATUS ;

#line 16203
typedef NTSTATUS ;

#line 16206
typedef NTSTATUS ;

#line 16210
typedef NTSTATUS ;

#line 16214
typedef NTSTATUS ;

#line 16218
typedef void ;

#line 16222
typedef NTSTATUS ;

#line 16227
typedef void ;

#line 16231
typedef struct _ACPI_INTERFACE_STANDARD ;

#line 16255
typedef enum _ACPI_REG_TYPE ;

#line 16268
typedef USHORT ;

#line 16272
typedef void ;

#line 16278
typedef struct ACPI_REGS_INTERFACE_STANDARD ;

#line 16300
typedef struct  {
	PVOID LinkNode ;
	ULONG StaticVector ;
	UCHAR Flags ;
} ;

#line 16314
typedef NTSTATUS ;

#line 16329
typedef NTSTATUS ;

#line 16336
typedef void ;

#line 16343
typedef struct _INT_ROUTE_INTERFACE_STANDARD ;

#line 16366
typedef struct _IO_ASSIGNED_RESOURCES ;

#line 16490
typedef enum _IO_NOTIFICATION_EVENT_CATEGORY ;

#line 16504
typedef NTSTATUS ;

#line 16537
typedef void ;

#line 16573
typedef enum _ARBITER_ACTION ;

#line 16586
typedef struct _ARBITER_CONFLICT_INFO ;

#line 16608
typedef struct _ARBITER_PARAMETERS ;

#line 16719
typedef enum _ARBITER_REQUEST_SOURCE ;

#line 16731
typedef enum _ARBITER_RESULT ;

#line 16761
typedef struct _ARBITER_LIST_ENTRY ;

#line 16832
typedef NTSTATUS ;

#line 16853
typedef struct _ARBITER_INTERFACE ;

#line 16880
typedef enum _RESOURCE_TRANSLATION_DIRECTION ;

#line 16889
typedef NTSTATUS ;

#line 16901
typedef NTSTATUS ;

#line 16915
typedef struct _TRANSLATOR_INTERFACE ;

#line 16931
typedef NTSTATUS ;

#line 16945
typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE ;

#line 16959
typedef struct _PLUGPLAY_NOTIFICATION_HEADER ;

#line 16972
typedef struct _HWPROFILE_CHANGE_NOTIFICATION ;

#line 16986
typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION ;

#line 17006
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION ;

#line 17026
typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION ;

#line 17054
typedef struct _DEVICE_DESCRIPTION ;

#line 17086
typedef BOOLEAN ;

#line 17333
typedef void ;

#line 17339
typedef struct _DEVICE_CONTROL_CONTEXT ;

#line 17349
typedef PBUS_HANDLER ;

#line 17355
typedef void ;

#line 17365
typedef enum _HAL_QUERY_INFORMATION_CLASS ;

#line 17381
typedef enum _HAL_SET_INFORMATION_CLASS ;

#line 17388
typedef NTSTATUS ;

#line 17405
typedef NTSTATUS ;

#line 17420
typedef void ;

#line 17429
typedef void ;

#line 17438
typedef NTSTATUS ;

#line 17447
typedef NTSTATUS ;

#line 17456
typedef NTSTATUS ;

#line 17466
typedef NTSTATUS ;

#line 17475
typedef NTSTATUS ;

#line 17486
typedef struct _PM_DISPATCH_TABLE ;

#line 17492
typedef NTSTATUS ;

#line 17505
typedef struct _DMA_ADAPTER ;

#line 17520
typedef NTSTATUS ;

#line 17543
typedef BOOLEAN ;

#line 17553
typedef NTSTATUS ;

#line 17566
typedef void ;

#line 17572
typedef void ;

#line 17578
typedef BOOLEAN ;

#line 17588
typedef struct  {
	ULONG Version ;
	pHalQuerySystemInformation HalQuerySystemInformation ;
	pHalSetSystemInformation HalSetSystemInformation ;
	pHalQueryBusSlots HalQueryBusSlots ;
	ULONG Spare1 ;
	pHalExamineMBR HalExamineMBR ;
	pHalIoAssignDriveLetters HalIoAssignDriveLetters ;
	pHalIoReadPartitionTable HalIoReadPartitionTable ;
	pHalIoSetPartitionInformation HalIoSetPartitionInformation ;
	pHalIoWritePartitionTable HalIoWritePartitionTable ;
	pHalHandlerForBus HalReferenceHandlerForBus ;
	pHalReferenceBusHandler HalReferenceBusHandler ;
	pHalReferenceBusHandler HalDereferenceBusHandler ;
	pHalInitPnpDriver HalInitPnpDriver ;
	pHalInitPowerManagement HalInitPowerManagement ;
	pHalGetDmaAdapter HalGetDmaAdapter ;
	pHalGetInterruptTranslator HalGetInterruptTranslator ;
} ;

#line 17650
typedef struct _HAL_BUS_INFORMATION ;

#line 17658
typedef struct _HAL_PROFILE_SOURCE_INFORMATION ;

#line 17665
typedef struct _HAL_PROFILE_SOURCE_INTERVAL ;

#line 17671
typedef enum _HAL_DISPLAY_BIOS_INFORMATION ;

#line 17678
typedef struct _HAL_POWER_INFORMATION ;

#line 17683
typedef struct _HAL_PROCESSOR_SPEED_INFO ;

#line 17688
typedef struct _HAL_CALLBACKS ;

#line 17694
typedef struct _HAL_PROCESSOR_FEATURE ;

#line 17706
typedef union _MCI_ADDR ;

#line 17716
typedef enum  {
	HAL_MCE_RECORD,
	HAL_MCA_RECORD
} ;

#line 17726
typedef struct _MCA_EXCEPTION ;

#line 17752
typedef void ;

#line 17762
typedef struct _MCA_DRIVER_INFO ;

#line 17772
typedef struct _SCATTER_GATHER_ELEMENT ;

#line 17778

#pragma warning(disable:4200)
#line 17779
typedef struct _SCATTER_GATHER_LIST ;

#line 17784

#pragma warning(default:4200)
#line 17788
typedef struct _DMA_OPERATIONS ;

typedef struct _DMA_ADAPTER ;

#line 17797
typedef void ;

#line 17801
typedef PVOID ;

#line 17808
typedef void ;

#line 17816
typedef NTSTATUS ;

#line 17824
typedef BOOLEAN ;

#line 17833
typedef void ;

#line 17837
typedef void ;

#line 17843
typedef PHYSICAL_ADDRESS ;

#line 17852
typedef ULONG ;

#line 17856
typedef ULONG ;

#line 17860
typedef void ;

#line 17868
typedef NTSTATUS ;

#line 17880
typedef void ;

#line 17887
typedef struct _DMA_OPERATIONS ;

#line 18235
typedef void ;

#line 18321
typedef struct _OBJECT_HANDLE_INFORMATION ;

#line 18402
typedef struct _PCI_SLOT_NUMBER ;

#line 18418
typedef struct _PCI_COMMON_CONFIG ;

#line 18591
typedef struct _PCI_CAPABILITIES_HEADER ;

#line 18600
typedef struct _PCI_PMC ;

#line 18618
typedef struct _PCI_PMCSR ;

#line 18628
typedef struct _PCI_PMCSR_BSE ;

#line 18635
typedef struct _PCI_PM_CAPABILITY ;

#line 18679
typedef struct _PCI_AGP_CAPABILITY ;

#line 18720
typedef struct _PCI_MSI_CAPABILITY ;

#line 18946
typedef void ;

#line 18954
typedef void ;

#line 18963
typedef void ;

#line 18975
typedef struct _PCIBUSDATA ;

#line 18986
typedef ULONG ;

#line 18995
typedef void ;

#line 19000
typedef void ;

#line 19006
typedef struct _PCI_BUS_INTERFACE_STANDARD ;

#line 19028
typedef BOOLEAN ;

#line 19043
typedef struct _PCI_DEVICE_PRESENT_INTERFACE ;

#line 127 "C:/NTDDK/inc/ntddser.h"
typedef struct _SERIALPERF_STATS ;

#line 136
typedef struct _SERIALCONFIG ;

#line 154
typedef struct _SERIAL_LINE_CONTROL ;

#line 160
typedef struct _SERIAL_TIMEOUTS ;

#line 175
typedef struct _SERIAL_QUEUE_SIZE ;

#line 185
typedef struct _SERIAL_BAUD_RATE ;

#line 247
typedef struct _SERIAL_CHARS ;

#line 284
typedef struct _SERIAL_HANDFLOW ;

#line 340
typedef struct _SERIAL_BASIC_SETTINGS ;

#line 353
typedef struct _SERIAL_STATUS ;

#line 433
typedef struct _SERIAL_XOFF_COUNTER ;

#line 539
typedef struct _SERIAL_COMMPROP ;

#line 631
typedef struct _SERENUM_PORT_DESC ;

#line 652
typedef UCHAR ;

#line 658
typedef void ;

#line 665
typedef enum _SERENUM_PORTION ;

#line 671
typedef struct _SERENUM_PORT_PARAMETERS ;

#line 28 "C:/NTDDK/inc/ddk/wdm/wmilib.h"

#pragma once
#line 38
typedef struct  {
	LPCGUID Guid ;
	ULONG InstanceCount ;
	ULONG Flags ;
} ;

#line 45
typedef NTSTATUS ;

#line 101
typedef NTSTATUS ;

#line 162
typedef NTSTATUS ;

#line 206
typedef NTSTATUS ;

#line 253
typedef NTSTATUS ;

#line 306
typedef enum  {
	WmiEventControl,
	WmiDataBlockControl
} ;

#line 312
typedef NTSTATUS ;

#line 355
typedef struct _WMILIB_CONTEXT ;

#line 411
typedef enum  {
	IrpProcessed,
	IrpNotCompleted,
	IrpNotWmi,
	IrpForward
} ;

#line 13 "C:/NTDDK/inc/wmidata.h"
typedef struct _MSWmi_MofData ;

#line 51
typedef struct _MSWmi_ProviderInfo ;

#line 66
typedef struct _MSWmi_PnPDeviceId ;

#line 83
typedef struct _MSWmi_PnPInstanceNames ;

#line 105
typedef struct _MSSmBios_RawSMBiosTables ;

#line 147
typedef struct _MSPower_DeviceEnable ;

#line 165
typedef struct _MSPower_DeviceWakeEnable ;

#line 182
typedef struct _MSNdis_NetworkAddress ;

#line 199
typedef struct _MSNdis_NetworkShortAddress ;

#line 216
typedef struct _MSNdis_NetworkLinkSpeed ;

#line 239
typedef struct _MSNdis_EnumerateAdapter ;

#line 256
typedef struct _MSNdis_NotifyAdapterRemoval ;

#line 273
typedef struct _MSNdis_NotifyAdapterArrival ;

#line 291
typedef struct _MSNdis_NdisEnumerateVc ;

#line 307
typedef struct _MSNdis_NotifyVcRemoval ;

#line 323
typedef struct _MSNdis_NotifyVcArrival ;

#line 338
typedef struct _MSNdis_HardwareStatus ;

#line 356
typedef struct _MSNdis_MediaSupported ;

#line 378
typedef struct _MSNdis_MediaInUse ;

#line 400
typedef struct _MSNdis_MaximumLookahead ;

#line 418
typedef struct _MSNdis_MaximumFrameSize ;

#line 436
typedef struct _MSNdis_LinkSpeed ;

#line 454
typedef struct _MSNdis_TransmitBufferSpace ;

#line 472
typedef struct _MSNdis_ReceiveBufferSpace ;

#line 490
typedef struct _MSNdis_TransmitBlockSize ;

#line 508
typedef struct _MSNdis_ReceiveBlockSize ;

#line 526
typedef struct _MSNdis_VendorID ;

#line 544
typedef struct _MSNdis_VendorDescription ;

#line 561
typedef struct _MSNdis_CurrentPacketFilter ;

#line 579
typedef struct _MSNdis_CurrentLookahead ;

#line 597
typedef struct _MSNdis_DriverVersion ;

#line 615
typedef struct _MSNdis_MaximumTotalSize ;

#line 633
typedef struct _MSNdis_MacOptions ;

#line 651
typedef struct _MSNdis_MediaConnectStatus ;

#line 669
typedef struct _MSNdis_MaximumSendPackets ;

#line 687
typedef struct _MSNdis_VendorDriverVersion ;

#line 705
typedef struct _MSNdis_TransmitsOk ;

#line 723
typedef struct _MSNdis_ReceivesOk ;

#line 741
typedef struct _MSNdis_TransmitsError ;

#line 759
typedef struct _MSNdis_ReceiveError ;

#line 777
typedef struct _MSNdis_ReceiveNoBuffer ;

#line 795
typedef struct _MSNdis_CoHardwareStatus ;

#line 813
typedef struct _MSNdis_CoMediaSupported ;

#line 835
typedef struct _MSNdis_CoMediaInUse ;

#line 857
typedef struct _MSNdis_CoLinkSpeed ;

#line 875
typedef struct _MSNdis_CoVendorId ;

#line 893
typedef struct _MSNdis_CoVendorDescription ;

#line 910
typedef struct _MSNdis_CoDriverVersion ;

#line 928
typedef struct _MSNdis_CoMacOptions ;

#line 946
typedef struct _MSNdis_CoMediaConnectStatus ;

#line 964
typedef struct _MSNdis_CoVendorDriverVersion ;

#line 982
typedef struct _MSNdis_CoMinimumLinkSpeed ;

#line 1000
typedef struct _MSNdis_CoTransmitPdusOk ;

#line 1018
typedef struct _MSNdis_CoReceivePdusOk ;

#line 1036
typedef struct _MSNdis_CoTransmitPduErrors ;

#line 1054
typedef struct _MSNdis_CoReceivePduErrors ;

#line 1072
typedef struct _MSNdis_CoReceivePdusNoBuffer ;

#line 1090
typedef struct _MSNdis_AtmSupportedVcRates ;

#line 1113
typedef struct _MSNdis_AtmSupportedServiceCategory ;

#line 1131
typedef struct _MSNdis_AtmSupportedAalTypes ;

#line 1149
typedef struct _MSNdis_AtmHardwareCurrentAddress ;

#line 1167
typedef struct _MSNdis_AtmMaxActiveVcs ;

#line 1185
typedef struct _MSNdis_AtmMaxActiveVciBits ;

#line 1203
typedef struct _MSNdis_AtmMaxActiveVpiBits ;

#line 1221
typedef struct _MSNdis_AtmMaxAal0PacketSize ;

#line 1239
typedef struct _MSNdis_AtmMaxAal1PacketSize ;

#line 1257
typedef struct _MSNdis_AtmMaxAal34PacketSize ;

#line 1275
typedef struct _MSNdis_AtmMaxAal5PacketSize ;

#line 1293
typedef struct _MSNdis_AtmReceiveCellsOk ;

#line 1311
typedef struct _MSNdis_AtmTransmitCellsOk ;

#line 1329
typedef struct _MSNdis_AtmReceiveCellsDropped ;

#line 1347
typedef struct _MSNdis_EthernetPermanentAddress ;

#line 1365
typedef struct _MSNdis_EthernetCurrentAddress ;

#line 1383
typedef struct _MSNdis_EthernetMulticastList ;

#line 1405
typedef struct _MSNdis_EthernetMaximumMulticastListSize ;

#line 1423
typedef struct _MSNdis_EthernetMacOptions ;

#line 1441
typedef struct _MSNdis_EthernetReceiveErrorAlignment ;

#line 1459
typedef struct _MSNdis_EthernetOneTransmitCollision ;

#line 1477
typedef struct _MSNdis_EthernetMoreTransmitCollisions ;

#line 1495
typedef struct _MSNdis_TokenRingPermanentAddress ;

#line 1513
typedef struct _MSNdis_TokenRingCurrentAddress ;

#line 1531
typedef struct _MSNdis_TokenRingCurrentFunctional ;

#line 1549
typedef struct _MSNdis_TokenRingCurrentGroup ;

#line 1567
typedef struct _MSNdis_TokenRingLastOpenStatus ;

#line 1585
typedef struct _MSNdis_TokenRingCurrentRingStatus ;

#line 1603
typedef struct _MSNdis_TokenRingCurrentRingState ;

#line 1621
typedef struct _MSNdis_TokenRingLineErrors ;

#line 1639
typedef struct _MSNdis_TokenRingLostFrames ;

#line 1657
typedef struct _MSNdis_FddiLongPermanentAddress ;

#line 1675
typedef struct _MSNdis_FddiLongCurrentAddress ;

#line 1693
typedef struct _MSNdis_FddiLongMulticastList ;

#line 1715
typedef struct _MSNdis_FddiLongMaximumListSize ;

#line 1733
typedef struct _MSNdis_FddiShortPermanentAddress ;

#line 1751
typedef struct _MSNdis_FddiShortCurrentAddress ;

#line 1769
typedef struct _MSNdis_FddiShortMulticastList ;

#line 1791
typedef struct _MSNdis_FddiShortMaximumListSize ;

#line 1809
typedef struct _MSNdis_FddiAttachmentType ;

#line 1827
typedef struct _MSNdis_FddiUpstreamNodeLong ;

#line 1845
typedef struct _MSNdis_FddiDownstreamNodeLong ;

#line 1863
typedef struct _MSNdis_FddiFrameErrors ;

#line 1881
typedef struct _MSNdis_FddiFramesLost ;

#line 1899
typedef struct _MSNdis_FddiRingManagmentState ;

#line 1917
typedef struct _MSNdis_FddiLctFailures ;

#line 1935
typedef struct _MSNdis_FddiLemRejects ;

#line 1953
typedef struct _MSNdis_FddiLConnectionState ;

#line 1972
typedef struct _MSNdis_StatusResetStart ;

#line 1988
typedef struct _MSNdis_StatusResetEnd ;

#line 2004
typedef struct _MSNdis_StatusMediaConnect ;

#line 2020
typedef struct _MSNdis_StatusMediaDisconnect ;

#line 2035
typedef struct _MSNdis_StatusMediaSpecificIndication ;

#line 2057
typedef struct _MSNdis_StatusLinkSpeedChange ;

#line 2075
typedef struct _MSNdis_StatusProtocolBind ;

#line 2092
typedef struct _MSNdis_StatusProtocolUnbind ;

#line 2109
typedef struct _KEYBOARD_PORT_WMI_STD_DATA ;

#line 2152
typedef struct _POINTER_PORT_WMI_STD_DATA ;

#line 2205
typedef struct _MSMouse_ClassInformation ;

#line 2223
typedef struct _MSKeyboard_ClassInformation ;

#line 2241
typedef struct _MSAcpi_ThermalZoneTemperature ;

#line 2304
typedef struct _WMI_DISK_GEOMETRY ;

#line 2342
typedef struct _WMI_DISK_PERFORMANCE ;

#line 2415
typedef struct _MSDiskDriver_Performance ;

#line 2437
typedef struct _STORAGE_FAILURE_PREDICT_STATUS ;

#line 2460
typedef struct _STORAGE_FAILURE_PREDICT_DATA ;

#line 2483
typedef struct _STORAGE_FAILURE_PREDICT_EVENT ;

#line 2513
typedef struct _STORAGE_FAILURE_PREDICT_FUNCTION ;

#line 2528
typedef struct _MSIde_PortDeviceInfo ;

#line 2556
typedef struct _MSSerial_PortName ;

#line 2573
typedef struct _SERIAL_WMI_COMM_DATA ;

#line 2723
typedef struct _SERIAL_WMI_HW_DATA ;

#line 2770
typedef struct _SERIAL_WMI_PERF_DATA ;

#line 2813
typedef struct _SERIAL_WMI_COMMPROP ;

#line 2920
typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS ;

#line 2943
typedef struct _PARALLEL_WMI_LOG_INFO ;

#line 3041
typedef struct _REDBOOK_WMI_STD_DATA ;

#line 3094
typedef struct _REDBOOK_WMI_PERF_DATA ;

#line 3137
typedef struct _RegisteredGuids ;

#line 475 "serial.h"
typedef struct _CONFIG_DATA ;

#line 509
typedef struct _SERIAL_CISR_SW ;

#line 520
typedef struct _SERIAL_FIRMWARE_DATA ;

#line 576
typedef struct _SERIAL_DEVICE_STATE ;

#line 646
typedef struct _SERIAL_DEVICE_EXTENSION ;

#line 1808
typedef struct _SERIAL_MULTIPORT_DISPATCH ;

#line 2157
typedef enum _SERIAL_MEM_COMPARES ;

#line 2164
typedef struct _SERIAL_LIST_DATA ;

#line 2169
typedef struct _SERIAL_GLOBALS ;

#line 2180
typedef struct _SERIAL_USER_DATA ;

#line 2206
typedef struct _SERIAL_PTR_CTX ;

#line 20 "serialp.h"
typedef NTSTATUS ;

#line 26
typedef void ;

#line 835
typedef struct _SERIAL_UPDATE_CHAR ;

#line 846
typedef struct _SERIAL_IOCTL_SYNC ;

#line 27 "read.c"
void SerialCancelCurrentRead(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 33
BOOLEAN SerialGrabReadFromIsr(PVOID Context ) ;
#line 38
BOOLEAN SerialUpdateReadByIsr(PVOID Context ) ;
#line 43
ULONG SerialGetCharsFromIntBuffer(PSERIAL_DEVICE_EXTENSION Extension ) ;
#line 48
BOOLEAN SerialUpdateInterruptBuffer(PVOID Context ) ;
#line 53
BOOLEAN SerialUpdateAndSwitchToUser(PVOID Context ) ;
#line 58
NTSTATUS SerialResizeBuffer(PSERIAL_DEVICE_EXTENSION Extension ) ;
#line 63
ULONG SerialMoveToNewIntBuffer(PSERIAL_DEVICE_EXTENSION Extension , PUCHAR
	NewBuffer ) ;
#line 69
BOOLEAN SerialUpdateAndSwitchToNew(PVOID Context ) ;

#line 75

#pragma alloc_text(PAGESER, SerialRead)
#line 76

#pragma alloc_text(PAGESER, SerialStartRead)
#line 77

#pragma alloc_text(PAGESER, SerialCancelCurrentRead)
#line 78

#pragma alloc_text(PAGESER, SerialGrabReadFromIsr)
#line 79

#pragma alloc_text(PAGESER, SerialUpdateReadByIsr)
#line 80

#pragma alloc_text(PAGESER, SerialGetCharsFromIntBuffer)
#line 81

#pragma alloc_text(PAGESER, SerialUpdateInterruptBuffer)
#line 82

#pragma alloc_text(PAGESER, SerialUpdateAndSwitchToUser)
#line 83

#pragma alloc_text(PAGESER, SerialResizeBuffer)
#line 84

#pragma alloc_text(PAGESER, SerialMoveToNewIntBuffer)
#line 85

#pragma alloc_text(PAGESER, SerialUpdateAndSwitchToNew)
#line 89
NTSTATUS SerialRead(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
	#line 119
	PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
	BOOLEAN acceptingIRPs ;
	NTSTATUS status ;
	#line 123
	;
	#line 125
	do
	{
		#line 125
		;
	}
	while(0);
	#line 127
	if((status = SerialIRPPrologue(Irp, extension)) != (NTSTATUS
		)0x00000000L)
	{
		{
			#line 128
			IofCompleteRequest(Irp, 0);
			#line 128
			SerialIRPEpilogue(extension);
		}
		#line 128
		;
		do
		{
			#line 129
			;
		}
		while(0);
		#line 130
		return status;
	}
	#line 136
	do
	{
		#line 136
		;
	}
	while(0);
	#line 137
	if(SerialCompleteIfError(DeviceObject, Irp) != (NTSTATUS )0x00000000L)
	{
		#line 143
		do
		{
			#line 143
			;
		}
		while(0);
		#line 145
		return (NTSTATUS )0xC0000120L;
	}
	#line 149
	(Irp->IoStatus).Information = 0L;
	#line 156
	if((((((Irp->Tail).Overlay).CurrentStackLocation)->Parameters).Read).Length
		)
	{
		#line 165
		do
		{
			#line 165
			;
		}
		while(0);
		#line 166
		return SerialStartOrQueue(extension, Irp, &
			extension->ReadQueue, & extension->CurrentReadIrp,
			SerialStartRead);
	}
	else
	{
		#line 176
		(Irp->IoStatus).Status = (NTSTATUS )0x00000000L;
		#line 180
		do
		{
			#line 180
			;
		}
		while(0);
		{
			#line 181
			IofCompleteRequest(Irp, 0);
			#line 181
			SerialIRPEpilogue(extension);
		}
		#line 181
		;
		#line 184
		do
		{
			#line 184
			;
		}
		while(0);
		#line 186
		return (NTSTATUS )0x00000000L;
	}
}

#line 192
NTSTATUS SerialStartRead(PSERIAL_DEVICE_EXTENSION Extension )
{
	#line 224
	SERIAL_UPDATE_CHAR updateChar ;
	#line 226
	PIRP newIrp ;
	KIRQL oldIrql ;
	KIRQL controlIrql ;
	#line 230
	BOOLEAN returnWithWhatsPresent ;
	BOOLEAN os2ssreturn ;
	BOOLEAN crunchDownToOne ;
	BOOLEAN useTotalTimer ;
	BOOLEAN useIntervalTimer ;
	#line 236
	ULONG multiplierVal ;
	ULONG constantVal ;
	#line 239
	LARGE_INTEGER totalTime ;
	#line 241
	SERIAL_TIMEOUTS timeoutsForIrp ;
	#line 243
	BOOLEAN setFirstStatus = 0;
	NTSTATUS firstStatus ;
	#line 246
	;
	#line 249
	do
	{
		#line 249
		;
	}
	while(0);
	#line 251
	updateChar.Extension = Extension;
	#line 253
	do
	{
		#line 260
		if(((((Extension->CurrentReadIrp)->Tail).Overlay).CurrentStackLocation
			)->MajorFunction != 0x03)
		{
			NTSTATUS localStatus = SerialResizeBuffer(Extension);
			#line 265
			if(! setFirstStatus)
			{
				firstStatus = localStatus;
				setFirstStatus = 1;
			}
		}
		else
		{
			#line 274
			Extension->NumberNeededForRead =
				((((((Extension->CurrentReadIrp)->Tail).Overlay)
				.CurrentStackLocation)->Parameters).Read).Length
				;
			#line 284
			useTotalTimer = 0;
			returnWithWhatsPresent = 0;
			os2ssreturn = 0;
			crunchDownToOne = 0;
			useIntervalTimer = 0;
			#line 306
			SerialCancelTimer(& Extension->ReadRequestTotalTimer,
				Extension);
			#line 307
			SerialCancelTimer(& Extension->ReadRequestIntervalTimer,
				Extension);
			#line 321
			* & controlIrql = KfAcquireSpinLock(&
				Extension->ControlLock);
			timeoutsForIrp = Extension->Timeouts;
			#line 328
			KfReleaseSpinLock(& Extension->ControlLock,
				controlIrql);
			#line 334
			if(timeoutsForIrp.ReadIntervalTimeout &&
				timeoutsForIrp.ReadIntervalTimeout !=
				0xffffffff)
			{
				useIntervalTimer = 1;
				#line 340
				(Extension->IntervalTime).QuadPart = (ULONGLONG
					)((ULONGLONG )((ULONG
					)timeoutsForIrp.ReadIntervalTimeout) *
					(ULONG )10000);
				#line 347
				if((Extension->IntervalTime).QuadPart >=
					(Extension->CutOverAmount).QuadPart)
				{
					Extension->IntervalTimeToUse = &
						Extension->LongIntervalAmount;
				}
				else
				{
					Extension->IntervalTimeToUse = &
						Extension->ShortIntervalAmount;
				}
			}
			#line 362
			if(timeoutsForIrp.ReadIntervalTimeout == 0xffffffff)
			{
				#line 381
				if(! timeoutsForIrp.ReadTotalTimeoutConstant &&
					!
					timeoutsForIrp.ReadTotalTimeoutMultiplier)
				{
					#line 384
					returnWithWhatsPresent = 1;
				}
				else
				{
					#line 386
					if(timeoutsForIrp.ReadTotalTimeoutConstant
						!= 0xffffffff &&
						timeoutsForIrp.ReadTotalTimeoutMultiplier
						!= 0xffffffff)
					{
						useTotalTimer = 1;
						os2ssreturn = 1;
						multiplierVal =
							timeoutsForIrp.ReadTotalTimeoutMultiplier;
						#line 394
						constantVal =
							timeoutsForIrp.ReadTotalTimeoutConstant;
					}
					else
					{
						#line 396
						if(timeoutsForIrp.ReadTotalTimeoutConstant
							!= 0xffffffff &&
							timeoutsForIrp.ReadTotalTimeoutMultiplier
							== 0xffffffff)
						{
							useTotalTimer = 1;
							os2ssreturn = 1;
							crunchDownToOne = 1;
							multiplierVal = 0;
							constantVal =
								timeoutsForIrp.ReadTotalTimeoutConstant
								;
						}
					}
				}
			}
			else
			{
				#line 416
				if(timeoutsForIrp.ReadTotalTimeoutMultiplier ||
					timeoutsForIrp.ReadTotalTimeoutConstant)
				{
					#line 423
					useTotalTimer = 1;
					multiplierVal =
						timeoutsForIrp.ReadTotalTimeoutMultiplier;
					#line 425
					constantVal =
						timeoutsForIrp.ReadTotalTimeoutConstant;
				}
			}
			#line 431
			if(useTotalTimer)
			{
				totalTime.QuadPart = (LONGLONG )((ULONGLONG
					)((ULONGLONG )((ULONG
					)Extension->NumberNeededForRead) *
					(ULONG )multiplierVal) + constantVal) *
					- 10000;
			}
			#line 454
			* & controlIrql = KfAcquireSpinLock(&
				Extension->ControlLock);
			updateChar.CharsCopied =
				SerialGetCharsFromIntBuffer(Extension);
			#line 462
			if(returnWithWhatsPresent || !
				Extension->NumberNeededForRead || os2ssreturn &&
				((Extension->CurrentReadIrp)->IoStatus).Information
				)
			{
				#line 472
				KeSynchronizeExecution(Extension->Interrupt,
					SerialUpdateInterruptBuffer, &
					updateChar);
				#line 481
				KfReleaseSpinLock(& Extension->ControlLock,
					controlIrql);
				((Extension->CurrentReadIrp)->IoStatus).Status =
					(NTSTATUS )0x00000000L;
				#line 484
				if(! setFirstStatus)
				{
					firstStatus = (NTSTATUS )0x00000000L;
					setFirstStatus = 1;
				}
			}
			else
			{
				{
					#line 499
					;
					#line 499
					((((((Extension->CurrentReadIrp)->Tail).Overlay
						).CurrentStackLocation)->Parameters
						).Others).Argument4 = (void * 
						)0;
				}
				#line 499
				;
				#line 501
				IoAcquireCancelSpinLock(& oldIrql);
				#line 507
				if((Extension->CurrentReadIrp)->Cancel)
				{
					IoReleaseCancelSpinLock(oldIrql);
					#line 513
					KfReleaseSpinLock(&
						Extension->ControlLock,
						controlIrql);
					#line 514
					((Extension->CurrentReadIrp)->IoStatus).Status
						= (NTSTATUS )0xC0000120L;
					((Extension->CurrentReadIrp)->IoStatus).Information
						= 0;
					if(! setFirstStatus)
					{
						firstStatus = (NTSTATUS
							)0xC0000120L;
						#line 521
						setFirstStatus = 1;
					}
				}
				else
				{
					#line 538
					if(crunchDownToOne)
					{
						#line 547
						;
						#line 549
						Extension->NumberNeededForRead =
							1;
						#line 552
						((((((Extension->CurrentReadIrp)
							->Tail).Overlay).CurrentStackLocation
							)->Parameters).Read).Length
							= 1;
					}
					#line 563
					KeSynchronizeExecution(Extension->Interrupt
						, SerialUpdateAndSwitchToUser, &
						updateChar);
					#line 569
					if(! updateChar.Completed)
					{
						#line 585
						if(useTotalTimer)
						{
							#line 590
							do
							{
	#line 590
	LONG _refType = 0x00000004;
	#line 590
	PULONG_PTR _arg4 = (PVOID )(&
		((((((Extension->CurrentReadIrp)->Tail).Overlay).CurrentStackLocation
		)->Parameters).Others).Argument4);
	#line 590
	;
	#line 590
	* _arg4 |= _refType;
							}
							while(0);
							#line 592
							SerialSetTimer(&
								Extension->ReadRequestTotalTimer
								, totalTime, &
								Extension->TotalReadTimeoutDpc
								, Extension);
						}
						#line 601
						if(useIntervalTimer)
						{
							#line 606
							do
							{
	#line 606
	LONG _refType = 0x00000008;
	#line 606
	PULONG_PTR _arg4 = (PVOID )(&
		((((((Extension->CurrentReadIrp)->Tail).Overlay).CurrentStackLocation
		)->Parameters).Others).Argument4);
	#line 606
	;
	#line 606
	* _arg4 |= _refType;
							}
							while(0);
							#line 608
							KeQuerySystemTime(&
								Extension->LastReadTime
								);
							SerialSetTimer(&
								Extension->ReadRequestIntervalTimer
								, *
								Extension->IntervalTimeToUse,
								&
								Extension->IntervalReadTimeoutDpc,
								Extension);
						}
						#line 620
						if(pending == 0)
							#line 620
							pending = 1;
						else
							#line 620
							errorFn();
						((((Extension->CurrentReadIrp)->Tail
							).Overlay).CurrentStackLocation
							)->Control |= 0x01;
						#line 622
						IoReleaseCancelSpinLock(oldIrql)
							;
						#line 626
						KfReleaseSpinLock(&
							Extension->ControlLock,
							controlIrql);
						#line 627
						if(! setFirstStatus)
						{
							firstStatus = (NTSTATUS
								)0x00000103L;
						}
						return firstStatus;
					}
					else
					{
						IoReleaseCancelSpinLock(oldIrql)
							;
						#line 640
						KfReleaseSpinLock(&
							Extension->ControlLock,
							controlIrql);
						#line 641
						((Extension->CurrentReadIrp)->IoStatus
							).Status = (NTSTATUS
							)0x00000000L;
						if(! setFirstStatus)
						{
							firstStatus = (NTSTATUS
								)0x00000000L;
							#line 647
							setFirstStatus = 1;
						}
					}
				}
			}
		}
		#line 663
		SerialGetNextIrp(& Extension->CurrentReadIrp, &
			Extension->ReadQueue, & newIrp, 1, Extension);
	}
	while(newIrp);
	#line 673
	return firstStatus;
}

#line 677
void SerialCompleteRead(PKDPC Dpc , PVOID DeferredContext , PVOID SystemContext1
	, PVOID SystemContext2 )
{
	#line 712
	PSERIAL_DEVICE_EXTENSION extension = DeferredContext;
	KIRQL oldIrql ;
	#line 715
	SystemContext1;
	SystemContext2;
	#line 719
	do
	{
		#line 719
		;
	}
	while(0);
	IoAcquireCancelSpinLock(& oldIrql);
	#line 732
	extension->CountOnLastRead = (LONG )(- 3);
	#line 734
	SerialTryToCompleteCurrent(extension, (void *  )0, oldIrql, (NTSTATUS
		)0x00000000L, & extension->CurrentReadIrp, &
		extension->ReadQueue, & extension->ReadRequestIntervalTimer, &
		extension->ReadRequestTotalTimer, SerialStartRead,
		SerialGetNextIrp, 0x00000001);
	#line 748
	SerialDpcEpilogue(extension, Dpc);
}

void SerialCancelCurrentRead(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
	#line 777
	PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
	;
	#line 788
	extension->CountOnLastRead = (LONG )(- 1);
	#line 790
	SerialTryToCompleteCurrent(extension, SerialGrabReadFromIsr,
		Irp->CancelIrql, (NTSTATUS )0xC0000120L, &
		extension->CurrentReadIrp, & extension->ReadQueue, &
		extension->ReadRequestIntervalTimer, &
		extension->ReadRequestTotalTimer, SerialStartRead,
		SerialGetNextIrp, 0x00000002);
}

#line 806
BOOLEAN SerialGrabReadFromIsr(PVOID Context )
{
	#line 843
	PSERIAL_DEVICE_EXTENSION extension = Context;
	;
	#line 846
	if(extension->ReadBufferBase != extension->InterruptReadBuffer)
	{
		#line 855
		((extension->CurrentReadIrp)->IoStatus).Information =
			((((((extension->CurrentReadIrp)->Tail).Overlay).CurrentStackLocation
			)->Parameters).Read).Length - (extension->LastCharSlot -
			extension->CurrentCharSlot + 1);
		#line 865
		extension->ReadBufferBase = extension->InterruptReadBuffer;
		extension->CurrentCharSlot = extension->InterruptReadBuffer;
		extension->FirstReadableChar = extension->InterruptReadBuffer;
		extension->LastCharSlot = extension->InterruptReadBuffer +
			(extension->BufferSize - 1);
		extension->CharsInInterruptBuffer = 0;
		#line 875
		do
		{
			#line 875
			LONG _refType = 0x00000001;
			#line 875
			PULONG_PTR _arg4 = (PVOID )(&
				((((((extension->CurrentReadIrp)->Tail).Overlay)
				.CurrentStackLocation)->Parameters).Others).Argument4
				);
			#line 875
			;
			#line 875
			* _arg4 &= ~ _refType;
		}
		while(0);
	}
	return 0;
}

#line 883
void SerialReadTimeout(PKDPC Dpc , PVOID DeferredContext , PVOID SystemContext1
	, PVOID SystemContext2 )
{
	#line 916
	PSERIAL_DEVICE_EXTENSION extension = DeferredContext;
	KIRQL oldIrql ;
	#line 919
	SystemContext1;
	SystemContext2;
	#line 923
	do
	{
		#line 923
		;
	}
	while(0);
	#line 925
	IoAcquireCancelSpinLock(& oldIrql);
	#line 935
	extension->CountOnLastRead = (LONG )(- 2);
	#line 937
	SerialTryToCompleteCurrent(extension, SerialGrabReadFromIsr, oldIrql,
		(NTSTATUS )0x00000102L, & extension->CurrentReadIrp, &
		extension->ReadQueue, & extension->ReadRequestIntervalTimer, &
		extension->ReadRequestTotalTimer, SerialStartRead,
		SerialGetNextIrp, 0x00000004);
	#line 951
	SerialDpcEpilogue(extension, Dpc);
}

#line 955
BOOLEAN SerialUpdateReadByIsr(PVOID Context )
{
	#line 984
	PSERIAL_DEVICE_EXTENSION extension = Context;
	;
	#line 987
	extension->CountOnLastRead = extension->ReadByIsr;
	extension->ReadByIsr = 0;
	#line 990
	return 0;
}

#line 994
void SerialIntervalReadTimeout(PKDPC Dpc , PVOID DeferredContext , PVOID
	SystemContext1 , PVOID SystemContext2 )
{
	#line 1034
	PSERIAL_DEVICE_EXTENSION extension = DeferredContext;
	KIRQL oldIrql ;
	#line 1037
	SystemContext1;
	SystemContext2;
	#line 1040
	IoAcquireCancelSpinLock(& oldIrql);
	#line 1042
	do
	{
		#line 1042
		;
	}
	while(0);
	#line 1044
	if(extension->CountOnLastRead == (LONG )(- 2))
	{
		#line 1052
		SerialTryToCompleteCurrent(extension, SerialGrabReadFromIsr,
			oldIrql, (NTSTATUS )0x00000102L, &
			extension->CurrentReadIrp, & extension->ReadQueue, &
			extension->ReadRequestIntervalTimer, &
			extension->ReadRequestTotalTimer, SerialStartRead,
			SerialGetNextIrp, 0x00000008);
	}
	else
	{
		#line 1066
		if(extension->CountOnLastRead == (LONG )(- 3))
		{
			#line 1075
			SerialTryToCompleteCurrent(extension,
				SerialGrabReadFromIsr, oldIrql, (NTSTATUS
				)0x00000000L, & extension->CurrentReadIrp, &
				extension->ReadQueue, &
				extension->ReadRequestIntervalTimer, &
				extension->ReadRequestTotalTimer,
				SerialStartRead, SerialGetNextIrp, 0x00000008);
		}
		else
		{
			#line 1089
			if(extension->CountOnLastRead == (LONG )(- 1))
			{
				#line 1098
				SerialTryToCompleteCurrent(extension,
					SerialGrabReadFromIsr, oldIrql,
					(NTSTATUS )0xC0000120L, &
					extension->CurrentReadIrp, &
					extension->ReadQueue, &
					extension->ReadRequestIntervalTimer, &
					extension->ReadRequestTotalTimer,
					SerialStartRead, SerialGetNextIrp,
					0x00000008);
			}
			else
			{
				#line 1112
				if(extension->CountOnLastRead ||
					extension->ReadByIsr)
				{
					#line 1121
					if(extension->ReadByIsr)
					{
						KeSynchronizeExecution(extension
							->Interrupt,
							SerialUpdateReadByIsr,
							extension);
						#line 1137
						KeQuerySystemTime(&
							extension->LastReadTime)
							;
						#line 1141
						SerialSetTimer(&
							extension->ReadRequestIntervalTimer,
							*
							extension->IntervalTimeToUse,
							&
							extension->IntervalReadTimeoutDpc,
							extension);
						IoReleaseCancelSpinLock(oldIrql)
							;
					}
					else
					{
						#line 1165
						LARGE_INTEGER currentTime ;
						#line 1167
						KeQuerySystemTime(&
							currentTime);
						#line 1171
						if(currentTime.QuadPart -
							(extension->LastReadTime
							).QuadPart >=
							(extension->IntervalTime)
							.QuadPart)
						{
							#line 1174
							SerialTryToCompleteCurrent
								(extension,
								SerialGrabReadFromIsr,
								oldIrql,
								(NTSTATUS
								)0x00000102L, &
								extension->CurrentReadIrp
								, &
								extension->ReadQueue,
								&
								extension->ReadRequestIntervalTimer,
								&
								extension->ReadRequestTotalTimer,
								SerialStartRead,
								SerialGetNextIrp
								, 0x00000008);
						}
						else
						{
							#line 1190
							SerialSetTimer(&
								extension->ReadRequestIntervalTimer
								, *
								extension->IntervalTimeToUse,
								&
								extension->IntervalReadTimeoutDpc,
								extension);
							#line 1196
							IoReleaseCancelSpinLock(
								oldIrql);
						}
					}
				}
				else
				{
					#line 1210
					SerialSetTimer(&
						extension->ReadRequestIntervalTimer,
						* extension->IntervalTimeToUse,
						&
						extension->IntervalReadTimeoutDpc,
						extension);
					#line 1217
					IoReleaseCancelSpinLock(oldIrql);
				}
			}
		}
	}
	#line 1221
	SerialDpcEpilogue(extension, Dpc);
}

#line 1225
ULONG SerialGetCharsFromIntBuffer(PSERIAL_DEVICE_EXTENSION Extension )
{
	#line 1261
	ULONG numberOfCharsToGet ;
	#line 1269
	ULONG firstTryNumberToGet ;
	#line 1271
	;
	#line 1279
	numberOfCharsToGet = Extension->CharsInInterruptBuffer;
	#line 1281
	if(numberOfCharsToGet > Extension->NumberNeededForRead)
	{
		numberOfCharsToGet = Extension->NumberNeededForRead;
	}
	#line 1287
	if(numberOfCharsToGet)
	{
		#line 1296
		firstTryNumberToGet = (ULONG )(Extension->LastCharSlot -
			Extension->FirstReadableChar) + 1;
		#line 1299
		if(firstTryNumberToGet > numberOfCharsToGet)
		{
			#line 1316
			memmove((PUCHAR
				)((Extension->CurrentReadIrp)->AssociatedIrp).SystemBuffer
				+
				(((((((Extension->CurrentReadIrp)->Tail).Overlay)
				.CurrentStackLocation)->Parameters).Read).Length
				- Extension->NumberNeededForRead),
				Extension->FirstReadableChar,
				numberOfCharsToGet);
			#line 1318
			Extension->NumberNeededForRead -= numberOfCharsToGet;
			#line 1331
			if(Extension->FirstReadableChar + (numberOfCharsToGet -
				1) == Extension->LastCharSlot)
			{
				Extension->FirstReadableChar =
					Extension->InterruptReadBuffer;
			}
			else
			{
				#line 1338
				Extension->FirstReadableChar +=
					numberOfCharsToGet;
			}
		}
		else
		{
			#line 1357
			memmove((PUCHAR
				)((Extension->CurrentReadIrp)->AssociatedIrp).SystemBuffer
				+
				(((((((Extension->CurrentReadIrp)->Tail).Overlay)
				.CurrentStackLocation)->Parameters).Read).Length
				- Extension->NumberNeededForRead),
				Extension->FirstReadableChar,
				firstTryNumberToGet);
			#line 1359
			Extension->NumberNeededForRead -= firstTryNumberToGet;
			#line 1375
			memmove((PUCHAR
				)((Extension->CurrentReadIrp)->AssociatedIrp).SystemBuffer
				+
				(((((((Extension->CurrentReadIrp)->Tail).Overlay)
				.CurrentStackLocation)->Parameters).Read).Length
				- Extension->NumberNeededForRead),
				Extension->InterruptReadBuffer,
				numberOfCharsToGet - firstTryNumberToGet);
			#line 1377
			Extension->FirstReadableChar =
				Extension->InterruptReadBuffer +
				(numberOfCharsToGet - firstTryNumberToGet);
			#line 1381
			Extension->NumberNeededForRead -= numberOfCharsToGet -
				firstTryNumberToGet;
		}
	}
	#line 1388
	((Extension->CurrentReadIrp)->IoStatus).Information +=
		numberOfCharsToGet;
	#line 1389
	return numberOfCharsToGet;
}

#line 1393
BOOLEAN SerialUpdateInterruptBuffer(PVOID Context )
{
	#line 1425
	PSERIAL_UPDATE_CHAR update = Context;
	PSERIAL_DEVICE_EXTENSION extension = update->Extension;
	#line 1428
	;
	#line 1430
	;
	extension->CharsInInterruptBuffer -= update->CharsCopied;
	#line 1437
	SerialHandleReducedIntBuffer(extension);
	#line 1440
	return 0;
}

#line 1444
BOOLEAN SerialUpdateAndSwitchToUser(PVOID Context )
{
	#line 1480
	PSERIAL_UPDATE_CHAR updateChar = Context;
	PSERIAL_DEVICE_EXTENSION extension = updateChar->Extension;
	#line 1483
	;
	#line 1485
	SerialUpdateInterruptBuffer(Context);
	#line 1493
	updateChar->CharsCopied = SerialGetCharsFromIntBuffer(extension);
	#line 1495
	SerialUpdateInterruptBuffer(Context);
	#line 1504
	if(extension->NumberNeededForRead)
	{
		#line 1511
		;
		#line 1536
		extension->CountOnLastRead = (LONG
			)((extension->CurrentReadIrp)->IoStatus).Information;
		#line 1539
		extension->ReadByIsr = 0;
		#line 1548
		extension->ReadBufferBase =
			((extension->CurrentReadIrp)->AssociatedIrp).SystemBuffer
			;
		#line 1557
		extension->CurrentCharSlot = extension->ReadBufferBase +
			((extension->CurrentReadIrp)->IoStatus).Information;
		#line 1567
		extension->LastCharSlot = extension->ReadBufferBase +
			(((((((extension->CurrentReadIrp)->Tail).Overlay).CurrentStackLocation
			)->Parameters).Read).Length - 1);
		#line 1580
		(PDRIVER_CANCEL )((PVOID )InterlockedExchange((PLONG )((PVOID * 
			)(& (extension->CurrentReadIrp)->CancelRoutine)), (LONG
			)((PVOID )SerialCancelCurrentRead)));
		#line 1593
		do
		{
			#line 1593
			LONG _refType = 0x00000001;
			#line 1593
			PULONG_PTR _arg4 = (PVOID )(&
				((((((extension->CurrentReadIrp)->Tail).Overlay)
				.CurrentStackLocation)->Parameters).Others).Argument4
				);
			#line 1593
			;
			#line 1593
			* _arg4 |= _refType;
		}
		while(0);
		#line 1597
		do
		{
			#line 1597
			LONG _refType = 0x00000002;
			#line 1597
			PULONG_PTR _arg4 = (PVOID )(&
				((((((extension->CurrentReadIrp)->Tail).Overlay)
				.CurrentStackLocation)->Parameters).Others).Argument4
				);
			#line 1597
			;
			#line 1597
			* _arg4 |= _refType;
		}
		while(0);
		#line 1599
		updateChar->Completed = 0;
	}
	else
	{
		updateChar->Completed = 1;
	}
	#line 1607
	return 0;
}

#line 1614
typedef struct _SERIAL_RESIZE_PARAMS {
	PSERIAL_DEVICE_EXTENSION Extension ;
	PUCHAR OldBuffer ;
	PUCHAR NewBuffer ;
	ULONG NewBufferSize ;
	ULONG NumberMoved ;
} SERIAL_RESIZE_PARAMS , *  PSERIAL_RESIZE_PARAMS ;

NTSTATUS SerialResizeBuffer(PSERIAL_DEVICE_EXTENSION Extension )
{
	#line 1654
	PSERIAL_QUEUE_SIZE rs
		= ((Extension->CurrentReadIrp)->AssociatedIrp).SystemBuffer;
	PIO_STACK_LOCATION irpSp
		= (((Extension->CurrentReadIrp)->Tail).Overlay).CurrentStackLocation;
	#line 1659
	PVOID newBuffer
		= ((irpSp->Parameters).DeviceIoControl).Type3InputBuffer;
	;
	#line 1663
	((irpSp->Parameters).DeviceIoControl).Type3InputBuffer = (void *  )0;
	((Extension->CurrentReadIrp)->IoStatus).Information = 0L;
	((Extension->CurrentReadIrp)->IoStatus).Status = (NTSTATUS )0x00000000L;
	#line 1667
	if(rs->InSize <= Extension->BufferSize)
	{
		#line 1675
		ExFreePool(newBuffer);
	}
	else
	{
		SERIAL_RESIZE_PARAMS rp ;
		KIRQL controlIrql ;
		#line 1713
		rp.Extension = Extension;
		rp.OldBuffer = Extension->InterruptReadBuffer;
		rp.NewBuffer = newBuffer;
		rp.NewBufferSize = rs->InSize;
		#line 1721
		* & controlIrql = KfAcquireSpinLock(& Extension->ControlLock);
		#line 1723
		rp.NumberMoved = SerialMoveToNewIntBuffer(Extension, newBuffer);
		#line 1728
		KeSynchronizeExecution(Extension->Interrupt,
			SerialUpdateAndSwitchToNew, & rp);
		#line 1737
		KfReleaseSpinLock(& Extension->ControlLock, controlIrql);
		#line 1743
		ExFreePool(rp.OldBuffer);
	}
	#line 1747
	return (NTSTATUS )0x00000000L;
}

#line 1751
ULONG SerialMoveToNewIntBuffer(PSERIAL_DEVICE_EXTENSION Extension , PUCHAR
	NewBuffer )
{
	#line 1783
	ULONG numberOfCharsMoved = Extension->CharsInInterruptBuffer;
	;
	#line 1786
	if(numberOfCharsMoved)
	{
		#line 1794
		ULONG firstTryNumberToGet = (ULONG )(Extension->LastCharSlot -
			Extension->FirstReadableChar) + 1;
		#line 1797
		if(firstTryNumberToGet >= numberOfCharsMoved)
		{
			#line 1807
			memmove(NewBuffer, Extension->FirstReadableChar,
				numberOfCharsMoved);
			if(Extension->FirstReadableChar + (numberOfCharsMoved -
				1) == Extension->LastCharSlot)
			{
				Extension->FirstReadableChar =
					Extension->InterruptReadBuffer;
			}
			else
			{
				#line 1816
				Extension->FirstReadableChar +=
					numberOfCharsMoved;
			}
		}
		else
		{
			#line 1830
			memmove(NewBuffer, Extension->FirstReadableChar,
				firstTryNumberToGet);
			#line 1841
			memmove(NewBuffer + firstTryNumberToGet,
				Extension->InterruptReadBuffer,
				numberOfCharsMoved - firstTryNumberToGet);
			#line 1843
			Extension->FirstReadableChar =
				Extension->InterruptReadBuffer +
				numberOfCharsMoved - firstTryNumberToGet;
		}
	}
	#line 1850
	return numberOfCharsMoved;
}

#line 1854
BOOLEAN SerialUpdateAndSwitchToNew(PVOID Context )
{
	#line 1885
	PSERIAL_RESIZE_PARAMS params = Context;
	PSERIAL_DEVICE_EXTENSION extension = params->Extension;
	ULONG tempCharsInInterruptBuffer = extension->CharsInInterruptBuffer;
	#line 1889
	;
	#line 1891
	;
	#line 1899
	extension->CharsInInterruptBuffer -= params->NumberMoved;
	#line 1901
	if(extension->CharsInInterruptBuffer)
	{
		SerialMoveToNewIntBuffer(extension, params->NewBuffer +
			params->NumberMoved);
	}
	#line 1910
	extension->CharsInInterruptBuffer = tempCharsInInterruptBuffer;
	#line 1913
	extension->LastCharSlot = params->NewBuffer + (params->NewBufferSize -
		1);
	#line 1914
	extension->FirstReadableChar = params->NewBuffer;
	extension->ReadBufferBase = params->NewBuffer;
	extension->InterruptReadBuffer = params->NewBuffer;
	extension->BufferSize = params->NewBufferSize;
	#line 1924
	extension->CurrentCharSlot = extension->InterruptReadBuffer +
		extension->CharsInInterruptBuffer;
	#line 1931
	(extension->HandFlow).XoffLimit = extension->BufferSize >> 3;
	(extension->HandFlow).XonLimit = extension->BufferSize >> 1;
	#line 1934
	(extension->WmiCommData).XoffXmitThreshold =
		(extension->HandFlow).XoffLimit;
	#line 1935
	(extension->WmiCommData).XonXmitThreshold =
		(extension->HandFlow).XonLimit;
	extension->BufferSizePt8 = 3 * (extension->BufferSize >> 2) +
		(extension->BufferSize >> 4);
	#line 1945
	SerialHandleReducedIntBuffer(extension);
	#line 1947
	return 0;
}

#line 16 "C:/NTDDK/inc/stddef.h"

#pragma once
#line 77
typedef int ;

#line 86
typedef unsigned int ;

#line 95
typedef int ;

#line 105
typedef unsigned int ;

#line 112
typedef unsigned short ;

#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"

#pragma once
#line 32

#pragma pack(push, 8)
#line 72
typedef enum _EXCEPTION_DISPOSITION ;

#line 89
struct _EXCEPTION_RECORD ;

#line 90
struct _CONTEXT ;

#line 155

#pragma pack(pop)
#line 25 "C:/NTDDK/inc/ntdef.h"

#pragma once
#line 15 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"

#pragma once
#line 66
typedef wchar_t ;

#line 67
typedef wchar_t ;

#line 127 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long ;

#line 25 "C:/NTDDK/inc/basetsd.h"

#pragma once
#line 36
typedef int ;

#line 37
typedef int ;

#line 43
typedef unsigned int ;

#line 44
typedef unsigned int ;

#line 45
typedef unsigned int ;

#line 84
typedef int ;

#line 85
typedef unsigned int ;

typedef long ;

#line 88
typedef unsigned long ;

#line 248
typedef unsigned short ;

#line 249
typedef short ;

#line 250
typedef unsigned long ;

#line 288
typedef ULONG_PTR ;

#line 289
typedef LONG_PTR ;

#line 295
typedef ULONG_PTR ;

#line 301
typedef __int64 ;

#line 302
typedef __int64 ;

#line 309
typedef unsigned __int64 ;

#line 310
typedef unsigned __int64 ;

#line 311
typedef unsigned __int64 ;

#line 217 "C:/NTDDK/inc/ntdef.h"
typedef void ;

#line 218
typedef void ;

#line 266
typedef char ;

#line 267
typedef short ;

#line 268
typedef long ;

#line 276
typedef wchar_t ;

#line 282
typedef WCHAR ;

#line 283
typedef WCHAR ;

#line 284
typedef const WCHAR ;

#line 285
typedef WCHAR ;

#line 286
typedef WCHAR ;

typedef const WCHAR ;

#line 293
typedef CHAR ;

#line 294
typedef CHAR ;

typedef const CHAR ;

#line 297
typedef CHAR ;

#line 298
typedef CHAR ;

#line 299
typedef const CHAR ;

#line 321
typedef char ;

#line 322
typedef unsigned char ;

#line 326
typedef LPSTR ;

#line 327
typedef LPSTR ;

#line 328
typedef LPCSTR ;

#line 337
typedef double ;

typedef struct _QUAD ;

#line 349
typedef SHORT ;

#line 350
typedef LONG ;

#line 351
typedef QUAD ;

#line 360
typedef unsigned char ;

#line 361
typedef unsigned short ;

#line 362
typedef unsigned long ;

#line 363
typedef QUAD ;

#line 369
typedef UCHAR ;

#line 370
typedef USHORT ;

#line 371
typedef ULONG ;

#line 372
typedef UQUAD ;

#line 378
typedef signed char ;

#line 379
typedef SCHAR ;

#line 394
typedef void ;

#line 400
typedef HANDLE ;

#line 406
typedef UCHAR ;

#line 407
typedef USHORT ;

#line 408
typedef ULONG ;

#line 414
typedef LONG ;

#line 478
typedef char ;

#line 479
typedef short ;

#line 480
typedef ULONG ;

typedef CCHAR ;

#line 483
typedef CSHORT ;

#line 484
typedef CLONG ;

#line 492
typedef ULONG ;

#line 493
typedef PULONG ;

#line 494
typedef USHORT ;

#line 500
typedef ULONG ;

#line 501
typedef ULONG ;

#line 508
typedef LONG ;

typedef NTSTATUS ;

#line 602
typedef struct _FLOAT128 ;

#line 607
typedef FLOAT128 ;

#line 621
typedef __int64 ;

#line 622
typedef unsigned __int64 ;

#line 639
typedef LONGLONG ;

#line 640
typedef ULONGLONG ;

#line 644
typedef LONGLONG ;

#line 649
typedef union _LARGE_INTEGER ;

#line 662
typedef LARGE_INTEGER ;

#line 668
typedef union _ULARGE_INTEGER ;

#line 681
typedef ULARGE_INTEGER ;

#line 690
typedef struct _LUID ;

#line 696
typedef ULONGLONG ;

#line 697
typedef DWORDLONG ;

#line 707
typedef LARGE_INTEGER ;

#line 831

#pragma warning(push)

#pragma warning(disable:4035)
__inline ULONGLONG __stdcall Int64ShllMod32___11(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 842
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    
		};
}

#line 845
__inline LONGLONG __stdcall Int64ShraMod32___11(LONGLONG Value , ULONG
	ShiftCount )
{
	#line 852
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    
		};
}

#line 855
__inline ULONGLONG __stdcall Int64ShrlMod32___11(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 862
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    
		};
}


#pragma warning(pop)
#line 956
typedef enum _EVENT_TYPE ;

#line 965
typedef enum _TIMER_TYPE ;

#line 974
typedef enum _WAIT_TYPE ;

#line 983
typedef CHAR ;

#line 984
typedef const char ;

#line 991
typedef struct _STRING ;

#line 999
typedef STRING ;

typedef STRING ;

#line 1002
typedef PSTRING ;

typedef STRING ;

#line 1005
typedef PSTRING ;

#line 1011
typedef struct _CSTRING ;

#line 1016
typedef CSTRING ;

#line 1019
typedef STRING ;

#line 1020
typedef PSTRING ;

#line 1027
typedef struct _UNICODE_STRING ;

#line 1036
typedef UNICODE_STRING ;

#line 1037
typedef const UNICODE_STRING ;

#line 1046
typedef UCHAR ;

#line 1047
typedef BOOLEAN ;

#line 1057
typedef struct _LIST_ENTRY ;

#line 1067
typedef struct _SINGLE_LIST_ENTRY ;

#line 1078
typedef struct LIST_ENTRY32 ;

#line 1082
typedef LIST_ENTRY32 ;

typedef struct LIST_ENTRY64 ;

#line 1088
typedef LIST_ENTRY64 ;

#line 1127
typedef struct _STRING32 ;

#line 1132
typedef STRING32 ;

typedef STRING32 ;

#line 1135
typedef UNICODE_STRING32 ;

typedef STRING32 ;

#line 1138
typedef ANSI_STRING32 ;

#line 1141
typedef struct _STRING64 ;

#line 1146
typedef STRING64 ;

typedef STRING64 ;

#line 1149
typedef UNICODE_STRING64 ;

typedef STRING64 ;

#line 1152
typedef ANSI_STRING64 ;

#line 1173
typedef struct _OBJECT_ATTRIBUTES ;

#line 1181
typedef OBJECT_ATTRIBUTES ;

#line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID ;

#line 70
typedef GUID ;

#line 75
typedef const GUID ;

#line 81
typedef GUID ;

#line 82
typedef IID ;

#line 85
typedef GUID ;

#line 86
typedef CLSID ;

#line 89
typedef GUID ;

#line 90
typedef FMTID ;

#line 16 "C:/NTDDK/inc/string.h"

#pragma once
#line 1233 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECTID ;

#line 1288
struct _CONTEXT ;

#line 1289
struct _EXCEPTION_RECORD ;

typedef EXCEPTION_DISPOSITION ;

#line 1306
typedef UCHAR ;

typedef KIRQL ;

#line 1316
typedef enum _NT_PRODUCT_TYPE ;

#line 1329
typedef enum _SUITE_TYPE ;

#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD ;

#line 76
typedef struct _ETHREAD ;

#line 77
typedef struct _EPROCESS ;

#line 78
typedef struct _PEB ;

#line 79
typedef struct _KINTERRUPT ;

#line 80
typedef struct _IO_TIMER ;

#line 81
typedef struct _OBJECT_TYPE ;

#line 82
typedef struct _CALLBACK_OBJECT ;

#line 83
typedef struct _DEVICE_HANDLER_OBJECT ;

#line 84
typedef struct _BUS_HANDLER ;

#line 143
typedef union _SLIST_HEADER ;

#line 204
typedef CCHAR ;

typedef enum _MODE ;

#line 222
struct _KAPC ;

typedef void ;

#line 232
typedef void ;

#line 242
typedef void ;

#line 248
typedef BOOLEAN ;

#line 254
typedef BOOLEAN ;

#line 265
typedef struct _KAPC ;

#line 292
struct _KDPC ;

typedef void ;

#line 351
typedef enum _KDPC_IMPORTANCE ;

#line 361
typedef struct _KDPC ;

#line 377
typedef PVOID ;

typedef void ;

#line 392
typedef struct _KIPI_COUNTS ;

#line 443
typedef struct _MDL ;

#line 532
typedef PVOID ;

#line 538
typedef PVOID ;

#line 544
typedef PVOID ;

typedef ULONG ;

#line 547
typedef ACCESS_MASK ;

#line 597
typedef struct _GENERIC_MAPPING ;

#line 603
typedef GENERIC_MAPPING ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES ;

#line 622
typedef LUID_AND_ATTRIBUTES ;

#line 623
typedef LUID_AND_ATTRIBUTES_ARRAY ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 642 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACL ;

#line 649
typedef ACL ;

#line 681
typedef struct _PRIVILEGE_SET ;

#line 735
typedef enum _SECURITY_IMPERSONATION_LEVEL ;

#line 753
typedef BOOLEAN ;

#line 762
typedef struct _SECURITY_QUALITY_OF_SERVICE ;

#line 774
typedef struct _SE_IMPERSONATION_STATE ;

#line 782
typedef ULONG ;

#line 809
typedef ULONG ;

#line 810
typedef KAFFINITY ;

#line 816
typedef LONG ;

#line 824
typedef ULONG_PTR ;

#line 825
typedef KSPIN_LOCK ;

#line 833
typedef void ;

#line 842
typedef enum _KPROFILE_SOURCE ;

#line 1079
typedef NTSTATUS ;

#line 1088
typedef struct _RTL_QUERY_REGISTRY_TABLE ;

#line 1952

#pragma warning(push)

#pragma warning(disable:4035)
#line 2019

#pragma warning(pop)
#line 2214
typedef struct _TIME_FIELDS ;

#line 2224
typedef TIME_FIELDS ;

#line 2499
typedef struct _RTL_BITMAP ;

#line 2503
typedef RTL_BITMAP ;

#line 2627
typedef struct _RTL_BITMAP_RUN ;

#line 2633
typedef RTL_BITMAP_RUN ;

#line 2886
typedef struct _RTL_RANGE ;

#line 2924
typedef struct _RTL_RANGE_LIST ;

#line 2950
typedef struct _RANGE_LIST_ITERATOR ;

#line 3019
typedef BOOLEAN ;

#line 3155
typedef struct _OSVERSIONINFOA ;

#line 3164
typedef struct _OSVERSIONINFOW ;

#line 3177
typedef OSVERSIONINFOA ;

#line 3178
typedef POSVERSIONINFOA ;

#line 3179
typedef LPOSVERSIONINFOA ;

#line 3182
typedef struct _OSVERSIONINFOEXA ;

#line 3195
typedef struct _OSVERSIONINFOEXW ;

#line 3213
typedef OSVERSIONINFOEXA ;

#line 3214
typedef POSVERSIONINFOEXA ;

#line 3215
typedef LPOSVERSIONINFOEXA ;

#line 3648
typedef struct _IO_STATUS_BLOCK ;

#line 3669
typedef void ;

#line 3685
typedef enum _FILE_INFORMATION_CLASS ;

#line 3731
typedef struct _FILE_BASIC_INFORMATION ;

#line 3739
typedef struct _FILE_STANDARD_INFORMATION ;

#line 3747
typedef struct _FILE_POSITION_INFORMATION ;

#line 3751
typedef struct _FILE_ALIGNMENT_INFORMATION ;

#line 3755
typedef struct _FILE_NAME_INFORMATION ;

#line 3760
typedef struct _FILE_NETWORK_OPEN_INFORMATION ;

#line 3770
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION ;

#line 3775
typedef struct _FILE_DISPOSITION_INFORMATION ;

#line 3779
typedef struct _FILE_END_OF_FILE_INFORMATION ;

#line 3784
typedef struct _FILE_FULL_EA_INFORMATION ;

#line 3798
typedef enum _FSINFOCLASS ;

#line 3810
typedef struct _FILE_FS_DEVICE_INFORMATION ;

#line 3820
typedef union _FILE_SEGMENT_ELEMENT ;

#line 3829
typedef enum _INTERFACE_TYPE ;

#line 3854
typedef enum _DMA_WIDTH ;

#line 3865
typedef enum _DMA_SPEED ;

#line 3879
typedef void ;

#line 3880
typedef void ;

#line 3888
typedef enum _BUS_DATA_TYPE ;

#line 3910
typedef struct _IO_ERROR_LOG_PACKET ;

#line 3931
typedef struct _IO_ERROR_LOG_MESSAGE ;

#line 4074
typedef struct _KEY_BASIC_INFORMATION ;

#line 4081
typedef struct _KEY_NODE_INFORMATION ;

#line 4091
typedef struct _KEY_FULL_INFORMATION ;

#line 4106
typedef struct _KEY_NAME_INFORMATION ;

#line 4112
typedef enum _KEY_INFORMATION_CLASS ;

#line 4122
typedef struct _KEY_WRITE_TIME_INFORMATION ;

#line 4126
typedef enum _KEY_SET_INFORMATION_CLASS ;

#line 4134
typedef struct _KEY_VALUE_BASIC_INFORMATION ;

#line 4141
typedef struct _KEY_VALUE_FULL_INFORMATION ;

#line 4151
typedef struct _KEY_VALUE_PARTIAL_INFORMATION ;

#line 4158
typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ;

#line 4164
typedef struct _KEY_VALUE_ENTRY ;

#line 4171
typedef enum _KEY_VALUE_INFORMATION_CLASS ;

#line 4210
typedef struct _OBJECT_NAME_INFORMATION ;

#line 4221
typedef enum _SECTION_INHERIT ;

#line 4294
typedef struct _CLIENT_ID ;

#line 4298
typedef CLIENT_ID ;

#line 4315
typedef struct _NT_TIB ;

#line 4327
typedef NT_TIB ;

#line 4332
typedef enum _PROCESSINFOCLASS ;

#line 4366
typedef enum _THREADINFOCLASS ;

#line 4395
typedef struct _PROCESS_WS_WATCH_INFORMATION ;

#line 4405
typedef struct _PROCESS_BASIC_INFORMATION ;

#line 4413
typedef PROCESS_BASIC_INFORMATION ;

#line 4422
typedef struct _PROCESS_DEVICEMAP_INFORMATION ;

#line 4440
typedef struct _PROCESS_SESSION_INFORMATION ;

#line 4454
typedef struct _QUOTA_LIMITS ;

#line 4462
typedef QUOTA_LIMITS ;

#line 4472
typedef struct _IO_COUNTERS ;

#line 4480
typedef IO_COUNTERS ;

#line 4488
typedef struct _VM_COUNTERS ;

#line 4501
typedef VM_COUNTERS ;

#line 4508
typedef struct _POOLED_USAGE_AND_LIMITS ;

#line 4519
typedef POOLED_USAGE_AND_LIMITS ;

#line 4528
typedef struct _PROCESS_ACCESS_TOKEN ;

#line 4555
typedef struct _KERNEL_USER_TIMES ;

#line 4561
typedef KERNEL_USER_TIMES ;

#line 4587
typedef enum _SYSTEM_POWER_STATE ;

#line 4598
typedef enum  {
	PowerActionNone = 0,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
} ;

typedef enum _DEVICE_POWER_STATE ;

#line 4618
typedef union _POWER_STATE ;

#line 4623
typedef enum _POWER_STATE_TYPE ;

#line 4654
typedef ULONG ;

typedef enum  {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
} ;

#line 4663
typedef enum  {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation
} ;

#line 4690
typedef ULONG ;

typedef LONG ;

#line 4693
typedef ULONG ;

#line 4719
typedef union _MCI_STATS ;

#line 4978
typedef struct _KPCR ;

#line 5006
typedef KPCR ;

#line 5012
typedef struct _KFLOATING_SAVE ;

#line 5153
typedef enum _INTERLOCKED_RESULT ;

#line 5252

#pragma warning(disable:4035)
#line 6994
typedef struct _KSYSTEM_TIME ;

#line 7014

#pragma warning(push)

#pragma warning(disable:4164)
#line 7019

#pragma function(_enable)
#line 7020

#pragma function(_disable)
#line 7024

#pragma warning(pop)
#line 7085
typedef struct _FLOATING_SAVE_AREA ;

#line 7097
typedef FLOATING_SAVE_AREA ;

#line 7109
typedef struct _CONTEXT ;

#line 7197
typedef CONTEXT ;

#line 7826
typedef void ;

#line 7850
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ;

#line 7899
typedef struct _KUSER_SHARED_DATA ;

#line 8123
typedef enum _CM_SERVICE_NODE_TYPE ;

#line 8132
typedef enum _CM_SERVICE_LOAD_TYPE ;

#line 8140
typedef enum _CM_ERROR_CONTROL_TYPE ;

#line 8172
typedef int ;

#line 8198
typedef enum _CM_SHARE_DISPOSITION ;

#line 8211
typedef PVOID ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST ;

#line 8443
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR ;

#line 8454
typedef struct _CM_RESOURCE_LIST ;

#line 8471
typedef struct _DEVICE_FLAGS ;

#line 8485
typedef struct _CM_COMPONENT_INFORMATION ;

#line 8503
typedef struct _CM_ROM_BLOCK ;

#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 8518 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_INT13_DRIVE_PARAMETER ;

#line 8532
typedef struct _CM_MCA_POS_DATA ;

#line 8544
typedef struct _EISA_MEMORY_TYPE ;

#line 8554
typedef struct _EISA_MEMORY_CONFIGURATION ;

#line 8567
typedef struct _EISA_IRQ_DESCRIPTOR ;

#line 8575
typedef struct _EISA_IRQ_CONFIGURATION ;

#line 8585
typedef struct _DMA_CONFIGURATION_BYTE0 ;

#line 8592
typedef struct _DMA_CONFIGURATION_BYTE1 ;

#line 8599
typedef struct _EISA_DMA_CONFIGURATION ;

#line 8609
typedef struct _EISA_PORT_DESCRIPTOR ;

#line 8616
typedef struct _EISA_PORT_CONFIGURATION ;

#line 8628
typedef struct _CM_EISA_SLOT_INFORMATION ;

#line 8644
typedef struct _CM_EISA_FUNCTION_INFORMATION ;

#line 8678
typedef struct _CM_PNP_BIOS_DEVICE_NODE ;

#line 8692
typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8761 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_SCSI_DEVICE_DATA ;

#line 8775
typedef struct _CM_VIDEO_DEVICE_DATA ;

#line 8785
typedef struct _CM_SONIC_DEVICE_DATA ;

#line 8796
typedef struct _CM_SERIAL_DEVICE_DATA ;

#line 8810
typedef struct _CM_MONITOR_DEVICE_DATA ;

#line 8844
typedef struct _CM_FLOPPY_DEVICE_DATA ;

#line 8881
typedef struct _CM_KEYBOARD_DEVICE_DATA ;

#line 8893
typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA ;

#line 8905
typedef struct _CM_PCCARD_DEVICE_DATA ;

#line 8944
typedef struct _IO_RESOURCE_DESCRIPTOR ;

#line 9027
typedef struct _IO_RESOURCE_LIST ;

#line 9036
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST ;

#line 9065
typedef struct _EXCEPTION_RECORD ;

#line 9074
typedef EXCEPTION_RECORD ;

typedef struct _EXCEPTION_RECORD32 ;

#line 9085
typedef struct _EXCEPTION_RECORD64 ;

#line 9099
typedef struct _EXCEPTION_POINTERS ;

#line 9111
typedef enum _CONFIGURATION_TYPE ;

#line 9161
typedef enum _KINTERRUPT_MODE ;

#line 9170
typedef enum _KWAIT_REASON ;

#line 9207
typedef struct _DISPATCHER_HEADER ;

#line 9217
typedef struct _KWAIT_BLOCK ;

#line 9230
typedef void ;

#line 9244
typedef struct _KDEVICE_QUEUE ;

#line 9252
typedef struct _KDEVICE_QUEUE_ENTRY ;

#line 9263
typedef struct _KEVENT ;

#line 9271
typedef BOOLEAN ;

#line 9281
typedef struct _KMUTANT ;

#line 9294
typedef struct _KSEMAPHORE ;

#line 9304
typedef struct _KTIMER ;

#line 9899
typedef enum _KBUGCHECK_BUFFER_DUMP_STATE ;

#line 9907
typedef void ;

#line 9914
typedef struct _KBUGCHECK_CALLBACK_RECORD ;

#line 10002
typedef void ;

#line 10020
typedef LOGICAL ;

#line 10037
typedef void ;

#line 10053
typedef enum _MEMORY_CACHING_TYPE_ORIG ;

#line 10057
typedef enum _MEMORY_CACHING_TYPE ;

#line 10087
typedef struct _DBGKD_DEBUG_DATA_HEADER64 ;

#line 10115
typedef enum _POOL_TYPE ;

#line 10195
typedef enum _EX_POOL_PRIORITY ;

#line 10247
typedef struct _FAST_MUTEX ;

#line 10574
typedef PVOID ;

#line 10582
typedef void ;

#line 10588
typedef struct _GENERAL_LOOKASIDE ;

#line 10619
typedef struct _NPAGED_LOOKASIDE_LIST ;

#line 10729
typedef struct _PAGED_LOOKASIDE_LIST ;

#line 10882
typedef enum _WORK_QUEUE_TYPE ;

#line 10889
typedef void ;

#line 10895
typedef struct _WORK_QUEUE_ITEM ;

#line 10926
typedef struct _ZONE_SEGMENT_HEADER ;

#line 10931
typedef struct _ZONE_HEADER ;

#line 11156
typedef ULONG_PTR ;

#line 11157
typedef ERESOURCE_THREAD ;

typedef struct _OWNER_ENTRY ;

#line 11168
typedef struct _ERESOURCE ;

#line 11197
typedef struct _RESOURCE_HASH_ENTRY ;

#line 11204
typedef struct _RESOURCE_PERFORMANCE_DATA ;

#line 11429
typedef struct _CALLBACK_OBJECT ;

typedef void ;

#line 11474
typedef GUID ;

#line 11862
typedef enum _MM_SYSTEM_SIZE ;

#line 11884
typedef enum _LOCK_OPERATION ;

#line 11970
typedef enum _MM_PAGE_PRIORITY ;

#line 11999
typedef struct _PHYSICAL_MEMORY_RANGE ;

#line 12385
typedef NTSTATUS ;

#line 12389
typedef NTSTATUS ;

#line 12399
struct _DRIVER_OBJECT ;

#line 12411
typedef enum _SECURITY_OPERATION_CODE ;

#line 12426
typedef struct _SECURITY_SUBJECT_CONTEXT ;

#line 12448
typedef struct _INITIAL_PRIVILEGE_SET ;

#line 12462
typedef struct _ACCESS_STATE ;

#line 12571
typedef void ;

#line 12585
typedef void ;

#line 12602
typedef struct _IMAGE_INFO ;

#line 12620
typedef void ;

#line 12859
typedef NTSTATUS ;

#line 12878
typedef enum _IO_QUERY_DEVICE_DATA_FORMAT ;

#line 12890
typedef enum _CREATE_FILE_TYPE ;

#line 12905
struct _DEVICE_DESCRIPTION ;

#line 12906
struct _DEVICE_OBJECT ;

#line 12907
struct _DMA_ADAPTER ;

#line 12908
struct _DRIVER_OBJECT ;

#line 12909
struct _DRIVE_LAYOUT_INFORMATION ;

#line 12910
struct _DISK_PARTITION ;

#line 12911
struct _FILE_OBJECT ;

#line 12912
struct _IRP ;

#line 12913
struct _SCSI_REQUEST_BLOCK ;

#line 12919
typedef void ;

#line 12932
typedef void ;

#line 12943
typedef NTSTATUS ;

#line 12955
typedef void ;

#line 12968
typedef void ;

#line 12979
typedef NTSTATUS ;

#line 12990
typedef void ;

#line 13001
typedef void ;

#line 13011
typedef NTSTATUS ;

#line 13025
typedef BOOLEAN ;

#line 13038
typedef BOOLEAN ;

#line 13051
typedef BOOLEAN ;

#line 13068
typedef BOOLEAN ;

#line 13078
typedef BOOLEAN ;

#line 13092
typedef BOOLEAN ;

#line 13106
typedef BOOLEAN ;

#line 13118
typedef BOOLEAN ;

#line 13127
typedef BOOLEAN ;

#line 13141
typedef BOOLEAN ;

#line 13161
typedef void ;

#line 13167
typedef void ;

#line 13179
typedef void ;

#line 13193
typedef BOOLEAN ;

#line 13207
typedef BOOLEAN ;

#line 13219
typedef BOOLEAN ;

#line 13227
typedef BOOLEAN ;

#line 13239
typedef BOOLEAN ;

#line 13253
typedef NTSTATUS ;

#line 13262
typedef NTSTATUS ;

#line 13275
typedef NTSTATUS ;

#line 13282
typedef NTSTATUS ;

#line 13289
typedef BOOLEAN ;

#line 13304
typedef BOOLEAN ;

#line 13319
typedef BOOLEAN ;

#line 13327
typedef BOOLEAN ;

#line 13336
typedef BOOLEAN ;

#line 13350
typedef struct _FAST_IO_DISPATCH ;

#line 13386
typedef enum _IO_ALLOCATION_ACTION ;

#line 13396
typedef IO_ALLOCATION_ACTION ;

#line 13410
typedef struct _IO_SECURITY_CONTEXT ;

#line 13434
typedef struct _VPB ;

#line 13482
typedef struct _ADAPTER_OBJECT ;

#line 13491
typedef struct _WAIT_CONTEXT_BLOCK ;

#line 13503
typedef struct _CONTROLLER_OBJECT ;

#line 13537
typedef struct _DEVICE_OBJECT ;

#line 13575
typedef struct _DEVICE_OBJECT ;

#line 13578
struct _DEVICE_OBJECT_POWER_EXTENSION ;

typedef struct _DEVOBJ_EXTENSION ;

#line 13608
typedef struct _DRIVER_EXTENSION ;

#line 13645
typedef struct _DRIVER_OBJECT ;

#line 13706
typedef struct _DRIVER_OBJECT ;

#line 13715
typedef struct _SECTION_OBJECT_POINTERS ;

#line 13720
typedef SECTION_OBJECT_POINTERS ;

#line 13726
typedef struct _IO_COMPLETION_CONTEXT ;

#line 13759
typedef struct _FILE_OBJECT ;

#line 13788
typedef struct _FILE_OBJECT ;

#line 13828
typedef struct _IRP ;

#line 14078
typedef NTSTATUS ;

#line 14163
typedef enum _DEVICE_RELATION_TYPE ;

#line 14171
typedef struct _DEVICE_RELATIONS ;

#line 14176
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE ;

#line 14185
typedef struct _INTERFACE ;

#line 14196
typedef struct _DEVICE_CAPABILITIES ;

#line 14229
typedef struct _POWER_SEQUENCE ;

#line 14235
typedef enum  {
	BusQueryDeviceID = 0,
	BusQueryHardwareIDs = 1,
	BusQueryCompatibleIDs = 2,
	BusQueryInstanceID = 3,
	BusQueryDeviceSerialNumber = 4
} ;

typedef ULONG ;

#line 14252
typedef enum  {
	DeviceTextDescription = 0,
	DeviceTextLocationInformation = 1
} ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 14615 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SHARE_ACCESS ;

#line 14635
typedef struct _CONFIGURATION_INFORMATION ;

#line 14848
typedef struct _BOOTDISK_INFORMATION ;

#line 15754
typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK ;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK ;

#line 15764
typedef struct _IO_REMOVE_LOCK_DBG_BLOCK ;

#line 15777
typedef struct _IO_REMOVE_LOCK ;

#line 16009
typedef struct _IO_WORKITEM ;

typedef void ;

#line 16100
typedef enum  {
	DevicePropertyDeviceDescription,
	DevicePropertyHardwareID,
	DevicePropertyCompatibleIDs,
	DevicePropertyBootConfiguration,
	DevicePropertyBootConfigurationTranslated,
	DevicePropertyClassName,
	DevicePropertyClassGuid,
	DevicePropertyDriverKeyName,
	DevicePropertyManufacturer,
	DevicePropertyFriendlyName,
	DevicePropertyLocationInformation,
	DevicePropertyPhysicalDeviceObjectName,
	DevicePropertyBusTypeGuid,
	DevicePropertyLegacyBusType,
	DevicePropertyBusNumber,
	DevicePropertyEnumeratorName,
	DevicePropertyAddress,
	DevicePropertyUINumber
} ;

typedef BOOLEAN ;

#line 16129
typedef struct _DMA_ADAPTER ;

#line 16135
typedef ULONG ;

#line 16148
typedef struct _PNP_BUS_INFORMATION ;

#line 16162
typedef struct _LEGACY_BUS_INFORMATION ;

#line 16168
typedef struct _BUS_INTERFACE_STANDARD ;

#line 16190
typedef BOOLEAN ;

#line 16194
typedef NTSTATUS ;

#line 16203
typedef NTSTATUS ;

#line 16206
typedef NTSTATUS ;

#line 16210
typedef NTSTATUS ;

#line 16214
typedef NTSTATUS ;

#line 16218
typedef void ;

#line 16222
typedef NTSTATUS ;

#line 16227
typedef void ;

#line 16231
typedef struct _ACPI_INTERFACE_STANDARD ;

#line 16255
typedef enum _ACPI_REG_TYPE ;

#line 16268
typedef USHORT ;

#line 16272
typedef void ;

#line 16278
typedef struct ACPI_REGS_INTERFACE_STANDARD ;

#line 16300
typedef struct  {
	PVOID LinkNode ;
	ULONG StaticVector ;
	UCHAR Flags ;
} ;

#line 16314
typedef NTSTATUS ;

#line 16329
typedef NTSTATUS ;

#line 16336
typedef void ;

#line 16343
typedef struct _INT_ROUTE_INTERFACE_STANDARD ;

#line 16366
typedef struct _IO_ASSIGNED_RESOURCES ;

#line 16490
typedef enum _IO_NOTIFICATION_EVENT_CATEGORY ;

#line 16504
typedef NTSTATUS ;

#line 16537
typedef void ;

#line 16573
typedef enum _ARBITER_ACTION ;

#line 16586
typedef struct _ARBITER_CONFLICT_INFO ;

#line 16608
typedef struct _ARBITER_PARAMETERS ;

#line 16719
typedef enum _ARBITER_REQUEST_SOURCE ;

#line 16731
typedef enum _ARBITER_RESULT ;

#line 16761
typedef struct _ARBITER_LIST_ENTRY ;

#line 16832
typedef NTSTATUS ;

#line 16853
typedef struct _ARBITER_INTERFACE ;

#line 16880
typedef enum _RESOURCE_TRANSLATION_DIRECTION ;

#line 16889
typedef NTSTATUS ;

#line 16901
typedef NTSTATUS ;

#line 16915
typedef struct _TRANSLATOR_INTERFACE ;

#line 16931
typedef NTSTATUS ;

#line 16945
typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE ;

#line 16959
typedef struct _PLUGPLAY_NOTIFICATION_HEADER ;

#line 16972
typedef struct _HWPROFILE_CHANGE_NOTIFICATION ;

#line 16986
typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION ;

#line 17006
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION ;

#line 17026
typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION ;

#line 17054
typedef struct _DEVICE_DESCRIPTION ;

#line 17086
typedef BOOLEAN ;

#line 17333
typedef void ;

#line 17339
typedef struct _DEVICE_CONTROL_CONTEXT ;

#line 17349
typedef PBUS_HANDLER ;

#line 17355
typedef void ;

#line 17365
typedef enum _HAL_QUERY_INFORMATION_CLASS ;

#line 17381
typedef enum _HAL_SET_INFORMATION_CLASS ;

#line 17388
typedef NTSTATUS ;

#line 17405
typedef NTSTATUS ;

#line 17420
typedef void ;

#line 17429
typedef void ;

#line 17438
typedef NTSTATUS ;

#line 17447
typedef NTSTATUS ;

#line 17456
typedef NTSTATUS ;

#line 17466
typedef NTSTATUS ;

#line 17475
typedef NTSTATUS ;

#line 17486
typedef struct _PM_DISPATCH_TABLE ;

#line 17492
typedef NTSTATUS ;

#line 17505
typedef struct _DMA_ADAPTER ;

#line 17520
typedef NTSTATUS ;

#line 17543
typedef BOOLEAN ;

#line 17553
typedef NTSTATUS ;

#line 17566
typedef void ;

#line 17572
typedef void ;

#line 17578
typedef BOOLEAN ;

#line 17588
typedef struct  {
	ULONG Version ;
	pHalQuerySystemInformation HalQuerySystemInformation ;
	pHalSetSystemInformation HalSetSystemInformation ;
	pHalQueryBusSlots HalQueryBusSlots ;
	ULONG Spare1 ;
	pHalExamineMBR HalExamineMBR ;
	pHalIoAssignDriveLetters HalIoAssignDriveLetters ;
	pHalIoReadPartitionTable HalIoReadPartitionTable ;
	pHalIoSetPartitionInformation HalIoSetPartitionInformation ;
	pHalIoWritePartitionTable HalIoWritePartitionTable ;
	pHalHandlerForBus HalReferenceHandlerForBus ;
	pHalReferenceBusHandler HalReferenceBusHandler ;
	pHalReferenceBusHandler HalDereferenceBusHandler ;
	pHalInitPnpDriver HalInitPnpDriver ;
	pHalInitPowerManagement HalInitPowerManagement ;
	pHalGetDmaAdapter HalGetDmaAdapter ;
	pHalGetInterruptTranslator HalGetInterruptTranslator ;
} ;

#line 17650
typedef struct _HAL_BUS_INFORMATION ;

#line 17658
typedef struct _HAL_PROFILE_SOURCE_INFORMATION ;

#line 17665
typedef struct _HAL_PROFILE_SOURCE_INTERVAL ;

#line 17671
typedef enum _HAL_DISPLAY_BIOS_INFORMATION ;

#line 17678
typedef struct _HAL_POWER_INFORMATION ;

#line 17683
typedef struct _HAL_PROCESSOR_SPEED_INFO ;

#line 17688
typedef struct _HAL_CALLBACKS ;

#line 17694
typedef struct _HAL_PROCESSOR_FEATURE ;

#line 17706
typedef union _MCI_ADDR ;

#line 17716
typedef enum  {
	HAL_MCE_RECORD,
	HAL_MCA_RECORD
} ;

#line 17726
typedef struct _MCA_EXCEPTION ;

#line 17752
typedef void ;

#line 17762
typedef struct _MCA_DRIVER_INFO ;

#line 17772
typedef struct _SCATTER_GATHER_ELEMENT ;

#line 17778

#pragma warning(disable:4200)
#line 17779
typedef struct _SCATTER_GATHER_LIST ;

#line 17784

#pragma warning(default:4200)
#line 17788
typedef struct _DMA_OPERATIONS ;

typedef struct _DMA_ADAPTER ;

#line 17797
typedef void ;

#line 17801
typedef PVOID ;

#line 17808
typedef void ;

#line 17816
typedef NTSTATUS ;

#line 17824
typedef BOOLEAN ;

#line 17833
typedef void ;

#line 17837
typedef void ;

#line 17843
typedef PHYSICAL_ADDRESS ;

#line 17852
typedef ULONG ;

#line 17856
typedef ULONG ;

#line 17860
typedef void ;

#line 17868
typedef NTSTATUS ;

#line 17880
typedef void ;

#line 17887
typedef struct _DMA_OPERATIONS ;

#line 18235
typedef void ;

#line 18321
typedef struct _OBJECT_HANDLE_INFORMATION ;

#line 18402
typedef struct _PCI_SLOT_NUMBER ;

#line 18418
typedef struct _PCI_COMMON_CONFIG ;

#line 18591
typedef struct _PCI_CAPABILITIES_HEADER ;

#line 18600
typedef struct _PCI_PMC ;

#line 18618
typedef struct _PCI_PMCSR ;

#line 18628
typedef struct _PCI_PMCSR_BSE ;

#line 18635
typedef struct _PCI_PM_CAPABILITY ;

#line 18679
typedef struct _PCI_AGP_CAPABILITY ;

#line 18720
typedef struct _PCI_MSI_CAPABILITY ;

#line 18946
typedef void ;

#line 18954
typedef void ;

#line 18963
typedef void ;

#line 18975
typedef struct _PCIBUSDATA ;

#line 18986
typedef ULONG ;

#line 18995
typedef void ;

#line 19000
typedef void ;

#line 19006
typedef struct _PCI_BUS_INTERFACE_STANDARD ;

#line 19028
typedef BOOLEAN ;

#line 19043
typedef struct _PCI_DEVICE_PRESENT_INTERFACE ;

#line 127 "C:/NTDDK/inc/ntddser.h"
typedef struct _SERIALPERF_STATS ;

#line 136
typedef struct _SERIALCONFIG ;

#line 154
typedef struct _SERIAL_LINE_CONTROL ;

#line 160
typedef struct _SERIAL_TIMEOUTS ;

#line 175
typedef struct _SERIAL_QUEUE_SIZE ;

#line 185
typedef struct _SERIAL_BAUD_RATE ;

#line 247
typedef struct _SERIAL_CHARS ;

#line 284
typedef struct _SERIAL_HANDFLOW ;

#line 340
typedef struct _SERIAL_BASIC_SETTINGS ;

#line 353
typedef struct _SERIAL_STATUS ;

#line 433
typedef struct _SERIAL_XOFF_COUNTER ;

#line 539
typedef struct _SERIAL_COMMPROP ;

#line 631
typedef struct _SERENUM_PORT_DESC ;

#line 652
typedef UCHAR ;

#line 658
typedef void ;

#line 665
typedef enum _SERENUM_PORTION ;

#line 671
typedef struct _SERENUM_PORT_PARAMETERS ;

#line 28 "C:/NTDDK/inc/ddk/wdm/wmilib.h"

#pragma once
#line 38
typedef struct  {
	LPCGUID Guid ;
	ULONG InstanceCount ;
	ULONG Flags ;
} ;

#line 45
typedef NTSTATUS ;

#line 101
typedef NTSTATUS ;

#line 162
typedef NTSTATUS ;

#line 206
typedef NTSTATUS ;

#line 253
typedef NTSTATUS ;

#line 306
typedef enum  {
	WmiEventControl,
	WmiDataBlockControl
} ;

#line 312
typedef NTSTATUS ;

#line 355
typedef struct _WMILIB_CONTEXT ;

#line 411
typedef enum  {
	IrpProcessed,
	IrpNotCompleted,
	IrpNotWmi,
	IrpForward
} ;

#line 13 "C:/NTDDK/inc/wmidata.h"
typedef struct _MSWmi_MofData ;

#line 51
typedef struct _MSWmi_ProviderInfo ;

#line 66
typedef struct _MSWmi_PnPDeviceId ;

#line 83
typedef struct _MSWmi_PnPInstanceNames ;

#line 105
typedef struct _MSSmBios_RawSMBiosTables ;

#line 147
typedef struct _MSPower_DeviceEnable ;

#line 165
typedef struct _MSPower_DeviceWakeEnable ;

#line 182
typedef struct _MSNdis_NetworkAddress ;

#line 199
typedef struct _MSNdis_NetworkShortAddress ;

#line 216
typedef struct _MSNdis_NetworkLinkSpeed ;

#line 239
typedef struct _MSNdis_EnumerateAdapter ;

#line 256
typedef struct _MSNdis_NotifyAdapterRemoval ;

#line 273
typedef struct _MSNdis_NotifyAdapterArrival ;

#line 291
typedef struct _MSNdis_NdisEnumerateVc ;

#line 307
typedef struct _MSNdis_NotifyVcRemoval ;

#line 323
typedef struct _MSNdis_NotifyVcArrival ;

#line 338
typedef struct _MSNdis_HardwareStatus ;

#line 356
typedef struct _MSNdis_MediaSupported ;

#line 378
typedef struct _MSNdis_MediaInUse ;

#line 400
typedef struct _MSNdis_MaximumLookahead ;

#line 418
typedef struct _MSNdis_MaximumFrameSize ;

#line 436
typedef struct _MSNdis_LinkSpeed ;

#line 454
typedef struct _MSNdis_TransmitBufferSpace ;

#line 472
typedef struct _MSNdis_ReceiveBufferSpace ;

#line 490
typedef struct _MSNdis_TransmitBlockSize ;

#line 508
typedef struct _MSNdis_ReceiveBlockSize ;

#line 526
typedef struct _MSNdis_VendorID ;

#line 544
typedef struct _MSNdis_VendorDescription ;

#line 561
typedef struct _MSNdis_CurrentPacketFilter ;

#line 579
typedef struct _MSNdis_CurrentLookahead ;

#line 597
typedef struct _MSNdis_DriverVersion ;

#line 615
typedef struct _MSNdis_MaximumTotalSize ;

#line 633
typedef struct _MSNdis_MacOptions ;

#line 651
typedef struct _MSNdis_MediaConnectStatus ;

#line 669
typedef struct _MSNdis_MaximumSendPackets ;

#line 687
typedef struct _MSNdis_VendorDriverVersion ;

#line 705
typedef struct _MSNdis_TransmitsOk ;

#line 723
typedef struct _MSNdis_ReceivesOk ;

#line 741
typedef struct _MSNdis_TransmitsError ;

#line 759
typedef struct _MSNdis_ReceiveError ;

#line 777
typedef struct _MSNdis_ReceiveNoBuffer ;

#line 795
typedef struct _MSNdis_CoHardwareStatus ;

#line 813
typedef struct _MSNdis_CoMediaSupported ;

#line 835
typedef struct _MSNdis_CoMediaInUse ;

#line 857
typedef struct _MSNdis_CoLinkSpeed ;

#line 875
typedef struct _MSNdis_CoVendorId ;

#line 893
typedef struct _MSNdis_CoVendorDescription ;

#line 910
typedef struct _MSNdis_CoDriverVersion ;

#line 928
typedef struct _MSNdis_CoMacOptions ;

#line 946
typedef struct _MSNdis_CoMediaConnectStatus ;

#line 964
typedef struct _MSNdis_CoVendorDriverVersion ;

#line 982
typedef struct _MSNdis_CoMinimumLinkSpeed ;

#line 1000
typedef struct _MSNdis_CoTransmitPdusOk ;

#line 1018
typedef struct _MSNdis_CoReceivePdusOk ;

#line 1036
typedef struct _MSNdis_CoTransmitPduErrors ;

#line 1054
typedef struct _MSNdis_CoReceivePduErrors ;

#line 1072
typedef struct _MSNdis_CoReceivePdusNoBuffer ;

#line 1090
typedef struct _MSNdis_AtmSupportedVcRates ;

#line 1113
typedef struct _MSNdis_AtmSupportedServiceCategory ;

#line 1131
typedef struct _MSNdis_AtmSupportedAalTypes ;

#line 1149
typedef struct _MSNdis_AtmHardwareCurrentAddress ;

#line 1167
typedef struct _MSNdis_AtmMaxActiveVcs ;

#line 1185
typedef struct _MSNdis_AtmMaxActiveVciBits ;

#line 1203
typedef struct _MSNdis_AtmMaxActiveVpiBits ;

#line 1221
typedef struct _MSNdis_AtmMaxAal0PacketSize ;

#line 1239
typedef struct _MSNdis_AtmMaxAal1PacketSize ;

#line 1257
typedef struct _MSNdis_AtmMaxAal34PacketSize ;

#line 1275
typedef struct _MSNdis_AtmMaxAal5PacketSize ;

#line 1293
typedef struct _MSNdis_AtmReceiveCellsOk ;

#line 1311
typedef struct _MSNdis_AtmTransmitCellsOk ;

#line 1329
typedef struct _MSNdis_AtmReceiveCellsDropped ;

#line 1347
typedef struct _MSNdis_EthernetPermanentAddress ;

#line 1365
typedef struct _MSNdis_EthernetCurrentAddress ;

#line 1383
typedef struct _MSNdis_EthernetMulticastList ;

#line 1405
typedef struct _MSNdis_EthernetMaximumMulticastListSize ;

#line 1423
typedef struct _MSNdis_EthernetMacOptions ;

#line 1441
typedef struct _MSNdis_EthernetReceiveErrorAlignment ;

#line 1459
typedef struct _MSNdis_EthernetOneTransmitCollision ;

#line 1477
typedef struct _MSNdis_EthernetMoreTransmitCollisions ;

#line 1495
typedef struct _MSNdis_TokenRingPermanentAddress ;

#line 1513
typedef struct _MSNdis_TokenRingCurrentAddress ;

#line 1531
typedef struct _MSNdis_TokenRingCurrentFunctional ;

#line 1549
typedef struct _MSNdis_TokenRingCurrentGroup ;

#line 1567
typedef struct _MSNdis_TokenRingLastOpenStatus ;

#line 1585
typedef struct _MSNdis_TokenRingCurrentRingStatus ;

#line 1603
typedef struct _MSNdis_TokenRingCurrentRingState ;

#line 1621
typedef struct _MSNdis_TokenRingLineErrors ;

#line 1639
typedef struct _MSNdis_TokenRingLostFrames ;

#line 1657
typedef struct _MSNdis_FddiLongPermanentAddress ;

#line 1675
typedef struct _MSNdis_FddiLongCurrentAddress ;

#line 1693
typedef struct _MSNdis_FddiLongMulticastList ;

#line 1715
typedef struct _MSNdis_FddiLongMaximumListSize ;

#line 1733
typedef struct _MSNdis_FddiShortPermanentAddress ;

#line 1751
typedef struct _MSNdis_FddiShortCurrentAddress ;

#line 1769
typedef struct _MSNdis_FddiShortMulticastList ;

#line 1791
typedef struct _MSNdis_FddiShortMaximumListSize ;

#line 1809
typedef struct _MSNdis_FddiAttachmentType ;

#line 1827
typedef struct _MSNdis_FddiUpstreamNodeLong ;

#line 1845
typedef struct _MSNdis_FddiDownstreamNodeLong ;

#line 1863
typedef struct _MSNdis_FddiFrameErrors ;

#line 1881
typedef struct _MSNdis_FddiFramesLost ;

#line 1899
typedef struct _MSNdis_FddiRingManagmentState ;

#line 1917
typedef struct _MSNdis_FddiLctFailures ;

#line 1935
typedef struct _MSNdis_FddiLemRejects ;

#line 1953
typedef struct _MSNdis_FddiLConnectionState ;

#line 1972
typedef struct _MSNdis_StatusResetStart ;

#line 1988
typedef struct _MSNdis_StatusResetEnd ;

#line 2004
typedef struct _MSNdis_StatusMediaConnect ;

#line 2020
typedef struct _MSNdis_StatusMediaDisconnect ;

#line 2035
typedef struct _MSNdis_StatusMediaSpecificIndication ;

#line 2057
typedef struct _MSNdis_StatusLinkSpeedChange ;

#line 2075
typedef struct _MSNdis_StatusProtocolBind ;

#line 2092
typedef struct _MSNdis_StatusProtocolUnbind ;

#line 2109
typedef struct _KEYBOARD_PORT_WMI_STD_DATA ;

#line 2152
typedef struct _POINTER_PORT_WMI_STD_DATA ;

#line 2205
typedef struct _MSMouse_ClassInformation ;

#line 2223
typedef struct _MSKeyboard_ClassInformation ;

#line 2241
typedef struct _MSAcpi_ThermalZoneTemperature ;

#line 2304
typedef struct _WMI_DISK_GEOMETRY ;

#line 2342
typedef struct _WMI_DISK_PERFORMANCE ;

#line 2415
typedef struct _MSDiskDriver_Performance ;

#line 2437
typedef struct _STORAGE_FAILURE_PREDICT_STATUS ;

#line 2460
typedef struct _STORAGE_FAILURE_PREDICT_DATA ;

#line 2483
typedef struct _STORAGE_FAILURE_PREDICT_EVENT ;

#line 2513
typedef struct _STORAGE_FAILURE_PREDICT_FUNCTION ;

#line 2528
typedef struct _MSIde_PortDeviceInfo ;

#line 2556
typedef struct _MSSerial_PortName ;

#line 2573
typedef struct _SERIAL_WMI_COMM_DATA ;

#line 2723
typedef struct _SERIAL_WMI_HW_DATA ;

#line 2770
typedef struct _SERIAL_WMI_PERF_DATA ;

#line 2813
typedef struct _SERIAL_WMI_COMMPROP ;

#line 2920
typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS ;

#line 2943
typedef struct _PARALLEL_WMI_LOG_INFO ;

#line 3041
typedef struct _REDBOOK_WMI_STD_DATA ;

#line 3094
typedef struct _REDBOOK_WMI_PERF_DATA ;

#line 3137
typedef struct _RegisteredGuids ;

#line 475 "serial.h"
typedef struct _CONFIG_DATA ;

#line 509
typedef struct _SERIAL_CISR_SW ;

#line 520
typedef struct _SERIAL_FIRMWARE_DATA ;

#line 576
typedef struct _SERIAL_DEVICE_STATE ;

#line 646
typedef struct _SERIAL_DEVICE_EXTENSION ;

#line 1808
typedef struct _SERIAL_MULTIPORT_DISPATCH ;

#line 2157
typedef enum _SERIAL_MEM_COMPARES ;

#line 2164
typedef struct _SERIAL_LIST_DATA ;

#line 2169
typedef struct _SERIAL_GLOBALS ;

#line 2180
typedef struct _SERIAL_USER_DATA ;

#line 2206
typedef struct _SERIAL_PTR_CTX ;

#line 20 "serialp.h"
typedef NTSTATUS ;

#line 26
typedef void ;

#line 835
typedef struct _SERIAL_UPDATE_CHAR ;

#line 846
typedef struct _SERIAL_IOCTL_SYNC ;

#line 27 "utils.c"
void SerialRundownIrpRefs(PIRP *  CurrentOpIrp , PKTIMER IntervalTimer , PKTIMER
	TotalTimer , PSERIAL_DEVICE_EXTENSION PDevExt ) ;

#line 36

#pragma alloc_text(PAGESER, SerialGetNextIrp)
#line 37

#pragma alloc_text(PAGESER, SerialGetNextIrpLocked)
#line 38

#pragma alloc_text(PAGESER, SerialTryToCompleteCurrent)
#line 39

#pragma alloc_text(PAGESER, SerialStartOrQueue)
#line 40

#pragma alloc_text(PAGESER, SerialCancelQueued)
#line 41

#pragma alloc_text(PAGESER, SerialCompleteIfError)
#line 42

#pragma alloc_text(PAGESER, SerialRundownIrpRefs)

#pragma alloc_text(PAGESRP0, SerialLogError)
#line 45

#pragma alloc_text(PAGESRP0, SerialMarkHardwareBroken)
#line 48
static const LARGE_INTEGER SerialPhysicalZero___0 = {0};

#line 51
void SerialKillAllReadsOrWrites(PDEVICE_OBJECT DeviceObject , PLIST_ENTRY
	QueueToClean , PIRP *  CurrentOpIrp )
{
	#line 81
	KIRQL cancelIrql ;
	PDRIVER_CANCEL cancelRoutine ;
	#line 89
	IoAcquireCancelSpinLock(& cancelIrql);
	#line 95
	while(! (QueueToClean->Flink == QueueToClean))
	{
		PIRP currentLastIrp = (IRP *  )((PCHAR )QueueToClean->Blink -
			(ULONG_PTR )(& ((((IRP * 
			)0)->Tail).Overlay).ListEntry));
		{
			#line 103
			PLIST_ENTRY _EX_Blink ;
			#line 103
			PLIST_ENTRY _EX_Flink ;
			#line 103
			_EX_Flink = (QueueToClean->Blink)->Flink;
			#line 103
			_EX_Blink = (QueueToClean->Blink)->Blink;
			#line 103
			_EX_Blink->Flink = _EX_Flink;
			#line 103
			_EX_Flink->Blink = _EX_Blink;
		}
		#line 103
		;
		#line 105
		cancelRoutine = currentLastIrp->CancelRoutine;
		currentLastIrp->CancelIrql = cancelIrql;
		currentLastIrp->CancelRoutine = (void *  )0;
		currentLastIrp->Cancel = 1;
		#line 110
		cancelRoutine(DeviceObject, currentLastIrp);
		#line 115
		IoAcquireCancelSpinLock(& cancelIrql);
	}
	#line 124
	if(* CurrentOpIrp)
	{
		#line 127
		cancelRoutine = (* CurrentOpIrp)->CancelRoutine;
		(* CurrentOpIrp)->Cancel = 1;
		#line 137
		if(cancelRoutine)
		{
			(* CurrentOpIrp)->CancelRoutine = (void *  )0;
			(* CurrentOpIrp)->CancelIrql = cancelIrql;
			#line 148
			cancelRoutine(DeviceObject, * CurrentOpIrp);
		}
		else
		{
			#line 155
			IoReleaseCancelSpinLock(cancelIrql);
		}
	}
	else
	{
		#line 161
		IoReleaseCancelSpinLock(cancelIrql);
	}
}

#line 167
void SerialGetNextIrp(PIRP *  CurrentOpIrp , PLIST_ENTRY QueueToProcess , PIRP
	*  NextIrp , BOOLEAN CompleteCurrent , PSERIAL_DEVICE_EXTENSION
	extension )
{
	#line 213
	KIRQL oldIrql ;
	;
	#line 217
	IoAcquireCancelSpinLock(& oldIrql);
	SerialGetNextIrpLocked(CurrentOpIrp, QueueToProcess, NextIrp,
		CompleteCurrent, extension, oldIrql);
}

void SerialGetNextIrpLocked(PIRP *  CurrentOpIrp , PLIST_ENTRY QueueToProcess ,
	PIRP *  NextIrp , BOOLEAN CompleteCurrent , PSERIAL_DEVICE_EXTENSION
	extension , KIRQL OldIrql )
{
	#line 274
	PIRP oldIrp ;
	#line 276
	;
	#line 279
	oldIrp = * CurrentOpIrp;
	#line 297
	if(! (QueueToProcess->Flink == QueueToProcess))
	{
		PLIST_ENTRY headOfList ;
		#line 301
		headOfList = QueueToProcess->Flink;
		{
			{
				#line 301
				PLIST_ENTRY _EX_Blink ;
				#line 301
				PLIST_ENTRY _EX_Flink ;
				#line 301
				_EX_Flink = (QueueToProcess->Flink)->Flink;
				#line 301
				_EX_Blink = (QueueToProcess->Flink)->Blink;
				#line 301
				_EX_Blink->Flink = _EX_Flink;
				#line 301
				_EX_Flink->Blink = _EX_Blink;
			}
		}
		#line 301
		;
		#line 303
		* CurrentOpIrp = (IRP *  )((PCHAR )headOfList - (ULONG_PTR )(&
			((((IRP *  )0)->Tail).Overlay).ListEntry));
		#line 312
		(PDRIVER_CANCEL )((PVOID )InterlockedExchange((PLONG )((PVOID * 
			)(& (* CurrentOpIrp)->CancelRoutine)), (LONG )((PVOID
			)((void *  )0))));
	}
	else
	{
		#line 316
		* CurrentOpIrp = (void *  )0;
	}
	#line 320
	* NextIrp = * CurrentOpIrp;
	IoReleaseCancelSpinLock(OldIrql);
	#line 323
	if(CompleteCurrent)
	{
		if(oldIrp)
		{
			#line 330
			do
			{
				#line 330
				;
			}
			while(0);
			{
				#line 332
				IofCompleteRequest(oldIrp, 2);
				#line 332
				SerialIRPEpilogue(extension);
			}
			#line 332
			;
		}
	}
}

#line 339
void SerialTryToCompleteCurrent(PSERIAL_DEVICE_EXTENSION Extension ,
	PKSYNCHRONIZE_ROUTINE SynchRoutine , KIRQL IrqlForRelease , NTSTATUS
	StatusToUse , PIRP *  CurrentOpIrp , PLIST_ENTRY QueueToProcess ,
	PKTIMER IntervalTimer , PKTIMER TotalTimer , PSERIAL_START_ROUTINE
	Starter , PSERIAL_GET_NEXT_ROUTINE GetNextIrp , LONG RefType )
{
	#line 390
	;
	#line 400
	do
	{
		#line 400
		LONG _refType = RefType;
		#line 400
		PULONG_PTR _arg4 = (PVOID )(& ((((((*
			CurrentOpIrp)->Tail).Overlay).CurrentStackLocation)->Parameters
			).Others).Argument4);
		#line 400
		;
		#line 400
		* _arg4 &= ~ _refType;
	}
	while(0);
	#line 402
	if(SynchRoutine)
	{
		KeSynchronizeExecution(Extension->Interrupt, SynchRoutine,
			Extension);
	}
	#line 416
	SerialRundownIrpRefs(CurrentOpIrp, IntervalTimer, TotalTimer,
		Extension);
	#line 427
	if(! (ULONG_PTR )((((((*
		CurrentOpIrp)->Tail).Overlay).CurrentStackLocation)->Parameters)
		.Others).Argument4)
	{
		#line 429
		PIRP newIrp ;
		#line 440
		((* CurrentOpIrp)->IoStatus).Status = StatusToUse;
		#line 442
		if(StatusToUse == (NTSTATUS )0xC0000120L)
		{
			((* CurrentOpIrp)->IoStatus).Information = 0;
		}
		#line 448
		if(GetNextIrp)
		{
			IoReleaseCancelSpinLock(IrqlForRelease);
			GetNextIrp(CurrentOpIrp, QueueToProcess, & newIrp, 1,
				Extension);
			#line 459
			if(newIrp)
			{
				Starter(Extension);
			}
		}
		else
		{
			#line 467
			PIRP oldIrp = * CurrentOpIrp;
			#line 475
			* CurrentOpIrp = (void *  )0;
			#line 477
			IoReleaseCancelSpinLock(IrqlForRelease);
			#line 481
			do
			{
				#line 481
				;
			}
			while(0);
			{
				#line 482
				IofCompleteRequest(oldIrp, 2);
				#line 482
				SerialIRPEpilogue(Extension);
			}
			#line 482
			;
		}
	}
	else
	{
		IoReleaseCancelSpinLock(IrqlForRelease);
	}
}

#line 493
void SerialRundownIrpRefs(PIRP *  CurrentOpIrp , PKTIMER IntervalTimer , PKTIMER
	TotalTimer , PSERIAL_DEVICE_EXTENSION PDevExt )
{
	#line 532
	;
	#line 545
	if((* CurrentOpIrp)->CancelRoutine)
	{
		#line 550
		do
		{
			#line 550
			LONG _refType = 0x00000002;
			#line 550
			PULONG_PTR _arg4 = (PVOID )(& ((((((*
				CurrentOpIrp)->Tail).Overlay).CurrentStackLocation
				)->Parameters).Others).Argument4);
			#line 550
			;
			#line 550
			* _arg4 &= ~ _refType;
		}
		while(0);
		#line 555
		(PDRIVER_CANCEL )((PVOID )InterlockedExchange((PLONG )((PVOID * 
			)(& (* CurrentOpIrp)->CancelRoutine)), (LONG )((PVOID
			)((void *  )0))));
	}
	if(IntervalTimer)
	{
		#line 582
		if(SerialCancelTimer(IntervalTimer, PDevExt))
		{
			#line 587
			do
			{
				#line 587
				LONG _refType = 0x00000008;
				#line 587
				PULONG_PTR _arg4 = (PVOID )(& ((((((*
					CurrentOpIrp)->Tail).Overlay).CurrentStackLocation
					)->Parameters).Others).Argument4);
				#line 587
				;
				#line 587
				* _arg4 &= ~ _refType;
			}
			while(0);
		}
	}
	#line 593
	if(TotalTimer)
	{
		#line 616
		if(SerialCancelTimer(TotalTimer, PDevExt))
		{
			#line 621
			do
			{
				#line 621
				LONG _refType = 0x00000004;
				#line 621
				PULONG_PTR _arg4 = (PVOID )(& ((((((*
					CurrentOpIrp)->Tail).Overlay).CurrentStackLocation
					)->Parameters).Others).Argument4);
				#line 621
				;
				#line 621
				* _arg4 &= ~ _refType;
			}
			while(0);
		}
	}
}

NTSTATUS SerialStartOrQueue(PSERIAL_DEVICE_EXTENSION Extension , PIRP Irp ,
	PLIST_ENTRY QueueToExamine , PIRP *  CurrentOpIrp ,
	PSERIAL_START_ROUTINE Starter )
{
	#line 673
	KIRQL oldIrql ;
	#line 675
	;
	#line 677
	IoAcquireCancelSpinLock(& oldIrql);
	#line 684
	if((((Irp->Tail).Overlay).CurrentStackLocation)->MajorFunction == 0x04)
	{
		#line 687
		Extension->TotalCharsQueued +=
			(((((Irp->Tail).Overlay).CurrentStackLocation)->Parameters
			).Write).Length;
	}
	else
	{
		#line 691
		if((((Irp->Tail).Overlay).CurrentStackLocation)->MajorFunction
			== 0x0e &&
			((((((Irp->Tail).Overlay).CurrentStackLocation)->Parameters
			).DeviceIoControl).IoControlCode == (0x0000001b << 16 |
			0 << 14 | 6 << 2 | 0) ||
			(((((Irp->Tail).Overlay).CurrentStackLocation)->Parameters
			).DeviceIoControl).IoControlCode == (0x0000001b << 16 |
			0 << 14 | 28 << 2 | 0)))
		{
			Extension->TotalCharsQueued++;
		}
	}
	#line 704
	if(QueueToExamine->Flink == QueueToExamine && ! * CurrentOpIrp)
	{
		#line 712
		* CurrentOpIrp = Irp;
		#line 714
		IoReleaseCancelSpinLock(oldIrql);
		#line 716
		return Starter(Extension);
	}
	else
	{
		#line 725
		if(Irp->Cancel)
		{
			#line 726
			PIO_STACK_LOCATION irpSp
				= ((Irp->Tail).Overlay).CurrentStackLocation;
			IoReleaseCancelSpinLock(oldIrql);
			#line 730
			if(((irpSp->Parameters).DeviceIoControl).IoControlCode
				== (0x0000001b << 16 | 0 << 14 | 2 << 2 | 0))
			{
				#line 738
				;
				#line 740
				ExFreePool(((irpSp->Parameters).DeviceIoControl)
					.Type3InputBuffer);
				((irpSp->Parameters).DeviceIoControl).Type3InputBuffer
					= (void *  )0;
			}
			(Irp->IoStatus).Status = (NTSTATUS )0xC0000120L;
			#line 750
			do
			{
				#line 750
				;
			}
			while(0);
			{
				#line 751
				IofCompleteRequest(Irp, 0);
				#line 751
				SerialIRPEpilogue(Extension);
			}
			#line 751
			;
			#line 753
			return (NTSTATUS )0xC0000120L;
		}
		else
		{
			#line 758
			(Irp->IoStatus).Status = (NTSTATUS )0x00000103L;
			if(pending == 0)
				#line 759
				pending = 1;
			else
				#line 759
				errorFn();
			(((Irp->Tail).Overlay).CurrentStackLocation)->Control |=
				0x01;
			{
				#line 765
				PLIST_ENTRY _EX_Blink ;
				#line 765
				PLIST_ENTRY _EX_ListHead ;
				#line 765
				_EX_ListHead = QueueToExamine;
				#line 765
				_EX_Blink = _EX_ListHead->Blink;
				#line 765
				(& ((Irp->Tail).Overlay).ListEntry)->Flink =
					_EX_ListHead;
				#line 765
				(& ((Irp->Tail).Overlay).ListEntry)->Blink =
					_EX_Blink;
				#line 765
				_EX_Blink->Flink = &
					((Irp->Tail).Overlay).ListEntry;
				#line 765
				_EX_ListHead->Blink = &
					((Irp->Tail).Overlay).ListEntry;
			}
			#line 765
			;
			#line 770
			(PDRIVER_CANCEL )((PVOID )InterlockedExchange((PLONG
				)((PVOID *  )(& Irp->CancelRoutine)), (LONG
				)((PVOID )SerialCancelQueued)));
			#line 772
			IoReleaseCancelSpinLock(oldIrql);
			#line 774
			return (NTSTATUS )0x00000103L;
		}
	}
}

#line 782
void SerialCancelQueued(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
	#line 809
	PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
	PIO_STACK_LOCATION irpSp = ((Irp->Tail).Overlay).CurrentStackLocation;
	#line 812
	;
	#line 814
	(Irp->IoStatus).Status = (NTSTATUS )0xC0000120L;
	(Irp->IoStatus).Information = 0;
	{
		PLIST_ENTRY _EX_Blink ;
		#line 817
		PLIST_ENTRY _EX_Flink ;
		#line 817
		_EX_Flink = (& ((Irp->Tail).Overlay).ListEntry)->Flink;
		#line 817
		_EX_Blink = (& ((Irp->Tail).Overlay).ListEntry)->Blink;
		#line 817
		_EX_Blink->Flink = _EX_Flink;
		#line 817
		_EX_Flink->Blink = _EX_Blink;
	}
	#line 817
	;
	#line 824
	if(irpSp->MajorFunction == 0x04)
	{
		extension->TotalCharsQueued -=
			((irpSp->Parameters).Write).Length;
	}
	else
	{
		#line 828
		if(irpSp->MajorFunction == 0x0e)
		{
			#line 837
			if(((irpSp->Parameters).DeviceIoControl).IoControlCode
				== (0x0000001b << 16 | 0 << 14 | 6 << 2 | 0) ||
				((irpSp->Parameters).DeviceIoControl).IoControlCode
				== (0x0000001b << 16 | 0 << 14 | 28 << 2 | 0))
			{
				extension->TotalCharsQueued--;
			}
			else
			{
				#line 844
				if(((irpSp->Parameters).DeviceIoControl).IoControlCode
					== (0x0000001b << 16 | 0 << 14 | 2 << 2
					| 0))
				{
					#line 853
					;
					#line 855
					ExFreePool(((irpSp->Parameters).DeviceIoControl
						).Type3InputBuffer);
					((irpSp->Parameters).DeviceIoControl).Type3InputBuffer
						= (void *  )0;
				}
			}
		}
	}
	IoReleaseCancelSpinLock(Irp->CancelIrql);
	#line 868
	do
	{
		#line 868
		;
	}
	while(0);
	{
		#line 869
		IofCompleteRequest(Irp, 2);
		#line 869
		SerialIRPEpilogue(extension);
	}
	#line 869
	;
}

NTSTATUS SerialCompleteIfError(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
	#line 900
	PSERIAL_DEVICE_EXTENSION extension = DeviceObject->DeviceExtension;
	#line 902
	NTSTATUS status = (NTSTATUS )0x00000000L;
	#line 904
	;
	#line 906
	if((extension->HandFlow).ControlHandShake & (ULONG )0x80000000 &&
		extension->ErrorWord)
	{
		PIO_STACK_LOCATION irpSp
			= ((Irp->Tail).Overlay).CurrentStackLocation;
		#line 916
		if(irpSp->MajorFunction != 0x0e ||
			((irpSp->Parameters).DeviceIoControl).IoControlCode !=
			(0x0000001b << 16 | 0 << 14 | 27 << 2 | 0))
		{
			status = (NTSTATUS )0xC0000120L;
			(Irp->IoStatus).Status = (NTSTATUS )0xC0000120L;
			(Irp->IoStatus).Information = 0;
			#line 927
			do
			{
				#line 927
				;
			}
			while(0);
			{
				#line 928
				IofCompleteRequest(Irp, 0);
				#line 928
				SerialIRPEpilogue(extension);
			}
			#line 928
			;
		}
	}
	#line 933
	return status;
}

#line 937
void SerialFilterCancelQueued(PDEVICE_OBJECT PDevObj , PIRP PIrp )
{
	#line 957
	PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
	PIO_STACK_LOCATION pIrpSp = ((PIrp->Tail).Overlay).CurrentStackLocation;
	#line 960
	(PIrp->IoStatus).Status = (NTSTATUS )0xC0000120L;
	(PIrp->IoStatus).Information = 0;
	{
		PLIST_ENTRY _EX_Blink ;
		#line 963
		PLIST_ENTRY _EX_Flink ;
		#line 963
		_EX_Flink = (& ((PIrp->Tail).Overlay).ListEntry)->Flink;
		#line 963
		_EX_Blink = (& ((PIrp->Tail).Overlay).ListEntry)->Blink;
		#line 963
		_EX_Blink->Flink = _EX_Flink;
		#line 963
		_EX_Flink->Blink = _EX_Blink;
	}
	#line 963
	;
	#line 965
	IoReleaseCancelSpinLock(PIrp->CancelIrql);
}

void SerialKillAllStalled(PDEVICE_OBJECT PDevObj )
{
	#line 971
	KIRQL cancelIrql ;
	PDRIVER_CANCEL cancelRoutine ;
	PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
	#line 975
	IoAcquireCancelSpinLock(& cancelIrql);
	#line 977
	while(! ((& pDevExt->StalledIrpQueue)->Flink == &
		pDevExt->StalledIrpQueue))
	{
		#line 979
		PIRP currentLastIrp = (IRP *  )((PCHAR
			)(pDevExt->StalledIrpQueue).Blink - (ULONG_PTR )(&
			((((IRP *  )0)->Tail).Overlay).ListEntry));
		{
			#line 982
			PLIST_ENTRY _EX_Blink ;
			#line 982
			PLIST_ENTRY _EX_Flink ;
			#line 982
			_EX_Flink = ((pDevExt->StalledIrpQueue).Blink)->Flink;
			#line 982
			_EX_Blink = ((pDevExt->StalledIrpQueue).Blink)->Blink;
			#line 982
			_EX_Blink->Flink = _EX_Flink;
			#line 982
			_EX_Flink->Blink = _EX_Blink;
		}
		#line 982
		;
		#line 984
		cancelRoutine = currentLastIrp->CancelRoutine;
		currentLastIrp->CancelIrql = cancelIrql;
		currentLastIrp->CancelRoutine = (void *  )0;
		currentLastIrp->Cancel = 1;
		#line 989
		cancelRoutine(PDevObj, currentLastIrp);
		#line 991
		IoAcquireCancelSpinLock(& cancelIrql);
	}
	#line 994
	IoReleaseCancelSpinLock(cancelIrql);
}

NTSTATUS SerialFilterIrps(PIRP PIrp , PSERIAL_DEVICE_EXTENSION PDevExt )
{
	#line 1020
	PIO_STACK_LOCATION pIrpStack ;
	KIRQL oldIrqlFlags ;
	#line 1023
	pIrpStack = ((PIrp->Tail).Overlay).CurrentStackLocation;
	#line 1025
	* & oldIrqlFlags = KfAcquireSpinLock(& PDevExt->FlagsLock);
	#line 1027
	if(PDevExt->DevicePNPAccept == 0x0L && (PDevExt->Flags & 0x4L) == 0)
	{
		KfReleaseSpinLock(& PDevExt->FlagsLock, oldIrqlFlags);
		return (NTSTATUS )0x00000000L;
	}
	#line 1033
	if(PDevExt->DevicePNPAccept & 0x1L || PDevExt->Flags & 0x4L ||
		PDevExt->DevicePNPAccept & 0x8L)
	{
		#line 1037
		KfReleaseSpinLock(& PDevExt->FlagsLock, oldIrqlFlags);
		#line 1043
		if(pIrpStack->MajorFunction == 0x1b)
		{
			#line 1044
			return (NTSTATUS )0x00000000L;
		}
		#line 1047
		(PIrp->IoStatus).Status = (NTSTATUS )0xC0000056L;
		return (NTSTATUS )0xC0000056L;
	}
	#line 1051
	if(PDevExt->DevicePNPAccept & 0x2L)
	{
		#line 1052
		KIRQL oldIrql ;
		#line 1054
		KfReleaseSpinLock(& PDevExt->FlagsLock, oldIrqlFlags);
		#line 1061
		if(pIrpStack->MajorFunction == 0x1b)
		{
			#line 1062
			return (NTSTATUS )0x00000000L;
		}
		#line 1065
		IoAcquireCancelSpinLock(& oldIrql);
		#line 1067
		if(PIrp->Cancel)
		{
			#line 1068
			IoReleaseCancelSpinLock(oldIrql);
			(PIrp->IoStatus).Status = (NTSTATUS )0xC0000120L;
			return (NTSTATUS )0xC0000120L;
		}
		else
		{
			#line 1076
			(PIrp->IoStatus).Status = (NTSTATUS )0x00000103L;
			if(pending == 0)
				#line 1077
				pending = 1;
			else
				#line 1077
				errorFn();
			(((PIrp->Tail).Overlay).CurrentStackLocation)->Control
				|= 0x01;
			{
				#line 1085
				PLIST_ENTRY _EX_Blink ;
				#line 1085
				PLIST_ENTRY _EX_ListHead ;
				#line 1085
				_EX_ListHead = & PDevExt->StalledIrpQueue;
				#line 1085
				_EX_Blink = _EX_ListHead->Blink;
				#line 1085
				(& ((PIrp->Tail).Overlay).ListEntry)->Flink =
					_EX_ListHead;
				#line 1085
				(& ((PIrp->Tail).Overlay).ListEntry)->Blink =
					_EX_Blink;
				#line 1085
				_EX_Blink->Flink = &
					((PIrp->Tail).Overlay).ListEntry;
				#line 1085
				_EX_ListHead->Blink = &
					((PIrp->Tail).Overlay).ListEntry;
			}
			#line 1085
			;
			#line 1087
			(PDRIVER_CANCEL )((PVOID )InterlockedExchange((PLONG
				)((PVOID *  )(& PIrp->CancelRoutine)), (LONG
				)((PVOID )SerialFilterCancelQueued)));
			#line 1088
			IoReleaseCancelSpinLock(oldIrql);
			return (NTSTATUS )0x00000103L;
		}
	}
	#line 1093
	KfReleaseSpinLock(& PDevExt->FlagsLock, oldIrqlFlags);
	#line 1095
	return (NTSTATUS )0x00000000L;
}

#line 1099
void SerialUnstallIrps(PSERIAL_DEVICE_EXTENSION PDevExt )
{
	#line 1118
	PLIST_ENTRY pIrpLink ;
	PIRP pIrp ;
	PIO_STACK_LOCATION pIrpStack ;
	PDEVICE_OBJECT pDevObj ;
	PDRIVER_OBJECT pDrvObj ;
	KIRQL oldIrql ;
	#line 1125
	do
	{
		#line 1125
		;
	}
	while(0);
	#line 1126
	IoAcquireCancelSpinLock(& oldIrql);
	#line 1128
	pIrpLink = (PDevExt->StalledIrpQueue).Flink;
	#line 1130
	while(pIrpLink != & PDevExt->StalledIrpQueue)
	{
		#line 1131
		pIrp = (IRP *  )((PCHAR )pIrpLink - (ULONG_PTR )(& ((((IRP * 
			)0)->Tail).Overlay).ListEntry));
		{
			#line 1132
			PLIST_ENTRY _EX_Blink ;
			#line 1132
			PLIST_ENTRY _EX_Flink ;
			#line 1132
			_EX_Flink = (& ((pIrp->Tail).Overlay).ListEntry)->Flink;
			#line 1132
			_EX_Blink = (& ((pIrp->Tail).Overlay).ListEntry)->Blink;
			#line 1132
			_EX_Blink->Flink = _EX_Flink;
			#line 1132
			_EX_Flink->Blink = _EX_Blink;
		}
		#line 1132
		;
		#line 1134
		pIrpStack = ((pIrp->Tail).Overlay).CurrentStackLocation;
		pDevObj = pIrpStack->DeviceObject;
		pDrvObj = pDevObj->DriverObject;
		(PDRIVER_CANCEL )((PVOID )InterlockedExchange((PLONG )((PVOID * 
			)(& pIrp->CancelRoutine)), (LONG )((PVOID )((void * 
			)0))));
		#line 1138
		IoReleaseCancelSpinLock(oldIrql);
		#line 1141
		do
		{
			#line 1141
			;
		}
		while(0);
		#line 1143
		((pDrvObj->MajorFunction)[pIrpStack->MajorFunction])(pDevObj,
			pIrp);
		IoAcquireCancelSpinLock(& oldIrql);
		pIrpLink = (PDevExt->StalledIrpQueue).Flink;
	}
	#line 1149
	IoReleaseCancelSpinLock(oldIrql);
	#line 1151
	do
	{
		#line 1151
		;
	}
	while(0);
}

#line 1155
NTSTATUS SerialIRPPrologue(PIRP PIrp , PSERIAL_DEVICE_EXTENSION PDevExt )
{
	#line 1175
	InterlockedIncrement(& PDevExt->PendingIRPCnt);
	#line 1177
	return SerialFilterIrps(PIrp, PDevExt);
}

#line 1182
void SerialIRPEpilogue(PSERIAL_DEVICE_EXTENSION PDevExt )
{
	#line 1202
	LONG pendingCnt ;
	#line 1204
	pendingCnt = InterlockedDecrement(& PDevExt->PendingIRPCnt);
	#line 1206
	;
	#line 1208
	if(pendingCnt == 0)
	{
		#line 1209
		KeSetEvent(& PDevExt->PendingIRPEvent, 0, 0);
	}
}

#line 1214
BOOLEAN SerialInsertQueueDpc(PRKDPC PDpc , PVOID Sarg1 , PVOID Sarg2 ,
	PSERIAL_DEVICE_EXTENSION PDevExt )
{
	#line 1236
	BOOLEAN queued ;
	#line 1238
	InterlockedIncrement(& PDevExt->DpcCount);
	;
	#line 1241
	queued = KeInsertQueueDpc(PDpc, Sarg1, Sarg2);
	#line 1243
	if(! queued)
	{
		#line 1244
		ULONG pendingCnt ;
		#line 1246
		pendingCnt = InterlockedDecrement(& PDevExt->DpcCount);
		#line 1249
		if(pendingCnt == 0)
		{
			#line 1250
			KeSetEvent(& PDevExt->PendingIRPEvent, 0, 0);
			;
		}
	}
	#line 1270
	return queued;
}

#line 1274
BOOLEAN SerialSetTimer(PKTIMER Timer , LARGE_INTEGER DueTime , PKDPC Dpc ,
	PSERIAL_DEVICE_EXTENSION PDevExt )
{
	#line 1300
	BOOLEAN set ;
	#line 1302
	InterlockedIncrement(& PDevExt->DpcCount);
	;
	#line 1305
	set = KeSetTimer(Timer, DueTime, Dpc);
	#line 1307
	if(set)
	{
		#line 1308
		InterlockedDecrement(& PDevExt->DpcCount);
	}
	#line 1327
	return set;
}

#line 1331
BOOLEAN SerialCancelTimer(PKTIMER Timer , PSERIAL_DEVICE_EXTENSION PDevExt )
{
	#line 1352
	BOOLEAN cancelled ;
	#line 1354
	cancelled = KeCancelTimer(Timer);
	#line 1356
	if(cancelled)
	{
		#line 1357
		SerialDpcEpilogue(PDevExt, Timer->Dpc);
	}
	#line 1360
	return cancelled;
}

#line 1364
void SerialDpcEpilogue(PSERIAL_DEVICE_EXTENSION PDevExt , PKDPC PDpc )
{
	#line 1382
	LONG pendingCnt ;
	#line 1384
	PDpc;
	#line 1387
	pendingCnt = InterlockedDecrement(& PDevExt->DpcCount);
	#line 1390
	;
	#line 1410
	if(pendingCnt == 0)
	{
		#line 1411
		KeSetEvent(& PDevExt->PendingDpcEvent, 0, 0);
		;
	}
}

#line 1418
void SerialUnlockPages(PKDPC PDpc , PVOID PDeferredContext , PVOID PSysContext1
	, PVOID PSysContext2 )
{
	#line 1440
	PSERIAL_DEVICE_EXTENSION pDevExt = (PSERIAL_DEVICE_EXTENSION
		)PDeferredContext;
	#line 1443
	PDpc;
	PSysContext1;
	PSysContext2;
	#line 1447
	KeSetEvent(& pDevExt->PendingDpcEvent, 0, 0);
}

#line 1451
NTSTATUS SerialIoCallDriver(PSERIAL_DEVICE_EXTENSION PDevExt , PDEVICE_OBJECT
	PDevObj , PIRP PIrp )
{
	#line 1474
	NTSTATUS status ;
	#line 1476
	status = IofCallDriver(PDevObj, PIrp);
	SerialIRPEpilogue(PDevExt);
	return status;
}

#line 1483
NTSTATUS SerialPoCallDriver(PSERIAL_DEVICE_EXTENSION PDevExt , PDEVICE_OBJECT
	PDevObj , PIRP PIrp )
{
	#line 1506
	NTSTATUS status ;
	#line 1508
	status = PoCallDriver(PDevObj, PIrp);
	SerialIRPEpilogue(PDevExt);
	return status;
}

#line 1514
void SerialLogError(PDRIVER_OBJECT DriverObject , PDEVICE_OBJECT DeviceObject ,
	LARGE_INTEGER P1 , LARGE_INTEGER P2 , ULONG SequenceNumber , UCHAR
	MajorFunctionCode , UCHAR RetryCount , ULONG UniqueErrorValue , NTSTATUS
	FinalStatus , NTSTATUS SpecificIOStatus , ULONG LengthOfInsert1 , PWCHAR
	Insert1 , ULONG LengthOfInsert2 , PWCHAR Insert2 )
{
	#line 1588
	PIO_ERROR_LOG_PACKET errorLogEntry ;
	#line 1590
	PVOID objectToUse ;
	SHORT dumpToAllocate = 0;
	PUCHAR ptrToFirstInsert ;
	PUCHAR ptrToSecondInsert ;
	#line 1595
	;
	#line 1597
	if(Insert1 == (void *  )0)
	{
		#line 1598
		LengthOfInsert1 = 0;
	}
	#line 1601
	if(Insert2 == (void *  )0)
	{
		#line 1602
		LengthOfInsert2 = 0;
	}
	#line 1606
	if((CHAR *  )DeviceObject != (CHAR *  )((void *  )0))
	{
		objectToUse = DeviceObject;
	}
	else
	{
		objectToUse = DriverObject;
	}
	#line 1616
	if(SerialMemCompare(P1, (ULONG )1, SerialPhysicalZero___0, (ULONG )1) !=
		AddressesAreEqual)
	{
		#line 1623
		dumpToAllocate = (SHORT )sizeof(LARGE_INTEGER );
	}
	#line 1627
	if(SerialMemCompare(P2, (ULONG )1, SerialPhysicalZero___0, (ULONG )1) !=
		AddressesAreEqual)
	{
		#line 1634
		dumpToAllocate += (SHORT )sizeof(LARGE_INTEGER );
	}
	#line 1638
	errorLogEntry = IoAllocateErrorLogEntry(objectToUse, (UCHAR
		)(sizeof(IO_ERROR_LOG_PACKET ) + dumpToAllocate +
		LengthOfInsert1 + LengthOfInsert2));
	#line 1646
	if(errorLogEntry != (void *  )0)
	{
		errorLogEntry->ErrorCode = SpecificIOStatus;
		errorLogEntry->SequenceNumber = SequenceNumber;
		errorLogEntry->MajorFunctionCode = MajorFunctionCode;
		errorLogEntry->RetryCount = RetryCount;
		errorLogEntry->UniqueErrorValue = UniqueErrorValue;
		errorLogEntry->FinalStatus = FinalStatus;
		errorLogEntry->DumpDataSize = dumpToAllocate;
		#line 1656
		if(dumpToAllocate)
		{
			#line 1662
			memcpy(& (errorLogEntry->DumpData)[0], & P1,
				sizeof(LARGE_INTEGER ));
			if(dumpToAllocate > sizeof(LARGE_INTEGER ))
			{
				#line 1671
				memcpy((PUCHAR )(& (errorLogEntry->DumpData)[0])
					+ sizeof(LARGE_INTEGER ), & P2,
					sizeof(LARGE_INTEGER ));
				#line 1673
				ptrToFirstInsert = (PUCHAR )(&
					(errorLogEntry->DumpData)[0]) + 2 *
					sizeof(LARGE_INTEGER );
			}
			else
			{
				#line 1678
				ptrToFirstInsert = (PUCHAR )(&
					(errorLogEntry->DumpData)[0]) +
					sizeof(LARGE_INTEGER );
			}
		}
		else
		{
			#line 1686
			ptrToFirstInsert = (PUCHAR )(&
				(errorLogEntry->DumpData)[0]);
		}
		#line 1690
		ptrToSecondInsert = ptrToFirstInsert + LengthOfInsert1;
		#line 1692
		if(LengthOfInsert1)
		{
			errorLogEntry->NumberOfStrings = 1;
			errorLogEntry->StringOffset = (USHORT )(ptrToFirstInsert
				- (PUCHAR )errorLogEntry);
			#line 1701
			memcpy(ptrToFirstInsert, Insert1, LengthOfInsert1);
			#line 1703
			if(LengthOfInsert2)
			{
				errorLogEntry->NumberOfStrings = 2;
				#line 1710
				memcpy(ptrToSecondInsert, Insert2,
					LengthOfInsert2);
			}
		}
		#line 1716
		IoWriteErrorLogEntry(errorLogEntry);
	}
}

#line 1722
void SerialMarkHardwareBroken(PSERIAL_DEVICE_EXTENSION PDevExt )
{
	#line 1740
	;
	#line 1746
	SerialSetDeviceFlags(PDevExt, & PDevExt->Flags, 0x4L, 1);
	#line 1752
	SerialLogError(PDevExt->DriverObject, (void *  )0,
		SerialPhysicalZero___0, SerialPhysicalZero___0, 0, 0, 0, 88,
		(NTSTATUS )0x00000000L, (NTSTATUS )0xC006002DL,
		(PDevExt->DeviceName).Length + sizeof(WCHAR ),
		(PDevExt->DeviceName).Buffer, 0, (void *  )0);
	#line 1761
	IoInvalidateDeviceState(PDevExt->Pdo);
}

void SerialSetDeviceFlags(PSERIAL_DEVICE_EXTENSION PDevExt , PULONG PFlags ,
	ULONG Value , BOOLEAN Set )
{
	#line 1789
	KIRQL oldIrql ;
	#line 1791
	* & oldIrql = KfAcquireSpinLock(& PDevExt->FlagsLock);
	#line 1793
	if(Set)
	{
		#line 1794
		* PFlags |= Value;
	}
	else
	{
		#line 1796
		* PFlags &= ~ Value;
	}
	#line 1799
	KfReleaseSpinLock(& PDevExt->FlagsLock, oldIrql);
}

#line 16 "C:/NTDDK/inc/stddef.h"

#pragma once
#line 77
typedef int ;

#line 86
typedef unsigned int ;

#line 95
typedef int ;

#line 105
typedef unsigned int ;

#line 112
typedef unsigned short ;

#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"

#pragma once
#line 32

#pragma pack(push, 8)
#line 72
typedef enum _EXCEPTION_DISPOSITION ;

#line 89
struct _EXCEPTION_RECORD ;

#line 90
struct _CONTEXT ;

#line 155

#pragma pack(pop)
#line 25 "C:/NTDDK/inc/ntdef.h"

#pragma once
#line 15 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"

#pragma once
#line 66
typedef wchar_t ;

#line 67
typedef wchar_t ;

#line 127 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long ;

#line 25 "C:/NTDDK/inc/basetsd.h"

#pragma once
#line 36
typedef int ;

#line 37
typedef int ;

#line 43
typedef unsigned int ;

#line 44
typedef unsigned int ;

#line 45
typedef unsigned int ;

#line 84
typedef int ;

#line 85
typedef unsigned int ;

typedef long ;

#line 88
typedef unsigned long ;

#line 248
typedef unsigned short ;

#line 249
typedef short ;

#line 250
typedef unsigned long ;

#line 288
typedef ULONG_PTR ;

#line 289
typedef LONG_PTR ;

#line 295
typedef ULONG_PTR ;

#line 301
typedef __int64 ;

#line 302
typedef __int64 ;

#line 309
typedef unsigned __int64 ;

#line 310
typedef unsigned __int64 ;

#line 311
typedef unsigned __int64 ;

#line 217 "C:/NTDDK/inc/ntdef.h"
typedef void ;

#line 218
typedef void ;

#line 266
typedef char ;

#line 267
typedef short ;

#line 268
typedef long ;

#line 276
typedef wchar_t ;

#line 282
typedef WCHAR ;

#line 283
typedef WCHAR ;

#line 284
typedef const WCHAR ;

#line 285
typedef WCHAR ;

#line 286
typedef WCHAR ;

typedef const WCHAR ;

#line 293
typedef CHAR ;

#line 294
typedef CHAR ;

typedef const CHAR ;

#line 297
typedef CHAR ;

#line 298
typedef CHAR ;

#line 299
typedef const CHAR ;

#line 321
typedef char ;

#line 322
typedef unsigned char ;

#line 326
typedef LPSTR ;

#line 327
typedef LPSTR ;

#line 328
typedef LPCSTR ;

#line 337
typedef double ;

typedef struct _QUAD ;

#line 349
typedef SHORT ;

#line 350
typedef LONG ;

#line 351
typedef QUAD ;

#line 360
typedef unsigned char ;

#line 361
typedef unsigned short ;

#line 362
typedef unsigned long ;

#line 363
typedef QUAD ;

#line 369
typedef UCHAR ;

#line 370
typedef USHORT ;

#line 371
typedef ULONG ;

#line 372
typedef UQUAD ;

#line 378
typedef signed char ;

#line 379
typedef SCHAR ;

#line 394
typedef void ;

#line 400
typedef HANDLE ;

#line 406
typedef UCHAR ;

#line 407
typedef USHORT ;

#line 408
typedef ULONG ;

#line 414
typedef LONG ;

#line 478
typedef char ;

#line 479
typedef short ;

#line 480
typedef ULONG ;

typedef CCHAR ;

#line 483
typedef CSHORT ;

#line 484
typedef CLONG ;

#line 492
typedef ULONG ;

#line 493
typedef PULONG ;

#line 494
typedef USHORT ;

#line 500
typedef ULONG ;

#line 501
typedef ULONG ;

#line 508
typedef LONG ;

typedef NTSTATUS ;

#line 602
typedef struct _FLOAT128 ;

#line 607
typedef FLOAT128 ;

#line 621
typedef __int64 ;

#line 622
typedef unsigned __int64 ;

#line 639
typedef LONGLONG ;

#line 640
typedef ULONGLONG ;

#line 644
typedef LONGLONG ;

#line 649
typedef union _LARGE_INTEGER ;

#line 662
typedef LARGE_INTEGER ;

#line 668
typedef union _ULARGE_INTEGER ;

#line 681
typedef ULARGE_INTEGER ;

#line 690
typedef struct _LUID ;

#line 696
typedef ULONGLONG ;

#line 697
typedef DWORDLONG ;

#line 707
typedef LARGE_INTEGER ;

#line 831

#pragma warning(push)

#pragma warning(disable:4035)
__inline ULONGLONG __stdcall Int64ShllMod32___12(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 842
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    
		};
}

#line 845
__inline LONGLONG __stdcall Int64ShraMod32___12(LONGLONG Value , ULONG
	ShiftCount )
{
	#line 852
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    
		};
}

#line 855
__inline ULONGLONG __stdcall Int64ShrlMod32___12(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 862
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    
		};
}


#pragma warning(pop)
#line 956
typedef enum _EVENT_TYPE ;

#line 965
typedef enum _TIMER_TYPE ;

#line 974
typedef enum _WAIT_TYPE ;

#line 983
typedef CHAR ;

#line 984
typedef const char ;

#line 991
typedef struct _STRING ;

#line 999
typedef STRING ;

typedef STRING ;

#line 1002
typedef PSTRING ;

typedef STRING ;

#line 1005
typedef PSTRING ;

#line 1011
typedef struct _CSTRING ;

#line 1016
typedef CSTRING ;

#line 1019
typedef STRING ;

#line 1020
typedef PSTRING ;

#line 1027
typedef struct _UNICODE_STRING ;

#line 1036
typedef UNICODE_STRING ;

#line 1037
typedef const UNICODE_STRING ;

#line 1046
typedef UCHAR ;

#line 1047
typedef BOOLEAN ;

#line 1057
typedef struct _LIST_ENTRY ;

#line 1067
typedef struct _SINGLE_LIST_ENTRY ;

#line 1078
typedef struct LIST_ENTRY32 ;

#line 1082
typedef LIST_ENTRY32 ;

typedef struct LIST_ENTRY64 ;

#line 1088
typedef LIST_ENTRY64 ;

#line 1127
typedef struct _STRING32 ;

#line 1132
typedef STRING32 ;

typedef STRING32 ;

#line 1135
typedef UNICODE_STRING32 ;

typedef STRING32 ;

#line 1138
typedef ANSI_STRING32 ;

#line 1141
typedef struct _STRING64 ;

#line 1146
typedef STRING64 ;

typedef STRING64 ;

#line 1149
typedef UNICODE_STRING64 ;

typedef STRING64 ;

#line 1152
typedef ANSI_STRING64 ;

#line 1173
typedef struct _OBJECT_ATTRIBUTES ;

#line 1181
typedef OBJECT_ATTRIBUTES ;

#line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID ;

#line 70
typedef GUID ;

#line 75
typedef const GUID ;

#line 81
typedef GUID ;

#line 82
typedef IID ;

#line 85
typedef GUID ;

#line 86
typedef CLSID ;

#line 89
typedef GUID ;

#line 90
typedef FMTID ;

#line 16 "C:/NTDDK/inc/string.h"

#pragma once
#line 1233 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECTID ;

#line 1288
struct _CONTEXT ;

#line 1289
struct _EXCEPTION_RECORD ;

typedef EXCEPTION_DISPOSITION ;

#line 1306
typedef UCHAR ;

typedef KIRQL ;

#line 1316
typedef enum _NT_PRODUCT_TYPE ;

#line 1329
typedef enum _SUITE_TYPE ;

#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD ;

#line 76
typedef struct _ETHREAD ;

#line 77
typedef struct _EPROCESS ;

#line 78
typedef struct _PEB ;

#line 79
typedef struct _KINTERRUPT ;

#line 80
typedef struct _IO_TIMER ;

#line 81
typedef struct _OBJECT_TYPE ;

#line 82
typedef struct _CALLBACK_OBJECT ;

#line 83
typedef struct _DEVICE_HANDLER_OBJECT ;

#line 84
typedef struct _BUS_HANDLER ;

#line 143
typedef union _SLIST_HEADER ;

#line 204
typedef CCHAR ;

typedef enum _MODE ;

#line 222
struct _KAPC ;

typedef void ;

#line 232
typedef void ;

#line 242
typedef void ;

#line 248
typedef BOOLEAN ;

#line 254
typedef BOOLEAN ;

#line 265
typedef struct _KAPC ;

#line 292
struct _KDPC ;

typedef void ;

#line 351
typedef enum _KDPC_IMPORTANCE ;

#line 361
typedef struct _KDPC ;

#line 377
typedef PVOID ;

typedef void ;

#line 392
typedef struct _KIPI_COUNTS ;

#line 443
typedef struct _MDL ;

#line 532
typedef PVOID ;

#line 538
typedef PVOID ;

#line 544
typedef PVOID ;

typedef ULONG ;

#line 547
typedef ACCESS_MASK ;

#line 597
typedef struct _GENERIC_MAPPING ;

#line 603
typedef GENERIC_MAPPING ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES ;

#line 622
typedef LUID_AND_ATTRIBUTES ;

#line 623
typedef LUID_AND_ATTRIBUTES_ARRAY ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 642 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACL ;

#line 649
typedef ACL ;

#line 681
typedef struct _PRIVILEGE_SET ;

#line 735
typedef enum _SECURITY_IMPERSONATION_LEVEL ;

#line 753
typedef BOOLEAN ;

#line 762
typedef struct _SECURITY_QUALITY_OF_SERVICE ;

#line 774
typedef struct _SE_IMPERSONATION_STATE ;

#line 782
typedef ULONG ;

#line 809
typedef ULONG ;

#line 810
typedef KAFFINITY ;

#line 816
typedef LONG ;

#line 824
typedef ULONG_PTR ;

#line 825
typedef KSPIN_LOCK ;

#line 833
typedef void ;

#line 842
typedef enum _KPROFILE_SOURCE ;

#line 1079
typedef NTSTATUS ;

#line 1088
typedef struct _RTL_QUERY_REGISTRY_TABLE ;

#line 1952

#pragma warning(push)

#pragma warning(disable:4035)
#line 2019

#pragma warning(pop)
#line 2214
typedef struct _TIME_FIELDS ;

#line 2224
typedef TIME_FIELDS ;

#line 2499
typedef struct _RTL_BITMAP ;

#line 2503
typedef RTL_BITMAP ;

#line 2627
typedef struct _RTL_BITMAP_RUN ;

#line 2633
typedef RTL_BITMAP_RUN ;

#line 2886
typedef struct _RTL_RANGE ;

#line 2924
typedef struct _RTL_RANGE_LIST ;

#line 2950
typedef struct _RANGE_LIST_ITERATOR ;

#line 3019
typedef BOOLEAN ;

#line 3155
typedef struct _OSVERSIONINFOA ;

#line 3164
typedef struct _OSVERSIONINFOW ;

#line 3177
typedef OSVERSIONINFOA ;

#line 3178
typedef POSVERSIONINFOA ;

#line 3179
typedef LPOSVERSIONINFOA ;

#line 3182
typedef struct _OSVERSIONINFOEXA ;

#line 3195
typedef struct _OSVERSIONINFOEXW ;

#line 3213
typedef OSVERSIONINFOEXA ;

#line 3214
typedef POSVERSIONINFOEXA ;

#line 3215
typedef LPOSVERSIONINFOEXA ;

#line 3648
typedef struct _IO_STATUS_BLOCK ;

#line 3669
typedef void ;

#line 3685
typedef enum _FILE_INFORMATION_CLASS ;

#line 3731
typedef struct _FILE_BASIC_INFORMATION ;

#line 3739
typedef struct _FILE_STANDARD_INFORMATION ;

#line 3747
typedef struct _FILE_POSITION_INFORMATION ;

#line 3751
typedef struct _FILE_ALIGNMENT_INFORMATION ;

#line 3755
typedef struct _FILE_NAME_INFORMATION ;

#line 3760
typedef struct _FILE_NETWORK_OPEN_INFORMATION ;

#line 3770
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION ;

#line 3775
typedef struct _FILE_DISPOSITION_INFORMATION ;

#line 3779
typedef struct _FILE_END_OF_FILE_INFORMATION ;

#line 3784
typedef struct _FILE_FULL_EA_INFORMATION ;

#line 3798
typedef enum _FSINFOCLASS ;

#line 3810
typedef struct _FILE_FS_DEVICE_INFORMATION ;

#line 3820
typedef union _FILE_SEGMENT_ELEMENT ;

#line 3829
typedef enum _INTERFACE_TYPE ;

#line 3854
typedef enum _DMA_WIDTH ;

#line 3865
typedef enum _DMA_SPEED ;

#line 3879
typedef void ;

#line 3880
typedef void ;

#line 3888
typedef enum _BUS_DATA_TYPE ;

#line 3910
typedef struct _IO_ERROR_LOG_PACKET ;

#line 3931
typedef struct _IO_ERROR_LOG_MESSAGE ;

#line 4074
typedef struct _KEY_BASIC_INFORMATION ;

#line 4081
typedef struct _KEY_NODE_INFORMATION ;

#line 4091
typedef struct _KEY_FULL_INFORMATION ;

#line 4106
typedef struct _KEY_NAME_INFORMATION ;

#line 4112
typedef enum _KEY_INFORMATION_CLASS ;

#line 4122
typedef struct _KEY_WRITE_TIME_INFORMATION ;

#line 4126
typedef enum _KEY_SET_INFORMATION_CLASS ;

#line 4134
typedef struct _KEY_VALUE_BASIC_INFORMATION ;

#line 4141
typedef struct _KEY_VALUE_FULL_INFORMATION ;

#line 4151
typedef struct _KEY_VALUE_PARTIAL_INFORMATION ;

#line 4158
typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ;

#line 4164
typedef struct _KEY_VALUE_ENTRY ;

#line 4171
typedef enum _KEY_VALUE_INFORMATION_CLASS ;

#line 4210
typedef struct _OBJECT_NAME_INFORMATION ;

#line 4221
typedef enum _SECTION_INHERIT ;

#line 4294
typedef struct _CLIENT_ID ;

#line 4298
typedef CLIENT_ID ;

#line 4315
typedef struct _NT_TIB ;

#line 4327
typedef NT_TIB ;

#line 4332
typedef enum _PROCESSINFOCLASS ;

#line 4366
typedef enum _THREADINFOCLASS ;

#line 4395
typedef struct _PROCESS_WS_WATCH_INFORMATION ;

#line 4405
typedef struct _PROCESS_BASIC_INFORMATION ;

#line 4413
typedef PROCESS_BASIC_INFORMATION ;

#line 4422
typedef struct _PROCESS_DEVICEMAP_INFORMATION ;

#line 4440
typedef struct _PROCESS_SESSION_INFORMATION ;

#line 4454
typedef struct _QUOTA_LIMITS ;

#line 4462
typedef QUOTA_LIMITS ;

#line 4472
typedef struct _IO_COUNTERS ;

#line 4480
typedef IO_COUNTERS ;

#line 4488
typedef struct _VM_COUNTERS ;

#line 4501
typedef VM_COUNTERS ;

#line 4508
typedef struct _POOLED_USAGE_AND_LIMITS ;

#line 4519
typedef POOLED_USAGE_AND_LIMITS ;

#line 4528
typedef struct _PROCESS_ACCESS_TOKEN ;

#line 4555
typedef struct _KERNEL_USER_TIMES ;

#line 4561
typedef KERNEL_USER_TIMES ;

#line 4587
typedef enum _SYSTEM_POWER_STATE ;

#line 4598
typedef enum  {
	PowerActionNone = 0,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
} ;

typedef enum _DEVICE_POWER_STATE ;

#line 4618
typedef union _POWER_STATE ;

#line 4623
typedef enum _POWER_STATE_TYPE ;

#line 4654
typedef ULONG ;

typedef enum  {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
} ;

#line 4663
typedef enum  {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation
} ;

#line 4690
typedef ULONG ;

typedef LONG ;

#line 4693
typedef ULONG ;

#line 4719
typedef union _MCI_STATS ;

#line 4978
typedef struct _KPCR ;

#line 5006
typedef KPCR ;

#line 5012
typedef struct _KFLOATING_SAVE ;

#line 5153
typedef enum _INTERLOCKED_RESULT ;

#line 5252

#pragma warning(disable:4035)
#line 6994
typedef struct _KSYSTEM_TIME ;

#line 7014

#pragma warning(push)

#pragma warning(disable:4164)
#line 7019

#pragma function(_enable)
#line 7020

#pragma function(_disable)
#line 7024

#pragma warning(pop)
#line 7085
typedef struct _FLOATING_SAVE_AREA ;

#line 7097
typedef FLOATING_SAVE_AREA ;

#line 7109
typedef struct _CONTEXT ;

#line 7197
typedef CONTEXT ;

#line 7826
typedef void ;

#line 7850
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ;

#line 7899
typedef struct _KUSER_SHARED_DATA ;

#line 8123
typedef enum _CM_SERVICE_NODE_TYPE ;

#line 8132
typedef enum _CM_SERVICE_LOAD_TYPE ;

#line 8140
typedef enum _CM_ERROR_CONTROL_TYPE ;

#line 8172
typedef int ;

#line 8198
typedef enum _CM_SHARE_DISPOSITION ;

#line 8211
typedef PVOID ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST ;

#line 8443
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR ;

#line 8454
typedef struct _CM_RESOURCE_LIST ;

#line 8471
typedef struct _DEVICE_FLAGS ;

#line 8485
typedef struct _CM_COMPONENT_INFORMATION ;

#line 8503
typedef struct _CM_ROM_BLOCK ;

#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 8518 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_INT13_DRIVE_PARAMETER ;

#line 8532
typedef struct _CM_MCA_POS_DATA ;

#line 8544
typedef struct _EISA_MEMORY_TYPE ;

#line 8554
typedef struct _EISA_MEMORY_CONFIGURATION ;

#line 8567
typedef struct _EISA_IRQ_DESCRIPTOR ;

#line 8575
typedef struct _EISA_IRQ_CONFIGURATION ;

#line 8585
typedef struct _DMA_CONFIGURATION_BYTE0 ;

#line 8592
typedef struct _DMA_CONFIGURATION_BYTE1 ;

#line 8599
typedef struct _EISA_DMA_CONFIGURATION ;

#line 8609
typedef struct _EISA_PORT_DESCRIPTOR ;

#line 8616
typedef struct _EISA_PORT_CONFIGURATION ;

#line 8628
typedef struct _CM_EISA_SLOT_INFORMATION ;

#line 8644
typedef struct _CM_EISA_FUNCTION_INFORMATION ;

#line 8678
typedef struct _CM_PNP_BIOS_DEVICE_NODE ;

#line 8692
typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8761 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_SCSI_DEVICE_DATA ;

#line 8775
typedef struct _CM_VIDEO_DEVICE_DATA ;

#line 8785
typedef struct _CM_SONIC_DEVICE_DATA ;

#line 8796
typedef struct _CM_SERIAL_DEVICE_DATA ;

#line 8810
typedef struct _CM_MONITOR_DEVICE_DATA ;

#line 8844
typedef struct _CM_FLOPPY_DEVICE_DATA ;

#line 8881
typedef struct _CM_KEYBOARD_DEVICE_DATA ;

#line 8893
typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA ;

#line 8905
typedef struct _CM_PCCARD_DEVICE_DATA ;

#line 8944
typedef struct _IO_RESOURCE_DESCRIPTOR ;

#line 9027
typedef struct _IO_RESOURCE_LIST ;

#line 9036
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST ;

#line 9065
typedef struct _EXCEPTION_RECORD ;

#line 9074
typedef EXCEPTION_RECORD ;

typedef struct _EXCEPTION_RECORD32 ;

#line 9085
typedef struct _EXCEPTION_RECORD64 ;

#line 9099
typedef struct _EXCEPTION_POINTERS ;

#line 9111
typedef enum _CONFIGURATION_TYPE ;

#line 9161
typedef enum _KINTERRUPT_MODE ;

#line 9170
typedef enum _KWAIT_REASON ;

#line 9207
typedef struct _DISPATCHER_HEADER ;

#line 9217
typedef struct _KWAIT_BLOCK ;

#line 9230
typedef void ;

#line 9244
typedef struct _KDEVICE_QUEUE ;

#line 9252
typedef struct _KDEVICE_QUEUE_ENTRY ;

#line 9263
typedef struct _KEVENT ;

#line 9271
typedef BOOLEAN ;

#line 9281
typedef struct _KMUTANT ;

#line 9294
typedef struct _KSEMAPHORE ;

#line 9304
typedef struct _KTIMER ;

#line 9899
typedef enum _KBUGCHECK_BUFFER_DUMP_STATE ;

#line 9907
typedef void ;

#line 9914
typedef struct _KBUGCHECK_CALLBACK_RECORD ;

#line 10002
typedef void ;

#line 10020
typedef LOGICAL ;

#line 10037
typedef void ;

#line 10053
typedef enum _MEMORY_CACHING_TYPE_ORIG ;

#line 10057
typedef enum _MEMORY_CACHING_TYPE ;

#line 10087
typedef struct _DBGKD_DEBUG_DATA_HEADER64 ;

#line 10115
typedef enum _POOL_TYPE ;

#line 10195
typedef enum _EX_POOL_PRIORITY ;

#line 10247
typedef struct _FAST_MUTEX ;

#line 10574
typedef PVOID ;

#line 10582
typedef void ;

#line 10588
typedef struct _GENERAL_LOOKASIDE ;

#line 10619
typedef struct _NPAGED_LOOKASIDE_LIST ;

#line 10729
typedef struct _PAGED_LOOKASIDE_LIST ;

#line 10882
typedef enum _WORK_QUEUE_TYPE ;

#line 10889
typedef void ;

#line 10895
typedef struct _WORK_QUEUE_ITEM ;

#line 10926
typedef struct _ZONE_SEGMENT_HEADER ;

#line 10931
typedef struct _ZONE_HEADER ;

#line 11156
typedef ULONG_PTR ;

#line 11157
typedef ERESOURCE_THREAD ;

typedef struct _OWNER_ENTRY ;

#line 11168
typedef struct _ERESOURCE ;

#line 11197
typedef struct _RESOURCE_HASH_ENTRY ;

#line 11204
typedef struct _RESOURCE_PERFORMANCE_DATA ;

#line 11429
typedef struct _CALLBACK_OBJECT ;

typedef void ;

#line 11474
typedef GUID ;

#line 11862
typedef enum _MM_SYSTEM_SIZE ;

#line 11884
typedef enum _LOCK_OPERATION ;

#line 11970
typedef enum _MM_PAGE_PRIORITY ;

#line 11999
typedef struct _PHYSICAL_MEMORY_RANGE ;

#line 12385
typedef NTSTATUS ;

#line 12389
typedef NTSTATUS ;

#line 12399
struct _DRIVER_OBJECT ;

#line 12411
typedef enum _SECURITY_OPERATION_CODE ;

#line 12426
typedef struct _SECURITY_SUBJECT_CONTEXT ;

#line 12448
typedef struct _INITIAL_PRIVILEGE_SET ;

#line 12462
typedef struct _ACCESS_STATE ;

#line 12571
typedef void ;

#line 12585
typedef void ;

#line 12602
typedef struct _IMAGE_INFO ;

#line 12620
typedef void ;

#line 12859
typedef NTSTATUS ;

#line 12878
typedef enum _IO_QUERY_DEVICE_DATA_FORMAT ;

#line 12890
typedef enum _CREATE_FILE_TYPE ;

#line 12905
struct _DEVICE_DESCRIPTION ;

#line 12906
struct _DEVICE_OBJECT ;

#line 12907
struct _DMA_ADAPTER ;

#line 12908
struct _DRIVER_OBJECT ;

#line 12909
struct _DRIVE_LAYOUT_INFORMATION ;

#line 12910
struct _DISK_PARTITION ;

#line 12911
struct _FILE_OBJECT ;

#line 12912
struct _IRP ;

#line 12913
struct _SCSI_REQUEST_BLOCK ;

#line 12919
typedef void ;

#line 12932
typedef void ;

#line 12943
typedef NTSTATUS ;

#line 12955
typedef void ;

#line 12968
typedef void ;

#line 12979
typedef NTSTATUS ;

#line 12990
typedef void ;

#line 13001
typedef void ;

#line 13011
typedef NTSTATUS ;

#line 13025
typedef BOOLEAN ;

#line 13038
typedef BOOLEAN ;

#line 13051
typedef BOOLEAN ;

#line 13068
typedef BOOLEAN ;

#line 13078
typedef BOOLEAN ;

#line 13092
typedef BOOLEAN ;

#line 13106
typedef BOOLEAN ;

#line 13118
typedef BOOLEAN ;

#line 13127
typedef BOOLEAN ;

#line 13141
typedef BOOLEAN ;

#line 13161
typedef void ;

#line 13167
typedef void ;

#line 13179
typedef void ;

#line 13193
typedef BOOLEAN ;

#line 13207
typedef BOOLEAN ;

#line 13219
typedef BOOLEAN ;

#line 13227
typedef BOOLEAN ;

#line 13239
typedef BOOLEAN ;

#line 13253
typedef NTSTATUS ;

#line 13262
typedef NTSTATUS ;

#line 13275
typedef NTSTATUS ;

#line 13282
typedef NTSTATUS ;

#line 13289
typedef BOOLEAN ;

#line 13304
typedef BOOLEAN ;

#line 13319
typedef BOOLEAN ;

#line 13327
typedef BOOLEAN ;

#line 13336
typedef BOOLEAN ;

#line 13350
typedef struct _FAST_IO_DISPATCH ;

#line 13386
typedef enum _IO_ALLOCATION_ACTION ;

#line 13396
typedef IO_ALLOCATION_ACTION ;

#line 13410
typedef struct _IO_SECURITY_CONTEXT ;

#line 13434
typedef struct _VPB ;

#line 13482
typedef struct _ADAPTER_OBJECT ;

#line 13491
typedef struct _WAIT_CONTEXT_BLOCK ;

#line 13503
typedef struct _CONTROLLER_OBJECT ;

#line 13537
typedef struct _DEVICE_OBJECT ;

#line 13575
typedef struct _DEVICE_OBJECT ;

#line 13578
struct _DEVICE_OBJECT_POWER_EXTENSION ;

typedef struct _DEVOBJ_EXTENSION ;

#line 13608
typedef struct _DRIVER_EXTENSION ;

#line 13645
typedef struct _DRIVER_OBJECT ;

#line 13706
typedef struct _DRIVER_OBJECT ;

#line 13715
typedef struct _SECTION_OBJECT_POINTERS ;

#line 13720
typedef SECTION_OBJECT_POINTERS ;

#line 13726
typedef struct _IO_COMPLETION_CONTEXT ;

#line 13759
typedef struct _FILE_OBJECT ;

#line 13788
typedef struct _FILE_OBJECT ;

#line 13828
typedef struct _IRP ;

#line 14078
typedef NTSTATUS ;

#line 14163
typedef enum _DEVICE_RELATION_TYPE ;

#line 14171
typedef struct _DEVICE_RELATIONS ;

#line 14176
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE ;

#line 14185
typedef struct _INTERFACE ;

#line 14196
typedef struct _DEVICE_CAPABILITIES ;

#line 14229
typedef struct _POWER_SEQUENCE ;

#line 14235
typedef enum  {
	BusQueryDeviceID = 0,
	BusQueryHardwareIDs = 1,
	BusQueryCompatibleIDs = 2,
	BusQueryInstanceID = 3,
	BusQueryDeviceSerialNumber = 4
} ;

typedef ULONG ;

#line 14252
typedef enum  {
	DeviceTextDescription = 0,
	DeviceTextLocationInformation = 1
} ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 14615 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SHARE_ACCESS ;

#line 14635
typedef struct _CONFIGURATION_INFORMATION ;

#line 14848
typedef struct _BOOTDISK_INFORMATION ;

#line 15754
typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK ;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK ;

#line 15764
typedef struct _IO_REMOVE_LOCK_DBG_BLOCK ;

#line 15777
typedef struct _IO_REMOVE_LOCK ;

#line 16009
typedef struct _IO_WORKITEM ;

typedef void ;

#line 16100
typedef enum  {
	DevicePropertyDeviceDescription,
	DevicePropertyHardwareID,
	DevicePropertyCompatibleIDs,
	DevicePropertyBootConfiguration,
	DevicePropertyBootConfigurationTranslated,
	DevicePropertyClassName,
	DevicePropertyClassGuid,
	DevicePropertyDriverKeyName,
	DevicePropertyManufacturer,
	DevicePropertyFriendlyName,
	DevicePropertyLocationInformation,
	DevicePropertyPhysicalDeviceObjectName,
	DevicePropertyBusTypeGuid,
	DevicePropertyLegacyBusType,
	DevicePropertyBusNumber,
	DevicePropertyEnumeratorName,
	DevicePropertyAddress,
	DevicePropertyUINumber
} ;

typedef BOOLEAN ;

#line 16129
typedef struct _DMA_ADAPTER ;

#line 16135
typedef ULONG ;

#line 16148
typedef struct _PNP_BUS_INFORMATION ;

#line 16162
typedef struct _LEGACY_BUS_INFORMATION ;

#line 16168
typedef struct _BUS_INTERFACE_STANDARD ;

#line 16190
typedef BOOLEAN ;

#line 16194
typedef NTSTATUS ;

#line 16203
typedef NTSTATUS ;

#line 16206
typedef NTSTATUS ;

#line 16210
typedef NTSTATUS ;

#line 16214
typedef NTSTATUS ;

#line 16218
typedef void ;

#line 16222
typedef NTSTATUS ;

#line 16227
typedef void ;

#line 16231
typedef struct _ACPI_INTERFACE_STANDARD ;

#line 16255
typedef enum _ACPI_REG_TYPE ;

#line 16268
typedef USHORT ;

#line 16272
typedef void ;

#line 16278
typedef struct ACPI_REGS_INTERFACE_STANDARD ;

#line 16300
typedef struct  {
	PVOID LinkNode ;
	ULONG StaticVector ;
	UCHAR Flags ;
} ;

#line 16314
typedef NTSTATUS ;

#line 16329
typedef NTSTATUS ;

#line 16336
typedef void ;

#line 16343
typedef struct _INT_ROUTE_INTERFACE_STANDARD ;

#line 16366
typedef struct _IO_ASSIGNED_RESOURCES ;

#line 16490
typedef enum _IO_NOTIFICATION_EVENT_CATEGORY ;

#line 16504
typedef NTSTATUS ;

#line 16537
typedef void ;

#line 16573
typedef enum _ARBITER_ACTION ;

#line 16586
typedef struct _ARBITER_CONFLICT_INFO ;

#line 16608
typedef struct _ARBITER_PARAMETERS ;

#line 16719
typedef enum _ARBITER_REQUEST_SOURCE ;

#line 16731
typedef enum _ARBITER_RESULT ;

#line 16761
typedef struct _ARBITER_LIST_ENTRY ;

#line 16832
typedef NTSTATUS ;

#line 16853
typedef struct _ARBITER_INTERFACE ;

#line 16880
typedef enum _RESOURCE_TRANSLATION_DIRECTION ;

#line 16889
typedef NTSTATUS ;

#line 16901
typedef NTSTATUS ;

#line 16915
typedef struct _TRANSLATOR_INTERFACE ;

#line 16931
typedef NTSTATUS ;

#line 16945
typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE ;

#line 16959
typedef struct _PLUGPLAY_NOTIFICATION_HEADER ;

#line 16972
typedef struct _HWPROFILE_CHANGE_NOTIFICATION ;

#line 16986
typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION ;

#line 17006
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION ;

#line 17026
typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION ;

#line 17054
typedef struct _DEVICE_DESCRIPTION ;

#line 17086
typedef BOOLEAN ;

#line 17333
typedef void ;

#line 17339
typedef struct _DEVICE_CONTROL_CONTEXT ;

#line 17349
typedef PBUS_HANDLER ;

#line 17355
typedef void ;

#line 17365
typedef enum _HAL_QUERY_INFORMATION_CLASS ;

#line 17381
typedef enum _HAL_SET_INFORMATION_CLASS ;

#line 17388
typedef NTSTATUS ;

#line 17405
typedef NTSTATUS ;

#line 17420
typedef void ;

#line 17429
typedef void ;

#line 17438
typedef NTSTATUS ;

#line 17447
typedef NTSTATUS ;

#line 17456
typedef NTSTATUS ;

#line 17466
typedef NTSTATUS ;

#line 17475
typedef NTSTATUS ;

#line 17486
typedef struct _PM_DISPATCH_TABLE ;

#line 17492
typedef NTSTATUS ;

#line 17505
typedef struct _DMA_ADAPTER ;

#line 17520
typedef NTSTATUS ;

#line 17543
typedef BOOLEAN ;

#line 17553
typedef NTSTATUS ;

#line 17566
typedef void ;

#line 17572
typedef void ;

#line 17578
typedef BOOLEAN ;

#line 17588
typedef struct  {
	ULONG Version ;
	pHalQuerySystemInformation HalQuerySystemInformation ;
	pHalSetSystemInformation HalSetSystemInformation ;
	pHalQueryBusSlots HalQueryBusSlots ;
	ULONG Spare1 ;
	pHalExamineMBR HalExamineMBR ;
	pHalIoAssignDriveLetters HalIoAssignDriveLetters ;
	pHalIoReadPartitionTable HalIoReadPartitionTable ;
	pHalIoSetPartitionInformation HalIoSetPartitionInformation ;
	pHalIoWritePartitionTable HalIoWritePartitionTable ;
	pHalHandlerForBus HalReferenceHandlerForBus ;
	pHalReferenceBusHandler HalReferenceBusHandler ;
	pHalReferenceBusHandler HalDereferenceBusHandler ;
	pHalInitPnpDriver HalInitPnpDriver ;
	pHalInitPowerManagement HalInitPowerManagement ;
	pHalGetDmaAdapter HalGetDmaAdapter ;
	pHalGetInterruptTranslator HalGetInterruptTranslator ;
} ;

#line 17650
typedef struct _HAL_BUS_INFORMATION ;

#line 17658
typedef struct _HAL_PROFILE_SOURCE_INFORMATION ;

#line 17665
typedef struct _HAL_PROFILE_SOURCE_INTERVAL ;

#line 17671
typedef enum _HAL_DISPLAY_BIOS_INFORMATION ;

#line 17678
typedef struct _HAL_POWER_INFORMATION ;

#line 17683
typedef struct _HAL_PROCESSOR_SPEED_INFO ;

#line 17688
typedef struct _HAL_CALLBACKS ;

#line 17694
typedef struct _HAL_PROCESSOR_FEATURE ;

#line 17706
typedef union _MCI_ADDR ;

#line 17716
typedef enum  {
	HAL_MCE_RECORD,
	HAL_MCA_RECORD
} ;

#line 17726
typedef struct _MCA_EXCEPTION ;

#line 17752
typedef void ;

#line 17762
typedef struct _MCA_DRIVER_INFO ;

#line 17772
typedef struct _SCATTER_GATHER_ELEMENT ;

#line 17778

#pragma warning(disable:4200)
#line 17779
typedef struct _SCATTER_GATHER_LIST ;

#line 17784

#pragma warning(default:4200)
#line 17788
typedef struct _DMA_OPERATIONS ;

typedef struct _DMA_ADAPTER ;

#line 17797
typedef void ;

#line 17801
typedef PVOID ;

#line 17808
typedef void ;

#line 17816
typedef NTSTATUS ;

#line 17824
typedef BOOLEAN ;

#line 17833
typedef void ;

#line 17837
typedef void ;

#line 17843
typedef PHYSICAL_ADDRESS ;

#line 17852
typedef ULONG ;

#line 17856
typedef ULONG ;

#line 17860
typedef void ;

#line 17868
typedef NTSTATUS ;

#line 17880
typedef void ;

#line 17887
typedef struct _DMA_OPERATIONS ;

#line 18235
typedef void ;

#line 18321
typedef struct _OBJECT_HANDLE_INFORMATION ;

#line 18402
typedef struct _PCI_SLOT_NUMBER ;

#line 18418
typedef struct _PCI_COMMON_CONFIG ;

#line 18591
typedef struct _PCI_CAPABILITIES_HEADER ;

#line 18600
typedef struct _PCI_PMC ;

#line 18618
typedef struct _PCI_PMCSR ;

#line 18628
typedef struct _PCI_PMCSR_BSE ;

#line 18635
typedef struct _PCI_PM_CAPABILITY ;

#line 18679
typedef struct _PCI_AGP_CAPABILITY ;

#line 18720
typedef struct _PCI_MSI_CAPABILITY ;

#line 18946
typedef void ;

#line 18954
typedef void ;

#line 18963
typedef void ;

#line 18975
typedef struct _PCIBUSDATA ;

#line 18986
typedef ULONG ;

#line 18995
typedef void ;

#line 19000
typedef void ;

#line 19006
typedef struct _PCI_BUS_INTERFACE_STANDARD ;

#line 19028
typedef BOOLEAN ;

#line 19043
typedef struct _PCI_DEVICE_PRESENT_INTERFACE ;

#line 127 "C:/NTDDK/inc/ntddser.h"
typedef struct _SERIALPERF_STATS ;

#line 136
typedef struct _SERIALCONFIG ;

#line 154
typedef struct _SERIAL_LINE_CONTROL ;

#line 160
typedef struct _SERIAL_TIMEOUTS ;

#line 175
typedef struct _SERIAL_QUEUE_SIZE ;

#line 185
typedef struct _SERIAL_BAUD_RATE ;

#line 247
typedef struct _SERIAL_CHARS ;

#line 284
typedef struct _SERIAL_HANDFLOW ;

#line 340
typedef struct _SERIAL_BASIC_SETTINGS ;

#line 353
typedef struct _SERIAL_STATUS ;

#line 433
typedef struct _SERIAL_XOFF_COUNTER ;

#line 539
typedef struct _SERIAL_COMMPROP ;

#line 631
typedef struct _SERENUM_PORT_DESC ;

#line 652
typedef UCHAR ;

#line 658
typedef void ;

#line 665
typedef enum _SERENUM_PORTION ;

#line 671
typedef struct _SERENUM_PORT_PARAMETERS ;

#line 28 "C:/NTDDK/inc/ddk/wdm/wmilib.h"

#pragma once
#line 38
typedef struct  {
	LPCGUID Guid ;
	ULONG InstanceCount ;
	ULONG Flags ;
} ;

#line 45
typedef NTSTATUS ;

#line 101
typedef NTSTATUS ;

#line 162
typedef NTSTATUS ;

#line 206
typedef NTSTATUS ;

#line 253
typedef NTSTATUS ;

#line 306
typedef enum  {
	WmiEventControl,
	WmiDataBlockControl
} ;

#line 312
typedef NTSTATUS ;

#line 355
typedef struct _WMILIB_CONTEXT ;

#line 411
typedef enum  {
	IrpProcessed,
	IrpNotCompleted,
	IrpNotWmi,
	IrpForward
} ;

#line 13 "C:/NTDDK/inc/wmidata.h"
typedef struct _MSWmi_MofData ;

#line 51
typedef struct _MSWmi_ProviderInfo ;

#line 66
typedef struct _MSWmi_PnPDeviceId ;

#line 83
typedef struct _MSWmi_PnPInstanceNames ;

#line 105
typedef struct _MSSmBios_RawSMBiosTables ;

#line 147
typedef struct _MSPower_DeviceEnable ;

#line 165
typedef struct _MSPower_DeviceWakeEnable ;

#line 182
typedef struct _MSNdis_NetworkAddress ;

#line 199
typedef struct _MSNdis_NetworkShortAddress ;

#line 216
typedef struct _MSNdis_NetworkLinkSpeed ;

#line 239
typedef struct _MSNdis_EnumerateAdapter ;

#line 256
typedef struct _MSNdis_NotifyAdapterRemoval ;

#line 273
typedef struct _MSNdis_NotifyAdapterArrival ;

#line 291
typedef struct _MSNdis_NdisEnumerateVc ;

#line 307
typedef struct _MSNdis_NotifyVcRemoval ;

#line 323
typedef struct _MSNdis_NotifyVcArrival ;

#line 338
typedef struct _MSNdis_HardwareStatus ;

#line 356
typedef struct _MSNdis_MediaSupported ;

#line 378
typedef struct _MSNdis_MediaInUse ;

#line 400
typedef struct _MSNdis_MaximumLookahead ;

#line 418
typedef struct _MSNdis_MaximumFrameSize ;

#line 436
typedef struct _MSNdis_LinkSpeed ;

#line 454
typedef struct _MSNdis_TransmitBufferSpace ;

#line 472
typedef struct _MSNdis_ReceiveBufferSpace ;

#line 490
typedef struct _MSNdis_TransmitBlockSize ;

#line 508
typedef struct _MSNdis_ReceiveBlockSize ;

#line 526
typedef struct _MSNdis_VendorID ;

#line 544
typedef struct _MSNdis_VendorDescription ;

#line 561
typedef struct _MSNdis_CurrentPacketFilter ;

#line 579
typedef struct _MSNdis_CurrentLookahead ;

#line 597
typedef struct _MSNdis_DriverVersion ;

#line 615
typedef struct _MSNdis_MaximumTotalSize ;

#line 633
typedef struct _MSNdis_MacOptions ;

#line 651
typedef struct _MSNdis_MediaConnectStatus ;

#line 669
typedef struct _MSNdis_MaximumSendPackets ;

#line 687
typedef struct _MSNdis_VendorDriverVersion ;

#line 705
typedef struct _MSNdis_TransmitsOk ;

#line 723
typedef struct _MSNdis_ReceivesOk ;

#line 741
typedef struct _MSNdis_TransmitsError ;

#line 759
typedef struct _MSNdis_ReceiveError ;

#line 777
typedef struct _MSNdis_ReceiveNoBuffer ;

#line 795
typedef struct _MSNdis_CoHardwareStatus ;

#line 813
typedef struct _MSNdis_CoMediaSupported ;

#line 835
typedef struct _MSNdis_CoMediaInUse ;

#line 857
typedef struct _MSNdis_CoLinkSpeed ;

#line 875
typedef struct _MSNdis_CoVendorId ;

#line 893
typedef struct _MSNdis_CoVendorDescription ;

#line 910
typedef struct _MSNdis_CoDriverVersion ;

#line 928
typedef struct _MSNdis_CoMacOptions ;

#line 946
typedef struct _MSNdis_CoMediaConnectStatus ;

#line 964
typedef struct _MSNdis_CoVendorDriverVersion ;

#line 982
typedef struct _MSNdis_CoMinimumLinkSpeed ;

#line 1000
typedef struct _MSNdis_CoTransmitPdusOk ;

#line 1018
typedef struct _MSNdis_CoReceivePdusOk ;

#line 1036
typedef struct _MSNdis_CoTransmitPduErrors ;

#line 1054
typedef struct _MSNdis_CoReceivePduErrors ;

#line 1072
typedef struct _MSNdis_CoReceivePdusNoBuffer ;

#line 1090
typedef struct _MSNdis_AtmSupportedVcRates ;

#line 1113
typedef struct _MSNdis_AtmSupportedServiceCategory ;

#line 1131
typedef struct _MSNdis_AtmSupportedAalTypes ;

#line 1149
typedef struct _MSNdis_AtmHardwareCurrentAddress ;

#line 1167
typedef struct _MSNdis_AtmMaxActiveVcs ;

#line 1185
typedef struct _MSNdis_AtmMaxActiveVciBits ;

#line 1203
typedef struct _MSNdis_AtmMaxActiveVpiBits ;

#line 1221
typedef struct _MSNdis_AtmMaxAal0PacketSize ;

#line 1239
typedef struct _MSNdis_AtmMaxAal1PacketSize ;

#line 1257
typedef struct _MSNdis_AtmMaxAal34PacketSize ;

#line 1275
typedef struct _MSNdis_AtmMaxAal5PacketSize ;

#line 1293
typedef struct _MSNdis_AtmReceiveCellsOk ;

#line 1311
typedef struct _MSNdis_AtmTransmitCellsOk ;

#line 1329
typedef struct _MSNdis_AtmReceiveCellsDropped ;

#line 1347
typedef struct _MSNdis_EthernetPermanentAddress ;

#line 1365
typedef struct _MSNdis_EthernetCurrentAddress ;

#line 1383
typedef struct _MSNdis_EthernetMulticastList ;

#line 1405
typedef struct _MSNdis_EthernetMaximumMulticastListSize ;

#line 1423
typedef struct _MSNdis_EthernetMacOptions ;

#line 1441
typedef struct _MSNdis_EthernetReceiveErrorAlignment ;

#line 1459
typedef struct _MSNdis_EthernetOneTransmitCollision ;

#line 1477
typedef struct _MSNdis_EthernetMoreTransmitCollisions ;

#line 1495
typedef struct _MSNdis_TokenRingPermanentAddress ;

#line 1513
typedef struct _MSNdis_TokenRingCurrentAddress ;

#line 1531
typedef struct _MSNdis_TokenRingCurrentFunctional ;

#line 1549
typedef struct _MSNdis_TokenRingCurrentGroup ;

#line 1567
typedef struct _MSNdis_TokenRingLastOpenStatus ;

#line 1585
typedef struct _MSNdis_TokenRingCurrentRingStatus ;

#line 1603
typedef struct _MSNdis_TokenRingCurrentRingState ;

#line 1621
typedef struct _MSNdis_TokenRingLineErrors ;

#line 1639
typedef struct _MSNdis_TokenRingLostFrames ;

#line 1657
typedef struct _MSNdis_FddiLongPermanentAddress ;

#line 1675
typedef struct _MSNdis_FddiLongCurrentAddress ;

#line 1693
typedef struct _MSNdis_FddiLongMulticastList ;

#line 1715
typedef struct _MSNdis_FddiLongMaximumListSize ;

#line 1733
typedef struct _MSNdis_FddiShortPermanentAddress ;

#line 1751
typedef struct _MSNdis_FddiShortCurrentAddress ;

#line 1769
typedef struct _MSNdis_FddiShortMulticastList ;

#line 1791
typedef struct _MSNdis_FddiShortMaximumListSize ;

#line 1809
typedef struct _MSNdis_FddiAttachmentType ;

#line 1827
typedef struct _MSNdis_FddiUpstreamNodeLong ;

#line 1845
typedef struct _MSNdis_FddiDownstreamNodeLong ;

#line 1863
typedef struct _MSNdis_FddiFrameErrors ;

#line 1881
typedef struct _MSNdis_FddiFramesLost ;

#line 1899
typedef struct _MSNdis_FddiRingManagmentState ;

#line 1917
typedef struct _MSNdis_FddiLctFailures ;

#line 1935
typedef struct _MSNdis_FddiLemRejects ;

#line 1953
typedef struct _MSNdis_FddiLConnectionState ;

#line 1972
typedef struct _MSNdis_StatusResetStart ;

#line 1988
typedef struct _MSNdis_StatusResetEnd ;

#line 2004
typedef struct _MSNdis_StatusMediaConnect ;

#line 2020
typedef struct _MSNdis_StatusMediaDisconnect ;

#line 2035
typedef struct _MSNdis_StatusMediaSpecificIndication ;

#line 2057
typedef struct _MSNdis_StatusLinkSpeedChange ;

#line 2075
typedef struct _MSNdis_StatusProtocolBind ;

#line 2092
typedef struct _MSNdis_StatusProtocolUnbind ;

#line 2109
typedef struct _KEYBOARD_PORT_WMI_STD_DATA ;

#line 2152
typedef struct _POINTER_PORT_WMI_STD_DATA ;

#line 2205
typedef struct _MSMouse_ClassInformation ;

#line 2223
typedef struct _MSKeyboard_ClassInformation ;

#line 2241
typedef struct _MSAcpi_ThermalZoneTemperature ;

#line 2304
typedef struct _WMI_DISK_GEOMETRY ;

#line 2342
typedef struct _WMI_DISK_PERFORMANCE ;

#line 2415
typedef struct _MSDiskDriver_Performance ;

#line 2437
typedef struct _STORAGE_FAILURE_PREDICT_STATUS ;

#line 2460
typedef struct _STORAGE_FAILURE_PREDICT_DATA ;

#line 2483
typedef struct _STORAGE_FAILURE_PREDICT_EVENT ;

#line 2513
typedef struct _STORAGE_FAILURE_PREDICT_FUNCTION ;

#line 2528
typedef struct _MSIde_PortDeviceInfo ;

#line 2556
typedef struct _MSSerial_PortName ;

#line 2573
typedef struct _SERIAL_WMI_COMM_DATA ;

#line 2723
typedef struct _SERIAL_WMI_HW_DATA ;

#line 2770
typedef struct _SERIAL_WMI_PERF_DATA ;

#line 2813
typedef struct _SERIAL_WMI_COMMPROP ;

#line 2920
typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS ;

#line 2943
typedef struct _PARALLEL_WMI_LOG_INFO ;

#line 3041
typedef struct _REDBOOK_WMI_STD_DATA ;

#line 3094
typedef struct _REDBOOK_WMI_PERF_DATA ;

#line 3137
typedef struct _RegisteredGuids ;

#line 475 "serial.h"
typedef struct _CONFIG_DATA ;

#line 509
typedef struct _SERIAL_CISR_SW ;

#line 520
typedef struct _SERIAL_FIRMWARE_DATA ;

#line 576
typedef struct _SERIAL_DEVICE_STATE ;

#line 646
typedef struct _SERIAL_DEVICE_EXTENSION ;

#line 1808
typedef struct _SERIAL_MULTIPORT_DISPATCH ;

#line 2157
typedef enum _SERIAL_MEM_COMPARES ;

#line 2164
typedef struct _SERIAL_LIST_DATA ;

#line 2169
typedef struct _SERIAL_GLOBALS ;

#line 2180
typedef struct _SERIAL_USER_DATA ;

#line 2206
typedef struct _SERIAL_PTR_CTX ;

#line 20 "serialp.h"
typedef NTSTATUS ;

#line 26
typedef void ;

#line 835
typedef struct _SERIAL_UPDATE_CHAR ;

#line 846
typedef struct _SERIAL_IOCTL_SYNC ;

#line 29 "waitmask.c"
BOOLEAN SerialGrabWaitFromIsr(PVOID Context ) ;
#line 34
BOOLEAN SerialGiveWaitToIsr(PVOID Context ) ;
#line 39
BOOLEAN SerialFinishOldWait(PVOID Context ) ;

#line 45

#pragma alloc_text(PAGESER, SerialStartMask)
#line 46

#pragma alloc_text(PAGESER, SerialCancelWait)
#line 47

#pragma alloc_text(PAGESER, SerialGrabWaitFromIsr)
#line 48

#pragma alloc_text(PAGESER, SerialGiveWaitToIsr)
#line 49

#pragma alloc_text(PAGESER, SerialFinishOldWait)
#line 53
NTSTATUS SerialStartMask(PSERIAL_DEVICE_EXTENSION Extension )
{
	#line 87
	PIO_STACK_LOCATION IrpSp ;
	#line 89
	PIRP NewIrp ;
	#line 91
	BOOLEAN SetFirstStatus = 0;
	NTSTATUS FirstStatus ;
	#line 94
	;
	#line 99
	do
	{
		#line 99
		;
	}
	while(0);
	#line 101
	;
	#line 103
	do
	{
		#line 108
		do
		{
			#line 108
			;
		}
		while(0);
		#line 109
		IrpSp =
			(((Extension->CurrentMaskIrp)->Tail).Overlay).CurrentStackLocation;
		#line 114
		;
		#line 116
		if(((IrpSp->Parameters).DeviceIoControl).IoControlCode ==
			(0x0000001b << 16 | 0 << 14 | 17 << 2 | 0))
		{
			#line 122
			do
			{
				#line 122
				;
			}
			while(0);
			#line 128
			KeSynchronizeExecution(Extension->Interrupt,
				SerialFinishOldWait, Extension);
			#line 140
			;
			#line 142
			((Extension->CurrentMaskIrp)->IoStatus).Status =
				(NTSTATUS )0x00000000L;
			if(! SetFirstStatus)
			{
				#line 150
				do
				{
					#line 150
					;
				}
				while(0);
				#line 151
				FirstStatus = (NTSTATUS )0x00000000L;
				SetFirstStatus = 1;
			}
			#line 161
			SerialGetNextIrp(& Extension->CurrentMaskIrp, &
				Extension->MaskQueue, & NewIrp, 1, Extension);
			#line 173
			do
			{
				#line 173
				;
			}
			while(0);
		}
		else
		{
			#line 184
			if(! Extension->IsrWaitMask ||
				Extension->CurrentWaitIrp)
			{
				#line 193
				do
				{
					#line 193
					;
				}
				while(0);
				#line 195
				((Extension->CurrentMaskIrp)->IoStatus).Status =
					(NTSTATUS )0xC000000DL;
				if(! SetFirstStatus)
				{
					#line 203
					do
					{
						#line 203
						;
					}
					while(0);
					#line 204
					FirstStatus = (NTSTATUS )0xC000000DL;
					SetFirstStatus = 1;
				}
				#line 209
				SerialGetNextIrp(& Extension->CurrentMaskIrp, &
					Extension->MaskQueue, & NewIrp, 1,
					Extension);
				#line 221
				do
				{
					#line 221
					;
				}
				while(0);
			}
			else
			{
				#line 225
				KIRQL OldIrql ;
				#line 239
				IoAcquireCancelSpinLock(& OldIrql);
				#line 241
				if((Extension->CurrentMaskIrp)->Cancel)
				{
					#line 247
					do
					{
						#line 247
						;
					}
					while(0);
					#line 248
					IoReleaseCancelSpinLock(OldIrql);
					((Extension->CurrentMaskIrp)->IoStatus).Status
						= (NTSTATUS )0xC0000120L;
					if(! SetFirstStatus)
					{
						#line 257
						do
						{
							#line 257
							;
						}
						while(0);
						#line 258
						FirstStatus = (NTSTATUS
							)0xC0000120L;
						#line 259
						SetFirstStatus = 1;
					}
					#line 263
					SerialGetNextIrp(&
						Extension->CurrentMaskIrp, &
						Extension->MaskQueue, & NewIrp,
						1, Extension);
					#line 275
					do
					{
						#line 275
						;
					}
					while(0);
				}
				else
				{
					#line 283
					do
					{
						#line 283
						;
					}
					while(0);
					#line 284
					if(! SetFirstStatus)
					{
						#line 290
						do
						{
							#line 290
							;
						}
						while(0);
						#line 291
						FirstStatus = (NTSTATUS
							)0x00000103L;
						#line 292
						SetFirstStatus = 1;
						#line 300
						if(pending == 0)
							#line 300
							pending = 1;
						else
							#line 300
							errorFn();
						((((Extension->CurrentMaskIrp)->Tail
							).Overlay).CurrentStackLocation
							)->Control |= 0x01;
					}
					#line 311
					;
					;
					#line 314
					Extension->CurrentWaitIrp =
						Extension->CurrentMaskIrp;
					{
						#line 315
						;
						#line 315
						((((((Extension->CurrentWaitIrp)
							->Tail).Overlay).CurrentStackLocation
							)->Parameters).Others).Argument4
							= (void *  )0;
					}
					#line 315
					;
					#line 319
					(PDRIVER_CANCEL )((PVOID
						)InterlockedExchange((PLONG
						)((PVOID *  )(&
						(Extension->CurrentWaitIrp)->CancelRoutine
						)), (LONG )((PVOID
						)SerialCancelWait)));
					#line 330
					do
					{
						#line 330
						LONG _refType = 0x00000002;
						#line 330
						PULONG_PTR _arg4 = (PVOID )(&
							((((((Extension->CurrentWaitIrp
							)->Tail).Overlay).CurrentStackLocation
							)->Parameters).Others).Argument4
							);
						#line 330
						;
						#line 330
						* _arg4 |= _refType;
					}
					while(0);
					#line 332
					KeSynchronizeExecution(Extension->Interrupt
						, SerialGiveWaitToIsr,
						Extension);
					#line 343
					Extension->CurrentMaskIrp = (void *  )0;
					#line 349
					SerialGetNextIrpLocked(&
						Extension->CurrentMaskIrp, &
						Extension->MaskQueue, & NewIrp,
						0, Extension, OldIrql);
					#line 362
					do
					{
						#line 362
						;
					}
					while(0);
				}
			}
		}
	}
	while(NewIrp);
	#line 372
	return FirstStatus;
}

#line 376
BOOLEAN SerialGrabWaitFromIsr(PVOID Context )
{
	#line 405
	PSERIAL_DEVICE_EXTENSION Extension = Context;
	;
	#line 411
	do
	{
		#line 411
		;
	}
	while(0);
	#line 413
	if(Extension->IrpMaskLocation)
	{
		#line 421
		do
		{
			#line 421
			;
		}
		while(0);
		#line 427
		* Extension->IrpMaskLocation = 0;
		Extension->IrpMaskLocation = (void *  )0;
		#line 430
		((Extension->CurrentWaitIrp)->IoStatus).Information =
			sizeof(ULONG );
		#line 440
		do
		{
			#line 440
			LONG _refType = 0x00000001;
			#line 440
			PULONG_PTR _arg4 = (PVOID )(&
				((((((Extension->CurrentWaitIrp)->Tail).Overlay)
				.CurrentStackLocation)->Parameters).Others).Argument4
				);
			#line 440
			;
			#line 440
			* _arg4 &= ~ _refType;
		}
		while(0);
	}
	return 0;
}

BOOLEAN SerialGiveWaitToIsr(PVOID Context )
{
	#line 476
	PSERIAL_DEVICE_EXTENSION Extension = Context;
	;
	#line 482
	do
	{
		#line 482
		;
	}
	while(0);
	#line 488
	;
	#line 500
	do
	{
		#line 500
		LONG _refType = 0x00000001;
		#line 500
		PULONG_PTR _arg4 = (PVOID )(&
			((((((Extension->CurrentWaitIrp)->Tail).Overlay).CurrentStackLocation
			)->Parameters).Others).Argument4);
		#line 500
		;
		#line 500
		* _arg4 |= _refType;
	}
	while(0);
	#line 502
	if(! Extension->HistoryMask)
	{
		#line 507
		do
		{
			#line 507
			;
		}
		while(0);
		#line 514
		Extension->EmptiedTransmit = 0;
		#line 520
		Extension->IrpMaskLocation =
			((Extension->CurrentWaitIrp)->AssociatedIrp).SystemBuffer
			;
		#line 528
		do
		{
			#line 528
			;
		}
		while(0);
	}
	else
	{
		#line 537
		do
		{
			#line 537
			;
		}
		while(0);
		#line 538
		* (ULONG * 
			)((Extension->CurrentWaitIrp)->AssociatedIrp).SystemBuffer
			= Extension->HistoryMask;
		#line 540
		Extension->HistoryMask = 0;
		((Extension->CurrentWaitIrp)->IoStatus).Information =
			sizeof(ULONG );
		#line 542
		((Extension->CurrentWaitIrp)->IoStatus).Status = (NTSTATUS
			)0x00000000L;
		SerialInsertQueueDpc(& Extension->CommWaitDpc, (void *  )0,
			(void *  )0, Extension);
	}
	#line 553
	return 0;
}

BOOLEAN SerialFinishOldWait(PVOID Context )
{
	#line 585
	PSERIAL_DEVICE_EXTENSION Extension = Context;
	;
	#line 591
	do
	{
		#line 591
		;
	}
	while(0);
	#line 592
	if(Extension->IrpMaskLocation)
	{
		#line 600
		do
		{
			#line 600
			;
		}
		while(0);
		#line 605
		* Extension->IrpMaskLocation = 0;
		Extension->IrpMaskLocation = (void *  )0;
		#line 608
		((Extension->CurrentWaitIrp)->IoStatus).Information =
			sizeof(ULONG );
		#line 615
		SerialInsertQueueDpc(& Extension->CommWaitDpc, (void *  )0,
			(void *  )0, Extension);
	}
	#line 628
	Extension->HistoryMask &= * (ULONG * 
		)((Extension->CurrentMaskIrp)->AssociatedIrp).SystemBuffer;
	#line 631
	Extension->IsrWaitMask = * (ULONG * 
		)((Extension->CurrentMaskIrp)->AssociatedIrp).SystemBuffer;
	#line 638
	do
	{
		#line 638
		;
	}
	while(0);
	#line 639
	return 0;
}

void SerialCancelWait(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
	#line 669
	PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
	;
	#line 675
	do
	{
		#line 675
		;
	}
	while(0);
	#line 680
	do
	{
		#line 680
		;
	}
	while(0);
	#line 681
	SerialTryToCompleteCurrent(Extension, SerialGrabWaitFromIsr,
		Irp->CancelIrql, (NTSTATUS )0xC0000120L, &
		Extension->CurrentWaitIrp, (void *  )0, (void *  )0, (void * 
		)0, (void *  )0, (void *  )0, 0x00000002);
}

#line 697
void SerialCompleteWait(PKDPC Dpc , PVOID DeferredContext , PVOID SystemContext1
	, PVOID SystemContext2 )
{
	#line 707
	PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
	KIRQL OldIrql ;
	#line 711
	do
	{
		#line 711
		;
	}
	while(0);
	#line 716
	do
	{
		#line 716
		;
	}
	while(0);
	#line 717
	SystemContext1;
	SystemContext2;
	#line 720
	IoAcquireCancelSpinLock(& OldIrql);
	#line 725
	do
	{
		#line 725
		;
	}
	while(0);
	#line 726
	SerialTryToCompleteCurrent(Extension, (void *  )0, OldIrql, (NTSTATUS
		)0x00000000L, & Extension->CurrentWaitIrp, (void *  )0, (void * 
		)0, (void *  )0, (void *  )0, (void *  )0, 0x00000001);
	#line 740
	SerialDpcEpilogue(Extension, Dpc);
}

#line 16 "C:/NTDDK/inc/stddef.h"

#pragma once
#line 77
typedef int ;

#line 86
typedef unsigned int ;

#line 95
typedef int ;

#line 105
typedef unsigned int ;

#line 112
typedef unsigned short ;

#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"

#pragma once
#line 32

#pragma pack(push, 8)
#line 72
typedef enum _EXCEPTION_DISPOSITION ;

#line 89
struct _EXCEPTION_RECORD ;

#line 90
struct _CONTEXT ;

#line 155

#pragma pack(pop)
#line 25 "C:/NTDDK/inc/ntdef.h"

#pragma once
#line 15 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"

#pragma once
#line 66
typedef wchar_t ;

#line 67
typedef wchar_t ;

#line 127 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long ;

#line 25 "C:/NTDDK/inc/basetsd.h"

#pragma once
#line 36
typedef int ;

#line 37
typedef int ;

#line 43
typedef unsigned int ;

#line 44
typedef unsigned int ;

#line 45
typedef unsigned int ;

#line 84
typedef int ;

#line 85
typedef unsigned int ;

typedef long ;

#line 88
typedef unsigned long ;

#line 248
typedef unsigned short ;

#line 249
typedef short ;

#line 250
typedef unsigned long ;

#line 288
typedef ULONG_PTR ;

#line 289
typedef LONG_PTR ;

#line 295
typedef ULONG_PTR ;

#line 301
typedef __int64 ;

#line 302
typedef __int64 ;

#line 309
typedef unsigned __int64 ;

#line 310
typedef unsigned __int64 ;

#line 311
typedef unsigned __int64 ;

#line 217 "C:/NTDDK/inc/ntdef.h"
typedef void ;

#line 218
typedef void ;

#line 266
typedef char ;

#line 267
typedef short ;

#line 268
typedef long ;

#line 276
typedef wchar_t ;

#line 282
typedef WCHAR ;

#line 283
typedef WCHAR ;

#line 284
typedef const WCHAR ;

#line 285
typedef WCHAR ;

#line 286
typedef WCHAR ;

typedef const WCHAR ;

#line 293
typedef CHAR ;

#line 294
typedef CHAR ;

typedef const CHAR ;

#line 297
typedef CHAR ;

#line 298
typedef CHAR ;

#line 299
typedef const CHAR ;

#line 321
typedef char ;

#line 322
typedef unsigned char ;

#line 326
typedef LPSTR ;

#line 327
typedef LPSTR ;

#line 328
typedef LPCSTR ;

#line 337
typedef double ;

typedef struct _QUAD ;

#line 349
typedef SHORT ;

#line 350
typedef LONG ;

#line 351
typedef QUAD ;

#line 360
typedef unsigned char ;

#line 361
typedef unsigned short ;

#line 362
typedef unsigned long ;

#line 363
typedef QUAD ;

#line 369
typedef UCHAR ;

#line 370
typedef USHORT ;

#line 371
typedef ULONG ;

#line 372
typedef UQUAD ;

#line 378
typedef signed char ;

#line 379
typedef SCHAR ;

#line 394
typedef void ;

#line 400
typedef HANDLE ;

#line 406
typedef UCHAR ;

#line 407
typedef USHORT ;

#line 408
typedef ULONG ;

#line 414
typedef LONG ;

#line 478
typedef char ;

#line 479
typedef short ;

#line 480
typedef ULONG ;

typedef CCHAR ;

#line 483
typedef CSHORT ;

#line 484
typedef CLONG ;

#line 492
typedef ULONG ;

#line 493
typedef PULONG ;

#line 494
typedef USHORT ;

#line 500
typedef ULONG ;

#line 501
typedef ULONG ;

#line 508
typedef LONG ;

typedef NTSTATUS ;

#line 602
typedef struct _FLOAT128 ;

#line 607
typedef FLOAT128 ;

#line 621
typedef __int64 ;

#line 622
typedef unsigned __int64 ;

#line 639
typedef LONGLONG ;

#line 640
typedef ULONGLONG ;

#line 644
typedef LONGLONG ;

#line 649
typedef union _LARGE_INTEGER ;

#line 662
typedef LARGE_INTEGER ;

#line 668
typedef union _ULARGE_INTEGER ;

#line 681
typedef ULARGE_INTEGER ;

#line 690
typedef struct _LUID ;

#line 696
typedef ULONGLONG ;

#line 697
typedef DWORDLONG ;

#line 707
typedef LARGE_INTEGER ;

#line 831

#pragma warning(push)

#pragma warning(disable:4035)
__inline ULONGLONG __stdcall Int64ShllMod32___13(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 842
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    
		};
}

#line 845
__inline LONGLONG __stdcall Int64ShraMod32___13(LONGLONG Value , ULONG
	ShiftCount )
{
	#line 852
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    
		};
}

#line 855
__inline ULONGLONG __stdcall Int64ShrlMod32___13(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 862
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    
		};
}


#pragma warning(pop)
#line 956
typedef enum _EVENT_TYPE ;

#line 965
typedef enum _TIMER_TYPE ;

#line 974
typedef enum _WAIT_TYPE ;

#line 983
typedef CHAR ;

#line 984
typedef const char ;

#line 991
typedef struct _STRING ;

#line 999
typedef STRING ;

typedef STRING ;

#line 1002
typedef PSTRING ;

typedef STRING ;

#line 1005
typedef PSTRING ;

#line 1011
typedef struct _CSTRING ;

#line 1016
typedef CSTRING ;

#line 1019
typedef STRING ;

#line 1020
typedef PSTRING ;

#line 1027
typedef struct _UNICODE_STRING ;

#line 1036
typedef UNICODE_STRING ;

#line 1037
typedef const UNICODE_STRING ;

#line 1046
typedef UCHAR ;

#line 1047
typedef BOOLEAN ;

#line 1057
typedef struct _LIST_ENTRY ;

#line 1067
typedef struct _SINGLE_LIST_ENTRY ;

#line 1078
typedef struct LIST_ENTRY32 ;

#line 1082
typedef LIST_ENTRY32 ;

typedef struct LIST_ENTRY64 ;

#line 1088
typedef LIST_ENTRY64 ;

#line 1127
typedef struct _STRING32 ;

#line 1132
typedef STRING32 ;

typedef STRING32 ;

#line 1135
typedef UNICODE_STRING32 ;

typedef STRING32 ;

#line 1138
typedef ANSI_STRING32 ;

#line 1141
typedef struct _STRING64 ;

#line 1146
typedef STRING64 ;

typedef STRING64 ;

#line 1149
typedef UNICODE_STRING64 ;

typedef STRING64 ;

#line 1152
typedef ANSI_STRING64 ;

#line 1173
typedef struct _OBJECT_ATTRIBUTES ;

#line 1181
typedef OBJECT_ATTRIBUTES ;

#line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID ;

#line 70
typedef GUID ;

#line 75
typedef const GUID ;

#line 81
typedef GUID ;

#line 82
typedef IID ;

#line 85
typedef GUID ;

#line 86
typedef CLSID ;

#line 89
typedef GUID ;

#line 90
typedef FMTID ;

#line 16 "C:/NTDDK/inc/string.h"

#pragma once
#line 1233 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECTID ;

#line 1288
struct _CONTEXT ;

#line 1289
struct _EXCEPTION_RECORD ;

typedef EXCEPTION_DISPOSITION ;

#line 1306
typedef UCHAR ;

typedef KIRQL ;

#line 1316
typedef enum _NT_PRODUCT_TYPE ;

#line 1329
typedef enum _SUITE_TYPE ;

#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD ;

#line 76
typedef struct _ETHREAD ;

#line 77
typedef struct _EPROCESS ;

#line 78
typedef struct _PEB ;

#line 79
typedef struct _KINTERRUPT ;

#line 80
typedef struct _IO_TIMER ;

#line 81
typedef struct _OBJECT_TYPE ;

#line 82
typedef struct _CALLBACK_OBJECT ;

#line 83
typedef struct _DEVICE_HANDLER_OBJECT ;

#line 84
typedef struct _BUS_HANDLER ;

#line 143
typedef union _SLIST_HEADER ;

#line 204
typedef CCHAR ;

typedef enum _MODE ;

#line 222
struct _KAPC ;

typedef void ;

#line 232
typedef void ;

#line 242
typedef void ;

#line 248
typedef BOOLEAN ;

#line 254
typedef BOOLEAN ;

#line 265
typedef struct _KAPC ;

#line 292
struct _KDPC ;

typedef void ;

#line 351
typedef enum _KDPC_IMPORTANCE ;

#line 361
typedef struct _KDPC ;

#line 377
typedef PVOID ;

typedef void ;

#line 392
typedef struct _KIPI_COUNTS ;

#line 443
typedef struct _MDL ;

#line 532
typedef PVOID ;

#line 538
typedef PVOID ;

#line 544
typedef PVOID ;

typedef ULONG ;

#line 547
typedef ACCESS_MASK ;

#line 597
typedef struct _GENERIC_MAPPING ;

#line 603
typedef GENERIC_MAPPING ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES ;

#line 622
typedef LUID_AND_ATTRIBUTES ;

#line 623
typedef LUID_AND_ATTRIBUTES_ARRAY ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 642 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACL ;

#line 649
typedef ACL ;

#line 681
typedef struct _PRIVILEGE_SET ;

#line 735
typedef enum _SECURITY_IMPERSONATION_LEVEL ;

#line 753
typedef BOOLEAN ;

#line 762
typedef struct _SECURITY_QUALITY_OF_SERVICE ;

#line 774
typedef struct _SE_IMPERSONATION_STATE ;

#line 782
typedef ULONG ;

#line 809
typedef ULONG ;

#line 810
typedef KAFFINITY ;

#line 816
typedef LONG ;

#line 824
typedef ULONG_PTR ;

#line 825
typedef KSPIN_LOCK ;

#line 833
typedef void ;

#line 842
typedef enum _KPROFILE_SOURCE ;

#line 1079
typedef NTSTATUS ;

#line 1088
typedef struct _RTL_QUERY_REGISTRY_TABLE ;

#line 1952

#pragma warning(push)

#pragma warning(disable:4035)
#line 2019

#pragma warning(pop)
#line 2214
typedef struct _TIME_FIELDS ;

#line 2224
typedef TIME_FIELDS ;

#line 2499
typedef struct _RTL_BITMAP ;

#line 2503
typedef RTL_BITMAP ;

#line 2627
typedef struct _RTL_BITMAP_RUN ;

#line 2633
typedef RTL_BITMAP_RUN ;

#line 2886
typedef struct _RTL_RANGE ;

#line 2924
typedef struct _RTL_RANGE_LIST ;

#line 2950
typedef struct _RANGE_LIST_ITERATOR ;

#line 3019
typedef BOOLEAN ;

#line 3155
typedef struct _OSVERSIONINFOA ;

#line 3164
typedef struct _OSVERSIONINFOW ;

#line 3177
typedef OSVERSIONINFOA ;

#line 3178
typedef POSVERSIONINFOA ;

#line 3179
typedef LPOSVERSIONINFOA ;

#line 3182
typedef struct _OSVERSIONINFOEXA ;

#line 3195
typedef struct _OSVERSIONINFOEXW ;

#line 3213
typedef OSVERSIONINFOEXA ;

#line 3214
typedef POSVERSIONINFOEXA ;

#line 3215
typedef LPOSVERSIONINFOEXA ;

#line 3648
typedef struct _IO_STATUS_BLOCK ;

#line 3669
typedef void ;

#line 3685
typedef enum _FILE_INFORMATION_CLASS ;

#line 3731
typedef struct _FILE_BASIC_INFORMATION ;

#line 3739
typedef struct _FILE_STANDARD_INFORMATION ;

#line 3747
typedef struct _FILE_POSITION_INFORMATION ;

#line 3751
typedef struct _FILE_ALIGNMENT_INFORMATION ;

#line 3755
typedef struct _FILE_NAME_INFORMATION ;

#line 3760
typedef struct _FILE_NETWORK_OPEN_INFORMATION ;

#line 3770
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION ;

#line 3775
typedef struct _FILE_DISPOSITION_INFORMATION ;

#line 3779
typedef struct _FILE_END_OF_FILE_INFORMATION ;

#line 3784
typedef struct _FILE_FULL_EA_INFORMATION ;

#line 3798
typedef enum _FSINFOCLASS ;

#line 3810
typedef struct _FILE_FS_DEVICE_INFORMATION ;

#line 3820
typedef union _FILE_SEGMENT_ELEMENT ;

#line 3829
typedef enum _INTERFACE_TYPE ;

#line 3854
typedef enum _DMA_WIDTH ;

#line 3865
typedef enum _DMA_SPEED ;

#line 3879
typedef void ;

#line 3880
typedef void ;

#line 3888
typedef enum _BUS_DATA_TYPE ;

#line 3910
typedef struct _IO_ERROR_LOG_PACKET ;

#line 3931
typedef struct _IO_ERROR_LOG_MESSAGE ;

#line 4074
typedef struct _KEY_BASIC_INFORMATION ;

#line 4081
typedef struct _KEY_NODE_INFORMATION ;

#line 4091
typedef struct _KEY_FULL_INFORMATION ;

#line 4106
typedef struct _KEY_NAME_INFORMATION ;

#line 4112
typedef enum _KEY_INFORMATION_CLASS ;

#line 4122
typedef struct _KEY_WRITE_TIME_INFORMATION ;

#line 4126
typedef enum _KEY_SET_INFORMATION_CLASS ;

#line 4134
typedef struct _KEY_VALUE_BASIC_INFORMATION ;

#line 4141
typedef struct _KEY_VALUE_FULL_INFORMATION ;

#line 4151
typedef struct _KEY_VALUE_PARTIAL_INFORMATION ;

#line 4158
typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ;

#line 4164
typedef struct _KEY_VALUE_ENTRY ;

#line 4171
typedef enum _KEY_VALUE_INFORMATION_CLASS ;

#line 4210
typedef struct _OBJECT_NAME_INFORMATION ;

#line 4221
typedef enum _SECTION_INHERIT ;

#line 4294
typedef struct _CLIENT_ID ;

#line 4298
typedef CLIENT_ID ;

#line 4315
typedef struct _NT_TIB ;

#line 4327
typedef NT_TIB ;

#line 4332
typedef enum _PROCESSINFOCLASS ;

#line 4366
typedef enum _THREADINFOCLASS ;

#line 4395
typedef struct _PROCESS_WS_WATCH_INFORMATION ;

#line 4405
typedef struct _PROCESS_BASIC_INFORMATION ;

#line 4413
typedef PROCESS_BASIC_INFORMATION ;

#line 4422
typedef struct _PROCESS_DEVICEMAP_INFORMATION ;

#line 4440
typedef struct _PROCESS_SESSION_INFORMATION ;

#line 4454
typedef struct _QUOTA_LIMITS ;

#line 4462
typedef QUOTA_LIMITS ;

#line 4472
typedef struct _IO_COUNTERS ;

#line 4480
typedef IO_COUNTERS ;

#line 4488
typedef struct _VM_COUNTERS ;

#line 4501
typedef VM_COUNTERS ;

#line 4508
typedef struct _POOLED_USAGE_AND_LIMITS ;

#line 4519
typedef POOLED_USAGE_AND_LIMITS ;

#line 4528
typedef struct _PROCESS_ACCESS_TOKEN ;

#line 4555
typedef struct _KERNEL_USER_TIMES ;

#line 4561
typedef KERNEL_USER_TIMES ;

#line 4587
typedef enum _SYSTEM_POWER_STATE ;

#line 4598
typedef enum  {
	PowerActionNone = 0,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
} ;

typedef enum _DEVICE_POWER_STATE ;

#line 4618
typedef union _POWER_STATE ;

#line 4623
typedef enum _POWER_STATE_TYPE ;

#line 4654
typedef ULONG ;

typedef enum  {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
} ;

#line 4663
typedef enum  {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation
} ;

#line 4690
typedef ULONG ;

typedef LONG ;

#line 4693
typedef ULONG ;

#line 4719
typedef union _MCI_STATS ;

#line 4978
typedef struct _KPCR ;

#line 5006
typedef KPCR ;

#line 5012
typedef struct _KFLOATING_SAVE ;

#line 5153
typedef enum _INTERLOCKED_RESULT ;

#line 5252

#pragma warning(disable:4035)
#line 6994
typedef struct _KSYSTEM_TIME ;

#line 7014

#pragma warning(push)

#pragma warning(disable:4164)
#line 7019

#pragma function(_enable)
#line 7020

#pragma function(_disable)
#line 7024

#pragma warning(pop)
#line 7085
typedef struct _FLOATING_SAVE_AREA ;

#line 7097
typedef FLOATING_SAVE_AREA ;

#line 7109
typedef struct _CONTEXT ;

#line 7197
typedef CONTEXT ;

#line 7826
typedef void ;

#line 7850
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ;

#line 7899
typedef struct _KUSER_SHARED_DATA ;

#line 8123
typedef enum _CM_SERVICE_NODE_TYPE ;

#line 8132
typedef enum _CM_SERVICE_LOAD_TYPE ;

#line 8140
typedef enum _CM_ERROR_CONTROL_TYPE ;

#line 8172
typedef int ;

#line 8198
typedef enum _CM_SHARE_DISPOSITION ;

#line 8211
typedef PVOID ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST ;

#line 8443
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR ;

#line 8454
typedef struct _CM_RESOURCE_LIST ;

#line 8471
typedef struct _DEVICE_FLAGS ;

#line 8485
typedef struct _CM_COMPONENT_INFORMATION ;

#line 8503
typedef struct _CM_ROM_BLOCK ;

#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 8518 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_INT13_DRIVE_PARAMETER ;

#line 8532
typedef struct _CM_MCA_POS_DATA ;

#line 8544
typedef struct _EISA_MEMORY_TYPE ;

#line 8554
typedef struct _EISA_MEMORY_CONFIGURATION ;

#line 8567
typedef struct _EISA_IRQ_DESCRIPTOR ;

#line 8575
typedef struct _EISA_IRQ_CONFIGURATION ;

#line 8585
typedef struct _DMA_CONFIGURATION_BYTE0 ;

#line 8592
typedef struct _DMA_CONFIGURATION_BYTE1 ;

#line 8599
typedef struct _EISA_DMA_CONFIGURATION ;

#line 8609
typedef struct _EISA_PORT_DESCRIPTOR ;

#line 8616
typedef struct _EISA_PORT_CONFIGURATION ;

#line 8628
typedef struct _CM_EISA_SLOT_INFORMATION ;

#line 8644
typedef struct _CM_EISA_FUNCTION_INFORMATION ;

#line 8678
typedef struct _CM_PNP_BIOS_DEVICE_NODE ;

#line 8692
typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8761 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_SCSI_DEVICE_DATA ;

#line 8775
typedef struct _CM_VIDEO_DEVICE_DATA ;

#line 8785
typedef struct _CM_SONIC_DEVICE_DATA ;

#line 8796
typedef struct _CM_SERIAL_DEVICE_DATA ;

#line 8810
typedef struct _CM_MONITOR_DEVICE_DATA ;

#line 8844
typedef struct _CM_FLOPPY_DEVICE_DATA ;

#line 8881
typedef struct _CM_KEYBOARD_DEVICE_DATA ;

#line 8893
typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA ;

#line 8905
typedef struct _CM_PCCARD_DEVICE_DATA ;

#line 8944
typedef struct _IO_RESOURCE_DESCRIPTOR ;

#line 9027
typedef struct _IO_RESOURCE_LIST ;

#line 9036
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST ;

#line 9065
typedef struct _EXCEPTION_RECORD ;

#line 9074
typedef EXCEPTION_RECORD ;

typedef struct _EXCEPTION_RECORD32 ;

#line 9085
typedef struct _EXCEPTION_RECORD64 ;

#line 9099
typedef struct _EXCEPTION_POINTERS ;

#line 9111
typedef enum _CONFIGURATION_TYPE ;

#line 9161
typedef enum _KINTERRUPT_MODE ;

#line 9170
typedef enum _KWAIT_REASON ;

#line 9207
typedef struct _DISPATCHER_HEADER ;

#line 9217
typedef struct _KWAIT_BLOCK ;

#line 9230
typedef void ;

#line 9244
typedef struct _KDEVICE_QUEUE ;

#line 9252
typedef struct _KDEVICE_QUEUE_ENTRY ;

#line 9263
typedef struct _KEVENT ;

#line 9271
typedef BOOLEAN ;

#line 9281
typedef struct _KMUTANT ;

#line 9294
typedef struct _KSEMAPHORE ;

#line 9304
typedef struct _KTIMER ;

#line 9899
typedef enum _KBUGCHECK_BUFFER_DUMP_STATE ;

#line 9907
typedef void ;

#line 9914
typedef struct _KBUGCHECK_CALLBACK_RECORD ;

#line 10002
typedef void ;

#line 10020
typedef LOGICAL ;

#line 10037
typedef void ;

#line 10053
typedef enum _MEMORY_CACHING_TYPE_ORIG ;

#line 10057
typedef enum _MEMORY_CACHING_TYPE ;

#line 10087
typedef struct _DBGKD_DEBUG_DATA_HEADER64 ;

#line 10115
typedef enum _POOL_TYPE ;

#line 10195
typedef enum _EX_POOL_PRIORITY ;

#line 10247
typedef struct _FAST_MUTEX ;

#line 10574
typedef PVOID ;

#line 10582
typedef void ;

#line 10588
typedef struct _GENERAL_LOOKASIDE ;

#line 10619
typedef struct _NPAGED_LOOKASIDE_LIST ;

#line 10729
typedef struct _PAGED_LOOKASIDE_LIST ;

#line 10882
typedef enum _WORK_QUEUE_TYPE ;

#line 10889
typedef void ;

#line 10895
typedef struct _WORK_QUEUE_ITEM ;

#line 10926
typedef struct _ZONE_SEGMENT_HEADER ;

#line 10931
typedef struct _ZONE_HEADER ;

#line 11156
typedef ULONG_PTR ;

#line 11157
typedef ERESOURCE_THREAD ;

typedef struct _OWNER_ENTRY ;

#line 11168
typedef struct _ERESOURCE ;

#line 11197
typedef struct _RESOURCE_HASH_ENTRY ;

#line 11204
typedef struct _RESOURCE_PERFORMANCE_DATA ;

#line 11429
typedef struct _CALLBACK_OBJECT ;

typedef void ;

#line 11474
typedef GUID ;

#line 11862
typedef enum _MM_SYSTEM_SIZE ;

#line 11884
typedef enum _LOCK_OPERATION ;

#line 11970
typedef enum _MM_PAGE_PRIORITY ;

#line 11999
typedef struct _PHYSICAL_MEMORY_RANGE ;

#line 12385
typedef NTSTATUS ;

#line 12389
typedef NTSTATUS ;

#line 12399
struct _DRIVER_OBJECT ;

#line 12411
typedef enum _SECURITY_OPERATION_CODE ;

#line 12426
typedef struct _SECURITY_SUBJECT_CONTEXT ;

#line 12448
typedef struct _INITIAL_PRIVILEGE_SET ;

#line 12462
typedef struct _ACCESS_STATE ;

#line 12571
typedef void ;

#line 12585
typedef void ;

#line 12602
typedef struct _IMAGE_INFO ;

#line 12620
typedef void ;

#line 12859
typedef NTSTATUS ;

#line 12878
typedef enum _IO_QUERY_DEVICE_DATA_FORMAT ;

#line 12890
typedef enum _CREATE_FILE_TYPE ;

#line 12905
struct _DEVICE_DESCRIPTION ;

#line 12906
struct _DEVICE_OBJECT ;

#line 12907
struct _DMA_ADAPTER ;

#line 12908
struct _DRIVER_OBJECT ;

#line 12909
struct _DRIVE_LAYOUT_INFORMATION ;

#line 12910
struct _DISK_PARTITION ;

#line 12911
struct _FILE_OBJECT ;

#line 12912
struct _IRP ;

#line 12913
struct _SCSI_REQUEST_BLOCK ;

#line 12919
typedef void ;

#line 12932
typedef void ;

#line 12943
typedef NTSTATUS ;

#line 12955
typedef void ;

#line 12968
typedef void ;

#line 12979
typedef NTSTATUS ;

#line 12990
typedef void ;

#line 13001
typedef void ;

#line 13011
typedef NTSTATUS ;

#line 13025
typedef BOOLEAN ;

#line 13038
typedef BOOLEAN ;

#line 13051
typedef BOOLEAN ;

#line 13068
typedef BOOLEAN ;

#line 13078
typedef BOOLEAN ;

#line 13092
typedef BOOLEAN ;

#line 13106
typedef BOOLEAN ;

#line 13118
typedef BOOLEAN ;

#line 13127
typedef BOOLEAN ;

#line 13141
typedef BOOLEAN ;

#line 13161
typedef void ;

#line 13167
typedef void ;

#line 13179
typedef void ;

#line 13193
typedef BOOLEAN ;

#line 13207
typedef BOOLEAN ;

#line 13219
typedef BOOLEAN ;

#line 13227
typedef BOOLEAN ;

#line 13239
typedef BOOLEAN ;

#line 13253
typedef NTSTATUS ;

#line 13262
typedef NTSTATUS ;

#line 13275
typedef NTSTATUS ;

#line 13282
typedef NTSTATUS ;

#line 13289
typedef BOOLEAN ;

#line 13304
typedef BOOLEAN ;

#line 13319
typedef BOOLEAN ;

#line 13327
typedef BOOLEAN ;

#line 13336
typedef BOOLEAN ;

#line 13350
typedef struct _FAST_IO_DISPATCH ;

#line 13386
typedef enum _IO_ALLOCATION_ACTION ;

#line 13396
typedef IO_ALLOCATION_ACTION ;

#line 13410
typedef struct _IO_SECURITY_CONTEXT ;

#line 13434
typedef struct _VPB ;

#line 13482
typedef struct _ADAPTER_OBJECT ;

#line 13491
typedef struct _WAIT_CONTEXT_BLOCK ;

#line 13503
typedef struct _CONTROLLER_OBJECT ;

#line 13537
typedef struct _DEVICE_OBJECT ;

#line 13575
typedef struct _DEVICE_OBJECT ;

#line 13578
struct _DEVICE_OBJECT_POWER_EXTENSION ;

typedef struct _DEVOBJ_EXTENSION ;

#line 13608
typedef struct _DRIVER_EXTENSION ;

#line 13645
typedef struct _DRIVER_OBJECT ;

#line 13706
typedef struct _DRIVER_OBJECT ;

#line 13715
typedef struct _SECTION_OBJECT_POINTERS ;

#line 13720
typedef SECTION_OBJECT_POINTERS ;

#line 13726
typedef struct _IO_COMPLETION_CONTEXT ;

#line 13759
typedef struct _FILE_OBJECT ;

#line 13788
typedef struct _FILE_OBJECT ;

#line 13828
typedef struct _IRP ;

#line 14078
typedef NTSTATUS ;

#line 14163
typedef enum _DEVICE_RELATION_TYPE ;

#line 14171
typedef struct _DEVICE_RELATIONS ;

#line 14176
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE ;

#line 14185
typedef struct _INTERFACE ;

#line 14196
typedef struct _DEVICE_CAPABILITIES ;

#line 14229
typedef struct _POWER_SEQUENCE ;

#line 14235
typedef enum  {
	BusQueryDeviceID = 0,
	BusQueryHardwareIDs = 1,
	BusQueryCompatibleIDs = 2,
	BusQueryInstanceID = 3,
	BusQueryDeviceSerialNumber = 4
} ;

typedef ULONG ;

#line 14252
typedef enum  {
	DeviceTextDescription = 0,
	DeviceTextLocationInformation = 1
} ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 14615 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SHARE_ACCESS ;

#line 14635
typedef struct _CONFIGURATION_INFORMATION ;

#line 14848
typedef struct _BOOTDISK_INFORMATION ;

#line 15754
typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK ;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK ;

#line 15764
typedef struct _IO_REMOVE_LOCK_DBG_BLOCK ;

#line 15777
typedef struct _IO_REMOVE_LOCK ;

#line 16009
typedef struct _IO_WORKITEM ;

typedef void ;

#line 16100
typedef enum  {
	DevicePropertyDeviceDescription,
	DevicePropertyHardwareID,
	DevicePropertyCompatibleIDs,
	DevicePropertyBootConfiguration,
	DevicePropertyBootConfigurationTranslated,
	DevicePropertyClassName,
	DevicePropertyClassGuid,
	DevicePropertyDriverKeyName,
	DevicePropertyManufacturer,
	DevicePropertyFriendlyName,
	DevicePropertyLocationInformation,
	DevicePropertyPhysicalDeviceObjectName,
	DevicePropertyBusTypeGuid,
	DevicePropertyLegacyBusType,
	DevicePropertyBusNumber,
	DevicePropertyEnumeratorName,
	DevicePropertyAddress,
	DevicePropertyUINumber
} ;

typedef BOOLEAN ;

#line 16129
typedef struct _DMA_ADAPTER ;

#line 16135
typedef ULONG ;

#line 16148
typedef struct _PNP_BUS_INFORMATION ;

#line 16162
typedef struct _LEGACY_BUS_INFORMATION ;

#line 16168
typedef struct _BUS_INTERFACE_STANDARD ;

#line 16190
typedef BOOLEAN ;

#line 16194
typedef NTSTATUS ;

#line 16203
typedef NTSTATUS ;

#line 16206
typedef NTSTATUS ;

#line 16210
typedef NTSTATUS ;

#line 16214
typedef NTSTATUS ;

#line 16218
typedef void ;

#line 16222
typedef NTSTATUS ;

#line 16227
typedef void ;

#line 16231
typedef struct _ACPI_INTERFACE_STANDARD ;

#line 16255
typedef enum _ACPI_REG_TYPE ;

#line 16268
typedef USHORT ;

#line 16272
typedef void ;

#line 16278
typedef struct ACPI_REGS_INTERFACE_STANDARD ;

#line 16300
typedef struct  {
	PVOID LinkNode ;
	ULONG StaticVector ;
	UCHAR Flags ;
} ;

#line 16314
typedef NTSTATUS ;

#line 16329
typedef NTSTATUS ;

#line 16336
typedef void ;

#line 16343
typedef struct _INT_ROUTE_INTERFACE_STANDARD ;

#line 16366
typedef struct _IO_ASSIGNED_RESOURCES ;

#line 16490
typedef enum _IO_NOTIFICATION_EVENT_CATEGORY ;

#line 16504
typedef NTSTATUS ;

#line 16537
typedef void ;

#line 16573
typedef enum _ARBITER_ACTION ;

#line 16586
typedef struct _ARBITER_CONFLICT_INFO ;

#line 16608
typedef struct _ARBITER_PARAMETERS ;

#line 16719
typedef enum _ARBITER_REQUEST_SOURCE ;

#line 16731
typedef enum _ARBITER_RESULT ;

#line 16761
typedef struct _ARBITER_LIST_ENTRY ;

#line 16832
typedef NTSTATUS ;

#line 16853
typedef struct _ARBITER_INTERFACE ;

#line 16880
typedef enum _RESOURCE_TRANSLATION_DIRECTION ;

#line 16889
typedef NTSTATUS ;

#line 16901
typedef NTSTATUS ;

#line 16915
typedef struct _TRANSLATOR_INTERFACE ;

#line 16931
typedef NTSTATUS ;

#line 16945
typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE ;

#line 16959
typedef struct _PLUGPLAY_NOTIFICATION_HEADER ;

#line 16972
typedef struct _HWPROFILE_CHANGE_NOTIFICATION ;

#line 16986
typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION ;

#line 17006
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION ;

#line 17026
typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION ;

#line 17054
typedef struct _DEVICE_DESCRIPTION ;

#line 17086
typedef BOOLEAN ;

#line 17333
typedef void ;

#line 17339
typedef struct _DEVICE_CONTROL_CONTEXT ;

#line 17349
typedef PBUS_HANDLER ;

#line 17355
typedef void ;

#line 17365
typedef enum _HAL_QUERY_INFORMATION_CLASS ;

#line 17381
typedef enum _HAL_SET_INFORMATION_CLASS ;

#line 17388
typedef NTSTATUS ;

#line 17405
typedef NTSTATUS ;

#line 17420
typedef void ;

#line 17429
typedef void ;

#line 17438
typedef NTSTATUS ;

#line 17447
typedef NTSTATUS ;

#line 17456
typedef NTSTATUS ;

#line 17466
typedef NTSTATUS ;

#line 17475
typedef NTSTATUS ;

#line 17486
typedef struct _PM_DISPATCH_TABLE ;

#line 17492
typedef NTSTATUS ;

#line 17505
typedef struct _DMA_ADAPTER ;

#line 17520
typedef NTSTATUS ;

#line 17543
typedef BOOLEAN ;

#line 17553
typedef NTSTATUS ;

#line 17566
typedef void ;

#line 17572
typedef void ;

#line 17578
typedef BOOLEAN ;

#line 17588
typedef struct  {
	ULONG Version ;
	pHalQuerySystemInformation HalQuerySystemInformation ;
	pHalSetSystemInformation HalSetSystemInformation ;
	pHalQueryBusSlots HalQueryBusSlots ;
	ULONG Spare1 ;
	pHalExamineMBR HalExamineMBR ;
	pHalIoAssignDriveLetters HalIoAssignDriveLetters ;
	pHalIoReadPartitionTable HalIoReadPartitionTable ;
	pHalIoSetPartitionInformation HalIoSetPartitionInformation ;
	pHalIoWritePartitionTable HalIoWritePartitionTable ;
	pHalHandlerForBus HalReferenceHandlerForBus ;
	pHalReferenceBusHandler HalReferenceBusHandler ;
	pHalReferenceBusHandler HalDereferenceBusHandler ;
	pHalInitPnpDriver HalInitPnpDriver ;
	pHalInitPowerManagement HalInitPowerManagement ;
	pHalGetDmaAdapter HalGetDmaAdapter ;
	pHalGetInterruptTranslator HalGetInterruptTranslator ;
} ;

#line 17650
typedef struct _HAL_BUS_INFORMATION ;

#line 17658
typedef struct _HAL_PROFILE_SOURCE_INFORMATION ;

#line 17665
typedef struct _HAL_PROFILE_SOURCE_INTERVAL ;

#line 17671
typedef enum _HAL_DISPLAY_BIOS_INFORMATION ;

#line 17678
typedef struct _HAL_POWER_INFORMATION ;

#line 17683
typedef struct _HAL_PROCESSOR_SPEED_INFO ;

#line 17688
typedef struct _HAL_CALLBACKS ;

#line 17694
typedef struct _HAL_PROCESSOR_FEATURE ;

#line 17706
typedef union _MCI_ADDR ;

#line 17716
typedef enum  {
	HAL_MCE_RECORD,
	HAL_MCA_RECORD
} ;

#line 17726
typedef struct _MCA_EXCEPTION ;

#line 17752
typedef void ;

#line 17762
typedef struct _MCA_DRIVER_INFO ;

#line 17772
typedef struct _SCATTER_GATHER_ELEMENT ;

#line 17778

#pragma warning(disable:4200)
#line 17779
typedef struct _SCATTER_GATHER_LIST ;

#line 17784

#pragma warning(default:4200)
#line 17788
typedef struct _DMA_OPERATIONS ;

typedef struct _DMA_ADAPTER ;

#line 17797
typedef void ;

#line 17801
typedef PVOID ;

#line 17808
typedef void ;

#line 17816
typedef NTSTATUS ;

#line 17824
typedef BOOLEAN ;

#line 17833
typedef void ;

#line 17837
typedef void ;

#line 17843
typedef PHYSICAL_ADDRESS ;

#line 17852
typedef ULONG ;

#line 17856
typedef ULONG ;

#line 17860
typedef void ;

#line 17868
typedef NTSTATUS ;

#line 17880
typedef void ;

#line 17887
typedef struct _DMA_OPERATIONS ;

#line 18235
typedef void ;

#line 18321
typedef struct _OBJECT_HANDLE_INFORMATION ;

#line 18402
typedef struct _PCI_SLOT_NUMBER ;

#line 18418
typedef struct _PCI_COMMON_CONFIG ;

#line 18591
typedef struct _PCI_CAPABILITIES_HEADER ;

#line 18600
typedef struct _PCI_PMC ;

#line 18618
typedef struct _PCI_PMCSR ;

#line 18628
typedef struct _PCI_PMCSR_BSE ;

#line 18635
typedef struct _PCI_PM_CAPABILITY ;

#line 18679
typedef struct _PCI_AGP_CAPABILITY ;

#line 18720
typedef struct _PCI_MSI_CAPABILITY ;

#line 18946
typedef void ;

#line 18954
typedef void ;

#line 18963
typedef void ;

#line 18975
typedef struct _PCIBUSDATA ;

#line 18986
typedef ULONG ;

#line 18995
typedef void ;

#line 19000
typedef void ;

#line 19006
typedef struct _PCI_BUS_INTERFACE_STANDARD ;

#line 19028
typedef BOOLEAN ;

#line 19043
typedef struct _PCI_DEVICE_PRESENT_INTERFACE ;

#line 127 "C:/NTDDK/inc/ntddser.h"
typedef struct _SERIALPERF_STATS ;

#line 136
typedef struct _SERIALCONFIG ;

#line 154
typedef struct _SERIAL_LINE_CONTROL ;

#line 160
typedef struct _SERIAL_TIMEOUTS ;

#line 175
typedef struct _SERIAL_QUEUE_SIZE ;

#line 185
typedef struct _SERIAL_BAUD_RATE ;

#line 247
typedef struct _SERIAL_CHARS ;

#line 284
typedef struct _SERIAL_HANDFLOW ;

#line 340
typedef struct _SERIAL_BASIC_SETTINGS ;

#line 353
typedef struct _SERIAL_STATUS ;

#line 433
typedef struct _SERIAL_XOFF_COUNTER ;

#line 539
typedef struct _SERIAL_COMMPROP ;

#line 631
typedef struct _SERENUM_PORT_DESC ;

#line 652
typedef UCHAR ;

#line 658
typedef void ;

#line 665
typedef enum _SERENUM_PORTION ;

#line 671
typedef struct _SERENUM_PORT_PARAMETERS ;

#line 28 "C:/NTDDK/inc/ddk/wdm/wmilib.h"

#pragma once
#line 38
typedef struct  {
	LPCGUID Guid ;
	ULONG InstanceCount ;
	ULONG Flags ;
} ;

#line 45
typedef NTSTATUS ;

#line 101
typedef NTSTATUS ;

#line 162
typedef NTSTATUS ;

#line 206
typedef NTSTATUS ;

#line 253
typedef NTSTATUS ;

#line 306
typedef enum  {
	WmiEventControl,
	WmiDataBlockControl
} ;

#line 312
typedef NTSTATUS ;

#line 355
typedef struct _WMILIB_CONTEXT ;

#line 411
typedef enum  {
	IrpProcessed,
	IrpNotCompleted,
	IrpNotWmi,
	IrpForward
} ;

#line 13 "C:/NTDDK/inc/wmidata.h"
typedef struct _MSWmi_MofData ;

#line 51
typedef struct _MSWmi_ProviderInfo ;

#line 66
typedef struct _MSWmi_PnPDeviceId ;

#line 83
typedef struct _MSWmi_PnPInstanceNames ;

#line 105
typedef struct _MSSmBios_RawSMBiosTables ;

#line 147
typedef struct _MSPower_DeviceEnable ;

#line 165
typedef struct _MSPower_DeviceWakeEnable ;

#line 182
typedef struct _MSNdis_NetworkAddress ;

#line 199
typedef struct _MSNdis_NetworkShortAddress ;

#line 216
typedef struct _MSNdis_NetworkLinkSpeed ;

#line 239
typedef struct _MSNdis_EnumerateAdapter ;

#line 256
typedef struct _MSNdis_NotifyAdapterRemoval ;

#line 273
typedef struct _MSNdis_NotifyAdapterArrival ;

#line 291
typedef struct _MSNdis_NdisEnumerateVc ;

#line 307
typedef struct _MSNdis_NotifyVcRemoval ;

#line 323
typedef struct _MSNdis_NotifyVcArrival ;

#line 338
typedef struct _MSNdis_HardwareStatus ;

#line 356
typedef struct _MSNdis_MediaSupported ;

#line 378
typedef struct _MSNdis_MediaInUse ;

#line 400
typedef struct _MSNdis_MaximumLookahead ;

#line 418
typedef struct _MSNdis_MaximumFrameSize ;

#line 436
typedef struct _MSNdis_LinkSpeed ;

#line 454
typedef struct _MSNdis_TransmitBufferSpace ;

#line 472
typedef struct _MSNdis_ReceiveBufferSpace ;

#line 490
typedef struct _MSNdis_TransmitBlockSize ;

#line 508
typedef struct _MSNdis_ReceiveBlockSize ;

#line 526
typedef struct _MSNdis_VendorID ;

#line 544
typedef struct _MSNdis_VendorDescription ;

#line 561
typedef struct _MSNdis_CurrentPacketFilter ;

#line 579
typedef struct _MSNdis_CurrentLookahead ;

#line 597
typedef struct _MSNdis_DriverVersion ;

#line 615
typedef struct _MSNdis_MaximumTotalSize ;

#line 633
typedef struct _MSNdis_MacOptions ;

#line 651
typedef struct _MSNdis_MediaConnectStatus ;

#line 669
typedef struct _MSNdis_MaximumSendPackets ;

#line 687
typedef struct _MSNdis_VendorDriverVersion ;

#line 705
typedef struct _MSNdis_TransmitsOk ;

#line 723
typedef struct _MSNdis_ReceivesOk ;

#line 741
typedef struct _MSNdis_TransmitsError ;

#line 759
typedef struct _MSNdis_ReceiveError ;

#line 777
typedef struct _MSNdis_ReceiveNoBuffer ;

#line 795
typedef struct _MSNdis_CoHardwareStatus ;

#line 813
typedef struct _MSNdis_CoMediaSupported ;

#line 835
typedef struct _MSNdis_CoMediaInUse ;

#line 857
typedef struct _MSNdis_CoLinkSpeed ;

#line 875
typedef struct _MSNdis_CoVendorId ;

#line 893
typedef struct _MSNdis_CoVendorDescription ;

#line 910
typedef struct _MSNdis_CoDriverVersion ;

#line 928
typedef struct _MSNdis_CoMacOptions ;

#line 946
typedef struct _MSNdis_CoMediaConnectStatus ;

#line 964
typedef struct _MSNdis_CoVendorDriverVersion ;

#line 982
typedef struct _MSNdis_CoMinimumLinkSpeed ;

#line 1000
typedef struct _MSNdis_CoTransmitPdusOk ;

#line 1018
typedef struct _MSNdis_CoReceivePdusOk ;

#line 1036
typedef struct _MSNdis_CoTransmitPduErrors ;

#line 1054
typedef struct _MSNdis_CoReceivePduErrors ;

#line 1072
typedef struct _MSNdis_CoReceivePdusNoBuffer ;

#line 1090
typedef struct _MSNdis_AtmSupportedVcRates ;

#line 1113
typedef struct _MSNdis_AtmSupportedServiceCategory ;

#line 1131
typedef struct _MSNdis_AtmSupportedAalTypes ;

#line 1149
typedef struct _MSNdis_AtmHardwareCurrentAddress ;

#line 1167
typedef struct _MSNdis_AtmMaxActiveVcs ;

#line 1185
typedef struct _MSNdis_AtmMaxActiveVciBits ;

#line 1203
typedef struct _MSNdis_AtmMaxActiveVpiBits ;

#line 1221
typedef struct _MSNdis_AtmMaxAal0PacketSize ;

#line 1239
typedef struct _MSNdis_AtmMaxAal1PacketSize ;

#line 1257
typedef struct _MSNdis_AtmMaxAal34PacketSize ;

#line 1275
typedef struct _MSNdis_AtmMaxAal5PacketSize ;

#line 1293
typedef struct _MSNdis_AtmReceiveCellsOk ;

#line 1311
typedef struct _MSNdis_AtmTransmitCellsOk ;

#line 1329
typedef struct _MSNdis_AtmReceiveCellsDropped ;

#line 1347
typedef struct _MSNdis_EthernetPermanentAddress ;

#line 1365
typedef struct _MSNdis_EthernetCurrentAddress ;

#line 1383
typedef struct _MSNdis_EthernetMulticastList ;

#line 1405
typedef struct _MSNdis_EthernetMaximumMulticastListSize ;

#line 1423
typedef struct _MSNdis_EthernetMacOptions ;

#line 1441
typedef struct _MSNdis_EthernetReceiveErrorAlignment ;

#line 1459
typedef struct _MSNdis_EthernetOneTransmitCollision ;

#line 1477
typedef struct _MSNdis_EthernetMoreTransmitCollisions ;

#line 1495
typedef struct _MSNdis_TokenRingPermanentAddress ;

#line 1513
typedef struct _MSNdis_TokenRingCurrentAddress ;

#line 1531
typedef struct _MSNdis_TokenRingCurrentFunctional ;

#line 1549
typedef struct _MSNdis_TokenRingCurrentGroup ;

#line 1567
typedef struct _MSNdis_TokenRingLastOpenStatus ;

#line 1585
typedef struct _MSNdis_TokenRingCurrentRingStatus ;

#line 1603
typedef struct _MSNdis_TokenRingCurrentRingState ;

#line 1621
typedef struct _MSNdis_TokenRingLineErrors ;

#line 1639
typedef struct _MSNdis_TokenRingLostFrames ;

#line 1657
typedef struct _MSNdis_FddiLongPermanentAddress ;

#line 1675
typedef struct _MSNdis_FddiLongCurrentAddress ;

#line 1693
typedef struct _MSNdis_FddiLongMulticastList ;

#line 1715
typedef struct _MSNdis_FddiLongMaximumListSize ;

#line 1733
typedef struct _MSNdis_FddiShortPermanentAddress ;

#line 1751
typedef struct _MSNdis_FddiShortCurrentAddress ;

#line 1769
typedef struct _MSNdis_FddiShortMulticastList ;

#line 1791
typedef struct _MSNdis_FddiShortMaximumListSize ;

#line 1809
typedef struct _MSNdis_FddiAttachmentType ;

#line 1827
typedef struct _MSNdis_FddiUpstreamNodeLong ;

#line 1845
typedef struct _MSNdis_FddiDownstreamNodeLong ;

#line 1863
typedef struct _MSNdis_FddiFrameErrors ;

#line 1881
typedef struct _MSNdis_FddiFramesLost ;

#line 1899
typedef struct _MSNdis_FddiRingManagmentState ;

#line 1917
typedef struct _MSNdis_FddiLctFailures ;

#line 1935
typedef struct _MSNdis_FddiLemRejects ;

#line 1953
typedef struct _MSNdis_FddiLConnectionState ;

#line 1972
typedef struct _MSNdis_StatusResetStart ;

#line 1988
typedef struct _MSNdis_StatusResetEnd ;

#line 2004
typedef struct _MSNdis_StatusMediaConnect ;

#line 2020
typedef struct _MSNdis_StatusMediaDisconnect ;

#line 2035
typedef struct _MSNdis_StatusMediaSpecificIndication ;

#line 2057
typedef struct _MSNdis_StatusLinkSpeedChange ;

#line 2075
typedef struct _MSNdis_StatusProtocolBind ;

#line 2092
typedef struct _MSNdis_StatusProtocolUnbind ;

#line 2109
typedef struct _KEYBOARD_PORT_WMI_STD_DATA ;

#line 2152
typedef struct _POINTER_PORT_WMI_STD_DATA ;

#line 2205
typedef struct _MSMouse_ClassInformation ;

#line 2223
typedef struct _MSKeyboard_ClassInformation ;

#line 2241
typedef struct _MSAcpi_ThermalZoneTemperature ;

#line 2304
typedef struct _WMI_DISK_GEOMETRY ;

#line 2342
typedef struct _WMI_DISK_PERFORMANCE ;

#line 2415
typedef struct _MSDiskDriver_Performance ;

#line 2437
typedef struct _STORAGE_FAILURE_PREDICT_STATUS ;

#line 2460
typedef struct _STORAGE_FAILURE_PREDICT_DATA ;

#line 2483
typedef struct _STORAGE_FAILURE_PREDICT_EVENT ;

#line 2513
typedef struct _STORAGE_FAILURE_PREDICT_FUNCTION ;

#line 2528
typedef struct _MSIde_PortDeviceInfo ;

#line 2556
typedef struct _MSSerial_PortName ;

#line 2573
typedef struct _SERIAL_WMI_COMM_DATA ;

#line 2723
typedef struct _SERIAL_WMI_HW_DATA ;

#line 2770
typedef struct _SERIAL_WMI_PERF_DATA ;

#line 2813
typedef struct _SERIAL_WMI_COMMPROP ;

#line 2920
typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS ;

#line 2943
typedef struct _PARALLEL_WMI_LOG_INFO ;

#line 3041
typedef struct _REDBOOK_WMI_STD_DATA ;

#line 3094
typedef struct _REDBOOK_WMI_PERF_DATA ;

#line 3137
typedef struct _RegisteredGuids ;

#line 475 "serial.h"
typedef struct _CONFIG_DATA ;

#line 509
typedef struct _SERIAL_CISR_SW ;

#line 520
typedef struct _SERIAL_FIRMWARE_DATA ;

#line 576
typedef struct _SERIAL_DEVICE_STATE ;

#line 646
typedef struct _SERIAL_DEVICE_EXTENSION ;

#line 1808
typedef struct _SERIAL_MULTIPORT_DISPATCH ;

#line 2157
typedef enum _SERIAL_MEM_COMPARES ;

#line 2164
typedef struct _SERIAL_LIST_DATA ;

#line 2169
typedef struct _SERIAL_GLOBALS ;

#line 2180
typedef struct _SERIAL_USER_DATA ;

#line 2206
typedef struct _SERIAL_PTR_CTX ;

#line 20 "serialp.h"
typedef NTSTATUS ;

#line 26
typedef void ;

#line 835
typedef struct _SERIAL_UPDATE_CHAR ;

#line 846
typedef struct _SERIAL_IOCTL_SYNC ;

#line 27 "write.c"
BOOLEAN SerialGiveWriteToIsr(PVOID Context ) ;
#line 32
void SerialCancelCurrentWrite(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 38
BOOLEAN SerialGrabWriteFromIsr(PVOID Context ) ;
#line 43
BOOLEAN SerialGrabXoffFromIsr(PVOID Context ) ;
#line 48
void SerialCancelCurrentXoff(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 54
BOOLEAN SerialGiveXoffToIsr(PVOID Context ) ;

#line 60

#pragma alloc_text(PAGESER, SerialProcessEmptyTransmit)
#line 61

#pragma alloc_text(PAGESER, SerialWrite)
#line 62

#pragma alloc_text(PAGESER, SerialStartWrite)
#line 63

#pragma alloc_text(PAGESER, SerialGetNextWrite)
#line 64

#pragma alloc_text(PAGESER, SerialGiveWriteToIsr)
#line 65

#pragma alloc_text(PAGESER, SerialCancelCurrentWrite)
#line 66

#pragma alloc_text(PAGESER, SerialGrabWriteFromIsr)
#line 67

#pragma alloc_text(PAGESER, SerialGrabXoffFromIsr)
#line 68

#pragma alloc_text(PAGESER, SerialCancelCurrentXoff)
#line 69

#pragma alloc_text(PAGESER, SerialGiveXoffToIsr)
#line 73
NTSTATUS SerialWrite(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
	#line 102
	PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
	NTSTATUS status ;
	#line 105
	;
	#line 107
	do
	{
		#line 107
		;
	}
	while(0);
	#line 109
	if((status = SerialIRPPrologue(Irp, Extension)) != (NTSTATUS
		)0x00000000L)
	{
		{
			#line 110
			IofCompleteRequest(Irp, 0);
			#line 110
			SerialIRPEpilogue(Extension);
		}
		#line 110
		;
		do
		{
			#line 111
			;
		}
		while(0);
		#line 112
		return status;
	}
	#line 118
	do
	{
		#line 118
		;
	}
	while(0);
	#line 119
	if(SerialCompleteIfError(DeviceObject, Irp) != (NTSTATUS )0x00000000L)
	{
		#line 124
		do
		{
			#line 124
			;
		}
		while(0);
		#line 126
		return (NTSTATUS )0xC0000120L;
	}
	#line 130
	(Irp->IoStatus).Information = 0L;
	#line 137
	if((((((Irp->Tail).Overlay).CurrentStackLocation)->Parameters).Write).Length
		)
	{
		#line 146
		do
		{
			#line 146
			;
		}
		while(0);
		#line 148
		return SerialStartOrQueue(Extension, Irp, &
			Extension->WriteQueue, & Extension->CurrentWriteIrp,
			SerialStartWrite);
	}
	else
	{
		#line 158
		(Irp->IoStatus).Status = (NTSTATUS )0x00000000L;
		#line 162
		do
		{
			#line 162
			;
		}
		while(0);
		{
			#line 163
			IofCompleteRequest(Irp, 0);
			#line 163
			SerialIRPEpilogue(Extension);
		}
		#line 163
		;
		#line 165
		do
		{
			#line 165
			;
		}
		while(0);
		#line 166
		return (NTSTATUS )0x00000000L;
	}
}

#line 172
NTSTATUS SerialStartWrite(PSERIAL_DEVICE_EXTENSION Extension )
{
	#line 198
	PIRP NewIrp ;
	KIRQL OldIrql ;
	LARGE_INTEGER TotalTime ;
	BOOLEAN UseATimer ;
	SERIAL_TIMEOUTS Timeouts ;
	BOOLEAN SetFirstStatus = 0;
	NTSTATUS FirstStatus ;
	#line 206
	;
	#line 208
	do
	{
		#line 208
		;
	}
	while(0);
	#line 210
	do
	{
		#line 216
		IoAcquireCancelSpinLock(& OldIrql);
		#line 229
		if(Extension->CurrentXoffIrp)
		{
			if((ULONG_PTR
				)((((((Extension->CurrentXoffIrp)->Tail).Overlay)
				.CurrentStackLocation)->Parameters).Others).Argument4
				)
			{
				#line 243
				do
				{
					#line 243
					LONG _refType = 0x00000010;
					#line 243
					PULONG_PTR _arg4 = (PVOID )(&
						((((((Extension->CurrentXoffIrp)
						->Tail).Overlay).CurrentStackLocation
						)->Parameters).Others).Argument4
						);
					#line 243
					;
					#line 243
					* _arg4 |= _refType;
				}
				while(0);
				#line 245
				((Extension->CurrentXoffIrp)->IoStatus).Information
					= 0;
				#line 252
				SerialTryToCompleteCurrent(Extension,
					SerialGrabXoffFromIsr, OldIrql,
					(NTSTATUS )0x40000008L, &
					Extension->CurrentXoffIrp, (void *  )0,
					(void *  )0, &
					Extension->XoffCountTimer, (void *  )0,
					(void *  )0, 0x00000010);
			}
			else
			{
				#line 274
				IoReleaseCancelSpinLock(OldIrql);
			}
		}
		else
		{
			#line 280
			IoReleaseCancelSpinLock(OldIrql);
		}
		#line 284
		UseATimer = 0;
		#line 297
		* & OldIrql = KfAcquireSpinLock(& Extension->ControlLock);
		#line 299
		Timeouts = Extension->Timeouts;
		#line 304
		KfReleaseSpinLock(& Extension->ControlLock, OldIrql);
		#line 306
		if(Timeouts.WriteTotalTimeoutConstant ||
			Timeouts.WriteTotalTimeoutMultiplier)
		{
			PIO_STACK_LOCATION IrpSp
				= (((Extension->CurrentWriteIrp)->Tail).Overlay)
				.CurrentStackLocation;
			UseATimer = 1;
			#line 321
			TotalTime.QuadPart = (LONGLONG )((ULONGLONG )((ULONGLONG
				)((ULONG )(IrpSp->MajorFunction == 0x04
				? ((IrpSp->Parameters).Write).Length : 1)) *
				(ULONG )Timeouts.WriteTotalTimeoutMultiplier) +
				Timeouts.WriteTotalTimeoutConstant) * - 10000;
		}
		{
			#line 338
			;
			#line 338
			((((((Extension->CurrentWriteIrp)->Tail).Overlay).CurrentStackLocation
				)->Parameters).Others).Argument4 = (void *  )0;
		}
		#line 338
		;
		#line 344
		IoAcquireCancelSpinLock(& OldIrql);
		if((Extension->CurrentWriteIrp)->Cancel)
		{
			IoReleaseCancelSpinLock(OldIrql);
			((Extension->CurrentWriteIrp)->IoStatus).Status =
				(NTSTATUS )0xC0000120L;
			if(! SetFirstStatus)
			{
				FirstStatus = (NTSTATUS )0xC0000120L;
				SetFirstStatus = 1;
			}
		}
		else
		{
			#line 359
			if(! SetFirstStatus)
			{
				#line 370
				if(pending == 0)
					#line 370
					pending = 1;
				else
					#line 370
					errorFn();
				((((Extension->CurrentWriteIrp)->Tail).Overlay).CurrentStackLocation
					)->Control |= 0x01;
				#line 372
				SetFirstStatus = 1;
				FirstStatus = (NTSTATUS )0x00000103L;
			}
			#line 389
			(PDRIVER_CANCEL )((PVOID )InterlockedExchange((PLONG
				)((PVOID *  )(&
				(Extension->CurrentWriteIrp)->CancelRoutine)),
				(LONG )((PVOID )SerialCancelCurrentWrite)));
			#line 394
			do
			{
				#line 394
				LONG _refType = 0x00000002;
				#line 394
				PULONG_PTR _arg4 = (PVOID )(&
					((((((Extension->CurrentWriteIrp)->Tail)
					.Overlay).CurrentStackLocation)->Parameters
					).Others).Argument4);
				#line 394
				;
				#line 394
				* _arg4 |= _refType;
			}
			while(0);
			#line 396
			if(UseATimer)
			{
				SerialSetTimer(&
					Extension->WriteRequestTotalTimer,
					TotalTime, &
					Extension->TotalWriteTimeoutDpc,
					Extension);
				#line 412
				do
				{
					#line 412
					LONG _refType = 0x00000004;
					#line 412
					PULONG_PTR _arg4 = (PVOID )(&
						((((((Extension->CurrentWriteIrp
						)->Tail).Overlay).CurrentStackLocation
						)->Parameters).Others).Argument4
						);
					#line 412
					;
					#line 412
					* _arg4 |= _refType;
				}
				while(0);
			}
			#line 415
			KeSynchronizeExecution(Extension->Interrupt,
				SerialGiveWriteToIsr, Extension);
			#line 421
			IoReleaseCancelSpinLock(OldIrql);
			break;
		}
		#line 431
		SerialGetNextWrite(& Extension->CurrentWriteIrp, &
			Extension->WriteQueue, & NewIrp, 1, Extension);
	}
	while(NewIrp);
	#line 441
	return FirstStatus;
}

#line 445
void SerialGetNextWrite(PIRP *  CurrentOpIrp , PLIST_ENTRY QueueToProcess , PIRP
	*  NewIrp , BOOLEAN CompleteCurrent , PSERIAL_DEVICE_EXTENSION Extension
	)
{
	#line 499
	;
	#line 501
	do
	{
		#line 501
		;
	}
	while(0);
	do
	{
		#line 511
		if(((((*
			CurrentOpIrp)->Tail).Overlay).CurrentStackLocation)->MajorFunction
			== 0x04)
		{
			#line 514
			KIRQL OldIrql ;
			#line 518
			;
			#line 520
			IoAcquireCancelSpinLock(& OldIrql);
			Extension->TotalCharsQueued -= ((((((*
				CurrentOpIrp)->Tail).Overlay).CurrentStackLocation
				)->Parameters).Write).Length;
			IoReleaseCancelSpinLock(OldIrql);
		}
		else
		{
			#line 526
			if(((((*
				CurrentOpIrp)->Tail).Overlay).CurrentStackLocation)
				->MajorFunction == 0x0e)
			{
				#line 529
				KIRQL OldIrql ;
				PIRP Irp ;
				PSERIAL_XOFF_COUNTER Xc ;
				#line 533
				IoAcquireCancelSpinLock(& OldIrql);
				#line 535
				Irp = * CurrentOpIrp;
				Xc = (Irp->AssociatedIrp).SystemBuffer;
				#line 543
				;
				#line 550
				;
				#line 557
				Extension->TotalCharsQueued--;
				#line 566
				if((Irp->IoStatus).Status != (NTSTATUS
					)0x00000000L)
				{
					#line 571
					;
				}
				else
				{
					#line 573
					if(Irp->Cancel)
					{
						(Irp->IoStatus).Status =
							(NTSTATUS )0xC0000120L;
					}
					else
					{
						#line 588
						(PDRIVER_CANCEL )((PVOID
							)InterlockedExchange((PLONG
							)((PVOID *  )(&
							Irp->CancelRoutine)),
							(LONG )((PVOID
							)SerialCancelCurrentXoff)
							));
						#line 593
						do
						{
							#line 593
							LONG _refType
								= 0x00000002;
							#line 593
							PULONG_PTR _arg4
								= (PVOID )(&
								(((((Irp->Tail).Overlay
								).CurrentStackLocation
								)->Parameters).Others
								).Argument4);
							#line 593
							;
							#line 593
							* _arg4 |= _refType;
						}
						while(0);
						#line 600
						CompleteCurrent = 0;
						#line 606
						Extension->CurrentXoffIrp = Irp;
						KeSynchronizeExecution(Extension
							->Interrupt,
							SerialGiveXoffToIsr,
							Extension);
						#line 619
						if(Xc->Timeout)
						{
							LARGE_INTEGER delta ;
							#line 623
							delta.QuadPart = -
								(LONGLONG
								)((ULONGLONG
								)((ULONGLONG
								)((ULONG )1000)
								* (ULONG
								)Xc->Timeout));
							#line 628
							SerialSetTimer(&
								Extension->XoffCountTimer
								, delta, &
								Extension->XoffCountTimeoutDpc
								, Extension);
							#line 639
							do
							{
	#line 639
	LONG _refType = 0x00000004;
	#line 639
	PULONG_PTR _arg4 = (PVOID )(&
		(((((Irp->Tail).Overlay).CurrentStackLocation)->Parameters).Others
		).Argument4);
	#line 639
	;
	#line 639
	* _arg4 |= _refType;
							}
							while(0);
						}
					}
				}
				IoReleaseCancelSpinLock(OldIrql);
			}
		}
		#line 654
		SerialGetNextIrp(CurrentOpIrp, QueueToProcess, NewIrp,
			CompleteCurrent, Extension);
		#line 662
		if(! * NewIrp)
		{
			KIRQL OldIrql ;
			#line 666
			IoAcquireCancelSpinLock(& OldIrql);
			KeSynchronizeExecution(Extension->Interrupt,
				SerialProcessEmptyTransmit, Extension);
			#line 672
			IoReleaseCancelSpinLock(OldIrql);
			#line 674
			break;
		}
		else
		{
			#line 676
			if(((((*
				NewIrp)->Tail).Overlay).CurrentStackLocation)->MajorFunction
				== 0x09)
			{
				#line 688
				;
				((* NewIrp)->IoStatus).Status = (NTSTATUS
					)0x00000000L;
			}
			else
			{
				#line 693
				break;
			}
		}
	}
	while(1);
}

#line 701
void SerialCompleteWrite(PKDPC Dpc , PVOID DeferredContext , PVOID
	SystemContext1 , PVOID SystemContext2 )
{
	#line 735
	PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
	KIRQL OldIrql ;
	#line 738
	SystemContext1;
	SystemContext2;
	#line 741
	do
	{
		#line 741
		;
	}
	while(0);
	#line 743
	IoAcquireCancelSpinLock(& OldIrql);
	#line 745
	SerialTryToCompleteCurrent(Extension, (void *  )0, OldIrql, (NTSTATUS
		)0x00000000L, & Extension->CurrentWriteIrp, &
		Extension->WriteQueue, (void *  )0, &
		Extension->WriteRequestTotalTimer, SerialStartWrite,
		SerialGetNextWrite, 0x00000001);
	#line 759
	SerialDpcEpilogue(Extension, Dpc);
}

#line 763
BOOLEAN SerialProcessEmptyTransmit(PVOID Context )
{
	#line 795
	PSERIAL_DEVICE_EXTENSION Extension = Context;
	;
	#line 798
	if(Extension->IsrWaitMask && Extension->IsrWaitMask & 0x0004 &&
		Extension->EmptiedTransmit && ! Extension->TransmitImmediate &&
		! Extension->CurrentWriteIrp && (& Extension->WriteQueue)->Flink
		== & Extension->WriteQueue)
	{
		#line 802
		Extension->HistoryMask |= 0x0004;
		if(Extension->IrpMaskLocation)
		{
			* Extension->IrpMaskLocation = Extension->HistoryMask;
			Extension->IrpMaskLocation = (void *  )0;
			Extension->HistoryMask = 0;
			#line 809
			((Extension->CurrentWaitIrp)->IoStatus).Information =
				sizeof(ULONG );
			#line 810
			SerialInsertQueueDpc(& Extension->CommWaitDpc, (void * 
				)0, (void *  )0, Extension);
		}
		#line 819
		Extension->CountOfTryingToLowerRTS++;
		SerialPerhapsLowerRTS(Extension);
	}
	#line 824
	return 0;
}

#line 828
BOOLEAN SerialGiveWriteToIsr(PVOID Context )
{
	#line 860
	PSERIAL_DEVICE_EXTENSION Extension = Context;
	#line 866
	PIO_STACK_LOCATION IrpSp ;
	#line 868
	;
	#line 870
	IrpSp =
		(((Extension->CurrentWriteIrp)->Tail).Overlay).CurrentStackLocation;
	#line 879
	if(IrpSp->MajorFunction == 0x04)
	{
		Extension->WriteLength = ((IrpSp->Parameters).Write).Length;
		Extension->WriteCurrentChar =
			((Extension->CurrentWriteIrp)->AssociatedIrp).SystemBuffer
			;
	}
	else
	{
		#line 887
		Extension->WriteLength = 1;
		Extension->WriteCurrentChar = (PUCHAR
			)((Extension->CurrentWriteIrp)->AssociatedIrp).SystemBuffer
			+ (LONG )((LONG_PTR )(& ((SERIAL_XOFF_COUNTER * 
			)0)->XoffChar));
	}
	#line 904
	do
	{
		#line 904
		LONG _refType = 0x00000001;
		#line 904
		PULONG_PTR _arg4 = (PVOID )(&
			((((((Extension->CurrentWriteIrp)->Tail).Overlay).CurrentStackLocation
			)->Parameters).Others).Argument4);
		#line 904
		;
		#line 904
		* _arg4 |= _refType;
	}
	while(0);
	#line 912
	if(! Extension->TransmitImmediate)
	{
		#line 928
		if(Extension->HoldingEmpty)
		{
			do
			{
				#line 930
				do
				{
					#line 930
					WRITE_PORT_UCHAR(Extension->Controller +
						(ULONG )(0x01 * 1), 0);
				}
				while(0);
			}
			while(0);
			#line 931
			do
			{
				#line 931
				do
				{
					#line 931
					WRITE_PORT_UCHAR(Extension->Controller +
						(ULONG )(0x01 * 1), (UCHAR
						)(0x01 | 0x02 | 0x04 | 0x08));
				}
				while(0);
			}
			while(0);
		}
	}
	#line 943
	if(((Extension->HandFlow).FlowReplace & (ULONG )0xc0) == (ULONG )0xc0)
	{
		#line 946
		SerialSetRTS(Extension);
	}
	#line 950
	return 0;
}

#line 954
void SerialCancelCurrentWrite(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
	#line 980
	PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
	;
	#line 983
	SerialTryToCompleteCurrent(Extension, SerialGrabWriteFromIsr,
		Irp->CancelIrql, (NTSTATUS )0xC0000120L, &
		Extension->CurrentWriteIrp, & Extension->WriteQueue, (void * 
		)0, & Extension->WriteRequestTotalTimer, SerialStartWrite,
		SerialGetNextWrite, 0x00000002);
}

#line 999
void SerialWriteTimeout(PKDPC Dpc , PVOID DeferredContext , PVOID SystemContext1
	, PVOID SystemContext2 )
{
	#line 1031
	PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
	KIRQL OldIrql ;
	#line 1034
	SystemContext1;
	SystemContext2;
	#line 1037
	do
	{
		#line 1037
		;
	}
	while(0);
	#line 1039
	IoAcquireCancelSpinLock(& OldIrql);
	#line 1041
	SerialTryToCompleteCurrent(Extension, SerialGrabWriteFromIsr, OldIrql,
		(NTSTATUS )0x00000102L, & Extension->CurrentWriteIrp, &
		Extension->WriteQueue, (void *  )0, &
		Extension->WriteRequestTotalTimer, SerialStartWrite,
		SerialGetNextWrite, 0x00000004);
	#line 1055
	SerialDpcEpilogue(Extension, Dpc);
}

BOOLEAN SerialGrabWriteFromIsr(PVOID Context )
{
	#line 1088
	PSERIAL_DEVICE_EXTENSION Extension = Context;
	;
	#line 1099
	if(Extension->WriteLength)
	{
		#line 1106
		if(((((Extension->CurrentWriteIrp)->Tail).Overlay).CurrentStackLocation
			)->MajorFunction == 0x04)
		{
			((Extension->CurrentWriteIrp)->IoStatus).Information =
				((((((Extension->CurrentWriteIrp)->Tail).Overlay
				).CurrentStackLocation)->Parameters).Write).Length
				- Extension->WriteLength;
		}
		else
		{
			#line 1117
			((Extension->CurrentWriteIrp)->IoStatus).Information =
				0;
		}
		#line 1129
		do
		{
			#line 1129
			LONG _refType = 0x00000001;
			#line 1129
			PULONG_PTR _arg4 = (PVOID )(&
				((((((Extension->CurrentWriteIrp)->Tail).Overlay
				).CurrentStackLocation)->Parameters).Others).Argument4
				);
			#line 1129
			;
			#line 1129
			* _arg4 &= ~ _refType;
		}
		while(0);
		#line 1131
		Extension->WriteLength = 0;
	}
	#line 1135
	return 0;
}

#line 1139
BOOLEAN SerialGrabXoffFromIsr(PVOID Context )
{
	#line 1171
	PSERIAL_DEVICE_EXTENSION Extension = Context;
	;
	#line 1174
	if(Extension->CountSinceXoff)
	{
		#line 1181
		Extension->CountSinceXoff = 0;
		#line 1191
		do
		{
			#line 1191
			LONG _refType = 0x00000001;
			#line 1191
			PULONG_PTR _arg4 = (PVOID )(&
				((((((Extension->CurrentXoffIrp)->Tail).Overlay)
				.CurrentStackLocation)->Parameters).Others).Argument4
				);
			#line 1191
			;
			#line 1191
			* _arg4 &= ~ _refType;
		}
		while(0);
	}
	return 0;
}

#line 1199
void SerialCompleteXoff(PKDPC Dpc , PVOID DeferredContext , PVOID SystemContext1
	, PVOID SystemContext2 )
{
	#line 1233
	PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
	KIRQL OldIrql ;
	#line 1236
	SystemContext1;
	SystemContext2;
	#line 1239
	do
	{
		#line 1239
		;
	}
	while(0);
	#line 1241
	IoAcquireCancelSpinLock(& OldIrql);
	#line 1243
	SerialTryToCompleteCurrent(Extension, (void *  )0, OldIrql, (NTSTATUS
		)0x00000000L, & Extension->CurrentXoffIrp, (void *  )0, (void * 
		)0, & Extension->XoffCountTimer, (void *  )0, (void *  )0,
		0x00000001);
	#line 1257
	SerialDpcEpilogue(Extension, Dpc);
}

#line 1261
void SerialTimeoutXoff(PKDPC Dpc , PVOID DeferredContext , PVOID SystemContext1
	, PVOID SystemContext2 )
{
	#line 1294
	PSERIAL_DEVICE_EXTENSION Extension = DeferredContext;
	KIRQL OldIrql ;
	#line 1297
	SystemContext1;
	SystemContext2;
	#line 1300
	do
	{
		#line 1300
		;
	}
	while(0);
	#line 1302
	IoAcquireCancelSpinLock(& OldIrql);
	#line 1304
	SerialTryToCompleteCurrent(Extension, SerialGrabXoffFromIsr, OldIrql,
		(NTSTATUS )0x4000000CL, & Extension->CurrentXoffIrp, (void * 
		)0, (void *  )0, (void *  )0, (void *  )0, (void *  )0,
		0x00000004);
	#line 1318
	SerialDpcEpilogue(Extension, Dpc);
}

#line 1322
void SerialCancelCurrentXoff(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
	#line 1348
	PSERIAL_DEVICE_EXTENSION Extension = DeviceObject->DeviceExtension;
	;
	#line 1351
	SerialTryToCompleteCurrent(Extension, SerialGrabXoffFromIsr,
		Irp->CancelIrql, (NTSTATUS )0xC0000120L, &
		Extension->CurrentXoffIrp, (void *  )0, (void *  )0, &
		Extension->XoffCountTimer, (void *  )0, (void *  )0,
		0x00000002);
}

#line 1367
BOOLEAN SerialGiveXoffToIsr(PVOID Context )
{
	#line 1398
	PSERIAL_DEVICE_EXTENSION Extension = Context;
	#line 1405
	PSERIAL_XOFF_COUNTER Xc
		= ((Extension->CurrentXoffIrp)->AssociatedIrp).SystemBuffer;
	#line 1408
	;
	#line 1410
	;
	Extension->CountSinceXoff = Xc->Counter;
	#line 1420
	do
	{
		#line 1420
		LONG _refType = 0x00000001;
		#line 1420
		PULONG_PTR _arg4 = (PVOID )(&
			((((((Extension->CurrentXoffIrp)->Tail).Overlay).CurrentStackLocation
			)->Parameters).Others).Argument4);
		#line 1420
		;
		#line 1420
		* _arg4 |= _refType;
	}
	while(0);
	#line 1422
	return 0;
}

#line 16 "C:/NTDDK/inc/stddef.h"

#pragma once
#line 77
typedef int ;

#line 86
typedef unsigned int ;

#line 95
typedef int ;

#line 105
typedef unsigned int ;

#line 112
typedef unsigned short ;

#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"

#pragma once
#line 32

#pragma pack(push, 8)
#line 72
typedef enum _EXCEPTION_DISPOSITION ;

#line 89
struct _EXCEPTION_RECORD ;

#line 90
struct _CONTEXT ;

#line 155

#pragma pack(pop)
#line 25 "C:/NTDDK/inc/ntdef.h"

#pragma once
#line 15 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"

#pragma once
#line 66
typedef wchar_t ;

#line 67
typedef wchar_t ;

#line 127 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long ;

#line 25 "C:/NTDDK/inc/basetsd.h"

#pragma once
#line 36
typedef int ;

#line 37
typedef int ;

#line 43
typedef unsigned int ;

#line 44
typedef unsigned int ;

#line 45
typedef unsigned int ;

#line 84
typedef int ;

#line 85
typedef unsigned int ;

typedef long ;

#line 88
typedef unsigned long ;

#line 248
typedef unsigned short ;

#line 249
typedef short ;

#line 250
typedef unsigned long ;

#line 288
typedef ULONG_PTR ;

#line 289
typedef LONG_PTR ;

#line 295
typedef ULONG_PTR ;

#line 301
typedef __int64 ;

#line 302
typedef __int64 ;

#line 309
typedef unsigned __int64 ;

#line 310
typedef unsigned __int64 ;

#line 311
typedef unsigned __int64 ;

#line 217 "C:/NTDDK/inc/ntdef.h"
typedef void ;

#line 218
typedef void ;

#line 266
typedef char ;

#line 267
typedef short ;

#line 268
typedef long ;

#line 276
typedef wchar_t ;

#line 282
typedef WCHAR ;

#line 283
typedef WCHAR ;

#line 284
typedef const WCHAR ;

#line 285
typedef WCHAR ;

#line 286
typedef WCHAR ;

typedef const WCHAR ;

#line 293
typedef CHAR ;

#line 294
typedef CHAR ;

typedef const CHAR ;

#line 297
typedef CHAR ;

#line 298
typedef CHAR ;

#line 299
typedef const CHAR ;

#line 321
typedef char ;

#line 322
typedef unsigned char ;

#line 326
typedef LPSTR ;

#line 327
typedef LPSTR ;

#line 328
typedef LPCSTR ;

#line 337
typedef double ;

typedef struct _QUAD ;

#line 349
typedef SHORT ;

#line 350
typedef LONG ;

#line 351
typedef QUAD ;

#line 360
typedef unsigned char ;

#line 361
typedef unsigned short ;

#line 362
typedef unsigned long ;

#line 363
typedef QUAD ;

#line 369
typedef UCHAR ;

#line 370
typedef USHORT ;

#line 371
typedef ULONG ;

#line 372
typedef UQUAD ;

#line 378
typedef signed char ;

#line 379
typedef SCHAR ;

#line 394
typedef void ;

#line 400
typedef HANDLE ;

#line 406
typedef UCHAR ;

#line 407
typedef USHORT ;

#line 408
typedef ULONG ;

#line 414
typedef LONG ;

#line 478
typedef char ;

#line 479
typedef short ;

#line 480
typedef ULONG ;

typedef CCHAR ;

#line 483
typedef CSHORT ;

#line 484
typedef CLONG ;

#line 492
typedef ULONG ;

#line 493
typedef PULONG ;

#line 494
typedef USHORT ;

#line 500
typedef ULONG ;

#line 501
typedef ULONG ;

#line 508
typedef LONG ;

typedef NTSTATUS ;

#line 602
typedef struct _FLOAT128 ;

#line 607
typedef FLOAT128 ;

#line 621
typedef __int64 ;

#line 622
typedef unsigned __int64 ;

#line 639
typedef LONGLONG ;

#line 640
typedef ULONGLONG ;

#line 644
typedef LONGLONG ;

#line 649
typedef union _LARGE_INTEGER ;

#line 662
typedef LARGE_INTEGER ;

#line 668
typedef union _ULARGE_INTEGER ;

#line 681
typedef ULARGE_INTEGER ;

#line 690
typedef struct _LUID ;

#line 696
typedef ULONGLONG ;

#line 697
typedef DWORDLONG ;

#line 707
typedef LARGE_INTEGER ;

#line 831

#pragma warning(push)

#pragma warning(disable:4035)
__inline ULONGLONG __stdcall Int64ShllMod32___14(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 842
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    
		};
}

#line 845
__inline LONGLONG __stdcall Int64ShraMod32___14(LONGLONG Value , ULONG
	ShiftCount )
{
	#line 852
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    
		};
}

#line 855
__inline ULONGLONG __stdcall Int64ShrlMod32___14(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 862
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    
		};
}


#pragma warning(pop)
#line 956
typedef enum _EVENT_TYPE ;

#line 965
typedef enum _TIMER_TYPE ;

#line 974
typedef enum _WAIT_TYPE ;

#line 983
typedef CHAR ;

#line 984
typedef const char ;

#line 991
typedef struct _STRING ;

#line 999
typedef STRING ;

typedef STRING ;

#line 1002
typedef PSTRING ;

typedef STRING ;

#line 1005
typedef PSTRING ;

#line 1011
typedef struct _CSTRING ;

#line 1016
typedef CSTRING ;

#line 1019
typedef STRING ;

#line 1020
typedef PSTRING ;

#line 1027
typedef struct _UNICODE_STRING ;

#line 1036
typedef UNICODE_STRING ;

#line 1037
typedef const UNICODE_STRING ;

#line 1046
typedef UCHAR ;

#line 1047
typedef BOOLEAN ;

#line 1057
typedef struct _LIST_ENTRY ;

#line 1067
typedef struct _SINGLE_LIST_ENTRY ;

#line 1078
typedef struct LIST_ENTRY32 ;

#line 1082
typedef LIST_ENTRY32 ;

typedef struct LIST_ENTRY64 ;

#line 1088
typedef LIST_ENTRY64 ;

#line 1127
typedef struct _STRING32 ;

#line 1132
typedef STRING32 ;

typedef STRING32 ;

#line 1135
typedef UNICODE_STRING32 ;

typedef STRING32 ;

#line 1138
typedef ANSI_STRING32 ;

#line 1141
typedef struct _STRING64 ;

#line 1146
typedef STRING64 ;

typedef STRING64 ;

#line 1149
typedef UNICODE_STRING64 ;

typedef STRING64 ;

#line 1152
typedef ANSI_STRING64 ;

#line 1173
typedef struct _OBJECT_ATTRIBUTES ;

#line 1181
typedef OBJECT_ATTRIBUTES ;

#line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID ;

#line 70
typedef GUID ;

#line 75
typedef const GUID ;

#line 81
typedef GUID ;

#line 82
typedef IID ;

#line 85
typedef GUID ;

#line 86
typedef CLSID ;

#line 89
typedef GUID ;

#line 90
typedef FMTID ;

#line 16 "C:/NTDDK/inc/string.h"

#pragma once
#line 1233 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECTID ;

#line 1288
struct _CONTEXT ;

#line 1289
struct _EXCEPTION_RECORD ;

typedef EXCEPTION_DISPOSITION ;

#line 1306
typedef UCHAR ;

typedef KIRQL ;

#line 1316
typedef enum _NT_PRODUCT_TYPE ;

#line 1329
typedef enum _SUITE_TYPE ;

#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD ;

#line 76
typedef struct _ETHREAD ;

#line 77
typedef struct _EPROCESS ;

#line 78
typedef struct _PEB ;

#line 79
typedef struct _KINTERRUPT ;

#line 80
typedef struct _IO_TIMER ;

#line 81
typedef struct _OBJECT_TYPE ;

#line 82
typedef struct _CALLBACK_OBJECT ;

#line 83
typedef struct _DEVICE_HANDLER_OBJECT ;

#line 84
typedef struct _BUS_HANDLER ;

#line 143
typedef union _SLIST_HEADER ;

#line 204
typedef CCHAR ;

typedef enum _MODE ;

#line 222
struct _KAPC ;

typedef void ;

#line 232
typedef void ;

#line 242
typedef void ;

#line 248
typedef BOOLEAN ;

#line 254
typedef BOOLEAN ;

#line 265
typedef struct _KAPC ;

#line 292
struct _KDPC ;

typedef void ;

#line 351
typedef enum _KDPC_IMPORTANCE ;

#line 361
typedef struct _KDPC ;

#line 377
typedef PVOID ;

typedef void ;

#line 392
typedef struct _KIPI_COUNTS ;

#line 443
typedef struct _MDL ;

#line 532
typedef PVOID ;

#line 538
typedef PVOID ;

#line 544
typedef PVOID ;

typedef ULONG ;

#line 547
typedef ACCESS_MASK ;

#line 597
typedef struct _GENERIC_MAPPING ;

#line 603
typedef GENERIC_MAPPING ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES ;

#line 622
typedef LUID_AND_ATTRIBUTES ;

#line 623
typedef LUID_AND_ATTRIBUTES_ARRAY ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 642 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACL ;

#line 649
typedef ACL ;

#line 681
typedef struct _PRIVILEGE_SET ;

#line 735
typedef enum _SECURITY_IMPERSONATION_LEVEL ;

#line 753
typedef BOOLEAN ;

#line 762
typedef struct _SECURITY_QUALITY_OF_SERVICE ;

#line 774
typedef struct _SE_IMPERSONATION_STATE ;

#line 782
typedef ULONG ;

#line 809
typedef ULONG ;

#line 810
typedef KAFFINITY ;

#line 816
typedef LONG ;

#line 824
typedef ULONG_PTR ;

#line 825
typedef KSPIN_LOCK ;

#line 833
typedef void ;

#line 842
typedef enum _KPROFILE_SOURCE ;

#line 1079
typedef NTSTATUS ;

#line 1088
typedef struct _RTL_QUERY_REGISTRY_TABLE ;

#line 1952

#pragma warning(push)

#pragma warning(disable:4035)
#line 2019

#pragma warning(pop)
#line 2214
typedef struct _TIME_FIELDS ;

#line 2224
typedef TIME_FIELDS ;

#line 2499
typedef struct _RTL_BITMAP ;

#line 2503
typedef RTL_BITMAP ;

#line 2627
typedef struct _RTL_BITMAP_RUN ;

#line 2633
typedef RTL_BITMAP_RUN ;

#line 2886
typedef struct _RTL_RANGE ;

#line 2924
typedef struct _RTL_RANGE_LIST ;

#line 2950
typedef struct _RANGE_LIST_ITERATOR ;

#line 3019
typedef BOOLEAN ;

#line 3155
typedef struct _OSVERSIONINFOA ;

#line 3164
typedef struct _OSVERSIONINFOW ;

#line 3177
typedef OSVERSIONINFOA ;

#line 3178
typedef POSVERSIONINFOA ;

#line 3179
typedef LPOSVERSIONINFOA ;

#line 3182
typedef struct _OSVERSIONINFOEXA ;

#line 3195
typedef struct _OSVERSIONINFOEXW ;

#line 3213
typedef OSVERSIONINFOEXA ;

#line 3214
typedef POSVERSIONINFOEXA ;

#line 3215
typedef LPOSVERSIONINFOEXA ;

#line 3648
typedef struct _IO_STATUS_BLOCK ;

#line 3669
typedef void ;

#line 3685
typedef enum _FILE_INFORMATION_CLASS ;

#line 3731
typedef struct _FILE_BASIC_INFORMATION ;

#line 3739
typedef struct _FILE_STANDARD_INFORMATION ;

#line 3747
typedef struct _FILE_POSITION_INFORMATION ;

#line 3751
typedef struct _FILE_ALIGNMENT_INFORMATION ;

#line 3755
typedef struct _FILE_NAME_INFORMATION ;

#line 3760
typedef struct _FILE_NETWORK_OPEN_INFORMATION ;

#line 3770
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION ;

#line 3775
typedef struct _FILE_DISPOSITION_INFORMATION ;

#line 3779
typedef struct _FILE_END_OF_FILE_INFORMATION ;

#line 3784
typedef struct _FILE_FULL_EA_INFORMATION ;

#line 3798
typedef enum _FSINFOCLASS ;

#line 3810
typedef struct _FILE_FS_DEVICE_INFORMATION ;

#line 3820
typedef union _FILE_SEGMENT_ELEMENT ;

#line 3829
typedef enum _INTERFACE_TYPE ;

#line 3854
typedef enum _DMA_WIDTH ;

#line 3865
typedef enum _DMA_SPEED ;

#line 3879
typedef void ;

#line 3880
typedef void ;

#line 3888
typedef enum _BUS_DATA_TYPE ;

#line 3910
typedef struct _IO_ERROR_LOG_PACKET ;

#line 3931
typedef struct _IO_ERROR_LOG_MESSAGE ;

#line 4074
typedef struct _KEY_BASIC_INFORMATION ;

#line 4081
typedef struct _KEY_NODE_INFORMATION ;

#line 4091
typedef struct _KEY_FULL_INFORMATION ;

#line 4106
typedef struct _KEY_NAME_INFORMATION ;

#line 4112
typedef enum _KEY_INFORMATION_CLASS ;

#line 4122
typedef struct _KEY_WRITE_TIME_INFORMATION ;

#line 4126
typedef enum _KEY_SET_INFORMATION_CLASS ;

#line 4134
typedef struct _KEY_VALUE_BASIC_INFORMATION ;

#line 4141
typedef struct _KEY_VALUE_FULL_INFORMATION ;

#line 4151
typedef struct _KEY_VALUE_PARTIAL_INFORMATION ;

#line 4158
typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ;

#line 4164
typedef struct _KEY_VALUE_ENTRY ;

#line 4171
typedef enum _KEY_VALUE_INFORMATION_CLASS ;

#line 4210
typedef struct _OBJECT_NAME_INFORMATION ;

#line 4221
typedef enum _SECTION_INHERIT ;

#line 4294
typedef struct _CLIENT_ID ;

#line 4298
typedef CLIENT_ID ;

#line 4315
typedef struct _NT_TIB ;

#line 4327
typedef NT_TIB ;

#line 4332
typedef enum _PROCESSINFOCLASS ;

#line 4366
typedef enum _THREADINFOCLASS ;

#line 4395
typedef struct _PROCESS_WS_WATCH_INFORMATION ;

#line 4405
typedef struct _PROCESS_BASIC_INFORMATION ;

#line 4413
typedef PROCESS_BASIC_INFORMATION ;

#line 4422
typedef struct _PROCESS_DEVICEMAP_INFORMATION ;

#line 4440
typedef struct _PROCESS_SESSION_INFORMATION ;

#line 4454
typedef struct _QUOTA_LIMITS ;

#line 4462
typedef QUOTA_LIMITS ;

#line 4472
typedef struct _IO_COUNTERS ;

#line 4480
typedef IO_COUNTERS ;

#line 4488
typedef struct _VM_COUNTERS ;

#line 4501
typedef VM_COUNTERS ;

#line 4508
typedef struct _POOLED_USAGE_AND_LIMITS ;

#line 4519
typedef POOLED_USAGE_AND_LIMITS ;

#line 4528
typedef struct _PROCESS_ACCESS_TOKEN ;

#line 4555
typedef struct _KERNEL_USER_TIMES ;

#line 4561
typedef KERNEL_USER_TIMES ;

#line 4587
typedef enum _SYSTEM_POWER_STATE ;

#line 4598
typedef enum  {
	PowerActionNone = 0,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
} ;

typedef enum _DEVICE_POWER_STATE ;

#line 4618
typedef union _POWER_STATE ;

#line 4623
typedef enum _POWER_STATE_TYPE ;

#line 4654
typedef ULONG ;

typedef enum  {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
} ;

#line 4663
typedef enum  {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation
} ;

#line 4690
typedef ULONG ;

typedef LONG ;

#line 4693
typedef ULONG ;

#line 4719
typedef union _MCI_STATS ;

#line 4978
typedef struct _KPCR ;

#line 5006
typedef KPCR ;

#line 5012
typedef struct _KFLOATING_SAVE ;

#line 5153
typedef enum _INTERLOCKED_RESULT ;

#line 5252

#pragma warning(disable:4035)
#line 6994
typedef struct _KSYSTEM_TIME ;

#line 7014

#pragma warning(push)

#pragma warning(disable:4164)
#line 7019

#pragma function(_enable)
#line 7020

#pragma function(_disable)
#line 7024

#pragma warning(pop)
#line 7085
typedef struct _FLOATING_SAVE_AREA ;

#line 7097
typedef FLOATING_SAVE_AREA ;

#line 7109
typedef struct _CONTEXT ;

#line 7197
typedef CONTEXT ;

#line 7826
typedef void ;

#line 7850
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ;

#line 7899
typedef struct _KUSER_SHARED_DATA ;

#line 8123
typedef enum _CM_SERVICE_NODE_TYPE ;

#line 8132
typedef enum _CM_SERVICE_LOAD_TYPE ;

#line 8140
typedef enum _CM_ERROR_CONTROL_TYPE ;

#line 8172
typedef int ;

#line 8198
typedef enum _CM_SHARE_DISPOSITION ;

#line 8211
typedef PVOID ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST ;

#line 8443
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR ;

#line 8454
typedef struct _CM_RESOURCE_LIST ;

#line 8471
typedef struct _DEVICE_FLAGS ;

#line 8485
typedef struct _CM_COMPONENT_INFORMATION ;

#line 8503
typedef struct _CM_ROM_BLOCK ;

#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 8518 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_INT13_DRIVE_PARAMETER ;

#line 8532
typedef struct _CM_MCA_POS_DATA ;

#line 8544
typedef struct _EISA_MEMORY_TYPE ;

#line 8554
typedef struct _EISA_MEMORY_CONFIGURATION ;

#line 8567
typedef struct _EISA_IRQ_DESCRIPTOR ;

#line 8575
typedef struct _EISA_IRQ_CONFIGURATION ;

#line 8585
typedef struct _DMA_CONFIGURATION_BYTE0 ;

#line 8592
typedef struct _DMA_CONFIGURATION_BYTE1 ;

#line 8599
typedef struct _EISA_DMA_CONFIGURATION ;

#line 8609
typedef struct _EISA_PORT_DESCRIPTOR ;

#line 8616
typedef struct _EISA_PORT_CONFIGURATION ;

#line 8628
typedef struct _CM_EISA_SLOT_INFORMATION ;

#line 8644
typedef struct _CM_EISA_FUNCTION_INFORMATION ;

#line 8678
typedef struct _CM_PNP_BIOS_DEVICE_NODE ;

#line 8692
typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8761 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_SCSI_DEVICE_DATA ;

#line 8775
typedef struct _CM_VIDEO_DEVICE_DATA ;

#line 8785
typedef struct _CM_SONIC_DEVICE_DATA ;

#line 8796
typedef struct _CM_SERIAL_DEVICE_DATA ;

#line 8810
typedef struct _CM_MONITOR_DEVICE_DATA ;

#line 8844
typedef struct _CM_FLOPPY_DEVICE_DATA ;

#line 8881
typedef struct _CM_KEYBOARD_DEVICE_DATA ;

#line 8893
typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA ;

#line 8905
typedef struct _CM_PCCARD_DEVICE_DATA ;

#line 8944
typedef struct _IO_RESOURCE_DESCRIPTOR ;

#line 9027
typedef struct _IO_RESOURCE_LIST ;

#line 9036
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST ;

#line 9065
typedef struct _EXCEPTION_RECORD ;

#line 9074
typedef EXCEPTION_RECORD ;

typedef struct _EXCEPTION_RECORD32 ;

#line 9085
typedef struct _EXCEPTION_RECORD64 ;

#line 9099
typedef struct _EXCEPTION_POINTERS ;

#line 9111
typedef enum _CONFIGURATION_TYPE ;

#line 9161
typedef enum _KINTERRUPT_MODE ;

#line 9170
typedef enum _KWAIT_REASON ;

#line 9207
typedef struct _DISPATCHER_HEADER ;

#line 9217
typedef struct _KWAIT_BLOCK ;

#line 9230
typedef void ;

#line 9244
typedef struct _KDEVICE_QUEUE ;

#line 9252
typedef struct _KDEVICE_QUEUE_ENTRY ;

#line 9263
typedef struct _KEVENT ;

#line 9271
typedef BOOLEAN ;

#line 9281
typedef struct _KMUTANT ;

#line 9294
typedef struct _KSEMAPHORE ;

#line 9304
typedef struct _KTIMER ;

#line 9899
typedef enum _KBUGCHECK_BUFFER_DUMP_STATE ;

#line 9907
typedef void ;

#line 9914
typedef struct _KBUGCHECK_CALLBACK_RECORD ;

#line 10002
typedef void ;

#line 10020
typedef LOGICAL ;

#line 10037
typedef void ;

#line 10053
typedef enum _MEMORY_CACHING_TYPE_ORIG ;

#line 10057
typedef enum _MEMORY_CACHING_TYPE ;

#line 10087
typedef struct _DBGKD_DEBUG_DATA_HEADER64 ;

#line 10115
typedef enum _POOL_TYPE ;

#line 10195
typedef enum _EX_POOL_PRIORITY ;

#line 10247
typedef struct _FAST_MUTEX ;

#line 10574
typedef PVOID ;

#line 10582
typedef void ;

#line 10588
typedef struct _GENERAL_LOOKASIDE ;

#line 10619
typedef struct _NPAGED_LOOKASIDE_LIST ;

#line 10729
typedef struct _PAGED_LOOKASIDE_LIST ;

#line 10882
typedef enum _WORK_QUEUE_TYPE ;

#line 10889
typedef void ;

#line 10895
typedef struct _WORK_QUEUE_ITEM ;

#line 10926
typedef struct _ZONE_SEGMENT_HEADER ;

#line 10931
typedef struct _ZONE_HEADER ;

#line 11156
typedef ULONG_PTR ;

#line 11157
typedef ERESOURCE_THREAD ;

typedef struct _OWNER_ENTRY ;

#line 11168
typedef struct _ERESOURCE ;

#line 11197
typedef struct _RESOURCE_HASH_ENTRY ;

#line 11204
typedef struct _RESOURCE_PERFORMANCE_DATA ;

#line 11429
typedef struct _CALLBACK_OBJECT ;

typedef void ;

#line 11474
typedef GUID ;

#line 11862
typedef enum _MM_SYSTEM_SIZE ;

#line 11884
typedef enum _LOCK_OPERATION ;

#line 11970
typedef enum _MM_PAGE_PRIORITY ;

#line 11999
typedef struct _PHYSICAL_MEMORY_RANGE ;

#line 12385
typedef NTSTATUS ;

#line 12389
typedef NTSTATUS ;

#line 12399
struct _DRIVER_OBJECT ;

#line 12411
typedef enum _SECURITY_OPERATION_CODE ;

#line 12426
typedef struct _SECURITY_SUBJECT_CONTEXT ;

#line 12448
typedef struct _INITIAL_PRIVILEGE_SET ;

#line 12462
typedef struct _ACCESS_STATE ;

#line 12571
typedef void ;

#line 12585
typedef void ;

#line 12602
typedef struct _IMAGE_INFO ;

#line 12620
typedef void ;

#line 12859
typedef NTSTATUS ;

#line 12878
typedef enum _IO_QUERY_DEVICE_DATA_FORMAT ;

#line 12890
typedef enum _CREATE_FILE_TYPE ;

#line 12905
struct _DEVICE_DESCRIPTION ;

#line 12906
struct _DEVICE_OBJECT ;

#line 12907
struct _DMA_ADAPTER ;

#line 12908
struct _DRIVER_OBJECT ;

#line 12909
struct _DRIVE_LAYOUT_INFORMATION ;

#line 12910
struct _DISK_PARTITION ;

#line 12911
struct _FILE_OBJECT ;

#line 12912
struct _IRP ;

#line 12913
struct _SCSI_REQUEST_BLOCK ;

#line 12919
typedef void ;

#line 12932
typedef void ;

#line 12943
typedef NTSTATUS ;

#line 12955
typedef void ;

#line 12968
typedef void ;

#line 12979
typedef NTSTATUS ;

#line 12990
typedef void ;

#line 13001
typedef void ;

#line 13011
typedef NTSTATUS ;

#line 13025
typedef BOOLEAN ;

#line 13038
typedef BOOLEAN ;

#line 13051
typedef BOOLEAN ;

#line 13068
typedef BOOLEAN ;

#line 13078
typedef BOOLEAN ;

#line 13092
typedef BOOLEAN ;

#line 13106
typedef BOOLEAN ;

#line 13118
typedef BOOLEAN ;

#line 13127
typedef BOOLEAN ;

#line 13141
typedef BOOLEAN ;

#line 13161
typedef void ;

#line 13167
typedef void ;

#line 13179
typedef void ;

#line 13193
typedef BOOLEAN ;

#line 13207
typedef BOOLEAN ;

#line 13219
typedef BOOLEAN ;

#line 13227
typedef BOOLEAN ;

#line 13239
typedef BOOLEAN ;

#line 13253
typedef NTSTATUS ;

#line 13262
typedef NTSTATUS ;

#line 13275
typedef NTSTATUS ;

#line 13282
typedef NTSTATUS ;

#line 13289
typedef BOOLEAN ;

#line 13304
typedef BOOLEAN ;

#line 13319
typedef BOOLEAN ;

#line 13327
typedef BOOLEAN ;

#line 13336
typedef BOOLEAN ;

#line 13350
typedef struct _FAST_IO_DISPATCH ;

#line 13386
typedef enum _IO_ALLOCATION_ACTION ;

#line 13396
typedef IO_ALLOCATION_ACTION ;

#line 13410
typedef struct _IO_SECURITY_CONTEXT ;

#line 13434
typedef struct _VPB ;

#line 13482
typedef struct _ADAPTER_OBJECT ;

#line 13491
typedef struct _WAIT_CONTEXT_BLOCK ;

#line 13503
typedef struct _CONTROLLER_OBJECT ;

#line 13537
typedef struct _DEVICE_OBJECT ;

#line 13575
typedef struct _DEVICE_OBJECT ;

#line 13578
struct _DEVICE_OBJECT_POWER_EXTENSION ;

typedef struct _DEVOBJ_EXTENSION ;

#line 13608
typedef struct _DRIVER_EXTENSION ;

#line 13645
typedef struct _DRIVER_OBJECT ;

#line 13706
typedef struct _DRIVER_OBJECT ;

#line 13715
typedef struct _SECTION_OBJECT_POINTERS ;

#line 13720
typedef SECTION_OBJECT_POINTERS ;

#line 13726
typedef struct _IO_COMPLETION_CONTEXT ;

#line 13759
typedef struct _FILE_OBJECT ;

#line 13788
typedef struct _FILE_OBJECT ;

#line 13828
typedef struct _IRP ;

#line 14078
typedef NTSTATUS ;

#line 14163
typedef enum _DEVICE_RELATION_TYPE ;

#line 14171
typedef struct _DEVICE_RELATIONS ;

#line 14176
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE ;

#line 14185
typedef struct _INTERFACE ;

#line 14196
typedef struct _DEVICE_CAPABILITIES ;

#line 14229
typedef struct _POWER_SEQUENCE ;

#line 14235
typedef enum  {
	BusQueryDeviceID = 0,
	BusQueryHardwareIDs = 1,
	BusQueryCompatibleIDs = 2,
	BusQueryInstanceID = 3,
	BusQueryDeviceSerialNumber = 4
} ;

typedef ULONG ;

#line 14252
typedef enum  {
	DeviceTextDescription = 0,
	DeviceTextLocationInformation = 1
} ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 14615 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SHARE_ACCESS ;

#line 14635
typedef struct _CONFIGURATION_INFORMATION ;

#line 14848
typedef struct _BOOTDISK_INFORMATION ;

#line 15754
typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK ;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK ;

#line 15764
typedef struct _IO_REMOVE_LOCK_DBG_BLOCK ;

#line 15777
typedef struct _IO_REMOVE_LOCK ;

#line 16009
typedef struct _IO_WORKITEM ;

typedef void ;

#line 16100
typedef enum  {
	DevicePropertyDeviceDescription,
	DevicePropertyHardwareID,
	DevicePropertyCompatibleIDs,
	DevicePropertyBootConfiguration,
	DevicePropertyBootConfigurationTranslated,
	DevicePropertyClassName,
	DevicePropertyClassGuid,
	DevicePropertyDriverKeyName,
	DevicePropertyManufacturer,
	DevicePropertyFriendlyName,
	DevicePropertyLocationInformation,
	DevicePropertyPhysicalDeviceObjectName,
	DevicePropertyBusTypeGuid,
	DevicePropertyLegacyBusType,
	DevicePropertyBusNumber,
	DevicePropertyEnumeratorName,
	DevicePropertyAddress,
	DevicePropertyUINumber
} ;

typedef BOOLEAN ;

#line 16129
typedef struct _DMA_ADAPTER ;

#line 16135
typedef ULONG ;

#line 16148
typedef struct _PNP_BUS_INFORMATION ;

#line 16162
typedef struct _LEGACY_BUS_INFORMATION ;

#line 16168
typedef struct _BUS_INTERFACE_STANDARD ;

#line 16190
typedef BOOLEAN ;

#line 16194
typedef NTSTATUS ;

#line 16203
typedef NTSTATUS ;

#line 16206
typedef NTSTATUS ;

#line 16210
typedef NTSTATUS ;

#line 16214
typedef NTSTATUS ;

#line 16218
typedef void ;

#line 16222
typedef NTSTATUS ;

#line 16227
typedef void ;

#line 16231
typedef struct _ACPI_INTERFACE_STANDARD ;

#line 16255
typedef enum _ACPI_REG_TYPE ;

#line 16268
typedef USHORT ;

#line 16272
typedef void ;

#line 16278
typedef struct ACPI_REGS_INTERFACE_STANDARD ;

#line 16300
typedef struct  {
	PVOID LinkNode ;
	ULONG StaticVector ;
	UCHAR Flags ;
} ;

#line 16314
typedef NTSTATUS ;

#line 16329
typedef NTSTATUS ;

#line 16336
typedef void ;

#line 16343
typedef struct _INT_ROUTE_INTERFACE_STANDARD ;

#line 16366
typedef struct _IO_ASSIGNED_RESOURCES ;

#line 16490
typedef enum _IO_NOTIFICATION_EVENT_CATEGORY ;

#line 16504
typedef NTSTATUS ;

#line 16537
typedef void ;

#line 16573
typedef enum _ARBITER_ACTION ;

#line 16586
typedef struct _ARBITER_CONFLICT_INFO ;

#line 16608
typedef struct _ARBITER_PARAMETERS ;

#line 16719
typedef enum _ARBITER_REQUEST_SOURCE ;

#line 16731
typedef enum _ARBITER_RESULT ;

#line 16761
typedef struct _ARBITER_LIST_ENTRY ;

#line 16832
typedef NTSTATUS ;

#line 16853
typedef struct _ARBITER_INTERFACE ;

#line 16880
typedef enum _RESOURCE_TRANSLATION_DIRECTION ;

#line 16889
typedef NTSTATUS ;

#line 16901
typedef NTSTATUS ;

#line 16915
typedef struct _TRANSLATOR_INTERFACE ;

#line 16931
typedef NTSTATUS ;

#line 16945
typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE ;

#line 16959
typedef struct _PLUGPLAY_NOTIFICATION_HEADER ;

#line 16972
typedef struct _HWPROFILE_CHANGE_NOTIFICATION ;

#line 16986
typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION ;

#line 17006
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION ;

#line 17026
typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION ;

#line 17054
typedef struct _DEVICE_DESCRIPTION ;

#line 17086
typedef BOOLEAN ;

#line 17333
typedef void ;

#line 17339
typedef struct _DEVICE_CONTROL_CONTEXT ;

#line 17349
typedef PBUS_HANDLER ;

#line 17355
typedef void ;

#line 17365
typedef enum _HAL_QUERY_INFORMATION_CLASS ;

#line 17381
typedef enum _HAL_SET_INFORMATION_CLASS ;

#line 17388
typedef NTSTATUS ;

#line 17405
typedef NTSTATUS ;

#line 17420
typedef void ;

#line 17429
typedef void ;

#line 17438
typedef NTSTATUS ;

#line 17447
typedef NTSTATUS ;

#line 17456
typedef NTSTATUS ;

#line 17466
typedef NTSTATUS ;

#line 17475
typedef NTSTATUS ;

#line 17486
typedef struct _PM_DISPATCH_TABLE ;

#line 17492
typedef NTSTATUS ;

#line 17505
typedef struct _DMA_ADAPTER ;

#line 17520
typedef NTSTATUS ;

#line 17543
typedef BOOLEAN ;

#line 17553
typedef NTSTATUS ;

#line 17566
typedef void ;

#line 17572
typedef void ;

#line 17578
typedef BOOLEAN ;

#line 17588
typedef struct  {
	ULONG Version ;
	pHalQuerySystemInformation HalQuerySystemInformation ;
	pHalSetSystemInformation HalSetSystemInformation ;
	pHalQueryBusSlots HalQueryBusSlots ;
	ULONG Spare1 ;
	pHalExamineMBR HalExamineMBR ;
	pHalIoAssignDriveLetters HalIoAssignDriveLetters ;
	pHalIoReadPartitionTable HalIoReadPartitionTable ;
	pHalIoSetPartitionInformation HalIoSetPartitionInformation ;
	pHalIoWritePartitionTable HalIoWritePartitionTable ;
	pHalHandlerForBus HalReferenceHandlerForBus ;
	pHalReferenceBusHandler HalReferenceBusHandler ;
	pHalReferenceBusHandler HalDereferenceBusHandler ;
	pHalInitPnpDriver HalInitPnpDriver ;
	pHalInitPowerManagement HalInitPowerManagement ;
	pHalGetDmaAdapter HalGetDmaAdapter ;
	pHalGetInterruptTranslator HalGetInterruptTranslator ;
} ;

#line 17650
typedef struct _HAL_BUS_INFORMATION ;

#line 17658
typedef struct _HAL_PROFILE_SOURCE_INFORMATION ;

#line 17665
typedef struct _HAL_PROFILE_SOURCE_INTERVAL ;

#line 17671
typedef enum _HAL_DISPLAY_BIOS_INFORMATION ;

#line 17678
typedef struct _HAL_POWER_INFORMATION ;

#line 17683
typedef struct _HAL_PROCESSOR_SPEED_INFO ;

#line 17688
typedef struct _HAL_CALLBACKS ;

#line 17694
typedef struct _HAL_PROCESSOR_FEATURE ;

#line 17706
typedef union _MCI_ADDR ;

#line 17716
typedef enum  {
	HAL_MCE_RECORD,
	HAL_MCA_RECORD
} ;

#line 17726
typedef struct _MCA_EXCEPTION ;

#line 17752
typedef void ;

#line 17762
typedef struct _MCA_DRIVER_INFO ;

#line 17772
typedef struct _SCATTER_GATHER_ELEMENT ;

#line 17778

#pragma warning(disable:4200)
#line 17779
typedef struct _SCATTER_GATHER_LIST ;

#line 17784

#pragma warning(default:4200)
#line 17788
typedef struct _DMA_OPERATIONS ;

typedef struct _DMA_ADAPTER ;

#line 17797
typedef void ;

#line 17801
typedef PVOID ;

#line 17808
typedef void ;

#line 17816
typedef NTSTATUS ;

#line 17824
typedef BOOLEAN ;

#line 17833
typedef void ;

#line 17837
typedef void ;

#line 17843
typedef PHYSICAL_ADDRESS ;

#line 17852
typedef ULONG ;

#line 17856
typedef ULONG ;

#line 17860
typedef void ;

#line 17868
typedef NTSTATUS ;

#line 17880
typedef void ;

#line 17887
typedef struct _DMA_OPERATIONS ;

#line 18235
typedef void ;

#line 18321
typedef struct _OBJECT_HANDLE_INFORMATION ;

#line 18402
typedef struct _PCI_SLOT_NUMBER ;

#line 18418
typedef struct _PCI_COMMON_CONFIG ;

#line 18591
typedef struct _PCI_CAPABILITIES_HEADER ;

#line 18600
typedef struct _PCI_PMC ;

#line 18618
typedef struct _PCI_PMCSR ;

#line 18628
typedef struct _PCI_PMCSR_BSE ;

#line 18635
typedef struct _PCI_PM_CAPABILITY ;

#line 18679
typedef struct _PCI_AGP_CAPABILITY ;

#line 18720
typedef struct _PCI_MSI_CAPABILITY ;

#line 18946
typedef void ;

#line 18954
typedef void ;

#line 18963
typedef void ;

#line 18975
typedef struct _PCIBUSDATA ;

#line 18986
typedef ULONG ;

#line 18995
typedef void ;

#line 19000
typedef void ;

#line 19006
typedef struct _PCI_BUS_INTERFACE_STANDARD ;

#line 19028
typedef BOOLEAN ;

#line 19043
typedef struct _PCI_DEVICE_PRESENT_INTERFACE ;

#line 127 "C:/NTDDK/inc/ntddser.h"
typedef struct _SERIALPERF_STATS ;

#line 136
typedef struct _SERIALCONFIG ;

#line 154
typedef struct _SERIAL_LINE_CONTROL ;

#line 160
typedef struct _SERIAL_TIMEOUTS ;

#line 175
typedef struct _SERIAL_QUEUE_SIZE ;

#line 185
typedef struct _SERIAL_BAUD_RATE ;

#line 247
typedef struct _SERIAL_CHARS ;

#line 284
typedef struct _SERIAL_HANDFLOW ;

#line 340
typedef struct _SERIAL_BASIC_SETTINGS ;

#line 353
typedef struct _SERIAL_STATUS ;

#line 433
typedef struct _SERIAL_XOFF_COUNTER ;

#line 539
typedef struct _SERIAL_COMMPROP ;

#line 631
typedef struct _SERENUM_PORT_DESC ;

#line 652
typedef UCHAR ;

#line 658
typedef void ;

#line 665
typedef enum _SERENUM_PORTION ;

#line 671
typedef struct _SERENUM_PORT_PARAMETERS ;

#line 28 "C:/NTDDK/inc/ddk/wdm/wmilib.h"

#pragma once
#line 38
typedef struct  {
	LPCGUID Guid ;
	ULONG InstanceCount ;
	ULONG Flags ;
} ;

#line 45
typedef NTSTATUS ;

#line 101
typedef NTSTATUS ;

#line 162
typedef NTSTATUS ;

#line 206
typedef NTSTATUS ;

#line 253
typedef NTSTATUS ;

#line 306
typedef enum  {
	WmiEventControl,
	WmiDataBlockControl
} ;

#line 312
typedef NTSTATUS ;

#line 355
typedef struct _WMILIB_CONTEXT ;

#line 411
typedef enum  {
	IrpProcessed,
	IrpNotCompleted,
	IrpNotWmi,
	IrpForward
} ;

#line 13 "C:/NTDDK/inc/wmidata.h"
typedef struct _MSWmi_MofData ;

#line 51
typedef struct _MSWmi_ProviderInfo ;

#line 66
typedef struct _MSWmi_PnPDeviceId ;

#line 83
typedef struct _MSWmi_PnPInstanceNames ;

#line 105
typedef struct _MSSmBios_RawSMBiosTables ;

#line 147
typedef struct _MSPower_DeviceEnable ;

#line 165
typedef struct _MSPower_DeviceWakeEnable ;

#line 182
typedef struct _MSNdis_NetworkAddress ;

#line 199
typedef struct _MSNdis_NetworkShortAddress ;

#line 216
typedef struct _MSNdis_NetworkLinkSpeed ;

#line 239
typedef struct _MSNdis_EnumerateAdapter ;

#line 256
typedef struct _MSNdis_NotifyAdapterRemoval ;

#line 273
typedef struct _MSNdis_NotifyAdapterArrival ;

#line 291
typedef struct _MSNdis_NdisEnumerateVc ;

#line 307
typedef struct _MSNdis_NotifyVcRemoval ;

#line 323
typedef struct _MSNdis_NotifyVcArrival ;

#line 338
typedef struct _MSNdis_HardwareStatus ;

#line 356
typedef struct _MSNdis_MediaSupported ;

#line 378
typedef struct _MSNdis_MediaInUse ;

#line 400
typedef struct _MSNdis_MaximumLookahead ;

#line 418
typedef struct _MSNdis_MaximumFrameSize ;

#line 436
typedef struct _MSNdis_LinkSpeed ;

#line 454
typedef struct _MSNdis_TransmitBufferSpace ;

#line 472
typedef struct _MSNdis_ReceiveBufferSpace ;

#line 490
typedef struct _MSNdis_TransmitBlockSize ;

#line 508
typedef struct _MSNdis_ReceiveBlockSize ;

#line 526
typedef struct _MSNdis_VendorID ;

#line 544
typedef struct _MSNdis_VendorDescription ;

#line 561
typedef struct _MSNdis_CurrentPacketFilter ;

#line 579
typedef struct _MSNdis_CurrentLookahead ;

#line 597
typedef struct _MSNdis_DriverVersion ;

#line 615
typedef struct _MSNdis_MaximumTotalSize ;

#line 633
typedef struct _MSNdis_MacOptions ;

#line 651
typedef struct _MSNdis_MediaConnectStatus ;

#line 669
typedef struct _MSNdis_MaximumSendPackets ;

#line 687
typedef struct _MSNdis_VendorDriverVersion ;

#line 705
typedef struct _MSNdis_TransmitsOk ;

#line 723
typedef struct _MSNdis_ReceivesOk ;

#line 741
typedef struct _MSNdis_TransmitsError ;

#line 759
typedef struct _MSNdis_ReceiveError ;

#line 777
typedef struct _MSNdis_ReceiveNoBuffer ;

#line 795
typedef struct _MSNdis_CoHardwareStatus ;

#line 813
typedef struct _MSNdis_CoMediaSupported ;

#line 835
typedef struct _MSNdis_CoMediaInUse ;

#line 857
typedef struct _MSNdis_CoLinkSpeed ;

#line 875
typedef struct _MSNdis_CoVendorId ;

#line 893
typedef struct _MSNdis_CoVendorDescription ;

#line 910
typedef struct _MSNdis_CoDriverVersion ;

#line 928
typedef struct _MSNdis_CoMacOptions ;

#line 946
typedef struct _MSNdis_CoMediaConnectStatus ;

#line 964
typedef struct _MSNdis_CoVendorDriverVersion ;

#line 982
typedef struct _MSNdis_CoMinimumLinkSpeed ;

#line 1000
typedef struct _MSNdis_CoTransmitPdusOk ;

#line 1018
typedef struct _MSNdis_CoReceivePdusOk ;

#line 1036
typedef struct _MSNdis_CoTransmitPduErrors ;

#line 1054
typedef struct _MSNdis_CoReceivePduErrors ;

#line 1072
typedef struct _MSNdis_CoReceivePdusNoBuffer ;

#line 1090
typedef struct _MSNdis_AtmSupportedVcRates ;

#line 1113
typedef struct _MSNdis_AtmSupportedServiceCategory ;

#line 1131
typedef struct _MSNdis_AtmSupportedAalTypes ;

#line 1149
typedef struct _MSNdis_AtmHardwareCurrentAddress ;

#line 1167
typedef struct _MSNdis_AtmMaxActiveVcs ;

#line 1185
typedef struct _MSNdis_AtmMaxActiveVciBits ;

#line 1203
typedef struct _MSNdis_AtmMaxActiveVpiBits ;

#line 1221
typedef struct _MSNdis_AtmMaxAal0PacketSize ;

#line 1239
typedef struct _MSNdis_AtmMaxAal1PacketSize ;

#line 1257
typedef struct _MSNdis_AtmMaxAal34PacketSize ;

#line 1275
typedef struct _MSNdis_AtmMaxAal5PacketSize ;

#line 1293
typedef struct _MSNdis_AtmReceiveCellsOk ;

#line 1311
typedef struct _MSNdis_AtmTransmitCellsOk ;

#line 1329
typedef struct _MSNdis_AtmReceiveCellsDropped ;

#line 1347
typedef struct _MSNdis_EthernetPermanentAddress ;

#line 1365
typedef struct _MSNdis_EthernetCurrentAddress ;

#line 1383
typedef struct _MSNdis_EthernetMulticastList ;

#line 1405
typedef struct _MSNdis_EthernetMaximumMulticastListSize ;

#line 1423
typedef struct _MSNdis_EthernetMacOptions ;

#line 1441
typedef struct _MSNdis_EthernetReceiveErrorAlignment ;

#line 1459
typedef struct _MSNdis_EthernetOneTransmitCollision ;

#line 1477
typedef struct _MSNdis_EthernetMoreTransmitCollisions ;

#line 1495
typedef struct _MSNdis_TokenRingPermanentAddress ;

#line 1513
typedef struct _MSNdis_TokenRingCurrentAddress ;

#line 1531
typedef struct _MSNdis_TokenRingCurrentFunctional ;

#line 1549
typedef struct _MSNdis_TokenRingCurrentGroup ;

#line 1567
typedef struct _MSNdis_TokenRingLastOpenStatus ;

#line 1585
typedef struct _MSNdis_TokenRingCurrentRingStatus ;

#line 1603
typedef struct _MSNdis_TokenRingCurrentRingState ;

#line 1621
typedef struct _MSNdis_TokenRingLineErrors ;

#line 1639
typedef struct _MSNdis_TokenRingLostFrames ;

#line 1657
typedef struct _MSNdis_FddiLongPermanentAddress ;

#line 1675
typedef struct _MSNdis_FddiLongCurrentAddress ;

#line 1693
typedef struct _MSNdis_FddiLongMulticastList ;

#line 1715
typedef struct _MSNdis_FddiLongMaximumListSize ;

#line 1733
typedef struct _MSNdis_FddiShortPermanentAddress ;

#line 1751
typedef struct _MSNdis_FddiShortCurrentAddress ;

#line 1769
typedef struct _MSNdis_FddiShortMulticastList ;

#line 1791
typedef struct _MSNdis_FddiShortMaximumListSize ;

#line 1809
typedef struct _MSNdis_FddiAttachmentType ;

#line 1827
typedef struct _MSNdis_FddiUpstreamNodeLong ;

#line 1845
typedef struct _MSNdis_FddiDownstreamNodeLong ;

#line 1863
typedef struct _MSNdis_FddiFrameErrors ;

#line 1881
typedef struct _MSNdis_FddiFramesLost ;

#line 1899
typedef struct _MSNdis_FddiRingManagmentState ;

#line 1917
typedef struct _MSNdis_FddiLctFailures ;

#line 1935
typedef struct _MSNdis_FddiLemRejects ;

#line 1953
typedef struct _MSNdis_FddiLConnectionState ;

#line 1972
typedef struct _MSNdis_StatusResetStart ;

#line 1988
typedef struct _MSNdis_StatusResetEnd ;

#line 2004
typedef struct _MSNdis_StatusMediaConnect ;

#line 2020
typedef struct _MSNdis_StatusMediaDisconnect ;

#line 2035
typedef struct _MSNdis_StatusMediaSpecificIndication ;

#line 2057
typedef struct _MSNdis_StatusLinkSpeedChange ;

#line 2075
typedef struct _MSNdis_StatusProtocolBind ;

#line 2092
typedef struct _MSNdis_StatusProtocolUnbind ;

#line 2109
typedef struct _KEYBOARD_PORT_WMI_STD_DATA ;

#line 2152
typedef struct _POINTER_PORT_WMI_STD_DATA ;

#line 2205
typedef struct _MSMouse_ClassInformation ;

#line 2223
typedef struct _MSKeyboard_ClassInformation ;

#line 2241
typedef struct _MSAcpi_ThermalZoneTemperature ;

#line 2304
typedef struct _WMI_DISK_GEOMETRY ;

#line 2342
typedef struct _WMI_DISK_PERFORMANCE ;

#line 2415
typedef struct _MSDiskDriver_Performance ;

#line 2437
typedef struct _STORAGE_FAILURE_PREDICT_STATUS ;

#line 2460
typedef struct _STORAGE_FAILURE_PREDICT_DATA ;

#line 2483
typedef struct _STORAGE_FAILURE_PREDICT_EVENT ;

#line 2513
typedef struct _STORAGE_FAILURE_PREDICT_FUNCTION ;

#line 2528
typedef struct _MSIde_PortDeviceInfo ;

#line 2556
typedef struct _MSSerial_PortName ;

#line 2573
typedef struct _SERIAL_WMI_COMM_DATA ;

#line 2723
typedef struct _SERIAL_WMI_HW_DATA ;

#line 2770
typedef struct _SERIAL_WMI_PERF_DATA ;

#line 2813
typedef struct _SERIAL_WMI_COMMPROP ;

#line 2920
typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS ;

#line 2943
typedef struct _PARALLEL_WMI_LOG_INFO ;

#line 3041
typedef struct _REDBOOK_WMI_STD_DATA ;

#line 3094
typedef struct _REDBOOK_WMI_PERF_DATA ;

#line 3137
typedef struct _RegisteredGuids ;

#line 475 "serial.h"
typedef struct _CONFIG_DATA ;

#line 509
typedef struct _SERIAL_CISR_SW ;

#line 520
typedef struct _SERIAL_FIRMWARE_DATA ;

#line 576
typedef struct _SERIAL_DEVICE_STATE ;

#line 646
typedef struct _SERIAL_DEVICE_EXTENSION ;

#line 1808
typedef struct _SERIAL_MULTIPORT_DISPATCH ;

#line 2157
typedef enum _SERIAL_MEM_COMPARES ;

#line 2164
typedef struct _SERIAL_LIST_DATA ;

#line 2169
typedef struct _SERIAL_GLOBALS ;

#line 2180
typedef struct _SERIAL_USER_DATA ;

#line 2206
typedef struct _SERIAL_PTR_CTX ;

#line 20 "serialp.h"
typedef NTSTATUS ;

#line 26
typedef void ;

#line 835
typedef struct _SERIAL_UPDATE_CHAR ;

#line 846
typedef struct _SERIAL_IOCTL_SYNC ;

#line 27 "pnp.c"
static const LARGE_INTEGER SerialPhysicalZero___1 = {0};

#line 32

#pragma alloc_text(PAGESRP0, SerialCreateDevObj)
#line 33

#pragma alloc_text(PAGESRP0, SerialAddDevice)
#line 34

#pragma alloc_text(PAGESRP0, SerialPnpDispatch)
#line 35

#pragma alloc_text(PAGESRP0, SerialStartDevice)
#line 36

#pragma alloc_text(PAGESRP0, SerialFinishStartDevice)
#line 37

#pragma alloc_text(PAGESRP0, SerialGetPortInfo)
#line 38

#pragma alloc_text(PAGESRP0, SerialDoExternalNaming)
#line 39

#pragma alloc_text(PAGESRP0, SerialReportMaxBaudRate)
#line 40

#pragma alloc_text(PAGESRP0, SerialControllerCallBack)
#line 41

#pragma alloc_text(PAGESRP0, SerialItemCallBack)
#line 42

#pragma alloc_text(PAGESRP0, SerialUndoExternalNaming)
#line 12 "C:/NTDDK/inc/initguid.h"

#pragma once
#line 56 "pnp.c"
extern const GUID __declspec(selectany) GUID_CLASS_COMPORT = {0x86e0d1e0L,
	0x8089, 0x11d0, {0x9c, 0xe4, 0x08, 0x00, 0x3e, 0x30, 0x1f, 0x73}};

#line 84
NTSTATUS SerialSyncCompletion(PDEVICE_OBJECT DeviceObject , PIRP Irp , PKEVENT
	SerialSyncEvent )
{
	#line 88
	KeSetEvent(SerialSyncEvent, 0, 0);
	return (NTSTATUS )0xC0000016L;
}

#line 93
NTSTATUS SerialCreateDevObj(PDRIVER_OBJECT DriverObject , PDEVICE_OBJECT * 
	NewDeviceObject )
{
	#line 117
	UNICODE_STRING deviceObjName ;
	PDEVICE_OBJECT deviceObject = (void *  )0;
	PSERIAL_DEVICE_EXTENSION pDevExt ;
	NTSTATUS status = (NTSTATUS )0x00000000L;
	static ULONG currentInstance = 0;
	UNICODE_STRING instanceStr ;
	WCHAR instanceNumberBuffer[20] ;
	#line 126
	;
	#line 128
	do
	{
		#line 128
		;
	}
	while(0);
	#line 134
	memset(& deviceObjName, 0, sizeof(UNICODE_STRING ));
	#line 136
	deviceObjName.MaximumLength = 128 * sizeof(WCHAR );
	deviceObjName.Buffer = ExAllocatePoolWithTag(PagedPool,
		deviceObjName.MaximumLength + sizeof(WCHAR ), 'XMOC');
	#line 141
	if(deviceObjName.Buffer == (void *  )0)
	{
		#line 142
		SerialLogError(DriverObject, (void *  )0,
			SerialPhysicalZero___1, SerialPhysicalZero___1, 0, 0, 0,
			19, (NTSTATUS )0x00000000L, (NTSTATUS )0xC0060008L, 0,
			(void *  )0, 0, (void *  )0);
		do
		{
			#line 146
			;
		}
		while(0);
		#line 148
		return (NTSTATUS )0xC000009AL;
	}
	#line 153
	memset(deviceObjName.Buffer, 0, deviceObjName.MaximumLength +
		sizeof(WCHAR ));
	#line 156
	RtlAppendUnicodeToString(& deviceObjName,
		"\134\0D\0e\0v\0i\0c\0e\0\134\0S\0e\0r\0i\0a\0l\0");
	RtlInitUnicodeString(& instanceStr, (void *  )0);
	#line 160
	instanceStr.MaximumLength = sizeof(instanceNumberBuffer);
	instanceStr.Buffer = instanceNumberBuffer;
	#line 163
	RtlIntegerToUnicodeString(currentInstance++, 10, & instanceStr);
	#line 165
	RtlAppendUnicodeStringToString(& deviceObjName, & instanceStr);
	#line 172
	status = IoCreateDevice(DriverObject, sizeof(SERIAL_DEVICE_EXTENSION ),
		& deviceObjName, 0x0000001b, 0x00000100, 1, & deviceObject);
	#line 177
	if(! ((NTSTATUS )status >= 0))
	{
		do
		{
			#line 179
			;
		}
		while(0);
		#line 180
		goto SerialCreateDevObjError;
	}
	#line 183
	;
	#line 192
	pDevExt = deviceObject->DeviceExtension;
	memset(pDevExt, 0, sizeof(SERIAL_DEVICE_EXTENSION ));
	#line 199
	pDevExt->PendingIRPCnt = 1;
	#line 206
	pDevExt->DpcCount = 1;
	#line 212
	(pDevExt->DeviceName).Buffer = ExAllocatePoolWithTag(PagedPool,
		deviceObjName.Length + sizeof(WCHAR ), 'XMOC');
	#line 215
	if(! (pDevExt->DeviceName).Buffer)
	{
		SerialLogError(DriverObject, (void *  )0,
			SerialPhysicalZero___1, SerialPhysicalZero___1, 0, 0, 0,
			19, (NTSTATUS )0x00000000L, (NTSTATUS )0xC0060008L, 0,
			(void *  )0, 0, (void *  )0);
		#line 235
		do
		{
			#line 235
			;
		}
		while(0);
		#line 237
		status = (NTSTATUS )0xC000009AL;
		goto SerialCreateDevObjError;
	}
	#line 241
	(pDevExt->DeviceName).MaximumLength = deviceObjName.Length +
		sizeof(WCHAR );
	#line 249
	memset((pDevExt->DeviceName).Buffer, 0,
		(pDevExt->DeviceName).MaximumLength);
	RtlAppendUnicodeStringToString(& pDevExt->DeviceName, & deviceObjName);
	#line 253
	(pDevExt->NtNameForPort).Buffer = ExAllocatePoolWithTag(PagedPool,
		deviceObjName.MaximumLength, 'XMOC');
	#line 256
	if((pDevExt->NtNameForPort).Buffer == (void *  )0)
	{
		do
		{
			#line 258
			;
		}
		while(0);
		#line 259
		status = (NTSTATUS )0xC000009AL;
		goto SerialCreateDevObjError;
	}
	#line 263
	(pDevExt->NtNameForPort).MaximumLength = deviceObjName.MaximumLength;
	RtlAppendUnicodeStringToString(& pDevExt->NtNameForPort, &
		deviceObjName);
	#line 273
	pDevExt->DeviceIsOpened = 0;
	pDevExt->DeviceObject = deviceObject;
	pDevExt->DriverObject = DriverObject;
	pDevExt->DeviceObject = deviceObject;
	pDevExt->PowerState = PowerDeviceD0;
	#line 279
	pDevExt->TxFifoAmount = driverDefaults.TxFIFODefault;
	pDevExt->CreatedSymbolicLink = 1;
	pDevExt->OwnsPowerPolicy = 1;
	#line 283
	(& pDevExt->CommonInterruptObject)->Flink = ((&
		pDevExt->CommonInterruptObject)->Blink = &
		pDevExt->CommonInterruptObject);
	#line 284
	(& pDevExt->TopLevelSharers)->Flink = ((&
		pDevExt->TopLevelSharers)->Blink = & pDevExt->TopLevelSharers);
	#line 285
	(& pDevExt->MultiportSiblings)->Flink = ((&
		pDevExt->MultiportSiblings)->Blink = &
		pDevExt->MultiportSiblings);
	#line 286
	(& pDevExt->AllDevObjs)->Flink = ((& pDevExt->AllDevObjs)->Blink = &
		pDevExt->AllDevObjs);
	#line 287
	(& pDevExt->ReadQueue)->Flink = ((& pDevExt->ReadQueue)->Blink = &
		pDevExt->ReadQueue);
	#line 288
	(& pDevExt->WriteQueue)->Flink = ((& pDevExt->WriteQueue)->Blink = &
		pDevExt->WriteQueue);
	#line 289
	(& pDevExt->MaskQueue)->Flink = ((& pDevExt->MaskQueue)->Blink = &
		pDevExt->MaskQueue);
	#line 290
	(& pDevExt->PurgeQueue)->Flink = ((& pDevExt->PurgeQueue)->Blink = &
		pDevExt->PurgeQueue);
	#line 291
	(& pDevExt->StalledIrpQueue)->Flink = ((&
		pDevExt->StalledIrpQueue)->Blink = & pDevExt->StalledIrpQueue);
	(& pDevExt->OpenMutex)->Count = 1;
	#line 293
	(& pDevExt->OpenMutex)->Contention = 0;
	#line 293
	KeInitializeEvent(& (& pDevExt->OpenMutex)->Event, SynchronizationEvent,
		0);
	#line 293
	;
	(& pDevExt->CloseMutex)->Count = 1;
	#line 294
	(& pDevExt->CloseMutex)->Contention = 0;
	#line 294
	KeInitializeEvent(& (& pDevExt->CloseMutex)->Event,
		SynchronizationEvent, 0);
	#line 294
	;
	#line 296
	KeInitializeEvent(& pDevExt->PendingIRPEvent, SynchronizationEvent, 0);
	KeInitializeEvent(& pDevExt->PendingDpcEvent, SynchronizationEvent, 0);
	KeInitializeEvent(& pDevExt->PowerD0Event, SynchronizationEvent, 0);
	#line 301
	deviceObject->Flags &= ~ 0x00000080;
	#line 303
	* NewDeviceObject = deviceObject;
	#line 305
	ExFreePool(deviceObjName.Buffer);
	#line 307
	do
	{
		#line 307
		;
	}
	while(0);
	#line 308
	return (NTSTATUS )0x00000000L;
	#line 311
	SerialCreateDevObjError:
	{
		do
		{
			#line 313
			;
		}
		while(0);
	}
	#line 319
	if(deviceObjName.Buffer != (void *  )0)
	{
		#line 320
		ExFreePool(deviceObjName.Buffer);
	}
	#line 323
	if(deviceObject)
	{
		if((pDevExt->NtNameForPort).Buffer != (void *  )0)
		{
			#line 326
			ExFreePool((pDevExt->NtNameForPort).Buffer);
		}
		#line 329
		if((pDevExt->DeviceName).Buffer != (void *  )0)
		{
			#line 330
			ExFreePool((pDevExt->DeviceName).Buffer);
		}
		#line 333
		IoDeleteDevice(deviceObject);
	}
	#line 336
	* NewDeviceObject = (void *  )0;
	#line 338
	do
	{
		#line 338
		;
	}
	while(0);
	#line 339
	return status;
}

#line 343
NTSTATUS SerialAddDevice(PDRIVER_OBJECT DriverObject , PDEVICE_OBJECT PPdo )
{
	#line 367
	PDEVICE_OBJECT pNewDevObj = (void *  )0;
	PDEVICE_OBJECT pLowerDevObj = (void *  )0;
	NTSTATUS status ;
	PSERIAL_DEVICE_EXTENSION pDevExt ;
	#line 372
	;
	#line 375
	do
	{
		#line 375
		;
	}
	while(0);
	#line 377
	if(PPdo == (void *  )0)
	{
		#line 383
		do
		{
			#line 383
			;
		}
		while(0);
		#line 385
		return (NTSTATUS )0x8000001AL;
	}
	#line 394
	status = SerialCreateDevObj(DriverObject, & pNewDevObj);
	#line 396
	if(! ((NTSTATUS )status >= 0))
	{
		#line 400
		do
		{
			#line 400
			;
		}
		while(0);
		#line 401
		return status;
	}
	#line 411
	pLowerDevObj = IoAttachDeviceToDeviceStack(pNewDevObj, PPdo);
	#line 417
	;
	#line 420
	pDevExt = pNewDevObj->DeviceExtension;
	pDevExt->LowerDeviceObject = pLowerDevObj;
	pDevExt->Pdo = PPdo;
	#line 434
	pNewDevObj->Flags |= 0x00000004 | 0x00002000;
	#line 436
	do
	{
		#line 436
		;
	}
	while(0);
	#line 438
	return status;
}

#line 442
NTSTATUS SerialPnpDispatch(PDEVICE_OBJECT PDevObj , PIRP PIrp )
{
	#line 466
	PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
	PDEVICE_OBJECT pLowerDevObj = pDevExt->LowerDeviceObject;
	PIO_STACK_LOCATION pIrpStack
		= ((PIrp->Tail).Overlay).CurrentStackLocation;
	#line 469
	NTSTATUS status ;
	PDEVICE_CAPABILITIES pDevCaps ;
	#line 472
	;
	#line 474
	if((status = SerialIRPPrologue(PIrp, pDevExt)) != (NTSTATUS
		)0x00000000L)
	{
		{
			#line 475
			IofCompleteRequest(PIrp, 0);
			#line 475
			SerialIRPEpilogue(pDevExt);
		}
		#line 475
		;
		return status;
	}
	#line 479
	switch(pIrpStack->MinorFunction)
	{
		#line 480
	case 0x09:
			#line 480
			;
		{
			#line 481
			PKEVENT pQueryCapsEvent ;
			SYSTEM_POWER_STATE cap ;
			#line 485
			do
			{
				#line 485
				;
			}
			while(0);
			#line 487
			pQueryCapsEvent = ExAllocatePoolWithTag(NonPagedPool,
				sizeof(KEVENT ), 'XMOC');
			if(pQueryCapsEvent == (void *  )0)
			{
				#line 490
				(PIrp->IoStatus).Status = (NTSTATUS
					)0xC000009AL;
				{
					#line 491
					IofCompleteRequest(PIrp, 0);
					#line 491
					SerialIRPEpilogue(pDevExt);
				}
				#line 491
				;
				return (NTSTATUS )0xC000009AL;
			}
			#line 495
			KeInitializeEvent(pQueryCapsEvent, SynchronizationEvent,
				0);
			{
				#line 497
				PIO_STACK_LOCATION irpSp ;
				#line 497
				PIO_STACK_LOCATION nextIrpSp ;
				#line 497
				irpSp =
					((PIrp->Tail).Overlay).CurrentStackLocation;
				#line 497
				nextIrpSp =
					((PIrp->Tail).Overlay).CurrentStackLocation
					- 1;
				#line 497
				memcpy(nextIrpSp, irpSp, (LONG )((LONG_PTR )(&
					((IO_STACK_LOCATION * 
					)0)->CompletionRoutine)));
				#line 497
				nextIrpSp->Control = 0;
			}
			#line 497
			;
			#line 499
			if(s != NP)
				#line 499
				errorFn();
			else
			{
				#line 501
				if(compRegistered != 0)
					#line 501
					errorFn();
				else
				{
					#line 503
					compRegistered = 1;
					compFptr = SerialSyncCompletion;
				}
			}
			{
				PIO_STACK_LOCATION irpSp ;
				#line 508
				;
				#line 508
				irpSp =
					((PIrp->Tail).Overlay).CurrentStackLocation
					- 1;
				#line 508
				irpSp->CompletionRoutine = SerialSyncCompletion;
				#line 508
				irpSp->Context = pQueryCapsEvent;
				#line 508
				irpSp->Control = 0;
				#line 508
				if(1)
				{
					#line 508
					irpSp->Control = 0x40;
				}
				#line 508
				if(1)
				{
					#line 508
					irpSp->Control |= 0x80;
				}
				#line 508
				if(1)
				{
					#line 508
					irpSp->Control |= 0x20;
				}
			}
			#line 508
			;
			#line 510
			status = IofCallDriver(pLowerDevObj, PIrp);
			#line 517
			if(status == (NTSTATUS )0x00000103L)
			{
				#line 518
				KeWaitForSingleObject(pQueryCapsEvent,
					Executive, KernelMode, 0, (void *  )0);
			}
			#line 522
			ExFreePool(pQueryCapsEvent);
			#line 524
			status = (PIrp->IoStatus).Status;
			#line 526
			if(((pIrpStack->Parameters).DeviceCapabilities).Capabilities
				== (void *  )0)
			{
				#line 527
				goto errQueryCaps;
			}
			#line 534
			do
			{
				#line 534
				;
			}
			while(0);
			#line 536
			pIrpStack = ((PIrp->Tail).Overlay).CurrentStackLocation;
			#line 538
			pDevCaps =
				((pIrpStack->Parameters).DeviceCapabilities).Capabilities;
			for(cap = PowerSystemSleeping1; cap <
				PowerSystemMaximum; cap++)
			{
				#line 545
				do
				{
					#line 545
					;
				}
				while(0);
				#line 547
				(pDevExt->DeviceStateMap)[cap] =
					(pDevCaps->DeviceState)[cap];
			}
			(pDevExt->DeviceStateMap)[PowerSystemUnspecified] =
				PowerDeviceUnspecified;
			#line 553
			(pDevExt->DeviceStateMap)[PowerSystemWorking] =
				PowerDeviceD0;
			#line 556
			pDevExt->SystemWake = pDevCaps->SystemWake;
			pDevExt->DeviceWake = pDevCaps->DeviceWake;
			#line 559
			errQueryCaps:
				#line 559
				;
			{
				IofCompleteRequest(PIrp, 0);
				#line 561
				SerialIRPEpilogue(pDevExt);
			}
			#line 561
			;
			return status;
		}
		#line 565
	case 0x07:
			#line 565
			;
		#line 571
		do
		{
			#line 571
			;
		}
		while(0);
		#line 573
		switch(((pIrpStack->Parameters).QueryDeviceRelations).Type)
		{
			#line 574
		case BusRelations:
				#line 574
				;
			do
			{
				#line 575
				;
			}
			while(0);
			#line 576
			break;
			#line 578
		case EjectionRelations:
				#line 578
				;
			do
			{
				#line 579
				;
			}
			while(0);
			#line 580
			break;
			#line 582
		case PowerRelations:
				#line 582
				;
			do
			{
				#line 583
				;
			}
			while(0);
			#line 584
			break;
			#line 586
		case RemovalRelations:
				#line 586
				;
			do
			{
				#line 587
				;
			}
			while(0);
			#line 588
			break;
			#line 590
		case TargetDeviceRelation:
				#line 590
				;
			do
			{
				#line 591
				;
			}
			while(0);
			#line 592
			break;
			#line 594
		default :
				#line 594
				;
			do
			{
				#line 595
				;
			}
			while(0);
			#line 596
			break;
		}
		#line 599
		if(s == NP)
			#line 599
			s = SKIP1;
		else
			#line 599
			errorFn();
		PIrp->CurrentLocation++;
		#line 600
		((PIrp->Tail).Overlay).CurrentStackLocation++;
		#line 600
		;
		status = SerialIoCallDriver(pDevExt, pLowerDevObj, PIrp);
		return status;
		#line 605
	case 0x08:
			#line 605
			;
		do
		{
			#line 606
			;
		}
		while(0);
		#line 607
		break;
		#line 610
	case 0x0B:
			#line 610
			;
		#line 612
		do
		{
			#line 612
			;
		}
		while(0);
		#line 613
		break;
		#line 616
	case 0x00:
			#line 616
			;
		{
			#line 617
			PVOID startLockPtr ;
			#line 619
			do
			{
				#line 619
				;
			}
			while(0);
			{
				#line 626
				MmLockPagableSectionByHandle(SerialGlobals.PAGESER_Handle
					);
			}
			#line 626
			;
			#line 636
			pDevExt->PowerState = PowerDeviceD0;
			#line 638
			status = SerialStartDevice(PDevObj, PIrp);
			#line 640
			(void )SerialGotoPowerState(PDevObj, pDevExt,
				PowerDeviceD3);
			{
				#line 642
				MmUnlockPagableImageSection(SerialGlobals.PAGESER_Handle
					);
			}
			#line 642
			;
			#line 645
			(PIrp->IoStatus).Status = status;
			{
				IofCompleteRequest(PIrp, 0);
				#line 647
				SerialIRPEpilogue(pDevExt);
			}
			#line 647
			;
			return status;
		}
		#line 652
	case 0x0F:
			#line 652
			;
		do
		{
			#line 653
			;
		}
		while(0);
		#line 654
		break;
		#line 657
	case 0x10:
			#line 657
			;
		do
		{
			#line 658
			;
		}
		while(0);
		#line 659
		break;
		#line 662
	case 0x11:
			#line 662
			;
		do
		{
			#line 663
			;
		}
		while(0);
		#line 664
		break;
		#line 667
	case 0x12:
			#line 667
			;
		do
		{
			#line 668
			;
		}
		while(0);
		#line 669
		break;
		#line 672
	case 0x13:
			#line 672
			;
		{
			#line 673
			UNICODE_STRING pIdBuf ;
			PWCHAR pPnpIdStr ;
			ULONG pnpIdStrLen ;
			ULONG isMulti = 0;
			HANDLE pnpKey ;
			#line 679
			do
			{
				#line 679
				;
			}
			while(0);
			#line 681
			if(((pIrpStack->Parameters).QueryId).IdType !=
				BusQueryHardwareIDs &&
				((pIrpStack->Parameters).QueryId).IdType !=
				BusQueryCompatibleIDs)
			{
				#line 683
				if(s == NP)
					#line 683
					s = SKIP1;
				else
					#line 683
					errorFn();
				PIrp->CurrentLocation++;
				#line 684
				((PIrp->Tail).Overlay).CurrentStackLocation++;
				#line 684
				;
				return SerialIoCallDriver(pDevExt, pLowerDevObj,
					PIrp);
			}
			if(((pIrpStack->Parameters).QueryId).IdType ==
				BusQueryCompatibleIDs)
			{
				#line 689
				(PIrp->IoStatus).Status = (NTSTATUS
					)0x00000000L;
				#line 690
				if(s == NP)
					#line 690
					s = SKIP1;
				else
					#line 690
					errorFn();
				PIrp->CurrentLocation++;
				#line 691
				((PIrp->Tail).Overlay).CurrentStackLocation++;
				#line 691
				;
				return SerialIoCallDriver(pDevExt, pLowerDevObj,
					PIrp);
			}
			status = IoOpenDeviceRegistryKey(pDevExt->Pdo, 1,
				0x00020000L, & pnpKey);
			#line 698
			if(! ((NTSTATUS )status >= 0))
			{
				#line 699
				(PIrp->IoStatus).Status = status;
				{
					IofCompleteRequest(PIrp, 0);
					#line 701
					SerialIRPEpilogue(pDevExt);
				}
				#line 701
				;
				return status;
			}
			#line 706
			status = SerialGetRegistryKeyValue(pnpKey,
				"M\0u\0l\0t\0i\0p\0o\0r\0t\0D\0e\0v\0i\0c\0e\0",
				sizeof("M\0u\0l\0t\0i\0p\0o\0r\0t\0D\0e\0v\0i\0c\0e\0"
				), & isMulti, sizeof(ULONG ));
			#line 711
			ZwClose(pnpKey);
			#line 713
			if(! ((NTSTATUS )status >= 0))
			{
				#line 714
				(PIrp->IoStatus).Status = status;
				{
					#line 715
					IofCompleteRequest(PIrp, 0);
					#line 715
					SerialIRPEpilogue(pDevExt);
				}
				#line 715
				;
				return status;
			}
			#line 719
			pPnpIdStr = isMulti ? "*\0P\0N\0P\00\05\00\02\0"
				: "*\0P\0N\0P\00\05\00\01\0";
			#line 720
			pnpIdStrLen = isMulti
				? sizeof("*\0P\0N\0P\00\05\00\02\0")
				: sizeof("*\0P\0N\0P\00\05\00\01\0");
			if((PIrp->IoStatus).Information != 0)
			{
				#line 724
				ULONG curStrLen ;
				ULONG allocLen = 0;
				PWSTR curStr = (PWSTR
					)(PIrp->IoStatus).Information;
				#line 733
				while((curStrLen = wcslen(curStr)) != 0)
				{
					#line 734
					allocLen += curStrLen * sizeof(WCHAR ) +
						sizeof((WCHAR )0);
					#line 735
					curStr += curStrLen + 1;
				}
				#line 738
				allocLen += sizeof((WCHAR )0);
				#line 740
				pIdBuf.Buffer = ExAllocatePoolWithTag(PagedPool,
					allocLen + pnpIdStrLen + sizeof(WCHAR ),
					'XMOC');
				#line 744
				if(pIdBuf.Buffer == (void *  )0)
				{
					#line 750
					ExFreePool((PWSTR
						)(PIrp->IoStatus).Information);
					#line 753
					(PIrp->IoStatus).Status = (NTSTATUS
						)0xC000009AL;
					#line 754
					(PIrp->IoStatus).Information = 0;
					{
						#line 755
						IofCompleteRequest(PIrp, 0);
						#line 755
						SerialIRPEpilogue(pDevExt);
					}
					#line 755
					;
					return (NTSTATUS )0xC000009AL;
				}
				#line 759
				pIdBuf.MaximumLength = (USHORT )(allocLen +
					pnpIdStrLen);
				#line 760
				pIdBuf.Length = (USHORT )allocLen -
					sizeof((WCHAR )0);
				memset(pIdBuf.Buffer, 0, pIdBuf.MaximumLength +
					sizeof(WCHAR ));
				memcpy(pIdBuf.Buffer, (PWSTR
					)(PIrp->IoStatus).Information,
					allocLen);
				#line 765
				RtlAppendUnicodeToString(& pIdBuf, pPnpIdStr);
				#line 771
				ExFreePool((PWSTR
					)(PIrp->IoStatus).Information);
			}
			else
			{
				do
				{
					#line 776
					;
				}
				while(0);
				#line 778
				pIdBuf.Buffer = ExAllocatePoolWithTag(PagedPool,
					pnpIdStrLen + sizeof(WCHAR ) * 2,
					'XMOC');
				if(pIdBuf.Buffer == (void *  )0)
				{
					#line 782
					(PIrp->IoStatus).Status = (NTSTATUS
						)0xC000009AL;
					#line 783
					(PIrp->IoStatus).Information = 0;
					{
						#line 784
						IofCompleteRequest(PIrp, 0);
						#line 784
						SerialIRPEpilogue(pDevExt);
					}
					#line 784
					;
					return (NTSTATUS )0xC000009AL;
				}
				#line 788
				pIdBuf.MaximumLength = (USHORT )pnpIdStrLen;
				pIdBuf.Length = 0;
				#line 792
				memset(pIdBuf.Buffer, 0, pIdBuf.MaximumLength +
					sizeof(WCHAR ) * 2);
				RtlAppendUnicodeToString(& pIdBuf, pPnpIdStr);
			}
			#line 797
			(PIrp->IoStatus).Information = (ULONG_PTR
				)pIdBuf.Buffer;
			#line 798
			(PIrp->IoStatus).Status = (NTSTATUS )0x00000000L;
			{
				PIO_STACK_LOCATION irpSp ;
				#line 800
				PIO_STACK_LOCATION nextIrpSp ;
				#line 800
				irpSp =
					((PIrp->Tail).Overlay).CurrentStackLocation;
				#line 800
				nextIrpSp =
					((PIrp->Tail).Overlay).CurrentStackLocation
					- 1;
				#line 800
				memcpy(nextIrpSp, irpSp, (LONG )((LONG_PTR )(&
					((IO_STACK_LOCATION * 
					)0)->CompletionRoutine)));
				#line 800
				nextIrpSp->Control = 0;
			}
			#line 800
			;
			return SerialIoCallDriver(pDevExt, pLowerDevObj, PIrp);
		}
		#line 804
	case 0x0D:
			#line 804
			;
		{
			#line 805
			HANDLE pnpKey ;
			PKEVENT pResFiltEvent ;
			ULONG isMulti = 0;
			PIO_RESOURCE_REQUIREMENTS_LIST pReqList ;
			PIO_RESOURCE_LIST pResList ;
			PIO_RESOURCE_DESCRIPTOR pResDesc ;
			ULONG i , j ;
			ULONG reqCnt ;
			ULONG gotISR ;
			ULONG gotInt ;
			ULONG listNum ;
			#line 818
			do
			{
				#line 818
				;
			}
			while(0);
			#line 819
			do
			{
				#line 819
				;
			}
			while(0);
			pResFiltEvent = ExAllocatePoolWithTag(NonPagedPool,
				sizeof(KEVENT ), 'XMOC');
			if(pResFiltEvent == (void *  )0)
			{
				#line 825
				(PIrp->IoStatus).Status = (NTSTATUS
					)0xC000009AL;
				{
					#line 826
					IofCompleteRequest(PIrp, 0);
					#line 826
					SerialIRPEpilogue(pDevExt);
				}
				#line 826
				;
				return (NTSTATUS )0xC000009AL;
			}
			#line 830
			KeInitializeEvent(pResFiltEvent, SynchronizationEvent,
				0);
			{
				#line 832
				PIO_STACK_LOCATION irpSp ;
				#line 832
				PIO_STACK_LOCATION nextIrpSp ;
				#line 832
				irpSp =
					((PIrp->Tail).Overlay).CurrentStackLocation;
				#line 832
				nextIrpSp =
					((PIrp->Tail).Overlay).CurrentStackLocation
					- 1;
				#line 832
				memcpy(nextIrpSp, irpSp, (LONG )((LONG_PTR )(&
					((IO_STACK_LOCATION * 
					)0)->CompletionRoutine)));
				#line 832
				nextIrpSp->Control = 0;
			}
			#line 832
			;
			#line 834
			if(s != NP)
				#line 834
				errorFn();
			else
			{
				#line 836
				if(compRegistered != 0)
					#line 836
					errorFn();
				else
				{
					#line 838
					compRegistered = 1;
					compFptr = SerialSyncCompletion;
				}
			}
			{
				PIO_STACK_LOCATION irpSp ;
				#line 843
				;
				#line 843
				irpSp =
					((PIrp->Tail).Overlay).CurrentStackLocation
					- 1;
				#line 843
				irpSp->CompletionRoutine = SerialSyncCompletion;
				#line 843
				irpSp->Context = pResFiltEvent;
				#line 843
				irpSp->Control = 0;
				#line 843
				if(1)
				{
					#line 843
					irpSp->Control = 0x40;
				}
				#line 843
				if(1)
				{
					#line 843
					irpSp->Control |= 0x80;
				}
				#line 843
				if(1)
				{
					#line 843
					irpSp->Control |= 0x20;
				}
			}
			#line 843
			;
			#line 845
			status = IofCallDriver(pLowerDevObj, PIrp);
			#line 852
			if(status == (NTSTATUS )0x00000103L)
			{
				#line 853
				KeWaitForSingleObject(pResFiltEvent, Executive,
					KernelMode, 0, (void *  )0);
			}
			#line 857
			ExFreePool(pResFiltEvent);
			#line 859
			if((PIrp->IoStatus).Information == 0)
			{
				#line 860
				if(((pIrpStack->Parameters).FilterResourceRequirements
					).IoResourceRequirementList == 0)
				{
					do
					{
						#line 863
						;
					}
					while(0);
					#line 864
					status = (PIrp->IoStatus).Status;
					{
						#line 865
						IofCompleteRequest(PIrp, 0);
						#line 865
						SerialIRPEpilogue(pDevExt);
					}
					#line 865
					;
					return status;
				}
				#line 869
				(PIrp->IoStatus).Information = (ULONG_PTR
					)((pIrpStack->Parameters).FilterResourceRequirements
					).IoResourceRequirementList;
			}
			#line 875
			status = IoOpenDeviceRegistryKey(pDevExt->Pdo, 1,
				0x00020000L, & pnpKey);
			#line 878
			if(! ((NTSTATUS )status >= 0))
			{
				#line 879
				(PIrp->IoStatus).Status = status;
				{
					IofCompleteRequest(PIrp, 0);
					#line 881
					SerialIRPEpilogue(pDevExt);
				}
				#line 881
				;
				return status;
			}
			#line 890
			status = SerialGetRegistryKeyValue(pnpKey,
				"M\0u\0l\0t\0i\0p\0o\0r\0t\0D\0e\0v\0i\0c\0e\0",
				sizeof("M\0u\0l\0t\0i\0p\0o\0r\0t\0D\0e\0v\0i\0c\0e\0"
				), & isMulti, sizeof(ULONG ));
			#line 895
			ZwClose(pnpKey);
			#line 908
			pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST
				)(PIrp->IoStatus).Information;
			#line 909
			pResList = & (pReqList->List)[0];
			#line 913
			do
			{
				#line 913
				;
			}
			while(0);
			#line 915
			for(listNum = 0; listNum < pReqList->AlternativeLists;
				listNum++)
			{
				#line 917
				gotISR = 0;
				gotInt = 0;
				#line 921
				do
				{
					#line 921
					;
				}
				while(0);
				#line 923
				for(j = 0; j < pResList->Count; j++)
				{
					#line 924
					pResDesc = & (pResList->Descriptors)[j];
					#line 926
					switch(pResDesc->Type)
					{
						#line 927
					case 1:
							#line 927
							;
						if(isMulti &&
							((pResDesc->u).Port).Length
							== (ULONG )(1 * 1) && !
							gotISR)
						{
							#line 931
							gotISR = 1;
							pResDesc->ShareDisposition
								=
								CmResourceShareShared;
							#line 934
							do
							{
	#line 934
	;
							}
							while(0);
						}
						#line 936
						break;
						#line 938
					case 2:
							#line 938
							;
						if(! gotInt)
						{
							#line 940
							gotInt = 1;
							if(pResDesc->ShareDisposition
								!=
								CmResourceShareShared)
							{
	#line 942
	pResDesc->ShareDisposition = CmResourceShareShared;
	#line 945
	do
	{
		#line 945
		;
	}
	while(0);
							}
							else
							{
	#line 947
	pDevExt->InterruptShareable = 1;
	#line 950
	do
	{
		#line 950
		;
	}
	while(0);
							}
						}
						#line 953
						break;
						#line 955
					default :
							#line 955
							;
						break;
					}
					#line 963
					if(isMulti && gotInt && gotISR || !
						isMulti && gotInt)
					{
						#line 964
						break;
					}
				}
				#line 968
				pResList = (PIO_RESOURCE_LIST )((PUCHAR
					)pResList + sizeof(IO_RESOURCE_LIST ) +
					sizeof(IO_RESOURCE_DESCRIPTOR ) *
					(pResList->Count - 1));
			}
			#line 976
			(PIrp->IoStatus).Status = (NTSTATUS )0x00000000L;
			{
				#line 977
				IofCompleteRequest(PIrp, 0);
				#line 977
				SerialIRPEpilogue(pDevExt);
			}
			#line 977
			;
			return (NTSTATUS )0x00000000L;
		}
		#line 981
	case 0x14:
			#line 981
			;
		{
			if(pDevExt->Flags & 0x4L)
			{
				#line 984
				(PNP_DEVICE_STATE )(PIrp->IoStatus).Information
					|= 0x00000004;
				(PIrp->IoStatus).Status = (NTSTATUS
					)0x00000000L;
			}
			{
				#line 989
				PIO_STACK_LOCATION irpSp ;
				#line 989
				PIO_STACK_LOCATION nextIrpSp ;
				#line 989
				irpSp =
					((PIrp->Tail).Overlay).CurrentStackLocation;
				#line 989
				nextIrpSp =
					((PIrp->Tail).Overlay).CurrentStackLocation
					- 1;
				#line 989
				memcpy(nextIrpSp, irpSp, (LONG )((LONG_PTR )(&
					((IO_STACK_LOCATION * 
					)0)->CompletionRoutine)));
				#line 989
				nextIrpSp->Control = 0;
			}
			#line 989
			;
			return SerialIoCallDriver(pDevExt, pLowerDevObj, PIrp);
		}
		#line 993
	case 0x04:
			#line 993
			;
		{
			ULONG pendingIRPs ;
			KIRQL oldIrql ;
			#line 998
			do
			{
				#line 998
				;
			}
			while(0);
			#line 999
			do
			{
				#line 999
				;
			}
			while(0);
			#line 1003
			;
			#line 1006
			SerialSetDeviceFlags(pDevExt, & pDevExt->Flags, 0x2L,
				1);
			#line 1007
			SerialSetDeviceFlags(pDevExt, &
				pDevExt->DevicePNPAccept, 0x4L, 1);
			#line 1008
			SerialSetDeviceFlags(pDevExt, &
				pDevExt->DevicePNPAccept, 0x2L, 0);
			pDevExt->PNPState = 0x3L;
			#line 1020
			InterlockedDecrement(& pDevExt->PendingIRPCnt);
			#line 1026
			pendingIRPs = InterlockedDecrement(&
				pDevExt->PendingIRPCnt);
			if(pendingIRPs)
			{
				#line 1029
				KeWaitForSingleObject(&
					pDevExt->PendingIRPEvent, Executive,
					KernelMode, 0, (void *  )0);
			}
			#line 1037
			InterlockedIncrement(& pDevExt->PendingIRPCnt);
			#line 1044
			if(pDevExt->Flags & 0x1L)
			{
				#line 1045
				SerialReleaseResources(pDevExt);
			}
			#line 1052
			(PIrp->IoStatus).Status = (NTSTATUS )0x00000000L;
			if(s == NP)
				#line 1053
				s = SKIP1;
			else
				#line 1053
				errorFn();
			PIrp->CurrentLocation++;
			#line 1054
			((PIrp->Tail).Overlay).CurrentStackLocation++;
			#line 1054
			;
			#line 1056
			return IofCallDriver(pLowerDevObj, PIrp);
		}
		#line 1059
	case 0x05:
			#line 1059
			;
		{
			KIRQL oldIrql ;
			#line 1064
			do
			{
				#line 1064
				;
			}
			while(0);
			#line 1065
			do
			{
				#line 1065
				;
			}
			while(0);
			#line 1072
			if(pDevExt->PortOnAMultiportCard)
			{
				#line 1073
				(PIrp->IoStatus).Status = (NTSTATUS
					)0xC00000BBL;
				#line 1074
				do
				{
					#line 1074
					;
				}
				while(0);
				{
					#line 1075
					IofCompleteRequest(PIrp, 0);
					#line 1075
					SerialIRPEpilogue(pDevExt);
				}
				#line 1075
				;
				return (NTSTATUS )0xC00000BBL;
			}
			#line 1084
			if(pDevExt->PNPState != 0x1L)
			{
				#line 1085
				if(s == NP)
					#line 1085
					s = SKIP1;
				else
					#line 1085
					errorFn();
				PIrp->CurrentLocation++;
				#line 1086
				((PIrp->Tail).Overlay).CurrentStackLocation++;
				#line 1086
				;
				return SerialIoCallDriver(pDevExt, pLowerDevObj,
					PIrp);
			}
			#line 1094
			ExAcquireFastMutex(& pDevExt->OpenMutex);
			#line 1096
			if(pDevExt->DeviceIsOpened)
			{
				#line 1097
				ExReleaseFastMutex(& pDevExt->OpenMutex);
				(PIrp->IoStatus).Status = (NTSTATUS
					)0x80000011L;
				#line 1099
				do
				{
					#line 1099
					;
				}
				while(0);
				{
					#line 1100
					IofCompleteRequest(PIrp, 0);
					#line 1100
					SerialIRPEpilogue(pDevExt);
				}
				#line 1100
				;
				return (NTSTATUS )0x80000011L;
			}
			#line 1104
			pDevExt->PNPState = 0x2L;
			#line 1106
			SerialSetDeviceFlags(pDevExt, &
				pDevExt->DevicePNPAccept, 0x2L, 1);
			#line 1111
			ExReleaseFastMutex(& pDevExt->OpenMutex);
			#line 1113
			(PIrp->IoStatus).Status = (NTSTATUS )0x00000000L;
			{
				#line 1114
				PIO_STACK_LOCATION irpSp ;
				#line 1114
				PIO_STACK_LOCATION nextIrpSp ;
				#line 1114
				irpSp =
					((PIrp->Tail).Overlay).CurrentStackLocation;
				#line 1114
				nextIrpSp =
					((PIrp->Tail).Overlay).CurrentStackLocation
					- 1;
				#line 1114
				memcpy(nextIrpSp, irpSp, (LONG )((LONG_PTR )(&
					((IO_STACK_LOCATION * 
					)0)->CompletionRoutine)));
				#line 1114
				nextIrpSp->Control = 0;
			}
			#line 1114
			;
			return SerialIoCallDriver(pDevExt, pLowerDevObj, PIrp);
		}
		#line 1118
	case 0x06:
			#line 1118
			;
		#line 1120
		do
		{
			#line 1120
			;
		}
		while(0);
		#line 1121
		do
		{
			#line 1121
			;
		}
		while(0);
		#line 1123
		if(pDevExt->PNPState == 0x2L)
		{
			#line 1128
			pDevExt->PNPState = 0x1L;
			SerialSetDeviceFlags(pDevExt, &
				pDevExt->DevicePNPAccept, 0x2L, 0);
		}
		(PIrp->IoStatus).Status = (NTSTATUS )0x00000000L;
		{
			#line 1133
			PIO_STACK_LOCATION irpSp ;
			#line 1133
			PIO_STACK_LOCATION nextIrpSp ;
			#line 1133
			irpSp = ((PIrp->Tail).Overlay).CurrentStackLocation;
			#line 1133
			nextIrpSp = ((PIrp->Tail).Overlay).CurrentStackLocation
				- 1;
			#line 1133
			memcpy(nextIrpSp, irpSp, (LONG )((LONG_PTR )(&
				((IO_STACK_LOCATION * 
				)0)->CompletionRoutine)));
			#line 1133
			nextIrpSp->Control = 0;
		}
		#line 1133
		;
		return SerialIoCallDriver(pDevExt, pLowerDevObj, PIrp);
		#line 1136
	case 0x03:
			#line 1136
			;
		#line 1139
		do
		{
			#line 1139
			;
		}
		while(0);
		#line 1140
		do
		{
			#line 1140
			;
		}
		while(0);
		#line 1146
		pDevExt->PNPState = 0x1L;
		SerialSetDeviceFlags(pDevExt, & pDevExt->DevicePNPAccept, 0x1L,
			0);
		(PIrp->IoStatus).Status = (NTSTATUS )0x00000000L;
		{
			#line 1150
			PIO_STACK_LOCATION irpSp ;
			#line 1150
			PIO_STACK_LOCATION nextIrpSp ;
			#line 1150
			irpSp = ((PIrp->Tail).Overlay).CurrentStackLocation;
			#line 1150
			nextIrpSp = ((PIrp->Tail).Overlay).CurrentStackLocation
				- 1;
			#line 1150
			memcpy(nextIrpSp, irpSp, (LONG )((LONG_PTR )(&
				((IO_STACK_LOCATION * 
				)0)->CompletionRoutine)));
			#line 1150
			nextIrpSp->Control = 0;
		}
		#line 1150
		;
		return SerialIoCallDriver(pDevExt, pLowerDevObj, PIrp);
		#line 1153
	case 0x01:
			#line 1153
			;
		{
			KIRQL oldIrql ;
			#line 1157
			do
			{
				#line 1157
				;
			}
			while(0);
			#line 1158
			do
			{
				#line 1158
				;
			}
			while(0);
			#line 1160
			ExAcquireFastMutex(& pDevExt->OpenMutex);
			#line 1166
			if(pDevExt->DeviceIsOpened)
			{
				#line 1167
				ExReleaseFastMutex(& pDevExt->OpenMutex);
				(PIrp->IoStatus).Status = (NTSTATUS
					)0x80000011L;
				#line 1169
				do
				{
					#line 1169
					;
				}
				while(0);
				{
					#line 1170
					IofCompleteRequest(PIrp, 0);
					#line 1170
					SerialIRPEpilogue(pDevExt);
				}
				#line 1170
				;
				return (NTSTATUS )0x80000011L;
			}
			#line 1174
			pDevExt->PNPState = 0x4L;
			SerialSetDeviceFlags(pDevExt, &
				pDevExt->DevicePNPAccept, 0x1L, 1);
			#line 1176
			ExReleaseFastMutex(& pDevExt->OpenMutex);
			#line 1178
			(PIrp->IoStatus).Status = (NTSTATUS )0x00000000L;
			{
				#line 1179
				PIO_STACK_LOCATION irpSp ;
				#line 1179
				PIO_STACK_LOCATION nextIrpSp ;
				#line 1179
				irpSp =
					((PIrp->Tail).Overlay).CurrentStackLocation;
				#line 1179
				nextIrpSp =
					((PIrp->Tail).Overlay).CurrentStackLocation
					- 1;
				#line 1179
				memcpy(nextIrpSp, irpSp, (LONG )((LONG_PTR )(&
					((IO_STACK_LOCATION * 
					)0)->CompletionRoutine)));
				#line 1179
				nextIrpSp->Control = 0;
			}
			#line 1179
			;
			return SerialIoCallDriver(pDevExt, pLowerDevObj, PIrp);
		}
		#line 1183
	case 0x17:
			#line 1183
			;
		{
			ULONG pendingIRPs ;
			KIRQL oldIrql ;
			#line 1188
			do
			{
				#line 1188
				;
			}
			while(0);
			#line 1189
			do
			{
				#line 1189
				;
			}
			while(0);
			#line 1195
			SerialSetDeviceFlags(pDevExt, &
				pDevExt->DevicePNPAccept, 0x8L, 1);
			#line 1201
			SerialKillPendingIrps(PDevObj);
			#line 1211
			InterlockedDecrement(& pDevExt->PendingIRPCnt);
			#line 1217
			pendingIRPs = InterlockedDecrement(&
				pDevExt->PendingIRPCnt);
			if(pendingIRPs)
			{
				#line 1220
				KeWaitForSingleObject(&
					pDevExt->PendingIRPEvent, Executive,
					KernelMode, 0, (void *  )0);
			}
			#line 1228
			InterlockedIncrement(& pDevExt->PendingIRPCnt);
			#line 1234
			SerialDisableInterfacesResources(PDevObj, 0);
			#line 1236
			(PIrp->IoStatus).Status = (NTSTATUS )0x00000000L;
			if(s == NP)
				#line 1237
				s = SKIP1;
			else
				#line 1237
				errorFn();
			PIrp->CurrentLocation++;
			#line 1238
			((PIrp->Tail).Overlay).CurrentStackLocation++;
			#line 1238
			;
			#line 1240
			return SerialIoCallDriver(pDevExt, pLowerDevObj, PIrp);
		}
		#line 1243
	case 0x02:
			#line 1243
			;
		{
			#line 1246
			ULONG pendingIRPs ;
			KIRQL oldIrql ;
			#line 1249
			do
			{
				#line 1249
				;
			}
			while(0);
			#line 1250
			do
			{
				#line 1250
				;
			}
			while(0);
			#line 1260
			SerialSetDeviceFlags(pDevExt, &
				pDevExt->DevicePNPAccept, 0x1L, 1);
			#line 1266
			SerialKillPendingIrps(PDevObj);
			#line 1272
			InterlockedDecrement(& pDevExt->PendingIRPCnt);
			#line 1279
			pendingIRPs = InterlockedDecrement(&
				pDevExt->PendingIRPCnt);
			if(pendingIRPs)
			{
				#line 1282
				KeWaitForSingleObject(&
					pDevExt->PendingIRPEvent, Executive,
					KernelMode, 0, (void *  )0);
			}
			#line 1290
			SerialRemoveDevObj(PDevObj);
			#line 1297
			(PIrp->IoStatus).Status = (NTSTATUS )0x00000000L;
			{
				PIO_STACK_LOCATION irpSp ;
				#line 1299
				PIO_STACK_LOCATION nextIrpSp ;
				#line 1299
				irpSp =
					((PIrp->Tail).Overlay).CurrentStackLocation;
				#line 1299
				nextIrpSp =
					((PIrp->Tail).Overlay).CurrentStackLocation
					- 1;
				#line 1299
				memcpy(nextIrpSp, irpSp, (LONG )((LONG_PTR )(&
					((IO_STACK_LOCATION * 
					)0)->CompletionRoutine)));
				#line 1299
				nextIrpSp->Control = 0;
			}
			#line 1299
			;
			#line 1305
			IofCallDriver(pLowerDevObj, PIrp);
			#line 1308
			return (NTSTATUS )0x00000000L;
		}
		#line 1311
	default :
			#line 1311
			;
		break;
	}
	#line 1322
	if(s == NP)
		#line 1322
		s = SKIP1;
	else
		#line 1322
		errorFn();
	PIrp->CurrentLocation++;
	#line 1323
	((PIrp->Tail).Overlay).CurrentStackLocation++;
	#line 1323
	;
	status = SerialIoCallDriver(pDevExt, pLowerDevObj, PIrp);
	return status;
}

#line 1330
UINT32 SerialReportMaxBaudRate(ULONG Bauds )
{
	#line 1349
	;
	#line 1351
	if(Bauds & (ULONG )0x00010000)
	{
		#line 1352
		return 128U * 1024U;
	}
	#line 1355
	if(Bauds & (ULONG )0x00020000)
	{
		#line 1356
		return 115200U;
	}
	#line 1359
	if(Bauds & (ULONG )0x00008000)
	{
		#line 1360
		return 56U * 1024U;
	}
	#line 1363
	if(Bauds & (ULONG )0x00040000)
	{
		#line 1364
		return 57600U;
	}
	#line 1367
	if(Bauds & (ULONG )0x00004000)
	{
		#line 1368
		return 38400U;
	}
	#line 1371
	if(Bauds & (ULONG )0x00002000)
	{
		#line 1372
		return 19200U;
	}
	#line 1375
	if(Bauds & (ULONG )0x00001000)
	{
		#line 1376
		return 14400U;
	}
	#line 1379
	if(Bauds & (ULONG )0x00000800)
	{
		#line 1380
		return 9600U;
	}
	#line 1383
	if(Bauds & (ULONG )0x00000400)
	{
		#line 1384
		return 7200U;
	}
	#line 1387
	if(Bauds & (ULONG )0x00000200)
	{
		#line 1388
		return 4800U;
	}
	#line 1391
	if(Bauds & (ULONG )0x00000100)
	{
		#line 1392
		return 2400U;
	}
	#line 1395
	if(Bauds & (ULONG )0x00000080)
	{
		#line 1396
		return 1800U;
	}
	#line 1399
	if(Bauds & (ULONG )0x00000040)
	{
		#line 1400
		return 1200U;
	}
	#line 1403
	if(Bauds & (ULONG )0x00000020)
	{
		#line 1404
		return 600U;
	}
	#line 1407
	if(Bauds & (ULONG )0x00000010)
	{
		#line 1408
		return 300U;
	}
	#line 1411
	if(Bauds & (ULONG )0x00000008)
	{
		#line 1412
		return 150U;
	}
	#line 1415
	if(Bauds & (ULONG )0x00000004)
	{
		#line 1416
		return 135U;
	}
	#line 1419
	if(Bauds & (ULONG )0x00000002)
	{
		#line 1420
		return 110U;
	}
	#line 1423
	if(Bauds & (ULONG )0x00000001)
	{
		#line 1424
		return 75U;
	}
	#line 1431
	return 0;
}

#line 1436
NTSTATUS SerialFinishStartDevice(PDEVICE_OBJECT PDevObj , PCM_RESOURCE_LIST
	PResList , PCM_RESOURCE_LIST PTrResList , PSERIAL_USER_DATA PUserData )
{
	#line 1469
	PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
	NTSTATUS status ;
	PCONFIG_DATA pConfig ;
	HANDLE pnpKey ;
	ULONG one = 1;
	BOOLEAN allocedUserData = 0;
	#line 1476
	;
	#line 1482
	if(pDevExt->Flags & 0x2L && pDevExt->Flags & 0x1L)
	{
		SerialSetDeviceFlags(pDevExt, & pDevExt->Flags, 0x2L, 0);
		#line 1486
		pDevExt->PNPState = 0x6L;
		#line 1492
		pDevExt->TopLevelOurIsr = (void *  )0;
		pDevExt->TopLevelOurIsrContext = (void *  )0;
		#line 1495
		pDevExt->OriginalController = SerialPhysicalZero___1;
		pDevExt->OriginalInterruptStatus = SerialPhysicalZero___1;
		#line 1498
		pDevExt->OurIsr = (void *  )0;
		pDevExt->OurIsrContext = (void *  )0;
		#line 1501
		pDevExt->Controller = (void *  )0;
		pDevExt->InterruptStatus = (void *  )0;
		pDevExt->Interrupt = (void *  )0;
		#line 1505
		pDevExt->SpanOfController = 0;
		pDevExt->SpanOfInterruptStatus = 0;
		#line 1508
		pDevExt->Vector = 0;
		pDevExt->Irql = 0;
		pDevExt->OriginalVector = 0;
		pDevExt->OriginalIrql = 0;
		pDevExt->AddressSpace = 0;
		pDevExt->BusNumber = 0;
		pDevExt->InterfaceType = 0;
		#line 1516
		pDevExt->CIsrSw = (void *  )0;
		#line 1518
		;
		#line 1521
		PUserData = ExAllocatePoolWithTag(PagedPool,
			sizeof(SERIAL_USER_DATA ), 'XMOC');
		if(PUserData == (void *  )0)
		{
			#line 1524
			return (NTSTATUS )0xC000009AL;
		}
		#line 1527
		allocedUserData = 1;
		#line 1529
		memset(PUserData, 0, sizeof(SERIAL_USER_DATA ));
		#line 1531
		PUserData->DisablePort = 0;
		PUserData->UserClockRate = pDevExt->ClockRate;
		PUserData->TxFIFO = pDevExt->TxFifoAmount;
		PUserData->PermitShareDefault = pDevExt->PermitShare;
		#line 1541
		switch(pDevExt->RxFifoTrigger)
		{
			#line 1542
		case (UCHAR )0x00:
				#line 1542
				;
			PUserData->RxFIFO = 1;
			break;
			#line 1546
		case (UCHAR )0x40:
				#line 1546
				;
			PUserData->RxFIFO = 4;
			break;
			#line 1550
		case (UCHAR )0x80:
				#line 1550
				;
			PUserData->RxFIFO = 8;
			break;
			#line 1554
		case (UCHAR )0xc0:
				#line 1554
				;
			PUserData->RxFIFO = 14;
			break;
			#line 1558
		default :
				#line 1558
				;
			PUserData->RxFIFO = 1;
		}
	}
	else
	{
		#line 1567
		status = IoOpenDeviceRegistryKey(pDevExt->Pdo, 1, 0x00020000L, &
			pnpKey);
		#line 1571
		if((NTSTATUS )status >= 0)
		{
			#line 1572
			ULONG powerPolicy = 0;
			#line 1578
			SerialGetRegistryKeyValue(pnpKey,
				"S\0e\0r\0i\0a\0l\0R\0e\0l\0i\0n\0q\0u\0i\0s\0h\0P\0o\0w\0e\0r\0P\0o\0l\0i\0c\0y\0",
				sizeof("S\0e\0r\0i\0a\0l\0R\0e\0l\0i\0n\0q\0u\0i\0s\0h\0P\0o\0w\0e\0r\0P\0o\0l\0i\0c\0y\0"
				), & powerPolicy, sizeof(ULONG ));
			pDevExt->OwnsPowerPolicy = powerPolicy ? 0 : 1;
			#line 1585
			ZwClose(pnpKey);
		}
	}
	#line 1593
	pConfig = ExAllocatePoolWithTag(PagedPool, sizeof(CONFIG_DATA ),
		'XMOC');
	if(pConfig == (void *  )0)
	{
		SerialLogError(pDevExt->DriverObject, (void *  )0,
			SerialPhysicalZero___1, SerialPhysicalZero___1, 0, 0, 0,
			37, (NTSTATUS )0x00000000L, (NTSTATUS )0xC0060008L, 0,
			(void *  )0, 0, (void *  )0);
		#line 1602
		do
		{
			#line 1602
			;
		}
		while(0);
		#line 1604
		status = (NTSTATUS )0xC000009AL;
		goto SerialFinishStartDeviceError;
	}
	#line 1608
	memset(pConfig, 0, sizeof(CONFIG_DATA ));
	#line 1615
	status = SerialGetPortInfo(PDevObj, PResList, PTrResList, pConfig,
		PUserData);
	#line 1618
	if(! ((NTSTATUS )status >= 0))
	{
		#line 1619
		goto SerialFinishStartDeviceError;
	}
	#line 1629
	if(pDevExt->PowerState != PowerDeviceD0)
	{
		status = SerialGotoPowerState(pDevExt->Pdo, pDevExt,
			PowerDeviceD0);
		if(! ((NTSTATUS )status >= 0))
		{
			#line 1634
			goto SerialFinishStartDeviceError;
		}
	}
	#line 1642
	status = SerialFindInitController(PDevObj, pConfig);
	#line 1644
	if(! ((NTSTATUS )status >= 0))
	{
		#line 1645
		goto SerialFinishStartDeviceError;
	}
	#line 1660
	if(pDevExt != (void *  )0)
	{
		#line 1663
		do
		{
			#line 1663
			;
		}
		while(0);
	}
	else
	{
		#line 1666
		do
		{
			#line 1666
			;
		}
		while(0);
	}
	#line 1669
	if(! pDevExt->Interrupt && pDevExt->OurIsr)
	{
		#line 1676
		do
		{
			#line 1676
			;
		}
		while(0);
		#line 1697
		do
		{
			#line 1697
			;
		}
		while(0);
		#line 1703
		(pDevExt->CIsrSw)->IsrFunc = pDevExt->OurIsr;
		(pDevExt->CIsrSw)->Context = pDevExt->OurIsrContext;
		#line 1706
		status = IoConnectInterrupt(& pDevExt->Interrupt, SerialCIsrSw,
			pDevExt->CIsrSw, (void *  )0, pDevExt->Vector,
			pDevExt->Irql, pDevExt->Irql, pConfig->InterruptMode,
			pDevExt->InterruptShareable, pConfig->Affinity, 0);
		#line 1714
		if(! ((NTSTATUS )status >= 0))
		{
			#line 1725
			do
			{
				#line 1725
				;
			}
			while(0);
			#line 1746
			do
			{
				#line 1746
				;
			}
			while(0);
			#line 1750
			SerialLogError(PDevObj->DriverObject, PDevObj,
				pDevExt->OriginalController,
				SerialPhysicalZero___1, 0, 0, 0, 1, status,
				(NTSTATUS )0xC0060007L,
				(pDevExt->DeviceName).Length + sizeof(WCHAR ),
				(pDevExt->DeviceName).Buffer, 0, (void *  )0);
			#line 1757
			status = (NTSTATUS )0xC0060007L;
			goto SerialFinishStartDeviceError;
		}
	}
	#line 1763
	do
	{
		#line 1763
		;
	}
	while(0);
	{
		#line 1770
		PLIST_ENTRY _EX_Blink ;
		#line 1770
		PLIST_ENTRY _EX_ListHead ;
		#line 1770
		_EX_ListHead = & SerialGlobals.AllDevObjs;
		#line 1770
		_EX_Blink = _EX_ListHead->Blink;
		#line 1770
		(& pDevExt->AllDevObjs)->Flink = _EX_ListHead;
		#line 1770
		(& pDevExt->AllDevObjs)->Blink = _EX_Blink;
		#line 1770
		_EX_Blink->Flink = & pDevExt->AllDevObjs;
		#line 1770
		_EX_ListHead->Blink = & pDevExt->AllDevObjs;
	}
	#line 1770
	;
	#line 1782
	do
	{
		#line 1782
		do
		{
			#line 1782
			WRITE_PORT_UCHAR(pDevExt->Controller + (ULONG )(0x01 *
				1), 0);
		}
		while(0);
	}
	while(0);
	#line 1785
	if(pDevExt->Jensen)
	{
		#line 1790
		do
		{
			#line 1790
			WRITE_PORT_UCHAR(pDevExt->Controller + (ULONG )(0x04 *
				1), (UCHAR )0x08);
		}
		while(0);
	}
	else
	{
		do
		{
			#line 1797
			WRITE_PORT_UCHAR(pDevExt->Controller + (ULONG )(0x04 *
				1), (UCHAR )0);
		}
		while(0);
	}
	#line 1808
	KeSynchronizeExecution(pDevExt->Interrupt, SerialReset, pDevExt);
	#line 1814
	KeSynchronizeExecution(pDevExt->Interrupt, SerialMarkClose, pDevExt);
	#line 1820
	KeSynchronizeExecution(pDevExt->Interrupt, SerialClrRTS, pDevExt);
	#line 1826
	KeSynchronizeExecution(pDevExt->Interrupt, SerialClrDTR, pDevExt);
	#line 1832
	if(pDevExt->PNPState == 0x0L)
	{
		#line 1837
		status = SerialDoExternalNaming(pDevExt,
			(pDevExt->DeviceObject)->DriverObject);
		#line 1841
		if(! ((NTSTATUS )status >= 0))
		{
			do
			{
				#line 1843
				;
			}
			while(0);
			#line 1849
			status = (NTSTATUS )0x00000000L;
		}
	}
	else
	{
		#line 1853
		do
		{
			#line 1853
			;
		}
		while(0);
	}
	#line 1856
	SerialFinishStartDeviceError:
		#line 1856
		;
	#line 1858
	if(! ((NTSTATUS )status >= 0))
	{
		do
		{
			#line 1860
			;
		}
		while(0);
		#line 1866
		if(pDevExt->PNPState == 0x6L)
		{
			#line 1872
			SerialKillPendingIrps(PDevObj);
			#line 1879
			SerialSetDeviceFlags(pDevExt, &
				pDevExt->DevicePNPAccept, 0x1L, 1);
			#line 1880
			SerialSetDeviceFlags(pDevExt, & pDevExt->Flags, 0x1L,
				0);
		}
	}
	else
	{
		#line 1888
		(pDevExt->WmiHwData).IrqNumber = pDevExt->Irql;
		(pDevExt->WmiHwData).IrqLevel = pDevExt->Irql;
		(pDevExt->WmiHwData).IrqVector = pDevExt->Vector;
		(pDevExt->WmiHwData).IrqAffinityMask = pConfig->Affinity;
		(pDevExt->WmiHwData).InterruptType = pConfig->InterruptMode ==
			Latched ? 0 : 1;
		(pDevExt->WmiHwData).BaseIOAddress = (ULONG_PTR
			)pDevExt->Controller;
		#line 1900
		(pDevExt->WmiCommData).BaudRate = pDevExt->CurrentBaud;
		(pDevExt->WmiCommData).BitsPerByte = (pDevExt->LineControl &
			0x03) + 5;
		#line 1902
		(pDevExt->WmiCommData).ParityCheckEnable = pDevExt->LineControl
			& 0x08 ? 1 : 0;
		#line 1905
		switch(pDevExt->LineControl & (UCHAR )0x38)
		{
			#line 1906
		case (UCHAR )0x00:
				#line 1906
				;
			(pDevExt->WmiCommData).Parity = 0;
			break;
			#line 1910
		case (UCHAR )0x08:
				#line 1910
				;
			(pDevExt->WmiCommData).Parity = 1;
			break;
			#line 1914
		case (UCHAR )0x18:
				#line 1914
				;
			(pDevExt->WmiCommData).Parity = 2;
			break;
			#line 1918
		case (UCHAR )0x28:
				#line 1918
				;
			(pDevExt->WmiCommData).Parity = 4;
			break;
			#line 1922
		case (UCHAR )0x38:
				#line 1922
				;
			(pDevExt->WmiCommData).Parity = 3;
			break;
			#line 1926
		default :
				#line 1926
				;
			;
			(pDevExt->WmiCommData).Parity = 0;
			break;
		}
		#line 1932
		(pDevExt->WmiCommData).StopBits = pDevExt->LineControl & (UCHAR
			)0x04 ? (pDevExt->WmiCommData).BitsPerByte == 5 ? 1 : 2
			: 0;
		(pDevExt->WmiCommData).XoffCharacter =
			(pDevExt->SpecialChars).XoffChar;
		#line 1936
		(pDevExt->WmiCommData).XoffXmitThreshold =
			(pDevExt->HandFlow).XoffLimit;
		#line 1937
		(pDevExt->WmiCommData).XonCharacter =
			(pDevExt->SpecialChars).XonChar;
		#line 1938
		(pDevExt->WmiCommData).XonXmitThreshold =
			(pDevExt->HandFlow).XonLimit;
		#line 1939
		(pDevExt->WmiCommData).MaximumBaudRate =
			SerialReportMaxBaudRate(pDevExt->SupportedBauds);
		(pDevExt->WmiCommData).MaximumOutputBufferSize = (UINT32
			)((ULONG )(- 1));
		#line 1942
		(pDevExt->WmiCommData).MaximumInputBufferSize = (UINT32 )((ULONG
			)(- 1));
		#line 1943
		(pDevExt->WmiCommData).Support16BitMode = 0;
		(pDevExt->WmiCommData).SupportDTRDSR = 1;
		(pDevExt->WmiCommData).SupportIntervalTimeouts = 1;
		(pDevExt->WmiCommData).SupportParityCheck = 1;
		(pDevExt->WmiCommData).SupportRTSCTS = 1;
		(pDevExt->WmiCommData).SupportXonXoff = 1;
		(pDevExt->WmiCommData).SettableBaudRate = 1;
		(pDevExt->WmiCommData).SettableDataBits = 1;
		(pDevExt->WmiCommData).SettableFlowControl = 1;
		(pDevExt->WmiCommData).SettableParity = 1;
		(pDevExt->WmiCommData).SettableParityCheck = 1;
		(pDevExt->WmiCommData).SettableStopBits = 1;
		(pDevExt->WmiCommData).IsBusy = 0;
		#line 1961
		memset(& pDevExt->WmiPerfData, 0, sizeof(pDevExt->WmiPerfData));
		#line 1964
		if(pDevExt->PNPState == 0x0L)
		{
			#line 1965
			PULONG countSoFar = &
				(IoGetConfigurationInformation())->SerialCount;
			#line 1966
			(* countSoFar)++;
			#line 1972
			(pDevExt->WmiLibInfo).GuidCount =
				sizeof(SerialWmiGuidList) /
				sizeof(WMIGUIDREGINFO );
			#line 1974
			(pDevExt->WmiLibInfo).GuidList = SerialWmiGuidList;
			;
			#line 1977
			(pDevExt->WmiLibInfo).QueryWmiRegInfo =
				SerialQueryWmiRegInfo;
			#line 1978
			(pDevExt->WmiLibInfo).QueryWmiDataBlock =
				SerialQueryWmiDataBlock;
			#line 1979
			(pDevExt->WmiLibInfo).SetWmiDataBlock =
				SerialSetWmiDataBlock;
			#line 1980
			(pDevExt->WmiLibInfo).SetWmiDataItem =
				SerialSetWmiDataItem;
			#line 1981
			(pDevExt->WmiLibInfo).ExecuteWmiMethod = (void *  )0;
			(pDevExt->WmiLibInfo).WmiFunctionControl = (void *  )0;
			#line 1984
			IoWMIRegistrationControl(PDevObj, 1);
		}
		#line 1988
		if(pDevExt->PNPState == 0x6L)
		{
			#line 1993
			SerialUnstallIrps(pDevExt);
		}
		#line 1996
		pDevExt->PNPState = 0x1L;
		SerialSetDeviceFlags(pDevExt, & pDevExt->DevicePNPAccept, ~
			0x0L, 0);
		#line 1998
		SerialSetDeviceFlags(pDevExt, & pDevExt->Flags, 0x1L, 1);
	}
	#line 2002
	if(pConfig)
	{
		#line 2003
		ExFreePool(pConfig);
	}
	#line 2006
	if(PUserData != (void *  )0 && allocedUserData)
	{
		#line 2007
		ExFreePool(PUserData);
	}
	#line 2010
	do
	{
		#line 2010
		;
	}
	while(0);
	#line 2012
	return status;
}

#line 2017
NTSTATUS SerialStartDevice(PDEVICE_OBJECT PDevObj , PIRP PIrp )
{
	#line 2043
	PIO_STACK_LOCATION pIrpStack
		= ((PIrp->Tail).Overlay).CurrentStackLocation;
	#line 2044
	NTSTATUS status = (NTSTATUS )0xC0000002L;
	PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
	PDEVICE_OBJECT pLowerDevObj = pDevExt->LowerDeviceObject;
	#line 2048
	;
	#line 2050
	do
	{
		#line 2050
		;
	}
	while(0);
	#line 2057
	KeInitializeEvent(& pDevExt->SerialStartEvent, SynchronizationEvent, 0);
	{
		#line 2060
		PIO_STACK_LOCATION irpSp ;
		#line 2060
		PIO_STACK_LOCATION nextIrpSp ;
		#line 2060
		irpSp = ((PIrp->Tail).Overlay).CurrentStackLocation;
		#line 2060
		nextIrpSp = ((PIrp->Tail).Overlay).CurrentStackLocation - 1;
		#line 2060
		memcpy(nextIrpSp, irpSp, (LONG )((LONG_PTR )(&
			((IO_STACK_LOCATION *  )0)->CompletionRoutine)));
		#line 2060
		nextIrpSp->Control = 0;
	}
	#line 2060
	;
	if(s != NP)
		#line 2061
		errorFn();
	else
	{
		#line 2063
		if(compRegistered != 0)
			#line 2063
			errorFn();
		else
		{
			#line 2065
			compRegistered = 1;
			compFptr = SerialSyncCompletion;
		}
	}
	{
		PIO_STACK_LOCATION irpSp ;
		#line 2070
		;
		#line 2070
		irpSp = ((PIrp->Tail).Overlay).CurrentStackLocation - 1;
		#line 2070
		irpSp->CompletionRoutine = SerialSyncCompletion;
		#line 2070
		irpSp->Context = & pDevExt->SerialStartEvent;
		#line 2070
		irpSp->Control = 0;
		#line 2070
		if(1)
		{
			#line 2070
			irpSp->Control = 0x40;
		}
		#line 2070
		if(1)
		{
			#line 2070
			irpSp->Control |= 0x80;
		}
		#line 2070
		if(1)
		{
			#line 2070
			irpSp->Control |= 0x20;
		}
	}
	#line 2070
	;
	#line 2072
	status = IofCallDriver(pLowerDevObj, PIrp);
	#line 2079
	if(status == (NTSTATUS )0x00000103L)
	{
		#line 2080
		KeWaitForSingleObject(& pDevExt->SerialStartEvent, Executive,
			KernelMode, 0, (void *  )0);
		#line 2083
		status = (PIrp->IoStatus).Status;
	}
	#line 2086
	if(! ((NTSTATUS )status >= 0))
	{
		#line 2087
		do
		{
			#line 2087
			;
		}
		while(0);
		#line 2088
		return status;
	}
	#line 2096
	status = SerialFinishStartDevice(PDevObj,
		((pIrpStack->Parameters).StartDevice).AllocatedResources,
		((pIrpStack->Parameters).StartDevice).AllocatedResourcesTranslated
		, (void *  )0);
	return status;
}

#line 2105
NTSTATUS SerialItemCallBack(PVOID Context , PUNICODE_STRING PathName ,
	INTERFACE_TYPE BusType , ULONG BusNumber , PKEY_VALUE_FULL_INFORMATION
	*  BusInformation , CONFIGURATION_TYPE ControllerType , ULONG
	ControllerNumber , PKEY_VALUE_FULL_INFORMATION *  ControllerInformation
	, CONFIGURATION_TYPE PeripheralType , ULONG PeripheralNumber ,
	PKEY_VALUE_FULL_INFORMATION *  PeripheralInformation )
{
	#line 2160
	;
	#line 2162
	* (BOOLEAN *  )Context = 1;
	return (NTSTATUS )0x00000000L;
}

#line 2167
NTSTATUS SerialControllerCallBack(PVOID Context , PUNICODE_STRING PathName ,
	INTERFACE_TYPE BusType , ULONG BusNumber , PKEY_VALUE_FULL_INFORMATION
	*  BusInformation , CONFIGURATION_TYPE ControllerType , ULONG
	ControllerNumber , PKEY_VALUE_FULL_INFORMATION *  ControllerInformation
	, CONFIGURATION_TYPE PeripheralType , ULONG PeripheralNumber ,
	PKEY_VALUE_FULL_INFORMATION *  PeripheralInformation )
{
	#line 2222
	PCM_FULL_RESOURCE_DESCRIPTOR controllerData ;
	PSERIAL_PTR_CTX pContext = (PSERIAL_PTR_CTX )Context;
	ULONG i ;
	#line 2226
	;
	#line 2228
	if((ControllerInformation[IoQueryDeviceConfigurationData])->DataLength
		== 0)
	{
		#line 2229
		pContext->isPointer = 0;
		return (NTSTATUS )0x00000000L;
	}
	#line 2233
	controllerData = (PCM_FULL_RESOURCE_DESCRIPTOR )((PUCHAR
		)ControllerInformation[IoQueryDeviceConfigurationData] +
		(ControllerInformation[IoQueryDeviceConfigurationData])->DataOffset
		);
	#line 2241
	for(i = 0; i < (controllerData->PartialResourceList).Count; i++)
	{
		PCM_PARTIAL_RESOURCE_DESCRIPTOR partial = &
			((controllerData->PartialResourceList).PartialDescriptors
			)[i];
		switch(partial->Type)
		{
			#line 2247
		case 1:
				#line 2247
				;
			if((((partial->u).Port).Start).QuadPart ==
				(pContext->Port).QuadPart)
			{
				#line 2252
				pContext->isPointer = 1;
				return (NTSTATUS )0x00000000L;
			}
			#line 2256
		case 2:
				#line 2256
				;
			if(((partial->u).Interrupt).Vector == pContext->Vector)
			{
				#line 2261
				pContext->isPointer = 2;
				return (NTSTATUS )0x00000000L;
			}
			#line 2265
		default :
				#line 2265
				;
			break;
		}
	}
	#line 2270
	pContext->isPointer = 0;
	return (NTSTATUS )0x00000000L;
}

#line 2276
NTSTATUS SerialGetPortInfo(PDEVICE_OBJECT PDevObj , PCM_RESOURCE_LIST PResList ,
	PCM_RESOURCE_LIST PTrResList , PCONFIG_DATA PConfig , PSERIAL_USER_DATA
	PUserData )
{
	#line 2313
	PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
	PDEVICE_OBJECT pLowerDevObj = pDevExt->LowerDeviceObject;
	NTSTATUS status = (NTSTATUS )0xC0000002L;
	CONFIGURATION_TYPE pointer = PointerPeripheral;
	CONFIGURATION_TYPE controllerType = SerialController;
	#line 2319
	HANDLE keyHandle ;
	ULONG count ;
	ULONG i ;
	INTERFACE_TYPE interfaceType ;
	#line 2324
	PCM_PARTIAL_RESOURCE_LIST pPartialResourceList , pPartialTrResourceList
		;
	#line 2325
	PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartialResourceDesc ,
		pPartialTrResourceDesc ;
	PCM_FULL_RESOURCE_DESCRIPTOR pFullResourceDesc = (void *  )0,
		pFullTrResourceDesc = (void *  )0;
	#line 2330
	ULONG defaultInterruptMode ;
	ULONG defaultAddressSpace ;
	ULONG defaultInterfaceType ;
	ULONG defaultClockRate ;
	ULONG zero = 0;
	SERIAL_PTR_CTX foundPointerCtx ;
	ULONG isMulti = 0;
	ULONG gotInt = 0;
	ULONG gotISR = 0;
	ULONG gotIO = 0;
	ULONG ioResIndex = 0;
	ULONG curIoIndex = 0;
	#line 2343
	;
	#line 2345
	do
	{
		#line 2345
		;
	}
	while(0);
	#line 2347
	do
	{
		#line 2347
		;
	}
	while(0);
	#line 2348
	do
	{
		#line 2348
		;
	}
	while(0);
	if(PResList == (void *  )0 || PTrResList == (void *  )0)
	{
		#line 2356
		;
		;
		#line 2362
		return (NTSTATUS )0xC000009AL;
	}
	#line 2369
	;
	;
	#line 2379
	status = IoOpenDeviceRegistryKey(pDevExt->Pdo, 1, 0x00020000L, &
		keyHandle);
	#line 2382
	if(! ((NTSTATUS )status >= 0))
	{
		#line 2383
		return status;
	}
	#line 2386
	status = SerialGetRegistryKeyValue(keyHandle,
		"M\0u\0l\0t\0i\0p\0o\0r\0t\0D\0e\0v\0i\0c\0e\0",
		sizeof("M\0u\0l\0t\0i\0p\0o\0r\0t\0D\0e\0v\0i\0c\0e\0"), &
		isMulti, sizeof(ULONG ));
	if(! ((NTSTATUS )status >= 0))
	{
		#line 2391
		isMulti = 0;
	}
	#line 2394
	status = SerialGetRegistryKeyValue(keyHandle,
		"S\0e\0r\0i\0a\0l\0I\0o\0R\0e\0s\0o\0u\0r\0c\0e\0s\0I\0n\0d\0e\0x\0",
		sizeof("S\0e\0r\0i\0a\0l\0I\0o\0R\0e\0s\0o\0u\0r\0c\0e\0s\0I\0n\0d\0e\0x\0"
		), & ioResIndex, sizeof(ULONG ));
	if(! ((NTSTATUS )status >= 0))
	{
		#line 2399
		ioResIndex = 0;
	}
	#line 2402
	ZwClose(keyHandle);
	#line 2405
	pFullResourceDesc = & (PResList->List)[0];
	pFullTrResourceDesc = & (PTrResList->List)[0];
	#line 2412
	if(pFullResourceDesc)
	{
		#line 2413
		pPartialResourceList = & pFullResourceDesc->PartialResourceList;
		pPartialResourceDesc = pPartialResourceList->PartialDescriptors;
		count = pPartialResourceList->Count;
		#line 2421
		PConfig->InterfaceType = pFullResourceDesc->InterfaceType;
		PConfig->BusNumber = pFullResourceDesc->BusNumber;
		#line 2429
		PConfig->ClockRate = 1843200;
		PConfig->InterruptStatus = SerialPhysicalZero___1;
		PConfig->SpanOfInterruptStatus = (ULONG )(1 * 1);
		#line 2433
		for(i = 0; i < count; i++, pPartialResourceDesc++)
		{
			switch(pPartialResourceDesc->Type)
			{
				#line 2436
			case 1:
					#line 2436
					;
				{
					if(((pPartialResourceDesc->u).Port).Length
						== (ULONG )(1 * 1) && gotISR ==
						0)
					{
						#line 2440
						if(isMulti)
						{
							#line 2441
							gotISR = 1;
							PConfig->InterruptStatus
								=
								((pPartialResourceDesc->u
								).Port).Start;
							#line 2444
							PConfig->SpanOfInterruptStatus
								=
								((pPartialResourceDesc->u
								).Port).Length;
							#line 2446
							PConfig->AddressSpace =
								pPartialResourceDesc->Flags
								;
						}
					}
					else
					{
						#line 2449
						if(gotIO == 0)
						{
							#line 2450
							if(curIoIndex ==
								ioResIndex)
							{
	#line 2451
	gotIO = 1;
	PConfig->Controller = ((pPartialResourceDesc->u).Port).Start;
	#line 2454
	PConfig->SpanOfController = (ULONG )(7 * 1);
	PConfig->AddressSpace = pPartialResourceDesc->Flags;
							}
							else
							{
	#line 2457
	curIoIndex++;
							}
						}
					}
					break;
				}
				#line 2464
			case 2:
					#line 2464
					;
				{
					#line 2465
					if(gotInt == 0)
					{
						#line 2466
						gotInt = 1;
						PConfig->OriginalIrql =
							((pPartialResourceDesc->u
							).Interrupt).Level;
						#line 2468
						PConfig->OriginalVector =
							((pPartialResourceDesc->u
							).Interrupt).Vector;
						#line 2470
						PConfig->Affinity =
							((pPartialResourceDesc->u
							).Interrupt).Affinity;
						#line 2472
						if(pPartialResourceDesc->Flags &
							1)
						{
							#line 2474
							PConfig->InterruptMode =
								Latched;
						}
						else
						{
							#line 2476
							PConfig->InterruptMode =
								LevelSensitive;
						}
					}
					#line 2479
					break;
				}
				#line 2482
			case 5:
					#line 2482
					;
				{
					#line 2483
					PCM_SERIAL_DEVICE_DATA sDeviceData ;
					#line 2485
					sDeviceData = (PCM_SERIAL_DEVICE_DATA
						)(pPartialResourceDesc + 1);
					#line 2486
					PConfig->ClockRate =
						sDeviceData->BaudClock;
					#line 2487
					break;
				}
				#line 2491
			default :
					#line 2491
					;
				{
					#line 2492
					break;
				}
			}
		}
	}
	#line 2503
	gotInt = 0;
	gotISR = 0;
	gotIO = 0;
	curIoIndex = 0;
	#line 2508
	if(pFullTrResourceDesc)
	{
		#line 2509
		pPartialTrResourceList = &
			pFullTrResourceDesc->PartialResourceList;
		#line 2510
		pPartialTrResourceDesc =
			pPartialTrResourceList->PartialDescriptors;
		#line 2511
		count = pPartialTrResourceList->Count;
		#line 2517
		PConfig->InterfaceType = pFullTrResourceDesc->InterfaceType;
		PConfig->BusNumber = pFullTrResourceDesc->BusNumber;
		#line 2520
		PConfig->TrInterruptStatus = SerialPhysicalZero___1;
		#line 2522
		for(i = 0; i < count; i++, pPartialTrResourceDesc++)
		{
			switch(pPartialTrResourceDesc->Type)
			{
				#line 2525
			case 1:
					#line 2525
					;
				{
					#line 2526
					if(((pPartialTrResourceDesc->u).Port).Length
						== (ULONG )(1 * 1) && gotISR ==
						0)
					{
						#line 2528
						if(isMulti)
						{
							#line 2529
							gotISR = 1;
							PConfig->TrInterruptStatus
								=
								((pPartialTrResourceDesc->u
								).Port).Start;
						}
					}
					else
					{
						#line 2534
						if(gotIO == 0)
						{
							#line 2535
							if(curIoIndex ==
								ioResIndex)
							{
	#line 2536
	gotIO = 1;
	PConfig->TrController = ((pPartialTrResourceDesc->u).Port).Start;
	#line 2539
	PConfig->AddressSpace = pPartialTrResourceDesc->Flags;
							}
							else
							{
	#line 2542
	curIoIndex++;
							}
						}
					}
					break;
				}
				#line 2549
			case 2:
					#line 2549
					;
				{
					#line 2550
					if(gotInt == 0)
					{
						#line 2551
						gotInt = 1;
						PConfig->TrVector =
							((pPartialTrResourceDesc->u
							).Interrupt).Vector;
						#line 2553
						PConfig->TrIrql =
							((pPartialTrResourceDesc->u
							).Interrupt).Level;
						#line 2554
						PConfig->Affinity =
							((pPartialTrResourceDesc->u
							).Interrupt).Affinity;
					}
					#line 2556
					break;
				}
				#line 2559
			default :
					#line 2559
					;
				{
					#line 2560
					break;
				}
			}
		}
	}
	#line 2572
	PConfig->PortIndex = 0;
	PConfig->DisablePort = 0;
	PConfig->PermitSystemWideShare = 0;
	PConfig->MaskInverted = 0;
	PConfig->Indexed = 0;
	PConfig->ForceFifoEnable = driverDefaults.ForceFifoEnableDefault;
	PConfig->RxFIFO = driverDefaults.RxFIFODefault;
	PConfig->TxFIFO = driverDefaults.TxFIFODefault;
	PConfig->PermitShare = driverDefaults.PermitShareDefault;
	PConfig->LogFifo = driverDefaults.LogFifoDefault;
	PConfig->Jensen = driverDefaults.JensenDetected;
	#line 2592
	defaultInterfaceType = (ULONG )Isa;
	defaultClockRate = 1843200;
	#line 2596
	for(interfaceType = 0; interfaceType < MaximumInterfaceType;
		interfaceType++)
	{
		#line 2601
		ULONG busZero = 0;
		BOOLEAN foundOne = 0;
		#line 2605
		if(interfaceType != Internal)
		{
			IoQueryDeviceDescription(& interfaceType, & busZero,
				(void *  )0, (void *  )0, (void *  )0, (void * 
				)0, SerialItemCallBack, & foundOne);
			#line 2618
			if(foundOne)
			{
				#line 2619
				defaultInterfaceType = (ULONG )interfaceType;
				#line 2621
				if(defaultInterfaceType == MicroChannel)
				{
					defaultInterruptMode = 0;
				}
				break;
			}
		}
	}
	#line 2644
	if(PUserData == (void *  )0)
	{
		#line 2645
		status = IoOpenDeviceRegistryKey(pDevExt->Pdo, 1, 0x00020000L, &
			keyHandle);
		#line 2650
		if(! ((NTSTATUS )status >= 0))
		{
			#line 2653
			do
			{
				#line 2653
				;
			}
			while(0);
			#line 2654
			goto PortInfoCleanUp;
		}
		else
		{
			#line 2657
			status = SerialGetRegistryKeyValue(keyHandle,
				"D\0i\0s\0a\0b\0l\0e\0P\0o\0r\0t\0",
				sizeof("D\0i\0s\0a\0b\0l\0e\0P\0o\0r\0t\0"), &
				PConfig->DisablePort, sizeof(ULONG ));
			#line 2663
			status = SerialGetRegistryKeyValue(keyHandle,
				"F\0o\0r\0c\0e\0F\0i\0f\0o\0E\0n\0a\0b\0l\0e\0",
				sizeof("F\0o\0r\0c\0e\0F\0i\0f\0o\0E\0n\0a\0b\0l\0e\0"
				), & PConfig->ForceFifoEnable, sizeof(ULONG ));
			#line 2669
			status = SerialGetRegistryKeyValue(keyHandle,
				"R\0x\0F\0I\0F\0O\0",
				sizeof("R\0x\0F\0I\0F\0O\0"), & PConfig->RxFIFO,
				sizeof(ULONG ));
			#line 2675
			status = SerialGetRegistryKeyValue(keyHandle,
				"T\0x\0F\0I\0F\0O\0",
				sizeof("T\0x\0F\0I\0F\0O\0"), & PConfig->TxFIFO,
				sizeof(ULONG ));
			#line 2681
			status = SerialGetRegistryKeyValue(keyHandle,
				"M\0a\0s\0k\0I\0n\0v\0e\0r\0t\0e\0d\0",
				sizeof("M\0a\0s\0k\0I\0n\0v\0e\0r\0t\0e\0d\0"),
				& PConfig->MaskInverted, sizeof(ULONG ));
			#line 2687
			status = SerialGetRegistryKeyValue(keyHandle,
				"S\0h\0a\0r\0e\0 \0S\0y\0s\0t\0e\0m\0 \0I\0n\0t\0e\0r\0r\0u\0p\0t\0",
				sizeof("S\0h\0a\0r\0e\0 \0S\0y\0s\0t\0e\0m\0 \0I\0n\0t\0e\0r\0r\0u\0p\0t\0"
				), & PConfig->PermitShare, sizeof(ULONG ));
			#line 2693
			status = SerialGetRegistryKeyValue(keyHandle,
				"P\0o\0r\0t\0I\0n\0d\0e\0x\0",
				sizeof("P\0o\0r\0t\0I\0n\0d\0e\0x\0"), &
				PConfig->PortIndex, sizeof(ULONG ));
			#line 2699
			status = SerialGetRegistryKeyValue(keyHandle,
				"I\0n\0d\0e\0x\0e\0d\0",
				sizeof("I\0n\0d\0e\0x\0e\0d\0"), &
				PConfig->Indexed, sizeof(ULONG ));
			#line 2704
			status = SerialGetRegistryKeyValue(keyHandle,
				"C\0l\0o\0c\0k\0R\0a\0t\0e\0",
				sizeof("C\0l\0o\0c\0k\0R\0a\0t\0e\0"), &
				PConfig->ClockRate, sizeof(ULONG ));
			#line 2710
			if(! ((NTSTATUS )status >= 0))
			{
				#line 2711
				PConfig->ClockRate = defaultClockRate;
			}
			#line 2714
			ZwClose(keyHandle);
		}
	}
	else
	{
		#line 2721
		ULONG badValue = (ULONG )(- 1);
		#line 2723
		PConfig->DisablePort = PUserData->DisablePort == badValue ? 0
			: PUserData->DisablePort;
		#line 2726
		PConfig->ForceFifoEnable = PUserData->ForceFIFOEnable ==
			badValue ? PUserData->ForceFIFOEnableDefault
			: PUserData->ForceFIFOEnable;
		PConfig->RxFIFO = PUserData->RxFIFO == badValue
			? PUserData->RxFIFODefault : PUserData->RxFIFO;
		#line 2732
		PConfig->Indexed = PUserData->UserIndexed == badValue ? 0
			: PUserData->UserIndexed;
		#line 2735
		PConfig->TxFIFO = PUserData->TxFIFO == badValue
			? PUserData->TxFIFODefault : PUserData->TxFIFO;
		#line 2738
		PConfig->MaskInverted = PUserData->MaskInverted == badValue ? 0
			: PUserData->MaskInverted;
		#line 2741
		PConfig->ClockRate = PUserData->UserClockRate == badValue
			? defaultClockRate : PUserData->UserClockRate;
		#line 2744
		PConfig->PermitShare = PUserData->PermitShareDefault;
		PConfig->PortIndex = PUserData->UserPortIndex;
	}
	#line 2772
	if(! (PConfig->Controller).LowPart)
	{
		#line 2778
		SerialLogError(PDevObj->DriverObject, (void *  )0,
			PConfig->Controller, SerialPhysicalZero___1, 0, 0, 0,
			58, (NTSTATUS )0x00000000L, (NTSTATUS )0xC0060019L, 0,
			(void *  )0, sizeof("P\0o\0r\0t\0A\0d\0d\0r\0e\0s\0s\0")
			+ sizeof(WCHAR ), "P\0o\0r\0t\0A\0d\0d\0r\0e\0s\0s\0");
		#line 2797
		do
		{
			#line 2797
			;
		}
		while(0);
		#line 2799
		status = (NTSTATUS )0xC0060019L;
		goto PortInfoCleanUp;
	}
	#line 2804
	if(! PConfig->OriginalVector)
	{
		#line 2810
		SerialLogError(pDevExt->DriverObject, (void *  )0,
			PConfig->Controller, SerialPhysicalZero___1, 0, 0, 0,
			59, (NTSTATUS )0x00000000L, (NTSTATUS )0xC0060019L,
			(pDevExt->DeviceName).Length,
			(pDevExt->DeviceName).Buffer,
			sizeof("I\0n\0t\0e\0r\0r\0u\0p\0t\0"),
			"I\0n\0t\0e\0r\0r\0u\0p\0t\0");
		#line 2828
		do
		{
			#line 2828
			;
		}
		while(0);
		#line 2830
		status = (NTSTATUS )0xC0060019L;
		goto PortInfoCleanUp;
	}
	#line 2835
	if((PConfig->InterruptStatus).LowPart != 0)
	{
		if(PConfig->PortIndex == 0xffffffff)
		{
			#line 2843
			SerialLogError(pDevExt->DriverObject, (void *  )0,
				PConfig->Controller, SerialPhysicalZero___1, 0,
				0, 0, 30, (NTSTATUS )0x00000000L, (NTSTATUS
				)0xC0060014L, 0, (void *  )0, 0, (void *  )0);
			#line 2861
			do
			{
				#line 2861
				;
			}
			while(0);
			#line 2863
			status = (NTSTATUS )0xC0060014L;
			goto PortInfoCleanUp;
		}
		else
		{
			#line 2866
			if(! PConfig->PortIndex)
			{
				#line 2872
				SerialLogError(pDevExt->DriverObject, (void * 
					)0, PConfig->Controller,
					SerialPhysicalZero___1, 0, 0, 0, 31,
					(NTSTATUS )0x00000000L, (NTSTATUS
					)0xC0060014L, 0, (void *  )0, 0,
					(void *  )0);
				#line 2894
				do
				{
					#line 2894
					;
				}
				while(0);
				#line 2896
				status = (NTSTATUS )0xC0060014L;
				goto PortInfoCleanUp;
			}
			else
			{
				if(PConfig->Indexed)
				{
					if(PConfig->PortIndex > 16)
					{
						SerialLogError(pDevExt->DriverObject
							, (void *  )0,
							PConfig->Controller,
							SerialPhysicalZero___1,
							0, 0, 0, 32, (NTSTATUS
							)0x00000000L, (NTSTATUS
							)0xC0060015L, 0,
							(void *  )0, 0, (void * 
							)0);
						#line 2924
						do
						{
							#line 2924
							;
						}
						while(0);
						#line 2926
						status = (NTSTATUS )0xC0060015L;
						goto PortInfoCleanUp;
					}
				}
				else
				{
					if(PConfig->PortIndex > 8)
					{
						SerialLogError(pDevExt->DriverObject
							, (void *  )0,
							PConfig->Controller,
							SerialPhysicalZero___1,
							0, 0, 0, 33, (NTSTATUS
							)0x00000000L, (NTSTATUS
							)0xC0060015L, 0,
							(void *  )0, 0, (void * 
							)0);
						#line 2953
						do
						{
							#line 2953
							;
						}
						while(0);
						#line 2955
						status = (NTSTATUS )0xC0060015L;
						goto PortInfoCleanUp;
					}
				}
			}
		}
	}
	#line 2974
	if(PConfig->BusNumber != 0)
	{
		BOOLEAN foundIt ;
		#line 2978
		if(PConfig->InterfaceType >= MaximumInterfaceType)
		{
			#line 2984
			SerialLogError(pDevExt->DriverObject, (void *  )0,
				PConfig->Controller, SerialPhysicalZero___1, 0,
				0, 0, 34, (NTSTATUS )0x00000000L, (NTSTATUS
				)0xC0060016L, 0, (void *  )0, 0, (void *  )0);
			#line 3002
			do
			{
				#line 3002
				;
			}
			while(0);
			#line 3004
			status = (NTSTATUS )0xC0060016L;
			goto PortInfoCleanUp;
		}
		#line 3008
		IoQueryDeviceDescription((INTERFACE_TYPE *  )(&
			PConfig->InterfaceType), & zero, (void *  )0, (void * 
			)0, (void *  )0, (void *  )0, SerialItemCallBack, &
			foundIt);
		#line 3019
		if(! foundIt)
		{
			SerialLogError(pDevExt->DriverObject, (void *  )0,
				PConfig->Controller, SerialPhysicalZero___1, 0,
				0, 0, 35, (NTSTATUS )0x00000000L, (NTSTATUS
				)0xC0060017L, 0, (void *  )0, 0, (void *  )0);
			#line 3042
			do
			{
				#line 3042
				;
			}
			while(0);
			#line 3044
			status = (NTSTATUS )0xC0060017L;
			goto PortInfoCleanUp;
		}
	}
	#line 3052
	if(PConfig->InterfaceType == MicroChannel && PConfig->InterruptMode ==
		1)
	{
		SerialLogError(pDevExt->DriverObject, (void *  )0,
			PConfig->Controller, SerialPhysicalZero___1, 0, 0, 0,
			36, (NTSTATUS )0x00000000L, (NTSTATUS )0xC0060018L, 0,
			(void *  )0, 0, (void *  )0);
		#line 3075
		do
		{
			#line 3075
			;
		}
		while(0);
		#line 3077
		status = (NTSTATUS )0xC0060018L;
		goto PortInfoCleanUp;
	}
	#line 3082
	status = (NTSTATUS )0x00000000L;
	#line 3089
	do
	{
		#line 3089
		;
	}
	while(0);
	do
	{
		#line 3092
		;
	}
	while(0);
	do
	{
		#line 3095
		;
	}
	while(0);
	do
	{
		#line 3098
		;
	}
	while(0);
	do
	{
		#line 3101
		;
	}
	while(0);
	do
	{
		#line 3104
		;
	}
	while(0);
	do
	{
		#line 3107
		;
	}
	while(0);
	do
	{
		#line 3110
		;
	}
	while(0);
	do
	{
		#line 3113
		;
	}
	while(0);
	do
	{
		#line 3116
		;
	}
	while(0);
	do
	{
		#line 3119
		;
	}
	while(0);
	#line 3121
	PortInfoCleanUp:
		#line 3121
		;
	#line 3123
	return status;
}

#line 3128
NTSTATUS SerialDoExternalNaming(PSERIAL_DEVICE_EXTENSION PDevExt ,
	PDRIVER_OBJECT PDrvObj )
{
	#line 3153
	NTSTATUS status = (NTSTATUS )0x00000000L;
	HANDLE keyHandle ;
	WCHAR *  pRegName = (void *  )0;
	UNICODE_STRING linkName ;
	PDEVICE_OBJECT pLowerDevObj , pDevObj ;
	ULONG bufLen ;
	#line 3161
	;
	#line 3163
	pDevObj = PDevExt->DeviceObject;
	pLowerDevObj = PDevExt->LowerDeviceObject;
	#line 3166
	status = IoOpenDeviceRegistryKey(PDevExt->Pdo, 1, 0x00020000L, &
		keyHandle);
	#line 3175
	if(status != (NTSTATUS )0x00000000L)
	{
		#line 3176
		return status;
	}
	#line 3180
	SerialGetRegistryKeyValue(keyHandle,
		"S\0e\0r\0i\0a\0l\0S\0k\0i\0p\0E\0x\0t\0e\0r\0n\0a\0l\0N\0a\0m\0i\0n\0g\0",
		sizeof("S\0e\0r\0i\0a\0l\0S\0k\0i\0p\0E\0x\0t\0e\0r\0n\0a\0l\0N\0a\0m\0i\0n\0g\0"
		), & PDevExt->SkipNaming, sizeof(ULONG ));
	if(PDevExt->SkipNaming)
	{
		#line 3185
		ZwClose(keyHandle);
		return (NTSTATUS )0x00000000L;
	}
	#line 3189
	memset(& linkName, 0, sizeof(UNICODE_STRING ));
	#line 3191
	linkName.MaximumLength = 128 * sizeof(WCHAR );
	linkName.Buffer = ExAllocatePoolWithTag(PagedPool,
		linkName.MaximumLength + sizeof(WCHAR ), 'XMOC');
	#line 3195
	if(linkName.Buffer == (void *  )0)
	{
		#line 3196
		SerialLogError(PDrvObj, pDevObj, SerialPhysicalZero___1,
			SerialPhysicalZero___1, 0, 0, 0, 19, (NTSTATUS
			)0x00000000L, (NTSTATUS )0xC0060008L, 0, (void *  )0, 0,
			(void *  )0);
		do
		{
			#line 3200
			;
		}
		while(0);
		#line 3202
		status = (NTSTATUS )0xC000009AL;
		ZwClose(keyHandle);
		goto SerialDoExternalNamingError;
	}
	#line 3208
	memset(linkName.Buffer, 0, linkName.MaximumLength + sizeof(WCHAR ));
	#line 3211
	pRegName = ExAllocatePoolWithTag(PagedPool, 128 * sizeof(WCHAR ) +
		sizeof(WCHAR ), 'XMOC');
	#line 3214
	if(pRegName == (void *  )0)
	{
		#line 3215
		SerialLogError(PDrvObj, pDevObj, SerialPhysicalZero___1,
			SerialPhysicalZero___1, 0, 0, 0, 19, (NTSTATUS
			)0x00000000L, (NTSTATUS )0xC0060008L, 0, (void *  )0, 0,
			(void *  )0);
		do
		{
			#line 3219
			;
		}
		while(0);
		#line 3221
		status = (NTSTATUS )0xC000009AL;
		ZwClose(keyHandle);
		goto SerialDoExternalNamingError;
	}
	#line 3231
	status = SerialGetRegistryKeyValue(keyHandle,
		"P\0o\0r\0t\0N\0a\0m\0e\0", sizeof("P\0o\0r\0t\0N\0a\0m\0e\0"),
		pRegName, 128 * sizeof(WCHAR ));
	#line 3235
	if(! ((NTSTATUS )status >= 0))
	{
		#line 3241
		status = SerialGetRegistryKeyValue(keyHandle,
			"I\0d\0e\0n\0t\0i\0f\0i\0e\0r\0",
			sizeof("I\0d\0e\0n\0t\0i\0f\0i\0e\0r\0"), pRegName, 128
			* sizeof(WCHAR ));
		#line 3246
		if(! ((NTSTATUS )status >= 0))
		{
			#line 3255
			do
			{
				#line 3255
				;
			}
			while(0);
			#line 3256
			ZwClose(keyHandle);
			goto SerialDoExternalNamingError;
		}
	}
	#line 3262
	ZwClose(keyHandle);
	#line 3264
	bufLen = wcslen(pRegName) * sizeof(WCHAR ) + sizeof((WCHAR )0);
	#line 3266
	(PDevExt->WmiIdentifier).Buffer = ExAllocatePoolWithTag(PagedPool,
		bufLen, 'XMOC');
	if((PDevExt->WmiIdentifier).Buffer == (void *  )0)
	{
		#line 3269
		SerialLogError(PDrvObj, pDevObj, SerialPhysicalZero___1,
			SerialPhysicalZero___1, 0, 0, 0, 19, (NTSTATUS
			)0x00000000L, (NTSTATUS )0xC0060008L, 0, (void *  )0, 0,
			(void *  )0);
		do
		{
			#line 3273
			;
		}
		while(0);
		#line 3275
		status = (NTSTATUS )0xC000009AL;
		goto SerialDoExternalNamingError;
	}
	#line 3279
	memset((PDevExt->WmiIdentifier).Buffer, 0, bufLen);
	#line 3281
	(PDevExt->WmiIdentifier).Length = 0;
	(PDevExt->WmiIdentifier).MaximumLength = (USHORT )bufLen - 1;
	RtlAppendUnicodeToString(& PDevExt->WmiIdentifier, pRegName);
	#line 3289
	RtlAppendUnicodeToString(& linkName, "\134\0");
	RtlAppendUnicodeToString(& linkName, "D\0o\0s\0D\0e\0v\0i\0c\0e\0s\0");
	RtlAppendUnicodeToString(& linkName, "\134\0");
	RtlAppendUnicodeToString(& linkName, pRegName);
	#line 3297
	(PDevExt->SymbolicLinkName).MaximumLength = linkName.Length +
		sizeof(WCHAR );
	#line 3298
	(PDevExt->SymbolicLinkName).Buffer = ExAllocatePoolWithTag(PagedPool,
		(PDevExt->SymbolicLinkName).MaximumLength, 'XMOC');
	#line 3301
	if(! (PDevExt->SymbolicLinkName).Buffer)
	{
		SerialLogError(PDrvObj, pDevObj, SerialPhysicalZero___1,
			SerialPhysicalZero___1, 0, 0, 0, 19, (NTSTATUS
			)0x00000000L, (NTSTATUS )0xC0060008L, 0, (void *  )0, 0,
			(void *  )0);
		do
		{
			#line 3307
			;
		}
		while(0);
		#line 3309
		status = (NTSTATUS )0xC000009AL;
		goto SerialDoExternalNamingError;
	}
	#line 3320
	memset((PDevExt->SymbolicLinkName).Buffer, 0,
		(PDevExt->SymbolicLinkName).MaximumLength);
	RtlAppendUnicodeStringToString(& PDevExt->SymbolicLinkName, & linkName);
	#line 3325
	(PDevExt->DosName).Buffer = ExAllocatePoolWithTag(PagedPool, 64 +
		sizeof(WCHAR ), 'XMOC');
	if(! (PDevExt->DosName).Buffer)
	{
		SerialLogError(PDrvObj, pDevObj, SerialPhysicalZero___1,
			SerialPhysicalZero___1, 0, 0, 0, 19, (NTSTATUS
			)0x00000000L, (NTSTATUS )0xC0060008L, 0, (void *  )0, 0,
			(void *  )0);
		do
		{
			#line 3333
			;
		}
		while(0);
		#line 3335
		status = (NTSTATUS )0xC000009AL;
		goto SerialDoExternalNamingError;
	}
	#line 3340
	(PDevExt->DosName).MaximumLength = 64 + sizeof(WCHAR );
	#line 3346
	(PDevExt->DosName).Length = 0;
	#line 3349
	memset((PDevExt->DosName).Buffer, 0, (PDevExt->DosName).MaximumLength);
	#line 3351
	RtlAppendUnicodeToString(& PDevExt->DosName, pRegName);
	#line 3353
	memset((PUCHAR )(& ((PDevExt->DosName).Buffer)[0]) +
		(PDevExt->DosName).Length, 0, sizeof(WCHAR ));
	#line 3356
	do
	{
		#line 3356
		;
	}
	while(0);
	#line 3361
	status = IoCreateSymbolicLink(& PDevExt->SymbolicLinkName, &
		PDevExt->DeviceName);
	#line 3364
	if(! ((NTSTATUS )status >= 0))
	{
		#line 3371
		SerialLogError(PDrvObj, pDevObj, SerialPhysicalZero___1,
			SerialPhysicalZero___1, 0, 0, 0, 52, status, (NTSTATUS
			)0x80060004L, (PDevExt->DeviceName).Length +
			sizeof(WCHAR ), (PDevExt->DeviceName).Buffer, 0,
			(void *  )0);
		#line 3381
		do
		{
			#line 3381
			;
		}
		while(0);
		#line 3383
		goto SerialDoExternalNamingError;
	}
	#line 3387
	PDevExt->CreatedSymbolicLink = 1;
	#line 3389
	status = RtlWriteRegistryValue(4, "S\0E\0R\0I\0A\0L\0C\0O\0M\0M\0",
		(PDevExt->DeviceName).Buffer, 1, (PDevExt->DosName).Buffer,
		(PDevExt->DosName).Length + sizeof(WCHAR ));
	#line 3394
	if(! ((NTSTATUS )status >= 0))
	{
		SerialLogError(PDrvObj, pDevObj, SerialPhysicalZero___1,
			SerialPhysicalZero___1, 0, 0, 0, 53, status, (NTSTATUS
			)0x80060005L, (PDevExt->DeviceName).Length +
			sizeof(WCHAR ), (PDevExt->DeviceName).Buffer, 0,
			(void *  )0);
		#line 3402
		do
		{
			#line 3402
			;
		}
		while(0);
		#line 3404
		goto SerialDoExternalNamingError;
	}
	#line 3407
	PDevExt->CreatedSerialCommEntry = 1;
	#line 3414
	status = IoRegisterDeviceInterface(PDevExt->Pdo, (LPGUID )(&
		GUID_CLASS_COMPORT), (void *  )0, &
		PDevExt->DeviceClassSymbolicName);
	if(! ((NTSTATUS )status >= 0))
	{
		#line 3420
		do
		{
			#line 3420
			;
		}
		while(0);
		#line 3422
		(PDevExt->DeviceClassSymbolicName).Buffer = (void *  )0;
		goto SerialDoExternalNamingError;
	}
	#line 3431
	status = IoSetDeviceInterfaceState(& PDevExt->DeviceClassSymbolicName,
		1);
	#line 3434
	if(! ((NTSTATUS )status >= 0))
	{
		#line 3437
		do
		{
			#line 3437
			;
		}
		while(0);
	}
	#line 3440
	SerialDoExternalNamingError:
		#line 3440
		;
	#line 3446
	if(! ((NTSTATUS )status >= 0))
	{
		#line 3447
		if((PDevExt->DosName).Buffer != (void *  )0)
		{
			#line 3448
			ExFreePool((PDevExt->DosName).Buffer);
			(PDevExt->DosName).Buffer = (void *  )0;
		}
		#line 3452
		if(PDevExt->CreatedSymbolicLink == 1)
		{
			#line 3453
			IoDeleteSymbolicLink(& PDevExt->SymbolicLinkName);
			PDevExt->CreatedSymbolicLink = 0;
		}
		#line 3457
		if((PDevExt->SymbolicLinkName).Buffer != (void *  )0)
		{
			#line 3458
			ExFreePool((PDevExt->SymbolicLinkName).Buffer);
			(PDevExt->SymbolicLinkName).Buffer = (void *  )0;
		}
		#line 3462
		if((PDevExt->DeviceName).Buffer != (void *  )0)
		{
			#line 3463
			RtlDeleteRegistryValue(4,
				"S\0E\0R\0I\0A\0L\0C\0O\0M\0M\0",
				(PDevExt->DeviceName).Buffer);
		}
		if((PDevExt->DeviceClassSymbolicName).Buffer)
		{
			#line 3468
			IoSetDeviceInterfaceState(&
				PDevExt->DeviceClassSymbolicName, 0);
		}
		if((PDevExt->WmiIdentifier).Buffer != (void *  )0)
		{
			#line 3472
			ExFreePool((PDevExt->WmiIdentifier).Buffer);
			(PDevExt->WmiIdentifier).Buffer = (void *  )0;
		}
	}
	#line 3481
	if(linkName.Buffer != (void *  )0)
	{
		#line 3482
		ExFreePool(linkName.Buffer);
	}
	#line 3485
	if(pRegName != (void *  )0)
	{
		#line 3486
		ExFreePool(pRegName);
	}
	#line 3489
	return status;
}

#line 3496
void SerialUndoExternalNaming(PSERIAL_DEVICE_EXTENSION Extension )
{
	#line 3521
	NTSTATUS status ;
	#line 3523
	;
	#line 3530
	do
	{
		#line 3530
		;
	}
	while(0);
	#line 3536
	if(Extension->SkipNaming)
	{
		#line 3537
		return;
	}
	#line 3546
	if((Extension->SymbolicLinkName).Buffer &&
		Extension->CreatedSymbolicLink)
	{
		if((Extension->DeviceClassSymbolicName).Buffer)
		{
			#line 3550
			status = IoSetDeviceInterfaceState(&
				Extension->DeviceClassSymbolicName, 0);
			#line 3559
			ExFreePool((Extension->DeviceClassSymbolicName).Buffer);
		}
		#line 3563
		IoDeleteSymbolicLink(& Extension->SymbolicLinkName);
	}
	#line 3567
	if((Extension->WmiIdentifier).Buffer)
	{
		#line 3568
		ExFreePool((Extension->WmiIdentifier).Buffer);
		(Extension->WmiIdentifier).MaximumLength =
			((Extension->WmiIdentifier).Length = 0);
		(Extension->WmiIdentifier).Buffer = (void *  )0;
	}
	#line 3579
	if((Extension->DeviceName).Buffer != (void *  )0 &&
		Extension->CreatedSerialCommEntry)
	{
		status = RtlDeleteRegistryValue(4,
			"S\0E\0R\0I\0A\0L\0C\0O\0M\0M\0",
			(Extension->DeviceName).Buffer);
		if(! ((NTSTATUS )status >= 0))
		{
			SerialLogError((Extension->DeviceObject)->DriverObject,
				Extension->DeviceObject,
				Extension->OriginalController,
				SerialPhysicalZero___1, 0, 0, 0, 55, status,
				(NTSTATUS )0x80060006L,
				(Extension->DeviceName).Length + sizeof(WCHAR ),
				(Extension->DeviceName).Buffer, 0, (void *  )0);
			#line 3607
			do
			{
				#line 3607
				;
			}
			while(0);
		}
	}
}

#line 16 "C:/NTDDK/inc/stddef.h"

#pragma once
#line 77
typedef int ;

#line 86
typedef unsigned int ;

#line 95
typedef int ;

#line 105
typedef unsigned int ;

#line 112
typedef unsigned short ;

#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"

#pragma once
#line 32

#pragma pack(push, 8)
#line 72
typedef enum _EXCEPTION_DISPOSITION ;

#line 89
struct _EXCEPTION_RECORD ;

#line 90
struct _CONTEXT ;

#line 155

#pragma pack(pop)
#line 25 "C:/NTDDK/inc/ntdef.h"

#pragma once
#line 15 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"

#pragma once
#line 66
typedef wchar_t ;

#line 67
typedef wchar_t ;

#line 127 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long ;

#line 25 "C:/NTDDK/inc/basetsd.h"

#pragma once
#line 36
typedef int ;

#line 37
typedef int ;

#line 43
typedef unsigned int ;

#line 44
typedef unsigned int ;

#line 45
typedef unsigned int ;

#line 84
typedef int ;

#line 85
typedef unsigned int ;

typedef long ;

#line 88
typedef unsigned long ;

#line 248
typedef unsigned short ;

#line 249
typedef short ;

#line 250
typedef unsigned long ;

#line 288
typedef ULONG_PTR ;

#line 289
typedef LONG_PTR ;

#line 295
typedef ULONG_PTR ;

#line 301
typedef __int64 ;

#line 302
typedef __int64 ;

#line 309
typedef unsigned __int64 ;

#line 310
typedef unsigned __int64 ;

#line 311
typedef unsigned __int64 ;

#line 217 "C:/NTDDK/inc/ntdef.h"
typedef void ;

#line 218
typedef void ;

#line 266
typedef char ;

#line 267
typedef short ;

#line 268
typedef long ;

#line 276
typedef wchar_t ;

#line 282
typedef WCHAR ;

#line 283
typedef WCHAR ;

#line 284
typedef const WCHAR ;

#line 285
typedef WCHAR ;

#line 286
typedef WCHAR ;

typedef const WCHAR ;

#line 293
typedef CHAR ;

#line 294
typedef CHAR ;

typedef const CHAR ;

#line 297
typedef CHAR ;

#line 298
typedef CHAR ;

#line 299
typedef const CHAR ;

#line 321
typedef char ;

#line 322
typedef unsigned char ;

#line 326
typedef LPSTR ;

#line 327
typedef LPSTR ;

#line 328
typedef LPCSTR ;

#line 337
typedef double ;

typedef struct _QUAD ;

#line 349
typedef SHORT ;

#line 350
typedef LONG ;

#line 351
typedef QUAD ;

#line 360
typedef unsigned char ;

#line 361
typedef unsigned short ;

#line 362
typedef unsigned long ;

#line 363
typedef QUAD ;

#line 369
typedef UCHAR ;

#line 370
typedef USHORT ;

#line 371
typedef ULONG ;

#line 372
typedef UQUAD ;

#line 378
typedef signed char ;

#line 379
typedef SCHAR ;

#line 394
typedef void ;

#line 400
typedef HANDLE ;

#line 406
typedef UCHAR ;

#line 407
typedef USHORT ;

#line 408
typedef ULONG ;

#line 414
typedef LONG ;

#line 478
typedef char ;

#line 479
typedef short ;

#line 480
typedef ULONG ;

typedef CCHAR ;

#line 483
typedef CSHORT ;

#line 484
typedef CLONG ;

#line 492
typedef ULONG ;

#line 493
typedef PULONG ;

#line 494
typedef USHORT ;

#line 500
typedef ULONG ;

#line 501
typedef ULONG ;

#line 508
typedef LONG ;

typedef NTSTATUS ;

#line 602
typedef struct _FLOAT128 ;

#line 607
typedef FLOAT128 ;

#line 621
typedef __int64 ;

#line 622
typedef unsigned __int64 ;

#line 639
typedef LONGLONG ;

#line 640
typedef ULONGLONG ;

#line 644
typedef LONGLONG ;

#line 649
typedef union _LARGE_INTEGER ;

#line 662
typedef LARGE_INTEGER ;

#line 668
typedef union _ULARGE_INTEGER ;

#line 681
typedef ULARGE_INTEGER ;

#line 690
typedef struct _LUID ;

#line 696
typedef ULONGLONG ;

#line 697
typedef DWORDLONG ;

#line 707
typedef LARGE_INTEGER ;

#line 831

#pragma warning(push)

#pragma warning(disable:4035)
__inline ULONGLONG __stdcall Int64ShllMod32___15(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 842
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    
		};
}

#line 845
__inline LONGLONG __stdcall Int64ShraMod32___15(LONGLONG Value , ULONG
	ShiftCount )
{
	#line 852
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    
		};
}

#line 855
__inline ULONGLONG __stdcall Int64ShrlMod32___15(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 862
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    
		};
}


#pragma warning(pop)
#line 956
typedef enum _EVENT_TYPE ;

#line 965
typedef enum _TIMER_TYPE ;

#line 974
typedef enum _WAIT_TYPE ;

#line 983
typedef CHAR ;

#line 984
typedef const char ;

#line 991
typedef struct _STRING ;

#line 999
typedef STRING ;

typedef STRING ;

#line 1002
typedef PSTRING ;

typedef STRING ;

#line 1005
typedef PSTRING ;

#line 1011
typedef struct _CSTRING ;

#line 1016
typedef CSTRING ;

#line 1019
typedef STRING ;

#line 1020
typedef PSTRING ;

#line 1027
typedef struct _UNICODE_STRING ;

#line 1036
typedef UNICODE_STRING ;

#line 1037
typedef const UNICODE_STRING ;

#line 1046
typedef UCHAR ;

#line 1047
typedef BOOLEAN ;

#line 1057
typedef struct _LIST_ENTRY ;

#line 1067
typedef struct _SINGLE_LIST_ENTRY ;

#line 1078
typedef struct LIST_ENTRY32 ;

#line 1082
typedef LIST_ENTRY32 ;

typedef struct LIST_ENTRY64 ;

#line 1088
typedef LIST_ENTRY64 ;

#line 1127
typedef struct _STRING32 ;

#line 1132
typedef STRING32 ;

typedef STRING32 ;

#line 1135
typedef UNICODE_STRING32 ;

typedef STRING32 ;

#line 1138
typedef ANSI_STRING32 ;

#line 1141
typedef struct _STRING64 ;

#line 1146
typedef STRING64 ;

typedef STRING64 ;

#line 1149
typedef UNICODE_STRING64 ;

typedef STRING64 ;

#line 1152
typedef ANSI_STRING64 ;

#line 1173
typedef struct _OBJECT_ATTRIBUTES ;

#line 1181
typedef OBJECT_ATTRIBUTES ;

#line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID ;

#line 70
typedef GUID ;

#line 75
typedef const GUID ;

#line 81
typedef GUID ;

#line 82
typedef IID ;

#line 85
typedef GUID ;

#line 86
typedef CLSID ;

#line 89
typedef GUID ;

#line 90
typedef FMTID ;

#line 16 "C:/NTDDK/inc/string.h"

#pragma once
#line 1233 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECTID ;

#line 1288
struct _CONTEXT ;

#line 1289
struct _EXCEPTION_RECORD ;

typedef EXCEPTION_DISPOSITION ;

#line 1306
typedef UCHAR ;

typedef KIRQL ;

#line 1316
typedef enum _NT_PRODUCT_TYPE ;

#line 1329
typedef enum _SUITE_TYPE ;

#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD ;

#line 76
typedef struct _ETHREAD ;

#line 77
typedef struct _EPROCESS ;

#line 78
typedef struct _PEB ;

#line 79
typedef struct _KINTERRUPT ;

#line 80
typedef struct _IO_TIMER ;

#line 81
typedef struct _OBJECT_TYPE ;

#line 82
typedef struct _CALLBACK_OBJECT ;

#line 83
typedef struct _DEVICE_HANDLER_OBJECT ;

#line 84
typedef struct _BUS_HANDLER ;

#line 143
typedef union _SLIST_HEADER ;

#line 204
typedef CCHAR ;

typedef enum _MODE ;

#line 222
struct _KAPC ;

typedef void ;

#line 232
typedef void ;

#line 242
typedef void ;

#line 248
typedef BOOLEAN ;

#line 254
typedef BOOLEAN ;

#line 265
typedef struct _KAPC ;

#line 292
struct _KDPC ;

typedef void ;

#line 351
typedef enum _KDPC_IMPORTANCE ;

#line 361
typedef struct _KDPC ;

#line 377
typedef PVOID ;

typedef void ;

#line 392
typedef struct _KIPI_COUNTS ;

#line 443
typedef struct _MDL ;

#line 532
typedef PVOID ;

#line 538
typedef PVOID ;

#line 544
typedef PVOID ;

typedef ULONG ;

#line 547
typedef ACCESS_MASK ;

#line 597
typedef struct _GENERIC_MAPPING ;

#line 603
typedef GENERIC_MAPPING ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES ;

#line 622
typedef LUID_AND_ATTRIBUTES ;

#line 623
typedef LUID_AND_ATTRIBUTES_ARRAY ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 642 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACL ;

#line 649
typedef ACL ;

#line 681
typedef struct _PRIVILEGE_SET ;

#line 735
typedef enum _SECURITY_IMPERSONATION_LEVEL ;

#line 753
typedef BOOLEAN ;

#line 762
typedef struct _SECURITY_QUALITY_OF_SERVICE ;

#line 774
typedef struct _SE_IMPERSONATION_STATE ;

#line 782
typedef ULONG ;

#line 809
typedef ULONG ;

#line 810
typedef KAFFINITY ;

#line 816
typedef LONG ;

#line 824
typedef ULONG_PTR ;

#line 825
typedef KSPIN_LOCK ;

#line 833
typedef void ;

#line 842
typedef enum _KPROFILE_SOURCE ;

#line 1079
typedef NTSTATUS ;

#line 1088
typedef struct _RTL_QUERY_REGISTRY_TABLE ;

#line 1952

#pragma warning(push)

#pragma warning(disable:4035)
#line 2019

#pragma warning(pop)
#line 2214
typedef struct _TIME_FIELDS ;

#line 2224
typedef TIME_FIELDS ;

#line 2499
typedef struct _RTL_BITMAP ;

#line 2503
typedef RTL_BITMAP ;

#line 2627
typedef struct _RTL_BITMAP_RUN ;

#line 2633
typedef RTL_BITMAP_RUN ;

#line 2886
typedef struct _RTL_RANGE ;

#line 2924
typedef struct _RTL_RANGE_LIST ;

#line 2950
typedef struct _RANGE_LIST_ITERATOR ;

#line 3019
typedef BOOLEAN ;

#line 3155
typedef struct _OSVERSIONINFOA ;

#line 3164
typedef struct _OSVERSIONINFOW ;

#line 3177
typedef OSVERSIONINFOA ;

#line 3178
typedef POSVERSIONINFOA ;

#line 3179
typedef LPOSVERSIONINFOA ;

#line 3182
typedef struct _OSVERSIONINFOEXA ;

#line 3195
typedef struct _OSVERSIONINFOEXW ;

#line 3213
typedef OSVERSIONINFOEXA ;

#line 3214
typedef POSVERSIONINFOEXA ;

#line 3215
typedef LPOSVERSIONINFOEXA ;

#line 3648
typedef struct _IO_STATUS_BLOCK ;

#line 3669
typedef void ;

#line 3685
typedef enum _FILE_INFORMATION_CLASS ;

#line 3731
typedef struct _FILE_BASIC_INFORMATION ;

#line 3739
typedef struct _FILE_STANDARD_INFORMATION ;

#line 3747
typedef struct _FILE_POSITION_INFORMATION ;

#line 3751
typedef struct _FILE_ALIGNMENT_INFORMATION ;

#line 3755
typedef struct _FILE_NAME_INFORMATION ;

#line 3760
typedef struct _FILE_NETWORK_OPEN_INFORMATION ;

#line 3770
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION ;

#line 3775
typedef struct _FILE_DISPOSITION_INFORMATION ;

#line 3779
typedef struct _FILE_END_OF_FILE_INFORMATION ;

#line 3784
typedef struct _FILE_FULL_EA_INFORMATION ;

#line 3798
typedef enum _FSINFOCLASS ;

#line 3810
typedef struct _FILE_FS_DEVICE_INFORMATION ;

#line 3820
typedef union _FILE_SEGMENT_ELEMENT ;

#line 3829
typedef enum _INTERFACE_TYPE ;

#line 3854
typedef enum _DMA_WIDTH ;

#line 3865
typedef enum _DMA_SPEED ;

#line 3879
typedef void ;

#line 3880
typedef void ;

#line 3888
typedef enum _BUS_DATA_TYPE ;

#line 3910
typedef struct _IO_ERROR_LOG_PACKET ;

#line 3931
typedef struct _IO_ERROR_LOG_MESSAGE ;

#line 4074
typedef struct _KEY_BASIC_INFORMATION ;

#line 4081
typedef struct _KEY_NODE_INFORMATION ;

#line 4091
typedef struct _KEY_FULL_INFORMATION ;

#line 4106
typedef struct _KEY_NAME_INFORMATION ;

#line 4112
typedef enum _KEY_INFORMATION_CLASS ;

#line 4122
typedef struct _KEY_WRITE_TIME_INFORMATION ;

#line 4126
typedef enum _KEY_SET_INFORMATION_CLASS ;

#line 4134
typedef struct _KEY_VALUE_BASIC_INFORMATION ;

#line 4141
typedef struct _KEY_VALUE_FULL_INFORMATION ;

#line 4151
typedef struct _KEY_VALUE_PARTIAL_INFORMATION ;

#line 4158
typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ;

#line 4164
typedef struct _KEY_VALUE_ENTRY ;

#line 4171
typedef enum _KEY_VALUE_INFORMATION_CLASS ;

#line 4210
typedef struct _OBJECT_NAME_INFORMATION ;

#line 4221
typedef enum _SECTION_INHERIT ;

#line 4294
typedef struct _CLIENT_ID ;

#line 4298
typedef CLIENT_ID ;

#line 4315
typedef struct _NT_TIB ;

#line 4327
typedef NT_TIB ;

#line 4332
typedef enum _PROCESSINFOCLASS ;

#line 4366
typedef enum _THREADINFOCLASS ;

#line 4395
typedef struct _PROCESS_WS_WATCH_INFORMATION ;

#line 4405
typedef struct _PROCESS_BASIC_INFORMATION ;

#line 4413
typedef PROCESS_BASIC_INFORMATION ;

#line 4422
typedef struct _PROCESS_DEVICEMAP_INFORMATION ;

#line 4440
typedef struct _PROCESS_SESSION_INFORMATION ;

#line 4454
typedef struct _QUOTA_LIMITS ;

#line 4462
typedef QUOTA_LIMITS ;

#line 4472
typedef struct _IO_COUNTERS ;

#line 4480
typedef IO_COUNTERS ;

#line 4488
typedef struct _VM_COUNTERS ;

#line 4501
typedef VM_COUNTERS ;

#line 4508
typedef struct _POOLED_USAGE_AND_LIMITS ;

#line 4519
typedef POOLED_USAGE_AND_LIMITS ;

#line 4528
typedef struct _PROCESS_ACCESS_TOKEN ;

#line 4555
typedef struct _KERNEL_USER_TIMES ;

#line 4561
typedef KERNEL_USER_TIMES ;

#line 4587
typedef enum _SYSTEM_POWER_STATE ;

#line 4598
typedef enum  {
	PowerActionNone = 0,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
} ;

typedef enum _DEVICE_POWER_STATE ;

#line 4618
typedef union _POWER_STATE ;

#line 4623
typedef enum _POWER_STATE_TYPE ;

#line 4654
typedef ULONG ;

typedef enum  {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
} ;

#line 4663
typedef enum  {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation
} ;

#line 4690
typedef ULONG ;

typedef LONG ;

#line 4693
typedef ULONG ;

#line 4719
typedef union _MCI_STATS ;

#line 4978
typedef struct _KPCR ;

#line 5006
typedef KPCR ;

#line 5012
typedef struct _KFLOATING_SAVE ;

#line 5153
typedef enum _INTERLOCKED_RESULT ;

#line 5252

#pragma warning(disable:4035)
#line 6994
typedef struct _KSYSTEM_TIME ;

#line 7014

#pragma warning(push)

#pragma warning(disable:4164)
#line 7019

#pragma function(_enable)
#line 7020

#pragma function(_disable)
#line 7024

#pragma warning(pop)
#line 7085
typedef struct _FLOATING_SAVE_AREA ;

#line 7097
typedef FLOATING_SAVE_AREA ;

#line 7109
typedef struct _CONTEXT ;

#line 7197
typedef CONTEXT ;

#line 7826
typedef void ;

#line 7850
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ;

#line 7899
typedef struct _KUSER_SHARED_DATA ;

#line 8123
typedef enum _CM_SERVICE_NODE_TYPE ;

#line 8132
typedef enum _CM_SERVICE_LOAD_TYPE ;

#line 8140
typedef enum _CM_ERROR_CONTROL_TYPE ;

#line 8172
typedef int ;

#line 8198
typedef enum _CM_SHARE_DISPOSITION ;

#line 8211
typedef PVOID ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST ;

#line 8443
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR ;

#line 8454
typedef struct _CM_RESOURCE_LIST ;

#line 8471
typedef struct _DEVICE_FLAGS ;

#line 8485
typedef struct _CM_COMPONENT_INFORMATION ;

#line 8503
typedef struct _CM_ROM_BLOCK ;

#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 8518 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_INT13_DRIVE_PARAMETER ;

#line 8532
typedef struct _CM_MCA_POS_DATA ;

#line 8544
typedef struct _EISA_MEMORY_TYPE ;

#line 8554
typedef struct _EISA_MEMORY_CONFIGURATION ;

#line 8567
typedef struct _EISA_IRQ_DESCRIPTOR ;

#line 8575
typedef struct _EISA_IRQ_CONFIGURATION ;

#line 8585
typedef struct _DMA_CONFIGURATION_BYTE0 ;

#line 8592
typedef struct _DMA_CONFIGURATION_BYTE1 ;

#line 8599
typedef struct _EISA_DMA_CONFIGURATION ;

#line 8609
typedef struct _EISA_PORT_DESCRIPTOR ;

#line 8616
typedef struct _EISA_PORT_CONFIGURATION ;

#line 8628
typedef struct _CM_EISA_SLOT_INFORMATION ;

#line 8644
typedef struct _CM_EISA_FUNCTION_INFORMATION ;

#line 8678
typedef struct _CM_PNP_BIOS_DEVICE_NODE ;

#line 8692
typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8761 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_SCSI_DEVICE_DATA ;

#line 8775
typedef struct _CM_VIDEO_DEVICE_DATA ;

#line 8785
typedef struct _CM_SONIC_DEVICE_DATA ;

#line 8796
typedef struct _CM_SERIAL_DEVICE_DATA ;

#line 8810
typedef struct _CM_MONITOR_DEVICE_DATA ;

#line 8844
typedef struct _CM_FLOPPY_DEVICE_DATA ;

#line 8881
typedef struct _CM_KEYBOARD_DEVICE_DATA ;

#line 8893
typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA ;

#line 8905
typedef struct _CM_PCCARD_DEVICE_DATA ;

#line 8944
typedef struct _IO_RESOURCE_DESCRIPTOR ;

#line 9027
typedef struct _IO_RESOURCE_LIST ;

#line 9036
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST ;

#line 9065
typedef struct _EXCEPTION_RECORD ;

#line 9074
typedef EXCEPTION_RECORD ;

typedef struct _EXCEPTION_RECORD32 ;

#line 9085
typedef struct _EXCEPTION_RECORD64 ;

#line 9099
typedef struct _EXCEPTION_POINTERS ;

#line 9111
typedef enum _CONFIGURATION_TYPE ;

#line 9161
typedef enum _KINTERRUPT_MODE ;

#line 9170
typedef enum _KWAIT_REASON ;

#line 9207
typedef struct _DISPATCHER_HEADER ;

#line 9217
typedef struct _KWAIT_BLOCK ;

#line 9230
typedef void ;

#line 9244
typedef struct _KDEVICE_QUEUE ;

#line 9252
typedef struct _KDEVICE_QUEUE_ENTRY ;

#line 9263
typedef struct _KEVENT ;

#line 9271
typedef BOOLEAN ;

#line 9281
typedef struct _KMUTANT ;

#line 9294
typedef struct _KSEMAPHORE ;

#line 9304
typedef struct _KTIMER ;

#line 9899
typedef enum _KBUGCHECK_BUFFER_DUMP_STATE ;

#line 9907
typedef void ;

#line 9914
typedef struct _KBUGCHECK_CALLBACK_RECORD ;

#line 10002
typedef void ;

#line 10020
typedef LOGICAL ;

#line 10037
typedef void ;

#line 10053
typedef enum _MEMORY_CACHING_TYPE_ORIG ;

#line 10057
typedef enum _MEMORY_CACHING_TYPE ;

#line 10087
typedef struct _DBGKD_DEBUG_DATA_HEADER64 ;

#line 10115
typedef enum _POOL_TYPE ;

#line 10195
typedef enum _EX_POOL_PRIORITY ;

#line 10247
typedef struct _FAST_MUTEX ;

#line 10574
typedef PVOID ;

#line 10582
typedef void ;

#line 10588
typedef struct _GENERAL_LOOKASIDE ;

#line 10619
typedef struct _NPAGED_LOOKASIDE_LIST ;

#line 10729
typedef struct _PAGED_LOOKASIDE_LIST ;

#line 10882
typedef enum _WORK_QUEUE_TYPE ;

#line 10889
typedef void ;

#line 10895
typedef struct _WORK_QUEUE_ITEM ;

#line 10926
typedef struct _ZONE_SEGMENT_HEADER ;

#line 10931
typedef struct _ZONE_HEADER ;

#line 11156
typedef ULONG_PTR ;

#line 11157
typedef ERESOURCE_THREAD ;

typedef struct _OWNER_ENTRY ;

#line 11168
typedef struct _ERESOURCE ;

#line 11197
typedef struct _RESOURCE_HASH_ENTRY ;

#line 11204
typedef struct _RESOURCE_PERFORMANCE_DATA ;

#line 11429
typedef struct _CALLBACK_OBJECT ;

typedef void ;

#line 11474
typedef GUID ;

#line 11862
typedef enum _MM_SYSTEM_SIZE ;

#line 11884
typedef enum _LOCK_OPERATION ;

#line 11970
typedef enum _MM_PAGE_PRIORITY ;

#line 11999
typedef struct _PHYSICAL_MEMORY_RANGE ;

#line 12385
typedef NTSTATUS ;

#line 12389
typedef NTSTATUS ;

#line 12399
struct _DRIVER_OBJECT ;

#line 12411
typedef enum _SECURITY_OPERATION_CODE ;

#line 12426
typedef struct _SECURITY_SUBJECT_CONTEXT ;

#line 12448
typedef struct _INITIAL_PRIVILEGE_SET ;

#line 12462
typedef struct _ACCESS_STATE ;

#line 12571
typedef void ;

#line 12585
typedef void ;

#line 12602
typedef struct _IMAGE_INFO ;

#line 12620
typedef void ;

#line 12859
typedef NTSTATUS ;

#line 12878
typedef enum _IO_QUERY_DEVICE_DATA_FORMAT ;

#line 12890
typedef enum _CREATE_FILE_TYPE ;

#line 12905
struct _DEVICE_DESCRIPTION ;

#line 12906
struct _DEVICE_OBJECT ;

#line 12907
struct _DMA_ADAPTER ;

#line 12908
struct _DRIVER_OBJECT ;

#line 12909
struct _DRIVE_LAYOUT_INFORMATION ;

#line 12910
struct _DISK_PARTITION ;

#line 12911
struct _FILE_OBJECT ;

#line 12912
struct _IRP ;

#line 12913
struct _SCSI_REQUEST_BLOCK ;

#line 12919
typedef void ;

#line 12932
typedef void ;

#line 12943
typedef NTSTATUS ;

#line 12955
typedef void ;

#line 12968
typedef void ;

#line 12979
typedef NTSTATUS ;

#line 12990
typedef void ;

#line 13001
typedef void ;

#line 13011
typedef NTSTATUS ;

#line 13025
typedef BOOLEAN ;

#line 13038
typedef BOOLEAN ;

#line 13051
typedef BOOLEAN ;

#line 13068
typedef BOOLEAN ;

#line 13078
typedef BOOLEAN ;

#line 13092
typedef BOOLEAN ;

#line 13106
typedef BOOLEAN ;

#line 13118
typedef BOOLEAN ;

#line 13127
typedef BOOLEAN ;

#line 13141
typedef BOOLEAN ;

#line 13161
typedef void ;

#line 13167
typedef void ;

#line 13179
typedef void ;

#line 13193
typedef BOOLEAN ;

#line 13207
typedef BOOLEAN ;

#line 13219
typedef BOOLEAN ;

#line 13227
typedef BOOLEAN ;

#line 13239
typedef BOOLEAN ;

#line 13253
typedef NTSTATUS ;

#line 13262
typedef NTSTATUS ;

#line 13275
typedef NTSTATUS ;

#line 13282
typedef NTSTATUS ;

#line 13289
typedef BOOLEAN ;

#line 13304
typedef BOOLEAN ;

#line 13319
typedef BOOLEAN ;

#line 13327
typedef BOOLEAN ;

#line 13336
typedef BOOLEAN ;

#line 13350
typedef struct _FAST_IO_DISPATCH ;

#line 13386
typedef enum _IO_ALLOCATION_ACTION ;

#line 13396
typedef IO_ALLOCATION_ACTION ;

#line 13410
typedef struct _IO_SECURITY_CONTEXT ;

#line 13434
typedef struct _VPB ;

#line 13482
typedef struct _ADAPTER_OBJECT ;

#line 13491
typedef struct _WAIT_CONTEXT_BLOCK ;

#line 13503
typedef struct _CONTROLLER_OBJECT ;

#line 13537
typedef struct _DEVICE_OBJECT ;

#line 13575
typedef struct _DEVICE_OBJECT ;

#line 13578
struct _DEVICE_OBJECT_POWER_EXTENSION ;

typedef struct _DEVOBJ_EXTENSION ;

#line 13608
typedef struct _DRIVER_EXTENSION ;

#line 13645
typedef struct _DRIVER_OBJECT ;

#line 13706
typedef struct _DRIVER_OBJECT ;

#line 13715
typedef struct _SECTION_OBJECT_POINTERS ;

#line 13720
typedef SECTION_OBJECT_POINTERS ;

#line 13726
typedef struct _IO_COMPLETION_CONTEXT ;

#line 13759
typedef struct _FILE_OBJECT ;

#line 13788
typedef struct _FILE_OBJECT ;

#line 13828
typedef struct _IRP ;

#line 14078
typedef NTSTATUS ;

#line 14163
typedef enum _DEVICE_RELATION_TYPE ;

#line 14171
typedef struct _DEVICE_RELATIONS ;

#line 14176
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE ;

#line 14185
typedef struct _INTERFACE ;

#line 14196
typedef struct _DEVICE_CAPABILITIES ;

#line 14229
typedef struct _POWER_SEQUENCE ;

#line 14235
typedef enum  {
	BusQueryDeviceID = 0,
	BusQueryHardwareIDs = 1,
	BusQueryCompatibleIDs = 2,
	BusQueryInstanceID = 3,
	BusQueryDeviceSerialNumber = 4
} ;

typedef ULONG ;

#line 14252
typedef enum  {
	DeviceTextDescription = 0,
	DeviceTextLocationInformation = 1
} ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 14615 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SHARE_ACCESS ;

#line 14635
typedef struct _CONFIGURATION_INFORMATION ;

#line 14848
typedef struct _BOOTDISK_INFORMATION ;

#line 15754
typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK ;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK ;

#line 15764
typedef struct _IO_REMOVE_LOCK_DBG_BLOCK ;

#line 15777
typedef struct _IO_REMOVE_LOCK ;

#line 16009
typedef struct _IO_WORKITEM ;

typedef void ;

#line 16100
typedef enum  {
	DevicePropertyDeviceDescription,
	DevicePropertyHardwareID,
	DevicePropertyCompatibleIDs,
	DevicePropertyBootConfiguration,
	DevicePropertyBootConfigurationTranslated,
	DevicePropertyClassName,
	DevicePropertyClassGuid,
	DevicePropertyDriverKeyName,
	DevicePropertyManufacturer,
	DevicePropertyFriendlyName,
	DevicePropertyLocationInformation,
	DevicePropertyPhysicalDeviceObjectName,
	DevicePropertyBusTypeGuid,
	DevicePropertyLegacyBusType,
	DevicePropertyBusNumber,
	DevicePropertyEnumeratorName,
	DevicePropertyAddress,
	DevicePropertyUINumber
} ;

typedef BOOLEAN ;

#line 16129
typedef struct _DMA_ADAPTER ;

#line 16135
typedef ULONG ;

#line 16148
typedef struct _PNP_BUS_INFORMATION ;

#line 16162
typedef struct _LEGACY_BUS_INFORMATION ;

#line 16168
typedef struct _BUS_INTERFACE_STANDARD ;

#line 16190
typedef BOOLEAN ;

#line 16194
typedef NTSTATUS ;

#line 16203
typedef NTSTATUS ;

#line 16206
typedef NTSTATUS ;

#line 16210
typedef NTSTATUS ;

#line 16214
typedef NTSTATUS ;

#line 16218
typedef void ;

#line 16222
typedef NTSTATUS ;

#line 16227
typedef void ;

#line 16231
typedef struct _ACPI_INTERFACE_STANDARD ;

#line 16255
typedef enum _ACPI_REG_TYPE ;

#line 16268
typedef USHORT ;

#line 16272
typedef void ;

#line 16278
typedef struct ACPI_REGS_INTERFACE_STANDARD ;

#line 16300
typedef struct  {
	PVOID LinkNode ;
	ULONG StaticVector ;
	UCHAR Flags ;
} ;

#line 16314
typedef NTSTATUS ;

#line 16329
typedef NTSTATUS ;

#line 16336
typedef void ;

#line 16343
typedef struct _INT_ROUTE_INTERFACE_STANDARD ;

#line 16366
typedef struct _IO_ASSIGNED_RESOURCES ;

#line 16490
typedef enum _IO_NOTIFICATION_EVENT_CATEGORY ;

#line 16504
typedef NTSTATUS ;

#line 16537
typedef void ;

#line 16573
typedef enum _ARBITER_ACTION ;

#line 16586
typedef struct _ARBITER_CONFLICT_INFO ;

#line 16608
typedef struct _ARBITER_PARAMETERS ;

#line 16719
typedef enum _ARBITER_REQUEST_SOURCE ;

#line 16731
typedef enum _ARBITER_RESULT ;

#line 16761
typedef struct _ARBITER_LIST_ENTRY ;

#line 16832
typedef NTSTATUS ;

#line 16853
typedef struct _ARBITER_INTERFACE ;

#line 16880
typedef enum _RESOURCE_TRANSLATION_DIRECTION ;

#line 16889
typedef NTSTATUS ;

#line 16901
typedef NTSTATUS ;

#line 16915
typedef struct _TRANSLATOR_INTERFACE ;

#line 16931
typedef NTSTATUS ;

#line 16945
typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE ;

#line 16959
typedef struct _PLUGPLAY_NOTIFICATION_HEADER ;

#line 16972
typedef struct _HWPROFILE_CHANGE_NOTIFICATION ;

#line 16986
typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION ;

#line 17006
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION ;

#line 17026
typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION ;

#line 17054
typedef struct _DEVICE_DESCRIPTION ;

#line 17086
typedef BOOLEAN ;

#line 17333
typedef void ;

#line 17339
typedef struct _DEVICE_CONTROL_CONTEXT ;

#line 17349
typedef PBUS_HANDLER ;

#line 17355
typedef void ;

#line 17365
typedef enum _HAL_QUERY_INFORMATION_CLASS ;

#line 17381
typedef enum _HAL_SET_INFORMATION_CLASS ;

#line 17388
typedef NTSTATUS ;

#line 17405
typedef NTSTATUS ;

#line 17420
typedef void ;

#line 17429
typedef void ;

#line 17438
typedef NTSTATUS ;

#line 17447
typedef NTSTATUS ;

#line 17456
typedef NTSTATUS ;

#line 17466
typedef NTSTATUS ;

#line 17475
typedef NTSTATUS ;

#line 17486
typedef struct _PM_DISPATCH_TABLE ;

#line 17492
typedef NTSTATUS ;

#line 17505
typedef struct _DMA_ADAPTER ;

#line 17520
typedef NTSTATUS ;

#line 17543
typedef BOOLEAN ;

#line 17553
typedef NTSTATUS ;

#line 17566
typedef void ;

#line 17572
typedef void ;

#line 17578
typedef BOOLEAN ;

#line 17588
typedef struct  {
	ULONG Version ;
	pHalQuerySystemInformation HalQuerySystemInformation ;
	pHalSetSystemInformation HalSetSystemInformation ;
	pHalQueryBusSlots HalQueryBusSlots ;
	ULONG Spare1 ;
	pHalExamineMBR HalExamineMBR ;
	pHalIoAssignDriveLetters HalIoAssignDriveLetters ;
	pHalIoReadPartitionTable HalIoReadPartitionTable ;
	pHalIoSetPartitionInformation HalIoSetPartitionInformation ;
	pHalIoWritePartitionTable HalIoWritePartitionTable ;
	pHalHandlerForBus HalReferenceHandlerForBus ;
	pHalReferenceBusHandler HalReferenceBusHandler ;
	pHalReferenceBusHandler HalDereferenceBusHandler ;
	pHalInitPnpDriver HalInitPnpDriver ;
	pHalInitPowerManagement HalInitPowerManagement ;
	pHalGetDmaAdapter HalGetDmaAdapter ;
	pHalGetInterruptTranslator HalGetInterruptTranslator ;
} ;

#line 17650
typedef struct _HAL_BUS_INFORMATION ;

#line 17658
typedef struct _HAL_PROFILE_SOURCE_INFORMATION ;

#line 17665
typedef struct _HAL_PROFILE_SOURCE_INTERVAL ;

#line 17671
typedef enum _HAL_DISPLAY_BIOS_INFORMATION ;

#line 17678
typedef struct _HAL_POWER_INFORMATION ;

#line 17683
typedef struct _HAL_PROCESSOR_SPEED_INFO ;

#line 17688
typedef struct _HAL_CALLBACKS ;

#line 17694
typedef struct _HAL_PROCESSOR_FEATURE ;

#line 17706
typedef union _MCI_ADDR ;

#line 17716
typedef enum  {
	HAL_MCE_RECORD,
	HAL_MCA_RECORD
} ;

#line 17726
typedef struct _MCA_EXCEPTION ;

#line 17752
typedef void ;

#line 17762
typedef struct _MCA_DRIVER_INFO ;

#line 17772
typedef struct _SCATTER_GATHER_ELEMENT ;

#line 17778

#pragma warning(disable:4200)
#line 17779
typedef struct _SCATTER_GATHER_LIST ;

#line 17784

#pragma warning(default:4200)
#line 17788
typedef struct _DMA_OPERATIONS ;

typedef struct _DMA_ADAPTER ;

#line 17797
typedef void ;

#line 17801
typedef PVOID ;

#line 17808
typedef void ;

#line 17816
typedef NTSTATUS ;

#line 17824
typedef BOOLEAN ;

#line 17833
typedef void ;

#line 17837
typedef void ;

#line 17843
typedef PHYSICAL_ADDRESS ;

#line 17852
typedef ULONG ;

#line 17856
typedef ULONG ;

#line 17860
typedef void ;

#line 17868
typedef NTSTATUS ;

#line 17880
typedef void ;

#line 17887
typedef struct _DMA_OPERATIONS ;

#line 18235
typedef void ;

#line 18321
typedef struct _OBJECT_HANDLE_INFORMATION ;

#line 18402
typedef struct _PCI_SLOT_NUMBER ;

#line 18418
typedef struct _PCI_COMMON_CONFIG ;

#line 18591
typedef struct _PCI_CAPABILITIES_HEADER ;

#line 18600
typedef struct _PCI_PMC ;

#line 18618
typedef struct _PCI_PMCSR ;

#line 18628
typedef struct _PCI_PMCSR_BSE ;

#line 18635
typedef struct _PCI_PM_CAPABILITY ;

#line 18679
typedef struct _PCI_AGP_CAPABILITY ;

#line 18720
typedef struct _PCI_MSI_CAPABILITY ;

#line 18946
typedef void ;

#line 18954
typedef void ;

#line 18963
typedef void ;

#line 18975
typedef struct _PCIBUSDATA ;

#line 18986
typedef ULONG ;

#line 18995
typedef void ;

#line 19000
typedef void ;

#line 19006
typedef struct _PCI_BUS_INTERFACE_STANDARD ;

#line 19028
typedef BOOLEAN ;

#line 19043
typedef struct _PCI_DEVICE_PRESENT_INTERFACE ;

#line 127 "C:/NTDDK/inc/ntddser.h"
typedef struct _SERIALPERF_STATS ;

#line 136
typedef struct _SERIALCONFIG ;

#line 154
typedef struct _SERIAL_LINE_CONTROL ;

#line 160
typedef struct _SERIAL_TIMEOUTS ;

#line 175
typedef struct _SERIAL_QUEUE_SIZE ;

#line 185
typedef struct _SERIAL_BAUD_RATE ;

#line 247
typedef struct _SERIAL_CHARS ;

#line 284
typedef struct _SERIAL_HANDFLOW ;

#line 340
typedef struct _SERIAL_BASIC_SETTINGS ;

#line 353
typedef struct _SERIAL_STATUS ;

#line 433
typedef struct _SERIAL_XOFF_COUNTER ;

#line 539
typedef struct _SERIAL_COMMPROP ;

#line 631
typedef struct _SERENUM_PORT_DESC ;

#line 652
typedef UCHAR ;

#line 658
typedef void ;

#line 665
typedef enum _SERENUM_PORTION ;

#line 671
typedef struct _SERENUM_PORT_PARAMETERS ;

#line 28 "C:/NTDDK/inc/ddk/wdm/wmilib.h"

#pragma once
#line 38
typedef struct  {
	LPCGUID Guid ;
	ULONG InstanceCount ;
	ULONG Flags ;
} ;

#line 45
typedef NTSTATUS ;

#line 101
typedef NTSTATUS ;

#line 162
typedef NTSTATUS ;

#line 206
typedef NTSTATUS ;

#line 253
typedef NTSTATUS ;

#line 306
typedef enum  {
	WmiEventControl,
	WmiDataBlockControl
} ;

#line 312
typedef NTSTATUS ;

#line 355
typedef struct _WMILIB_CONTEXT ;

#line 411
typedef enum  {
	IrpProcessed,
	IrpNotCompleted,
	IrpNotWmi,
	IrpForward
} ;

#line 13 "C:/NTDDK/inc/wmidata.h"
typedef struct _MSWmi_MofData ;

#line 51
typedef struct _MSWmi_ProviderInfo ;

#line 66
typedef struct _MSWmi_PnPDeviceId ;

#line 83
typedef struct _MSWmi_PnPInstanceNames ;

#line 105
typedef struct _MSSmBios_RawSMBiosTables ;

#line 147
typedef struct _MSPower_DeviceEnable ;

#line 165
typedef struct _MSPower_DeviceWakeEnable ;

#line 182
typedef struct _MSNdis_NetworkAddress ;

#line 199
typedef struct _MSNdis_NetworkShortAddress ;

#line 216
typedef struct _MSNdis_NetworkLinkSpeed ;

#line 239
typedef struct _MSNdis_EnumerateAdapter ;

#line 256
typedef struct _MSNdis_NotifyAdapterRemoval ;

#line 273
typedef struct _MSNdis_NotifyAdapterArrival ;

#line 291
typedef struct _MSNdis_NdisEnumerateVc ;

#line 307
typedef struct _MSNdis_NotifyVcRemoval ;

#line 323
typedef struct _MSNdis_NotifyVcArrival ;

#line 338
typedef struct _MSNdis_HardwareStatus ;

#line 356
typedef struct _MSNdis_MediaSupported ;

#line 378
typedef struct _MSNdis_MediaInUse ;

#line 400
typedef struct _MSNdis_MaximumLookahead ;

#line 418
typedef struct _MSNdis_MaximumFrameSize ;

#line 436
typedef struct _MSNdis_LinkSpeed ;

#line 454
typedef struct _MSNdis_TransmitBufferSpace ;

#line 472
typedef struct _MSNdis_ReceiveBufferSpace ;

#line 490
typedef struct _MSNdis_TransmitBlockSize ;

#line 508
typedef struct _MSNdis_ReceiveBlockSize ;

#line 526
typedef struct _MSNdis_VendorID ;

#line 544
typedef struct _MSNdis_VendorDescription ;

#line 561
typedef struct _MSNdis_CurrentPacketFilter ;

#line 579
typedef struct _MSNdis_CurrentLookahead ;

#line 597
typedef struct _MSNdis_DriverVersion ;

#line 615
typedef struct _MSNdis_MaximumTotalSize ;

#line 633
typedef struct _MSNdis_MacOptions ;

#line 651
typedef struct _MSNdis_MediaConnectStatus ;

#line 669
typedef struct _MSNdis_MaximumSendPackets ;

#line 687
typedef struct _MSNdis_VendorDriverVersion ;

#line 705
typedef struct _MSNdis_TransmitsOk ;

#line 723
typedef struct _MSNdis_ReceivesOk ;

#line 741
typedef struct _MSNdis_TransmitsError ;

#line 759
typedef struct _MSNdis_ReceiveError ;

#line 777
typedef struct _MSNdis_ReceiveNoBuffer ;

#line 795
typedef struct _MSNdis_CoHardwareStatus ;

#line 813
typedef struct _MSNdis_CoMediaSupported ;

#line 835
typedef struct _MSNdis_CoMediaInUse ;

#line 857
typedef struct _MSNdis_CoLinkSpeed ;

#line 875
typedef struct _MSNdis_CoVendorId ;

#line 893
typedef struct _MSNdis_CoVendorDescription ;

#line 910
typedef struct _MSNdis_CoDriverVersion ;

#line 928
typedef struct _MSNdis_CoMacOptions ;

#line 946
typedef struct _MSNdis_CoMediaConnectStatus ;

#line 964
typedef struct _MSNdis_CoVendorDriverVersion ;

#line 982
typedef struct _MSNdis_CoMinimumLinkSpeed ;

#line 1000
typedef struct _MSNdis_CoTransmitPdusOk ;

#line 1018
typedef struct _MSNdis_CoReceivePdusOk ;

#line 1036
typedef struct _MSNdis_CoTransmitPduErrors ;

#line 1054
typedef struct _MSNdis_CoReceivePduErrors ;

#line 1072
typedef struct _MSNdis_CoReceivePdusNoBuffer ;

#line 1090
typedef struct _MSNdis_AtmSupportedVcRates ;

#line 1113
typedef struct _MSNdis_AtmSupportedServiceCategory ;

#line 1131
typedef struct _MSNdis_AtmSupportedAalTypes ;

#line 1149
typedef struct _MSNdis_AtmHardwareCurrentAddress ;

#line 1167
typedef struct _MSNdis_AtmMaxActiveVcs ;

#line 1185
typedef struct _MSNdis_AtmMaxActiveVciBits ;

#line 1203
typedef struct _MSNdis_AtmMaxActiveVpiBits ;

#line 1221
typedef struct _MSNdis_AtmMaxAal0PacketSize ;

#line 1239
typedef struct _MSNdis_AtmMaxAal1PacketSize ;

#line 1257
typedef struct _MSNdis_AtmMaxAal34PacketSize ;

#line 1275
typedef struct _MSNdis_AtmMaxAal5PacketSize ;

#line 1293
typedef struct _MSNdis_AtmReceiveCellsOk ;

#line 1311
typedef struct _MSNdis_AtmTransmitCellsOk ;

#line 1329
typedef struct _MSNdis_AtmReceiveCellsDropped ;

#line 1347
typedef struct _MSNdis_EthernetPermanentAddress ;

#line 1365
typedef struct _MSNdis_EthernetCurrentAddress ;

#line 1383
typedef struct _MSNdis_EthernetMulticastList ;

#line 1405
typedef struct _MSNdis_EthernetMaximumMulticastListSize ;

#line 1423
typedef struct _MSNdis_EthernetMacOptions ;

#line 1441
typedef struct _MSNdis_EthernetReceiveErrorAlignment ;

#line 1459
typedef struct _MSNdis_EthernetOneTransmitCollision ;

#line 1477
typedef struct _MSNdis_EthernetMoreTransmitCollisions ;

#line 1495
typedef struct _MSNdis_TokenRingPermanentAddress ;

#line 1513
typedef struct _MSNdis_TokenRingCurrentAddress ;

#line 1531
typedef struct _MSNdis_TokenRingCurrentFunctional ;

#line 1549
typedef struct _MSNdis_TokenRingCurrentGroup ;

#line 1567
typedef struct _MSNdis_TokenRingLastOpenStatus ;

#line 1585
typedef struct _MSNdis_TokenRingCurrentRingStatus ;

#line 1603
typedef struct _MSNdis_TokenRingCurrentRingState ;

#line 1621
typedef struct _MSNdis_TokenRingLineErrors ;

#line 1639
typedef struct _MSNdis_TokenRingLostFrames ;

#line 1657
typedef struct _MSNdis_FddiLongPermanentAddress ;

#line 1675
typedef struct _MSNdis_FddiLongCurrentAddress ;

#line 1693
typedef struct _MSNdis_FddiLongMulticastList ;

#line 1715
typedef struct _MSNdis_FddiLongMaximumListSize ;

#line 1733
typedef struct _MSNdis_FddiShortPermanentAddress ;

#line 1751
typedef struct _MSNdis_FddiShortCurrentAddress ;

#line 1769
typedef struct _MSNdis_FddiShortMulticastList ;

#line 1791
typedef struct _MSNdis_FddiShortMaximumListSize ;

#line 1809
typedef struct _MSNdis_FddiAttachmentType ;

#line 1827
typedef struct _MSNdis_FddiUpstreamNodeLong ;

#line 1845
typedef struct _MSNdis_FddiDownstreamNodeLong ;

#line 1863
typedef struct _MSNdis_FddiFrameErrors ;

#line 1881
typedef struct _MSNdis_FddiFramesLost ;

#line 1899
typedef struct _MSNdis_FddiRingManagmentState ;

#line 1917
typedef struct _MSNdis_FddiLctFailures ;

#line 1935
typedef struct _MSNdis_FddiLemRejects ;

#line 1953
typedef struct _MSNdis_FddiLConnectionState ;

#line 1972
typedef struct _MSNdis_StatusResetStart ;

#line 1988
typedef struct _MSNdis_StatusResetEnd ;

#line 2004
typedef struct _MSNdis_StatusMediaConnect ;

#line 2020
typedef struct _MSNdis_StatusMediaDisconnect ;

#line 2035
typedef struct _MSNdis_StatusMediaSpecificIndication ;

#line 2057
typedef struct _MSNdis_StatusLinkSpeedChange ;

#line 2075
typedef struct _MSNdis_StatusProtocolBind ;

#line 2092
typedef struct _MSNdis_StatusProtocolUnbind ;

#line 2109
typedef struct _KEYBOARD_PORT_WMI_STD_DATA ;

#line 2152
typedef struct _POINTER_PORT_WMI_STD_DATA ;

#line 2205
typedef struct _MSMouse_ClassInformation ;

#line 2223
typedef struct _MSKeyboard_ClassInformation ;

#line 2241
typedef struct _MSAcpi_ThermalZoneTemperature ;

#line 2304
typedef struct _WMI_DISK_GEOMETRY ;

#line 2342
typedef struct _WMI_DISK_PERFORMANCE ;

#line 2415
typedef struct _MSDiskDriver_Performance ;

#line 2437
typedef struct _STORAGE_FAILURE_PREDICT_STATUS ;

#line 2460
typedef struct _STORAGE_FAILURE_PREDICT_DATA ;

#line 2483
typedef struct _STORAGE_FAILURE_PREDICT_EVENT ;

#line 2513
typedef struct _STORAGE_FAILURE_PREDICT_FUNCTION ;

#line 2528
typedef struct _MSIde_PortDeviceInfo ;

#line 2556
typedef struct _MSSerial_PortName ;

#line 2573
typedef struct _SERIAL_WMI_COMM_DATA ;

#line 2723
typedef struct _SERIAL_WMI_HW_DATA ;

#line 2770
typedef struct _SERIAL_WMI_PERF_DATA ;

#line 2813
typedef struct _SERIAL_WMI_COMMPROP ;

#line 2920
typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS ;

#line 2943
typedef struct _PARALLEL_WMI_LOG_INFO ;

#line 3041
typedef struct _REDBOOK_WMI_STD_DATA ;

#line 3094
typedef struct _REDBOOK_WMI_PERF_DATA ;

#line 3137
typedef struct _RegisteredGuids ;

#line 475 "serial.h"
typedef struct _CONFIG_DATA ;

#line 509
typedef struct _SERIAL_CISR_SW ;

#line 520
typedef struct _SERIAL_FIRMWARE_DATA ;

#line 576
typedef struct _SERIAL_DEVICE_STATE ;

#line 646
typedef struct _SERIAL_DEVICE_EXTENSION ;

#line 1808
typedef struct _SERIAL_MULTIPORT_DISPATCH ;

#line 2157
typedef enum _SERIAL_MEM_COMPARES ;

#line 2164
typedef struct _SERIAL_LIST_DATA ;

#line 2169
typedef struct _SERIAL_GLOBALS ;

#line 2180
typedef struct _SERIAL_USER_DATA ;

#line 2206
typedef struct _SERIAL_PTR_CTX ;

#line 20 "serialp.h"
typedef NTSTATUS ;

#line 26
typedef void ;

#line 835
typedef struct _SERIAL_UPDATE_CHAR ;

#line 846
typedef struct _SERIAL_IOCTL_SYNC ;

#line 29 "registry.c"

#pragma alloc_text(INIT, SerialGetConfigDefaults)

#pragma alloc_text(PAGESRP0, SerialGetRegistryKeyValue)
#line 32

#pragma alloc_text(PAGESRP0, SerialPutRegistryKeyValue)
#line 36
NTSTATUS SerialGetConfigDefaults(PSERIAL_FIRMWARE_DATA DriverDefaultsPtr ,
	PUNICODE_STRING RegistryPath )
{
	#line 69
	NTSTATUS Status = (NTSTATUS )0x00000000L;
	#line 75
	RTL_QUERY_REGISTRY_TABLE paramTable[8] ;
	#line 77
	PWCHAR path ;
	ULONG zero = 0;
	ULONG DbgDefault = 0;
	ULONG notThereDefault = 1234567;
	#line 82
	;
	#line 95
	path = ExAllocatePoolWithTag(PagedPool, RegistryPath->Length +
		sizeof(WCHAR ), 'XMOC');
	if(! path)
	{
		#line 98
		Status = (NTSTATUS )0xC000009AL;
		return Status;
	}
	#line 102
	memset(DriverDefaultsPtr, 0, sizeof(SERIAL_FIRMWARE_DATA ));
	memset(& paramTable[0], 0, sizeof(paramTable));
	memset(path, 0, RegistryPath->Length + sizeof(WCHAR ));
	memmove(path, RegistryPath->Buffer, RegistryPath->Length);
	#line 107
	(paramTable[0]).Flags = 0x00000020;
	(paramTable[0]).Name = "B\0r\0e\0a\0k\0O\0n\0E\0n\0t\0r\0y\0";
	(paramTable[0]).EntryContext = & DriverDefaultsPtr->ShouldBreakOnEntry;
	(paramTable[0]).DefaultType = 4;
	(paramTable[0]).DefaultData = & zero;
	(paramTable[0]).DefaultLength = sizeof(ULONG );
	#line 114
	(paramTable[1]).Flags = 0x00000020;
	(paramTable[1]).Name = "D\0e\0b\0u\0g\0L\0e\0v\0e\0l\0";
	(paramTable[1]).EntryContext = & DriverDefaultsPtr->DebugLevel;
	(paramTable[1]).DefaultType = 4;
	(paramTable[1]).DefaultData = & DbgDefault;
	(paramTable[1]).DefaultLength = sizeof(ULONG );
	#line 121
	(paramTable[2]).Flags = 0x00000020;
	(paramTable[2]).Name = "F\0o\0r\0c\0e\0F\0i\0f\0o\0E\0n\0a\0b\0l\0e\0";
	(paramTable[2]).EntryContext = &
		DriverDefaultsPtr->ForceFifoEnableDefault;
	#line 124
	(paramTable[2]).DefaultType = 4;
	(paramTable[2]).DefaultData = & notThereDefault;
	(paramTable[2]).DefaultLength = sizeof(ULONG );
	#line 128
	(paramTable[3]).Flags = 0x00000020;
	(paramTable[3]).Name = "R\0x\0F\0I\0F\0O\0";
	(paramTable[3]).EntryContext = & DriverDefaultsPtr->RxFIFODefault;
	(paramTable[3]).DefaultType = 4;
	(paramTable[3]).DefaultData = & notThereDefault;
	(paramTable[3]).DefaultLength = sizeof(ULONG );
	#line 135
	(paramTable[4]).Flags = 0x00000020;
	(paramTable[4]).Name = "T\0x\0F\0I\0F\0O\0";
	(paramTable[4]).EntryContext = & DriverDefaultsPtr->TxFIFODefault;
	(paramTable[4]).DefaultType = 4;
	(paramTable[4]).DefaultData = & notThereDefault;
	(paramTable[4]).DefaultLength = sizeof(ULONG );
	#line 142
	(paramTable[5]).Flags = 0x00000020;
	(paramTable[5]).Name = "P\0e\0r\0m\0i\0t\0S\0h\0a\0r\0e\0";
	(paramTable[5]).EntryContext = & DriverDefaultsPtr->PermitShareDefault;
	(paramTable[5]).DefaultType = 4;
	(paramTable[5]).DefaultData = & notThereDefault;
	(paramTable[5]).DefaultLength = sizeof(ULONG );
	#line 149
	(paramTable[6]).Flags = 0x00000020;
	(paramTable[6]).Name = "L\0o\0g\0F\0i\0f\0o\0";
	(paramTable[6]).EntryContext = & DriverDefaultsPtr->LogFifoDefault;
	(paramTable[6]).DefaultType = 4;
	(paramTable[6]).DefaultData = & notThereDefault;
	(paramTable[6]).DefaultLength = sizeof(ULONG );
	#line 156
	Status = RtlQueryRegistryValues(0 | 0x80000000, path, & paramTable[0],
		(void *  )0, (void *  )0);
	#line 162
	if(! ((NTSTATUS )Status >= 0))
	{
		#line 163
		DriverDefaultsPtr->ShouldBreakOnEntry = 0;
		DriverDefaultsPtr->DebugLevel = 0;
	}
	#line 173
	if(DriverDefaultsPtr->ForceFifoEnableDefault == notThereDefault)
	{
		DriverDefaultsPtr->ForceFifoEnableDefault = 1;
		RtlWriteRegistryValue(0, path,
			"F\0o\0r\0c\0e\0F\0i\0f\0o\0E\0n\0a\0b\0l\0e\0", 4, &
			DriverDefaultsPtr->ForceFifoEnableDefault, sizeof(ULONG
			));
	}
	#line 187
	if(DriverDefaultsPtr->RxFIFODefault == notThereDefault)
	{
		#line 188
		DriverDefaultsPtr->RxFIFODefault = 8;
		RtlWriteRegistryValue(0, path, "R\0x\0F\0I\0F\0O\0", 4, &
			DriverDefaultsPtr->RxFIFODefault, sizeof(ULONG ));
	}
	#line 199
	if(DriverDefaultsPtr->TxFIFODefault == notThereDefault)
	{
		DriverDefaultsPtr->TxFIFODefault = 14;
		RtlWriteRegistryValue(0, path, "T\0x\0F\0I\0F\0O\0", 4, &
			DriverDefaultsPtr->TxFIFODefault, sizeof(ULONG ));
	}
	#line 213
	if(DriverDefaultsPtr->PermitShareDefault == notThereDefault)
	{
		DriverDefaultsPtr->PermitShareDefault = 0;
		#line 220
		RtlWriteRegistryValue(0, path,
			"P\0e\0r\0m\0i\0t\0S\0h\0a\0r\0e\0", 4, &
			DriverDefaultsPtr->PermitShareDefault, sizeof(ULONG ));
	}
	#line 232
	if(DriverDefaultsPtr->LogFifoDefault == notThereDefault)
	{
		#line 240
		DriverDefaultsPtr->LogFifoDefault = 0;
		#line 242
		RtlWriteRegistryValue(0, path, "L\0o\0g\0F\0i\0f\0o\0", 4, &
			DriverDefaultsPtr->LogFifoDefault, sizeof(ULONG ));
		#line 251
		DriverDefaultsPtr->LogFifoDefault = 1;
	}
	#line 259
	if(path)
	{
		#line 260
		ExFreePool(path);
	}
	#line 266
	DriverDefaultsPtr->PermitSystemWideShare = 0;
	#line 268
	return Status;
}

#line 272
NTSTATUS SerialGetRegistryKeyValue(HANDLE Handle , PWCHAR KeyNameString , ULONG
	KeyNameStringLength , PVOID Data , ULONG DataLength )
{
	#line 305
	UNICODE_STRING keyName ;
	ULONG length ;
	PKEY_VALUE_FULL_INFORMATION fullInfo ;
	#line 309
	NTSTATUS ntStatus = (NTSTATUS )0xC000009AL;
	#line 311
	;
	#line 313
	do
	{
		#line 313
		;
	}
	while(0);
	RtlInitUnicodeString(& keyName, KeyNameString);
	#line 318
	length = sizeof(KEY_VALUE_FULL_INFORMATION ) + KeyNameStringLength +
		DataLength;
	fullInfo = ExAllocatePoolWithTag(PagedPool, length, 'XMOC');
	#line 322
	if(fullInfo)
	{
		#line 323
		ntStatus = ZwQueryValueKey(Handle, & keyName,
			KeyValueFullInformation, fullInfo, length, & length);
		#line 330
		if((NTSTATUS )ntStatus >= 0)
		{
			#line 335
			if(DataLength >= fullInfo->DataLength)
			{
				#line 338
				memcpy(Data, (PUCHAR )fullInfo +
					fullInfo->DataOffset,
					fullInfo->DataLength);
			}
		}
		#line 342
		ExFreePool(fullInfo);
	}
	#line 345
	return ntStatus;
}

#line 350
NTSTATUS SerialPutRegistryKeyValue(HANDLE Handle , PWCHAR PKeyNameString , ULONG
	KeyNameStringLength , ULONG Dtype , PVOID PData , ULONG DataLength )
{
	#line 381
	NTSTATUS status ;
	UNICODE_STRING keyname ;
	#line 384
	;
	#line 386
	do
	{
		#line 386
		;
	}
	while(0);
	#line 388
	RtlInitUnicodeString(& keyname, (void *  )0);
	keyname.MaximumLength = (USHORT )(KeyNameStringLength + sizeof(WCHAR ));
	keyname.Buffer = ExAllocatePoolWithTag(PagedPool, keyname.MaximumLength,
		'XMOC');
	if(keyname.Buffer == (void *  )0)
	{
		#line 393
		return (NTSTATUS )0xC000009AL;
	}
	#line 396
	RtlAppendUnicodeToString(& keyname, PKeyNameString);
	#line 398
	status = ZwSetValueKey(Handle, & keyname, 0, Dtype, PData, DataLength);
	#line 400
	ExFreePool(keyname.Buffer);
	#line 402
	return status;
}

#line 16 "C:/NTDDK/inc/stddef.h"

#pragma once
#line 77
typedef int ;

#line 86
typedef unsigned int ;

#line 95
typedef int ;

#line 105
typedef unsigned int ;

#line 112
typedef unsigned short ;

#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"

#pragma once
#line 32

#pragma pack(push, 8)
#line 72
typedef enum _EXCEPTION_DISPOSITION ;

#line 89
struct _EXCEPTION_RECORD ;

#line 90
struct _CONTEXT ;

#line 155

#pragma pack(pop)
#line 25 "C:/NTDDK/inc/ntdef.h"

#pragma once
#line 15 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"

#pragma once
#line 66
typedef wchar_t ;

#line 67
typedef wchar_t ;

#line 127 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long ;

#line 25 "C:/NTDDK/inc/basetsd.h"

#pragma once
#line 36
typedef int ;

#line 37
typedef int ;

#line 43
typedef unsigned int ;

#line 44
typedef unsigned int ;

#line 45
typedef unsigned int ;

#line 84
typedef int ;

#line 85
typedef unsigned int ;

typedef long ;

#line 88
typedef unsigned long ;

#line 248
typedef unsigned short ;

#line 249
typedef short ;

#line 250
typedef unsigned long ;

#line 288
typedef ULONG_PTR ;

#line 289
typedef LONG_PTR ;

#line 295
typedef ULONG_PTR ;

#line 301
typedef __int64 ;

#line 302
typedef __int64 ;

#line 309
typedef unsigned __int64 ;

#line 310
typedef unsigned __int64 ;

#line 311
typedef unsigned __int64 ;

#line 217 "C:/NTDDK/inc/ntdef.h"
typedef void ;

#line 218
typedef void ;

#line 266
typedef char ;

#line 267
typedef short ;

#line 268
typedef long ;

#line 276
typedef wchar_t ;

#line 282
typedef WCHAR ;

#line 283
typedef WCHAR ;

#line 284
typedef const WCHAR ;

#line 285
typedef WCHAR ;

#line 286
typedef WCHAR ;

typedef const WCHAR ;

#line 293
typedef CHAR ;

#line 294
typedef CHAR ;

typedef const CHAR ;

#line 297
typedef CHAR ;

#line 298
typedef CHAR ;

#line 299
typedef const CHAR ;

#line 321
typedef char ;

#line 322
typedef unsigned char ;

#line 326
typedef LPSTR ;

#line 327
typedef LPSTR ;

#line 328
typedef LPCSTR ;

#line 337
typedef double ;

typedef struct _QUAD ;

#line 349
typedef SHORT ;

#line 350
typedef LONG ;

#line 351
typedef QUAD ;

#line 360
typedef unsigned char ;

#line 361
typedef unsigned short ;

#line 362
typedef unsigned long ;

#line 363
typedef QUAD ;

#line 369
typedef UCHAR ;

#line 370
typedef USHORT ;

#line 371
typedef ULONG ;

#line 372
typedef UQUAD ;

#line 378
typedef signed char ;

#line 379
typedef SCHAR ;

#line 394
typedef void ;

#line 400
typedef HANDLE ;

#line 406
typedef UCHAR ;

#line 407
typedef USHORT ;

#line 408
typedef ULONG ;

#line 414
typedef LONG ;

#line 478
typedef char ;

#line 479
typedef short ;

#line 480
typedef ULONG ;

typedef CCHAR ;

#line 483
typedef CSHORT ;

#line 484
typedef CLONG ;

#line 492
typedef ULONG ;

#line 493
typedef PULONG ;

#line 494
typedef USHORT ;

#line 500
typedef ULONG ;

#line 501
typedef ULONG ;

#line 508
typedef LONG ;

typedef NTSTATUS ;

#line 602
typedef struct _FLOAT128 ;

#line 607
typedef FLOAT128 ;

#line 621
typedef __int64 ;

#line 622
typedef unsigned __int64 ;

#line 639
typedef LONGLONG ;

#line 640
typedef ULONGLONG ;

#line 644
typedef LONGLONG ;

#line 649
typedef union _LARGE_INTEGER ;

#line 662
typedef LARGE_INTEGER ;

#line 668
typedef union _ULARGE_INTEGER ;

#line 681
typedef ULARGE_INTEGER ;

#line 690
typedef struct _LUID ;

#line 696
typedef ULONGLONG ;

#line 697
typedef DWORDLONG ;

#line 707
typedef LARGE_INTEGER ;

#line 831

#pragma warning(push)

#pragma warning(disable:4035)
__inline ULONGLONG __stdcall Int64ShllMod32___16(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 842
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    
		};
}

#line 845
__inline LONGLONG __stdcall Int64ShraMod32___16(LONGLONG Value , ULONG
	ShiftCount )
{
	#line 852
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    
		};
}

#line 855
__inline ULONGLONG __stdcall Int64ShrlMod32___16(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 862
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    
		};
}


#pragma warning(pop)
#line 956
typedef enum _EVENT_TYPE ;

#line 965
typedef enum _TIMER_TYPE ;

#line 974
typedef enum _WAIT_TYPE ;

#line 983
typedef CHAR ;

#line 984
typedef const char ;

#line 991
typedef struct _STRING ;

#line 999
typedef STRING ;

typedef STRING ;

#line 1002
typedef PSTRING ;

typedef STRING ;

#line 1005
typedef PSTRING ;

#line 1011
typedef struct _CSTRING ;

#line 1016
typedef CSTRING ;

#line 1019
typedef STRING ;

#line 1020
typedef PSTRING ;

#line 1027
typedef struct _UNICODE_STRING ;

#line 1036
typedef UNICODE_STRING ;

#line 1037
typedef const UNICODE_STRING ;

#line 1046
typedef UCHAR ;

#line 1047
typedef BOOLEAN ;

#line 1057
typedef struct _LIST_ENTRY ;

#line 1067
typedef struct _SINGLE_LIST_ENTRY ;

#line 1078
typedef struct LIST_ENTRY32 ;

#line 1082
typedef LIST_ENTRY32 ;

typedef struct LIST_ENTRY64 ;

#line 1088
typedef LIST_ENTRY64 ;

#line 1127
typedef struct _STRING32 ;

#line 1132
typedef STRING32 ;

typedef STRING32 ;

#line 1135
typedef UNICODE_STRING32 ;

typedef STRING32 ;

#line 1138
typedef ANSI_STRING32 ;

#line 1141
typedef struct _STRING64 ;

#line 1146
typedef STRING64 ;

typedef STRING64 ;

#line 1149
typedef UNICODE_STRING64 ;

typedef STRING64 ;

#line 1152
typedef ANSI_STRING64 ;

#line 1173
typedef struct _OBJECT_ATTRIBUTES ;

#line 1181
typedef OBJECT_ATTRIBUTES ;

#line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID ;

#line 70
typedef GUID ;

#line 75
typedef const GUID ;

#line 81
typedef GUID ;

#line 82
typedef IID ;

#line 85
typedef GUID ;

#line 86
typedef CLSID ;

#line 89
typedef GUID ;

#line 90
typedef FMTID ;

#line 16 "C:/NTDDK/inc/string.h"

#pragma once
#line 1233 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECTID ;

#line 1288
struct _CONTEXT ;

#line 1289
struct _EXCEPTION_RECORD ;

typedef EXCEPTION_DISPOSITION ;

#line 1306
typedef UCHAR ;

typedef KIRQL ;

#line 1316
typedef enum _NT_PRODUCT_TYPE ;

#line 1329
typedef enum _SUITE_TYPE ;

#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD ;

#line 76
typedef struct _ETHREAD ;

#line 77
typedef struct _EPROCESS ;

#line 78
typedef struct _PEB ;

#line 79
typedef struct _KINTERRUPT ;

#line 80
typedef struct _IO_TIMER ;

#line 81
typedef struct _OBJECT_TYPE ;

#line 82
typedef struct _CALLBACK_OBJECT ;

#line 83
typedef struct _DEVICE_HANDLER_OBJECT ;

#line 84
typedef struct _BUS_HANDLER ;

#line 143
typedef union _SLIST_HEADER ;

#line 204
typedef CCHAR ;

typedef enum _MODE ;

#line 222
struct _KAPC ;

typedef void ;

#line 232
typedef void ;

#line 242
typedef void ;

#line 248
typedef BOOLEAN ;

#line 254
typedef BOOLEAN ;

#line 265
typedef struct _KAPC ;

#line 292
struct _KDPC ;

typedef void ;

#line 351
typedef enum _KDPC_IMPORTANCE ;

#line 361
typedef struct _KDPC ;

#line 377
typedef PVOID ;

typedef void ;

#line 392
typedef struct _KIPI_COUNTS ;

#line 443
typedef struct _MDL ;

#line 532
typedef PVOID ;

#line 538
typedef PVOID ;

#line 544
typedef PVOID ;

typedef ULONG ;

#line 547
typedef ACCESS_MASK ;

#line 597
typedef struct _GENERIC_MAPPING ;

#line 603
typedef GENERIC_MAPPING ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES ;

#line 622
typedef LUID_AND_ATTRIBUTES ;

#line 623
typedef LUID_AND_ATTRIBUTES_ARRAY ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 642 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACL ;

#line 649
typedef ACL ;

#line 681
typedef struct _PRIVILEGE_SET ;

#line 735
typedef enum _SECURITY_IMPERSONATION_LEVEL ;

#line 753
typedef BOOLEAN ;

#line 762
typedef struct _SECURITY_QUALITY_OF_SERVICE ;

#line 774
typedef struct _SE_IMPERSONATION_STATE ;

#line 782
typedef ULONG ;

#line 809
typedef ULONG ;

#line 810
typedef KAFFINITY ;

#line 816
typedef LONG ;

#line 824
typedef ULONG_PTR ;

#line 825
typedef KSPIN_LOCK ;

#line 833
typedef void ;

#line 842
typedef enum _KPROFILE_SOURCE ;

#line 1079
typedef NTSTATUS ;

#line 1088
typedef struct _RTL_QUERY_REGISTRY_TABLE ;

#line 1952

#pragma warning(push)

#pragma warning(disable:4035)
#line 2019

#pragma warning(pop)
#line 2214
typedef struct _TIME_FIELDS ;

#line 2224
typedef TIME_FIELDS ;

#line 2499
typedef struct _RTL_BITMAP ;

#line 2503
typedef RTL_BITMAP ;

#line 2627
typedef struct _RTL_BITMAP_RUN ;

#line 2633
typedef RTL_BITMAP_RUN ;

#line 2886
typedef struct _RTL_RANGE ;

#line 2924
typedef struct _RTL_RANGE_LIST ;

#line 2950
typedef struct _RANGE_LIST_ITERATOR ;

#line 3019
typedef BOOLEAN ;

#line 3155
typedef struct _OSVERSIONINFOA ;

#line 3164
typedef struct _OSVERSIONINFOW ;

#line 3177
typedef OSVERSIONINFOA ;

#line 3178
typedef POSVERSIONINFOA ;

#line 3179
typedef LPOSVERSIONINFOA ;

#line 3182
typedef struct _OSVERSIONINFOEXA ;

#line 3195
typedef struct _OSVERSIONINFOEXW ;

#line 3213
typedef OSVERSIONINFOEXA ;

#line 3214
typedef POSVERSIONINFOEXA ;

#line 3215
typedef LPOSVERSIONINFOEXA ;

#line 3648
typedef struct _IO_STATUS_BLOCK ;

#line 3669
typedef void ;

#line 3685
typedef enum _FILE_INFORMATION_CLASS ;

#line 3731
typedef struct _FILE_BASIC_INFORMATION ;

#line 3739
typedef struct _FILE_STANDARD_INFORMATION ;

#line 3747
typedef struct _FILE_POSITION_INFORMATION ;

#line 3751
typedef struct _FILE_ALIGNMENT_INFORMATION ;

#line 3755
typedef struct _FILE_NAME_INFORMATION ;

#line 3760
typedef struct _FILE_NETWORK_OPEN_INFORMATION ;

#line 3770
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION ;

#line 3775
typedef struct _FILE_DISPOSITION_INFORMATION ;

#line 3779
typedef struct _FILE_END_OF_FILE_INFORMATION ;

#line 3784
typedef struct _FILE_FULL_EA_INFORMATION ;

#line 3798
typedef enum _FSINFOCLASS ;

#line 3810
typedef struct _FILE_FS_DEVICE_INFORMATION ;

#line 3820
typedef union _FILE_SEGMENT_ELEMENT ;

#line 3829
typedef enum _INTERFACE_TYPE ;

#line 3854
typedef enum _DMA_WIDTH ;

#line 3865
typedef enum _DMA_SPEED ;

#line 3879
typedef void ;

#line 3880
typedef void ;

#line 3888
typedef enum _BUS_DATA_TYPE ;

#line 3910
typedef struct _IO_ERROR_LOG_PACKET ;

#line 3931
typedef struct _IO_ERROR_LOG_MESSAGE ;

#line 4074
typedef struct _KEY_BASIC_INFORMATION ;

#line 4081
typedef struct _KEY_NODE_INFORMATION ;

#line 4091
typedef struct _KEY_FULL_INFORMATION ;

#line 4106
typedef struct _KEY_NAME_INFORMATION ;

#line 4112
typedef enum _KEY_INFORMATION_CLASS ;

#line 4122
typedef struct _KEY_WRITE_TIME_INFORMATION ;

#line 4126
typedef enum _KEY_SET_INFORMATION_CLASS ;

#line 4134
typedef struct _KEY_VALUE_BASIC_INFORMATION ;

#line 4141
typedef struct _KEY_VALUE_FULL_INFORMATION ;

#line 4151
typedef struct _KEY_VALUE_PARTIAL_INFORMATION ;

#line 4158
typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ;

#line 4164
typedef struct _KEY_VALUE_ENTRY ;

#line 4171
typedef enum _KEY_VALUE_INFORMATION_CLASS ;

#line 4210
typedef struct _OBJECT_NAME_INFORMATION ;

#line 4221
typedef enum _SECTION_INHERIT ;

#line 4294
typedef struct _CLIENT_ID ;

#line 4298
typedef CLIENT_ID ;

#line 4315
typedef struct _NT_TIB ;

#line 4327
typedef NT_TIB ;

#line 4332
typedef enum _PROCESSINFOCLASS ;

#line 4366
typedef enum _THREADINFOCLASS ;

#line 4395
typedef struct _PROCESS_WS_WATCH_INFORMATION ;

#line 4405
typedef struct _PROCESS_BASIC_INFORMATION ;

#line 4413
typedef PROCESS_BASIC_INFORMATION ;

#line 4422
typedef struct _PROCESS_DEVICEMAP_INFORMATION ;

#line 4440
typedef struct _PROCESS_SESSION_INFORMATION ;

#line 4454
typedef struct _QUOTA_LIMITS ;

#line 4462
typedef QUOTA_LIMITS ;

#line 4472
typedef struct _IO_COUNTERS ;

#line 4480
typedef IO_COUNTERS ;

#line 4488
typedef struct _VM_COUNTERS ;

#line 4501
typedef VM_COUNTERS ;

#line 4508
typedef struct _POOLED_USAGE_AND_LIMITS ;

#line 4519
typedef POOLED_USAGE_AND_LIMITS ;

#line 4528
typedef struct _PROCESS_ACCESS_TOKEN ;

#line 4555
typedef struct _KERNEL_USER_TIMES ;

#line 4561
typedef KERNEL_USER_TIMES ;

#line 4587
typedef enum _SYSTEM_POWER_STATE ;

#line 4598
typedef enum  {
	PowerActionNone = 0,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
} ;

typedef enum _DEVICE_POWER_STATE ;

#line 4618
typedef union _POWER_STATE ;

#line 4623
typedef enum _POWER_STATE_TYPE ;

#line 4654
typedef ULONG ;

typedef enum  {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
} ;

#line 4663
typedef enum  {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation
} ;

#line 4690
typedef ULONG ;

typedef LONG ;

#line 4693
typedef ULONG ;

#line 4719
typedef union _MCI_STATS ;

#line 4978
typedef struct _KPCR ;

#line 5006
typedef KPCR ;

#line 5012
typedef struct _KFLOATING_SAVE ;

#line 5153
typedef enum _INTERLOCKED_RESULT ;

#line 5252

#pragma warning(disable:4035)
#line 6994
typedef struct _KSYSTEM_TIME ;

#line 7014

#pragma warning(push)

#pragma warning(disable:4164)
#line 7019

#pragma function(_enable)
#line 7020

#pragma function(_disable)
#line 7024

#pragma warning(pop)
#line 7085
typedef struct _FLOATING_SAVE_AREA ;

#line 7097
typedef FLOATING_SAVE_AREA ;

#line 7109
typedef struct _CONTEXT ;

#line 7197
typedef CONTEXT ;

#line 7826
typedef void ;

#line 7850
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ;

#line 7899
typedef struct _KUSER_SHARED_DATA ;

#line 8123
typedef enum _CM_SERVICE_NODE_TYPE ;

#line 8132
typedef enum _CM_SERVICE_LOAD_TYPE ;

#line 8140
typedef enum _CM_ERROR_CONTROL_TYPE ;

#line 8172
typedef int ;

#line 8198
typedef enum _CM_SHARE_DISPOSITION ;

#line 8211
typedef PVOID ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST ;

#line 8443
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR ;

#line 8454
typedef struct _CM_RESOURCE_LIST ;

#line 8471
typedef struct _DEVICE_FLAGS ;

#line 8485
typedef struct _CM_COMPONENT_INFORMATION ;

#line 8503
typedef struct _CM_ROM_BLOCK ;

#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 8518 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_INT13_DRIVE_PARAMETER ;

#line 8532
typedef struct _CM_MCA_POS_DATA ;

#line 8544
typedef struct _EISA_MEMORY_TYPE ;

#line 8554
typedef struct _EISA_MEMORY_CONFIGURATION ;

#line 8567
typedef struct _EISA_IRQ_DESCRIPTOR ;

#line 8575
typedef struct _EISA_IRQ_CONFIGURATION ;

#line 8585
typedef struct _DMA_CONFIGURATION_BYTE0 ;

#line 8592
typedef struct _DMA_CONFIGURATION_BYTE1 ;

#line 8599
typedef struct _EISA_DMA_CONFIGURATION ;

#line 8609
typedef struct _EISA_PORT_DESCRIPTOR ;

#line 8616
typedef struct _EISA_PORT_CONFIGURATION ;

#line 8628
typedef struct _CM_EISA_SLOT_INFORMATION ;

#line 8644
typedef struct _CM_EISA_FUNCTION_INFORMATION ;

#line 8678
typedef struct _CM_PNP_BIOS_DEVICE_NODE ;

#line 8692
typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8761 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_SCSI_DEVICE_DATA ;

#line 8775
typedef struct _CM_VIDEO_DEVICE_DATA ;

#line 8785
typedef struct _CM_SONIC_DEVICE_DATA ;

#line 8796
typedef struct _CM_SERIAL_DEVICE_DATA ;

#line 8810
typedef struct _CM_MONITOR_DEVICE_DATA ;

#line 8844
typedef struct _CM_FLOPPY_DEVICE_DATA ;

#line 8881
typedef struct _CM_KEYBOARD_DEVICE_DATA ;

#line 8893
typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA ;

#line 8905
typedef struct _CM_PCCARD_DEVICE_DATA ;

#line 8944
typedef struct _IO_RESOURCE_DESCRIPTOR ;

#line 9027
typedef struct _IO_RESOURCE_LIST ;

#line 9036
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST ;

#line 9065
typedef struct _EXCEPTION_RECORD ;

#line 9074
typedef EXCEPTION_RECORD ;

typedef struct _EXCEPTION_RECORD32 ;

#line 9085
typedef struct _EXCEPTION_RECORD64 ;

#line 9099
typedef struct _EXCEPTION_POINTERS ;

#line 9111
typedef enum _CONFIGURATION_TYPE ;

#line 9161
typedef enum _KINTERRUPT_MODE ;

#line 9170
typedef enum _KWAIT_REASON ;

#line 9207
typedef struct _DISPATCHER_HEADER ;

#line 9217
typedef struct _KWAIT_BLOCK ;

#line 9230
typedef void ;

#line 9244
typedef struct _KDEVICE_QUEUE ;

#line 9252
typedef struct _KDEVICE_QUEUE_ENTRY ;

#line 9263
typedef struct _KEVENT ;

#line 9271
typedef BOOLEAN ;

#line 9281
typedef struct _KMUTANT ;

#line 9294
typedef struct _KSEMAPHORE ;

#line 9304
typedef struct _KTIMER ;

#line 9899
typedef enum _KBUGCHECK_BUFFER_DUMP_STATE ;

#line 9907
typedef void ;

#line 9914
typedef struct _KBUGCHECK_CALLBACK_RECORD ;

#line 10002
typedef void ;

#line 10020
typedef LOGICAL ;

#line 10037
typedef void ;

#line 10053
typedef enum _MEMORY_CACHING_TYPE_ORIG ;

#line 10057
typedef enum _MEMORY_CACHING_TYPE ;

#line 10087
typedef struct _DBGKD_DEBUG_DATA_HEADER64 ;

#line 10115
typedef enum _POOL_TYPE ;

#line 10195
typedef enum _EX_POOL_PRIORITY ;

#line 10247
typedef struct _FAST_MUTEX ;

#line 10574
typedef PVOID ;

#line 10582
typedef void ;

#line 10588
typedef struct _GENERAL_LOOKASIDE ;

#line 10619
typedef struct _NPAGED_LOOKASIDE_LIST ;

#line 10729
typedef struct _PAGED_LOOKASIDE_LIST ;

#line 10882
typedef enum _WORK_QUEUE_TYPE ;

#line 10889
typedef void ;

#line 10895
typedef struct _WORK_QUEUE_ITEM ;

#line 10926
typedef struct _ZONE_SEGMENT_HEADER ;

#line 10931
typedef struct _ZONE_HEADER ;

#line 11156
typedef ULONG_PTR ;

#line 11157
typedef ERESOURCE_THREAD ;

typedef struct _OWNER_ENTRY ;

#line 11168
typedef struct _ERESOURCE ;

#line 11197
typedef struct _RESOURCE_HASH_ENTRY ;

#line 11204
typedef struct _RESOURCE_PERFORMANCE_DATA ;

#line 11429
typedef struct _CALLBACK_OBJECT ;

typedef void ;

#line 11474
typedef GUID ;

#line 11862
typedef enum _MM_SYSTEM_SIZE ;

#line 11884
typedef enum _LOCK_OPERATION ;

#line 11970
typedef enum _MM_PAGE_PRIORITY ;

#line 11999
typedef struct _PHYSICAL_MEMORY_RANGE ;

#line 12385
typedef NTSTATUS ;

#line 12389
typedef NTSTATUS ;

#line 12399
struct _DRIVER_OBJECT ;

#line 12411
typedef enum _SECURITY_OPERATION_CODE ;

#line 12426
typedef struct _SECURITY_SUBJECT_CONTEXT ;

#line 12448
typedef struct _INITIAL_PRIVILEGE_SET ;

#line 12462
typedef struct _ACCESS_STATE ;

#line 12571
typedef void ;

#line 12585
typedef void ;

#line 12602
typedef struct _IMAGE_INFO ;

#line 12620
typedef void ;

#line 12859
typedef NTSTATUS ;

#line 12878
typedef enum _IO_QUERY_DEVICE_DATA_FORMAT ;

#line 12890
typedef enum _CREATE_FILE_TYPE ;

#line 12905
struct _DEVICE_DESCRIPTION ;

#line 12906
struct _DEVICE_OBJECT ;

#line 12907
struct _DMA_ADAPTER ;

#line 12908
struct _DRIVER_OBJECT ;

#line 12909
struct _DRIVE_LAYOUT_INFORMATION ;

#line 12910
struct _DISK_PARTITION ;

#line 12911
struct _FILE_OBJECT ;

#line 12912
struct _IRP ;

#line 12913
struct _SCSI_REQUEST_BLOCK ;

#line 12919
typedef void ;

#line 12932
typedef void ;

#line 12943
typedef NTSTATUS ;

#line 12955
typedef void ;

#line 12968
typedef void ;

#line 12979
typedef NTSTATUS ;

#line 12990
typedef void ;

#line 13001
typedef void ;

#line 13011
typedef NTSTATUS ;

#line 13025
typedef BOOLEAN ;

#line 13038
typedef BOOLEAN ;

#line 13051
typedef BOOLEAN ;

#line 13068
typedef BOOLEAN ;

#line 13078
typedef BOOLEAN ;

#line 13092
typedef BOOLEAN ;

#line 13106
typedef BOOLEAN ;

#line 13118
typedef BOOLEAN ;

#line 13127
typedef BOOLEAN ;

#line 13141
typedef BOOLEAN ;

#line 13161
typedef void ;

#line 13167
typedef void ;

#line 13179
typedef void ;

#line 13193
typedef BOOLEAN ;

#line 13207
typedef BOOLEAN ;

#line 13219
typedef BOOLEAN ;

#line 13227
typedef BOOLEAN ;

#line 13239
typedef BOOLEAN ;

#line 13253
typedef NTSTATUS ;

#line 13262
typedef NTSTATUS ;

#line 13275
typedef NTSTATUS ;

#line 13282
typedef NTSTATUS ;

#line 13289
typedef BOOLEAN ;

#line 13304
typedef BOOLEAN ;

#line 13319
typedef BOOLEAN ;

#line 13327
typedef BOOLEAN ;

#line 13336
typedef BOOLEAN ;

#line 13350
typedef struct _FAST_IO_DISPATCH ;

#line 13386
typedef enum _IO_ALLOCATION_ACTION ;

#line 13396
typedef IO_ALLOCATION_ACTION ;

#line 13410
typedef struct _IO_SECURITY_CONTEXT ;

#line 13434
typedef struct _VPB ;

#line 13482
typedef struct _ADAPTER_OBJECT ;

#line 13491
typedef struct _WAIT_CONTEXT_BLOCK ;

#line 13503
typedef struct _CONTROLLER_OBJECT ;

#line 13537
typedef struct _DEVICE_OBJECT ;

#line 13575
typedef struct _DEVICE_OBJECT ;

#line 13578
struct _DEVICE_OBJECT_POWER_EXTENSION ;

typedef struct _DEVOBJ_EXTENSION ;

#line 13608
typedef struct _DRIVER_EXTENSION ;

#line 13645
typedef struct _DRIVER_OBJECT ;

#line 13706
typedef struct _DRIVER_OBJECT ;

#line 13715
typedef struct _SECTION_OBJECT_POINTERS ;

#line 13720
typedef SECTION_OBJECT_POINTERS ;

#line 13726
typedef struct _IO_COMPLETION_CONTEXT ;

#line 13759
typedef struct _FILE_OBJECT ;

#line 13788
typedef struct _FILE_OBJECT ;

#line 13828
typedef struct _IRP ;

#line 14078
typedef NTSTATUS ;

#line 14163
typedef enum _DEVICE_RELATION_TYPE ;

#line 14171
typedef struct _DEVICE_RELATIONS ;

#line 14176
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE ;

#line 14185
typedef struct _INTERFACE ;

#line 14196
typedef struct _DEVICE_CAPABILITIES ;

#line 14229
typedef struct _POWER_SEQUENCE ;

#line 14235
typedef enum  {
	BusQueryDeviceID = 0,
	BusQueryHardwareIDs = 1,
	BusQueryCompatibleIDs = 2,
	BusQueryInstanceID = 3,
	BusQueryDeviceSerialNumber = 4
} ;

typedef ULONG ;

#line 14252
typedef enum  {
	DeviceTextDescription = 0,
	DeviceTextLocationInformation = 1
} ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 14615 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SHARE_ACCESS ;

#line 14635
typedef struct _CONFIGURATION_INFORMATION ;

#line 14848
typedef struct _BOOTDISK_INFORMATION ;

#line 15754
typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK ;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK ;

#line 15764
typedef struct _IO_REMOVE_LOCK_DBG_BLOCK ;

#line 15777
typedef struct _IO_REMOVE_LOCK ;

#line 16009
typedef struct _IO_WORKITEM ;

typedef void ;

#line 16100
typedef enum  {
	DevicePropertyDeviceDescription,
	DevicePropertyHardwareID,
	DevicePropertyCompatibleIDs,
	DevicePropertyBootConfiguration,
	DevicePropertyBootConfigurationTranslated,
	DevicePropertyClassName,
	DevicePropertyClassGuid,
	DevicePropertyDriverKeyName,
	DevicePropertyManufacturer,
	DevicePropertyFriendlyName,
	DevicePropertyLocationInformation,
	DevicePropertyPhysicalDeviceObjectName,
	DevicePropertyBusTypeGuid,
	DevicePropertyLegacyBusType,
	DevicePropertyBusNumber,
	DevicePropertyEnumeratorName,
	DevicePropertyAddress,
	DevicePropertyUINumber
} ;

typedef BOOLEAN ;

#line 16129
typedef struct _DMA_ADAPTER ;

#line 16135
typedef ULONG ;

#line 16148
typedef struct _PNP_BUS_INFORMATION ;

#line 16162
typedef struct _LEGACY_BUS_INFORMATION ;

#line 16168
typedef struct _BUS_INTERFACE_STANDARD ;

#line 16190
typedef BOOLEAN ;

#line 16194
typedef NTSTATUS ;

#line 16203
typedef NTSTATUS ;

#line 16206
typedef NTSTATUS ;

#line 16210
typedef NTSTATUS ;

#line 16214
typedef NTSTATUS ;

#line 16218
typedef void ;

#line 16222
typedef NTSTATUS ;

#line 16227
typedef void ;

#line 16231
typedef struct _ACPI_INTERFACE_STANDARD ;

#line 16255
typedef enum _ACPI_REG_TYPE ;

#line 16268
typedef USHORT ;

#line 16272
typedef void ;

#line 16278
typedef struct ACPI_REGS_INTERFACE_STANDARD ;

#line 16300
typedef struct  {
	PVOID LinkNode ;
	ULONG StaticVector ;
	UCHAR Flags ;
} ;

#line 16314
typedef NTSTATUS ;

#line 16329
typedef NTSTATUS ;

#line 16336
typedef void ;

#line 16343
typedef struct _INT_ROUTE_INTERFACE_STANDARD ;

#line 16366
typedef struct _IO_ASSIGNED_RESOURCES ;

#line 16490
typedef enum _IO_NOTIFICATION_EVENT_CATEGORY ;

#line 16504
typedef NTSTATUS ;

#line 16537
typedef void ;

#line 16573
typedef enum _ARBITER_ACTION ;

#line 16586
typedef struct _ARBITER_CONFLICT_INFO ;

#line 16608
typedef struct _ARBITER_PARAMETERS ;

#line 16719
typedef enum _ARBITER_REQUEST_SOURCE ;

#line 16731
typedef enum _ARBITER_RESULT ;

#line 16761
typedef struct _ARBITER_LIST_ENTRY ;

#line 16832
typedef NTSTATUS ;

#line 16853
typedef struct _ARBITER_INTERFACE ;

#line 16880
typedef enum _RESOURCE_TRANSLATION_DIRECTION ;

#line 16889
typedef NTSTATUS ;

#line 16901
typedef NTSTATUS ;

#line 16915
typedef struct _TRANSLATOR_INTERFACE ;

#line 16931
typedef NTSTATUS ;

#line 16945
typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE ;

#line 16959
typedef struct _PLUGPLAY_NOTIFICATION_HEADER ;

#line 16972
typedef struct _HWPROFILE_CHANGE_NOTIFICATION ;

#line 16986
typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION ;

#line 17006
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION ;

#line 17026
typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION ;

#line 17054
typedef struct _DEVICE_DESCRIPTION ;

#line 17086
typedef BOOLEAN ;

#line 17333
typedef void ;

#line 17339
typedef struct _DEVICE_CONTROL_CONTEXT ;

#line 17349
typedef PBUS_HANDLER ;

#line 17355
typedef void ;

#line 17365
typedef enum _HAL_QUERY_INFORMATION_CLASS ;

#line 17381
typedef enum _HAL_SET_INFORMATION_CLASS ;

#line 17388
typedef NTSTATUS ;

#line 17405
typedef NTSTATUS ;

#line 17420
typedef void ;

#line 17429
typedef void ;

#line 17438
typedef NTSTATUS ;

#line 17447
typedef NTSTATUS ;

#line 17456
typedef NTSTATUS ;

#line 17466
typedef NTSTATUS ;

#line 17475
typedef NTSTATUS ;

#line 17486
typedef struct _PM_DISPATCH_TABLE ;

#line 17492
typedef NTSTATUS ;

#line 17505
typedef struct _DMA_ADAPTER ;

#line 17520
typedef NTSTATUS ;

#line 17543
typedef BOOLEAN ;

#line 17553
typedef NTSTATUS ;

#line 17566
typedef void ;

#line 17572
typedef void ;

#line 17578
typedef BOOLEAN ;

#line 17588
typedef struct  {
	ULONG Version ;
	pHalQuerySystemInformation HalQuerySystemInformation ;
	pHalSetSystemInformation HalSetSystemInformation ;
	pHalQueryBusSlots HalQueryBusSlots ;
	ULONG Spare1 ;
	pHalExamineMBR HalExamineMBR ;
	pHalIoAssignDriveLetters HalIoAssignDriveLetters ;
	pHalIoReadPartitionTable HalIoReadPartitionTable ;
	pHalIoSetPartitionInformation HalIoSetPartitionInformation ;
	pHalIoWritePartitionTable HalIoWritePartitionTable ;
	pHalHandlerForBus HalReferenceHandlerForBus ;
	pHalReferenceBusHandler HalReferenceBusHandler ;
	pHalReferenceBusHandler HalDereferenceBusHandler ;
	pHalInitPnpDriver HalInitPnpDriver ;
	pHalInitPowerManagement HalInitPowerManagement ;
	pHalGetDmaAdapter HalGetDmaAdapter ;
	pHalGetInterruptTranslator HalGetInterruptTranslator ;
} ;

#line 17650
typedef struct _HAL_BUS_INFORMATION ;

#line 17658
typedef struct _HAL_PROFILE_SOURCE_INFORMATION ;

#line 17665
typedef struct _HAL_PROFILE_SOURCE_INTERVAL ;

#line 17671
typedef enum _HAL_DISPLAY_BIOS_INFORMATION ;

#line 17678
typedef struct _HAL_POWER_INFORMATION ;

#line 17683
typedef struct _HAL_PROCESSOR_SPEED_INFO ;

#line 17688
typedef struct _HAL_CALLBACKS ;

#line 17694
typedef struct _HAL_PROCESSOR_FEATURE ;

#line 17706
typedef union _MCI_ADDR ;

#line 17716
typedef enum  {
	HAL_MCE_RECORD,
	HAL_MCA_RECORD
} ;

#line 17726
typedef struct _MCA_EXCEPTION ;

#line 17752
typedef void ;

#line 17762
typedef struct _MCA_DRIVER_INFO ;

#line 17772
typedef struct _SCATTER_GATHER_ELEMENT ;

#line 17778

#pragma warning(disable:4200)
#line 17779
typedef struct _SCATTER_GATHER_LIST ;

#line 17784

#pragma warning(default:4200)
#line 17788
typedef struct _DMA_OPERATIONS ;

typedef struct _DMA_ADAPTER ;

#line 17797
typedef void ;

#line 17801
typedef PVOID ;

#line 17808
typedef void ;

#line 17816
typedef NTSTATUS ;

#line 17824
typedef BOOLEAN ;

#line 17833
typedef void ;

#line 17837
typedef void ;

#line 17843
typedef PHYSICAL_ADDRESS ;

#line 17852
typedef ULONG ;

#line 17856
typedef ULONG ;

#line 17860
typedef void ;

#line 17868
typedef NTSTATUS ;

#line 17880
typedef void ;

#line 17887
typedef struct _DMA_OPERATIONS ;

#line 18235
typedef void ;

#line 18321
typedef struct _OBJECT_HANDLE_INFORMATION ;

#line 18402
typedef struct _PCI_SLOT_NUMBER ;

#line 18418
typedef struct _PCI_COMMON_CONFIG ;

#line 18591
typedef struct _PCI_CAPABILITIES_HEADER ;

#line 18600
typedef struct _PCI_PMC ;

#line 18618
typedef struct _PCI_PMCSR ;

#line 18628
typedef struct _PCI_PMCSR_BSE ;

#line 18635
typedef struct _PCI_PM_CAPABILITY ;

#line 18679
typedef struct _PCI_AGP_CAPABILITY ;

#line 18720
typedef struct _PCI_MSI_CAPABILITY ;

#line 18946
typedef void ;

#line 18954
typedef void ;

#line 18963
typedef void ;

#line 18975
typedef struct _PCIBUSDATA ;

#line 18986
typedef ULONG ;

#line 18995
typedef void ;

#line 19000
typedef void ;

#line 19006
typedef struct _PCI_BUS_INTERFACE_STANDARD ;

#line 19028
typedef BOOLEAN ;

#line 19043
typedef struct _PCI_DEVICE_PRESENT_INTERFACE ;

#line 127 "C:/NTDDK/inc/ntddser.h"
typedef struct _SERIALPERF_STATS ;

#line 136
typedef struct _SERIALCONFIG ;

#line 154
typedef struct _SERIAL_LINE_CONTROL ;

#line 160
typedef struct _SERIAL_TIMEOUTS ;

#line 175
typedef struct _SERIAL_QUEUE_SIZE ;

#line 185
typedef struct _SERIAL_BAUD_RATE ;

#line 247
typedef struct _SERIAL_CHARS ;

#line 284
typedef struct _SERIAL_HANDFLOW ;

#line 340
typedef struct _SERIAL_BASIC_SETTINGS ;

#line 353
typedef struct _SERIAL_STATUS ;

#line 433
typedef struct _SERIAL_XOFF_COUNTER ;

#line 539
typedef struct _SERIAL_COMMPROP ;

#line 631
typedef struct _SERENUM_PORT_DESC ;

#line 652
typedef UCHAR ;

#line 658
typedef void ;

#line 665
typedef enum _SERENUM_PORTION ;

#line 671
typedef struct _SERENUM_PORT_PARAMETERS ;

#line 28 "C:/NTDDK/inc/ddk/wdm/wmilib.h"

#pragma once
#line 38
typedef struct  {
	LPCGUID Guid ;
	ULONG InstanceCount ;
	ULONG Flags ;
} ;

#line 45
typedef NTSTATUS ;

#line 101
typedef NTSTATUS ;

#line 162
typedef NTSTATUS ;

#line 206
typedef NTSTATUS ;

#line 253
typedef NTSTATUS ;

#line 306
typedef enum  {
	WmiEventControl,
	WmiDataBlockControl
} ;

#line 312
typedef NTSTATUS ;

#line 355
typedef struct _WMILIB_CONTEXT ;

#line 411
typedef enum  {
	IrpProcessed,
	IrpNotCompleted,
	IrpNotWmi,
	IrpForward
} ;

#line 13 "C:/NTDDK/inc/wmidata.h"
typedef struct _MSWmi_MofData ;

#line 51
typedef struct _MSWmi_ProviderInfo ;

#line 66
typedef struct _MSWmi_PnPDeviceId ;

#line 83
typedef struct _MSWmi_PnPInstanceNames ;

#line 105
typedef struct _MSSmBios_RawSMBiosTables ;

#line 147
typedef struct _MSPower_DeviceEnable ;

#line 165
typedef struct _MSPower_DeviceWakeEnable ;

#line 182
typedef struct _MSNdis_NetworkAddress ;

#line 199
typedef struct _MSNdis_NetworkShortAddress ;

#line 216
typedef struct _MSNdis_NetworkLinkSpeed ;

#line 239
typedef struct _MSNdis_EnumerateAdapter ;

#line 256
typedef struct _MSNdis_NotifyAdapterRemoval ;

#line 273
typedef struct _MSNdis_NotifyAdapterArrival ;

#line 291
typedef struct _MSNdis_NdisEnumerateVc ;

#line 307
typedef struct _MSNdis_NotifyVcRemoval ;

#line 323
typedef struct _MSNdis_NotifyVcArrival ;

#line 338
typedef struct _MSNdis_HardwareStatus ;

#line 356
typedef struct _MSNdis_MediaSupported ;

#line 378
typedef struct _MSNdis_MediaInUse ;

#line 400
typedef struct _MSNdis_MaximumLookahead ;

#line 418
typedef struct _MSNdis_MaximumFrameSize ;

#line 436
typedef struct _MSNdis_LinkSpeed ;

#line 454
typedef struct _MSNdis_TransmitBufferSpace ;

#line 472
typedef struct _MSNdis_ReceiveBufferSpace ;

#line 490
typedef struct _MSNdis_TransmitBlockSize ;

#line 508
typedef struct _MSNdis_ReceiveBlockSize ;

#line 526
typedef struct _MSNdis_VendorID ;

#line 544
typedef struct _MSNdis_VendorDescription ;

#line 561
typedef struct _MSNdis_CurrentPacketFilter ;

#line 579
typedef struct _MSNdis_CurrentLookahead ;

#line 597
typedef struct _MSNdis_DriverVersion ;

#line 615
typedef struct _MSNdis_MaximumTotalSize ;

#line 633
typedef struct _MSNdis_MacOptions ;

#line 651
typedef struct _MSNdis_MediaConnectStatus ;

#line 669
typedef struct _MSNdis_MaximumSendPackets ;

#line 687
typedef struct _MSNdis_VendorDriverVersion ;

#line 705
typedef struct _MSNdis_TransmitsOk ;

#line 723
typedef struct _MSNdis_ReceivesOk ;

#line 741
typedef struct _MSNdis_TransmitsError ;

#line 759
typedef struct _MSNdis_ReceiveError ;

#line 777
typedef struct _MSNdis_ReceiveNoBuffer ;

#line 795
typedef struct _MSNdis_CoHardwareStatus ;

#line 813
typedef struct _MSNdis_CoMediaSupported ;

#line 835
typedef struct _MSNdis_CoMediaInUse ;

#line 857
typedef struct _MSNdis_CoLinkSpeed ;

#line 875
typedef struct _MSNdis_CoVendorId ;

#line 893
typedef struct _MSNdis_CoVendorDescription ;

#line 910
typedef struct _MSNdis_CoDriverVersion ;

#line 928
typedef struct _MSNdis_CoMacOptions ;

#line 946
typedef struct _MSNdis_CoMediaConnectStatus ;

#line 964
typedef struct _MSNdis_CoVendorDriverVersion ;

#line 982
typedef struct _MSNdis_CoMinimumLinkSpeed ;

#line 1000
typedef struct _MSNdis_CoTransmitPdusOk ;

#line 1018
typedef struct _MSNdis_CoReceivePdusOk ;

#line 1036
typedef struct _MSNdis_CoTransmitPduErrors ;

#line 1054
typedef struct _MSNdis_CoReceivePduErrors ;

#line 1072
typedef struct _MSNdis_CoReceivePdusNoBuffer ;

#line 1090
typedef struct _MSNdis_AtmSupportedVcRates ;

#line 1113
typedef struct _MSNdis_AtmSupportedServiceCategory ;

#line 1131
typedef struct _MSNdis_AtmSupportedAalTypes ;

#line 1149
typedef struct _MSNdis_AtmHardwareCurrentAddress ;

#line 1167
typedef struct _MSNdis_AtmMaxActiveVcs ;

#line 1185
typedef struct _MSNdis_AtmMaxActiveVciBits ;

#line 1203
typedef struct _MSNdis_AtmMaxActiveVpiBits ;

#line 1221
typedef struct _MSNdis_AtmMaxAal0PacketSize ;

#line 1239
typedef struct _MSNdis_AtmMaxAal1PacketSize ;

#line 1257
typedef struct _MSNdis_AtmMaxAal34PacketSize ;

#line 1275
typedef struct _MSNdis_AtmMaxAal5PacketSize ;

#line 1293
typedef struct _MSNdis_AtmReceiveCellsOk ;

#line 1311
typedef struct _MSNdis_AtmTransmitCellsOk ;

#line 1329
typedef struct _MSNdis_AtmReceiveCellsDropped ;

#line 1347
typedef struct _MSNdis_EthernetPermanentAddress ;

#line 1365
typedef struct _MSNdis_EthernetCurrentAddress ;

#line 1383
typedef struct _MSNdis_EthernetMulticastList ;

#line 1405
typedef struct _MSNdis_EthernetMaximumMulticastListSize ;

#line 1423
typedef struct _MSNdis_EthernetMacOptions ;

#line 1441
typedef struct _MSNdis_EthernetReceiveErrorAlignment ;

#line 1459
typedef struct _MSNdis_EthernetOneTransmitCollision ;

#line 1477
typedef struct _MSNdis_EthernetMoreTransmitCollisions ;

#line 1495
typedef struct _MSNdis_TokenRingPermanentAddress ;

#line 1513
typedef struct _MSNdis_TokenRingCurrentAddress ;

#line 1531
typedef struct _MSNdis_TokenRingCurrentFunctional ;

#line 1549
typedef struct _MSNdis_TokenRingCurrentGroup ;

#line 1567
typedef struct _MSNdis_TokenRingLastOpenStatus ;

#line 1585
typedef struct _MSNdis_TokenRingCurrentRingStatus ;

#line 1603
typedef struct _MSNdis_TokenRingCurrentRingState ;

#line 1621
typedef struct _MSNdis_TokenRingLineErrors ;

#line 1639
typedef struct _MSNdis_TokenRingLostFrames ;

#line 1657
typedef struct _MSNdis_FddiLongPermanentAddress ;

#line 1675
typedef struct _MSNdis_FddiLongCurrentAddress ;

#line 1693
typedef struct _MSNdis_FddiLongMulticastList ;

#line 1715
typedef struct _MSNdis_FddiLongMaximumListSize ;

#line 1733
typedef struct _MSNdis_FddiShortPermanentAddress ;

#line 1751
typedef struct _MSNdis_FddiShortCurrentAddress ;

#line 1769
typedef struct _MSNdis_FddiShortMulticastList ;

#line 1791
typedef struct _MSNdis_FddiShortMaximumListSize ;

#line 1809
typedef struct _MSNdis_FddiAttachmentType ;

#line 1827
typedef struct _MSNdis_FddiUpstreamNodeLong ;

#line 1845
typedef struct _MSNdis_FddiDownstreamNodeLong ;

#line 1863
typedef struct _MSNdis_FddiFrameErrors ;

#line 1881
typedef struct _MSNdis_FddiFramesLost ;

#line 1899
typedef struct _MSNdis_FddiRingManagmentState ;

#line 1917
typedef struct _MSNdis_FddiLctFailures ;

#line 1935
typedef struct _MSNdis_FddiLemRejects ;

#line 1953
typedef struct _MSNdis_FddiLConnectionState ;

#line 1972
typedef struct _MSNdis_StatusResetStart ;

#line 1988
typedef struct _MSNdis_StatusResetEnd ;

#line 2004
typedef struct _MSNdis_StatusMediaConnect ;

#line 2020
typedef struct _MSNdis_StatusMediaDisconnect ;

#line 2035
typedef struct _MSNdis_StatusMediaSpecificIndication ;

#line 2057
typedef struct _MSNdis_StatusLinkSpeedChange ;

#line 2075
typedef struct _MSNdis_StatusProtocolBind ;

#line 2092
typedef struct _MSNdis_StatusProtocolUnbind ;

#line 2109
typedef struct _KEYBOARD_PORT_WMI_STD_DATA ;

#line 2152
typedef struct _POINTER_PORT_WMI_STD_DATA ;

#line 2205
typedef struct _MSMouse_ClassInformation ;

#line 2223
typedef struct _MSKeyboard_ClassInformation ;

#line 2241
typedef struct _MSAcpi_ThermalZoneTemperature ;

#line 2304
typedef struct _WMI_DISK_GEOMETRY ;

#line 2342
typedef struct _WMI_DISK_PERFORMANCE ;

#line 2415
typedef struct _MSDiskDriver_Performance ;

#line 2437
typedef struct _STORAGE_FAILURE_PREDICT_STATUS ;

#line 2460
typedef struct _STORAGE_FAILURE_PREDICT_DATA ;

#line 2483
typedef struct _STORAGE_FAILURE_PREDICT_EVENT ;

#line 2513
typedef struct _STORAGE_FAILURE_PREDICT_FUNCTION ;

#line 2528
typedef struct _MSIde_PortDeviceInfo ;

#line 2556
typedef struct _MSSerial_PortName ;

#line 2573
typedef struct _SERIAL_WMI_COMM_DATA ;

#line 2723
typedef struct _SERIAL_WMI_HW_DATA ;

#line 2770
typedef struct _SERIAL_WMI_PERF_DATA ;

#line 2813
typedef struct _SERIAL_WMI_COMMPROP ;

#line 2920
typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS ;

#line 2943
typedef struct _PARALLEL_WMI_LOG_INFO ;

#line 3041
typedef struct _REDBOOK_WMI_STD_DATA ;

#line 3094
typedef struct _REDBOOK_WMI_PERF_DATA ;

#line 3137
typedef struct _RegisteredGuids ;

#line 475 "serial.h"
typedef struct _CONFIG_DATA ;

#line 509
typedef struct _SERIAL_CISR_SW ;

#line 520
typedef struct _SERIAL_FIRMWARE_DATA ;

#line 576
typedef struct _SERIAL_DEVICE_STATE ;

#line 646
typedef struct _SERIAL_DEVICE_EXTENSION ;

#line 1808
typedef struct _SERIAL_MULTIPORT_DISPATCH ;

#line 2157
typedef enum _SERIAL_MEM_COMPARES ;

#line 2164
typedef struct _SERIAL_LIST_DATA ;

#line 2169
typedef struct _SERIAL_GLOBALS ;

#line 2180
typedef struct _SERIAL_USER_DATA ;

#line 2206
typedef struct _SERIAL_PTR_CTX ;

#line 20 "serialp.h"
typedef NTSTATUS ;

#line 26
typedef void ;

#line 835
typedef struct _SERIAL_UPDATE_CHAR ;

#line 846
typedef struct _SERIAL_IOCTL_SYNC ;

#line 27 "legacy.c"

#pragma alloc_text(INIT, SerialEnumerateLegacy)
#line 28

#pragma alloc_text(INIT, SerialMigrateLegacyRegistry)
#line 29

#pragma alloc_text(INIT, SerialBuildResourceList)
#line 30

#pragma alloc_text(INIT, SerialTranslateResourceList)
#line 31

#pragma alloc_text(INIT, SerialBuildRequirementsList)
#line 32

#pragma alloc_text(INIT, SerialIsUserDataValid)
#line 35
static const LARGE_INTEGER SerialPhysicalZero___2 = {0};

#line 39
NTSTATUS SerialTranslateResourceList(PDRIVER_OBJECT DriverObject ,
	PKEY_BASIC_INFORMATION UserSubKey , PCM_RESOURCE_LIST PTrResourceList ,
	PCM_RESOURCE_LIST PResourceList , ULONG PartialCount , PSERIAL_USER_DATA
	PUserData )
{
	#line 78
	KIRQL outIrql ;
	KAFFINITY outAffinity = (KAFFINITY )(- 1);
	ULONG outAddrSpace ;
	LARGE_INTEGER outPhysAddr ;
	NTSTATUS status = (NTSTATUS )0x00000000L;
	#line 84
	;
	#line 86
	do
	{
		#line 86
		;
	}
	while(0);
	#line 88
	outIrql = (KIRQL )(PUserData->UserLevel ? PUserData->UserLevel
		: PUserData->UserVector);
	#line 96
	memcpy(PTrResourceList, PResourceList, sizeof(CM_RESOURCE_LIST ) +
		sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR ) * 2);
	outAddrSpace =
		(((((PTrResourceList->List)[0]).PartialResourceList).PartialDescriptors)
		[0]).Flags;
	#line 100
	outPhysAddr =
		(((((((PTrResourceList->List)[0]).PartialResourceList).PartialDescriptors)
		[0]).u).Port).Start;
	#line 104
	if(HalTranslateBusAddress(PUserData->UserInterfaceType,
		PUserData->UserBusNumber, PUserData->UserPort, & outAddrSpace, &
		outPhysAddr) == 0)
	{
		SerialLogError(DriverObject, (void *  )0, PUserData->UserPort,
			SerialPhysicalZero___2, 0, 0, 0, 60, (NTSTATUS
			)0x00000000L, (NTSTATUS )0xC0060025L,
			UserSubKey->NameLength + sizeof(WCHAR ), &
			(UserSubKey->Name)[0], 0, (void *  )0);
		#line 127
		do
		{
			#line 127
			;
		}
		while(0);
		#line 129
		status = (NTSTATUS )0xC0000073L;
		goto SerialTranslateError;
	}
	#line 133
	(((((PTrResourceList->List)[0]).PartialResourceList).PartialDescriptors)
		[0]).Flags = (USHORT )outAddrSpace;
	(((((((PTrResourceList->List)[0]).PartialResourceList).PartialDescriptors
		)[0]).u).Port).Start = outPhysAddr;
	#line 138
	if(((((((((PTrResourceList->List)[0]).PartialResourceList).PartialDescriptors
		)[1]).u).Interrupt).Vector =
		HalGetInterruptVector(PUserData->UserInterfaceType,
		PUserData->UserBusNumber, PUserData->UserLevel
		? PUserData->UserLevel : PUserData->UserVector,
		PUserData->UserVector, & outIrql, & outAffinity)) == 0)
	{
		#line 147
		SerialLogError(DriverObject, (void *  )0, PUserData->UserPort,
			SerialPhysicalZero___2, 0, 0, 0, 61, (NTSTATUS
			)0x00000000L, (NTSTATUS )0xC0060026L,
			UserSubKey->NameLength + sizeof(WCHAR ), &
			(UserSubKey->Name)[0], 0, (void *  )0);
		status = (NTSTATUS )0xC0000073L;
		goto SerialTranslateError;
	}
	#line 156
	(((((((PTrResourceList->List)[0]).PartialResourceList).PartialDescriptors
		)[1]).u).Interrupt).Level = outIrql;
	#line 159
	(((((((PTrResourceList->List)[0]).PartialResourceList).PartialDescriptors
		)[1]).u).Interrupt).Affinity = outAffinity;
	#line 162
	outAddrSpace =
		(((((PTrResourceList->List)[0]).PartialResourceList).PartialDescriptors)
		[2]).Flags;
	#line 164
	outPhysAddr =
		(((((((PTrResourceList->List)[0]).PartialResourceList).PartialDescriptors)
		[2]).u).Port).Start;
	#line 168
	if(PartialCount == 3)
	{
		#line 169
		if(HalTranslateBusAddress(PUserData->UserInterfaceType,
			PUserData->UserBusNumber,
			PUserData->UserInterruptStatus, & outAddrSpace, &
			outPhysAddr) == 0)
		{
			SerialLogError(DriverObject, (void *  )0,
				PUserData->UserPort, SerialPhysicalZero___2, 0,
				0, 0, 62, (NTSTATUS )0x00000000L, (NTSTATUS
				)0xC0060027L, UserSubKey->NameLength +
				sizeof(WCHAR ), & (UserSubKey->Name)[0], 0,
				(void *  )0);
			#line 194
			do
			{
				#line 194
				;
			}
			while(0);
			#line 196
			status = (NTSTATUS )0xC0000073L;
			goto SerialTranslateError;
		}
		#line 200
		do
		{
			#line 200
			;
		}
		while(0);
		#line 202
		(((((PTrResourceList->List)[0]).PartialResourceList).PartialDescriptors
			)[2]).Flags = (USHORT )outAddrSpace;
		(((((((PTrResourceList->List)[0]).PartialResourceList).PartialDescriptors
			)[2]).u).Port).Start = outPhysAddr;
	}
	#line 208
	SerialTranslateError:
		#line 208
		;
	#line 210
	do
	{
		#line 210
		;
	}
	while(0);
	#line 212
	return status;
}

#line 216
NTSTATUS SerialBuildRequirementsList(PIO_RESOURCE_REQUIREMENTS_LIST
	PRequiredList , ULONG PartialCount , PSERIAL_USER_DATA PUserData )
{
	#line 249
	PIO_RESOURCE_LIST reqResList ;
	PIO_RESOURCE_DESCRIPTOR reqResDesc ;
	NTSTATUS status = (NTSTATUS )0x00000000L;
	#line 253
	;
	#line 255
	do
	{
		#line 255
		;
	}
	while(0);
	#line 262
	memset(PRequiredList, 0, sizeof(IO_RESOURCE_REQUIREMENTS_LIST ) +
		sizeof(IO_RESOURCE_DESCRIPTOR ) * 2);
	PRequiredList->ListSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST ) +
		sizeof(IO_RESOURCE_DESCRIPTOR ) * (PartialCount - 1);
	PRequiredList->InterfaceType = PUserData->UserInterfaceType;
	PRequiredList->BusNumber = PUserData->UserBusNumber;
	PRequiredList->SlotNumber = 0;
	PRequiredList->AlternativeLists = 1;
	#line 271
	reqResList = & (PRequiredList->List)[0];
	#line 273
	reqResList->Version = 1;
	reqResList->Revision = 1;
	reqResList->Count = PartialCount;
	#line 277
	reqResDesc = & (reqResList->Descriptors)[0];
	#line 284
	reqResDesc->Flags = (USHORT )PUserData->UserAddressSpace;
	reqResDesc->Type = 1;
	reqResDesc->ShareDisposition = CmResourceShareDriverExclusive;
	((reqResDesc->u).Port).Length = (ULONG )(7 * 1);
	((reqResDesc->u).Port).Alignment = 1;
	((reqResDesc->u).Port).MinimumAddress = PUserData->UserPort;
	(((reqResDesc->u).Port).MaximumAddress).QuadPart =
		(PUserData->UserPort).QuadPart + (ULONG )(7 * 1) - 1;
	#line 294
	reqResDesc++;
	#line 301
	if(PUserData->UserInterruptMode == Latched)
	{
		#line 302
		reqResDesc->Flags = 1;
	}
	else
	{
		#line 304
		reqResDesc->Flags = 0;
	}
	#line 313
	reqResDesc->ShareDisposition = CmResourceShareShared;
	#line 315
	reqResDesc->Type = 2;
	((reqResDesc->u).Interrupt).MinimumVector = PUserData->UserVector;
	((reqResDesc->u).Interrupt).MaximumVector = PUserData->UserVector;
	#line 322
	if(PartialCount == 3)
	{
		reqResDesc++;
		#line 326
		reqResDesc->Type = 1;
		#line 334
		reqResDesc->ShareDisposition = CmResourceShareShared;
		#line 336
		reqResDesc->Flags = (USHORT )PUserData->UserAddressSpace;
		((reqResDesc->u).Port).Length = 1;
		((reqResDesc->u).Port).Alignment = 1;
		((reqResDesc->u).Port).MinimumAddress =
			PUserData->UserInterruptStatus;
		#line 340
		((reqResDesc->u).Port).MaximumAddress =
			PUserData->UserInterruptStatus;
	}
	do
	{
		#line 343
		;
	}
	while(0);
	#line 345
	return status;
}

#line 350
NTSTATUS SerialBuildResourceList(PCM_RESOURCE_LIST PResourceList , PULONG
	PPartialCount , PSERIAL_USER_DATA PUserData )
{
	#line 381
	ULONG countOfPartials ;
	PCM_PARTIAL_RESOURCE_DESCRIPTOR pPartial ;
	NTSTATUS status = (NTSTATUS )0x00000000L;
	#line 385
	;
	#line 387
	do
	{
		#line 387
		;
	}
	while(0);
	#line 388
	do
	{
		#line 388
		;
	}
	while(0);
	#line 390
	* PPartialCount = 0;
	#line 396
	countOfPartials = (PUserData->UserInterruptStatus).LowPart != 0 ? 3 : 2;
	#line 400
	memset(PResourceList, 0, sizeof(CM_RESOURCE_LIST ) +
		sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR ) * 2);
	PResourceList->Count = 1;
	#line 404
	((PResourceList->List)[0]).InterfaceType = PUserData->UserInterfaceType;
	((PResourceList->List)[0]).BusNumber = PUserData->UserBusNumber;
	(((PResourceList->List)[0]).PartialResourceList).Count =
		countOfPartials;
	pPartial = &
		((((PResourceList->List)[0]).PartialResourceList).PartialDescriptors)
		[0];
	#line 416
	pPartial->Type = 1;
	pPartial->ShareDisposition = CmResourceShareDeviceExclusive;
	pPartial->Flags = (USHORT )PUserData->UserAddressSpace;
	((pPartial->u).Port).Start = PUserData->UserPort;
	((pPartial->u).Port).Length = (ULONG )(7 * 1);
	#line 423
	pPartial++;
	#line 430
	pPartial->Type = 2;
	#line 438
	pPartial->ShareDisposition = CmResourceShareShared;
	#line 440
	if(PUserData->UserInterruptMode == Latched)
	{
		#line 441
		pPartial->Flags = 1;
	}
	else
	{
		#line 443
		pPartial->Flags = 0;
	}
	#line 446
	((pPartial->u).Interrupt).Vector = PUserData->UserVector;
	#line 448
	if(PUserData->UserLevel == 0)
	{
		#line 449
		((pPartial->u).Interrupt).Level = PUserData->UserVector;
	}
	else
	{
		#line 451
		((pPartial->u).Interrupt).Level = PUserData->UserLevel;
	}
	#line 459
	if(countOfPartials == 3)
	{
		pPartial++;
		#line 463
		pPartial->Type = 1;
		#line 471
		pPartial->ShareDisposition = CmResourceShareShared;
		#line 473
		pPartial->Flags = (USHORT )PUserData->UserAddressSpace;
		((pPartial->u).Port).Start = PUserData->UserInterruptStatus;
		((pPartial->u).Port).Length = (ULONG )(1 * 1);
	}
	#line 478
	* PPartialCount = countOfPartials;
	#line 480
	do
	{
		#line 480
		;
	}
	while(0);
	#line 482
	return status;
}

#line 486
NTSTATUS SerialMigrateLegacyRegistry(PDEVICE_OBJECT PPdo , PSERIAL_USER_DATA
	PUserData , BOOLEAN IsMulti )
{
	#line 514
	NTSTATUS status ;
	HANDLE pnpKey ;
	UNICODE_STRING pnpNameBuf ;
	ULONG isMultiport = 1;
	ULONG one = 1;
	#line 520
	;
	#line 522
	do
	{
		#line 522
		;
	}
	while(0);
	#line 524
	status = IoOpenDeviceRegistryKey(PPdo, 1, 0x00020000L, & pnpKey);
	#line 527
	if(! ((NTSTATUS )status >= 0))
	{
		do
		{
			#line 529
			;
		}
		while(0);
		#line 530
		return status;
	}
	#line 537
	pnpNameBuf.MaximumLength = sizeof(WCHAR ) * 256;
	pnpNameBuf.Length = 0;
	pnpNameBuf.Buffer = ExAllocatePoolWithTag(PagedPool, sizeof(WCHAR ) *
		257, 'XMOC');
	if(pnpNameBuf.Buffer == (void *  )0)
	{
		#line 542
		SerialLogError(PPdo->DriverObject, (void *  )0,
			PUserData->UserPort, SerialPhysicalZero___2, 0, 0, 0,
			63, (NTSTATUS )0x00000000L, (NTSTATUS )0xC0060008L, 0,
			(void *  )0, 0, (void *  )0);
		#line 547
		do
		{
			#line 547
			;
		}
		while(0);
		#line 548
		status = (NTSTATUS )0xC000009AL;
		goto MigrateLegacyExit;
	}
	#line 553
	memset(pnpNameBuf.Buffer, 0, pnpNameBuf.MaximumLength + sizeof(WCHAR ));
	#line 560
	RtlAppendUnicodeStringToString(& pnpNameBuf, &
		PUserData->UserSymbolicLink);
	memset((PUCHAR )(& (pnpNameBuf.Buffer)[0]) + pnpNameBuf.Length, 0,
		sizeof(WCHAR ));
	status = SerialPutRegistryKeyValue(pnpKey, "P\0o\0r\0t\0N\0a\0m\0e\0",
		sizeof("P\0o\0r\0t\0N\0a\0m\0e\0"), 1, pnpNameBuf.Buffer,
		pnpNameBuf.Length + sizeof(WCHAR ));
	#line 568
	ExFreePool(pnpNameBuf.Buffer);
	#line 570
	if(! ((NTSTATUS )status >= 0))
	{
		#line 571
		do
		{
			#line 571
			;
		}
		while(0);
		#line 572
		goto MigrateLegacyExit;
	}
	#line 579
	if(IsMulti)
	{
		#line 580
		status = SerialPutRegistryKeyValue(pnpKey,
			"M\0u\0l\0t\0i\0p\0o\0r\0t\0D\0e\0v\0i\0c\0e\0",
			sizeof("M\0u\0l\0t\0i\0p\0o\0r\0t\0D\0e\0v\0i\0c\0e\0"),
			4, & isMultiport, sizeof(ULONG ));
		if(! ((NTSTATUS )status >= 0))
		{
			#line 585
			do
			{
				#line 585
				;
			}
			while(0);
			#line 586
			goto MigrateLegacyExit;
		}
	}
	#line 597
	if(PUserData->UserPortIndex != 0)
	{
		#line 598
		status = SerialPutRegistryKeyValue(pnpKey,
			"P\0o\0r\0t\0I\0n\0d\0e\0x\0",
			sizeof("P\0o\0r\0t\0I\0n\0d\0e\0x\0"), 4, &
			PUserData->UserPortIndex, sizeof(ULONG ));
		#line 603
		if(! ((NTSTATUS )status >= 0))
		{
			#line 604
			do
			{
				#line 604
				;
			}
			while(0);
			#line 605
			goto MigrateLegacyExit;
		}
	}
	#line 614
	if(PUserData->UserClockRate != (ULONG )(- 1))
	{
		#line 615
		status = SerialPutRegistryKeyValue(pnpKey,
			"C\0l\0o\0c\0k\0R\0a\0t\0e\0",
			sizeof("C\0l\0o\0c\0k\0R\0a\0t\0e\0"), 4, &
			PUserData->UserClockRate, sizeof(ULONG ));
		#line 620
		if(! ((NTSTATUS )status >= 0))
		{
			#line 621
			do
			{
				#line 621
				;
			}
			while(0);
			#line 622
			goto MigrateLegacyExit;
		}
	}
	#line 631
	if(PUserData->UserIndexed != (ULONG )(- 1))
	{
		#line 632
		status = SerialPutRegistryKeyValue(pnpKey,
			"I\0n\0d\0e\0x\0e\0d\0",
			sizeof("I\0n\0d\0e\0x\0e\0d\0"), 4, &
			PUserData->UserIndexed, sizeof(ULONG ));
		if(! ((NTSTATUS )status >= 0))
		{
			#line 637
			do
			{
				#line 637
				;
			}
			while(0);
			#line 638
			goto MigrateLegacyExit;
		}
	}
	#line 647
	if(PUserData->DisablePort != (ULONG )(- 1))
	{
		#line 648
		status = SerialPutRegistryKeyValue(pnpKey,
			"D\0i\0s\0a\0b\0l\0e\0P\0o\0r\0t\0",
			sizeof("D\0i\0s\0a\0b\0l\0e\0P\0o\0r\0t\0"), 4, &
			PUserData->DisablePort, sizeof(ULONG ));
		if(! ((NTSTATUS )status >= 0))
		{
			#line 653
			do
			{
				#line 653
				;
			}
			while(0);
			#line 654
			goto MigrateLegacyExit;
		}
	}
	#line 662
	if(PUserData->ForceFIFOEnable != (ULONG )(- 1))
	{
		#line 663
		status = SerialPutRegistryKeyValue(pnpKey,
			"F\0o\0r\0c\0e\0F\0i\0f\0o\0E\0n\0a\0b\0l\0e\0",
			sizeof("F\0o\0r\0c\0e\0F\0i\0f\0o\0E\0n\0a\0b\0l\0e\0"),
			4, & PUserData->ForceFIFOEnable, sizeof(ULONG ));
		#line 668
		if(! ((NTSTATUS )status >= 0))
		{
			#line 669
			do
			{
				#line 669
				;
			}
			while(0);
			#line 670
			goto MigrateLegacyExit;
		}
	}
	#line 679
	if(PUserData->RxFIFO != (ULONG )(- 1))
	{
		#line 680
		status = SerialPutRegistryKeyValue(pnpKey, "R\0x\0F\0I\0F\0O\0",
			sizeof("R\0x\0F\0I\0F\0O\0"), 4, & PUserData->RxFIFO,
			sizeof(ULONG ));
		#line 684
		if(! ((NTSTATUS )status >= 0))
		{
			#line 685
			do
			{
				#line 685
				;
			}
			while(0);
			#line 686
			goto MigrateLegacyExit;
		}
	}
	#line 695
	if(PUserData->TxFIFO != (ULONG )(- 1))
	{
		#line 696
		status = SerialPutRegistryKeyValue(pnpKey, "T\0x\0F\0I\0F\0O\0",
			sizeof("T\0x\0F\0I\0F\0O\0"), 4, & PUserData->TxFIFO,
			sizeof(ULONG ));
		#line 700
		if(! ((NTSTATUS )status >= 0))
		{
			#line 701
			do
			{
				#line 701
				;
			}
			while(0);
			#line 702
			goto MigrateLegacyExit;
		}
	}
	#line 711
	if(PUserData->MaskInverted != (ULONG )(- 1))
	{
		#line 712
		status = SerialPutRegistryKeyValue(pnpKey,
			"M\0a\0s\0k\0I\0n\0v\0e\0r\0t\0e\0d\0",
			sizeof("M\0a\0s\0k\0I\0n\0v\0e\0r\0t\0e\0d\0"), 4, &
			PUserData->MaskInverted, sizeof(ULONG ));
		if(! ((NTSTATUS )status >= 0))
		{
			#line 717
			do
			{
				#line 717
				;
			}
			while(0);
			#line 718
			goto MigrateLegacyExit;
		}
	}
	#line 723
	MigrateLegacyExit:
		#line 723
		;
	#line 725
	ZwClose(pnpKey);
	#line 728
	do
	{
		#line 728
		;
	}
	while(0);
	#line 730
	return status;
}

#line 736
BOOLEAN SerialIsUserDataValid(PDRIVER_OBJECT DriverObject ,
	PKEY_BASIC_INFORMATION UserSubKey , PRTL_QUERY_REGISTRY_TABLE Parameters
	, ULONG DefaultInterfaceType , PSERIAL_USER_DATA PUserData )
{
	#line 773
	ULONG zero = 0;
	BOOLEAN rval = 1;
	#line 776
	;
	#line 779
	do
	{
		#line 779
		;
	}
	while(0);
	#line 803
	if(! (PUserData->UserPort).LowPart)
	{
		#line 809
		SerialLogError(DriverObject, (void *  )0, PUserData->UserPort,
			SerialPhysicalZero___2, 0, 0, 0, 64, (NTSTATUS
			)0x00000000L, (NTSTATUS )0xC0060019L,
			UserSubKey->NameLength + sizeof(WCHAR ), &
			(UserSubKey->Name)[0], wcslen((Parameters[1]).Name) *
			sizeof(WCHAR ) + sizeof(WCHAR ), (Parameters[1]).Name);
		#line 830
		do
		{
			#line 830
			;
		}
		while(0);
		#line 831
		rval = 0;
		goto SerialIsUserDataValidError;
	}
	#line 835
	if(! PUserData->UserVector)
	{
		#line 841
		SerialLogError(DriverObject, (void *  )0, PUserData->UserPort,
			SerialPhysicalZero___2, 0, 0, 0, 65, (NTSTATUS
			)0x00000000L, (NTSTATUS )0xC0060019L,
			UserSubKey->NameLength + sizeof(WCHAR ), &
			(UserSubKey->Name)[0], wcslen((Parameters[2]).Name) *
			sizeof(WCHAR ) + sizeof(WCHAR ), (Parameters[2]).Name);
		#line 862
		do
		{
			#line 862
			;
		}
		while(0);
		#line 864
		rval = 0;
		goto SerialIsUserDataValidError;
	}
	#line 868
	if(! (PUserData->UserSymbolicLink).Length)
	{
		#line 874
		SerialLogError(DriverObject, (void *  )0, PUserData->UserPort,
			SerialPhysicalZero___2, 0, 0, 0, 66, (NTSTATUS
			)0x00000000L, (NTSTATUS )0xC0060019L,
			UserSubKey->NameLength + sizeof(WCHAR ), &
			(UserSubKey->Name)[0], wcslen((Parameters[3]).Name) *
			sizeof(WCHAR ) + sizeof(WCHAR ), (Parameters[3]).Name);
		#line 887
		do
		{
			#line 887
			;
		}
		while(0);
		#line 889
		rval = 0;
		goto SerialIsUserDataValidError;
	}
	#line 893
	if((PUserData->UserInterruptStatus).LowPart != 0)
	{
		if(PUserData->UserPortIndex == 0xffffffff)
		{
			#line 901
			SerialLogError(DriverObject, (void *  )0,
				PUserData->UserPort, SerialPhysicalZero___2, 0,
				0, 0, 67, (NTSTATUS )0x00000000L, (NTSTATUS
				)0xC0060014L,
				(PUserData->UserSymbolicLink).Length +
				sizeof(WCHAR ),
				(PUserData->UserSymbolicLink).Buffer, 0,
				(void *  )0);
			#line 921
			do
			{
				#line 921
				;
			}
			while(0);
			#line 923
			rval = 0;
			goto SerialIsUserDataValidError;
		}
		else
		{
			#line 926
			if(! PUserData->UserPortIndex)
			{
				#line 932
				SerialLogError(DriverObject, (void *  )0,
					PUserData->UserPort,
					SerialPhysicalZero___2, 0, 0, 0, 68,
					(NTSTATUS )0x00000000L, (NTSTATUS
					)0xC0060014L,
					(PUserData->UserSymbolicLink).Length +
					sizeof(WCHAR ),
					(PUserData->UserSymbolicLink).Buffer, 0,
					(void *  )0);
				#line 953
				do
				{
					#line 953
					;
				}
				while(0);
				#line 955
				rval = 0;
				goto SerialIsUserDataValidError;
			}
			else
			{
				if(PUserData->UserIndexed)
				{
					if(PUserData->UserPortIndex > 16)
					{
						SerialLogError(DriverObject,
							(void *  )0,
							PUserData->UserPort,
							SerialPhysicalZero___2,
							0, 0, 0, 69, (NTSTATUS
							)0x00000000L, (NTSTATUS
							)0xC0060015L,
							(PUserData->UserSymbolicLink)
							.Length + sizeof(WCHAR
							),
							(PUserData->UserSymbolicLink)
							.Buffer, 0, (void * 
							)0);
						#line 984
						do
						{
							#line 984
							;
						}
						while(0);
						#line 986
						rval = 0;
						goto SerialIsUserDataValidError;
					}
				}
				else
				{
					if(PUserData->UserPortIndex > 8)
					{
						SerialLogError(DriverObject,
							(void *  )0,
							PUserData->UserPort,
							SerialPhysicalZero___2,
							0, 0, 0, 70, (NTSTATUS
							)0x00000000L, (NTSTATUS
							)0xC0060015L,
							(PUserData->UserSymbolicLink)
							.Length + sizeof(WCHAR
							),
							(PUserData->UserSymbolicLink)
							.Buffer, 0, (void * 
							)0);
						#line 1014
						do
						{
							#line 1014
							;
						}
						while(0);
						#line 1016
						rval = 0;
						goto SerialIsUserDataValidError;
					}
				}
			}
		}
	}
	#line 1034
	if(PUserData->UserBusNumber != 0 || PUserData->UserInterfaceType !=
		DefaultInterfaceType)
	{
		BOOLEAN foundIt ;
		if(PUserData->UserInterfaceType >= MaximumInterfaceType)
		{
			#line 1044
			SerialLogError(DriverObject, (void *  )0,
				PUserData->UserPort, SerialPhysicalZero___2, 0,
				0, 0, 71, (NTSTATUS )0x00000000L, (NTSTATUS
				)0xC0060016L,
				(PUserData->UserSymbolicLink).Length +
				sizeof(WCHAR ),
				(PUserData->UserSymbolicLink).Buffer, 0,
				(void *  )0);
			#line 1064
			do
			{
				#line 1064
				;
			}
			while(0);
			#line 1066
			rval = 0;
			goto SerialIsUserDataValidError;
		}
		#line 1070
		IoQueryDeviceDescription((INTERFACE_TYPE *  )(&
			PUserData->UserInterfaceType), & zero, (void *  )0,
			(void *  )0, (void *  )0, (void *  )0,
			SerialItemCallBack, & foundIt);
		#line 1081
		if(! foundIt)
		{
			SerialLogError(DriverObject, (void *  )0,
				PUserData->UserPort, SerialPhysicalZero___2, 0,
				0, 0, 72, (NTSTATUS )0x00000000L, (NTSTATUS
				)0xC0060017L,
				(PUserData->UserSymbolicLink).Length +
				sizeof(WCHAR ),
				(PUserData->UserSymbolicLink).Buffer, 0,
				(void *  )0);
			#line 1104
			do
			{
				#line 1104
				;
			}
			while(0);
			#line 1106
			rval = 0;
			goto SerialIsUserDataValidError;
		}
	}
	#line 1112
	if(PUserData->UserInterfaceType == MicroChannel &&
		PUserData->UserInterruptMode == 1)
	{
		SerialLogError(DriverObject, (void *  )0, PUserData->UserPort,
			SerialPhysicalZero___2, 0, 0, 0, 73, (NTSTATUS
			)0x00000000L, (NTSTATUS )0xC0060018L,
			(PUserData->UserSymbolicLink).Length + sizeof(WCHAR ),
			(PUserData->UserSymbolicLink).Buffer, 0, (void *  )0);
		#line 1136
		do
		{
			#line 1136
			;
		}
		while(0);
		#line 1138
		rval = 0;
		goto SerialIsUserDataValidError;
	}
	#line 1146
	do
	{
		#line 1146
		;
	}
	while(0);
	#line 1151
	do
	{
		#line 1151
		;
	}
	while(0);
	#line 1156
	do
	{
		#line 1156
		;
	}
	while(0);
	#line 1161
	do
	{
		#line 1161
		;
	}
	while(0);
	#line 1166
	do
	{
		#line 1166
		;
	}
	while(0);
	#line 1171
	do
	{
		#line 1171
		;
	}
	while(0);
	#line 1176
	do
	{
		#line 1176
		;
	}
	while(0);
	#line 1181
	do
	{
		#line 1181
		;
	}
	while(0);
	#line 1186
	do
	{
		#line 1186
		;
	}
	while(0);
	#line 1191
	do
	{
		#line 1191
		;
	}
	while(0);
	#line 1196
	do
	{
		#line 1196
		;
	}
	while(0);
	do
	{
		#line 1199
		;
	}
	while(0);
	#line 1201
	SerialIsUserDataValidError:
		#line 1203
		return rval;
}

#line 1208
NTSTATUS SerialEnumerateLegacy(PDRIVER_OBJECT DriverObject , PUNICODE_STRING
	RegistryPath , PSERIAL_FIRMWARE_DATA DriverDefaultsPtr )
{
	#line 1244
	SERIAL_FIRMWARE_DATA firmware ;
	#line 1246
	PRTL_QUERY_REGISTRY_TABLE parameters = (void *  )0;
	#line 1248
	INTERFACE_TYPE interfaceType ;
	ULONG defaultInterfaceType ;
	#line 1251
	PULONG countSoFar = & (IoGetConfigurationInformation())->SerialCount;
	#line 1257
	ULONG maxUlong = 0xffffffff;
	ULONG zero = 0;
	ULONG nonzero = 1;
	ULONG badValue = (ULONG )(- 1);
	#line 1262
	ULONG defaultInterruptMode ;
	ULONG defaultAddressSpace = 0x0001;
	#line 1268
	SERIAL_USER_DATA userData ;
	ULONG legacyDiscovered ;
	#line 1271
	UNICODE_STRING PnPID ;
	UNICODE_STRING legacyKeys ;
	#line 1274
	UNICODE_STRING parametersPath ;
	OBJECT_ATTRIBUTES parametersAttributes ;
	HANDLE parametersKey ;
	HANDLE pnpKey ;
	PKEY_BASIC_INFORMATION userSubKey = (void *  )0;
	ULONG i ;
	#line 1281
	PCM_RESOURCE_LIST resourceList = (void *  )0;
	PCM_RESOURCE_LIST trResourceList = (void *  )0;
	PIO_RESOURCE_REQUIREMENTS_LIST pRequiredList = (void *  )0;
	ULONG countOfPartials ;
	PDEVICE_OBJECT newPdo ;
	ULONG brokenStatus ;
	#line 1288
	;
	#line 1290
	do
	{
		#line 1290
		;
	}
	while(0);
	#line 1292
	PnPID.Buffer = (void *  )0;
	legacyKeys.Buffer = (void *  )0;
	(userData.UserSymbolicLink).Buffer = (void *  )0;
	parametersPath.Buffer = (void *  )0;
	#line 1297
	userData.ForceFIFOEnableDefault =
		DriverDefaultsPtr->ForceFifoEnableDefault;
	#line 1298
	userData.PermitShareDefault = DriverDefaultsPtr->PermitShareDefault;
	userData.LogFIFODefault = DriverDefaultsPtr->LogFifoDefault;
	userData.DefaultPermitSystemWideShare = 0;
	userData.RxFIFODefault = DriverDefaultsPtr->RxFIFODefault;
	userData.TxFIFODefault = DriverDefaultsPtr->TxFIFODefault;
	#line 1319
	defaultInterfaceType = (ULONG )Isa;
	defaultInterruptMode = 1;
	#line 1322
	for(interfaceType = 0; interfaceType < MaximumInterfaceType;
		interfaceType++)
	{
		#line 1328
		ULONG busZero = 0;
		BOOLEAN foundOne = 0;
		#line 1331
		if(interfaceType != Internal)
		{
			IoQueryDeviceDescription(& interfaceType, & busZero,
				(void *  )0, (void *  )0, (void *  )0, (void * 
				)0, SerialItemCallBack, & foundOne);
			#line 1344
			if(foundOne)
			{
				defaultInterfaceType = (ULONG )interfaceType;
				if(defaultInterfaceType == MicroChannel)
				{
					defaultInterruptMode = 0;
					#line 1356
					userData.DefaultPermitSystemWideShare =
						1;
				}
				#line 1360
				break;
			}
		}
	}
	#line 1375
	(userData.UserSymbolicLink).Buffer = (void *  )0;
	parametersPath.Buffer = (void *  )0;
	#line 1384
	parameters = ExAllocatePoolWithTag(PagedPool,
		sizeof(RTL_QUERY_REGISTRY_TABLE ) * 22, 'XMOC');
	#line 1389
	if(! parameters)
	{
		SerialLogError(DriverObject, (void *  )0,
			SerialPhysicalZero___2, SerialPhysicalZero___2, 0, 0, 0,
			74, (NTSTATUS )0x00000000L, (NTSTATUS )0xC0060008L, 0,
			(void *  )0, 0, (void *  )0);
		#line 1412
		do
		{
			#line 1412
			;
		}
		while(0);
		#line 1414
		goto LegacyInitLeave;
	}
	#line 1421
	memset(parameters, 0, sizeof(RTL_QUERY_REGISTRY_TABLE ) * 22);
	#line 1438
	RtlInitUnicodeString(& userData.UserSymbolicLink, (void *  )0);
	(userData.UserSymbolicLink).MaximumLength = sizeof(WCHAR ) * 256;
	(userData.UserSymbolicLink).Buffer = ExAllocatePoolWithTag(PagedPool,
		sizeof(WCHAR ) * 257, 'XMOC');
	#line 1443
	if(! (userData.UserSymbolicLink).Buffer)
	{
		SerialLogError(DriverObject, (void *  )0,
			SerialPhysicalZero___2, SerialPhysicalZero___2, 0, 0, 0,
			75, (NTSTATUS )0x00000000L, (NTSTATUS )0xC0060008L, 0,
			(void *  )0, 0, (void *  )0);
		#line 1466
		do
		{
			#line 1466
			;
		}
		while(0);
		#line 1468
		goto LegacyInitLeave;
	}
	#line 1486
	RtlInitUnicodeString(& PnPID, (void *  )0);
	PnPID.MaximumLength = sizeof(WCHAR ) * 256;
	PnPID.Buffer = ExAllocatePoolWithTag(PagedPool, sizeof(WCHAR ) * 257,
		'XMOC');
	if(PnPID.Buffer == 0)
	{
		SerialLogError(DriverObject, (void *  )0,
			SerialPhysicalZero___2, SerialPhysicalZero___2, 0, 0, 0,
			76, (NTSTATUS )0x00000000L, (NTSTATUS )0xC0060008L, 0,
			(void *  )0, 0, (void *  )0);
		#line 1513
		do
		{
			#line 1513
			;
		}
		while(0);
		#line 1515
		goto LegacyInitLeave;
	}
	#line 1521
	RtlInitUnicodeString(& legacyKeys, (void *  )0);
	legacyKeys.MaximumLength = sizeof(WCHAR ) * 256;
	legacyKeys.Buffer = ExAllocatePoolWithTag(PagedPool, sizeof(WCHAR ) *
		257, 'XMOC');
	if(! legacyKeys.Buffer)
	{
		SerialLogError(DriverObject, (void *  )0,
			SerialPhysicalZero___2, SerialPhysicalZero___2, 0, 0, 0,
			77, (NTSTATUS )0x00000000L, (NTSTATUS )0xC0060008L, 0,
			(void *  )0, 0, (void *  )0);
		#line 1545
		do
		{
			#line 1545
			;
		}
		while(0);
		#line 1547
		goto LegacyInitLeave;
	}
	#line 1551
	resourceList = ExAllocatePoolWithTag(PagedPool, sizeof(CM_RESOURCE_LIST
		) + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR ) * 2, 'XMOC');
	#line 1554
	if(resourceList == (void *  )0)
	{
		#line 1555
		SerialLogError(DriverObject, (void *  )0, userData.UserPort,
			SerialPhysicalZero___2, 0, 0, 0, 78, (NTSTATUS
			)0x00000000L, (NTSTATUS )0xC0060008L, 0, (void *  )0, 0,
			(void *  )0);
		#line 1571
		goto LegacyInitLeave;
	}
	#line 1574
	trResourceList = ExAllocatePoolWithTag(PagedPool,
		sizeof(CM_RESOURCE_LIST ) +
		sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR ) * 2, 'XMOC');
	#line 1578
	if(trResourceList == (void *  )0)
	{
		#line 1579
		SerialLogError(DriverObject, (void *  )0, userData.UserPort,
			SerialPhysicalZero___2, 0, 0, 0, 79, (NTSTATUS
			)0x00000000L, (NTSTATUS )0xC0060008L, 0, (void *  )0, 0,
			(void *  )0);
		#line 1595
		goto LegacyInitLeave;
	}
	#line 1599
	pRequiredList = ExAllocatePoolWithTag(PagedPool,
		sizeof(IO_RESOURCE_REQUIREMENTS_LIST ) +
		sizeof(IO_RESOURCE_DESCRIPTOR ) * 2, 'XMOC');
	#line 1603
	if(pRequiredList == (void *  )0)
	{
		#line 1604
		SerialLogError(DriverObject, (void *  )0, userData.UserPort,
			SerialPhysicalZero___2, 0, 0, 0, 80, (NTSTATUS
			)0x00000000L, (NTSTATUS )0xC0060008L, 0, (void *  )0, 0,
			(void *  )0);
		#line 1621
		goto LegacyInitLeave;
	}
	#line 1629
	RtlInitUnicodeString(& parametersPath, (void *  )0);
	#line 1634
	parametersPath.MaximumLength = RegistryPath->Length + sizeof("\134\0") +
		sizeof("P\0a\0r\0a\0m\0e\0t\0e\0r\0s\0");
	#line 1638
	parametersPath.Buffer = ExAllocatePoolWithTag(PagedPool,
		parametersPath.MaximumLength, 'XMOC');
	#line 1643
	if(! parametersPath.Buffer)
	{
		SerialLogError(DriverObject, (void *  )0,
			SerialPhysicalZero___2, SerialPhysicalZero___2, 0, 0, 0,
			81, (NTSTATUS )0x00000000L, (NTSTATUS )0xC0060008L, 0,
			(void *  )0, 0, (void *  )0);
		#line 1666
		do
		{
			#line 1666
			;
		}
		while(0);
		#line 1668
		goto LegacyInitLeave;
	}
	#line 1679
	memset(parametersPath.Buffer, 0, parametersPath.MaximumLength);
	RtlAppendUnicodeStringToString(& parametersPath, RegistryPath);
	#line 1684
	RtlAppendUnicodeToString(& parametersPath, "\134\0");
	#line 1688
	RtlAppendUnicodeToString(& parametersPath,
		"P\0a\0r\0a\0m\0e\0t\0e\0r\0s\0");
	#line 1696
	memset(legacyKeys.Buffer, 0, legacyKeys.MaximumLength);
	RtlAppendUnicodeStringToString(& legacyKeys, & parametersPath);
	#line 1700
	userSubKey = ExAllocatePoolWithTag(PagedPool,
		sizeof(KEY_BASIC_INFORMATION ) + sizeof(WCHAR ) * 256, 'XMOC');
	#line 1705
	if(! userSubKey)
	{
		SerialLogError(DriverObject, (void *  )0,
			SerialPhysicalZero___2, SerialPhysicalZero___2, 0, 0, 0,
			82, (NTSTATUS )0x00000000L, (NTSTATUS )0xC0060008L, 0,
			(void *  )0, 0, (void *  )0);
		#line 1728
		do
		{
			#line 1728
			;
		}
		while(0);
		#line 1730
		goto LegacyInitLeave;
	}
	{
		#line 1744
		(& parametersAttributes)->Length = sizeof(OBJECT_ATTRIBUTES );
		#line 1744
		(& parametersAttributes)->RootDirectory = (void *  )0;
		#line 1744
		(& parametersAttributes)->Attributes = 0x00000040L;
		#line 1744
		(& parametersAttributes)->ObjectName = & parametersPath;
		#line 1744
		(& parametersAttributes)->SecurityDescriptor = (void *  )0;
		#line 1744
		(& parametersAttributes)->SecurityQualityOfService = (void * 
			)0;
	}
	#line 1744
	;
	#line 1746
	if(! ((NTSTATUS )ZwOpenKey(& parametersKey, 0x02000000L, &
		parametersAttributes) >= 0))
	{
		#line 1752
		SerialLogError(DriverObject, (void *  )0,
			SerialPhysicalZero___2, SerialPhysicalZero___2, 0, 0, 0,
			83, (NTSTATUS )0x00000000L, (NTSTATUS )0xC0060012L, 0,
			(void *  )0, 0, (void *  )0);
		#line 1772
		do
		{
			#line 1772
			;
		}
		while(0);
		#line 1773
		goto LegacyInitLeave;
	}
	#line 1779
	(parameters[0]).Flags = 0x00000001;
	#line 1781
	(parameters[1]).Flags = 0x00000020;
	(parameters[1]).Name = "P\0o\0r\0t\0A\0d\0d\0r\0e\0s\0s\0";
	(parameters[1]).EntryContext = & (userData.UserPort).LowPart;
	(parameters[1]).DefaultType = 4;
	(parameters[1]).DefaultData = & zero;
	(parameters[1]).DefaultLength = sizeof(ULONG );
	#line 1788
	(parameters[2]).Flags = 0x00000020;
	(parameters[2]).Name = "I\0n\0t\0e\0r\0r\0u\0p\0t\0";
	(parameters[2]).EntryContext = & userData.UserVector;
	(parameters[2]).DefaultType = 4;
	(parameters[2]).DefaultData = & zero;
	(parameters[2]).DefaultLength = sizeof(ULONG );
	#line 1795
	(parameters[3]).Flags = 0x00000020;
	(parameters[3]).Name = "D\0o\0s\0D\0e\0v\0i\0c\0e\0s\0";
	(parameters[3]).EntryContext = & userData.UserSymbolicLink;
	(parameters[3]).DefaultType = 1;
	(parameters[3]).DefaultData = "";
	(parameters[3]).DefaultLength = 0;
	#line 1802
	(parameters[4]).Flags = 0x00000020;
	(parameters[4]).Name = "I\0n\0t\0e\0r\0r\0u\0p\0t\0S\0t\0a\0t\0u\0s\0";
	(parameters[4]).EntryContext = & (userData.UserInterruptStatus).LowPart;
	(parameters[4]).DefaultType = 4;
	(parameters[4]).DefaultData = & zero;
	(parameters[4]).DefaultLength = sizeof(ULONG );
	#line 1809
	(parameters[5]).Flags = 0x00000020;
	(parameters[5]).Name = "P\0o\0r\0t\0I\0n\0d\0e\0x\0";
	(parameters[5]).EntryContext = & userData.UserPortIndex;
	(parameters[5]).DefaultType = 4;
	(parameters[5]).DefaultData = & zero;
	(parameters[5]).DefaultLength = sizeof(ULONG );
	#line 1816
	(parameters[6]).Flags = 0x00000020;
	(parameters[6]).Name = "B\0u\0s\0N\0u\0m\0b\0e\0r\0";
	(parameters[6]).EntryContext = & userData.UserBusNumber;
	(parameters[6]).DefaultType = 4;
	(parameters[6]).DefaultData = & zero;
	(parameters[6]).DefaultLength = sizeof(ULONG );
	#line 1823
	(parameters[7]).Flags = 0x00000020;
	(parameters[7]).Name = "B\0u\0s\0T\0y\0p\0e\0";
	(parameters[7]).EntryContext = & userData.UserInterfaceType;
	(parameters[7]).DefaultType = 4;
	(parameters[7]).DefaultData = & defaultInterfaceType;
	(parameters[7]).DefaultLength = sizeof(ULONG );
	#line 1830
	(parameters[8]).Flags = 0x00000020;
	(parameters[8]).Name = "C\0l\0o\0c\0k\0R\0a\0t\0e\0";
	(parameters[8]).EntryContext = & userData.UserClockRate;
	(parameters[8]).DefaultType = 4;
	(parameters[8]).DefaultData = & badValue;
	(parameters[8]).DefaultLength = sizeof(ULONG );
	#line 1837
	(parameters[9]).Flags = 0x00000020;
	(parameters[9]).Name = "I\0n\0d\0e\0x\0e\0d\0";
	(parameters[9]).EntryContext = & userData.UserIndexed;
	(parameters[9]).DefaultType = 4;
	(parameters[9]).DefaultData = & badValue;
	(parameters[9]).DefaultLength = sizeof(ULONG );
	#line 1844
	(parameters[10]).Flags = 0x00000020;
	(parameters[10]).Name = "I\0n\0t\0e\0r\0r\0u\0p\0t\0M\0o\0d\0e\0";
	(parameters[10]).EntryContext = & userData.UserInterruptMode;
	(parameters[10]).DefaultType = 4;
	(parameters[10]).DefaultData = & defaultInterruptMode;
	(parameters[10]).DefaultLength = sizeof(ULONG );
	#line 1851
	(parameters[11]).Flags = 0x00000020;
	(parameters[11]).Name = "A\0d\0d\0r\0e\0s\0s\0S\0p\0a\0c\0e\0";
	(parameters[11]).EntryContext = & userData.UserAddressSpace;
	(parameters[11]).DefaultType = 4;
	(parameters[11]).DefaultData = & defaultAddressSpace;
	(parameters[11]).DefaultLength = sizeof(ULONG );
	#line 1858
	(parameters[12]).Flags = 0x00000020;
	(parameters[12]).Name = "I\0n\0t\0e\0r\0r\0u\0p\0t\0L\0e\0v\0e\0l\0";
	(parameters[12]).EntryContext = & userData.UserLevel;
	(parameters[12]).DefaultType = 4;
	(parameters[12]).DefaultData = & zero;
	(parameters[12]).DefaultLength = sizeof(ULONG );
	#line 1865
	(parameters[13]).Flags = 0x00000020;
	(parameters[13]).Name = "D\0i\0s\0a\0b\0l\0e\0P\0o\0r\0t\0";
	(parameters[13]).EntryContext = & userData.DisablePort;
	(parameters[13]).DefaultType = 4;
	(parameters[13]).DefaultData = & badValue;
	(parameters[13]).DefaultLength = sizeof(ULONG );
	#line 1872
	(parameters[14]).Flags = 0x00000020;
	(parameters[14]).Name = "F\0o\0r\0c\0e\0F\0i\0f\0o\0E\0n\0a\0b\0l\0e\0";
	(parameters[14]).EntryContext = & userData.ForceFIFOEnable;
	(parameters[14]).DefaultType = 4;
	(parameters[14]).DefaultData = & badValue;
	(parameters[14]).DefaultLength = sizeof(ULONG );
	#line 1879
	(parameters[15]).Flags = 0x00000020;
	(parameters[15]).Name = "R\0x\0F\0I\0F\0O\0";
	(parameters[15]).EntryContext = & userData.RxFIFO;
	(parameters[15]).DefaultType = 4;
	(parameters[15]).DefaultData = & badValue;
	(parameters[15]).DefaultLength = sizeof(ULONG );
	#line 1886
	(parameters[16]).Flags = 0x00000020;
	(parameters[16]).Name = "T\0x\0F\0I\0F\0O\0";
	(parameters[16]).EntryContext = & userData.TxFIFO;
	(parameters[16]).DefaultType = 4;
	(parameters[16]).DefaultData = & badValue;
	(parameters[16]).DefaultLength = sizeof(ULONG );
	#line 1893
	(parameters[17]).Flags = 0x00000020;
	(parameters[17]).Name = "M\0a\0s\0k\0I\0n\0v\0e\0r\0t\0e\0d\0";
	(parameters[17]).EntryContext = & userData.MaskInverted;
	(parameters[17]).DefaultType = 4;
	(parameters[17]).DefaultData = & zero;
	(parameters[17]).DefaultLength = sizeof(ULONG );
	#line 1900
	(parameters[18]).Flags = 0x00000020;
	(parameters[18]).Name = "P\0n\0P\0D\0e\0v\0i\0c\0e\0I\0D\0";
	(parameters[18]).EntryContext = & PnPID;
	(parameters[18]).DefaultType = 1;
	(parameters[18]).DefaultData = "";
	(parameters[18]).DefaultLength = 0;
	#line 1907
	(parameters[19]).Flags = 0x00000020;
	(parameters[19]).Name =
		"L\0e\0g\0a\0c\0y\0D\0i\0s\0c\0o\0v\0e\0r\0e\0d\0";
	#line 1909
	(parameters[19]).EntryContext = & legacyDiscovered;
	(parameters[19]).DefaultType = 4;
	(parameters[19]).DefaultData = & zero;
	(parameters[19]).DefaultLength = sizeof(ULONG );
	#line 1920
	(parameters[20]).Flags = 0x00000020;
	(parameters[20]).Name =
		"I\0n\0t\0e\0r\0r\0u\0p\0t\0 \0S\0t\0a\0t\0u\0s\0";
	#line 1922
	(parameters[20]).EntryContext = & brokenStatus;
	(parameters[20]).DefaultType = 4;
	(parameters[20]).DefaultData = & zero;
	(parameters[20]).DefaultLength = sizeof(ULONG );
	#line 1928
	i = 0;
	#line 1930
	while(1)
	{
		NTSTATUS status ;
		ULONG actuallyReturned ;
		PDEVICE_OBJECT newDevObj = (void *  )0;
		PSERIAL_DEVICE_EXTENSION deviceExtension ;
		PDEVICE_OBJECT lowerDevice ;
		#line 1944
		status = ZwEnumerateKey(parametersKey, i, KeyBasicInformation,
			userSubKey, sizeof(KEY_BASIC_INFORMATION ) +
			sizeof(WCHAR ) * 255, & actuallyReturned);
		#line 1954
		if(status == (NTSTATUS )0x8000001AL)
		{
			break;
		}
		#line 1959
		if(status == (NTSTATUS )0x80000005L)
		{
			SerialLogError(DriverObject, (void *  )0,
				SerialPhysicalZero___2, SerialPhysicalZero___2,
				0, 0, 0, 84, (NTSTATUS )0x00000000L, (NTSTATUS
				)0xC0060013L, 0, (void *  )0, 0, (void *  )0);
			#line 1982
			do
			{
				#line 1982
				;
			}
			while(0);
			#line 1983
			i++;
			continue;
		}
		#line 1988
		if(! ((NTSTATUS )status >= 0))
		{
			SerialLogError(DriverObject, (void *  )0,
				SerialPhysicalZero___2, SerialPhysicalZero___2,
				0, 0, 0, 85, (NTSTATUS )0x00000000L, (NTSTATUS
				)0xC0060013L, 0, (void *  )0, 0, (void *  )0);
			#line 2011
			do
			{
				#line 2011
				;
			}
			while(0);
			#line 2012
			i++;
			continue;
		}
		#line 2024
		memset((PUCHAR )(& (userSubKey->Name)[0]) +
			userSubKey->NameLength, 0, sizeof(WCHAR ));
		(parameters[0]).Name = & (userSubKey->Name)[0];
		#line 2033
		memset(& userData.UserPort, 0, sizeof(userData.UserPort));
		#line 2035
		memset(& userData.UserInterruptStatus, 0,
			sizeof(userData.UserInterruptStatus));
		#line 2042
		memset((userData.UserSymbolicLink).Buffer, 0,
			(userData.UserSymbolicLink).MaximumLength);
		#line 2043
		(userData.UserSymbolicLink).Length = 0;
		#line 2046
		status = RtlQueryRegistryValues(0, parametersPath.Buffer,
			parameters, (void *  )0, (void *  )0);
		#line 2053
		if(! ((NTSTATUS )status >= 0))
		{
			#line 2054
			SerialLogError(DriverObject, (void *  )0,
				SerialPhysicalZero___2, SerialPhysicalZero___2,
				0, 0, 0, 86, (NTSTATUS )0x00000000L, (NTSTATUS
				)0xC0060019L, userSubKey->NameLength +
				sizeof(WCHAR ), & (userSubKey->Name)[0], 0,
				(void *  )0);
			#line 2076
			do
			{
				#line 2076
				;
			}
			while(0);
			#line 2078
			i++;
			continue;
		}
		#line 2093
		if(PnPID.Length != 0)
		{
			#line 2094
			i++;
			continue;
		}
		#line 2103
		if(legacyDiscovered != 0)
		{
			#line 2104
			i++;
			continue;
		}
		#line 2115
		memset((PUCHAR )(& ((userData.UserSymbolicLink).Buffer)[0]) +
			(userData.UserSymbolicLink).Length, 0, sizeof(WCHAR ));
		#line 2121
		if(brokenStatus != 0)
		{
			#line 2122
			(userData.UserInterruptStatus).LowPart = brokenStatus;
		}
		#line 2129
		if(SerialIsUserDataValid(DriverObject, userSubKey, parameters,
			defaultInterfaceType, & userData) == 0)
		{
			#line 2131
			i++;
			continue;
		}
		#line 2153
		status = SerialBuildResourceList(resourceList, &
			countOfPartials, & userData);
		#line 2156
		if(! ((NTSTATUS )status >= 0))
		{
			#line 2157
			i++;
			continue;
		}
		#line 2161
		;
		#line 2163
		status = SerialTranslateResourceList(DriverObject, userSubKey,
			trResourceList, resourceList, countOfPartials, &
			userData);
		#line 2167
		if(! ((NTSTATUS )status >= 0))
		{
			#line 2168
			i++;
			continue;
		}
		#line 2172
		status = SerialBuildRequirementsList(pRequiredList,
			countOfPartials, & userData);
		#line 2175
		if(! ((NTSTATUS )status >= 0))
		{
			#line 2176
			i++;
			continue;
		}
		#line 2180
		newPdo = (void *  )0;
		#line 2187
		status = IoReportDetectedDevice(DriverObject,
			InterfaceTypeUndefined, - 1, - 1, resourceList,
			pRequiredList, 0, & newPdo);
		#line 2203
		if(! ((NTSTATUS )status >= 0))
		{
			#line 2204
			if(status == (NTSTATUS )0xC000009AL)
			{
				#line 2205
				SerialLogError(DriverObject, (void *  )0,
					userData.UserPort,
					SerialPhysicalZero___2, 0, 0, 0, 89,
					status, (NTSTATUS )0xC006002CL,
					userSubKey->NameLength + sizeof(WCHAR ),
					& (userSubKey->Name)[0], 0, (void * 
					)0);
			}
			else
			{
				#line 2211
				SerialLogError(DriverObject, (void *  )0,
					userData.UserPort,
					SerialPhysicalZero___2, 0, 0, 0, 87,
					status, (NTSTATUS )0xC0060028L,
					userSubKey->NameLength + sizeof(WCHAR ),
					& (userSubKey->Name)[0], 0, (void * 
					)0);
			}
			#line 2218
			do
			{
				#line 2218
				;
			}
			while(0);
			#line 2219
			i++;
			continue;
		}
		#line 2228
		status = SerialMigrateLegacyRegistry(newPdo, & userData,
			(BOOLEAN )(countOfPartials == 3 ? 1 : 0));
		#line 2232
		if(! ((NTSTATUS )status >= 0))
		{
			#line 2237
			i++;
			continue;
		}
		#line 2245
		status = SerialCreateDevObj(DriverObject, & newDevObj);
		#line 2247
		if(! ((NTSTATUS )status >= 0))
		{
			#line 2252
			i++;
			continue;
		}
		#line 2256
		lowerDevice = IoAttachDeviceToDeviceStack(newDevObj, newPdo);
		deviceExtension = newDevObj->DeviceExtension;
		deviceExtension->LowerDeviceObject = lowerDevice;
		deviceExtension->Pdo = newPdo;
		newDevObj->Flags |= 0x00002000 | 0x00000004;
		{
			#line 2266
			MmLockPagableSectionByHandle(SerialGlobals.PAGESER_Handle
				);
		}
		#line 2266
		;
		#line 2269
		status = SerialFinishStartDevice(newDevObj, resourceList,
			trResourceList, & userData);
		{
			MmUnlockPagableImageSection(SerialGlobals.PAGESER_Handle
				);
		}
		#line 2272
		;
		#line 2281
		if(! ((NTSTATUS )status >= 0))
		{
			#line 2287
			SerialRemoveDevObj(newDevObj);
			#line 2289
			i++;
			continue;
		}
		#line 2297
		RtlAppendUnicodeToString(& legacyKeys, "\134\0");
		RtlAppendUnicodeToString(& legacyKeys, & (userSubKey->Name)[0]);
		#line 2300
		status = RtlWriteRegistryValue(0, legacyKeys.Buffer,
			"L\0e\0g\0a\0c\0y\0D\0i\0s\0c\0o\0v\0e\0r\0e\0d\0", 4, &
			nonzero, sizeof(nonzero));
		#line 2309
		memset(legacyKeys.Buffer, 0, legacyKeys.MaximumLength);
		legacyKeys.Length = 0;
		RtlAppendUnicodeStringToString(& legacyKeys, & parametersPath);
		#line 2318
		if(! ((NTSTATUS )status >= 0))
		{
			#line 2319
			SerialLogError(DriverObject, (void *  )0,
				userData.UserPort, SerialPhysicalZero___2, 0, 0,
				0, 88, (NTSTATUS )0x00000000L, (NTSTATUS
				)0xC0060029L, 0, (void *  )0, 0, (void *  )0);
			#line 2325
			do
			{
				#line 2325
				;
			}
			while(0);
		}
		#line 2328
		i++;
		(* countSoFar)++;
	}
	#line 2333
	ZwClose(parametersKey);
	#line 2335
	LegacyInitLeave:
		#line 2335
		;
	#line 2337
	if(userSubKey != (void *  )0)
	{
		#line 2338
		ExFreePool(userSubKey);
	}
	#line 2341
	if(PnPID.Buffer != (void *  )0)
	{
		#line 2342
		ExFreePool(PnPID.Buffer);
	}
	#line 2345
	if(legacyKeys.Buffer != (void *  )0)
	{
		#line 2346
		ExFreePool(legacyKeys.Buffer);
	}
	#line 2349
	if((userData.UserSymbolicLink).Buffer != (void *  )0)
	{
		#line 2350
		ExFreePool((userData.UserSymbolicLink).Buffer);
	}
	#line 2353
	if(parametersPath.Buffer != (void *  )0)
	{
		#line 2354
		ExFreePool(parametersPath.Buffer);
	}
	#line 2357
	if(parameters != (void *  )0)
	{
		#line 2358
		ExFreePool(parameters);
	}
	#line 2361
	if(resourceList != (void *  )0)
	{
		#line 2362
		ExFreePool(resourceList);
	}
	#line 2365
	if(trResourceList != (void *  )0)
	{
		#line 2366
		ExFreePool(trResourceList);
	}
	#line 2369
	if(pRequiredList != (void *  )0)
	{
		#line 2370
		ExFreePool(pRequiredList);
	}
	#line 2374
	do
	{
		#line 2374
		;
	}
	while(0);
	#line 2376
	return (NTSTATUS )0x00000000L;
}

#line 16 "C:/NTDDK/inc/stddef.h"

#pragma once
#line 77
typedef int ;

#line 86
typedef unsigned int ;

#line 95
typedef int ;

#line 105
typedef unsigned int ;

#line 112
typedef unsigned short ;

#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"

#pragma once
#line 32

#pragma pack(push, 8)
#line 72
typedef enum _EXCEPTION_DISPOSITION ;

#line 89
struct _EXCEPTION_RECORD ;

#line 90
struct _CONTEXT ;

#line 155

#pragma pack(pop)
#line 25 "C:/NTDDK/inc/ntdef.h"

#pragma once
#line 15 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"

#pragma once
#line 66
typedef wchar_t ;

#line 67
typedef wchar_t ;

#line 127 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long ;

#line 25 "C:/NTDDK/inc/basetsd.h"

#pragma once
#line 36
typedef int ;

#line 37
typedef int ;

#line 43
typedef unsigned int ;

#line 44
typedef unsigned int ;

#line 45
typedef unsigned int ;

#line 84
typedef int ;

#line 85
typedef unsigned int ;

typedef long ;

#line 88
typedef unsigned long ;

#line 248
typedef unsigned short ;

#line 249
typedef short ;

#line 250
typedef unsigned long ;

#line 288
typedef ULONG_PTR ;

#line 289
typedef LONG_PTR ;

#line 295
typedef ULONG_PTR ;

#line 301
typedef __int64 ;

#line 302
typedef __int64 ;

#line 309
typedef unsigned __int64 ;

#line 310
typedef unsigned __int64 ;

#line 311
typedef unsigned __int64 ;

#line 217 "C:/NTDDK/inc/ntdef.h"
typedef void ;

#line 218
typedef void ;

#line 266
typedef char ;

#line 267
typedef short ;

#line 268
typedef long ;

#line 276
typedef wchar_t ;

#line 282
typedef WCHAR ;

#line 283
typedef WCHAR ;

#line 284
typedef const WCHAR ;

#line 285
typedef WCHAR ;

#line 286
typedef WCHAR ;

typedef const WCHAR ;

#line 293
typedef CHAR ;

#line 294
typedef CHAR ;

typedef const CHAR ;

#line 297
typedef CHAR ;

#line 298
typedef CHAR ;

#line 299
typedef const CHAR ;

#line 321
typedef char ;

#line 322
typedef unsigned char ;

#line 326
typedef LPSTR ;

#line 327
typedef LPSTR ;

#line 328
typedef LPCSTR ;

#line 337
typedef double ;

typedef struct _QUAD ;

#line 349
typedef SHORT ;

#line 350
typedef LONG ;

#line 351
typedef QUAD ;

#line 360
typedef unsigned char ;

#line 361
typedef unsigned short ;

#line 362
typedef unsigned long ;

#line 363
typedef QUAD ;

#line 369
typedef UCHAR ;

#line 370
typedef USHORT ;

#line 371
typedef ULONG ;

#line 372
typedef UQUAD ;

#line 378
typedef signed char ;

#line 379
typedef SCHAR ;

#line 394
typedef void ;

#line 400
typedef HANDLE ;

#line 406
typedef UCHAR ;

#line 407
typedef USHORT ;

#line 408
typedef ULONG ;

#line 414
typedef LONG ;

#line 478
typedef char ;

#line 479
typedef short ;

#line 480
typedef ULONG ;

typedef CCHAR ;

#line 483
typedef CSHORT ;

#line 484
typedef CLONG ;

#line 492
typedef ULONG ;

#line 493
typedef PULONG ;

#line 494
typedef USHORT ;

#line 500
typedef ULONG ;

#line 501
typedef ULONG ;

#line 508
typedef LONG ;

typedef NTSTATUS ;

#line 602
typedef struct _FLOAT128 ;

#line 607
typedef FLOAT128 ;

#line 621
typedef __int64 ;

#line 622
typedef unsigned __int64 ;

#line 639
typedef LONGLONG ;

#line 640
typedef ULONGLONG ;

#line 644
typedef LONGLONG ;

#line 649
typedef union _LARGE_INTEGER ;

#line 662
typedef LARGE_INTEGER ;

#line 668
typedef union _ULARGE_INTEGER ;

#line 681
typedef ULARGE_INTEGER ;

#line 690
typedef struct _LUID ;

#line 696
typedef ULONGLONG ;

#line 697
typedef DWORDLONG ;

#line 707
typedef LARGE_INTEGER ;

#line 831

#pragma warning(push)

#pragma warning(disable:4035)
__inline ULONGLONG __stdcall Int64ShllMod32___17(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 842
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    
		};
}

#line 845
__inline LONGLONG __stdcall Int64ShraMod32___17(LONGLONG Value , ULONG
	ShiftCount )
{
	#line 852
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    
		};
}

#line 855
__inline ULONGLONG __stdcall Int64ShrlMod32___17(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 862
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    
		};
}


#pragma warning(pop)
#line 956
typedef enum _EVENT_TYPE ;

#line 965
typedef enum _TIMER_TYPE ;

#line 974
typedef enum _WAIT_TYPE ;

#line 983
typedef CHAR ;

#line 984
typedef const char ;

#line 991
typedef struct _STRING ;

#line 999
typedef STRING ;

typedef STRING ;

#line 1002
typedef PSTRING ;

typedef STRING ;

#line 1005
typedef PSTRING ;

#line 1011
typedef struct _CSTRING ;

#line 1016
typedef CSTRING ;

#line 1019
typedef STRING ;

#line 1020
typedef PSTRING ;

#line 1027
typedef struct _UNICODE_STRING ;

#line 1036
typedef UNICODE_STRING ;

#line 1037
typedef const UNICODE_STRING ;

#line 1046
typedef UCHAR ;

#line 1047
typedef BOOLEAN ;

#line 1057
typedef struct _LIST_ENTRY ;

#line 1067
typedef struct _SINGLE_LIST_ENTRY ;

#line 1078
typedef struct LIST_ENTRY32 ;

#line 1082
typedef LIST_ENTRY32 ;

typedef struct LIST_ENTRY64 ;

#line 1088
typedef LIST_ENTRY64 ;

#line 1127
typedef struct _STRING32 ;

#line 1132
typedef STRING32 ;

typedef STRING32 ;

#line 1135
typedef UNICODE_STRING32 ;

typedef STRING32 ;

#line 1138
typedef ANSI_STRING32 ;

#line 1141
typedef struct _STRING64 ;

#line 1146
typedef STRING64 ;

typedef STRING64 ;

#line 1149
typedef UNICODE_STRING64 ;

typedef STRING64 ;

#line 1152
typedef ANSI_STRING64 ;

#line 1173
typedef struct _OBJECT_ATTRIBUTES ;

#line 1181
typedef OBJECT_ATTRIBUTES ;

#line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID ;

#line 70
typedef GUID ;

#line 75
typedef const GUID ;

#line 81
typedef GUID ;

#line 82
typedef IID ;

#line 85
typedef GUID ;

#line 86
typedef CLSID ;

#line 89
typedef GUID ;

#line 90
typedef FMTID ;

#line 16 "C:/NTDDK/inc/string.h"

#pragma once
#line 1233 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECTID ;

#line 1288
struct _CONTEXT ;

#line 1289
struct _EXCEPTION_RECORD ;

typedef EXCEPTION_DISPOSITION ;

#line 1306
typedef UCHAR ;

typedef KIRQL ;

#line 1316
typedef enum _NT_PRODUCT_TYPE ;

#line 1329
typedef enum _SUITE_TYPE ;

#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD ;

#line 76
typedef struct _ETHREAD ;

#line 77
typedef struct _EPROCESS ;

#line 78
typedef struct _PEB ;

#line 79
typedef struct _KINTERRUPT ;

#line 80
typedef struct _IO_TIMER ;

#line 81
typedef struct _OBJECT_TYPE ;

#line 82
typedef struct _CALLBACK_OBJECT ;

#line 83
typedef struct _DEVICE_HANDLER_OBJECT ;

#line 84
typedef struct _BUS_HANDLER ;

#line 143
typedef union _SLIST_HEADER ;

#line 204
typedef CCHAR ;

typedef enum _MODE ;

#line 222
struct _KAPC ;

typedef void ;

#line 232
typedef void ;

#line 242
typedef void ;

#line 248
typedef BOOLEAN ;

#line 254
typedef BOOLEAN ;

#line 265
typedef struct _KAPC ;

#line 292
struct _KDPC ;

typedef void ;

#line 351
typedef enum _KDPC_IMPORTANCE ;

#line 361
typedef struct _KDPC ;

#line 377
typedef PVOID ;

typedef void ;

#line 392
typedef struct _KIPI_COUNTS ;

#line 443
typedef struct _MDL ;

#line 532
typedef PVOID ;

#line 538
typedef PVOID ;

#line 544
typedef PVOID ;

typedef ULONG ;

#line 547
typedef ACCESS_MASK ;

#line 597
typedef struct _GENERIC_MAPPING ;

#line 603
typedef GENERIC_MAPPING ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES ;

#line 622
typedef LUID_AND_ATTRIBUTES ;

#line 623
typedef LUID_AND_ATTRIBUTES_ARRAY ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 642 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACL ;

#line 649
typedef ACL ;

#line 681
typedef struct _PRIVILEGE_SET ;

#line 735
typedef enum _SECURITY_IMPERSONATION_LEVEL ;

#line 753
typedef BOOLEAN ;

#line 762
typedef struct _SECURITY_QUALITY_OF_SERVICE ;

#line 774
typedef struct _SE_IMPERSONATION_STATE ;

#line 782
typedef ULONG ;

#line 809
typedef ULONG ;

#line 810
typedef KAFFINITY ;

#line 816
typedef LONG ;

#line 824
typedef ULONG_PTR ;

#line 825
typedef KSPIN_LOCK ;

#line 833
typedef void ;

#line 842
typedef enum _KPROFILE_SOURCE ;

#line 1079
typedef NTSTATUS ;

#line 1088
typedef struct _RTL_QUERY_REGISTRY_TABLE ;

#line 1952

#pragma warning(push)

#pragma warning(disable:4035)
#line 2019

#pragma warning(pop)
#line 2214
typedef struct _TIME_FIELDS ;

#line 2224
typedef TIME_FIELDS ;

#line 2499
typedef struct _RTL_BITMAP ;

#line 2503
typedef RTL_BITMAP ;

#line 2627
typedef struct _RTL_BITMAP_RUN ;

#line 2633
typedef RTL_BITMAP_RUN ;

#line 2886
typedef struct _RTL_RANGE ;

#line 2924
typedef struct _RTL_RANGE_LIST ;

#line 2950
typedef struct _RANGE_LIST_ITERATOR ;

#line 3019
typedef BOOLEAN ;

#line 3155
typedef struct _OSVERSIONINFOA ;

#line 3164
typedef struct _OSVERSIONINFOW ;

#line 3177
typedef OSVERSIONINFOA ;

#line 3178
typedef POSVERSIONINFOA ;

#line 3179
typedef LPOSVERSIONINFOA ;

#line 3182
typedef struct _OSVERSIONINFOEXA ;

#line 3195
typedef struct _OSVERSIONINFOEXW ;

#line 3213
typedef OSVERSIONINFOEXA ;

#line 3214
typedef POSVERSIONINFOEXA ;

#line 3215
typedef LPOSVERSIONINFOEXA ;

#line 3648
typedef struct _IO_STATUS_BLOCK ;

#line 3669
typedef void ;

#line 3685
typedef enum _FILE_INFORMATION_CLASS ;

#line 3731
typedef struct _FILE_BASIC_INFORMATION ;

#line 3739
typedef struct _FILE_STANDARD_INFORMATION ;

#line 3747
typedef struct _FILE_POSITION_INFORMATION ;

#line 3751
typedef struct _FILE_ALIGNMENT_INFORMATION ;

#line 3755
typedef struct _FILE_NAME_INFORMATION ;

#line 3760
typedef struct _FILE_NETWORK_OPEN_INFORMATION ;

#line 3770
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION ;

#line 3775
typedef struct _FILE_DISPOSITION_INFORMATION ;

#line 3779
typedef struct _FILE_END_OF_FILE_INFORMATION ;

#line 3784
typedef struct _FILE_FULL_EA_INFORMATION ;

#line 3798
typedef enum _FSINFOCLASS ;

#line 3810
typedef struct _FILE_FS_DEVICE_INFORMATION ;

#line 3820
typedef union _FILE_SEGMENT_ELEMENT ;

#line 3829
typedef enum _INTERFACE_TYPE ;

#line 3854
typedef enum _DMA_WIDTH ;

#line 3865
typedef enum _DMA_SPEED ;

#line 3879
typedef void ;

#line 3880
typedef void ;

#line 3888
typedef enum _BUS_DATA_TYPE ;

#line 3910
typedef struct _IO_ERROR_LOG_PACKET ;

#line 3931
typedef struct _IO_ERROR_LOG_MESSAGE ;

#line 4074
typedef struct _KEY_BASIC_INFORMATION ;

#line 4081
typedef struct _KEY_NODE_INFORMATION ;

#line 4091
typedef struct _KEY_FULL_INFORMATION ;

#line 4106
typedef struct _KEY_NAME_INFORMATION ;

#line 4112
typedef enum _KEY_INFORMATION_CLASS ;

#line 4122
typedef struct _KEY_WRITE_TIME_INFORMATION ;

#line 4126
typedef enum _KEY_SET_INFORMATION_CLASS ;

#line 4134
typedef struct _KEY_VALUE_BASIC_INFORMATION ;

#line 4141
typedef struct _KEY_VALUE_FULL_INFORMATION ;

#line 4151
typedef struct _KEY_VALUE_PARTIAL_INFORMATION ;

#line 4158
typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ;

#line 4164
typedef struct _KEY_VALUE_ENTRY ;

#line 4171
typedef enum _KEY_VALUE_INFORMATION_CLASS ;

#line 4210
typedef struct _OBJECT_NAME_INFORMATION ;

#line 4221
typedef enum _SECTION_INHERIT ;

#line 4294
typedef struct _CLIENT_ID ;

#line 4298
typedef CLIENT_ID ;

#line 4315
typedef struct _NT_TIB ;

#line 4327
typedef NT_TIB ;

#line 4332
typedef enum _PROCESSINFOCLASS ;

#line 4366
typedef enum _THREADINFOCLASS ;

#line 4395
typedef struct _PROCESS_WS_WATCH_INFORMATION ;

#line 4405
typedef struct _PROCESS_BASIC_INFORMATION ;

#line 4413
typedef PROCESS_BASIC_INFORMATION ;

#line 4422
typedef struct _PROCESS_DEVICEMAP_INFORMATION ;

#line 4440
typedef struct _PROCESS_SESSION_INFORMATION ;

#line 4454
typedef struct _QUOTA_LIMITS ;

#line 4462
typedef QUOTA_LIMITS ;

#line 4472
typedef struct _IO_COUNTERS ;

#line 4480
typedef IO_COUNTERS ;

#line 4488
typedef struct _VM_COUNTERS ;

#line 4501
typedef VM_COUNTERS ;

#line 4508
typedef struct _POOLED_USAGE_AND_LIMITS ;

#line 4519
typedef POOLED_USAGE_AND_LIMITS ;

#line 4528
typedef struct _PROCESS_ACCESS_TOKEN ;

#line 4555
typedef struct _KERNEL_USER_TIMES ;

#line 4561
typedef KERNEL_USER_TIMES ;

#line 4587
typedef enum _SYSTEM_POWER_STATE ;

#line 4598
typedef enum  {
	PowerActionNone = 0,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
} ;

typedef enum _DEVICE_POWER_STATE ;

#line 4618
typedef union _POWER_STATE ;

#line 4623
typedef enum _POWER_STATE_TYPE ;

#line 4654
typedef ULONG ;

typedef enum  {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
} ;

#line 4663
typedef enum  {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation
} ;

#line 4690
typedef ULONG ;

typedef LONG ;

#line 4693
typedef ULONG ;

#line 4719
typedef union _MCI_STATS ;

#line 4978
typedef struct _KPCR ;

#line 5006
typedef KPCR ;

#line 5012
typedef struct _KFLOATING_SAVE ;

#line 5153
typedef enum _INTERLOCKED_RESULT ;

#line 5252

#pragma warning(disable:4035)
#line 6994
typedef struct _KSYSTEM_TIME ;

#line 7014

#pragma warning(push)

#pragma warning(disable:4164)
#line 7019

#pragma function(_enable)
#line 7020

#pragma function(_disable)
#line 7024

#pragma warning(pop)
#line 7085
typedef struct _FLOATING_SAVE_AREA ;

#line 7097
typedef FLOATING_SAVE_AREA ;

#line 7109
typedef struct _CONTEXT ;

#line 7197
typedef CONTEXT ;

#line 7826
typedef void ;

#line 7850
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ;

#line 7899
typedef struct _KUSER_SHARED_DATA ;

#line 8123
typedef enum _CM_SERVICE_NODE_TYPE ;

#line 8132
typedef enum _CM_SERVICE_LOAD_TYPE ;

#line 8140
typedef enum _CM_ERROR_CONTROL_TYPE ;

#line 8172
typedef int ;

#line 8198
typedef enum _CM_SHARE_DISPOSITION ;

#line 8211
typedef PVOID ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST ;

#line 8443
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR ;

#line 8454
typedef struct _CM_RESOURCE_LIST ;

#line 8471
typedef struct _DEVICE_FLAGS ;

#line 8485
typedef struct _CM_COMPONENT_INFORMATION ;

#line 8503
typedef struct _CM_ROM_BLOCK ;

#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 8518 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_INT13_DRIVE_PARAMETER ;

#line 8532
typedef struct _CM_MCA_POS_DATA ;

#line 8544
typedef struct _EISA_MEMORY_TYPE ;

#line 8554
typedef struct _EISA_MEMORY_CONFIGURATION ;

#line 8567
typedef struct _EISA_IRQ_DESCRIPTOR ;

#line 8575
typedef struct _EISA_IRQ_CONFIGURATION ;

#line 8585
typedef struct _DMA_CONFIGURATION_BYTE0 ;

#line 8592
typedef struct _DMA_CONFIGURATION_BYTE1 ;

#line 8599
typedef struct _EISA_DMA_CONFIGURATION ;

#line 8609
typedef struct _EISA_PORT_DESCRIPTOR ;

#line 8616
typedef struct _EISA_PORT_CONFIGURATION ;

#line 8628
typedef struct _CM_EISA_SLOT_INFORMATION ;

#line 8644
typedef struct _CM_EISA_FUNCTION_INFORMATION ;

#line 8678
typedef struct _CM_PNP_BIOS_DEVICE_NODE ;

#line 8692
typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8761 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_SCSI_DEVICE_DATA ;

#line 8775
typedef struct _CM_VIDEO_DEVICE_DATA ;

#line 8785
typedef struct _CM_SONIC_DEVICE_DATA ;

#line 8796
typedef struct _CM_SERIAL_DEVICE_DATA ;

#line 8810
typedef struct _CM_MONITOR_DEVICE_DATA ;

#line 8844
typedef struct _CM_FLOPPY_DEVICE_DATA ;

#line 8881
typedef struct _CM_KEYBOARD_DEVICE_DATA ;

#line 8893
typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA ;

#line 8905
typedef struct _CM_PCCARD_DEVICE_DATA ;

#line 8944
typedef struct _IO_RESOURCE_DESCRIPTOR ;

#line 9027
typedef struct _IO_RESOURCE_LIST ;

#line 9036
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST ;

#line 9065
typedef struct _EXCEPTION_RECORD ;

#line 9074
typedef EXCEPTION_RECORD ;

typedef struct _EXCEPTION_RECORD32 ;

#line 9085
typedef struct _EXCEPTION_RECORD64 ;

#line 9099
typedef struct _EXCEPTION_POINTERS ;

#line 9111
typedef enum _CONFIGURATION_TYPE ;

#line 9161
typedef enum _KINTERRUPT_MODE ;

#line 9170
typedef enum _KWAIT_REASON ;

#line 9207
typedef struct _DISPATCHER_HEADER ;

#line 9217
typedef struct _KWAIT_BLOCK ;

#line 9230
typedef void ;

#line 9244
typedef struct _KDEVICE_QUEUE ;

#line 9252
typedef struct _KDEVICE_QUEUE_ENTRY ;

#line 9263
typedef struct _KEVENT ;

#line 9271
typedef BOOLEAN ;

#line 9281
typedef struct _KMUTANT ;

#line 9294
typedef struct _KSEMAPHORE ;

#line 9304
typedef struct _KTIMER ;

#line 9899
typedef enum _KBUGCHECK_BUFFER_DUMP_STATE ;

#line 9907
typedef void ;

#line 9914
typedef struct _KBUGCHECK_CALLBACK_RECORD ;

#line 10002
typedef void ;

#line 10020
typedef LOGICAL ;

#line 10037
typedef void ;

#line 10053
typedef enum _MEMORY_CACHING_TYPE_ORIG ;

#line 10057
typedef enum _MEMORY_CACHING_TYPE ;

#line 10087
typedef struct _DBGKD_DEBUG_DATA_HEADER64 ;

#line 10115
typedef enum _POOL_TYPE ;

#line 10195
typedef enum _EX_POOL_PRIORITY ;

#line 10247
typedef struct _FAST_MUTEX ;

#line 10574
typedef PVOID ;

#line 10582
typedef void ;

#line 10588
typedef struct _GENERAL_LOOKASIDE ;

#line 10619
typedef struct _NPAGED_LOOKASIDE_LIST ;

#line 10729
typedef struct _PAGED_LOOKASIDE_LIST ;

#line 10882
typedef enum _WORK_QUEUE_TYPE ;

#line 10889
typedef void ;

#line 10895
typedef struct _WORK_QUEUE_ITEM ;

#line 10926
typedef struct _ZONE_SEGMENT_HEADER ;

#line 10931
typedef struct _ZONE_HEADER ;

#line 11156
typedef ULONG_PTR ;

#line 11157
typedef ERESOURCE_THREAD ;

typedef struct _OWNER_ENTRY ;

#line 11168
typedef struct _ERESOURCE ;

#line 11197
typedef struct _RESOURCE_HASH_ENTRY ;

#line 11204
typedef struct _RESOURCE_PERFORMANCE_DATA ;

#line 11429
typedef struct _CALLBACK_OBJECT ;

typedef void ;

#line 11474
typedef GUID ;

#line 11862
typedef enum _MM_SYSTEM_SIZE ;

#line 11884
typedef enum _LOCK_OPERATION ;

#line 11970
typedef enum _MM_PAGE_PRIORITY ;

#line 11999
typedef struct _PHYSICAL_MEMORY_RANGE ;

#line 12385
typedef NTSTATUS ;

#line 12389
typedef NTSTATUS ;

#line 12399
struct _DRIVER_OBJECT ;

#line 12411
typedef enum _SECURITY_OPERATION_CODE ;

#line 12426
typedef struct _SECURITY_SUBJECT_CONTEXT ;

#line 12448
typedef struct _INITIAL_PRIVILEGE_SET ;

#line 12462
typedef struct _ACCESS_STATE ;

#line 12571
typedef void ;

#line 12585
typedef void ;

#line 12602
typedef struct _IMAGE_INFO ;

#line 12620
typedef void ;

#line 12859
typedef NTSTATUS ;

#line 12878
typedef enum _IO_QUERY_DEVICE_DATA_FORMAT ;

#line 12890
typedef enum _CREATE_FILE_TYPE ;

#line 12905
struct _DEVICE_DESCRIPTION ;

#line 12906
struct _DEVICE_OBJECT ;

#line 12907
struct _DMA_ADAPTER ;

#line 12908
struct _DRIVER_OBJECT ;

#line 12909
struct _DRIVE_LAYOUT_INFORMATION ;

#line 12910
struct _DISK_PARTITION ;

#line 12911
struct _FILE_OBJECT ;

#line 12912
struct _IRP ;

#line 12913
struct _SCSI_REQUEST_BLOCK ;

#line 12919
typedef void ;

#line 12932
typedef void ;

#line 12943
typedef NTSTATUS ;

#line 12955
typedef void ;

#line 12968
typedef void ;

#line 12979
typedef NTSTATUS ;

#line 12990
typedef void ;

#line 13001
typedef void ;

#line 13011
typedef NTSTATUS ;

#line 13025
typedef BOOLEAN ;

#line 13038
typedef BOOLEAN ;

#line 13051
typedef BOOLEAN ;

#line 13068
typedef BOOLEAN ;

#line 13078
typedef BOOLEAN ;

#line 13092
typedef BOOLEAN ;

#line 13106
typedef BOOLEAN ;

#line 13118
typedef BOOLEAN ;

#line 13127
typedef BOOLEAN ;

#line 13141
typedef BOOLEAN ;

#line 13161
typedef void ;

#line 13167
typedef void ;

#line 13179
typedef void ;

#line 13193
typedef BOOLEAN ;

#line 13207
typedef BOOLEAN ;

#line 13219
typedef BOOLEAN ;

#line 13227
typedef BOOLEAN ;

#line 13239
typedef BOOLEAN ;

#line 13253
typedef NTSTATUS ;

#line 13262
typedef NTSTATUS ;

#line 13275
typedef NTSTATUS ;

#line 13282
typedef NTSTATUS ;

#line 13289
typedef BOOLEAN ;

#line 13304
typedef BOOLEAN ;

#line 13319
typedef BOOLEAN ;

#line 13327
typedef BOOLEAN ;

#line 13336
typedef BOOLEAN ;

#line 13350
typedef struct _FAST_IO_DISPATCH ;

#line 13386
typedef enum _IO_ALLOCATION_ACTION ;

#line 13396
typedef IO_ALLOCATION_ACTION ;

#line 13410
typedef struct _IO_SECURITY_CONTEXT ;

#line 13434
typedef struct _VPB ;

#line 13482
typedef struct _ADAPTER_OBJECT ;

#line 13491
typedef struct _WAIT_CONTEXT_BLOCK ;

#line 13503
typedef struct _CONTROLLER_OBJECT ;

#line 13537
typedef struct _DEVICE_OBJECT ;

#line 13575
typedef struct _DEVICE_OBJECT ;

#line 13578
struct _DEVICE_OBJECT_POWER_EXTENSION ;

typedef struct _DEVOBJ_EXTENSION ;

#line 13608
typedef struct _DRIVER_EXTENSION ;

#line 13645
typedef struct _DRIVER_OBJECT ;

#line 13706
typedef struct _DRIVER_OBJECT ;

#line 13715
typedef struct _SECTION_OBJECT_POINTERS ;

#line 13720
typedef SECTION_OBJECT_POINTERS ;

#line 13726
typedef struct _IO_COMPLETION_CONTEXT ;

#line 13759
typedef struct _FILE_OBJECT ;

#line 13788
typedef struct _FILE_OBJECT ;

#line 13828
typedef struct _IRP ;

#line 14078
typedef NTSTATUS ;

#line 14163
typedef enum _DEVICE_RELATION_TYPE ;

#line 14171
typedef struct _DEVICE_RELATIONS ;

#line 14176
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE ;

#line 14185
typedef struct _INTERFACE ;

#line 14196
typedef struct _DEVICE_CAPABILITIES ;

#line 14229
typedef struct _POWER_SEQUENCE ;

#line 14235
typedef enum  {
	BusQueryDeviceID = 0,
	BusQueryHardwareIDs = 1,
	BusQueryCompatibleIDs = 2,
	BusQueryInstanceID = 3,
	BusQueryDeviceSerialNumber = 4
} ;

typedef ULONG ;

#line 14252
typedef enum  {
	DeviceTextDescription = 0,
	DeviceTextLocationInformation = 1
} ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 14615 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SHARE_ACCESS ;

#line 14635
typedef struct _CONFIGURATION_INFORMATION ;

#line 14848
typedef struct _BOOTDISK_INFORMATION ;

#line 15754
typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK ;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK ;

#line 15764
typedef struct _IO_REMOVE_LOCK_DBG_BLOCK ;

#line 15777
typedef struct _IO_REMOVE_LOCK ;

#line 16009
typedef struct _IO_WORKITEM ;

typedef void ;

#line 16100
typedef enum  {
	DevicePropertyDeviceDescription,
	DevicePropertyHardwareID,
	DevicePropertyCompatibleIDs,
	DevicePropertyBootConfiguration,
	DevicePropertyBootConfigurationTranslated,
	DevicePropertyClassName,
	DevicePropertyClassGuid,
	DevicePropertyDriverKeyName,
	DevicePropertyManufacturer,
	DevicePropertyFriendlyName,
	DevicePropertyLocationInformation,
	DevicePropertyPhysicalDeviceObjectName,
	DevicePropertyBusTypeGuid,
	DevicePropertyLegacyBusType,
	DevicePropertyBusNumber,
	DevicePropertyEnumeratorName,
	DevicePropertyAddress,
	DevicePropertyUINumber
} ;

typedef BOOLEAN ;

#line 16129
typedef struct _DMA_ADAPTER ;

#line 16135
typedef ULONG ;

#line 16148
typedef struct _PNP_BUS_INFORMATION ;

#line 16162
typedef struct _LEGACY_BUS_INFORMATION ;

#line 16168
typedef struct _BUS_INTERFACE_STANDARD ;

#line 16190
typedef BOOLEAN ;

#line 16194
typedef NTSTATUS ;

#line 16203
typedef NTSTATUS ;

#line 16206
typedef NTSTATUS ;

#line 16210
typedef NTSTATUS ;

#line 16214
typedef NTSTATUS ;

#line 16218
typedef void ;

#line 16222
typedef NTSTATUS ;

#line 16227
typedef void ;

#line 16231
typedef struct _ACPI_INTERFACE_STANDARD ;

#line 16255
typedef enum _ACPI_REG_TYPE ;

#line 16268
typedef USHORT ;

#line 16272
typedef void ;

#line 16278
typedef struct ACPI_REGS_INTERFACE_STANDARD ;

#line 16300
typedef struct  {
	PVOID LinkNode ;
	ULONG StaticVector ;
	UCHAR Flags ;
} ;

#line 16314
typedef NTSTATUS ;

#line 16329
typedef NTSTATUS ;

#line 16336
typedef void ;

#line 16343
typedef struct _INT_ROUTE_INTERFACE_STANDARD ;

#line 16366
typedef struct _IO_ASSIGNED_RESOURCES ;

#line 16490
typedef enum _IO_NOTIFICATION_EVENT_CATEGORY ;

#line 16504
typedef NTSTATUS ;

#line 16537
typedef void ;

#line 16573
typedef enum _ARBITER_ACTION ;

#line 16586
typedef struct _ARBITER_CONFLICT_INFO ;

#line 16608
typedef struct _ARBITER_PARAMETERS ;

#line 16719
typedef enum _ARBITER_REQUEST_SOURCE ;

#line 16731
typedef enum _ARBITER_RESULT ;

#line 16761
typedef struct _ARBITER_LIST_ENTRY ;

#line 16832
typedef NTSTATUS ;

#line 16853
typedef struct _ARBITER_INTERFACE ;

#line 16880
typedef enum _RESOURCE_TRANSLATION_DIRECTION ;

#line 16889
typedef NTSTATUS ;

#line 16901
typedef NTSTATUS ;

#line 16915
typedef struct _TRANSLATOR_INTERFACE ;

#line 16931
typedef NTSTATUS ;

#line 16945
typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE ;

#line 16959
typedef struct _PLUGPLAY_NOTIFICATION_HEADER ;

#line 16972
typedef struct _HWPROFILE_CHANGE_NOTIFICATION ;

#line 16986
typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION ;

#line 17006
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION ;

#line 17026
typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION ;

#line 17054
typedef struct _DEVICE_DESCRIPTION ;

#line 17086
typedef BOOLEAN ;

#line 17333
typedef void ;

#line 17339
typedef struct _DEVICE_CONTROL_CONTEXT ;

#line 17349
typedef PBUS_HANDLER ;

#line 17355
typedef void ;

#line 17365
typedef enum _HAL_QUERY_INFORMATION_CLASS ;

#line 17381
typedef enum _HAL_SET_INFORMATION_CLASS ;

#line 17388
typedef NTSTATUS ;

#line 17405
typedef NTSTATUS ;

#line 17420
typedef void ;

#line 17429
typedef void ;

#line 17438
typedef NTSTATUS ;

#line 17447
typedef NTSTATUS ;

#line 17456
typedef NTSTATUS ;

#line 17466
typedef NTSTATUS ;

#line 17475
typedef NTSTATUS ;

#line 17486
typedef struct _PM_DISPATCH_TABLE ;

#line 17492
typedef NTSTATUS ;

#line 17505
typedef struct _DMA_ADAPTER ;

#line 17520
typedef NTSTATUS ;

#line 17543
typedef BOOLEAN ;

#line 17553
typedef NTSTATUS ;

#line 17566
typedef void ;

#line 17572
typedef void ;

#line 17578
typedef BOOLEAN ;

#line 17588
typedef struct  {
	ULONG Version ;
	pHalQuerySystemInformation HalQuerySystemInformation ;
	pHalSetSystemInformation HalSetSystemInformation ;
	pHalQueryBusSlots HalQueryBusSlots ;
	ULONG Spare1 ;
	pHalExamineMBR HalExamineMBR ;
	pHalIoAssignDriveLetters HalIoAssignDriveLetters ;
	pHalIoReadPartitionTable HalIoReadPartitionTable ;
	pHalIoSetPartitionInformation HalIoSetPartitionInformation ;
	pHalIoWritePartitionTable HalIoWritePartitionTable ;
	pHalHandlerForBus HalReferenceHandlerForBus ;
	pHalReferenceBusHandler HalReferenceBusHandler ;
	pHalReferenceBusHandler HalDereferenceBusHandler ;
	pHalInitPnpDriver HalInitPnpDriver ;
	pHalInitPowerManagement HalInitPowerManagement ;
	pHalGetDmaAdapter HalGetDmaAdapter ;
	pHalGetInterruptTranslator HalGetInterruptTranslator ;
} ;

#line 17650
typedef struct _HAL_BUS_INFORMATION ;

#line 17658
typedef struct _HAL_PROFILE_SOURCE_INFORMATION ;

#line 17665
typedef struct _HAL_PROFILE_SOURCE_INTERVAL ;

#line 17671
typedef enum _HAL_DISPLAY_BIOS_INFORMATION ;

#line 17678
typedef struct _HAL_POWER_INFORMATION ;

#line 17683
typedef struct _HAL_PROCESSOR_SPEED_INFO ;

#line 17688
typedef struct _HAL_CALLBACKS ;

#line 17694
typedef struct _HAL_PROCESSOR_FEATURE ;

#line 17706
typedef union _MCI_ADDR ;

#line 17716
typedef enum  {
	HAL_MCE_RECORD,
	HAL_MCA_RECORD
} ;

#line 17726
typedef struct _MCA_EXCEPTION ;

#line 17752
typedef void ;

#line 17762
typedef struct _MCA_DRIVER_INFO ;

#line 17772
typedef struct _SCATTER_GATHER_ELEMENT ;

#line 17778

#pragma warning(disable:4200)
#line 17779
typedef struct _SCATTER_GATHER_LIST ;

#line 17784

#pragma warning(default:4200)
#line 17788
typedef struct _DMA_OPERATIONS ;

typedef struct _DMA_ADAPTER ;

#line 17797
typedef void ;

#line 17801
typedef PVOID ;

#line 17808
typedef void ;

#line 17816
typedef NTSTATUS ;

#line 17824
typedef BOOLEAN ;

#line 17833
typedef void ;

#line 17837
typedef void ;

#line 17843
typedef PHYSICAL_ADDRESS ;

#line 17852
typedef ULONG ;

#line 17856
typedef ULONG ;

#line 17860
typedef void ;

#line 17868
typedef NTSTATUS ;

#line 17880
typedef void ;

#line 17887
typedef struct _DMA_OPERATIONS ;

#line 18235
typedef void ;

#line 18321
typedef struct _OBJECT_HANDLE_INFORMATION ;

#line 18402
typedef struct _PCI_SLOT_NUMBER ;

#line 18418
typedef struct _PCI_COMMON_CONFIG ;

#line 18591
typedef struct _PCI_CAPABILITIES_HEADER ;

#line 18600
typedef struct _PCI_PMC ;

#line 18618
typedef struct _PCI_PMCSR ;

#line 18628
typedef struct _PCI_PMCSR_BSE ;

#line 18635
typedef struct _PCI_PM_CAPABILITY ;

#line 18679
typedef struct _PCI_AGP_CAPABILITY ;

#line 18720
typedef struct _PCI_MSI_CAPABILITY ;

#line 18946
typedef void ;

#line 18954
typedef void ;

#line 18963
typedef void ;

#line 18975
typedef struct _PCIBUSDATA ;

#line 18986
typedef ULONG ;

#line 18995
typedef void ;

#line 19000
typedef void ;

#line 19006
typedef struct _PCI_BUS_INTERFACE_STANDARD ;

#line 19028
typedef BOOLEAN ;

#line 19043
typedef struct _PCI_DEVICE_PRESENT_INTERFACE ;

#line 127 "C:/NTDDK/inc/ntddser.h"
typedef struct _SERIALPERF_STATS ;

#line 136
typedef struct _SERIALCONFIG ;

#line 154
typedef struct _SERIAL_LINE_CONTROL ;

#line 160
typedef struct _SERIAL_TIMEOUTS ;

#line 175
typedef struct _SERIAL_QUEUE_SIZE ;

#line 185
typedef struct _SERIAL_BAUD_RATE ;

#line 247
typedef struct _SERIAL_CHARS ;

#line 284
typedef struct _SERIAL_HANDFLOW ;

#line 340
typedef struct _SERIAL_BASIC_SETTINGS ;

#line 353
typedef struct _SERIAL_STATUS ;

#line 433
typedef struct _SERIAL_XOFF_COUNTER ;

#line 539
typedef struct _SERIAL_COMMPROP ;

#line 631
typedef struct _SERENUM_PORT_DESC ;

#line 652
typedef UCHAR ;

#line 658
typedef void ;

#line 665
typedef enum _SERENUM_PORTION ;

#line 671
typedef struct _SERENUM_PORT_PARAMETERS ;

#line 28 "C:/NTDDK/inc/ddk/wdm/wmilib.h"

#pragma once
#line 38
typedef struct  {
	LPCGUID Guid ;
	ULONG InstanceCount ;
	ULONG Flags ;
} ;

#line 45
typedef NTSTATUS ;

#line 101
typedef NTSTATUS ;

#line 162
typedef NTSTATUS ;

#line 206
typedef NTSTATUS ;

#line 253
typedef NTSTATUS ;

#line 306
typedef enum  {
	WmiEventControl,
	WmiDataBlockControl
} ;

#line 312
typedef NTSTATUS ;

#line 355
typedef struct _WMILIB_CONTEXT ;

#line 411
typedef enum  {
	IrpProcessed,
	IrpNotCompleted,
	IrpNotWmi,
	IrpForward
} ;

#line 13 "C:/NTDDK/inc/wmidata.h"
typedef struct _MSWmi_MofData ;

#line 51
typedef struct _MSWmi_ProviderInfo ;

#line 66
typedef struct _MSWmi_PnPDeviceId ;

#line 83
typedef struct _MSWmi_PnPInstanceNames ;

#line 105
typedef struct _MSSmBios_RawSMBiosTables ;

#line 147
typedef struct _MSPower_DeviceEnable ;

#line 165
typedef struct _MSPower_DeviceWakeEnable ;

#line 182
typedef struct _MSNdis_NetworkAddress ;

#line 199
typedef struct _MSNdis_NetworkShortAddress ;

#line 216
typedef struct _MSNdis_NetworkLinkSpeed ;

#line 239
typedef struct _MSNdis_EnumerateAdapter ;

#line 256
typedef struct _MSNdis_NotifyAdapterRemoval ;

#line 273
typedef struct _MSNdis_NotifyAdapterArrival ;

#line 291
typedef struct _MSNdis_NdisEnumerateVc ;

#line 307
typedef struct _MSNdis_NotifyVcRemoval ;

#line 323
typedef struct _MSNdis_NotifyVcArrival ;

#line 338
typedef struct _MSNdis_HardwareStatus ;

#line 356
typedef struct _MSNdis_MediaSupported ;

#line 378
typedef struct _MSNdis_MediaInUse ;

#line 400
typedef struct _MSNdis_MaximumLookahead ;

#line 418
typedef struct _MSNdis_MaximumFrameSize ;

#line 436
typedef struct _MSNdis_LinkSpeed ;

#line 454
typedef struct _MSNdis_TransmitBufferSpace ;

#line 472
typedef struct _MSNdis_ReceiveBufferSpace ;

#line 490
typedef struct _MSNdis_TransmitBlockSize ;

#line 508
typedef struct _MSNdis_ReceiveBlockSize ;

#line 526
typedef struct _MSNdis_VendorID ;

#line 544
typedef struct _MSNdis_VendorDescription ;

#line 561
typedef struct _MSNdis_CurrentPacketFilter ;

#line 579
typedef struct _MSNdis_CurrentLookahead ;

#line 597
typedef struct _MSNdis_DriverVersion ;

#line 615
typedef struct _MSNdis_MaximumTotalSize ;

#line 633
typedef struct _MSNdis_MacOptions ;

#line 651
typedef struct _MSNdis_MediaConnectStatus ;

#line 669
typedef struct _MSNdis_MaximumSendPackets ;

#line 687
typedef struct _MSNdis_VendorDriverVersion ;

#line 705
typedef struct _MSNdis_TransmitsOk ;

#line 723
typedef struct _MSNdis_ReceivesOk ;

#line 741
typedef struct _MSNdis_TransmitsError ;

#line 759
typedef struct _MSNdis_ReceiveError ;

#line 777
typedef struct _MSNdis_ReceiveNoBuffer ;

#line 795
typedef struct _MSNdis_CoHardwareStatus ;

#line 813
typedef struct _MSNdis_CoMediaSupported ;

#line 835
typedef struct _MSNdis_CoMediaInUse ;

#line 857
typedef struct _MSNdis_CoLinkSpeed ;

#line 875
typedef struct _MSNdis_CoVendorId ;

#line 893
typedef struct _MSNdis_CoVendorDescription ;

#line 910
typedef struct _MSNdis_CoDriverVersion ;

#line 928
typedef struct _MSNdis_CoMacOptions ;

#line 946
typedef struct _MSNdis_CoMediaConnectStatus ;

#line 964
typedef struct _MSNdis_CoVendorDriverVersion ;

#line 982
typedef struct _MSNdis_CoMinimumLinkSpeed ;

#line 1000
typedef struct _MSNdis_CoTransmitPdusOk ;

#line 1018
typedef struct _MSNdis_CoReceivePdusOk ;

#line 1036
typedef struct _MSNdis_CoTransmitPduErrors ;

#line 1054
typedef struct _MSNdis_CoReceivePduErrors ;

#line 1072
typedef struct _MSNdis_CoReceivePdusNoBuffer ;

#line 1090
typedef struct _MSNdis_AtmSupportedVcRates ;

#line 1113
typedef struct _MSNdis_AtmSupportedServiceCategory ;

#line 1131
typedef struct _MSNdis_AtmSupportedAalTypes ;

#line 1149
typedef struct _MSNdis_AtmHardwareCurrentAddress ;

#line 1167
typedef struct _MSNdis_AtmMaxActiveVcs ;

#line 1185
typedef struct _MSNdis_AtmMaxActiveVciBits ;

#line 1203
typedef struct _MSNdis_AtmMaxActiveVpiBits ;

#line 1221
typedef struct _MSNdis_AtmMaxAal0PacketSize ;

#line 1239
typedef struct _MSNdis_AtmMaxAal1PacketSize ;

#line 1257
typedef struct _MSNdis_AtmMaxAal34PacketSize ;

#line 1275
typedef struct _MSNdis_AtmMaxAal5PacketSize ;

#line 1293
typedef struct _MSNdis_AtmReceiveCellsOk ;

#line 1311
typedef struct _MSNdis_AtmTransmitCellsOk ;

#line 1329
typedef struct _MSNdis_AtmReceiveCellsDropped ;

#line 1347
typedef struct _MSNdis_EthernetPermanentAddress ;

#line 1365
typedef struct _MSNdis_EthernetCurrentAddress ;

#line 1383
typedef struct _MSNdis_EthernetMulticastList ;

#line 1405
typedef struct _MSNdis_EthernetMaximumMulticastListSize ;

#line 1423
typedef struct _MSNdis_EthernetMacOptions ;

#line 1441
typedef struct _MSNdis_EthernetReceiveErrorAlignment ;

#line 1459
typedef struct _MSNdis_EthernetOneTransmitCollision ;

#line 1477
typedef struct _MSNdis_EthernetMoreTransmitCollisions ;

#line 1495
typedef struct _MSNdis_TokenRingPermanentAddress ;

#line 1513
typedef struct _MSNdis_TokenRingCurrentAddress ;

#line 1531
typedef struct _MSNdis_TokenRingCurrentFunctional ;

#line 1549
typedef struct _MSNdis_TokenRingCurrentGroup ;

#line 1567
typedef struct _MSNdis_TokenRingLastOpenStatus ;

#line 1585
typedef struct _MSNdis_TokenRingCurrentRingStatus ;

#line 1603
typedef struct _MSNdis_TokenRingCurrentRingState ;

#line 1621
typedef struct _MSNdis_TokenRingLineErrors ;

#line 1639
typedef struct _MSNdis_TokenRingLostFrames ;

#line 1657
typedef struct _MSNdis_FddiLongPermanentAddress ;

#line 1675
typedef struct _MSNdis_FddiLongCurrentAddress ;

#line 1693
typedef struct _MSNdis_FddiLongMulticastList ;

#line 1715
typedef struct _MSNdis_FddiLongMaximumListSize ;

#line 1733
typedef struct _MSNdis_FddiShortPermanentAddress ;

#line 1751
typedef struct _MSNdis_FddiShortCurrentAddress ;

#line 1769
typedef struct _MSNdis_FddiShortMulticastList ;

#line 1791
typedef struct _MSNdis_FddiShortMaximumListSize ;

#line 1809
typedef struct _MSNdis_FddiAttachmentType ;

#line 1827
typedef struct _MSNdis_FddiUpstreamNodeLong ;

#line 1845
typedef struct _MSNdis_FddiDownstreamNodeLong ;

#line 1863
typedef struct _MSNdis_FddiFrameErrors ;

#line 1881
typedef struct _MSNdis_FddiFramesLost ;

#line 1899
typedef struct _MSNdis_FddiRingManagmentState ;

#line 1917
typedef struct _MSNdis_FddiLctFailures ;

#line 1935
typedef struct _MSNdis_FddiLemRejects ;

#line 1953
typedef struct _MSNdis_FddiLConnectionState ;

#line 1972
typedef struct _MSNdis_StatusResetStart ;

#line 1988
typedef struct _MSNdis_StatusResetEnd ;

#line 2004
typedef struct _MSNdis_StatusMediaConnect ;

#line 2020
typedef struct _MSNdis_StatusMediaDisconnect ;

#line 2035
typedef struct _MSNdis_StatusMediaSpecificIndication ;

#line 2057
typedef struct _MSNdis_StatusLinkSpeedChange ;

#line 2075
typedef struct _MSNdis_StatusProtocolBind ;

#line 2092
typedef struct _MSNdis_StatusProtocolUnbind ;

#line 2109
typedef struct _KEYBOARD_PORT_WMI_STD_DATA ;

#line 2152
typedef struct _POINTER_PORT_WMI_STD_DATA ;

#line 2205
typedef struct _MSMouse_ClassInformation ;

#line 2223
typedef struct _MSKeyboard_ClassInformation ;

#line 2241
typedef struct _MSAcpi_ThermalZoneTemperature ;

#line 2304
typedef struct _WMI_DISK_GEOMETRY ;

#line 2342
typedef struct _WMI_DISK_PERFORMANCE ;

#line 2415
typedef struct _MSDiskDriver_Performance ;

#line 2437
typedef struct _STORAGE_FAILURE_PREDICT_STATUS ;

#line 2460
typedef struct _STORAGE_FAILURE_PREDICT_DATA ;

#line 2483
typedef struct _STORAGE_FAILURE_PREDICT_EVENT ;

#line 2513
typedef struct _STORAGE_FAILURE_PREDICT_FUNCTION ;

#line 2528
typedef struct _MSIde_PortDeviceInfo ;

#line 2556
typedef struct _MSSerial_PortName ;

#line 2573
typedef struct _SERIAL_WMI_COMM_DATA ;

#line 2723
typedef struct _SERIAL_WMI_HW_DATA ;

#line 2770
typedef struct _SERIAL_WMI_PERF_DATA ;

#line 2813
typedef struct _SERIAL_WMI_COMMPROP ;

#line 2920
typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS ;

#line 2943
typedef struct _PARALLEL_WMI_LOG_INFO ;

#line 3041
typedef struct _REDBOOK_WMI_STD_DATA ;

#line 3094
typedef struct _REDBOOK_WMI_PERF_DATA ;

#line 3137
typedef struct _RegisteredGuids ;

#line 475 "serial.h"
typedef struct _CONFIG_DATA ;

#line 509
typedef struct _SERIAL_CISR_SW ;

#line 520
typedef struct _SERIAL_FIRMWARE_DATA ;

#line 576
typedef struct _SERIAL_DEVICE_STATE ;

#line 646
typedef struct _SERIAL_DEVICE_EXTENSION ;

#line 1808
typedef struct _SERIAL_MULTIPORT_DISPATCH ;

#line 2157
typedef enum _SERIAL_MEM_COMPARES ;

#line 2164
typedef struct _SERIAL_LIST_DATA ;

#line 2169
typedef struct _SERIAL_GLOBALS ;

#line 2180
typedef struct _SERIAL_USER_DATA ;

#line 2206
typedef struct _SERIAL_PTR_CTX ;

#line 20 "serialp.h"
typedef NTSTATUS ;

#line 26
typedef void ;

#line 835
typedef struct _SERIAL_UPDATE_CHAR ;

#line 846
typedef struct _SERIAL_IOCTL_SYNC ;

#line 24 "C:/NTDDK/inc/wmistr.h"

#pragma warning(disable:4200)
#line 28
typedef struct _WNODE_HEADER {
	ULONG BufferSize ;
	ULONG ProviderId ;
	union  {
		ULONG64 HistoricalContext ;
		struct  {
			ULONG Version ;
			ULONG Linkage ;
		}  ;
	}  ;
	union  {
		ULONG CountLost ;
		HANDLE KernelHandle ;
		LARGE_INTEGER TimeStamp ;
	}  ;
	GUID Guid ;
	ULONG ClientContext ;
	ULONG Flags ;
} WNODE_HEADER , *  PWNODE_HEADER ;

#line 124
typedef struct  {
	ULONG OffsetInstanceData ;
	ULONG LengthInstanceData ;
} OFFSETINSTANCEDATAANDLENGTH , *  POFFSETINSTANCEDATAANDLENGTH ;

#line 131
typedef struct tagWNODE_ALL_DATA {
	struct _WNODE_HEADER WnodeHeader ;
	ULONG DataBlockOffset ;
	ULONG InstanceCount ;
	ULONG OffsetInstanceNameOffsets ;
	union  {
		ULONG FixedInstanceSize ;
		OFFSETINSTANCEDATAANDLENGTH OffsetInstanceDataAndLength[] ;
	}  ;
} WNODE_ALL_DATA , *  PWNODE_ALL_DATA ;

#line 163
typedef struct tagWNODE_SINGLE_INSTANCE {
	struct _WNODE_HEADER WnodeHeader ;
	ULONG OffsetInstanceName ;
	ULONG InstanceIndex ;
	ULONG DataBlockOffset ;
	ULONG SizeDataBlock ;
	UCHAR VariableData[] ;
} WNODE_SINGLE_INSTANCE , *  PWNODE_SINGLE_INSTANCE ;

#line 187
typedef struct tagWNODE_SINGLE_ITEM {
	struct _WNODE_HEADER WnodeHeader ;
	ULONG OffsetInstanceName ;
	ULONG InstanceIndex ;
	ULONG ItemId ;
	ULONG DataBlockOffset ;
	ULONG SizeDataItem ;
	UCHAR VariableData[] ;
} WNODE_SINGLE_ITEM , *  PWNODE_SINGLE_ITEM ;

#line 212
typedef struct tagWNODE_METHOD_ITEM {
	struct _WNODE_HEADER WnodeHeader ;
	ULONG OffsetInstanceName ;
	ULONG InstanceIndex ;
	ULONG MethodId ;
	ULONG DataBlockOffset ;
	ULONG SizeDataBlock ;
	UCHAR VariableData[] ;
} WNODE_METHOD_ITEM , *  PWNODE_METHOD_ITEM ;

#line 242
typedef struct tagWNODE_EVENT_ITEM {
	struct _WNODE_HEADER WnodeHeader ;
} WNODE_EVENT_ITEM , *  PWNODE_EVENT_ITEM ;

#line 260
typedef struct tagWNODE_EVENT_REFERENCE {
	struct _WNODE_HEADER WnodeHeader ;
	GUID TargetGuid ;
	ULONG TargetDataBlockSize ;
	union  {
		ULONG TargetInstanceIndex ;
		WCHAR TargetInstanceName[] ;
	}  ;
} WNODE_EVENT_REFERENCE , *  PWNODE_EVENT_REFERENCE ;

#line 273
typedef struct tagWNODE_TOO_SMALL {
	struct _WNODE_HEADER WnodeHeader ;
	ULONG SizeNeeded ;
} WNODE_TOO_SMALL , *  PWNODE_TOO_SMALL ;

#line 280
typedef struct  {
	GUID Guid ;
	ULONG Flags ;
	ULONG InstanceCount ;
	union  {
		ULONG InstanceNameList ;
		ULONG BaseNameOffset ;
		ULONG_PTR Pdo ;
		ULONG_PTR InstanceInfo ;
	}  ;
} WMIREGGUIDW , *  PWMIREGGUIDW ;

#line 313
typedef WMIREGGUIDW WMIREGGUID ;

#line 314
typedef PWMIREGGUIDW PWMIREGGUID ;

#line 359
typedef struct  {
	ULONG BufferSize ;
	ULONG NextWmiRegInfo ;
	ULONG RegistryPath ;
	ULONG MofResourceName ;
	ULONG GuidCount ;
	WMIREGGUIDW WmiRegGuid[] ;
} WMIREGINFOW , *  PWMIREGINFOW ;

#line 385
typedef WMIREGINFOW WMIREGINFO ;

#line 386
typedef PWMIREGINFOW PWMIREGINFO ;

#line 390
typedef enum  {
	WMI_GET_ALL_DATA = 0,
	WMI_GET_SINGLE_INSTANCE = 1,
	WMI_SET_SINGLE_INSTANCE = 2,
	WMI_SET_SINGLE_ITEM = 3,
	WMI_ENABLE_EVENTS = 4,
	WMI_DISABLE_EVENTS = 5,
	WMI_ENABLE_COLLECTION = 6,
	WMI_DISABLE_COLLECTION = 7,
	WMI_REGINFO = 8,
	WMI_EXECUTE_METHOD = 9
} WMIDPREQUESTCODE ;

#line 25 "wmi.c"

#pragma alloc_text(PAGESRP0, SerialSystemControlDispatch)
#line 26

#pragma alloc_text(PAGESRP0, SerialTossWMIRequest)
#line 27

#pragma alloc_text(PAGESRP0, SerialSetWmiDataItem)
#line 28

#pragma alloc_text(PAGESRP0, SerialSetWmiDataBlock)
#line 29

#pragma alloc_text(PAGESRP0, SerialQueryWmiDataBlock)
#line 30

#pragma alloc_text(PAGESRP0, SerialQueryWmiRegInfo)
#line 34
NTSTATUS SerialSystemControlDispatch(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
	#line 37
	SYSCTL_IRP_DISPOSITION disposition ;
	NTSTATUS status ;
	PSERIAL_DEVICE_EXTENSION pDevExt = (PSERIAL_DEVICE_EXTENSION
		)DeviceObject->DeviceExtension;
	#line 42
	;
	#line 44
	status = WmiSystemControl(& pDevExt->WmiLibInfo, DeviceObject, Irp, &
		disposition);
	#line 48
	switch(disposition)
	{
	case IrpProcessed:
			#line 50
			;
		{
			#line 54
			break;
		}
		#line 57
	case IrpNotCompleted:
			#line 57
			;
		{
			#line 62
			IofCompleteRequest(Irp, 0);
			break;
		}
		#line 66
	case IrpForward:
			#line 66
			;
	case IrpNotWmi:
			#line 67
			;
		{
			#line 72
			if(s == NP)
				#line 72
				s = SKIP1;
			else
				#line 72
				errorFn();
			Irp->CurrentLocation++;
			#line 73
			((Irp->Tail).Overlay).CurrentStackLocation++;
			#line 73
			;
			status = IofCallDriver(pDevExt->LowerDeviceObject, Irp);
			break;
		}
		#line 78
	default :
			#line 78
			;
		{
			#line 82
			;
			if(s == NP)
				#line 83
				s = SKIP1;
			else
				#line 83
				errorFn();
			Irp->CurrentLocation++;
			#line 84
			((Irp->Tail).Overlay).CurrentStackLocation++;
			#line 84
			;
			status = IofCallDriver(pDevExt->LowerDeviceObject, Irp);
			break;
		}
	}
	#line 90
	return status;
}

#line 101
GUID SerialPortNameGuid = {0xa0ec11a8, 0xb16c, 0x11d1, {0xbd, 0x98, 0x00, 0xa0,
	0xc9, 0x06, 0xbe, 0x2d}};
#line 102
GUID SerialPortCommGuid = {0xedb16a62, 0xb16c, 0x11d1, {0xbd, 0x98, 0x00, 0xa0,
	0xc9, 0x06, 0xbe, 0x2d}};
#line 103
GUID SerialPortHWGuid = {0x270b9b86, 0xb16d, 0x11d1, {0xbd, 0x98, 0x00, 0xa0,
	0xc9, 0x06, 0xbe, 0x2d}};
#line 104
GUID SerailPortPerfGuid = {0x56415acc, 0xb16d, 0x11d1, {0xbd, 0x98, 0x00, 0xa0,
	0xc9, 0x06, 0xbe, 0x2d}};
#line 105
GUID SerialPortPropertiesGuid = {0x8209ec2a, 0x2d6b, 0x11d2, {0xba, 0x49, 0x00,
	0xa0, 0xc9, 0x06, 0x29, 0x10}};
WMIGUIDREGINFO SerialWmiGuidList[5] = {{& SerialPortNameGuid, 1, 0}, {&
	SerialPortCommGuid, 1, 0}, {& SerialPortHWGuid, 1, 0}, {&
	SerailPortPerfGuid, 1, 0}, {& SerialPortPropertiesGuid, 1, 0}};

#line 122
NTSTATUS SerialTossWMIRequest(PDEVICE_OBJECT PDevObj , PIRP PIrp , ULONG
	GuidIndex )
{
	#line 126
	PSERIAL_DEVICE_EXTENSION pDevExt ;
	NTSTATUS status ;
	#line 129
	;
	#line 131
	pDevExt = (PSERIAL_DEVICE_EXTENSION )PDevObj->DeviceExtension;
	#line 133
	switch(GuidIndex)
	{
	case 0:
			#line 135
			;
	case 1:
			#line 136
			;
	case 2:
			#line 137
			;
	case 3:
			#line 138
			;
	case 4:
			#line 139
			;
		status = (NTSTATUS )0xC0000010L;
		break;
		#line 143
	default :
			#line 143
			;
		status = (NTSTATUS )0xC0000295L;
		break;
	}
	#line 148
	status = WmiCompleteRequest(PDevObj, PIrp, status, 0, 0);
	#line 151
	return status;
}

#line 155
NTSTATUS SerialSetWmiDataItem(PDEVICE_OBJECT PDevObj , PIRP PIrp , ULONG
	GuidIndex , ULONG InstanceIndex , ULONG DataItemId , ULONG BufferSize ,
	PUCHAR PBuffer )
{
	#line 194
	;
	#line 200
	return SerialTossWMIRequest(PDevObj, PIrp, GuidIndex);
}

#line 204
NTSTATUS SerialSetWmiDataBlock(PDEVICE_OBJECT PDevObj , PIRP PIrp , ULONG
	GuidIndex , ULONG InstanceIndex , ULONG BufferSize , PUCHAR PBuffer )
{
	#line 241
	;
	#line 247
	return SerialTossWMIRequest(PDevObj, PIrp, GuidIndex);
}

#line 251
NTSTATUS SerialQueryWmiDataBlock(PDEVICE_OBJECT PDevObj , PIRP PIrp , ULONG
	GuidIndex , ULONG InstanceIndex , ULONG InstanceCount , PULONG
	InstanceLengthArray , ULONG OutBufferSize , PUCHAR PBuffer )
{
	#line 300
	NTSTATUS status ;
	ULONG size = 0;
	PSERIAL_DEVICE_EXTENSION pDevExt = (PSERIAL_DEVICE_EXTENSION
		)PDevObj->DeviceExtension;
	#line 305
	;
	#line 307
	switch(GuidIndex)
	{
		#line 308
	case 0:
			#line 308
			;
		size = (pDevExt->WmiIdentifier).Length;
		#line 311
		if(OutBufferSize < size + sizeof(USHORT ))
		{
			#line 312
			size += sizeof(USHORT );
			status = (NTSTATUS )0xC0000023L;
			break;
		}
		#line 317
		if((pDevExt->WmiIdentifier).Buffer == (void *  )0)
		{
			#line 318
			status = (NTSTATUS )0xC000009AL;
			break;
		}
		#line 326
		* (USHORT *  )PBuffer = (USHORT )size;
		(UCHAR *  )PBuffer += sizeof(USHORT );
		#line 329
		memcpy(PBuffer, (pDevExt->WmiIdentifier).Buffer, size);
		#line 335
		size += sizeof(USHORT );
		* InstanceLengthArray = size;
		#line 338
		status = (NTSTATUS )0x00000000L;
		#line 340
		break;
		#line 342
	case 1:
			#line 342
			;
		size = sizeof(SERIAL_WMI_COMM_DATA );
		#line 345
		if(OutBufferSize < size)
		{
			#line 346
			status = (NTSTATUS )0xC0000023L;
			break;
		}
		#line 350
		* InstanceLengthArray = size;
		* (PSERIAL_WMI_COMM_DATA )PBuffer = pDevExt->WmiCommData;
		#line 353
		status = (NTSTATUS )0x00000000L;
		#line 355
		break;
		#line 357
	case 2:
			#line 357
			;
		size = sizeof(SERIAL_WMI_HW_DATA );
		#line 360
		if(OutBufferSize < size)
		{
			#line 361
			status = (NTSTATUS )0xC0000023L;
			break;
		}
		#line 365
		* InstanceLengthArray = size;
		* (PSERIAL_WMI_HW_DATA )PBuffer = pDevExt->WmiHwData;
		#line 368
		status = (NTSTATUS )0x00000000L;
		#line 370
		break;
		#line 372
	case 3:
			#line 372
			;
		size = sizeof(SERIAL_WMI_PERF_DATA );
		#line 375
		if(OutBufferSize < size)
		{
			#line 376
			status = (NTSTATUS )0xC0000023L;
			break;
		}
		#line 380
		* InstanceLengthArray = size;
		* (PSERIAL_WMI_PERF_DATA )PBuffer = pDevExt->WmiPerfData;
		#line 383
		status = (NTSTATUS )0x00000000L;
		#line 385
		break;
		#line 387
	case 4:
			#line 387
			;
		size = sizeof(SERIAL_COMMPROP ) + sizeof(ULONG );
		#line 390
		if(OutBufferSize < size)
		{
			#line 391
			status = (NTSTATUS )0xC0000023L;
			break;
		}
		#line 395
		* InstanceLengthArray = size;
		SerialGetProperties(pDevExt, (PSERIAL_COMMPROP )PBuffer);
		#line 401
		* (PULONG )((PSERIAL_COMMPROP )PBuffer)->ProvChar = 0;
		#line 403
		status = (NTSTATUS )0x00000000L;
		#line 405
		break;
		#line 407
	default :
			#line 407
			;
		status = (NTSTATUS )0xC0000295L;
		break;
	}
	#line 412
	status = WmiCompleteRequest(PDevObj, PIrp, status, size, 0);
	#line 415
	return status;
}

#line 419
NTSTATUS SerialQueryWmiRegInfo(PDEVICE_OBJECT PDevObj , PULONG PRegFlags ,
	PUNICODE_STRING PInstanceName , PUNICODE_STRING *  PRegistryPath ,
	PUNICODE_STRING MofResourceName , PDEVICE_OBJECT *  Pdo )
{
	#line 471
	PSERIAL_DEVICE_EXTENSION pDevExt = (PSERIAL_DEVICE_EXTENSION
		)PDevObj->DeviceExtension;
	#line 474
	;
	#line 476
	* PRegFlags = 0x00000020;
	* PRegistryPath = & SerialGlobals.RegistryPath;
	* Pdo = pDevExt->Pdo;
	#line 480
	return (NTSTATUS )0x00000000L;
}

#line 16 "C:/NTDDK/inc/stddef.h"

#pragma once
#line 77
typedef int ;

#line 86
typedef unsigned int ;

#line 95
typedef int ;

#line 105
typedef unsigned int ;

#line 112
typedef unsigned short ;

#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"

#pragma once
#line 32

#pragma pack(push, 8)
#line 72
typedef enum _EXCEPTION_DISPOSITION ;

#line 89
struct _EXCEPTION_RECORD ;

#line 90
struct _CONTEXT ;

#line 155

#pragma pack(pop)
#line 25 "C:/NTDDK/inc/ntdef.h"

#pragma once
#line 15 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"

#pragma once
#line 66
typedef wchar_t ;

#line 67
typedef wchar_t ;

#line 127 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long ;

#line 25 "C:/NTDDK/inc/basetsd.h"

#pragma once
#line 36
typedef int ;

#line 37
typedef int ;

#line 43
typedef unsigned int ;

#line 44
typedef unsigned int ;

#line 45
typedef unsigned int ;

#line 84
typedef int ;

#line 85
typedef unsigned int ;

typedef long ;

#line 88
typedef unsigned long ;

#line 248
typedef unsigned short ;

#line 249
typedef short ;

#line 250
typedef unsigned long ;

#line 288
typedef ULONG_PTR ;

#line 289
typedef LONG_PTR ;

#line 295
typedef ULONG_PTR ;

#line 301
typedef __int64 ;

#line 302
typedef __int64 ;

#line 309
typedef unsigned __int64 ;

#line 310
typedef unsigned __int64 ;

#line 311
typedef unsigned __int64 ;

#line 217 "C:/NTDDK/inc/ntdef.h"
typedef void ;

#line 218
typedef void ;

#line 266
typedef char ;

#line 267
typedef short ;

#line 268
typedef long ;

#line 276
typedef wchar_t ;

#line 282
typedef WCHAR ;

#line 283
typedef WCHAR ;

#line 284
typedef const WCHAR ;

#line 285
typedef WCHAR ;

#line 286
typedef WCHAR ;

typedef const WCHAR ;

#line 293
typedef CHAR ;

#line 294
typedef CHAR ;

typedef const CHAR ;

#line 297
typedef CHAR ;

#line 298
typedef CHAR ;

#line 299
typedef const CHAR ;

#line 321
typedef char ;

#line 322
typedef unsigned char ;

#line 326
typedef LPSTR ;

#line 327
typedef LPSTR ;

#line 328
typedef LPCSTR ;

#line 337
typedef double ;

typedef struct _QUAD ;

#line 349
typedef SHORT ;

#line 350
typedef LONG ;

#line 351
typedef QUAD ;

#line 360
typedef unsigned char ;

#line 361
typedef unsigned short ;

#line 362
typedef unsigned long ;

#line 363
typedef QUAD ;

#line 369
typedef UCHAR ;

#line 370
typedef USHORT ;

#line 371
typedef ULONG ;

#line 372
typedef UQUAD ;

#line 378
typedef signed char ;

#line 379
typedef SCHAR ;

#line 394
typedef void ;

#line 400
typedef HANDLE ;

#line 406
typedef UCHAR ;

#line 407
typedef USHORT ;

#line 408
typedef ULONG ;

#line 414
typedef LONG ;

#line 478
typedef char ;

#line 479
typedef short ;

#line 480
typedef ULONG ;

typedef CCHAR ;

#line 483
typedef CSHORT ;

#line 484
typedef CLONG ;

#line 492
typedef ULONG ;

#line 493
typedef PULONG ;

#line 494
typedef USHORT ;

#line 500
typedef ULONG ;

#line 501
typedef ULONG ;

#line 508
typedef LONG ;

typedef NTSTATUS ;

#line 602
typedef struct _FLOAT128 ;

#line 607
typedef FLOAT128 ;

#line 621
typedef __int64 ;

#line 622
typedef unsigned __int64 ;

#line 639
typedef LONGLONG ;

#line 640
typedef ULONGLONG ;

#line 644
typedef LONGLONG ;

#line 649
typedef union _LARGE_INTEGER ;

#line 662
typedef LARGE_INTEGER ;

#line 668
typedef union _ULARGE_INTEGER ;

#line 681
typedef ULARGE_INTEGER ;

#line 690
typedef struct _LUID ;

#line 696
typedef ULONGLONG ;

#line 697
typedef DWORDLONG ;

#line 707
typedef LARGE_INTEGER ;

#line 831

#pragma warning(push)

#pragma warning(disable:4035)
__inline ULONGLONG __stdcall Int64ShllMod32___18(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 842
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    
		};
}

#line 845
__inline LONGLONG __stdcall Int64ShraMod32___18(LONGLONG Value , ULONG
	ShiftCount )
{
	#line 852
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    
		};
}

#line 855
__inline ULONGLONG __stdcall Int64ShrlMod32___18(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 862
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    
		};
}


#pragma warning(pop)
#line 956
typedef enum _EVENT_TYPE ;

#line 965
typedef enum _TIMER_TYPE ;

#line 974
typedef enum _WAIT_TYPE ;

#line 983
typedef CHAR ;

#line 984
typedef const char ;

#line 991
typedef struct _STRING ;

#line 999
typedef STRING ;

typedef STRING ;

#line 1002
typedef PSTRING ;

typedef STRING ;

#line 1005
typedef PSTRING ;

#line 1011
typedef struct _CSTRING ;

#line 1016
typedef CSTRING ;

#line 1019
typedef STRING ;

#line 1020
typedef PSTRING ;

#line 1027
typedef struct _UNICODE_STRING ;

#line 1036
typedef UNICODE_STRING ;

#line 1037
typedef const UNICODE_STRING ;

#line 1046
typedef UCHAR ;

#line 1047
typedef BOOLEAN ;

#line 1057
typedef struct _LIST_ENTRY ;

#line 1067
typedef struct _SINGLE_LIST_ENTRY ;

#line 1078
typedef struct LIST_ENTRY32 ;

#line 1082
typedef LIST_ENTRY32 ;

typedef struct LIST_ENTRY64 ;

#line 1088
typedef LIST_ENTRY64 ;

#line 1127
typedef struct _STRING32 ;

#line 1132
typedef STRING32 ;

typedef STRING32 ;

#line 1135
typedef UNICODE_STRING32 ;

typedef STRING32 ;

#line 1138
typedef ANSI_STRING32 ;

#line 1141
typedef struct _STRING64 ;

#line 1146
typedef STRING64 ;

typedef STRING64 ;

#line 1149
typedef UNICODE_STRING64 ;

typedef STRING64 ;

#line 1152
typedef ANSI_STRING64 ;

#line 1173
typedef struct _OBJECT_ATTRIBUTES ;

#line 1181
typedef OBJECT_ATTRIBUTES ;

#line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID ;

#line 70
typedef GUID ;

#line 75
typedef const GUID ;

#line 81
typedef GUID ;

#line 82
typedef IID ;

#line 85
typedef GUID ;

#line 86
typedef CLSID ;

#line 89
typedef GUID ;

#line 90
typedef FMTID ;

#line 16 "C:/NTDDK/inc/string.h"

#pragma once
#line 1233 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECTID ;

#line 1288
struct _CONTEXT ;

#line 1289
struct _EXCEPTION_RECORD ;

typedef EXCEPTION_DISPOSITION ;

#line 1306
typedef UCHAR ;

typedef KIRQL ;

#line 1316
typedef enum _NT_PRODUCT_TYPE ;

#line 1329
typedef enum _SUITE_TYPE ;

#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD ;

#line 76
typedef struct _ETHREAD ;

#line 77
typedef struct _EPROCESS ;

#line 78
typedef struct _PEB ;

#line 79
typedef struct _KINTERRUPT ;

#line 80
typedef struct _IO_TIMER ;

#line 81
typedef struct _OBJECT_TYPE ;

#line 82
typedef struct _CALLBACK_OBJECT ;

#line 83
typedef struct _DEVICE_HANDLER_OBJECT ;

#line 84
typedef struct _BUS_HANDLER ;

#line 143
typedef union _SLIST_HEADER ;

#line 204
typedef CCHAR ;

typedef enum _MODE ;

#line 222
struct _KAPC ;

typedef void ;

#line 232
typedef void ;

#line 242
typedef void ;

#line 248
typedef BOOLEAN ;

#line 254
typedef BOOLEAN ;

#line 265
typedef struct _KAPC ;

#line 292
struct _KDPC ;

typedef void ;

#line 351
typedef enum _KDPC_IMPORTANCE ;

#line 361
typedef struct _KDPC ;

#line 377
typedef PVOID ;

typedef void ;

#line 392
typedef struct _KIPI_COUNTS ;

#line 443
typedef struct _MDL ;

#line 532
typedef PVOID ;

#line 538
typedef PVOID ;

#line 544
typedef PVOID ;

typedef ULONG ;

#line 547
typedef ACCESS_MASK ;

#line 597
typedef struct _GENERIC_MAPPING ;

#line 603
typedef GENERIC_MAPPING ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES ;

#line 622
typedef LUID_AND_ATTRIBUTES ;

#line 623
typedef LUID_AND_ATTRIBUTES_ARRAY ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 642 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACL ;

#line 649
typedef ACL ;

#line 681
typedef struct _PRIVILEGE_SET ;

#line 735
typedef enum _SECURITY_IMPERSONATION_LEVEL ;

#line 753
typedef BOOLEAN ;

#line 762
typedef struct _SECURITY_QUALITY_OF_SERVICE ;

#line 774
typedef struct _SE_IMPERSONATION_STATE ;

#line 782
typedef ULONG ;

#line 809
typedef ULONG ;

#line 810
typedef KAFFINITY ;

#line 816
typedef LONG ;

#line 824
typedef ULONG_PTR ;

#line 825
typedef KSPIN_LOCK ;

#line 833
typedef void ;

#line 842
typedef enum _KPROFILE_SOURCE ;

#line 1079
typedef NTSTATUS ;

#line 1088
typedef struct _RTL_QUERY_REGISTRY_TABLE ;

#line 1952

#pragma warning(push)

#pragma warning(disable:4035)
#line 2019

#pragma warning(pop)
#line 2214
typedef struct _TIME_FIELDS ;

#line 2224
typedef TIME_FIELDS ;

#line 2499
typedef struct _RTL_BITMAP ;

#line 2503
typedef RTL_BITMAP ;

#line 2627
typedef struct _RTL_BITMAP_RUN ;

#line 2633
typedef RTL_BITMAP_RUN ;

#line 2886
typedef struct _RTL_RANGE ;

#line 2924
typedef struct _RTL_RANGE_LIST ;

#line 2950
typedef struct _RANGE_LIST_ITERATOR ;

#line 3019
typedef BOOLEAN ;

#line 3155
typedef struct _OSVERSIONINFOA ;

#line 3164
typedef struct _OSVERSIONINFOW ;

#line 3177
typedef OSVERSIONINFOA ;

#line 3178
typedef POSVERSIONINFOA ;

#line 3179
typedef LPOSVERSIONINFOA ;

#line 3182
typedef struct _OSVERSIONINFOEXA ;

#line 3195
typedef struct _OSVERSIONINFOEXW ;

#line 3213
typedef OSVERSIONINFOEXA ;

#line 3214
typedef POSVERSIONINFOEXA ;

#line 3215
typedef LPOSVERSIONINFOEXA ;

#line 3648
typedef struct _IO_STATUS_BLOCK ;

#line 3669
typedef void ;

#line 3685
typedef enum _FILE_INFORMATION_CLASS ;

#line 3731
typedef struct _FILE_BASIC_INFORMATION ;

#line 3739
typedef struct _FILE_STANDARD_INFORMATION ;

#line 3747
typedef struct _FILE_POSITION_INFORMATION ;

#line 3751
typedef struct _FILE_ALIGNMENT_INFORMATION ;

#line 3755
typedef struct _FILE_NAME_INFORMATION ;

#line 3760
typedef struct _FILE_NETWORK_OPEN_INFORMATION ;

#line 3770
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION ;

#line 3775
typedef struct _FILE_DISPOSITION_INFORMATION ;

#line 3779
typedef struct _FILE_END_OF_FILE_INFORMATION ;

#line 3784
typedef struct _FILE_FULL_EA_INFORMATION ;

#line 3798
typedef enum _FSINFOCLASS ;

#line 3810
typedef struct _FILE_FS_DEVICE_INFORMATION ;

#line 3820
typedef union _FILE_SEGMENT_ELEMENT ;

#line 3829
typedef enum _INTERFACE_TYPE ;

#line 3854
typedef enum _DMA_WIDTH ;

#line 3865
typedef enum _DMA_SPEED ;

#line 3879
typedef void ;

#line 3880
typedef void ;

#line 3888
typedef enum _BUS_DATA_TYPE ;

#line 3910
typedef struct _IO_ERROR_LOG_PACKET ;

#line 3931
typedef struct _IO_ERROR_LOG_MESSAGE ;

#line 4074
typedef struct _KEY_BASIC_INFORMATION ;

#line 4081
typedef struct _KEY_NODE_INFORMATION ;

#line 4091
typedef struct _KEY_FULL_INFORMATION ;

#line 4106
typedef struct _KEY_NAME_INFORMATION ;

#line 4112
typedef enum _KEY_INFORMATION_CLASS ;

#line 4122
typedef struct _KEY_WRITE_TIME_INFORMATION ;

#line 4126
typedef enum _KEY_SET_INFORMATION_CLASS ;

#line 4134
typedef struct _KEY_VALUE_BASIC_INFORMATION ;

#line 4141
typedef struct _KEY_VALUE_FULL_INFORMATION ;

#line 4151
typedef struct _KEY_VALUE_PARTIAL_INFORMATION ;

#line 4158
typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ;

#line 4164
typedef struct _KEY_VALUE_ENTRY ;

#line 4171
typedef enum _KEY_VALUE_INFORMATION_CLASS ;

#line 4210
typedef struct _OBJECT_NAME_INFORMATION ;

#line 4221
typedef enum _SECTION_INHERIT ;

#line 4294
typedef struct _CLIENT_ID ;

#line 4298
typedef CLIENT_ID ;

#line 4315
typedef struct _NT_TIB ;

#line 4327
typedef NT_TIB ;

#line 4332
typedef enum _PROCESSINFOCLASS ;

#line 4366
typedef enum _THREADINFOCLASS ;

#line 4395
typedef struct _PROCESS_WS_WATCH_INFORMATION ;

#line 4405
typedef struct _PROCESS_BASIC_INFORMATION ;

#line 4413
typedef PROCESS_BASIC_INFORMATION ;

#line 4422
typedef struct _PROCESS_DEVICEMAP_INFORMATION ;

#line 4440
typedef struct _PROCESS_SESSION_INFORMATION ;

#line 4454
typedef struct _QUOTA_LIMITS ;

#line 4462
typedef QUOTA_LIMITS ;

#line 4472
typedef struct _IO_COUNTERS ;

#line 4480
typedef IO_COUNTERS ;

#line 4488
typedef struct _VM_COUNTERS ;

#line 4501
typedef VM_COUNTERS ;

#line 4508
typedef struct _POOLED_USAGE_AND_LIMITS ;

#line 4519
typedef POOLED_USAGE_AND_LIMITS ;

#line 4528
typedef struct _PROCESS_ACCESS_TOKEN ;

#line 4555
typedef struct _KERNEL_USER_TIMES ;

#line 4561
typedef KERNEL_USER_TIMES ;

#line 4587
typedef enum _SYSTEM_POWER_STATE ;

#line 4598
typedef enum  {
	PowerActionNone = 0,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
} ;

typedef enum _DEVICE_POWER_STATE ;

#line 4618
typedef union _POWER_STATE ;

#line 4623
typedef enum _POWER_STATE_TYPE ;

#line 4654
typedef ULONG ;

typedef enum  {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
} ;

#line 4663
typedef enum  {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation
} ;

#line 4690
typedef ULONG ;

typedef LONG ;

#line 4693
typedef ULONG ;

#line 4719
typedef union _MCI_STATS ;

#line 4978
typedef struct _KPCR ;

#line 5006
typedef KPCR ;

#line 5012
typedef struct _KFLOATING_SAVE ;

#line 5153
typedef enum _INTERLOCKED_RESULT ;

#line 5252

#pragma warning(disable:4035)
#line 6994
typedef struct _KSYSTEM_TIME ;

#line 7014

#pragma warning(push)

#pragma warning(disable:4164)
#line 7019

#pragma function(_enable)
#line 7020

#pragma function(_disable)
#line 7024

#pragma warning(pop)
#line 7085
typedef struct _FLOATING_SAVE_AREA ;

#line 7097
typedef FLOATING_SAVE_AREA ;

#line 7109
typedef struct _CONTEXT ;

#line 7197
typedef CONTEXT ;

#line 7826
typedef void ;

#line 7850
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ;

#line 7899
typedef struct _KUSER_SHARED_DATA ;

#line 8123
typedef enum _CM_SERVICE_NODE_TYPE ;

#line 8132
typedef enum _CM_SERVICE_LOAD_TYPE ;

#line 8140
typedef enum _CM_ERROR_CONTROL_TYPE ;

#line 8172
typedef int ;

#line 8198
typedef enum _CM_SHARE_DISPOSITION ;

#line 8211
typedef PVOID ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST ;

#line 8443
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR ;

#line 8454
typedef struct _CM_RESOURCE_LIST ;

#line 8471
typedef struct _DEVICE_FLAGS ;

#line 8485
typedef struct _CM_COMPONENT_INFORMATION ;

#line 8503
typedef struct _CM_ROM_BLOCK ;

#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 8518 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_INT13_DRIVE_PARAMETER ;

#line 8532
typedef struct _CM_MCA_POS_DATA ;

#line 8544
typedef struct _EISA_MEMORY_TYPE ;

#line 8554
typedef struct _EISA_MEMORY_CONFIGURATION ;

#line 8567
typedef struct _EISA_IRQ_DESCRIPTOR ;

#line 8575
typedef struct _EISA_IRQ_CONFIGURATION ;

#line 8585
typedef struct _DMA_CONFIGURATION_BYTE0 ;

#line 8592
typedef struct _DMA_CONFIGURATION_BYTE1 ;

#line 8599
typedef struct _EISA_DMA_CONFIGURATION ;

#line 8609
typedef struct _EISA_PORT_DESCRIPTOR ;

#line 8616
typedef struct _EISA_PORT_CONFIGURATION ;

#line 8628
typedef struct _CM_EISA_SLOT_INFORMATION ;

#line 8644
typedef struct _CM_EISA_FUNCTION_INFORMATION ;

#line 8678
typedef struct _CM_PNP_BIOS_DEVICE_NODE ;

#line 8692
typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8761 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_SCSI_DEVICE_DATA ;

#line 8775
typedef struct _CM_VIDEO_DEVICE_DATA ;

#line 8785
typedef struct _CM_SONIC_DEVICE_DATA ;

#line 8796
typedef struct _CM_SERIAL_DEVICE_DATA ;

#line 8810
typedef struct _CM_MONITOR_DEVICE_DATA ;

#line 8844
typedef struct _CM_FLOPPY_DEVICE_DATA ;

#line 8881
typedef struct _CM_KEYBOARD_DEVICE_DATA ;

#line 8893
typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA ;

#line 8905
typedef struct _CM_PCCARD_DEVICE_DATA ;

#line 8944
typedef struct _IO_RESOURCE_DESCRIPTOR ;

#line 9027
typedef struct _IO_RESOURCE_LIST ;

#line 9036
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST ;

#line 9065
typedef struct _EXCEPTION_RECORD ;

#line 9074
typedef EXCEPTION_RECORD ;

typedef struct _EXCEPTION_RECORD32 ;

#line 9085
typedef struct _EXCEPTION_RECORD64 ;

#line 9099
typedef struct _EXCEPTION_POINTERS ;

#line 9111
typedef enum _CONFIGURATION_TYPE ;

#line 9161
typedef enum _KINTERRUPT_MODE ;

#line 9170
typedef enum _KWAIT_REASON ;

#line 9207
typedef struct _DISPATCHER_HEADER ;

#line 9217
typedef struct _KWAIT_BLOCK ;

#line 9230
typedef void ;

#line 9244
typedef struct _KDEVICE_QUEUE ;

#line 9252
typedef struct _KDEVICE_QUEUE_ENTRY ;

#line 9263
typedef struct _KEVENT ;

#line 9271
typedef BOOLEAN ;

#line 9281
typedef struct _KMUTANT ;

#line 9294
typedef struct _KSEMAPHORE ;

#line 9304
typedef struct _KTIMER ;

#line 9899
typedef enum _KBUGCHECK_BUFFER_DUMP_STATE ;

#line 9907
typedef void ;

#line 9914
typedef struct _KBUGCHECK_CALLBACK_RECORD ;

#line 10002
typedef void ;

#line 10020
typedef LOGICAL ;

#line 10037
typedef void ;

#line 10053
typedef enum _MEMORY_CACHING_TYPE_ORIG ;

#line 10057
typedef enum _MEMORY_CACHING_TYPE ;

#line 10087
typedef struct _DBGKD_DEBUG_DATA_HEADER64 ;

#line 10115
typedef enum _POOL_TYPE ;

#line 10195
typedef enum _EX_POOL_PRIORITY ;

#line 10247
typedef struct _FAST_MUTEX ;

#line 10574
typedef PVOID ;

#line 10582
typedef void ;

#line 10588
typedef struct _GENERAL_LOOKASIDE ;

#line 10619
typedef struct _NPAGED_LOOKASIDE_LIST ;

#line 10729
typedef struct _PAGED_LOOKASIDE_LIST ;

#line 10882
typedef enum _WORK_QUEUE_TYPE ;

#line 10889
typedef void ;

#line 10895
typedef struct _WORK_QUEUE_ITEM ;

#line 10926
typedef struct _ZONE_SEGMENT_HEADER ;

#line 10931
typedef struct _ZONE_HEADER ;

#line 11156
typedef ULONG_PTR ;

#line 11157
typedef ERESOURCE_THREAD ;

typedef struct _OWNER_ENTRY ;

#line 11168
typedef struct _ERESOURCE ;

#line 11197
typedef struct _RESOURCE_HASH_ENTRY ;

#line 11204
typedef struct _RESOURCE_PERFORMANCE_DATA ;

#line 11429
typedef struct _CALLBACK_OBJECT ;

typedef void ;

#line 11474
typedef GUID ;

#line 11862
typedef enum _MM_SYSTEM_SIZE ;

#line 11884
typedef enum _LOCK_OPERATION ;

#line 11970
typedef enum _MM_PAGE_PRIORITY ;

#line 11999
typedef struct _PHYSICAL_MEMORY_RANGE ;

#line 12385
typedef NTSTATUS ;

#line 12389
typedef NTSTATUS ;

#line 12399
struct _DRIVER_OBJECT ;

#line 12411
typedef enum _SECURITY_OPERATION_CODE ;

#line 12426
typedef struct _SECURITY_SUBJECT_CONTEXT ;

#line 12448
typedef struct _INITIAL_PRIVILEGE_SET ;

#line 12462
typedef struct _ACCESS_STATE ;

#line 12571
typedef void ;

#line 12585
typedef void ;

#line 12602
typedef struct _IMAGE_INFO ;

#line 12620
typedef void ;

#line 12859
typedef NTSTATUS ;

#line 12878
typedef enum _IO_QUERY_DEVICE_DATA_FORMAT ;

#line 12890
typedef enum _CREATE_FILE_TYPE ;

#line 12905
struct _DEVICE_DESCRIPTION ;

#line 12906
struct _DEVICE_OBJECT ;

#line 12907
struct _DMA_ADAPTER ;

#line 12908
struct _DRIVER_OBJECT ;

#line 12909
struct _DRIVE_LAYOUT_INFORMATION ;

#line 12910
struct _DISK_PARTITION ;

#line 12911
struct _FILE_OBJECT ;

#line 12912
struct _IRP ;

#line 12913
struct _SCSI_REQUEST_BLOCK ;

#line 12919
typedef void ;

#line 12932
typedef void ;

#line 12943
typedef NTSTATUS ;

#line 12955
typedef void ;

#line 12968
typedef void ;

#line 12979
typedef NTSTATUS ;

#line 12990
typedef void ;

#line 13001
typedef void ;

#line 13011
typedef NTSTATUS ;

#line 13025
typedef BOOLEAN ;

#line 13038
typedef BOOLEAN ;

#line 13051
typedef BOOLEAN ;

#line 13068
typedef BOOLEAN ;

#line 13078
typedef BOOLEAN ;

#line 13092
typedef BOOLEAN ;

#line 13106
typedef BOOLEAN ;

#line 13118
typedef BOOLEAN ;

#line 13127
typedef BOOLEAN ;

#line 13141
typedef BOOLEAN ;

#line 13161
typedef void ;

#line 13167
typedef void ;

#line 13179
typedef void ;

#line 13193
typedef BOOLEAN ;

#line 13207
typedef BOOLEAN ;

#line 13219
typedef BOOLEAN ;

#line 13227
typedef BOOLEAN ;

#line 13239
typedef BOOLEAN ;

#line 13253
typedef NTSTATUS ;

#line 13262
typedef NTSTATUS ;

#line 13275
typedef NTSTATUS ;

#line 13282
typedef NTSTATUS ;

#line 13289
typedef BOOLEAN ;

#line 13304
typedef BOOLEAN ;

#line 13319
typedef BOOLEAN ;

#line 13327
typedef BOOLEAN ;

#line 13336
typedef BOOLEAN ;

#line 13350
typedef struct _FAST_IO_DISPATCH ;

#line 13386
typedef enum _IO_ALLOCATION_ACTION ;

#line 13396
typedef IO_ALLOCATION_ACTION ;

#line 13410
typedef struct _IO_SECURITY_CONTEXT ;

#line 13434
typedef struct _VPB ;

#line 13482
typedef struct _ADAPTER_OBJECT ;

#line 13491
typedef struct _WAIT_CONTEXT_BLOCK ;

#line 13503
typedef struct _CONTROLLER_OBJECT ;

#line 13537
typedef struct _DEVICE_OBJECT ;

#line 13575
typedef struct _DEVICE_OBJECT ;

#line 13578
struct _DEVICE_OBJECT_POWER_EXTENSION ;

typedef struct _DEVOBJ_EXTENSION ;

#line 13608
typedef struct _DRIVER_EXTENSION ;

#line 13645
typedef struct _DRIVER_OBJECT ;

#line 13706
typedef struct _DRIVER_OBJECT ;

#line 13715
typedef struct _SECTION_OBJECT_POINTERS ;

#line 13720
typedef SECTION_OBJECT_POINTERS ;

#line 13726
typedef struct _IO_COMPLETION_CONTEXT ;

#line 13759
typedef struct _FILE_OBJECT ;

#line 13788
typedef struct _FILE_OBJECT ;

#line 13828
typedef struct _IRP ;

#line 14078
typedef NTSTATUS ;

#line 14163
typedef enum _DEVICE_RELATION_TYPE ;

#line 14171
typedef struct _DEVICE_RELATIONS ;

#line 14176
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE ;

#line 14185
typedef struct _INTERFACE ;

#line 14196
typedef struct _DEVICE_CAPABILITIES ;

#line 14229
typedef struct _POWER_SEQUENCE ;

#line 14235
typedef enum  {
	BusQueryDeviceID = 0,
	BusQueryHardwareIDs = 1,
	BusQueryCompatibleIDs = 2,
	BusQueryInstanceID = 3,
	BusQueryDeviceSerialNumber = 4
} ;

typedef ULONG ;

#line 14252
typedef enum  {
	DeviceTextDescription = 0,
	DeviceTextLocationInformation = 1
} ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 14615 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SHARE_ACCESS ;

#line 14635
typedef struct _CONFIGURATION_INFORMATION ;

#line 14848
typedef struct _BOOTDISK_INFORMATION ;

#line 15754
typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK ;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK ;

#line 15764
typedef struct _IO_REMOVE_LOCK_DBG_BLOCK ;

#line 15777
typedef struct _IO_REMOVE_LOCK ;

#line 16009
typedef struct _IO_WORKITEM ;

typedef void ;

#line 16100
typedef enum  {
	DevicePropertyDeviceDescription,
	DevicePropertyHardwareID,
	DevicePropertyCompatibleIDs,
	DevicePropertyBootConfiguration,
	DevicePropertyBootConfigurationTranslated,
	DevicePropertyClassName,
	DevicePropertyClassGuid,
	DevicePropertyDriverKeyName,
	DevicePropertyManufacturer,
	DevicePropertyFriendlyName,
	DevicePropertyLocationInformation,
	DevicePropertyPhysicalDeviceObjectName,
	DevicePropertyBusTypeGuid,
	DevicePropertyLegacyBusType,
	DevicePropertyBusNumber,
	DevicePropertyEnumeratorName,
	DevicePropertyAddress,
	DevicePropertyUINumber
} ;

typedef BOOLEAN ;

#line 16129
typedef struct _DMA_ADAPTER ;

#line 16135
typedef ULONG ;

#line 16148
typedef struct _PNP_BUS_INFORMATION ;

#line 16162
typedef struct _LEGACY_BUS_INFORMATION ;

#line 16168
typedef struct _BUS_INTERFACE_STANDARD ;

#line 16190
typedef BOOLEAN ;

#line 16194
typedef NTSTATUS ;

#line 16203
typedef NTSTATUS ;

#line 16206
typedef NTSTATUS ;

#line 16210
typedef NTSTATUS ;

#line 16214
typedef NTSTATUS ;

#line 16218
typedef void ;

#line 16222
typedef NTSTATUS ;

#line 16227
typedef void ;

#line 16231
typedef struct _ACPI_INTERFACE_STANDARD ;

#line 16255
typedef enum _ACPI_REG_TYPE ;

#line 16268
typedef USHORT ;

#line 16272
typedef void ;

#line 16278
typedef struct ACPI_REGS_INTERFACE_STANDARD ;

#line 16300
typedef struct  {
	PVOID LinkNode ;
	ULONG StaticVector ;
	UCHAR Flags ;
} ;

#line 16314
typedef NTSTATUS ;

#line 16329
typedef NTSTATUS ;

#line 16336
typedef void ;

#line 16343
typedef struct _INT_ROUTE_INTERFACE_STANDARD ;

#line 16366
typedef struct _IO_ASSIGNED_RESOURCES ;

#line 16490
typedef enum _IO_NOTIFICATION_EVENT_CATEGORY ;

#line 16504
typedef NTSTATUS ;

#line 16537
typedef void ;

#line 16573
typedef enum _ARBITER_ACTION ;

#line 16586
typedef struct _ARBITER_CONFLICT_INFO ;

#line 16608
typedef struct _ARBITER_PARAMETERS ;

#line 16719
typedef enum _ARBITER_REQUEST_SOURCE ;

#line 16731
typedef enum _ARBITER_RESULT ;

#line 16761
typedef struct _ARBITER_LIST_ENTRY ;

#line 16832
typedef NTSTATUS ;

#line 16853
typedef struct _ARBITER_INTERFACE ;

#line 16880
typedef enum _RESOURCE_TRANSLATION_DIRECTION ;

#line 16889
typedef NTSTATUS ;

#line 16901
typedef NTSTATUS ;

#line 16915
typedef struct _TRANSLATOR_INTERFACE ;

#line 16931
typedef NTSTATUS ;

#line 16945
typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE ;

#line 16959
typedef struct _PLUGPLAY_NOTIFICATION_HEADER ;

#line 16972
typedef struct _HWPROFILE_CHANGE_NOTIFICATION ;

#line 16986
typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION ;

#line 17006
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION ;

#line 17026
typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION ;

#line 17054
typedef struct _DEVICE_DESCRIPTION ;

#line 17086
typedef BOOLEAN ;

#line 17333
typedef void ;

#line 17339
typedef struct _DEVICE_CONTROL_CONTEXT ;

#line 17349
typedef PBUS_HANDLER ;

#line 17355
typedef void ;

#line 17365
typedef enum _HAL_QUERY_INFORMATION_CLASS ;

#line 17381
typedef enum _HAL_SET_INFORMATION_CLASS ;

#line 17388
typedef NTSTATUS ;

#line 17405
typedef NTSTATUS ;

#line 17420
typedef void ;

#line 17429
typedef void ;

#line 17438
typedef NTSTATUS ;

#line 17447
typedef NTSTATUS ;

#line 17456
typedef NTSTATUS ;

#line 17466
typedef NTSTATUS ;

#line 17475
typedef NTSTATUS ;

#line 17486
typedef struct _PM_DISPATCH_TABLE ;

#line 17492
typedef NTSTATUS ;

#line 17505
typedef struct _DMA_ADAPTER ;

#line 17520
typedef NTSTATUS ;

#line 17543
typedef BOOLEAN ;

#line 17553
typedef NTSTATUS ;

#line 17566
typedef void ;

#line 17572
typedef void ;

#line 17578
typedef BOOLEAN ;

#line 17588
typedef struct  {
	ULONG Version ;
	pHalQuerySystemInformation HalQuerySystemInformation ;
	pHalSetSystemInformation HalSetSystemInformation ;
	pHalQueryBusSlots HalQueryBusSlots ;
	ULONG Spare1 ;
	pHalExamineMBR HalExamineMBR ;
	pHalIoAssignDriveLetters HalIoAssignDriveLetters ;
	pHalIoReadPartitionTable HalIoReadPartitionTable ;
	pHalIoSetPartitionInformation HalIoSetPartitionInformation ;
	pHalIoWritePartitionTable HalIoWritePartitionTable ;
	pHalHandlerForBus HalReferenceHandlerForBus ;
	pHalReferenceBusHandler HalReferenceBusHandler ;
	pHalReferenceBusHandler HalDereferenceBusHandler ;
	pHalInitPnpDriver HalInitPnpDriver ;
	pHalInitPowerManagement HalInitPowerManagement ;
	pHalGetDmaAdapter HalGetDmaAdapter ;
	pHalGetInterruptTranslator HalGetInterruptTranslator ;
} ;

#line 17650
typedef struct _HAL_BUS_INFORMATION ;

#line 17658
typedef struct _HAL_PROFILE_SOURCE_INFORMATION ;

#line 17665
typedef struct _HAL_PROFILE_SOURCE_INTERVAL ;

#line 17671
typedef enum _HAL_DISPLAY_BIOS_INFORMATION ;

#line 17678
typedef struct _HAL_POWER_INFORMATION ;

#line 17683
typedef struct _HAL_PROCESSOR_SPEED_INFO ;

#line 17688
typedef struct _HAL_CALLBACKS ;

#line 17694
typedef struct _HAL_PROCESSOR_FEATURE ;

#line 17706
typedef union _MCI_ADDR ;

#line 17716
typedef enum  {
	HAL_MCE_RECORD,
	HAL_MCA_RECORD
} ;

#line 17726
typedef struct _MCA_EXCEPTION ;

#line 17752
typedef void ;

#line 17762
typedef struct _MCA_DRIVER_INFO ;

#line 17772
typedef struct _SCATTER_GATHER_ELEMENT ;

#line 17778

#pragma warning(disable:4200)
#line 17779
typedef struct _SCATTER_GATHER_LIST ;

#line 17784

#pragma warning(default:4200)
#line 17788
typedef struct _DMA_OPERATIONS ;

typedef struct _DMA_ADAPTER ;

#line 17797
typedef void ;

#line 17801
typedef PVOID ;

#line 17808
typedef void ;

#line 17816
typedef NTSTATUS ;

#line 17824
typedef BOOLEAN ;

#line 17833
typedef void ;

#line 17837
typedef void ;

#line 17843
typedef PHYSICAL_ADDRESS ;

#line 17852
typedef ULONG ;

#line 17856
typedef ULONG ;

#line 17860
typedef void ;

#line 17868
typedef NTSTATUS ;

#line 17880
typedef void ;

#line 17887
typedef struct _DMA_OPERATIONS ;

#line 18235
typedef void ;

#line 18321
typedef struct _OBJECT_HANDLE_INFORMATION ;

#line 18402
typedef struct _PCI_SLOT_NUMBER ;

#line 18418
typedef struct _PCI_COMMON_CONFIG ;

#line 18591
typedef struct _PCI_CAPABILITIES_HEADER ;

#line 18600
typedef struct _PCI_PMC ;

#line 18618
typedef struct _PCI_PMCSR ;

#line 18628
typedef struct _PCI_PMCSR_BSE ;

#line 18635
typedef struct _PCI_PM_CAPABILITY ;

#line 18679
typedef struct _PCI_AGP_CAPABILITY ;

#line 18720
typedef struct _PCI_MSI_CAPABILITY ;

#line 18946
typedef void ;

#line 18954
typedef void ;

#line 18963
typedef void ;

#line 18975
typedef struct _PCIBUSDATA ;

#line 18986
typedef ULONG ;

#line 18995
typedef void ;

#line 19000
typedef void ;

#line 19006
typedef struct _PCI_BUS_INTERFACE_STANDARD ;

#line 19028
typedef BOOLEAN ;

#line 19043
typedef struct _PCI_DEVICE_PRESENT_INTERFACE ;

#line 127 "C:/NTDDK/inc/ntddser.h"
typedef struct _SERIALPERF_STATS ;

#line 136
typedef struct _SERIALCONFIG ;

#line 154
typedef struct _SERIAL_LINE_CONTROL ;

#line 160
typedef struct _SERIAL_TIMEOUTS ;

#line 175
typedef struct _SERIAL_QUEUE_SIZE ;

#line 185
typedef struct _SERIAL_BAUD_RATE ;

#line 247
typedef struct _SERIAL_CHARS ;

#line 284
typedef struct _SERIAL_HANDFLOW ;

#line 340
typedef struct _SERIAL_BASIC_SETTINGS ;

#line 353
typedef struct _SERIAL_STATUS ;

#line 433
typedef struct _SERIAL_XOFF_COUNTER ;

#line 539
typedef struct _SERIAL_COMMPROP ;

#line 631
typedef struct _SERENUM_PORT_DESC ;

#line 652
typedef UCHAR ;

#line 658
typedef void ;

#line 665
typedef enum _SERENUM_PORTION ;

#line 671
typedef struct _SERENUM_PORT_PARAMETERS ;

#line 28 "C:/NTDDK/inc/ddk/wdm/wmilib.h"

#pragma once
#line 38
typedef struct  {
	LPCGUID Guid ;
	ULONG InstanceCount ;
	ULONG Flags ;
} ;

#line 45
typedef NTSTATUS ;

#line 101
typedef NTSTATUS ;

#line 162
typedef NTSTATUS ;

#line 206
typedef NTSTATUS ;

#line 253
typedef NTSTATUS ;

#line 306
typedef enum  {
	WmiEventControl,
	WmiDataBlockControl
} ;

#line 312
typedef NTSTATUS ;

#line 355
typedef struct _WMILIB_CONTEXT ;

#line 411
typedef enum  {
	IrpProcessed,
	IrpNotCompleted,
	IrpNotWmi,
	IrpForward
} ;

#line 13 "C:/NTDDK/inc/wmidata.h"
typedef struct _MSWmi_MofData ;

#line 51
typedef struct _MSWmi_ProviderInfo ;

#line 66
typedef struct _MSWmi_PnPDeviceId ;

#line 83
typedef struct _MSWmi_PnPInstanceNames ;

#line 105
typedef struct _MSSmBios_RawSMBiosTables ;

#line 147
typedef struct _MSPower_DeviceEnable ;

#line 165
typedef struct _MSPower_DeviceWakeEnable ;

#line 182
typedef struct _MSNdis_NetworkAddress ;

#line 199
typedef struct _MSNdis_NetworkShortAddress ;

#line 216
typedef struct _MSNdis_NetworkLinkSpeed ;

#line 239
typedef struct _MSNdis_EnumerateAdapter ;

#line 256
typedef struct _MSNdis_NotifyAdapterRemoval ;

#line 273
typedef struct _MSNdis_NotifyAdapterArrival ;

#line 291
typedef struct _MSNdis_NdisEnumerateVc ;

#line 307
typedef struct _MSNdis_NotifyVcRemoval ;

#line 323
typedef struct _MSNdis_NotifyVcArrival ;

#line 338
typedef struct _MSNdis_HardwareStatus ;

#line 356
typedef struct _MSNdis_MediaSupported ;

#line 378
typedef struct _MSNdis_MediaInUse ;

#line 400
typedef struct _MSNdis_MaximumLookahead ;

#line 418
typedef struct _MSNdis_MaximumFrameSize ;

#line 436
typedef struct _MSNdis_LinkSpeed ;

#line 454
typedef struct _MSNdis_TransmitBufferSpace ;

#line 472
typedef struct _MSNdis_ReceiveBufferSpace ;

#line 490
typedef struct _MSNdis_TransmitBlockSize ;

#line 508
typedef struct _MSNdis_ReceiveBlockSize ;

#line 526
typedef struct _MSNdis_VendorID ;

#line 544
typedef struct _MSNdis_VendorDescription ;

#line 561
typedef struct _MSNdis_CurrentPacketFilter ;

#line 579
typedef struct _MSNdis_CurrentLookahead ;

#line 597
typedef struct _MSNdis_DriverVersion ;

#line 615
typedef struct _MSNdis_MaximumTotalSize ;

#line 633
typedef struct _MSNdis_MacOptions ;

#line 651
typedef struct _MSNdis_MediaConnectStatus ;

#line 669
typedef struct _MSNdis_MaximumSendPackets ;

#line 687
typedef struct _MSNdis_VendorDriverVersion ;

#line 705
typedef struct _MSNdis_TransmitsOk ;

#line 723
typedef struct _MSNdis_ReceivesOk ;

#line 741
typedef struct _MSNdis_TransmitsError ;

#line 759
typedef struct _MSNdis_ReceiveError ;

#line 777
typedef struct _MSNdis_ReceiveNoBuffer ;

#line 795
typedef struct _MSNdis_CoHardwareStatus ;

#line 813
typedef struct _MSNdis_CoMediaSupported ;

#line 835
typedef struct _MSNdis_CoMediaInUse ;

#line 857
typedef struct _MSNdis_CoLinkSpeed ;

#line 875
typedef struct _MSNdis_CoVendorId ;

#line 893
typedef struct _MSNdis_CoVendorDescription ;

#line 910
typedef struct _MSNdis_CoDriverVersion ;

#line 928
typedef struct _MSNdis_CoMacOptions ;

#line 946
typedef struct _MSNdis_CoMediaConnectStatus ;

#line 964
typedef struct _MSNdis_CoVendorDriverVersion ;

#line 982
typedef struct _MSNdis_CoMinimumLinkSpeed ;

#line 1000
typedef struct _MSNdis_CoTransmitPdusOk ;

#line 1018
typedef struct _MSNdis_CoReceivePdusOk ;

#line 1036
typedef struct _MSNdis_CoTransmitPduErrors ;

#line 1054
typedef struct _MSNdis_CoReceivePduErrors ;

#line 1072
typedef struct _MSNdis_CoReceivePdusNoBuffer ;

#line 1090
typedef struct _MSNdis_AtmSupportedVcRates ;

#line 1113
typedef struct _MSNdis_AtmSupportedServiceCategory ;

#line 1131
typedef struct _MSNdis_AtmSupportedAalTypes ;

#line 1149
typedef struct _MSNdis_AtmHardwareCurrentAddress ;

#line 1167
typedef struct _MSNdis_AtmMaxActiveVcs ;

#line 1185
typedef struct _MSNdis_AtmMaxActiveVciBits ;

#line 1203
typedef struct _MSNdis_AtmMaxActiveVpiBits ;

#line 1221
typedef struct _MSNdis_AtmMaxAal0PacketSize ;

#line 1239
typedef struct _MSNdis_AtmMaxAal1PacketSize ;

#line 1257
typedef struct _MSNdis_AtmMaxAal34PacketSize ;

#line 1275
typedef struct _MSNdis_AtmMaxAal5PacketSize ;

#line 1293
typedef struct _MSNdis_AtmReceiveCellsOk ;

#line 1311
typedef struct _MSNdis_AtmTransmitCellsOk ;

#line 1329
typedef struct _MSNdis_AtmReceiveCellsDropped ;

#line 1347
typedef struct _MSNdis_EthernetPermanentAddress ;

#line 1365
typedef struct _MSNdis_EthernetCurrentAddress ;

#line 1383
typedef struct _MSNdis_EthernetMulticastList ;

#line 1405
typedef struct _MSNdis_EthernetMaximumMulticastListSize ;

#line 1423
typedef struct _MSNdis_EthernetMacOptions ;

#line 1441
typedef struct _MSNdis_EthernetReceiveErrorAlignment ;

#line 1459
typedef struct _MSNdis_EthernetOneTransmitCollision ;

#line 1477
typedef struct _MSNdis_EthernetMoreTransmitCollisions ;

#line 1495
typedef struct _MSNdis_TokenRingPermanentAddress ;

#line 1513
typedef struct _MSNdis_TokenRingCurrentAddress ;

#line 1531
typedef struct _MSNdis_TokenRingCurrentFunctional ;

#line 1549
typedef struct _MSNdis_TokenRingCurrentGroup ;

#line 1567
typedef struct _MSNdis_TokenRingLastOpenStatus ;

#line 1585
typedef struct _MSNdis_TokenRingCurrentRingStatus ;

#line 1603
typedef struct _MSNdis_TokenRingCurrentRingState ;

#line 1621
typedef struct _MSNdis_TokenRingLineErrors ;

#line 1639
typedef struct _MSNdis_TokenRingLostFrames ;

#line 1657
typedef struct _MSNdis_FddiLongPermanentAddress ;

#line 1675
typedef struct _MSNdis_FddiLongCurrentAddress ;

#line 1693
typedef struct _MSNdis_FddiLongMulticastList ;

#line 1715
typedef struct _MSNdis_FddiLongMaximumListSize ;

#line 1733
typedef struct _MSNdis_FddiShortPermanentAddress ;

#line 1751
typedef struct _MSNdis_FddiShortCurrentAddress ;

#line 1769
typedef struct _MSNdis_FddiShortMulticastList ;

#line 1791
typedef struct _MSNdis_FddiShortMaximumListSize ;

#line 1809
typedef struct _MSNdis_FddiAttachmentType ;

#line 1827
typedef struct _MSNdis_FddiUpstreamNodeLong ;

#line 1845
typedef struct _MSNdis_FddiDownstreamNodeLong ;

#line 1863
typedef struct _MSNdis_FddiFrameErrors ;

#line 1881
typedef struct _MSNdis_FddiFramesLost ;

#line 1899
typedef struct _MSNdis_FddiRingManagmentState ;

#line 1917
typedef struct _MSNdis_FddiLctFailures ;

#line 1935
typedef struct _MSNdis_FddiLemRejects ;

#line 1953
typedef struct _MSNdis_FddiLConnectionState ;

#line 1972
typedef struct _MSNdis_StatusResetStart ;

#line 1988
typedef struct _MSNdis_StatusResetEnd ;

#line 2004
typedef struct _MSNdis_StatusMediaConnect ;

#line 2020
typedef struct _MSNdis_StatusMediaDisconnect ;

#line 2035
typedef struct _MSNdis_StatusMediaSpecificIndication ;

#line 2057
typedef struct _MSNdis_StatusLinkSpeedChange ;

#line 2075
typedef struct _MSNdis_StatusProtocolBind ;

#line 2092
typedef struct _MSNdis_StatusProtocolUnbind ;

#line 2109
typedef struct _KEYBOARD_PORT_WMI_STD_DATA ;

#line 2152
typedef struct _POINTER_PORT_WMI_STD_DATA ;

#line 2205
typedef struct _MSMouse_ClassInformation ;

#line 2223
typedef struct _MSKeyboard_ClassInformation ;

#line 2241
typedef struct _MSAcpi_ThermalZoneTemperature ;

#line 2304
typedef struct _WMI_DISK_GEOMETRY ;

#line 2342
typedef struct _WMI_DISK_PERFORMANCE ;

#line 2415
typedef struct _MSDiskDriver_Performance ;

#line 2437
typedef struct _STORAGE_FAILURE_PREDICT_STATUS ;

#line 2460
typedef struct _STORAGE_FAILURE_PREDICT_DATA ;

#line 2483
typedef struct _STORAGE_FAILURE_PREDICT_EVENT ;

#line 2513
typedef struct _STORAGE_FAILURE_PREDICT_FUNCTION ;

#line 2528
typedef struct _MSIde_PortDeviceInfo ;

#line 2556
typedef struct _MSSerial_PortName ;

#line 2573
typedef struct _SERIAL_WMI_COMM_DATA ;

#line 2723
typedef struct _SERIAL_WMI_HW_DATA ;

#line 2770
typedef struct _SERIAL_WMI_PERF_DATA ;

#line 2813
typedef struct _SERIAL_WMI_COMMPROP ;

#line 2920
typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS ;

#line 2943
typedef struct _PARALLEL_WMI_LOG_INFO ;

#line 3041
typedef struct _REDBOOK_WMI_STD_DATA ;

#line 3094
typedef struct _REDBOOK_WMI_PERF_DATA ;

#line 3137
typedef struct _RegisteredGuids ;

#line 475 "serial.h"
typedef struct _CONFIG_DATA ;

#line 509
typedef struct _SERIAL_CISR_SW ;

#line 520
typedef struct _SERIAL_FIRMWARE_DATA ;

#line 576
typedef struct _SERIAL_DEVICE_STATE ;

#line 646
typedef struct _SERIAL_DEVICE_EXTENSION ;

#line 1808
typedef struct _SERIAL_MULTIPORT_DISPATCH ;

#line 2157
typedef enum _SERIAL_MEM_COMPARES ;

#line 2164
typedef struct _SERIAL_LIST_DATA ;

#line 2169
typedef struct _SERIAL_GLOBALS ;

#line 2180
typedef struct _SERIAL_USER_DATA ;

#line 2206
typedef struct _SERIAL_PTR_CTX ;

#line 20 "serialp.h"
typedef NTSTATUS ;

#line 26
typedef void ;

#line 835
typedef struct _SERIAL_UPDATE_CHAR ;

#line 846
typedef struct _SERIAL_IOCTL_SYNC ;

#line 27 "power.c"

#pragma alloc_text(PAGESRP0, SerialGotoPowerState)
#line 28

#pragma alloc_text(PAGESRP0, SerialPowerDispatch)
#line 29

#pragma alloc_text(PAGESRP0, SerialSetPowerD0)
#line 30

#pragma alloc_text(PAGESRP0, SerialSetPowerD3)
#line 31

#pragma alloc_text(PAGESRP0, SerialSaveDeviceState)
#line 32

#pragma alloc_text(PAGESRP0, SerialRestoreDeviceState)
#line 33

#pragma alloc_text(PAGESRP0, SerialSendWaitWake)
#line 37
NTSTATUS SerialSystemPowerCompletion(PDEVICE_OBJECT PDevObj , UCHAR
	MinorFunction , POWER_STATE PowerState , PVOID Context ,
	PIO_STATUS_BLOCK IoStatus )
{
	#line 67
	if(Context != (void *  )0)
	{
		#line 68
		KeSetEvent((PKEVENT )Context, 0, 0);
	}
	#line 71
	return (NTSTATUS )0x00000000L;
}

#line 76
void SerialSaveDeviceState(PSERIAL_DEVICE_EXTENSION PDevExt )
{
	#line 96
	PSERIAL_DEVICE_STATE pDevState = & PDevExt->DeviceState;
	#line 98
	;
	#line 100
	do
	{
		#line 100
		;
	}
	while(0);
	#line 106
	pDevState->IER = READ_PORT_UCHAR(PDevExt->Controller + (ULONG )(0x01 *
		1));
	#line 107
	pDevState->MCR = READ_PORT_UCHAR(PDevExt->Controller + (ULONG )(0x04 *
		1));
	#line 108
	pDevState->LCR = READ_PORT_UCHAR(PDevExt->Controller + (ULONG )(0x03 *
		1));
	#line 111
	do
	{
		#line 111
		;
	}
	while(0);
}

#line 115
void SerialRestoreDeviceState(PSERIAL_DEVICE_EXTENSION PDevExt )
{
	#line 135
	PSERIAL_DEVICE_STATE pDevState = & PDevExt->DeviceState;
	SHORT divisor ;
	SERIAL_IOCTL_SYNC S ;
	#line 139
	;
	#line 141
	do
	{
		#line 141
		;
	}
	while(0);
	#line 142
	do
	{
		#line 142
		;
	}
	while(0);
	#line 148
	do
	{
		#line 148
		WRITE_PORT_UCHAR(PDevExt->Controller + (ULONG )(0x04 * 1), 0);
	}
	while(0);
	#line 149
	do
	{
		#line 149
		do
		{
			#line 149
			WRITE_PORT_UCHAR(PDevExt->Controller + (ULONG )(0x01 *
				1), 0);
		}
		while(0);
	}
	while(0);
	SerialGetDivisorFromBaud(PDevExt->ClockRate, PDevExt->CurrentBaud, &
		divisor);
	#line 156
	S.Extension = PDevExt;
	S.Data = (PVOID )divisor;
	SerialSetBaud(& S);
	#line 164
	if(PDevExt->FifoPresent)
	{
		#line 165
		do
		{
			#line 165
			WRITE_PORT_UCHAR(PDevExt->Controller + (ULONG )(0x02 *
				1), (UCHAR )0);
		}
		while(0);
		#line 166
		READ_PORT_UCHAR(PDevExt->Controller + (ULONG )(0x00 * 1));
		#line 170
		do
		{
			#line 170
			WRITE_PORT_UCHAR(PDevExt->Controller + (ULONG )(0x02 *
				1), (UCHAR )((UCHAR )0x01 |
				PDevExt->RxFifoTrigger | (UCHAR )0x02 | (UCHAR
				)0x04));
		}
		while(0);
	}
	else
	{
		#line 172
		do
		{
			#line 172
			WRITE_PORT_UCHAR(PDevExt->Controller + (ULONG )(0x02 *
				1), (UCHAR )0);
		}
		while(0);
	}
	#line 181
	if(PDevExt->InterruptStatus)
	{
		#line 182
		if(PDevExt->Indexed)
		{
			#line 183
			WRITE_PORT_UCHAR(PDevExt->InterruptStatus, (UCHAR
				)0xFF);
		}
		else
		{
			#line 189
			if(PDevExt->OurIsrContext == PDevExt)
			{
				#line 194
				WRITE_PORT_UCHAR(PDevExt->InterruptStatus,
					(UCHAR )(1 << PDevExt->PortIndex - 1));
			}
			else
			{
				#line 201
				WRITE_PORT_UCHAR(PDevExt->InterruptStatus,
					(UCHAR )((PSERIAL_MULTIPORT_DISPATCH
					)PDevExt->OurIsrContext)->UsablePortMask
					);
			}
		}
	}
	#line 212
	do
	{
		#line 212
		WRITE_PORT_UCHAR(PDevExt->Controller + (ULONG )(0x01 * 1),
			pDevState->IER);
	}
	while(0);
	#line 213
	do
	{
		#line 213
		WRITE_PORT_UCHAR(PDevExt->Controller + (ULONG )(0x03 * 1),
			pDevState->LCR);
	}
	while(0);
	#line 219
	READ_PORT_UCHAR(PDevExt->Controller + (ULONG )(0x02 * 1));
	READ_PORT_UCHAR(PDevExt->Controller + (ULONG )(0x05 * 1));
	READ_PORT_UCHAR(PDevExt->Controller + (ULONG )(0x06 * 1));
	#line 224
	if((PDevExt->DeviceState).Reopen == 1)
	{
		#line 225
		do
		{
			#line 225
			;
		}
		while(0);
		#line 227
		PDevExt->DeviceIsOpened = 1;
		(PDevExt->DeviceState).Reopen = 0;
		#line 235
		do
		{
			#line 235
			WRITE_PORT_UCHAR(PDevExt->Controller + (ULONG )(0x04 *
				1), (UCHAR )(pDevState->MCR | 0x08));
		}
		while(0);
		#line 241
		do
		{
			#line 241
			do
			{
				#line 241
				WRITE_PORT_UCHAR(PDevExt->Controller + (ULONG
					)(0x01 * 1), 0);
			}
			while(0);
		}
		while(0);
		#line 242
		do
		{
			#line 242
			do
			{
				#line 242
				WRITE_PORT_UCHAR(PDevExt->Controller + (ULONG
					)(0x01 * 1), (UCHAR )(0x01 | 0x02 | 0x04
					| 0x08));
			}
			while(0);
		}
		while(0);
	}
}

#line 248
NTSTATUS SerialPowerDispatch(PDEVICE_OBJECT PDevObj , PIRP PIrp )
{
	#line 273
	PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
	PIO_STACK_LOCATION pIrpStack
		= ((PIrp->Tail).Overlay).CurrentStackLocation;
	#line 275
	NTSTATUS status ;
	PDEVICE_OBJECT pLowerDevObj = pDevExt->LowerDeviceObject;
	PDEVICE_OBJECT pPdo = pDevExt->Pdo;
	BOOLEAN acceptingIRPs ;
	#line 280
	;
	#line 282
	if((status = SerialIRPPrologue(PIrp, pDevExt)) != (NTSTATUS
		)0x00000000L)
	{
		#line 283
		PoStartNextPowerIrp(PIrp);
		{
			#line 284
			IofCompleteRequest(PIrp, 0);
			#line 284
			SerialIRPEpilogue(pDevExt);
		}
		#line 284
		;
		return status;
	}
	#line 288
	status = (NTSTATUS )0x00000000L;
	#line 290
	switch(pIrpStack->MinorFunction)
	{
	case 0x00:
			#line 292
			;
		do
		{
			#line 293
			;
		}
		while(0);
		#line 294
		break;
		#line 297
	case 0x01:
			#line 297
			;
		do
		{
			#line 298
			;
		}
		while(0);
		#line 299
		break;
		#line 302
	case 0x02:
			#line 302
			;
		do
		{
			#line 303
			;
		}
		while(0);
		#line 309
		switch(((pIrpStack->Parameters).Power).Type)
		{
			#line 310
		case SystemPowerState:
				#line 310
				;
			{
				#line 311
				POWER_STATE powerState ;
				#line 317
				do
				{
					#line 317
					;
				}
				while(0);
				#line 325
				if(pDevExt->OwnsPowerPolicy != 1)
				{
					#line 326
					status = (NTSTATUS )0x00000000L;
					goto PowerExit;
				}
				#line 331
				switch((((pIrpStack->Parameters).Power).State).SystemState
					)
				{
					#line 332
				case PowerSystemUnspecified:
						#line 332
						;
					powerState.DeviceState =
						PowerDeviceUnspecified;
					#line 334
					break;
					#line 336
				case PowerSystemWorking:
						#line 336
						;
					powerState.DeviceState = PowerDeviceD0;
					break;
					#line 340
				case PowerSystemSleeping1:
						#line 340
						;
				case PowerSystemSleeping2:
						#line 341
						;
				case PowerSystemSleeping3:
						#line 342
						;
				case PowerSystemHibernate:
						#line 343
						;
				case PowerSystemShutdown:
						#line 344
						;
				case PowerSystemMaximum:
						#line 345
						;
					powerState.DeviceState =
						(pDevExt->DeviceStateMap)[(((pIrpStack
						->Parameters).Power).State).SystemState
						];
					#line 349
					break;
					#line 351
				default :
						#line 351
						;
					status = (NTSTATUS )0x00000000L;
					goto PowerExit;
					break;
				}
				#line 358
				status = (NTSTATUS )0x00000000L;
				#line 360
				PoSetPowerState(PDevObj,
					((pIrpStack->Parameters).Power).Type,
					((pIrpStack->Parameters).Power).State);
				#line 373
				if(powerState.DeviceState < pDevExt->PowerState
					&& pDevExt->OpenCount)
				{
					#line 375
					PoRequestPowerIrp(pPdo, 0x02,
						powerState, (void *  )0,
						(void *  )0, (void *  )0);
				}
				else
				{
					#line 383
					if(powerState.DeviceState >=
						pDevExt->PowerState)
					{
						#line 390
						if(pDevExt->PendingWakeIrp ==
							(void *  )0 && !
							pDevExt->SendWaitWake ||
							powerState.DeviceState
							<= pDevExt->DeviceWake)
						{
							#line 392
							PoRequestPowerIrp(pPdo,
								0x02,
								powerState,
								(void *  )0,
								(void *  )0,
								(void *  )0);
						}
						else
						{
							#line 399
							status = (NTSTATUS
								)0xC0000184L;
						}
					}
				}
				goto PowerExit;
			}
			#line 407
		case DevicePowerState:
				#line 407
				;
			do
			{
				#line 408
				;
			}
			while(0);
			#line 409
			break;
			#line 411
		default :
				#line 411
				;
			do
			{
				#line 412
				;
			}
			while(0);
			#line 413
			status = (NTSTATUS )0x00000000L;
			goto PowerExit;
		}
		#line 422
		if(pDevExt->PowerState ==
			(((pIrpStack->Parameters).Power).State).DeviceState)
		{
			do
			{
				#line 425
				;
			}
			while(0);
			#line 426
			status = (NTSTATUS )0x00000000L;
			break;
		}
		#line 431
		switch((((pIrpStack->Parameters).Power).State).DeviceState)
		{
		case PowerDeviceD0:
				#line 433
				;
			do
			{
				#line 434
				;
			}
			while(0);
			#line 435
			return SerialSetPowerD0(PDevObj, PIrp);
			#line 437
		case PowerDeviceD1:
				#line 437
				;
		case PowerDeviceD2:
				#line 438
				;
		case PowerDeviceD3:
				#line 439
				;
			do
			{
				#line 440
				;
			}
			while(0);
			#line 441
			return SerialSetPowerD3(PDevObj, PIrp);
			#line 443
		default :
				#line 443
				;
			break;
		}
		break;
		#line 450
	case 0x03:
			#line 450
			;
		#line 452
		do
		{
			#line 452
			;
		}
		while(0);
		#line 460
		if(pDevExt->PendingWakeIrp != (void *  )0 ||
			pDevExt->SendWaitWake)
		{
			#line 461
			if(((pIrpStack->Parameters).Power).Type ==
				DevicePowerState &&
				(((pIrpStack->Parameters).Power).State).DeviceState
				> pDevExt->DeviceWake)
			{
				#line 464
				status = ((PIrp->IoStatus).Status = (NTSTATUS
					)0xC0000184L);
				#line 465
				PoStartNextPowerIrp(PIrp);
				{
					#line 466
					IofCompleteRequest(PIrp, 0);
					#line 466
					SerialIRPEpilogue(pDevExt);
				}
				#line 466
				;
				return status;
			}
		}
		#line 475
		(PIrp->IoStatus).Status = (NTSTATUS )0x00000000L;
		status = (NTSTATUS )0x00000000L;
		PoStartNextPowerIrp(PIrp);
		PIrp->CurrentLocation++;
		#line 478
		((PIrp->Tail).Overlay).CurrentStackLocation++;
		#line 478
		;
		return SerialPoCallDriver(pDevExt, pLowerDevObj, PIrp);
	}
	#line 484
	PowerExit:
		#line 484
		;
	#line 486
	PoStartNextPowerIrp(PIrp);
	#line 492
	PIrp->CurrentLocation++;
	#line 492
	((PIrp->Tail).Overlay).CurrentStackLocation++;
	#line 492
	;
	status = SerialPoCallDriver(pDevExt, pLowerDevObj, PIrp);
	#line 495
	return status;
}

#line 502
NTSTATUS SerialSetPowerD0(PDEVICE_OBJECT PDevObj , PIRP PIrp )
{
	#line 528
	PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
	PIO_STACK_LOCATION pIrpStack
		= ((PIrp->Tail).Overlay).CurrentStackLocation;
	#line 530
	NTSTATUS status ;
	#line 532
	;
	#line 534
	do
	{
		#line 534
		;
	}
	while(0);
	#line 535
	do
	{
		#line 535
		;
	}
	while(0);
	#line 537
	;
	#line 543
	KeClearEvent(& pDevExt->PowerD0Event);
	{
		#line 546
		PIO_STACK_LOCATION irpSp ;
		#line 546
		PIO_STACK_LOCATION nextIrpSp ;
		#line 546
		irpSp = ((PIrp->Tail).Overlay).CurrentStackLocation;
		#line 546
		nextIrpSp = ((PIrp->Tail).Overlay).CurrentStackLocation - 1;
		#line 546
		memcpy(nextIrpSp, irpSp, (LONG )((LONG_PTR )(&
			((IO_STACK_LOCATION *  )0)->CompletionRoutine)));
		#line 546
		nextIrpSp->Control = 0;
	}
	#line 546
	;
	if(s != NP)
		#line 547
		errorFn();
	else
	{
		#line 549
		if(compRegistered != 0)
			#line 549
			errorFn();
		else
		{
			#line 551
			compRegistered = 1;
			compFptr = SerialSyncCompletion;
		}
	}
	{
		PIO_STACK_LOCATION irpSp ;
		#line 556
		;
		#line 556
		irpSp = ((PIrp->Tail).Overlay).CurrentStackLocation - 1;
		#line 556
		irpSp->CompletionRoutine = SerialSyncCompletion;
		#line 556
		irpSp->Context = & pDevExt->PowerD0Event;
		#line 556
		irpSp->Control = 0;
		#line 556
		if(1)
		{
			#line 556
			irpSp->Control = 0x40;
		}
		#line 556
		if(1)
		{
			#line 556
			irpSp->Control |= 0x80;
		}
		#line 556
		if(1)
		{
			#line 556
			irpSp->Control |= 0x20;
		}
	}
	#line 556
	;
	#line 558
	do
	{
		#line 558
		;
	}
	while(0);
	#line 560
	status = PoCallDriver(pDevExt->LowerDeviceObject, PIrp);
	#line 562
	if(status == (NTSTATUS )0x00000103L)
	{
		#line 563
		do
		{
			#line 563
			;
		}
		while(0);
		#line 564
		KeWaitForSingleObject(& pDevExt->PowerD0Event, Executive,
			KernelMode, 0, (void *  )0);
	}
	else
	{
		#line 567
		if(! ((NTSTATUS )status >= 0))
		{
			#line 568
			(PIrp->IoStatus).Status = status;
			PoStartNextPowerIrp(PIrp);
			{
				#line 570
				IofCompleteRequest(PIrp, 0);
				#line 570
				SerialIRPEpilogue(pDevExt);
			}
			#line 570
			;
			return status;
		}
	}
	#line 575
	if(! ((NTSTATUS )(PIrp->IoStatus).Status >= 0))
	{
		#line 576
		status = (PIrp->IoStatus).Status;
		PoStartNextPowerIrp(PIrp);
		{
			#line 578
			IofCompleteRequest(PIrp, 0);
			#line 578
			SerialIRPEpilogue(pDevExt);
		}
		#line 578
		;
		return status;
	}
	#line 586
	pDevExt->PowerState = PowerDeviceD0;
	#line 594
	if(pDevExt->PNPState == 0x1L)
	{
		#line 595
		SerialRestoreDeviceState(pDevExt);
	}
	#line 602
	PoSetPowerState(PDevObj, ((pIrpStack->Parameters).Power).Type,
		((pIrpStack->Parameters).Power).State);
	#line 605
	PoStartNextPowerIrp(PIrp);
	{
		#line 606
		IofCompleteRequest(PIrp, 0);
		#line 606
		SerialIRPEpilogue(pDevExt);
	}
	#line 606
	;
	#line 609
	do
	{
		#line 609
		;
	}
	while(0);
	#line 610
	return status;
}

#line 614
NTSTATUS SerialGotoPowerState(PDEVICE_OBJECT PDevObj , PSERIAL_DEVICE_EXTENSION
	PDevExt , DEVICE_POWER_STATE DevPowerState )
{
	#line 640
	KEVENT gotoPowEvent ;
	NTSTATUS status ;
	POWER_STATE powerState ;
	#line 644
	;
	#line 646
	do
	{
		#line 646
		;
	}
	while(0);
	#line 648
	powerState.DeviceState = DevPowerState;
	#line 650
	KeInitializeEvent(& gotoPowEvent, SynchronizationEvent, 0);
	#line 652
	status = PoRequestPowerIrp(PDevObj, 0x02, powerState,
		SerialSystemPowerCompletion, & gotoPowEvent, (void *  )0);
	#line 656
	if(status == (NTSTATUS )0x00000103L)
	{
		#line 657
		KeWaitForSingleObject(& gotoPowEvent, Executive, KernelMode, 0,
			(void *  )0);
		#line 658
		status = (NTSTATUS )0x00000000L;
	}
	#line 667
	do
	{
		#line 667
		;
	}
	while(0);
	#line 669
	return status;
}

#line 675
NTSTATUS SerialSetPowerD3(PDEVICE_OBJECT PDevObj , PIRP PIrp )
{
	#line 696
	NTSTATUS status = (NTSTATUS )0x00000000L;
	PSERIAL_DEVICE_EXTENSION pDevExt = PDevObj->DeviceExtension;
	PIO_STACK_LOCATION pIrpStack
		= ((PIrp->Tail).Overlay).CurrentStackLocation;
	;
	#line 702
	do
	{
		#line 702
		;
	}
	while(0);
	#line 709
	if(pDevExt->SendWaitWake)
	{
		#line 710
		SerialSendWaitWake(pDevExt);
	}
	#line 716
	PoSetPowerState(PDevObj, ((pIrpStack->Parameters).Power).Type,
		((pIrpStack->Parameters).Power).State);
	#line 724
	if(pDevExt->DeviceIsOpened == 1)
	{
		#line 725
		LARGE_INTEGER charTime ;
		#line 727
		pDevExt->DeviceIsOpened = 0;
		(pDevExt->DeviceState).Reopen = 1;
		#line 730
		charTime.QuadPart = - (SerialGetCharTime(pDevExt)).QuadPart;
		#line 736
		SerialDisableUART(pDevExt);
		#line 742
		SerialDrainUART(pDevExt, & charTime);
		#line 748
		SerialSaveDeviceState(pDevExt);
	}
	#line 757
	(PIrp->IoStatus).Status = (NTSTATUS )0x00000000L;
	#line 759
	pDevExt->PowerState = PowerDeviceD3;
	#line 766
	(PIrp->IoStatus).Status = (NTSTATUS )0x00000000L;
	#line 768
	PoStartNextPowerIrp(PIrp);
	PIrp->CurrentLocation++;
	#line 769
	((PIrp->Tail).Overlay).CurrentStackLocation++;
	#line 769
	;
	#line 771
	return SerialPoCallDriver(pDevExt, pDevExt->LowerDeviceObject, PIrp);
}

#line 775
NTSTATUS SerialSendWaitWake(PSERIAL_DEVICE_EXTENSION PDevExt )
{
	#line 795
	NTSTATUS status ;
	PIRP pIrp ;
	POWER_STATE powerState ;
	#line 799
	;
	#line 806
	if(PDevExt->PendingWakeIrp != (void *  )0)
	{
		#line 807
		return (NTSTATUS )0xC0000184L;
	}
	#line 814
	if(PDevExt->SystemWake <= PowerSystemWorking)
	{
		#line 815
		return (NTSTATUS )0xC0000184L;
	}
	#line 818
	if(PDevExt->DeviceWake == PowerDeviceUnspecified)
	{
		#line 819
		return (NTSTATUS )0xC0000184L;
	}
	#line 827
	InterlockedIncrement(& PDevExt->PendingIRPCnt);
	#line 829
	powerState.SystemState = PDevExt->SystemWake;
	#line 831
	status = PoRequestPowerIrp(PDevExt->Pdo, 0x00, powerState,
		SerialWakeCompletion, PDevExt, & pIrp);
	#line 834
	if(status == (NTSTATUS )0x00000103L)
	{
		#line 835
		status = (NTSTATUS )0x00000000L;
		PDevExt->PendingWakeIrp = pIrp;
	}
	else
	{
		#line 837
		if(! ((NTSTATUS )status >= 0))
		{
			#line 838
			SerialIRPEpilogue(PDevExt);
		}
	}
	return status;
}

NTSTATUS SerialWakeCompletion(PDEVICE_OBJECT PDevObj , UCHAR MinorFunction ,
	POWER_STATE PowerState , PVOID Context , PIO_STATUS_BLOCK IoStatus )
{
	#line 874
	NTSTATUS status ;
	PSERIAL_DEVICE_EXTENSION pDevExt = (PSERIAL_DEVICE_EXTENSION )Context;
	POWER_STATE powerState ;
	#line 878
	status = IoStatus->Status;
	#line 880
	if((NTSTATUS )status >= 0)
	{
		#line 885
		powerState.DeviceState = PowerDeviceD0;
		#line 887
		PoRequestPowerIrp(pDevExt->Pdo, 0x02, powerState, (void *  )0,
			(void *  )0, (void *  )0);
	}
	#line 892
	pDevExt->PendingWakeIrp = (void *  )0;
	SerialIRPEpilogue(pDevExt);
	#line 895
	return status;
}

#line 16 "C:/NTDDK/inc/stddef.h"

#pragma once
#line 77
typedef int ;

#line 86
typedef unsigned int ;

#line 95
typedef int ;

#line 105
typedef unsigned int ;

#line 112
typedef unsigned short ;

#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"

#pragma once
#line 32

#pragma pack(push, 8)
#line 72
typedef enum _EXCEPTION_DISPOSITION ;

#line 89
struct _EXCEPTION_RECORD ;

#line 90
struct _CONTEXT ;

#line 155

#pragma pack(pop)
#line 25 "C:/NTDDK/inc/ntdef.h"

#pragma once
#line 15 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"

#pragma once
#line 66
typedef wchar_t ;

#line 67
typedef wchar_t ;

#line 127 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long ;

#line 25 "C:/NTDDK/inc/basetsd.h"

#pragma once
#line 36
typedef int ;

#line 37
typedef int ;

#line 43
typedef unsigned int ;

#line 44
typedef unsigned int ;

#line 45
typedef unsigned int ;

#line 84
typedef int ;

#line 85
typedef unsigned int ;

typedef long ;

#line 88
typedef unsigned long ;

#line 248
typedef unsigned short ;

#line 249
typedef short ;

#line 250
typedef unsigned long ;

#line 288
typedef ULONG_PTR ;

#line 289
typedef LONG_PTR ;

#line 295
typedef ULONG_PTR ;

#line 301
typedef __int64 ;

#line 302
typedef __int64 ;

#line 309
typedef unsigned __int64 ;

#line 310
typedef unsigned __int64 ;

#line 311
typedef unsigned __int64 ;

#line 217 "C:/NTDDK/inc/ntdef.h"
typedef void ;

#line 218
typedef void ;

#line 266
typedef char ;

#line 267
typedef short ;

#line 268
typedef long ;

#line 276
typedef wchar_t ;

#line 282
typedef WCHAR ;

#line 283
typedef WCHAR ;

#line 284
typedef const WCHAR ;

#line 285
typedef WCHAR ;

#line 286
typedef WCHAR ;

typedef const WCHAR ;

#line 293
typedef CHAR ;

#line 294
typedef CHAR ;

typedef const CHAR ;

#line 297
typedef CHAR ;

#line 298
typedef CHAR ;

#line 299
typedef const CHAR ;

#line 321
typedef char ;

#line 322
typedef unsigned char ;

#line 326
typedef LPSTR ;

#line 327
typedef LPSTR ;

#line 328
typedef LPCSTR ;

#line 337
typedef double ;

typedef struct _QUAD ;

#line 349
typedef SHORT ;

#line 350
typedef LONG ;

#line 351
typedef QUAD ;

#line 360
typedef unsigned char ;

#line 361
typedef unsigned short ;

#line 362
typedef unsigned long ;

#line 363
typedef QUAD ;

#line 369
typedef UCHAR ;

#line 370
typedef USHORT ;

#line 371
typedef ULONG ;

#line 372
typedef UQUAD ;

#line 378
typedef signed char ;

#line 379
typedef SCHAR ;

#line 394
typedef void ;

#line 400
typedef HANDLE ;

#line 406
typedef UCHAR ;

#line 407
typedef USHORT ;

#line 408
typedef ULONG ;

#line 414
typedef LONG ;

#line 478
typedef char ;

#line 479
typedef short ;

#line 480
typedef ULONG ;

typedef CCHAR ;

#line 483
typedef CSHORT ;

#line 484
typedef CLONG ;

#line 492
typedef ULONG ;

#line 493
typedef PULONG ;

#line 494
typedef USHORT ;

#line 500
typedef ULONG ;

#line 501
typedef ULONG ;

#line 508
typedef LONG ;

typedef NTSTATUS ;

#line 602
typedef struct _FLOAT128 ;

#line 607
typedef FLOAT128 ;

#line 621
typedef __int64 ;

#line 622
typedef unsigned __int64 ;

#line 639
typedef LONGLONG ;

#line 640
typedef ULONGLONG ;

#line 644
typedef LONGLONG ;

#line 649
typedef union _LARGE_INTEGER ;

#line 662
typedef LARGE_INTEGER ;

#line 668
typedef union _ULARGE_INTEGER ;

#line 681
typedef ULARGE_INTEGER ;

#line 690
typedef struct _LUID ;

#line 696
typedef ULONGLONG ;

#line 697
typedef DWORDLONG ;

#line 707
typedef LARGE_INTEGER ;

#line 831

#pragma warning(push)

#pragma warning(disable:4035)
__inline ULONGLONG __stdcall Int64ShllMod32___19(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 842
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    
		};
}

#line 845
__inline LONGLONG __stdcall Int64ShraMod32___19(LONGLONG Value , ULONG
	ShiftCount )
{
	#line 852
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    
		};
}

#line 855
__inline ULONGLONG __stdcall Int64ShrlMod32___19(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 862
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    
		};
}


#pragma warning(pop)
#line 956
typedef enum _EVENT_TYPE ;

#line 965
typedef enum _TIMER_TYPE ;

#line 974
typedef enum _WAIT_TYPE ;

#line 983
typedef CHAR ;

#line 984
typedef const char ;

#line 991
typedef struct _STRING ;

#line 999
typedef STRING ;

typedef STRING ;

#line 1002
typedef PSTRING ;

typedef STRING ;

#line 1005
typedef PSTRING ;

#line 1011
typedef struct _CSTRING ;

#line 1016
typedef CSTRING ;

#line 1019
typedef STRING ;

#line 1020
typedef PSTRING ;

#line 1027
typedef struct _UNICODE_STRING ;

#line 1036
typedef UNICODE_STRING ;

#line 1037
typedef const UNICODE_STRING ;

#line 1046
typedef UCHAR ;

#line 1047
typedef BOOLEAN ;

#line 1057
typedef struct _LIST_ENTRY ;

#line 1067
typedef struct _SINGLE_LIST_ENTRY ;

#line 1078
typedef struct LIST_ENTRY32 ;

#line 1082
typedef LIST_ENTRY32 ;

typedef struct LIST_ENTRY64 ;

#line 1088
typedef LIST_ENTRY64 ;

#line 1127
typedef struct _STRING32 ;

#line 1132
typedef STRING32 ;

typedef STRING32 ;

#line 1135
typedef UNICODE_STRING32 ;

typedef STRING32 ;

#line 1138
typedef ANSI_STRING32 ;

#line 1141
typedef struct _STRING64 ;

#line 1146
typedef STRING64 ;

typedef STRING64 ;

#line 1149
typedef UNICODE_STRING64 ;

typedef STRING64 ;

#line 1152
typedef ANSI_STRING64 ;

#line 1173
typedef struct _OBJECT_ATTRIBUTES ;

#line 1181
typedef OBJECT_ATTRIBUTES ;

#line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID ;

#line 70
typedef GUID ;

#line 75
typedef const GUID ;

#line 81
typedef GUID ;

#line 82
typedef IID ;

#line 85
typedef GUID ;

#line 86
typedef CLSID ;

#line 89
typedef GUID ;

#line 90
typedef FMTID ;

#line 16 "C:/NTDDK/inc/string.h"

#pragma once
#line 1233 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECTID ;

#line 1288
struct _CONTEXT ;

#line 1289
struct _EXCEPTION_RECORD ;

typedef EXCEPTION_DISPOSITION ;

#line 1306
typedef UCHAR ;

typedef KIRQL ;

#line 1316
typedef enum _NT_PRODUCT_TYPE ;

#line 1329
typedef enum _SUITE_TYPE ;

#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD ;

#line 76
typedef struct _ETHREAD ;

#line 77
typedef struct _EPROCESS ;

#line 78
typedef struct _PEB ;

#line 79
typedef struct _KINTERRUPT ;

#line 80
typedef struct _IO_TIMER ;

#line 81
typedef struct _OBJECT_TYPE ;

#line 82
typedef struct _CALLBACK_OBJECT ;

#line 83
typedef struct _DEVICE_HANDLER_OBJECT ;

#line 84
typedef struct _BUS_HANDLER ;

#line 143
typedef union _SLIST_HEADER ;

#line 204
typedef CCHAR ;

typedef enum _MODE ;

#line 222
struct _KAPC ;

typedef void ;

#line 232
typedef void ;

#line 242
typedef void ;

#line 248
typedef BOOLEAN ;

#line 254
typedef BOOLEAN ;

#line 265
typedef struct _KAPC ;

#line 292
struct _KDPC ;

typedef void ;

#line 351
typedef enum _KDPC_IMPORTANCE ;

#line 361
typedef struct _KDPC ;

#line 377
typedef PVOID ;

typedef void ;

#line 392
typedef struct _KIPI_COUNTS ;

#line 443
typedef struct _MDL ;

#line 532
typedef PVOID ;

#line 538
typedef PVOID ;

#line 544
typedef PVOID ;

typedef ULONG ;

#line 547
typedef ACCESS_MASK ;

#line 597
typedef struct _GENERIC_MAPPING ;

#line 603
typedef GENERIC_MAPPING ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES ;

#line 622
typedef LUID_AND_ATTRIBUTES ;

#line 623
typedef LUID_AND_ATTRIBUTES_ARRAY ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 642 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACL ;

#line 649
typedef ACL ;

#line 681
typedef struct _PRIVILEGE_SET ;

#line 735
typedef enum _SECURITY_IMPERSONATION_LEVEL ;

#line 753
typedef BOOLEAN ;

#line 762
typedef struct _SECURITY_QUALITY_OF_SERVICE ;

#line 774
typedef struct _SE_IMPERSONATION_STATE ;

#line 782
typedef ULONG ;

#line 809
typedef ULONG ;

#line 810
typedef KAFFINITY ;

#line 816
typedef LONG ;

#line 824
typedef ULONG_PTR ;

#line 825
typedef KSPIN_LOCK ;

#line 833
typedef void ;

#line 842
typedef enum _KPROFILE_SOURCE ;

#line 1079
typedef NTSTATUS ;

#line 1088
typedef struct _RTL_QUERY_REGISTRY_TABLE ;

#line 1952

#pragma warning(push)

#pragma warning(disable:4035)
#line 2019

#pragma warning(pop)
#line 2214
typedef struct _TIME_FIELDS ;

#line 2224
typedef TIME_FIELDS ;

#line 2499
typedef struct _RTL_BITMAP ;

#line 2503
typedef RTL_BITMAP ;

#line 2627
typedef struct _RTL_BITMAP_RUN ;

#line 2633
typedef RTL_BITMAP_RUN ;

#line 2886
typedef struct _RTL_RANGE ;

#line 2924
typedef struct _RTL_RANGE_LIST ;

#line 2950
typedef struct _RANGE_LIST_ITERATOR ;

#line 3019
typedef BOOLEAN ;

#line 3155
typedef struct _OSVERSIONINFOA ;

#line 3164
typedef struct _OSVERSIONINFOW ;

#line 3177
typedef OSVERSIONINFOA ;

#line 3178
typedef POSVERSIONINFOA ;

#line 3179
typedef LPOSVERSIONINFOA ;

#line 3182
typedef struct _OSVERSIONINFOEXA ;

#line 3195
typedef struct _OSVERSIONINFOEXW ;

#line 3213
typedef OSVERSIONINFOEXA ;

#line 3214
typedef POSVERSIONINFOEXA ;

#line 3215
typedef LPOSVERSIONINFOEXA ;

#line 3648
typedef struct _IO_STATUS_BLOCK ;

#line 3669
typedef void ;

#line 3685
typedef enum _FILE_INFORMATION_CLASS ;

#line 3731
typedef struct _FILE_BASIC_INFORMATION ;

#line 3739
typedef struct _FILE_STANDARD_INFORMATION ;

#line 3747
typedef struct _FILE_POSITION_INFORMATION ;

#line 3751
typedef struct _FILE_ALIGNMENT_INFORMATION ;

#line 3755
typedef struct _FILE_NAME_INFORMATION ;

#line 3760
typedef struct _FILE_NETWORK_OPEN_INFORMATION ;

#line 3770
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION ;

#line 3775
typedef struct _FILE_DISPOSITION_INFORMATION ;

#line 3779
typedef struct _FILE_END_OF_FILE_INFORMATION ;

#line 3784
typedef struct _FILE_FULL_EA_INFORMATION ;

#line 3798
typedef enum _FSINFOCLASS ;

#line 3810
typedef struct _FILE_FS_DEVICE_INFORMATION ;

#line 3820
typedef union _FILE_SEGMENT_ELEMENT ;

#line 3829
typedef enum _INTERFACE_TYPE ;

#line 3854
typedef enum _DMA_WIDTH ;

#line 3865
typedef enum _DMA_SPEED ;

#line 3879
typedef void ;

#line 3880
typedef void ;

#line 3888
typedef enum _BUS_DATA_TYPE ;

#line 3910
typedef struct _IO_ERROR_LOG_PACKET ;

#line 3931
typedef struct _IO_ERROR_LOG_MESSAGE ;

#line 4074
typedef struct _KEY_BASIC_INFORMATION ;

#line 4081
typedef struct _KEY_NODE_INFORMATION ;

#line 4091
typedef struct _KEY_FULL_INFORMATION ;

#line 4106
typedef struct _KEY_NAME_INFORMATION ;

#line 4112
typedef enum _KEY_INFORMATION_CLASS ;

#line 4122
typedef struct _KEY_WRITE_TIME_INFORMATION ;

#line 4126
typedef enum _KEY_SET_INFORMATION_CLASS ;

#line 4134
typedef struct _KEY_VALUE_BASIC_INFORMATION ;

#line 4141
typedef struct _KEY_VALUE_FULL_INFORMATION ;

#line 4151
typedef struct _KEY_VALUE_PARTIAL_INFORMATION ;

#line 4158
typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ;

#line 4164
typedef struct _KEY_VALUE_ENTRY ;

#line 4171
typedef enum _KEY_VALUE_INFORMATION_CLASS ;

#line 4210
typedef struct _OBJECT_NAME_INFORMATION ;

#line 4221
typedef enum _SECTION_INHERIT ;

#line 4294
typedef struct _CLIENT_ID ;

#line 4298
typedef CLIENT_ID ;

#line 4315
typedef struct _NT_TIB ;

#line 4327
typedef NT_TIB ;

#line 4332
typedef enum _PROCESSINFOCLASS ;

#line 4366
typedef enum _THREADINFOCLASS ;

#line 4395
typedef struct _PROCESS_WS_WATCH_INFORMATION ;

#line 4405
typedef struct _PROCESS_BASIC_INFORMATION ;

#line 4413
typedef PROCESS_BASIC_INFORMATION ;

#line 4422
typedef struct _PROCESS_DEVICEMAP_INFORMATION ;

#line 4440
typedef struct _PROCESS_SESSION_INFORMATION ;

#line 4454
typedef struct _QUOTA_LIMITS ;

#line 4462
typedef QUOTA_LIMITS ;

#line 4472
typedef struct _IO_COUNTERS ;

#line 4480
typedef IO_COUNTERS ;

#line 4488
typedef struct _VM_COUNTERS ;

#line 4501
typedef VM_COUNTERS ;

#line 4508
typedef struct _POOLED_USAGE_AND_LIMITS ;

#line 4519
typedef POOLED_USAGE_AND_LIMITS ;

#line 4528
typedef struct _PROCESS_ACCESS_TOKEN ;

#line 4555
typedef struct _KERNEL_USER_TIMES ;

#line 4561
typedef KERNEL_USER_TIMES ;

#line 4587
typedef enum _SYSTEM_POWER_STATE ;

#line 4598
typedef enum  {
	PowerActionNone = 0,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
} ;

typedef enum _DEVICE_POWER_STATE ;

#line 4618
typedef union _POWER_STATE ;

#line 4623
typedef enum _POWER_STATE_TYPE ;

#line 4654
typedef ULONG ;

typedef enum  {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
} ;

#line 4663
typedef enum  {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation
} ;

#line 4690
typedef ULONG ;

typedef LONG ;

#line 4693
typedef ULONG ;

#line 4719
typedef union _MCI_STATS ;

#line 4978
typedef struct _KPCR ;

#line 5006
typedef KPCR ;

#line 5012
typedef struct _KFLOATING_SAVE ;

#line 5153
typedef enum _INTERLOCKED_RESULT ;

#line 5252

#pragma warning(disable:4035)
#line 6994
typedef struct _KSYSTEM_TIME ;

#line 7014

#pragma warning(push)

#pragma warning(disable:4164)
#line 7019

#pragma function(_enable)
#line 7020

#pragma function(_disable)
#line 7024

#pragma warning(pop)
#line 7085
typedef struct _FLOATING_SAVE_AREA ;

#line 7097
typedef FLOATING_SAVE_AREA ;

#line 7109
typedef struct _CONTEXT ;

#line 7197
typedef CONTEXT ;

#line 7826
typedef void ;

#line 7850
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ;

#line 7899
typedef struct _KUSER_SHARED_DATA ;

#line 8123
typedef enum _CM_SERVICE_NODE_TYPE ;

#line 8132
typedef enum _CM_SERVICE_LOAD_TYPE ;

#line 8140
typedef enum _CM_ERROR_CONTROL_TYPE ;

#line 8172
typedef int ;

#line 8198
typedef enum _CM_SHARE_DISPOSITION ;

#line 8211
typedef PVOID ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST ;

#line 8443
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR ;

#line 8454
typedef struct _CM_RESOURCE_LIST ;

#line 8471
typedef struct _DEVICE_FLAGS ;

#line 8485
typedef struct _CM_COMPONENT_INFORMATION ;

#line 8503
typedef struct _CM_ROM_BLOCK ;

#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 8518 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_INT13_DRIVE_PARAMETER ;

#line 8532
typedef struct _CM_MCA_POS_DATA ;

#line 8544
typedef struct _EISA_MEMORY_TYPE ;

#line 8554
typedef struct _EISA_MEMORY_CONFIGURATION ;

#line 8567
typedef struct _EISA_IRQ_DESCRIPTOR ;

#line 8575
typedef struct _EISA_IRQ_CONFIGURATION ;

#line 8585
typedef struct _DMA_CONFIGURATION_BYTE0 ;

#line 8592
typedef struct _DMA_CONFIGURATION_BYTE1 ;

#line 8599
typedef struct _EISA_DMA_CONFIGURATION ;

#line 8609
typedef struct _EISA_PORT_DESCRIPTOR ;

#line 8616
typedef struct _EISA_PORT_CONFIGURATION ;

#line 8628
typedef struct _CM_EISA_SLOT_INFORMATION ;

#line 8644
typedef struct _CM_EISA_FUNCTION_INFORMATION ;

#line 8678
typedef struct _CM_PNP_BIOS_DEVICE_NODE ;

#line 8692
typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8761 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_SCSI_DEVICE_DATA ;

#line 8775
typedef struct _CM_VIDEO_DEVICE_DATA ;

#line 8785
typedef struct _CM_SONIC_DEVICE_DATA ;

#line 8796
typedef struct _CM_SERIAL_DEVICE_DATA ;

#line 8810
typedef struct _CM_MONITOR_DEVICE_DATA ;

#line 8844
typedef struct _CM_FLOPPY_DEVICE_DATA ;

#line 8881
typedef struct _CM_KEYBOARD_DEVICE_DATA ;

#line 8893
typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA ;

#line 8905
typedef struct _CM_PCCARD_DEVICE_DATA ;

#line 8944
typedef struct _IO_RESOURCE_DESCRIPTOR ;

#line 9027
typedef struct _IO_RESOURCE_LIST ;

#line 9036
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST ;

#line 9065
typedef struct _EXCEPTION_RECORD ;

#line 9074
typedef EXCEPTION_RECORD ;

typedef struct _EXCEPTION_RECORD32 ;

#line 9085
typedef struct _EXCEPTION_RECORD64 ;

#line 9099
typedef struct _EXCEPTION_POINTERS ;

#line 9111
typedef enum _CONFIGURATION_TYPE ;

#line 9161
typedef enum _KINTERRUPT_MODE ;

#line 9170
typedef enum _KWAIT_REASON ;

#line 9207
typedef struct _DISPATCHER_HEADER ;

#line 9217
typedef struct _KWAIT_BLOCK ;

#line 9230
typedef void ;

#line 9244
typedef struct _KDEVICE_QUEUE ;

#line 9252
typedef struct _KDEVICE_QUEUE_ENTRY ;

#line 9263
typedef struct _KEVENT ;

#line 9271
typedef BOOLEAN ;

#line 9281
typedef struct _KMUTANT ;

#line 9294
typedef struct _KSEMAPHORE ;

#line 9304
typedef struct _KTIMER ;

#line 9899
typedef enum _KBUGCHECK_BUFFER_DUMP_STATE ;

#line 9907
typedef void ;

#line 9914
typedef struct _KBUGCHECK_CALLBACK_RECORD ;

#line 10002
typedef void ;

#line 10020
typedef LOGICAL ;

#line 10037
typedef void ;

#line 10053
typedef enum _MEMORY_CACHING_TYPE_ORIG ;

#line 10057
typedef enum _MEMORY_CACHING_TYPE ;

#line 10087
typedef struct _DBGKD_DEBUG_DATA_HEADER64 ;

#line 10115
typedef enum _POOL_TYPE ;

#line 10195
typedef enum _EX_POOL_PRIORITY ;

#line 10247
typedef struct _FAST_MUTEX ;

#line 10574
typedef PVOID ;

#line 10582
typedef void ;

#line 10588
typedef struct _GENERAL_LOOKASIDE ;

#line 10619
typedef struct _NPAGED_LOOKASIDE_LIST ;

#line 10729
typedef struct _PAGED_LOOKASIDE_LIST ;

#line 10882
typedef enum _WORK_QUEUE_TYPE ;

#line 10889
typedef void ;

#line 10895
typedef struct _WORK_QUEUE_ITEM ;

#line 10926
typedef struct _ZONE_SEGMENT_HEADER ;

#line 10931
typedef struct _ZONE_HEADER ;

#line 11156
typedef ULONG_PTR ;

#line 11157
typedef ERESOURCE_THREAD ;

typedef struct _OWNER_ENTRY ;

#line 11168
typedef struct _ERESOURCE ;

#line 11197
typedef struct _RESOURCE_HASH_ENTRY ;

#line 11204
typedef struct _RESOURCE_PERFORMANCE_DATA ;

#line 11429
typedef struct _CALLBACK_OBJECT ;

typedef void ;

#line 11474
typedef GUID ;

#line 11862
typedef enum _MM_SYSTEM_SIZE ;

#line 11884
typedef enum _LOCK_OPERATION ;

#line 11970
typedef enum _MM_PAGE_PRIORITY ;

#line 11999
typedef struct _PHYSICAL_MEMORY_RANGE ;

#line 12385
typedef NTSTATUS ;

#line 12389
typedef NTSTATUS ;

#line 12399
struct _DRIVER_OBJECT ;

#line 12411
typedef enum _SECURITY_OPERATION_CODE ;

#line 12426
typedef struct _SECURITY_SUBJECT_CONTEXT ;

#line 12448
typedef struct _INITIAL_PRIVILEGE_SET ;

#line 12462
typedef struct _ACCESS_STATE ;

#line 12571
typedef void ;

#line 12585
typedef void ;

#line 12602
typedef struct _IMAGE_INFO ;

#line 12620
typedef void ;

#line 12859
typedef NTSTATUS ;

#line 12878
typedef enum _IO_QUERY_DEVICE_DATA_FORMAT ;

#line 12890
typedef enum _CREATE_FILE_TYPE ;

#line 12905
struct _DEVICE_DESCRIPTION ;

#line 12906
struct _DEVICE_OBJECT ;

#line 12907
struct _DMA_ADAPTER ;

#line 12908
struct _DRIVER_OBJECT ;

#line 12909
struct _DRIVE_LAYOUT_INFORMATION ;

#line 12910
struct _DISK_PARTITION ;

#line 12911
struct _FILE_OBJECT ;

#line 12912
struct _IRP ;

#line 12913
struct _SCSI_REQUEST_BLOCK ;

#line 12919
typedef void ;

#line 12932
typedef void ;

#line 12943
typedef NTSTATUS ;

#line 12955
typedef void ;

#line 12968
typedef void ;

#line 12979
typedef NTSTATUS ;

#line 12990
typedef void ;

#line 13001
typedef void ;

#line 13011
typedef NTSTATUS ;

#line 13025
typedef BOOLEAN ;

#line 13038
typedef BOOLEAN ;

#line 13051
typedef BOOLEAN ;

#line 13068
typedef BOOLEAN ;

#line 13078
typedef BOOLEAN ;

#line 13092
typedef BOOLEAN ;

#line 13106
typedef BOOLEAN ;

#line 13118
typedef BOOLEAN ;

#line 13127
typedef BOOLEAN ;

#line 13141
typedef BOOLEAN ;

#line 13161
typedef void ;

#line 13167
typedef void ;

#line 13179
typedef void ;

#line 13193
typedef BOOLEAN ;

#line 13207
typedef BOOLEAN ;

#line 13219
typedef BOOLEAN ;

#line 13227
typedef BOOLEAN ;

#line 13239
typedef BOOLEAN ;

#line 13253
typedef NTSTATUS ;

#line 13262
typedef NTSTATUS ;

#line 13275
typedef NTSTATUS ;

#line 13282
typedef NTSTATUS ;

#line 13289
typedef BOOLEAN ;

#line 13304
typedef BOOLEAN ;

#line 13319
typedef BOOLEAN ;

#line 13327
typedef BOOLEAN ;

#line 13336
typedef BOOLEAN ;

#line 13350
typedef struct _FAST_IO_DISPATCH ;

#line 13386
typedef enum _IO_ALLOCATION_ACTION ;

#line 13396
typedef IO_ALLOCATION_ACTION ;

#line 13410
typedef struct _IO_SECURITY_CONTEXT ;

#line 13434
typedef struct _VPB ;

#line 13482
typedef struct _ADAPTER_OBJECT ;

#line 13491
typedef struct _WAIT_CONTEXT_BLOCK ;

#line 13503
typedef struct _CONTROLLER_OBJECT ;

#line 13537
typedef struct _DEVICE_OBJECT ;

#line 13575
typedef struct _DEVICE_OBJECT ;

#line 13578
struct _DEVICE_OBJECT_POWER_EXTENSION ;

typedef struct _DEVOBJ_EXTENSION ;

#line 13608
typedef struct _DRIVER_EXTENSION ;

#line 13645
typedef struct _DRIVER_OBJECT ;

#line 13706
typedef struct _DRIVER_OBJECT ;

#line 13715
typedef struct _SECTION_OBJECT_POINTERS ;

#line 13720
typedef SECTION_OBJECT_POINTERS ;

#line 13726
typedef struct _IO_COMPLETION_CONTEXT ;

#line 13759
typedef struct _FILE_OBJECT ;

#line 13788
typedef struct _FILE_OBJECT ;

#line 13828
typedef struct _IRP ;

#line 14078
typedef NTSTATUS ;

#line 14163
typedef enum _DEVICE_RELATION_TYPE ;

#line 14171
typedef struct _DEVICE_RELATIONS ;

#line 14176
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE ;

#line 14185
typedef struct _INTERFACE ;

#line 14196
typedef struct _DEVICE_CAPABILITIES ;

#line 14229
typedef struct _POWER_SEQUENCE ;

#line 14235
typedef enum  {
	BusQueryDeviceID = 0,
	BusQueryHardwareIDs = 1,
	BusQueryCompatibleIDs = 2,
	BusQueryInstanceID = 3,
	BusQueryDeviceSerialNumber = 4
} ;

typedef ULONG ;

#line 14252
typedef enum  {
	DeviceTextDescription = 0,
	DeviceTextLocationInformation = 1
} ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 14615 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SHARE_ACCESS ;

#line 14635
typedef struct _CONFIGURATION_INFORMATION ;

#line 14848
typedef struct _BOOTDISK_INFORMATION ;

#line 15754
typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK ;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK ;

#line 15764
typedef struct _IO_REMOVE_LOCK_DBG_BLOCK ;

#line 15777
typedef struct _IO_REMOVE_LOCK ;

#line 16009
typedef struct _IO_WORKITEM ;

typedef void ;

#line 16100
typedef enum  {
	DevicePropertyDeviceDescription,
	DevicePropertyHardwareID,
	DevicePropertyCompatibleIDs,
	DevicePropertyBootConfiguration,
	DevicePropertyBootConfigurationTranslated,
	DevicePropertyClassName,
	DevicePropertyClassGuid,
	DevicePropertyDriverKeyName,
	DevicePropertyManufacturer,
	DevicePropertyFriendlyName,
	DevicePropertyLocationInformation,
	DevicePropertyPhysicalDeviceObjectName,
	DevicePropertyBusTypeGuid,
	DevicePropertyLegacyBusType,
	DevicePropertyBusNumber,
	DevicePropertyEnumeratorName,
	DevicePropertyAddress,
	DevicePropertyUINumber
} ;

typedef BOOLEAN ;

#line 16129
typedef struct _DMA_ADAPTER ;

#line 16135
typedef ULONG ;

#line 16148
typedef struct _PNP_BUS_INFORMATION ;

#line 16162
typedef struct _LEGACY_BUS_INFORMATION ;

#line 16168
typedef struct _BUS_INTERFACE_STANDARD ;

#line 16190
typedef BOOLEAN ;

#line 16194
typedef NTSTATUS ;

#line 16203
typedef NTSTATUS ;

#line 16206
typedef NTSTATUS ;

#line 16210
typedef NTSTATUS ;

#line 16214
typedef NTSTATUS ;

#line 16218
typedef void ;

#line 16222
typedef NTSTATUS ;

#line 16227
typedef void ;

#line 16231
typedef struct _ACPI_INTERFACE_STANDARD ;

#line 16255
typedef enum _ACPI_REG_TYPE ;

#line 16268
typedef USHORT ;

#line 16272
typedef void ;

#line 16278
typedef struct ACPI_REGS_INTERFACE_STANDARD ;

#line 16300
typedef struct  {
	PVOID LinkNode ;
	ULONG StaticVector ;
	UCHAR Flags ;
} ;

#line 16314
typedef NTSTATUS ;

#line 16329
typedef NTSTATUS ;

#line 16336
typedef void ;

#line 16343
typedef struct _INT_ROUTE_INTERFACE_STANDARD ;

#line 16366
typedef struct _IO_ASSIGNED_RESOURCES ;

#line 16490
typedef enum _IO_NOTIFICATION_EVENT_CATEGORY ;

#line 16504
typedef NTSTATUS ;

#line 16537
typedef void ;

#line 16573
typedef enum _ARBITER_ACTION ;

#line 16586
typedef struct _ARBITER_CONFLICT_INFO ;

#line 16608
typedef struct _ARBITER_PARAMETERS ;

#line 16719
typedef enum _ARBITER_REQUEST_SOURCE ;

#line 16731
typedef enum _ARBITER_RESULT ;

#line 16761
typedef struct _ARBITER_LIST_ENTRY ;

#line 16832
typedef NTSTATUS ;

#line 16853
typedef struct _ARBITER_INTERFACE ;

#line 16880
typedef enum _RESOURCE_TRANSLATION_DIRECTION ;

#line 16889
typedef NTSTATUS ;

#line 16901
typedef NTSTATUS ;

#line 16915
typedef struct _TRANSLATOR_INTERFACE ;

#line 16931
typedef NTSTATUS ;

#line 16945
typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE ;

#line 16959
typedef struct _PLUGPLAY_NOTIFICATION_HEADER ;

#line 16972
typedef struct _HWPROFILE_CHANGE_NOTIFICATION ;

#line 16986
typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION ;

#line 17006
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION ;

#line 17026
typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION ;

#line 17054
typedef struct _DEVICE_DESCRIPTION ;

#line 17086
typedef BOOLEAN ;

#line 17333
typedef void ;

#line 17339
typedef struct _DEVICE_CONTROL_CONTEXT ;

#line 17349
typedef PBUS_HANDLER ;

#line 17355
typedef void ;

#line 17365
typedef enum _HAL_QUERY_INFORMATION_CLASS ;

#line 17381
typedef enum _HAL_SET_INFORMATION_CLASS ;

#line 17388
typedef NTSTATUS ;

#line 17405
typedef NTSTATUS ;

#line 17420
typedef void ;

#line 17429
typedef void ;

#line 17438
typedef NTSTATUS ;

#line 17447
typedef NTSTATUS ;

#line 17456
typedef NTSTATUS ;

#line 17466
typedef NTSTATUS ;

#line 17475
typedef NTSTATUS ;

#line 17486
typedef struct _PM_DISPATCH_TABLE ;

#line 17492
typedef NTSTATUS ;

#line 17505
typedef struct _DMA_ADAPTER ;

#line 17520
typedef NTSTATUS ;

#line 17543
typedef BOOLEAN ;

#line 17553
typedef NTSTATUS ;

#line 17566
typedef void ;

#line 17572
typedef void ;

#line 17578
typedef BOOLEAN ;

#line 17588
typedef struct  {
	ULONG Version ;
	pHalQuerySystemInformation HalQuerySystemInformation ;
	pHalSetSystemInformation HalSetSystemInformation ;
	pHalQueryBusSlots HalQueryBusSlots ;
	ULONG Spare1 ;
	pHalExamineMBR HalExamineMBR ;
	pHalIoAssignDriveLetters HalIoAssignDriveLetters ;
	pHalIoReadPartitionTable HalIoReadPartitionTable ;
	pHalIoSetPartitionInformation HalIoSetPartitionInformation ;
	pHalIoWritePartitionTable HalIoWritePartitionTable ;
	pHalHandlerForBus HalReferenceHandlerForBus ;
	pHalReferenceBusHandler HalReferenceBusHandler ;
	pHalReferenceBusHandler HalDereferenceBusHandler ;
	pHalInitPnpDriver HalInitPnpDriver ;
	pHalInitPowerManagement HalInitPowerManagement ;
	pHalGetDmaAdapter HalGetDmaAdapter ;
	pHalGetInterruptTranslator HalGetInterruptTranslator ;
} ;

#line 17650
typedef struct _HAL_BUS_INFORMATION ;

#line 17658
typedef struct _HAL_PROFILE_SOURCE_INFORMATION ;

#line 17665
typedef struct _HAL_PROFILE_SOURCE_INTERVAL ;

#line 17671
typedef enum _HAL_DISPLAY_BIOS_INFORMATION ;

#line 17678
typedef struct _HAL_POWER_INFORMATION ;

#line 17683
typedef struct _HAL_PROCESSOR_SPEED_INFO ;

#line 17688
typedef struct _HAL_CALLBACKS ;

#line 17694
typedef struct _HAL_PROCESSOR_FEATURE ;

#line 17706
typedef union _MCI_ADDR ;

#line 17716
typedef enum  {
	HAL_MCE_RECORD,
	HAL_MCA_RECORD
} ;

#line 17726
typedef struct _MCA_EXCEPTION ;

#line 17752
typedef void ;

#line 17762
typedef struct _MCA_DRIVER_INFO ;

#line 17772
typedef struct _SCATTER_GATHER_ELEMENT ;

#line 17778

#pragma warning(disable:4200)
#line 17779
typedef struct _SCATTER_GATHER_LIST ;

#line 17784

#pragma warning(default:4200)
#line 17788
typedef struct _DMA_OPERATIONS ;

typedef struct _DMA_ADAPTER ;

#line 17797
typedef void ;

#line 17801
typedef PVOID ;

#line 17808
typedef void ;

#line 17816
typedef NTSTATUS ;

#line 17824
typedef BOOLEAN ;

#line 17833
typedef void ;

#line 17837
typedef void ;

#line 17843
typedef PHYSICAL_ADDRESS ;

#line 17852
typedef ULONG ;

#line 17856
typedef ULONG ;

#line 17860
typedef void ;

#line 17868
typedef NTSTATUS ;

#line 17880
typedef void ;

#line 17887
typedef struct _DMA_OPERATIONS ;

#line 18235
typedef void ;

#line 18321
typedef struct _OBJECT_HANDLE_INFORMATION ;

#line 18402
typedef struct _PCI_SLOT_NUMBER ;

#line 18418
typedef struct _PCI_COMMON_CONFIG ;

#line 18591
typedef struct _PCI_CAPABILITIES_HEADER ;

#line 18600
typedef struct _PCI_PMC ;

#line 18618
typedef struct _PCI_PMCSR ;

#line 18628
typedef struct _PCI_PMCSR_BSE ;

#line 18635
typedef struct _PCI_PM_CAPABILITY ;

#line 18679
typedef struct _PCI_AGP_CAPABILITY ;

#line 18720
typedef struct _PCI_MSI_CAPABILITY ;

#line 18946
typedef void ;

#line 18954
typedef void ;

#line 18963
typedef void ;

#line 18975
typedef struct _PCIBUSDATA ;

#line 18986
typedef ULONG ;

#line 18995
typedef void ;

#line 19000
typedef void ;

#line 19006
typedef struct _PCI_BUS_INTERFACE_STANDARD ;

#line 19028
typedef BOOLEAN ;

#line 19043
typedef struct _PCI_DEVICE_PRESENT_INTERFACE ;

#line 127 "C:/NTDDK/inc/ntddser.h"
typedef struct _SERIALPERF_STATS ;

#line 136
typedef struct _SERIALCONFIG ;

#line 154
typedef struct _SERIAL_LINE_CONTROL ;

#line 160
typedef struct _SERIAL_TIMEOUTS ;

#line 175
typedef struct _SERIAL_QUEUE_SIZE ;

#line 185
typedef struct _SERIAL_BAUD_RATE ;

#line 247
typedef struct _SERIAL_CHARS ;

#line 284
typedef struct _SERIAL_HANDFLOW ;

#line 340
typedef struct _SERIAL_BASIC_SETTINGS ;

#line 353
typedef struct _SERIAL_STATUS ;

#line 433
typedef struct _SERIAL_XOFF_COUNTER ;

#line 539
typedef struct _SERIAL_COMMPROP ;

#line 631
typedef struct _SERENUM_PORT_DESC ;

#line 652
typedef UCHAR ;

#line 658
typedef void ;

#line 665
typedef enum _SERENUM_PORTION ;

#line 671
typedef struct _SERENUM_PORT_PARAMETERS ;

#line 28 "C:/NTDDK/inc/ddk/wdm/wmilib.h"

#pragma once
#line 38
typedef struct  {
	LPCGUID Guid ;
	ULONG InstanceCount ;
	ULONG Flags ;
} ;

#line 45
typedef NTSTATUS ;

#line 101
typedef NTSTATUS ;

#line 162
typedef NTSTATUS ;

#line 206
typedef NTSTATUS ;

#line 253
typedef NTSTATUS ;

#line 306
typedef enum  {
	WmiEventControl,
	WmiDataBlockControl
} ;

#line 312
typedef NTSTATUS ;

#line 355
typedef struct _WMILIB_CONTEXT ;

#line 411
typedef enum  {
	IrpProcessed,
	IrpNotCompleted,
	IrpNotWmi,
	IrpForward
} ;

#line 13 "C:/NTDDK/inc/wmidata.h"
typedef struct _MSWmi_MofData ;

#line 51
typedef struct _MSWmi_ProviderInfo ;

#line 66
typedef struct _MSWmi_PnPDeviceId ;

#line 83
typedef struct _MSWmi_PnPInstanceNames ;

#line 105
typedef struct _MSSmBios_RawSMBiosTables ;

#line 147
typedef struct _MSPower_DeviceEnable ;

#line 165
typedef struct _MSPower_DeviceWakeEnable ;

#line 182
typedef struct _MSNdis_NetworkAddress ;

#line 199
typedef struct _MSNdis_NetworkShortAddress ;

#line 216
typedef struct _MSNdis_NetworkLinkSpeed ;

#line 239
typedef struct _MSNdis_EnumerateAdapter ;

#line 256
typedef struct _MSNdis_NotifyAdapterRemoval ;

#line 273
typedef struct _MSNdis_NotifyAdapterArrival ;

#line 291
typedef struct _MSNdis_NdisEnumerateVc ;

#line 307
typedef struct _MSNdis_NotifyVcRemoval ;

#line 323
typedef struct _MSNdis_NotifyVcArrival ;

#line 338
typedef struct _MSNdis_HardwareStatus ;

#line 356
typedef struct _MSNdis_MediaSupported ;

#line 378
typedef struct _MSNdis_MediaInUse ;

#line 400
typedef struct _MSNdis_MaximumLookahead ;

#line 418
typedef struct _MSNdis_MaximumFrameSize ;

#line 436
typedef struct _MSNdis_LinkSpeed ;

#line 454
typedef struct _MSNdis_TransmitBufferSpace ;

#line 472
typedef struct _MSNdis_ReceiveBufferSpace ;

#line 490
typedef struct _MSNdis_TransmitBlockSize ;

#line 508
typedef struct _MSNdis_ReceiveBlockSize ;

#line 526
typedef struct _MSNdis_VendorID ;

#line 544
typedef struct _MSNdis_VendorDescription ;

#line 561
typedef struct _MSNdis_CurrentPacketFilter ;

#line 579
typedef struct _MSNdis_CurrentLookahead ;

#line 597
typedef struct _MSNdis_DriverVersion ;

#line 615
typedef struct _MSNdis_MaximumTotalSize ;

#line 633
typedef struct _MSNdis_MacOptions ;

#line 651
typedef struct _MSNdis_MediaConnectStatus ;

#line 669
typedef struct _MSNdis_MaximumSendPackets ;

#line 687
typedef struct _MSNdis_VendorDriverVersion ;

#line 705
typedef struct _MSNdis_TransmitsOk ;

#line 723
typedef struct _MSNdis_ReceivesOk ;

#line 741
typedef struct _MSNdis_TransmitsError ;

#line 759
typedef struct _MSNdis_ReceiveError ;

#line 777
typedef struct _MSNdis_ReceiveNoBuffer ;

#line 795
typedef struct _MSNdis_CoHardwareStatus ;

#line 813
typedef struct _MSNdis_CoMediaSupported ;

#line 835
typedef struct _MSNdis_CoMediaInUse ;

#line 857
typedef struct _MSNdis_CoLinkSpeed ;

#line 875
typedef struct _MSNdis_CoVendorId ;

#line 893
typedef struct _MSNdis_CoVendorDescription ;

#line 910
typedef struct _MSNdis_CoDriverVersion ;

#line 928
typedef struct _MSNdis_CoMacOptions ;

#line 946
typedef struct _MSNdis_CoMediaConnectStatus ;

#line 964
typedef struct _MSNdis_CoVendorDriverVersion ;

#line 982
typedef struct _MSNdis_CoMinimumLinkSpeed ;

#line 1000
typedef struct _MSNdis_CoTransmitPdusOk ;

#line 1018
typedef struct _MSNdis_CoReceivePdusOk ;

#line 1036
typedef struct _MSNdis_CoTransmitPduErrors ;

#line 1054
typedef struct _MSNdis_CoReceivePduErrors ;

#line 1072
typedef struct _MSNdis_CoReceivePdusNoBuffer ;

#line 1090
typedef struct _MSNdis_AtmSupportedVcRates ;

#line 1113
typedef struct _MSNdis_AtmSupportedServiceCategory ;

#line 1131
typedef struct _MSNdis_AtmSupportedAalTypes ;

#line 1149
typedef struct _MSNdis_AtmHardwareCurrentAddress ;

#line 1167
typedef struct _MSNdis_AtmMaxActiveVcs ;

#line 1185
typedef struct _MSNdis_AtmMaxActiveVciBits ;

#line 1203
typedef struct _MSNdis_AtmMaxActiveVpiBits ;

#line 1221
typedef struct _MSNdis_AtmMaxAal0PacketSize ;

#line 1239
typedef struct _MSNdis_AtmMaxAal1PacketSize ;

#line 1257
typedef struct _MSNdis_AtmMaxAal34PacketSize ;

#line 1275
typedef struct _MSNdis_AtmMaxAal5PacketSize ;

#line 1293
typedef struct _MSNdis_AtmReceiveCellsOk ;

#line 1311
typedef struct _MSNdis_AtmTransmitCellsOk ;

#line 1329
typedef struct _MSNdis_AtmReceiveCellsDropped ;

#line 1347
typedef struct _MSNdis_EthernetPermanentAddress ;

#line 1365
typedef struct _MSNdis_EthernetCurrentAddress ;

#line 1383
typedef struct _MSNdis_EthernetMulticastList ;

#line 1405
typedef struct _MSNdis_EthernetMaximumMulticastListSize ;

#line 1423
typedef struct _MSNdis_EthernetMacOptions ;

#line 1441
typedef struct _MSNdis_EthernetReceiveErrorAlignment ;

#line 1459
typedef struct _MSNdis_EthernetOneTransmitCollision ;

#line 1477
typedef struct _MSNdis_EthernetMoreTransmitCollisions ;

#line 1495
typedef struct _MSNdis_TokenRingPermanentAddress ;

#line 1513
typedef struct _MSNdis_TokenRingCurrentAddress ;

#line 1531
typedef struct _MSNdis_TokenRingCurrentFunctional ;

#line 1549
typedef struct _MSNdis_TokenRingCurrentGroup ;

#line 1567
typedef struct _MSNdis_TokenRingLastOpenStatus ;

#line 1585
typedef struct _MSNdis_TokenRingCurrentRingStatus ;

#line 1603
typedef struct _MSNdis_TokenRingCurrentRingState ;

#line 1621
typedef struct _MSNdis_TokenRingLineErrors ;

#line 1639
typedef struct _MSNdis_TokenRingLostFrames ;

#line 1657
typedef struct _MSNdis_FddiLongPermanentAddress ;

#line 1675
typedef struct _MSNdis_FddiLongCurrentAddress ;

#line 1693
typedef struct _MSNdis_FddiLongMulticastList ;

#line 1715
typedef struct _MSNdis_FddiLongMaximumListSize ;

#line 1733
typedef struct _MSNdis_FddiShortPermanentAddress ;

#line 1751
typedef struct _MSNdis_FddiShortCurrentAddress ;

#line 1769
typedef struct _MSNdis_FddiShortMulticastList ;

#line 1791
typedef struct _MSNdis_FddiShortMaximumListSize ;

#line 1809
typedef struct _MSNdis_FddiAttachmentType ;

#line 1827
typedef struct _MSNdis_FddiUpstreamNodeLong ;

#line 1845
typedef struct _MSNdis_FddiDownstreamNodeLong ;

#line 1863
typedef struct _MSNdis_FddiFrameErrors ;

#line 1881
typedef struct _MSNdis_FddiFramesLost ;

#line 1899
typedef struct _MSNdis_FddiRingManagmentState ;

#line 1917
typedef struct _MSNdis_FddiLctFailures ;

#line 1935
typedef struct _MSNdis_FddiLemRejects ;

#line 1953
typedef struct _MSNdis_FddiLConnectionState ;

#line 1972
typedef struct _MSNdis_StatusResetStart ;

#line 1988
typedef struct _MSNdis_StatusResetEnd ;

#line 2004
typedef struct _MSNdis_StatusMediaConnect ;

#line 2020
typedef struct _MSNdis_StatusMediaDisconnect ;

#line 2035
typedef struct _MSNdis_StatusMediaSpecificIndication ;

#line 2057
typedef struct _MSNdis_StatusLinkSpeedChange ;

#line 2075
typedef struct _MSNdis_StatusProtocolBind ;

#line 2092
typedef struct _MSNdis_StatusProtocolUnbind ;

#line 2109
typedef struct _KEYBOARD_PORT_WMI_STD_DATA ;

#line 2152
typedef struct _POINTER_PORT_WMI_STD_DATA ;

#line 2205
typedef struct _MSMouse_ClassInformation ;

#line 2223
typedef struct _MSKeyboard_ClassInformation ;

#line 2241
typedef struct _MSAcpi_ThermalZoneTemperature ;

#line 2304
typedef struct _WMI_DISK_GEOMETRY ;

#line 2342
typedef struct _WMI_DISK_PERFORMANCE ;

#line 2415
typedef struct _MSDiskDriver_Performance ;

#line 2437
typedef struct _STORAGE_FAILURE_PREDICT_STATUS ;

#line 2460
typedef struct _STORAGE_FAILURE_PREDICT_DATA ;

#line 2483
typedef struct _STORAGE_FAILURE_PREDICT_EVENT ;

#line 2513
typedef struct _STORAGE_FAILURE_PREDICT_FUNCTION ;

#line 2528
typedef struct _MSIde_PortDeviceInfo ;

#line 2556
typedef struct _MSSerial_PortName ;

#line 2573
typedef struct _SERIAL_WMI_COMM_DATA ;

#line 2723
typedef struct _SERIAL_WMI_HW_DATA ;

#line 2770
typedef struct _SERIAL_WMI_PERF_DATA ;

#line 2813
typedef struct _SERIAL_WMI_COMMPROP ;

#line 2920
typedef struct _PARPORT_WMI_ALLOC_FREE_COUNTS ;

#line 2943
typedef struct _PARALLEL_WMI_LOG_INFO ;

#line 3041
typedef struct _REDBOOK_WMI_STD_DATA ;

#line 3094
typedef struct _REDBOOK_WMI_PERF_DATA ;

#line 3137
typedef struct _RegisteredGuids ;

#line 475 "serial.h"
typedef struct _CONFIG_DATA ;

#line 509
typedef struct _SERIAL_CISR_SW ;

#line 520
typedef struct _SERIAL_FIRMWARE_DATA ;

#line 576
typedef struct _SERIAL_DEVICE_STATE ;

#line 646
typedef struct _SERIAL_DEVICE_EXTENSION ;

#line 1808
typedef struct _SERIAL_MULTIPORT_DISPATCH ;

#line 2157
typedef enum _SERIAL_MEM_COMPARES ;

#line 2164
typedef struct _SERIAL_LIST_DATA ;

#line 2169
typedef struct _SERIAL_GLOBALS ;

#line 2180
typedef struct _SERIAL_USER_DATA ;

#line 2206
typedef struct _SERIAL_PTR_CTX ;

#line 20 "serialp.h"
typedef NTSTATUS ;

#line 26
typedef void ;

#line 835
typedef struct _SERIAL_UPDATE_CHAR ;

#line 846
typedef struct _SERIAL_IOCTL_SYNC ;

#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"

#pragma once
#line 32

#pragma pack(push, 8)
#line 72
typedef enum _EXCEPTION_DISPOSITION ;

#line 89
struct _EXCEPTION_RECORD ;

#line 90
struct _CONTEXT ;

#line 155

#pragma pack(pop)
#line 25 "C:/NTDDK/inc/ntdef.h"

#pragma once
#line 15 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"

#pragma once
#line 60
typedef unsigned short ;

#line 66
typedef wchar_t ;

#line 67
typedef wchar_t ;

#line 127 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long ;

#line 25 "C:/NTDDK/inc/basetsd.h"

#pragma once
#line 36
typedef int ;

#line 37
typedef int ;

#line 43
typedef unsigned int ;

#line 44
typedef unsigned int ;

#line 45
typedef unsigned int ;

#line 84
typedef int ;

#line 85
typedef unsigned int ;

typedef long ;

#line 88
typedef unsigned long ;

#line 248
typedef unsigned short ;

#line 249
typedef short ;

#line 250
typedef unsigned long ;

#line 288
typedef ULONG_PTR ;

#line 289
typedef LONG_PTR ;

#line 295
typedef ULONG_PTR ;

#line 301
typedef __int64 ;

#line 302
typedef __int64 ;

#line 309
typedef unsigned __int64 ;

#line 310
typedef unsigned __int64 ;

#line 311
typedef unsigned __int64 ;

#line 217 "C:/NTDDK/inc/ntdef.h"
typedef void ;

#line 218
typedef void ;

#line 266
typedef char ;

#line 267
typedef short ;

#line 268
typedef long ;

#line 276
typedef wchar_t ;

#line 282
typedef WCHAR ;

#line 283
typedef WCHAR ;

#line 284
typedef const WCHAR ;

#line 285
typedef WCHAR ;

#line 286
typedef WCHAR ;

typedef const WCHAR ;

#line 293
typedef CHAR ;

#line 294
typedef CHAR ;

typedef const CHAR ;

#line 297
typedef CHAR ;

#line 298
typedef CHAR ;

#line 299
typedef const CHAR ;

#line 321
typedef char ;

#line 322
typedef unsigned char ;

#line 326
typedef LPSTR ;

#line 327
typedef LPSTR ;

#line 328
typedef LPCSTR ;

#line 337
typedef double ;

typedef struct _QUAD ;

#line 349
typedef SHORT ;

#line 350
typedef LONG ;

#line 351
typedef QUAD ;

#line 360
typedef unsigned char ;

#line 361
typedef unsigned short ;

#line 362
typedef unsigned long ;

#line 363
typedef QUAD ;

#line 369
typedef UCHAR ;

#line 370
typedef USHORT ;

#line 371
typedef ULONG ;

#line 372
typedef UQUAD ;

#line 378
typedef signed char ;

#line 379
typedef SCHAR ;

#line 394
typedef void ;

#line 400
typedef HANDLE ;

#line 406
typedef UCHAR ;

#line 407
typedef USHORT ;

#line 408
typedef ULONG ;

#line 414
typedef LONG ;

#line 478
typedef char ;

#line 479
typedef short ;

#line 480
typedef ULONG ;

typedef CCHAR ;

#line 483
typedef CSHORT ;

#line 484
typedef CLONG ;

#line 492
typedef ULONG ;

#line 493
typedef PULONG ;

#line 494
typedef USHORT ;

#line 500
typedef ULONG ;

#line 501
typedef ULONG ;

#line 508
typedef LONG ;

typedef NTSTATUS ;

#line 602
typedef struct _FLOAT128 ;

#line 607
typedef FLOAT128 ;

#line 621
typedef __int64 ;

#line 622
typedef unsigned __int64 ;

#line 639
typedef LONGLONG ;

#line 640
typedef ULONGLONG ;

#line 644
typedef LONGLONG ;

#line 649
typedef union _LARGE_INTEGER ;

#line 662
typedef LARGE_INTEGER ;

#line 668
typedef union _ULARGE_INTEGER ;

#line 681
typedef ULARGE_INTEGER ;

#line 690
typedef struct _LUID ;

#line 696
typedef ULONGLONG ;

#line 697
typedef DWORDLONG ;

#line 707
typedef LARGE_INTEGER ;

#line 831

#pragma warning(push)

#pragma warning(disable:4035)
__inline ULONGLONG __stdcall Int64ShllMod32___20(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 842
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    
		};
}

#line 845
__inline LONGLONG __stdcall Int64ShraMod32___20(LONGLONG Value , ULONG
	ShiftCount )
{
	#line 852
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    
		};
}

#line 855
__inline ULONGLONG __stdcall Int64ShrlMod32___20(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 862
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    
		};
}


#pragma warning(pop)
#line 956
typedef enum _EVENT_TYPE ;

#line 965
typedef enum _TIMER_TYPE ;

#line 974
typedef enum _WAIT_TYPE ;

#line 983
typedef CHAR ;

#line 984
typedef const char ;

#line 991
typedef struct _STRING ;

#line 999
typedef STRING ;

typedef STRING ;

#line 1002
typedef PSTRING ;

typedef STRING ;

#line 1005
typedef PSTRING ;

#line 1011
typedef struct _CSTRING ;

#line 1016
typedef CSTRING ;

#line 1019
typedef STRING ;

#line 1020
typedef PSTRING ;

#line 1027
typedef struct _UNICODE_STRING ;

#line 1036
typedef UNICODE_STRING ;

#line 1037
typedef const UNICODE_STRING ;

#line 1046
typedef UCHAR ;

#line 1047
typedef BOOLEAN ;

#line 1057
typedef struct _LIST_ENTRY ;

#line 1067
typedef struct _SINGLE_LIST_ENTRY ;

#line 1078
typedef struct LIST_ENTRY32 ;

#line 1082
typedef LIST_ENTRY32 ;

typedef struct LIST_ENTRY64 ;

#line 1088
typedef LIST_ENTRY64 ;

#line 1127
typedef struct _STRING32 ;

#line 1132
typedef STRING32 ;

typedef STRING32 ;

#line 1135
typedef UNICODE_STRING32 ;

typedef STRING32 ;

#line 1138
typedef ANSI_STRING32 ;

#line 1141
typedef struct _STRING64 ;

#line 1146
typedef STRING64 ;

typedef STRING64 ;

#line 1149
typedef UNICODE_STRING64 ;

typedef STRING64 ;

#line 1152
typedef ANSI_STRING64 ;

#line 1173
typedef struct _OBJECT_ATTRIBUTES ;

#line 1181
typedef OBJECT_ATTRIBUTES ;

#line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID ;

#line 70
typedef GUID ;

#line 75
typedef const GUID ;

#line 81
typedef GUID ;

#line 82
typedef IID ;

#line 85
typedef GUID ;

#line 86
typedef CLSID ;

#line 89
typedef GUID ;

#line 90
typedef FMTID ;

#line 16 "C:/NTDDK/inc/string.h"

#pragma once
#line 54
typedef unsigned int ;

#line 1233 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECTID ;

#line 1288
struct _CONTEXT ;

#line 1289
struct _EXCEPTION_RECORD ;

typedef EXCEPTION_DISPOSITION ;

#line 1306
typedef UCHAR ;

typedef KIRQL ;

#line 1316
typedef enum _NT_PRODUCT_TYPE ;

#line 1329
typedef enum _SUITE_TYPE ;

#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD ;

#line 76
typedef struct _ETHREAD ;

#line 77
typedef struct _EPROCESS ;

#line 78
typedef struct _PEB ;

#line 79
typedef struct _KINTERRUPT ;

#line 80
typedef struct _IO_TIMER ;

#line 81
typedef struct _OBJECT_TYPE ;

#line 82
typedef struct _CALLBACK_OBJECT ;

#line 83
typedef struct _DEVICE_HANDLER_OBJECT ;

#line 84
typedef struct _BUS_HANDLER ;

#line 143
typedef union _SLIST_HEADER ;

#line 204
typedef CCHAR ;

typedef enum _MODE ;

#line 222
struct _KAPC ;

typedef void ;

#line 232
typedef void ;

#line 242
typedef void ;

#line 248
typedef BOOLEAN ;

#line 254
typedef BOOLEAN ;

#line 265
typedef struct _KAPC ;

#line 292
struct _KDPC ;

typedef void ;

#line 351
typedef enum _KDPC_IMPORTANCE ;

#line 361
typedef struct _KDPC ;

#line 377
typedef PVOID ;

typedef void ;

#line 392
typedef struct _KIPI_COUNTS ;

#line 443
typedef struct _MDL ;

#line 532
typedef PVOID ;

#line 538
typedef PVOID ;

#line 544
typedef PVOID ;

typedef ULONG ;

#line 547
typedef ACCESS_MASK ;

#line 597
typedef struct _GENERIC_MAPPING ;

#line 603
typedef GENERIC_MAPPING ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES ;

#line 622
typedef LUID_AND_ATTRIBUTES ;

#line 623
typedef LUID_AND_ATTRIBUTES_ARRAY ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 642 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACL ;

#line 649
typedef ACL ;

#line 681
typedef struct _PRIVILEGE_SET ;

#line 735
typedef enum _SECURITY_IMPERSONATION_LEVEL ;

#line 753
typedef BOOLEAN ;

#line 762
typedef struct _SECURITY_QUALITY_OF_SERVICE ;

#line 774
typedef struct _SE_IMPERSONATION_STATE ;

#line 782
typedef ULONG ;

#line 809
typedef ULONG ;

#line 810
typedef KAFFINITY ;

#line 816
typedef LONG ;

#line 824
typedef ULONG_PTR ;

#line 825
typedef KSPIN_LOCK ;

#line 833
typedef void ;

#line 842
typedef enum _KPROFILE_SOURCE ;

#line 1079
typedef NTSTATUS ;

#line 1088
typedef struct _RTL_QUERY_REGISTRY_TABLE ;

#line 1952

#pragma warning(push)

#pragma warning(disable:4035)
#line 2019

#pragma warning(pop)
#line 2214
typedef struct _TIME_FIELDS ;

#line 2224
typedef TIME_FIELDS ;

#line 2499
typedef struct _RTL_BITMAP ;

#line 2503
typedef RTL_BITMAP ;

#line 2627
typedef struct _RTL_BITMAP_RUN ;

#line 2633
typedef RTL_BITMAP_RUN ;

#line 2886
typedef struct _RTL_RANGE ;

#line 2924
typedef struct _RTL_RANGE_LIST ;

#line 2950
typedef struct _RANGE_LIST_ITERATOR ;

#line 3019
typedef BOOLEAN ;

#line 3155
typedef struct _OSVERSIONINFOA ;

#line 3164
typedef struct _OSVERSIONINFOW ;

#line 3177
typedef OSVERSIONINFOA ;

#line 3178
typedef POSVERSIONINFOA ;

#line 3179
typedef LPOSVERSIONINFOA ;

#line 3182
typedef struct _OSVERSIONINFOEXA ;

#line 3195
typedef struct _OSVERSIONINFOEXW ;

#line 3213
typedef OSVERSIONINFOEXA ;

#line 3214
typedef POSVERSIONINFOEXA ;

#line 3215
typedef LPOSVERSIONINFOEXA ;

#line 3648
typedef struct _IO_STATUS_BLOCK ;

#line 3669
typedef void ;

#line 3685
typedef enum _FILE_INFORMATION_CLASS ;

#line 3731
typedef struct _FILE_BASIC_INFORMATION ;

#line 3739
typedef struct _FILE_STANDARD_INFORMATION ;

#line 3747
typedef struct _FILE_POSITION_INFORMATION ;

#line 3751
typedef struct _FILE_ALIGNMENT_INFORMATION ;

#line 3755
typedef struct _FILE_NAME_INFORMATION ;

#line 3760
typedef struct _FILE_NETWORK_OPEN_INFORMATION ;

#line 3770
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION ;

#line 3775
typedef struct _FILE_DISPOSITION_INFORMATION ;

#line 3779
typedef struct _FILE_END_OF_FILE_INFORMATION ;

#line 3784
typedef struct _FILE_FULL_EA_INFORMATION ;

#line 3798
typedef enum _FSINFOCLASS ;

#line 3810
typedef struct _FILE_FS_DEVICE_INFORMATION ;

#line 3820
typedef union _FILE_SEGMENT_ELEMENT ;

#line 3829
typedef enum _INTERFACE_TYPE ;

#line 3854
typedef enum _DMA_WIDTH ;

#line 3865
typedef enum _DMA_SPEED ;

#line 3879
typedef void ;

#line 3880
typedef void ;

#line 3888
typedef enum _BUS_DATA_TYPE ;

#line 3910
typedef struct _IO_ERROR_LOG_PACKET ;

#line 3931
typedef struct _IO_ERROR_LOG_MESSAGE ;

#line 4074
typedef struct _KEY_BASIC_INFORMATION ;

#line 4081
typedef struct _KEY_NODE_INFORMATION ;

#line 4091
typedef struct _KEY_FULL_INFORMATION ;

#line 4106
typedef struct _KEY_NAME_INFORMATION ;

#line 4112
typedef enum _KEY_INFORMATION_CLASS ;

#line 4122
typedef struct _KEY_WRITE_TIME_INFORMATION ;

#line 4126
typedef enum _KEY_SET_INFORMATION_CLASS ;

#line 4134
typedef struct _KEY_VALUE_BASIC_INFORMATION ;

#line 4141
typedef struct _KEY_VALUE_FULL_INFORMATION ;

#line 4151
typedef struct _KEY_VALUE_PARTIAL_INFORMATION ;

#line 4158
typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ;

#line 4164
typedef struct _KEY_VALUE_ENTRY ;

#line 4171
typedef enum _KEY_VALUE_INFORMATION_CLASS ;

#line 4210
typedef struct _OBJECT_NAME_INFORMATION ;

#line 4221
typedef enum _SECTION_INHERIT ;

#line 4294
typedef struct _CLIENT_ID ;

#line 4298
typedef CLIENT_ID ;

#line 4315
typedef struct _NT_TIB ;

#line 4327
typedef NT_TIB ;

#line 4332
typedef enum _PROCESSINFOCLASS ;

#line 4366
typedef enum _THREADINFOCLASS ;

#line 4395
typedef struct _PROCESS_WS_WATCH_INFORMATION ;

#line 4405
typedef struct _PROCESS_BASIC_INFORMATION ;

#line 4413
typedef PROCESS_BASIC_INFORMATION ;

#line 4422
typedef struct _PROCESS_DEVICEMAP_INFORMATION ;

#line 4440
typedef struct _PROCESS_SESSION_INFORMATION ;

#line 4454
typedef struct _QUOTA_LIMITS ;

#line 4462
typedef QUOTA_LIMITS ;

#line 4472
typedef struct _IO_COUNTERS ;

#line 4480
typedef IO_COUNTERS ;

#line 4488
typedef struct _VM_COUNTERS ;

#line 4501
typedef VM_COUNTERS ;

#line 4508
typedef struct _POOLED_USAGE_AND_LIMITS ;

#line 4519
typedef POOLED_USAGE_AND_LIMITS ;

#line 4528
typedef struct _PROCESS_ACCESS_TOKEN ;

#line 4555
typedef struct _KERNEL_USER_TIMES ;

#line 4561
typedef KERNEL_USER_TIMES ;

#line 4587
typedef enum _SYSTEM_POWER_STATE ;

#line 4598
typedef enum  {
	PowerActionNone = 0,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
} ;

typedef enum _DEVICE_POWER_STATE ;

#line 4618
typedef union _POWER_STATE ;

#line 4623
typedef enum _POWER_STATE_TYPE ;

#line 4654
typedef ULONG ;

typedef enum  {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
} ;

#line 4663
typedef enum  {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation
} ;

#line 4690
typedef ULONG ;

typedef LONG ;

#line 4693
typedef ULONG ;

#line 4719
typedef union _MCI_STATS ;

#line 4978
typedef struct _KPCR ;

#line 5006
typedef KPCR ;

#line 5012
typedef struct _KFLOATING_SAVE ;

#line 5153
typedef enum _INTERLOCKED_RESULT ;

#line 5252

#pragma warning(disable:4035)
#line 6994
typedef struct _KSYSTEM_TIME ;

#line 7014

#pragma warning(push)

#pragma warning(disable:4164)
#line 7019

#pragma function(_enable)
#line 7020

#pragma function(_disable)
#line 7024

#pragma warning(pop)
#line 7085
typedef struct _FLOATING_SAVE_AREA ;

#line 7097
typedef FLOATING_SAVE_AREA ;

#line 7109
typedef struct _CONTEXT ;

#line 7197
typedef CONTEXT ;

#line 7826
typedef void ;

#line 7850
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ;

#line 7899
typedef struct _KUSER_SHARED_DATA ;

#line 8123
typedef enum _CM_SERVICE_NODE_TYPE ;

#line 8132
typedef enum _CM_SERVICE_LOAD_TYPE ;

#line 8140
typedef enum _CM_ERROR_CONTROL_TYPE ;

#line 8172
typedef int ;

#line 8198
typedef enum _CM_SHARE_DISPOSITION ;

#line 8211
typedef PVOID ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST ;

#line 8443
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR ;

#line 8454
typedef struct _CM_RESOURCE_LIST ;

#line 8471
typedef struct _DEVICE_FLAGS ;

#line 8485
typedef struct _CM_COMPONENT_INFORMATION ;

#line 8503
typedef struct _CM_ROM_BLOCK ;

#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 8518 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_INT13_DRIVE_PARAMETER ;

#line 8532
typedef struct _CM_MCA_POS_DATA ;

#line 8544
typedef struct _EISA_MEMORY_TYPE ;

#line 8554
typedef struct _EISA_MEMORY_CONFIGURATION ;

#line 8567
typedef struct _EISA_IRQ_DESCRIPTOR ;

#line 8575
typedef struct _EISA_IRQ_CONFIGURATION ;

#line 8585
typedef struct _DMA_CONFIGURATION_BYTE0 ;

#line 8592
typedef struct _DMA_CONFIGURATION_BYTE1 ;

#line 8599
typedef struct _EISA_DMA_CONFIGURATION ;

#line 8609
typedef struct _EISA_PORT_DESCRIPTOR ;

#line 8616
typedef struct _EISA_PORT_CONFIGURATION ;

#line 8628
typedef struct _CM_EISA_SLOT_INFORMATION ;

#line 8644
typedef struct _CM_EISA_FUNCTION_INFORMATION ;

#line 8678
typedef struct _CM_PNP_BIOS_DEVICE_NODE ;

#line 8692
typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8761 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_SCSI_DEVICE_DATA ;

#line 8775
typedef struct _CM_VIDEO_DEVICE_DATA ;

#line 8785
typedef struct _CM_SONIC_DEVICE_DATA ;

#line 8796
typedef struct _CM_SERIAL_DEVICE_DATA ;

#line 8810
typedef struct _CM_MONITOR_DEVICE_DATA ;

#line 8844
typedef struct _CM_FLOPPY_DEVICE_DATA ;

#line 8881
typedef struct _CM_KEYBOARD_DEVICE_DATA ;

#line 8893
typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA ;

#line 8905
typedef struct _CM_PCCARD_DEVICE_DATA ;

#line 8944
typedef struct _IO_RESOURCE_DESCRIPTOR ;

#line 9027
typedef struct _IO_RESOURCE_LIST ;

#line 9036
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST ;

#line 9065
typedef struct _EXCEPTION_RECORD ;

#line 9074
typedef EXCEPTION_RECORD ;

typedef struct _EXCEPTION_RECORD32 ;

#line 9085
typedef struct _EXCEPTION_RECORD64 ;

#line 9099
typedef struct _EXCEPTION_POINTERS ;

#line 9111
typedef enum _CONFIGURATION_TYPE ;

#line 9161
typedef enum _KINTERRUPT_MODE ;

#line 9170
typedef enum _KWAIT_REASON ;

#line 9207
typedef struct _DISPATCHER_HEADER ;

#line 9217
typedef struct _KWAIT_BLOCK ;

#line 9230
typedef void ;

#line 9244
typedef struct _KDEVICE_QUEUE ;

#line 9252
typedef struct _KDEVICE_QUEUE_ENTRY ;

#line 9263
typedef struct _KEVENT ;

#line 9271
typedef BOOLEAN ;

#line 9281
typedef struct _KMUTANT ;

#line 9294
typedef struct _KSEMAPHORE ;

#line 9304
typedef struct _KTIMER ;

#line 9899
typedef enum _KBUGCHECK_BUFFER_DUMP_STATE ;

#line 9907
typedef void ;

#line 9914
typedef struct _KBUGCHECK_CALLBACK_RECORD ;

#line 10002
typedef void ;

#line 10020
typedef LOGICAL ;

#line 10037
typedef void ;

#line 10053
typedef enum _MEMORY_CACHING_TYPE_ORIG ;

#line 10057
typedef enum _MEMORY_CACHING_TYPE ;

#line 10087
typedef struct _DBGKD_DEBUG_DATA_HEADER64 ;

#line 10115
typedef enum _POOL_TYPE ;

#line 10195
typedef enum _EX_POOL_PRIORITY ;

#line 10247
typedef struct _FAST_MUTEX ;

#line 10574
typedef PVOID ;

#line 10582
typedef void ;

#line 10588
typedef struct _GENERAL_LOOKASIDE ;

#line 10619
typedef struct _NPAGED_LOOKASIDE_LIST ;

#line 10729
typedef struct _PAGED_LOOKASIDE_LIST ;

#line 10882
typedef enum _WORK_QUEUE_TYPE ;

#line 10889
typedef void ;

#line 10895
typedef struct _WORK_QUEUE_ITEM ;

#line 10926
typedef struct _ZONE_SEGMENT_HEADER ;

#line 10931
typedef struct _ZONE_HEADER ;

#line 11156
typedef ULONG_PTR ;

#line 11157
typedef ERESOURCE_THREAD ;

typedef struct _OWNER_ENTRY ;

#line 11168
typedef struct _ERESOURCE ;

#line 11197
typedef struct _RESOURCE_HASH_ENTRY ;

#line 11204
typedef struct _RESOURCE_PERFORMANCE_DATA ;

#line 11429
typedef struct _CALLBACK_OBJECT ;

typedef void ;

#line 11474
typedef GUID ;

#line 11862
typedef enum _MM_SYSTEM_SIZE ;

#line 11884
typedef enum _LOCK_OPERATION ;

#line 11970
typedef enum _MM_PAGE_PRIORITY ;

#line 11999
typedef struct _PHYSICAL_MEMORY_RANGE ;

#line 12385
typedef NTSTATUS ;

#line 12389
typedef NTSTATUS ;

#line 12399
struct _DRIVER_OBJECT ;

#line 12411
typedef enum _SECURITY_OPERATION_CODE ;

#line 12426
typedef struct _SECURITY_SUBJECT_CONTEXT ;

#line 12448
typedef struct _INITIAL_PRIVILEGE_SET ;

#line 12462
typedef struct _ACCESS_STATE ;

#line 12571
typedef void ;

#line 12585
typedef void ;

#line 12602
typedef struct _IMAGE_INFO ;

#line 12620
typedef void ;

#line 12859
typedef NTSTATUS ;

#line 12878
typedef enum _IO_QUERY_DEVICE_DATA_FORMAT ;

#line 12890
typedef enum _CREATE_FILE_TYPE ;

#line 12905
struct _DEVICE_DESCRIPTION ;

#line 12906
struct _DEVICE_OBJECT ;

#line 12907
struct _DMA_ADAPTER ;

#line 12908
struct _DRIVER_OBJECT ;

#line 12909
struct _DRIVE_LAYOUT_INFORMATION ;

#line 12910
struct _DISK_PARTITION ;

#line 12911
struct _FILE_OBJECT ;

#line 12912
struct _IRP ;

#line 12913
struct _SCSI_REQUEST_BLOCK ;

#line 12919
typedef void ;

#line 12932
typedef void ;

#line 12943
typedef NTSTATUS ;

#line 12955
typedef void ;

#line 12968
typedef void ;

#line 12979
typedef NTSTATUS ;

#line 12990
typedef void ;

#line 13001
typedef void ;

#line 13011
typedef NTSTATUS ;

#line 13025
typedef BOOLEAN ;

#line 13038
typedef BOOLEAN ;

#line 13051
typedef BOOLEAN ;

#line 13068
typedef BOOLEAN ;

#line 13078
typedef BOOLEAN ;

#line 13092
typedef BOOLEAN ;

#line 13106
typedef BOOLEAN ;

#line 13118
typedef BOOLEAN ;

#line 13127
typedef BOOLEAN ;

#line 13141
typedef BOOLEAN ;

#line 13161
typedef void ;

#line 13167
typedef void ;

#line 13179
typedef void ;

#line 13193
typedef BOOLEAN ;

#line 13207
typedef BOOLEAN ;

#line 13219
typedef BOOLEAN ;

#line 13227
typedef BOOLEAN ;

#line 13239
typedef BOOLEAN ;

#line 13253
typedef NTSTATUS ;

#line 13262
typedef NTSTATUS ;

#line 13275
typedef NTSTATUS ;

#line 13282
typedef NTSTATUS ;

#line 13289
typedef BOOLEAN ;

#line 13304
typedef BOOLEAN ;

#line 13319
typedef BOOLEAN ;

#line 13327
typedef BOOLEAN ;

#line 13336
typedef BOOLEAN ;

#line 13350
typedef struct _FAST_IO_DISPATCH ;

#line 13386
typedef enum _IO_ALLOCATION_ACTION ;

#line 13396
typedef IO_ALLOCATION_ACTION ;

#line 13410
typedef struct _IO_SECURITY_CONTEXT ;

#line 13434
typedef struct _VPB ;

#line 13482
typedef struct _ADAPTER_OBJECT ;

#line 13491
typedef struct _WAIT_CONTEXT_BLOCK ;

#line 13503
typedef struct _CONTROLLER_OBJECT ;

#line 13537
typedef struct _DEVICE_OBJECT ;

#line 13575
typedef struct _DEVICE_OBJECT ;

#line 13578
struct _DEVICE_OBJECT_POWER_EXTENSION ;

typedef struct _DEVOBJ_EXTENSION ;

#line 13608
typedef struct _DRIVER_EXTENSION ;

#line 13645
typedef struct _DRIVER_OBJECT ;

#line 13706
typedef struct _DRIVER_OBJECT ;

#line 13715
typedef struct _SECTION_OBJECT_POINTERS ;

#line 13720
typedef SECTION_OBJECT_POINTERS ;

#line 13726
typedef struct _IO_COMPLETION_CONTEXT ;

#line 13759
typedef struct _FILE_OBJECT ;

#line 13788
typedef struct _FILE_OBJECT ;

#line 13828
typedef struct _IRP ;

#line 14078
typedef NTSTATUS ;

#line 14163
typedef enum _DEVICE_RELATION_TYPE ;

#line 14171
typedef struct _DEVICE_RELATIONS ;

#line 14176
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE ;

#line 14185
typedef struct _INTERFACE ;

#line 14196
typedef struct _DEVICE_CAPABILITIES ;

#line 14229
typedef struct _POWER_SEQUENCE ;

#line 14235
typedef enum  {
	BusQueryDeviceID = 0,
	BusQueryHardwareIDs = 1,
	BusQueryCompatibleIDs = 2,
	BusQueryInstanceID = 3,
	BusQueryDeviceSerialNumber = 4
} ;

typedef ULONG ;

#line 14252
typedef enum  {
	DeviceTextDescription = 0,
	DeviceTextLocationInformation = 1
} ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 14615 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SHARE_ACCESS ;

#line 14635
typedef struct _CONFIGURATION_INFORMATION ;

#line 14848
typedef struct _BOOTDISK_INFORMATION ;

#line 15754
typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK ;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK ;

#line 15764
typedef struct _IO_REMOVE_LOCK_DBG_BLOCK ;

#line 15777
typedef struct _IO_REMOVE_LOCK ;

#line 16009
typedef struct _IO_WORKITEM ;

typedef void ;

#line 16100
typedef enum  {
	DevicePropertyDeviceDescription,
	DevicePropertyHardwareID,
	DevicePropertyCompatibleIDs,
	DevicePropertyBootConfiguration,
	DevicePropertyBootConfigurationTranslated,
	DevicePropertyClassName,
	DevicePropertyClassGuid,
	DevicePropertyDriverKeyName,
	DevicePropertyManufacturer,
	DevicePropertyFriendlyName,
	DevicePropertyLocationInformation,
	DevicePropertyPhysicalDeviceObjectName,
	DevicePropertyBusTypeGuid,
	DevicePropertyLegacyBusType,
	DevicePropertyBusNumber,
	DevicePropertyEnumeratorName,
	DevicePropertyAddress,
	DevicePropertyUINumber
} ;

typedef BOOLEAN ;

#line 16129
typedef struct _DMA_ADAPTER ;

#line 16135
typedef ULONG ;

#line 16148
typedef struct _PNP_BUS_INFORMATION ;

#line 16162
typedef struct _LEGACY_BUS_INFORMATION ;

#line 16168
typedef struct _BUS_INTERFACE_STANDARD ;

#line 16190
typedef BOOLEAN ;

#line 16194
typedef NTSTATUS ;

#line 16203
typedef NTSTATUS ;

#line 16206
typedef NTSTATUS ;

#line 16210
typedef NTSTATUS ;

#line 16214
typedef NTSTATUS ;

#line 16218
typedef void ;

#line 16222
typedef NTSTATUS ;

#line 16227
typedef void ;

#line 16231
typedef struct _ACPI_INTERFACE_STANDARD ;

#line 16255
typedef enum _ACPI_REG_TYPE ;

#line 16268
typedef USHORT ;

#line 16272
typedef void ;

#line 16278
typedef struct ACPI_REGS_INTERFACE_STANDARD ;

#line 16300
typedef struct  {
	PVOID LinkNode ;
	ULONG StaticVector ;
	UCHAR Flags ;
} ;

#line 16314
typedef NTSTATUS ;

#line 16329
typedef NTSTATUS ;

#line 16336
typedef void ;

#line 16343
typedef struct _INT_ROUTE_INTERFACE_STANDARD ;

#line 16366
typedef struct _IO_ASSIGNED_RESOURCES ;

#line 16490
typedef enum _IO_NOTIFICATION_EVENT_CATEGORY ;

#line 16504
typedef NTSTATUS ;

#line 16537
typedef void ;

#line 16573
typedef enum _ARBITER_ACTION ;

#line 16586
typedef struct _ARBITER_CONFLICT_INFO ;

#line 16608
typedef struct _ARBITER_PARAMETERS ;

#line 16719
typedef enum _ARBITER_REQUEST_SOURCE ;

#line 16731
typedef enum _ARBITER_RESULT ;

#line 16761
typedef struct _ARBITER_LIST_ENTRY ;

#line 16832
typedef NTSTATUS ;

#line 16853
typedef struct _ARBITER_INTERFACE ;

#line 16880
typedef enum _RESOURCE_TRANSLATION_DIRECTION ;

#line 16889
typedef NTSTATUS ;

#line 16901
typedef NTSTATUS ;

#line 16915
typedef struct _TRANSLATOR_INTERFACE ;

#line 16931
typedef NTSTATUS ;

#line 16945
typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE ;

#line 16959
typedef struct _PLUGPLAY_NOTIFICATION_HEADER ;

#line 16972
typedef struct _HWPROFILE_CHANGE_NOTIFICATION ;

#line 16986
typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION ;

#line 17006
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION ;

#line 17026
typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION ;

#line 17054
typedef struct _DEVICE_DESCRIPTION ;

#line 17086
typedef BOOLEAN ;

#line 17333
typedef void ;

#line 17339
typedef struct _DEVICE_CONTROL_CONTEXT ;

#line 17349
typedef PBUS_HANDLER ;

#line 17355
typedef void ;

#line 17365
typedef enum _HAL_QUERY_INFORMATION_CLASS ;

#line 17381
typedef enum _HAL_SET_INFORMATION_CLASS ;

#line 17388
typedef NTSTATUS ;

#line 17405
typedef NTSTATUS ;

#line 17420
typedef void ;

#line 17429
typedef void ;

#line 17438
typedef NTSTATUS ;

#line 17447
typedef NTSTATUS ;

#line 17456
typedef NTSTATUS ;

#line 17466
typedef NTSTATUS ;

#line 17475
typedef NTSTATUS ;

#line 17486
typedef struct _PM_DISPATCH_TABLE ;

#line 17492
typedef NTSTATUS ;

#line 17505
typedef struct _DMA_ADAPTER ;

#line 17520
typedef NTSTATUS ;

#line 17543
typedef BOOLEAN ;

#line 17553
typedef NTSTATUS ;

#line 17566
typedef void ;

#line 17572
typedef void ;

#line 17578
typedef BOOLEAN ;

#line 17588
typedef struct  {
	ULONG Version ;
	pHalQuerySystemInformation HalQuerySystemInformation ;
	pHalSetSystemInformation HalSetSystemInformation ;
	pHalQueryBusSlots HalQueryBusSlots ;
	ULONG Spare1 ;
	pHalExamineMBR HalExamineMBR ;
	pHalIoAssignDriveLetters HalIoAssignDriveLetters ;
	pHalIoReadPartitionTable HalIoReadPartitionTable ;
	pHalIoSetPartitionInformation HalIoSetPartitionInformation ;
	pHalIoWritePartitionTable HalIoWritePartitionTable ;
	pHalHandlerForBus HalReferenceHandlerForBus ;
	pHalReferenceBusHandler HalReferenceBusHandler ;
	pHalReferenceBusHandler HalDereferenceBusHandler ;
	pHalInitPnpDriver HalInitPnpDriver ;
	pHalInitPowerManagement HalInitPowerManagement ;
	pHalGetDmaAdapter HalGetDmaAdapter ;
	pHalGetInterruptTranslator HalGetInterruptTranslator ;
} ;

#line 17650
typedef struct _HAL_BUS_INFORMATION ;

#line 17658
typedef struct _HAL_PROFILE_SOURCE_INFORMATION ;

#line 17665
typedef struct _HAL_PROFILE_SOURCE_INTERVAL ;

#line 17671
typedef enum _HAL_DISPLAY_BIOS_INFORMATION ;

#line 17678
typedef struct _HAL_POWER_INFORMATION ;

#line 17683
typedef struct _HAL_PROCESSOR_SPEED_INFO ;

#line 17688
typedef struct _HAL_CALLBACKS ;

#line 17694
typedef struct _HAL_PROCESSOR_FEATURE ;

#line 17706
typedef union _MCI_ADDR ;

#line 17716
typedef enum  {
	HAL_MCE_RECORD,
	HAL_MCA_RECORD
} ;

#line 17726
typedef struct _MCA_EXCEPTION ;

#line 17752
typedef void ;

#line 17762
typedef struct _MCA_DRIVER_INFO ;

#line 17772
typedef struct _SCATTER_GATHER_ELEMENT ;

#line 17778

#pragma warning(disable:4200)
#line 17779
typedef struct _SCATTER_GATHER_LIST ;

#line 17784

#pragma warning(default:4200)
#line 17788
typedef struct _DMA_OPERATIONS ;

typedef struct _DMA_ADAPTER ;

#line 17797
typedef void ;

#line 17801
typedef PVOID ;

#line 17808
typedef void ;

#line 17816
typedef NTSTATUS ;

#line 17824
typedef BOOLEAN ;

#line 17833
typedef void ;

#line 17837
typedef void ;

#line 17843
typedef PHYSICAL_ADDRESS ;

#line 17852
typedef ULONG ;

#line 17856
typedef ULONG ;

#line 17860
typedef void ;

#line 17868
typedef NTSTATUS ;

#line 17880
typedef void ;

#line 17887
typedef struct _DMA_OPERATIONS ;

#line 18235
typedef void ;

#line 18321
typedef struct _OBJECT_HANDLE_INFORMATION ;

#line 18402
typedef struct _PCI_SLOT_NUMBER ;

#line 18418
typedef struct _PCI_COMMON_CONFIG ;

#line 18591
typedef struct _PCI_CAPABILITIES_HEADER ;

#line 18600
typedef struct _PCI_PMC ;

#line 18618
typedef struct _PCI_PMCSR ;

#line 18628
typedef struct _PCI_PMCSR_BSE ;

#line 18635
typedef struct _PCI_PM_CAPABILITY ;

#line 18679
typedef struct _PCI_AGP_CAPABILITY ;

#line 18720
typedef struct _PCI_MSI_CAPABILITY ;

#line 18946
typedef void ;

#line 18954
typedef void ;

#line 18963
typedef void ;

#line 18975
typedef struct _PCIBUSDATA ;

#line 18986
typedef ULONG ;

#line 18995
typedef void ;

#line 19000
typedef void ;

#line 19006
typedef struct _PCI_BUS_INTERFACE_STANDARD ;

#line 19028
typedef BOOLEAN ;

#line 19043
typedef struct _PCI_DEVICE_PRESENT_INTERFACE ;

#line 15 "../slam-kernel.c"
void errorFn() {
ERROR: ;
}

#line 22
int s ;
int UNLOADED , NP , DC , SKIP1 , SKIP2 , MPR1 , MPR3 , IPC ;
#line 26
int pending ;
PIO_COMPLETION_ROUTINE compFptr ;
int compRegistered ;
int lowerDriverReturn ;
int setEventCalled ;
int customIrp ;
int routine ;
#line 34
int myStatus ;
#line 36
void _BLAST_init()
{
        #line 53
        UNLOADED = 0;
        NP = 1;
        DC = 2;
        SKIP1 = 3;
        SKIP2 = 4;
        MPR1 = 5;
        MPR3 = 6;
        IPC = 7;
        #line 63
        s = UNLOADED;
        pending = 0;
        compFptr = 0;
        compRegistered = 0;
        lowerDriverReturn = 0;
        setEventCalled = 0;
        customIrp = 0;
}
#line 58
extern NTSTATUS DriverEntry(PDRIVER_OBJECT , PUNICODE_STRING ) ;
#line 62
IRP *  pirp ;

void stub_driver_init()
{
	s = NP;
	pending = 0;
	compFptr = 0;
	compRegistered = 0;
	lowerDriverReturn = 0;
	setEventCalled = 0;
	customIrp = 0;
}

#line 77
int main()
{
	#line 78
	DRIVER_OBJECT d ;
	UNICODE_STRING u ;
	NTSTATUS status ;
	int we_should_unload ;
	IRP irp;
	pirp = &irp;
	#line 83
	_BLAST_init();
	#line 85
//	status = DriverEntry(& d, & u);
	#line 87
	if((NTSTATUS )status >= 0)
	{
		#line 88
		int __BLAST_NONDET ;
		int idx ;
		int irp_choice ;
		DEVICE_OBJECT devobj ;
		#line 97
		extern NTSTATUS SerialAddDevice(PDRIVER_OBJECT , PDEVICE_OBJECT
			) ;
		#line 100
		s = NP;
		pending = 0;
		compFptr = 0;
		compRegistered = 0;
		lowerDriverReturn = 0;
		setEventCalled = 0;
		customIrp = 0;
		#line 108
		(pirp->IoStatus).Status = (NTSTATUS )0x00000000L;
		myStatus = (NTSTATUS )0x00000000L;
		#line 111
		if(irp_choice == 0)
		{
			#line 112
			(pirp->IoStatus).Status = (NTSTATUS )0xC00000BBL;
			myStatus = (NTSTATUS )0xC00000BBL;
		}
		#line 116
//		status = SerialAddDevice(& d, & devobj);
		#line 118
		stub_driver_init();
		#line 120
		if(! ((NTSTATUS )status >= 0))
			#line 120
			return - 1;
		#line 124
		switch(__BLAST_NONDET)
		{
		case 0:
				#line 126
				;
			{
				#line 127
				extern NTSTATUS SerialCreateOpen(PDEVICE_OBJECT
					, PIRP ) ;
				#line 128
				status = SerialCreateOpen(& devobj, pirp);
			}
			#line 129
			break;
			#line 132
		case 1:
				#line 132
				;
			{
				#line 133
				extern NTSTATUS SerialClose(PDEVICE_OBJECT ,
					PIRP ) ;
				#line 134
				status = SerialClose(& devobj, pirp);
			}
			#line 135
			break;
			#line 138
		case 2:
				#line 138
				;
			{
				#line 139
				extern NTSTATUS SerialIoControl(PDEVICE_OBJECT ,
					PIRP ) ;
				#line 140
				status = SerialIoControl(& devobj, pirp);
			}
			#line 141
			break;
			#line 144
		case 3:
				#line 144
				;
			{
				#line 145
				extern NTSTATUS SerialPnpDispatch(PDEVICE_OBJECT
					, PIRP ) ;
				#line 146
				status = SerialPnpDispatch(& devobj, pirp);
			}
			#line 147
			break;
			#line 150
		case 4:
				#line 150
				;
			{
				#line 151
				extern NTSTATUS
					SerialPowerDispatch(PDEVICE_OBJECT ,
					PIRP ) ;
				#line 152
				status = SerialPowerDispatch(& devobj, pirp);
			}
			#line 153
			break;
			#line 156
		case 5:
				#line 156
				;
			{
				#line 157
				extern NTSTATUS SerialCleanup(PDEVICE_OBJECT ,
					PIRP ) ;
				#line 158
				status = SerialCleanup(& devobj, pirp);
			}
			#line 159
			break;
			#line 186
		case 11:
				#line 186
				;
			{
				#line 187
				extern NTSTATUS SerialCleanup(PDEVICE_OBJECT ,
					PIRP ) ;
				#line 188
				status = SerialCleanup(& devobj, pirp);
			}
			#line 189
			break;
/*
			#line 192
		case 12:
				#line 192
				;
			{
				#line 193
				extern NTSTATUS SerialFlush(PDEVICE_OBJECT ,
					PIRP ) ;
				#line 194
				status = SerialFlush(& devobj, pirp);
			}
			#line 195
			break;
*/
			#line 215
		default :
				#line 215
				;
			return - 1;
		}
		#line 221
		if(we_should_unload)
		{
			#line 222
			extern void SerialUnload(PDRIVER_OBJECT ) ;
			SerialUnload(& d);
		}
	}
	#line 227
	RETPT:
	{
		#line 228
		if(pending == 1 && s == NP)
		{
			#line 229
			s = NP;
		}
		else
		{
			#line 231
			if(pending == 1 && s == MPR3)
			{
				#line 232
				s = MPR3;
			}
			else
			{
				#line 234
				if(s == UNLOADED || status == - 1)
				{
					#line 235
					;
				}
				else
				{
					#line 237
					if(s != SKIP2 && s != IPC && s != DC)
						#line 237
						errorFn();
					else
					{
						#line 239
						if(pending == 1)
						{
							#line 240
							if(status != 259)
	#line 240
	errorFn();
						}
						else
						{
							#line 242
							if(s == DC)
							{
	#line 243
	if(status == 259)
		#line 243
		errorFn();
							}
							else
							{
	#line 245
	if(status != lowerDriverReturn)
		#line 245
		errorFn();
							}
						}
					}
				}
			}
		}
	}
	#line 252
	return status;
}

char _SLAM_alloc_dummy ;

char *  malloc(int i )
{
	#line 258
	int __BLAST_NONDET ;
	#line 260
	if(__BLAST_NONDET)
	{
		#line 261
		return (char *  )0;
	}
	else
		#line 262
		return (char *  )1;
}

#line 271
__declspec(dllimport) void ExAcquireFastMutex(PFAST_MUTEX FastMutex )
{
	#line 278
	return;
}

__declspec(dllimport) void ExReleaseFastMutex(PFAST_MUTEX FastMutex )
{
	#line 288
	return;
}

#line 305
__declspec(dllimport) PVOID __stdcall ExAllocatePoolWithTag(POOL_TYPE PoolType ,
	SIZE_T NumberOfBytes , ULONG Tag )
{
	#line 314
	PVOID x ;
	x = malloc(NumberOfBytes);
	return x;
}

#line 320
__declspec(dllimport) void __stdcall ExFreePool(PVOID P )
{
	#line 326
	return;
}

__declspec(dllimport) PLIST_ENTRY ExfInterlockedInsertHeadList(PLIST_ENTRY
	ListHead , PLIST_ENTRY ListEntry , PKSPIN_LOCK Lock )
{
	#line 337
	return (void *  )0;
}

__declspec(dllimport) PLIST_ENTRY ExfInterlockedInsertTailList(PLIST_ENTRY
	ListHead , PLIST_ENTRY ListEntry , PKSPIN_LOCK Lock )
{
	#line 349
	return (void *  )0;
}

__declspec(dllimport) PLIST_ENTRY ExfInterlockedRemoveHeadList(PLIST_ENTRY
	ListHead , PKSPIN_LOCK Lock )
{
	#line 360
	return (void *  )0;
}

#line 376
__declspec(dllimport) PMDL IoAllocateMdl(PVOID VirtualAddress , ULONG Length ,
	BOOLEAN SecondaryBuffer , BOOLEAN ChargeQuota , PIRP Irp )
{
	#line 386
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 388
	case 0:
			#line 388
			;
		#line 388
		return (void *  )malloc(sizeof(MDL ));
	default :
			#line 389
			;
		#line 389
		return (void *  )0;
	}
}

__declspec(dllimport) PDEVICE_OBJECT IoAttachDeviceToDeviceStack(PDEVICE_OBJECT
	SourceDevice , PDEVICE_OBJECT TargetDevice )
{
	#line 400
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 402
	case 0:
			#line 402
			;
		#line 402
		return TargetDevice;
	default :
			#line 403
			;
		#line 403
		return (void *  )0;
	}
}

__declspec(dllimport) PIRP IoBuildAsynchronousFsdRequest(ULONG MajorFunction ,
	PDEVICE_OBJECT DeviceObject , PVOID Buffer , ULONG Length ,
	PLARGE_INTEGER StartingOffset , PIO_STATUS_BLOCK IoStatusBlock )
{
	#line 418
	int __BLAST_NONDET ;
	customIrp = 1;
	#line 421
	switch(__BLAST_NONDET)
	{
		#line 422
	case 0:
			#line 422
			;
		#line 422
		return (void *  )malloc(sizeof(IRP ));
	default :
			#line 423
			;
		#line 423
		return (void *  )0;
	}
}

#line 438
__declspec(dllimport) PIRP IoBuildDeviceIoControlRequest(ULONG IoControlCode ,
	PDEVICE_OBJECT DeviceObject , PVOID InputBuffer , ULONG
	InputBufferLength , PVOID OutputBuffer , ULONG OutputBufferLength ,
	BOOLEAN InternalDeviceIoControl , PKEVENT Event , PIO_STATUS_BLOCK
	IoStatusBlock )
{
	#line 452
	int __BLAST_NONDET ;
	customIrp = 1;
	#line 455
	switch(__BLAST_NONDET)
	{
		#line 456
	case 0:
			#line 456
			;
		#line 456
		return (void *  )malloc(sizeof(IRP ));
	default :
			#line 457
			;
		#line 457
		return (void *  )0;
	}
}

__declspec(dllimport) NTSTATUS IoCreateDevice(PDRIVER_OBJECT DriverObject ,
	ULONG DeviceExtensionSize , PUNICODE_STRING DeviceName , ULONG
	DeviceType , ULONG DeviceCharacteristics , BOOLEAN Exclusive ,
	PDEVICE_OBJECT *  DeviceObject )
{
	#line 473
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 475
	case 0:
			#line 475
			;
		#line 475
		* DeviceObject = (void *  )malloc(sizeof(DEVICE_OBJECT ));
		return (NTSTATUS )0x00000000L;
		#line 482
	default :
			#line 482
			;
		#line 482
		return (NTSTATUS )0xC0000001L;
	}
}

#line 487
__declspec(dllimport) NTSTATUS IoCreateSymbolicLink(PUNICODE_STRING
	SymbolicLinkName , PUNICODE_STRING DeviceName )
{
	#line 494
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 496
	case 0:
			#line 496
			;
		#line 496
		return (NTSTATUS )0x00000000L;
	default :
			#line 497
			;
		#line 497
		return (NTSTATUS )0xC0000001L;
	}
}

__declspec(dllimport) void IoDeleteDevice(PDEVICE_OBJECT DeviceObject )
{
}

#line 510
__declspec(dllimport) NTSTATUS IoDeleteSymbolicLink(PUNICODE_STRING
	SymbolicLinkName )
{
	#line 516
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 518
	case 0:
			#line 518
			;
		#line 518
		return (NTSTATUS )0x00000000L;
	default :
			#line 519
			;
		#line 519
		return (NTSTATUS )0xC0000001L;
	}
}

__declspec(dllimport) void IoDetachDevice(PDEVICE_OBJECT TargetDevice )
{
}

#line 532
__declspec(dllimport) void IoFreeIrp(PIRP Irp )
{
}

#line 541
__declspec(dllimport) void IoFreeMdl(PMDL Mdl )
{
}

#line 550
__declspec(dllimport) PCONFIGURATION_INFORMATION
	IoGetConfigurationInformation(void  )
{
	#line 555
	return (void *  )malloc(sizeof(CONFIGURATION_INFORMATION ));
}

__declspec(dllimport) NTSTATUS IoQueryDeviceDescription(PINTERFACE_TYPE BusType
	, PULONG BusNumber , PCONFIGURATION_TYPE ControllerType , PULONG
	ControllerNumber , PCONFIGURATION_TYPE PeripheralType , PULONG
	PeripheralNumber , PIO_QUERY_DEVICE_ROUTINE CalloutRoutine , PVOID
	Context )
{
	#line 571
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 573
	case 0:
			#line 573
			;
		#line 573
		return (NTSTATUS )0x00000000L;
	default :
			#line 574
			;
		#line 574
		return (NTSTATUS )0xC0000001L;
	}
}

__declspec(dllimport) NTSTATUS __stdcall
	IoRegisterDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject , const
	GUID *  InterfaceClassGuid , PUNICODE_STRING ReferenceString ,
	PUNICODE_STRING SymbolicLinkName )
{
	#line 588
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 590
	case 0:
			#line 590
			;
		#line 590
		return (NTSTATUS )0x00000000L;
	default :
			#line 591
			;
		#line 591
		return (NTSTATUS )0xC0000010L;
	}
}

__declspec(dllimport) void IoReleaseCancelSpinLock(KIRQL Irql )
{
}

#line 604
__declspec(dllimport) NTSTATUS IoSetDeviceInterfaceState(PUNICODE_STRING
	SymbolicLinkName , BOOLEAN Enable )
{
	#line 611
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 613
	case 0:
			#line 613
			;
		#line 613
		return (NTSTATUS )0x00000000L;
		#line 618
	default :
			#line 618
			;
		#line 618
		return (NTSTATUS )0xC0000001L;
	}
}

#line 623
__declspec(dllimport) void IoSetHardErrorOrVerifyDevice(PIRP Irp ,
	PDEVICE_OBJECT DeviceObject )
{
}

#line 636
void stubMoreProcessingRequired()
{
	#line 639
	if(s == NP)
		#line 639
		s = MPR1;
	else
		#line 640
		errorFn();
}

__declspec(dllimport) NTSTATUS IofCallDriver(PDEVICE_OBJECT DeviceObject , PIRP
	Irp )
{
	#line 651
	int __BLAST_NONDET ;
	NTSTATUS returnVal2 ;
	int compRetStatus ;
	PVOID lcontext ;
	#line 656
	if(compRegistered)
	{
		#line 657
	/*
		compRetStatus = (* compFptr)(DeviceObject, Irp, lcontext);
	*/
		compRetStatus = SerialSyncCompletion(DeviceObject, Irp, lcontext);
		if(compRetStatus == (NTSTATUS )0xC0000016L)
			#line 658
			stubMoreProcessingRequired();
	}
	#line 663
	switch(__BLAST_NONDET)
	{
		#line 664
	case 0:
			#line 664
			;
		#line 664
		returnVal2 = (NTSTATUS )0x00000000L;
		#line 664
		break;
		#line 666
	case 1:
			#line 666
			;
		#line 666
		returnVal2 = (NTSTATUS )0xC0000001L;
		#line 666
		break;
		#line 668
	default :
			#line 668
			;
		#line 668
		returnVal2 = (NTSTATUS )0x00000103L;
		#line 668
		break;
	}
	if(s == NP)
	{
		#line 671
		s = IPC;
		#line 671
		lowerDriverReturn = returnVal2;
	}
	else
	{
		#line 673
		if(s == MPR1)
		{
			#line 674
			if(returnVal2 == (NTSTATUS )0x00000103L)
			{
				#line 675
				s = MPR3;
				#line 675
				lowerDriverReturn = returnVal2;
			}
			else
			{
				#line 677
				s = NP;
				#line 677
				lowerDriverReturn = returnVal2;
			}
		}
		else
		{
			#line 680
			if(s == SKIP1)
			{
				#line 680
				s = SKIP2;
				#line 680
				lowerDriverReturn = returnVal2;
			}
			else
				#line 681
				errorFn();
		}
	}
	return returnVal2;
}

#line 706
__declspec(dllimport) void IofCompleteRequest(PIRP Irp , CCHAR PriorityBoost )
{
	#line 714
	if(s == NP)
		#line 714
		s = DC;
	else
		#line 715
		errorFn();
}

__declspec(dllimport) KIRQL KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK SpinLock )
{
}

#line 727
__declspec(dllimport) NTSTATUS KeDelayExecutionThread(KPROCESSOR_MODE WaitMode ,
	BOOLEAN Alertable , PLARGE_INTEGER Interval )
{
	#line 735
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 737
	case 0:
			#line 737
			;
		#line 737
		return (NTSTATUS )0x00000000L;
		#line 742
	default :
			#line 742
			;
		#line 742
		return (NTSTATUS )0xC0000001L;
	}
}

#line 747
__declspec(dllimport) void KeInitializeEvent(PRKEVENT Event , EVENT_TYPE Type ,
	BOOLEAN State )
{
}

#line 758
__declspec(dllimport) void KeInitializeSemaphore(PRKSEMAPHORE Semaphore , LONG
	Count , LONG Limit )
{
}

#line 769
__declspec(dllimport) void __stdcall KeInitializeSpinLock(PKSPIN_LOCK SpinLock )
{
}

#line 779
__declspec(dllimport) LONG KeReleaseSemaphore(PRKSEMAPHORE Semaphore , KPRIORITY
	Increment , LONG Adjustment , BOOLEAN Wait )
{
	#line 788
	LONG r ;
	return r;
}

__declspec(dllimport) void KfReleaseSpinLock(PKSPIN_LOCK SpinLock , KIRQL
	NewIrql )
{
}

#line 803
__declspec(dllimport) LONG KeSetEvent(PRKEVENT Event , KPRIORITY Increment ,
	BOOLEAN Wait )
{
	#line 811
	LONG l ;
	#line 813
	setEventCalled = 1;
	#line 815
	return l;
}

__declspec(dllimport) NTSTATUS KeWaitForSingleObject(PVOID Object , KWAIT_REASON
	WaitReason , KPROCESSOR_MODE WaitMode , BOOLEAN Alertable ,
	PLARGE_INTEGER Timeout )
{
	#line 828
	int __BLAST_NONDET ;
	if(s == MPR3 && setEventCalled == 1)
	{
		#line 830
		s = NP;
		#line 830
		setEventCalled = 0;
	}
	else
	{
		#line 832
		if(customIrp == 1)
		{
			#line 833
			s = NP;
			#line 833
			customIrp = 0;
		}
		else
		{
			#line 835
			if(s == MPR3)
				#line 835
				errorFn();
		}
	}
	#line 839
	switch(__BLAST_NONDET)
	{
		#line 840
	case 0:
			#line 840
			;
		#line 840
		return (NTSTATUS )0x00000000L;
		#line 846
	default :
			#line 846
			;
		#line 846
		return (NTSTATUS )0xC0000001L;
	}
}

#line 851
__declspec(dllimport) PVOID MmAllocateContiguousMemory(SIZE_T NumberOfBytes ,
	PHYSICAL_ADDRESS HighestAcceptableAddress )
{
	#line 857
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 859
	case 0:
			#line 859
			;
		#line 859
		return malloc(NumberOfBytes);
	case 1:
			#line 860
			;
		#line 860
		return (void *  )0;
	}
}

__declspec(dllimport) void MmFreeContiguousMemory(PVOID BaseAddress )
{
}

#line 873
__declspec(dllimport) PVOID MmMapLockedPagesSpecifyCache(PMDL
	MemoryDescriptorList , KPROCESSOR_MODE AccessMode , MEMORY_CACHING_TYPE
	CacheType , PVOID BaseAddress , ULONG BugCheckOnFailure ,
	MM_PAGE_PRIORITY Priority )
{
	#line 884
	return (void *  )0;
}

__declspec(dllimport) PVOID MmPageEntireDriver(PVOID AddressWithinSection )
{
	#line 893
	return (void *  )0;
}

__declspec(dllimport) void MmResetDriverPaging(PVOID AddressWithinSection )
{
}

#line 906
__declspec(dllimport) void MmUnlockPages(PMDL MemoryDescriptorList )
{
}

#line 915
__declspec(dllimport) NTSTATUS ObReferenceObjectByHandle(HANDLE Handle ,
	ACCESS_MASK DesiredAccess , POBJECT_TYPE ObjectType , KPROCESSOR_MODE
	AccessMode , PVOID *  Object , POBJECT_HANDLE_INFORMATION
	HandleInformation )
{
	#line 926
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 928
	case 0:
			#line 928
			;
		#line 928
		return (NTSTATUS )0x00000000L;
		#line 934
	default :
			#line 934
			;
		#line 934
		return (NTSTATUS )0xC0000001L;
	}
}

#line 940
__declspec(dllimport) void ObfDereferenceObject(PVOID Object )
{
}

#line 950
__declspec(dllimport) NTSTATUS PoCallDriver(PDEVICE_OBJECT DeviceObject , PIRP
	Irp )
{
	#line 957
	int __BLAST_NONDET ;
	int compRetStatus ;
	NTSTATUS returnVal ;
	#line 961
	PVOID lcontext ;
	#line 963
	if(compRegistered)
	{
		#line 964
/*
		compRetStatus = (* compFptr)(DeviceObject, Irp, lcontext);
*/
		compRetStatus = SerialSyncCompletion(DeviceObject, Irp, lcontext);
		if(compRetStatus == (NTSTATUS )0xC0000016L)
			#line 965
			stubMoreProcessingRequired();
	}
	#line 970
	switch(__BLAST_NONDET)
	{
		#line 971
	case 0:
			#line 971
			;
		returnVal = (NTSTATUS )0x00000000L;
		break;
	case 1:
			#line 974
			;
		returnVal = (NTSTATUS )0xC0000001L;
		break;
	default :
			#line 977
			;
		returnVal = (NTSTATUS )0x00000103L;
		#line 978
		break;
	}
	if(s == NP)
	{
		#line 981
		s = IPC;
		#line 981
		lowerDriverReturn = returnVal;
	}
	else
	{
		#line 983
		if(s == MPR1)
		{
			#line 984
			if(returnVal == (NTSTATUS )0x00000103L)
			{
				#line 985
				s = MPR3;
				#line 985
				lowerDriverReturn = returnVal;
			}
			else
			{
				#line 987
				s = NP;
				#line 987
				lowerDriverReturn = returnVal;
			}
		}
		else
		{
			#line 990
			if(s == SKIP1)
			{
				#line 990
				s = SKIP2;
				#line 990
				lowerDriverReturn = returnVal;
			}
			else
				#line 991
				errorFn();
		}
	}
	return returnVal;
}

__declspec(dllimport) void PoStartNextPowerIrp(PIRP Irp )
{
}

#line 1006
__declspec(dllimport) NTSTATUS PsCreateSystemThread(PHANDLE ThreadHandle , ULONG
	DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes , HANDLE
	ProcessHandle , PCLIENT_ID ClientId , PKSTART_ROUTINE StartRoutine ,
	PVOID StartContext )
{
	#line 1018
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 1020
	case 0:
			#line 1020
			;
		#line 1020
		return (NTSTATUS )0x00000000L;
	default :
			#line 1021
			;
		#line 1021
		return (NTSTATUS )0xC0000001L;
	}
}

__declspec(dllimport) NTSTATUS PsTerminateSystemThread(NTSTATUS ExitStatus )
{
	#line 1031
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 1033
	case 0:
			#line 1033
			;
		#line 1033
		return (NTSTATUS )0x00000000L;
	default :
			#line 1034
			;
		#line 1034
		return (NTSTATUS )0xC0000001L;
	}
}

#line 1039
__declspec(dllimport) NTSTATUS __stdcall
	RtlAnsiStringToUnicodeString(PUNICODE_STRING DestinationString ,
	PANSI_STRING SourceString , BOOLEAN AllocateDestinationString )
{
	#line 1048
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 1050
	case 0:
			#line 1050
			;
		#line 1050
		return (NTSTATUS )0x00000000L;
	default :
			#line 1051
			;
		#line 1051
		return (NTSTATUS )0xC0000001L;
	}
}

__declspec(dllimport) SIZE_T __stdcall RtlCompareMemory(const void *  Source1 ,
	const void *  Source2 , SIZE_T Length )
{
	#line 1064
	SIZE_T r ;
	return r;
}

__declspec(dllimport) void __stdcall RtlCopyUnicodeString(PUNICODE_STRING
	DestinationString , PUNICODE_STRING SourceString )
{
}

#line 1079
__declspec(dllimport) NTSTATUS __stdcall RtlDeleteRegistryValue(ULONG RelativeTo
	, PCWSTR Path , PCWSTR ValueName )
{
	#line 1088
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 1090
	case 0:
			#line 1090
			;
		#line 1090
		return (NTSTATUS )0x00000000L;
	default :
			#line 1091
			;
		#line 1091
		return (NTSTATUS )0xC0000001L;
	}
}

__declspec(dllimport) void __stdcall RtlFreeUnicodeString(PUNICODE_STRING
	UnicodeString )
{
}

#line 1105
__declspec(dllimport) void __stdcall RtlInitString(PSTRING DestinationString ,
	PCSZ SourceString )
{
}

#line 1116
__declspec(dllimport) void __stdcall RtlInitUnicodeString(PUNICODE_STRING
	DestinationString , PCWSTR SourceString )
{
}

#line 1128
__declspec(dllimport) NTSTATUS __stdcall RtlQueryRegistryValues(ULONG RelativeTo
	, PCWSTR Path , PRTL_QUERY_REGISTRY_TABLE QueryTable , PVOID Context ,
	PVOID Environment )
{
	#line 1139
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 1141
	case 0:
			#line 1141
			;
		#line 1141
		return (NTSTATUS )0x00000000L;
		#line 1146
	default :
			#line 1146
			;
		#line 1146
		return (NTSTATUS )0xC0000001L;
	}
}

__declspec(dllimport) NTSTATUS __stdcall ZwClose(HANDLE Handle )
{
	#line 1157
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 1159
	case 0:
			#line 1159
			;
		#line 1159
		return (NTSTATUS )0x00000000L;
		#line 1165
	default :
			#line 1165
			;
		#line 1165
		return (NTSTATUS )0xC0000001L;
	}
}


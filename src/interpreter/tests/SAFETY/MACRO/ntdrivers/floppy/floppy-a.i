/* Generated by Frontc */

#line 16 "C:/NTDDK/inc/stdio.h"

#pragma once
#line 32

#pragma pack(push, 8)
#line 63
typedef unsigned int size_t ;

#line 70
typedef unsigned short wchar_t ;

#line 76
typedef wchar_t wint_t ;

#line 77
typedef wchar_t wctype_t ;

#line 89
typedef char *  va_list ;

#line 118
struct _iobuf {
	char *  _ptr ;
	int _cnt ;
	char *  _base ;
	int _flag ;
	int _file ;
	int _charbuf ;
	int _bufsiz ;
	char *  _tmpfname ;
} ;

#line 128
typedef struct _iobuf FILE ;

#line 184
extern FILE _iob[] ;

#line 198
typedef __int64 fpos_t ;

#line 239
int __cdecl _filbuf(FILE *  ) ;
int __cdecl _flsbuf(int  , FILE *  ) ;
#line 245
FILE * __cdecl _fsopen(const char *  , const char *  , int  ) ;
#line 248
void __cdecl clearerr(FILE *  ) ;
int __cdecl fclose(FILE *  ) ;
int __cdecl _fcloseall(void  ) ;
#line 255
FILE * __cdecl _fdopen(int  , const char *  ) ;
#line 258
int __cdecl feof(FILE *  ) ;
int __cdecl ferror(FILE *  ) ;
int __cdecl fflush(FILE *  ) ;
int __cdecl fgetc(FILE *  ) ;
int __cdecl _fgetchar(void  ) ;
int __cdecl fgetpos(FILE *  , fpos_t *  ) ;
char * __cdecl fgets(char *  , int  , FILE *  ) ;
#line 269
int __cdecl _fileno(FILE *  ) ;
#line 272
int __cdecl _flushall(void  ) ;
FILE * __cdecl fopen(const char *  , const char *  ) ;
int __cdecl fprintf(FILE *  , const char *  , ...) ;
int __cdecl fputc(int  , FILE *  ) ;
int __cdecl _fputchar(int  ) ;
int __cdecl fputs(const char *  , FILE *  ) ;
size_t __cdecl fread(void *  , size_t , size_t , FILE *  ) ;
FILE * __cdecl freopen(const char *  , const char *  , FILE *  ) ;
int __cdecl fscanf(FILE *  , const char *  , ...) ;
int __cdecl fsetpos(FILE *  , const fpos_t *  ) ;
int __cdecl fseek(FILE *  , long  , int  ) ;
long __cdecl ftell(FILE *  ) ;
size_t __cdecl fwrite(const void *  , size_t , size_t , FILE *  ) ;
int __cdecl getc(FILE *  ) ;
int __cdecl getchar(void  ) ;
int __cdecl _getmaxstdio(void  ) ;
char * __cdecl gets(char *  ) ;
int __cdecl _getw(FILE *  ) ;
void __cdecl perror(const char *  ) ;
int __cdecl _pclose(FILE *  ) ;
FILE * __cdecl _popen(const char *  , const char *  ) ;
int __cdecl printf(const char *  , ...) ;
int __cdecl putc(int  , FILE *  ) ;
int __cdecl putchar(int  ) ;
int __cdecl puts(const char *  ) ;
int __cdecl _putw(int  , FILE *  ) ;
int __cdecl remove(const char *  ) ;
int __cdecl rename(const char *  , const char *  ) ;
void __cdecl rewind(FILE *  ) ;
int __cdecl _rmtmp(void  ) ;
int __cdecl scanf(const char *  , ...) ;
void __cdecl setbuf(FILE *  , char *  ) ;
int __cdecl _setmaxstdio(int  ) ;
int __cdecl setvbuf(FILE *  , char *  , int  , size_t ) ;
int __cdecl _snprintf(char *  , size_t , const char *  , ...) ;
int __cdecl sprintf(char *  , const char *  , ...) ;
int __cdecl sscanf(const char *  , const char *  , ...) ;
char * __cdecl _tempnam(const char *  , const char *  ) ;
FILE * __cdecl tmpfile(void  ) ;
char * __cdecl tmpnam(char *  ) ;
int __cdecl ungetc(int  , FILE *  ) ;
int __cdecl _unlink(const char *  ) ;
int __cdecl vfprintf(FILE *  , const char *  , va_list ) ;
int __cdecl vprintf(const char *  , va_list ) ;
int __cdecl _vsnprintf(char *  , size_t , const char *  , va_list ) ;
int __cdecl vsprintf(char *  , const char *  , va_list ) ;
#line 330
FILE * __cdecl _wfsopen(const wchar_t *  , const wchar_t *  , int  ) ;
#line 333
wint_t __cdecl fgetwc(FILE *  ) ;
wint_t __cdecl _fgetwchar(void  ) ;
wint_t __cdecl fputwc(wint_t , FILE *  ) ;
wint_t __cdecl _fputwchar(wint_t ) ;
wint_t __cdecl getwc(FILE *  ) ;
wint_t __cdecl getwchar(void  ) ;
wint_t __cdecl putwc(wint_t , FILE *  ) ;
wint_t __cdecl putwchar(wint_t ) ;
wint_t __cdecl ungetwc(wint_t , FILE *  ) ;
#line 343
wchar_t * __cdecl fgetws(wchar_t *  , int  , FILE *  ) ;
int __cdecl fputws(const wchar_t *  , FILE *  ) ;
wchar_t * __cdecl _getws(wchar_t *  ) ;
int __cdecl _putws(const wchar_t *  ) ;
#line 348
int __cdecl fwprintf(FILE *  , const wchar_t *  , ...) ;
int __cdecl wprintf(const wchar_t *  , ...) ;
int __cdecl _snwprintf(wchar_t *  , size_t , const wchar_t *  , ...) ;
int __cdecl swprintf(wchar_t *  , const wchar_t *  , ...) ;
int __cdecl vfwprintf(FILE *  , const wchar_t *  , va_list ) ;
int __cdecl vwprintf(const wchar_t *  , va_list ) ;
int __cdecl _vsnwprintf(wchar_t *  , size_t , const wchar_t *  , va_list ) ;
int __cdecl vswprintf(wchar_t *  , const wchar_t *  , va_list ) ;
int __cdecl fwscanf(FILE *  , const wchar_t *  , ...) ;
int __cdecl swscanf(const wchar_t *  , const wchar_t *  , ...) ;
int __cdecl wscanf(const wchar_t *  , ...) ;
#line 365
FILE * __cdecl _wfdopen(int  , const wchar_t *  ) ;
FILE * __cdecl _wfopen(const wchar_t *  , const wchar_t *  ) ;
FILE * __cdecl _wfreopen(const wchar_t *  , const wchar_t *  , FILE *  ) ;
void __cdecl _wperror(const wchar_t *  ) ;
FILE * __cdecl _wpopen(const wchar_t *  , const wchar_t *  ) ;
int __cdecl _wremove(const wchar_t *  ) ;
wchar_t * __cdecl _wtempnam(const wchar_t *  , const wchar_t *  ) ;
wchar_t * __cdecl _wtmpnam(wchar_t *  ) ;
#line 412
int __cdecl fcloseall(void  ) ;
FILE * __cdecl fdopen(int  , const char *  ) ;
int __cdecl fgetchar(void  ) ;
int __cdecl fileno(FILE *  ) ;
int __cdecl flushall(void  ) ;
int __cdecl fputchar(int  ) ;
int __cdecl getw(FILE *  ) ;
int __cdecl putw(int  , FILE *  ) ;
int __cdecl rmtmp(void  ) ;
char * __cdecl tempnam(const char *  , const char *  ) ;
int __cdecl unlink(const char *  ) ;

#line 431

#pragma pack(pop)
#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"

#pragma once
#line 32

#pragma pack(push, 8)
#line 72
typedef enum _EXCEPTION_DISPOSITION {
	ExceptionContinueExecution,
	ExceptionContinueSearch,
	ExceptionNestedException,
	ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION ;

#line 89
struct _EXCEPTION_RECORD ;

#line 90
struct _CONTEXT ;

EXCEPTION_DISPOSITION __cdecl _except_handler(struct _EXCEPTION_RECORD * 
	ExceptionRecord , void *  EstablisherFrame , struct _CONTEXT * 
	ContextRecord , void *  DispatcherContext ) ;
#line 133
unsigned long __cdecl _exception_code(void  ) ;
void * __cdecl _exception_info(void  ) ;
int __cdecl _abnormal_termination(void  ) ;

#line 155

#pragma pack(pop)
#line 25 "C:/NTDDK/inc/ntdef.h"

#pragma once
#line 15 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"

#pragma once
#line 106
int __cdecl _isctype(int  , int  ) ;
int __cdecl isalpha(int  ) ;
int __cdecl isupper(int  ) ;
int __cdecl islower(int  ) ;
int __cdecl isdigit(int  ) ;
int __cdecl isxdigit(int  ) ;
int __cdecl isspace(int  ) ;
int __cdecl ispunct(int  ) ;
int __cdecl isalnum(int  ) ;
int __cdecl isprint(int  ) ;
int __cdecl isgraph(int  ) ;
int __cdecl iscntrl(int  ) ;
int __cdecl toupper(int  ) ;
int __cdecl tolower(int  ) ;
int __cdecl _tolower(int  ) ;
int __cdecl _toupper(int  ) ;
int __cdecl __isascii(int  ) ;
int __cdecl __toascii(int  ) ;
int __cdecl __iscsymf(int  ) ;
int __cdecl __iscsym(int  ) ;
#line 137
int __cdecl iswalpha(wint_t ) ;
int __cdecl iswupper(wint_t ) ;
int __cdecl iswlower(wint_t ) ;
int __cdecl iswdigit(wint_t ) ;
int __cdecl iswxdigit(wint_t ) ;
int __cdecl iswspace(wint_t ) ;
int __cdecl iswpunct(wint_t ) ;
int __cdecl iswalnum(wint_t ) ;
int __cdecl iswprint(wint_t ) ;
int __cdecl iswgraph(wint_t ) ;
int __cdecl iswcntrl(wint_t ) ;
int __cdecl iswascii(wint_t ) ;
int __cdecl isleadbyte(int  ) ;
#line 151
wchar_t __cdecl towupper(wchar_t ) ;
wchar_t __cdecl towlower(wchar_t ) ;
#line 154
int __cdecl iswctype(wint_t , wctype_t ) ;
#line 157
int __cdecl is_wctype(wint_t , wctype_t ) ;

#line 127 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long POINTER_64_INT ;

#line 25 "C:/NTDDK/inc/basetsd.h"

#pragma once
#line 36
typedef int LONG32 , *  PLONG32 ;

#line 37
typedef int INT32 , *  PINT32 ;

#line 43
typedef unsigned int ULONG32 , *  PULONG32 ;

#line 44
typedef unsigned int DWORD32 , *  PDWORD32 ;

#line 45
typedef unsigned int UINT32 , *  PUINT32 ;

#line 84
typedef int INT_PTR , *  PINT_PTR ;

#line 85
typedef unsigned int UINT_PTR , *  PUINT_PTR ;

typedef long LONG_PTR , *  PLONG_PTR ;

#line 88
typedef unsigned long ULONG_PTR , *  PULONG_PTR ;

#line 248
typedef unsigned short UHALF_PTR , *  PUHALF_PTR ;

#line 249
typedef short HALF_PTR , *  PHALF_PTR ;

#line 250
typedef unsigned long HANDLE_PTR ;

#line 288
typedef ULONG_PTR SIZE_T , *  PSIZE_T ;

#line 289
typedef LONG_PTR SSIZE_T , *  PSSIZE_T ;

#line 295
typedef ULONG_PTR DWORD_PTR , *  PDWORD_PTR ;

#line 301
typedef __int64 LONG64 , *  PLONG64 ;

#line 302
typedef __int64 INT64 , *  PINT64 ;

#line 309
typedef unsigned __int64 ULONG64 , *  PULONG64 ;

#line 310
typedef unsigned __int64 DWORD64 , *  PDWORD64 ;

#line 311
typedef unsigned __int64 UINT64 , *  PUINT64 ;

#line 217 "C:/NTDDK/inc/ntdef.h"
typedef void *  PVOID ;

#line 218
typedef void *  PVOID64 ;

#line 266
typedef char CHAR ;

#line 267
typedef short SHORT ;

#line 268
typedef long LONG ;

#line 276
typedef wchar_t WCHAR ;

#line 282
typedef WCHAR *  PWCHAR ;

#line 283
typedef WCHAR *  LPWCH , *  PWCH ;

#line 284
typedef const WCHAR *  LPCWCH , *  PCWCH ;

#line 285
typedef WCHAR *  NWPSTR ;

#line 286
typedef WCHAR *  LPWSTR , *  PWSTR ;

typedef const WCHAR *  LPCWSTR , *  PCWSTR ;

#line 293
typedef CHAR *  PCHAR ;

#line 294
typedef CHAR *  LPCH , *  PCH ;

typedef const CHAR *  LPCCH , *  PCCH ;

#line 297
typedef CHAR *  NPSTR ;

#line 298
typedef CHAR *  LPSTR , *  PSTR ;

#line 299
typedef const CHAR *  LPCSTR , *  PCSTR ;

#line 321
typedef char TCHAR , *  PTCHAR ;

#line 322
typedef unsigned char TUCHAR , *  PTUCHAR ;

#line 326
typedef LPSTR LPTCH , PTCH ;

#line 327
typedef LPSTR PTSTR , LPTSTR ;

#line 328
typedef LPCSTR PCTSTR , LPCTSTR ;

#line 337
typedef double DOUBLE ;

typedef struct _QUAD {
	double DoNotUseThisField ;
} QUAD ;

#line 349
typedef SHORT *  PSHORT ;

#line 350
typedef LONG *  PLONG ;

#line 351
typedef QUAD *  PQUAD ;

#line 360
typedef unsigned char UCHAR ;

#line 361
typedef unsigned short USHORT ;

#line 362
typedef unsigned long ULONG ;

#line 363
typedef QUAD UQUAD ;

#line 369
typedef UCHAR *  PUCHAR ;

#line 370
typedef USHORT *  PUSHORT ;

#line 371
typedef ULONG *  PULONG ;

#line 372
typedef UQUAD *  PUQUAD ;

#line 378
typedef signed char SCHAR ;

#line 379
typedef SCHAR *  PSCHAR ;

#line 394
typedef void *  HANDLE ;

#line 400
typedef HANDLE *  PHANDLE ;

#line 406
typedef UCHAR FCHAR ;

#line 407
typedef USHORT FSHORT ;

#line 408
typedef ULONG FLONG ;

#line 414
typedef LONG HRESULT ;

#line 478
typedef char CCHAR ;

#line 479
typedef short CSHORT ;

#line 480
typedef ULONG CLONG ;

typedef CCHAR *  PCCHAR ;

#line 483
typedef CSHORT *  PCSHORT ;

#line 484
typedef CLONG *  PCLONG ;

#line 492
typedef ULONG LCID ;

#line 493
typedef PULONG PLCID ;

#line 494
typedef USHORT LANGID ;

#line 500
typedef ULONG LOGICAL ;

#line 501
typedef ULONG *  PLOGICAL ;

#line 508
typedef LONG NTSTATUS ;

typedef NTSTATUS *  PNTSTATUS ;

#line 602
typedef struct _FLOAT128 {
	__int64 LowPart ;
	__int64 HighPart ;
} FLOAT128 ;

typedef FLOAT128 *  PFLOAT128 ;

#line 621
typedef __int64 LONGLONG ;

#line 622
typedef unsigned __int64 ULONGLONG ;

#line 639
typedef LONGLONG *  PLONGLONG ;

#line 640
typedef ULONGLONG *  PULONGLONG ;

#line 644
typedef LONGLONG USN ;

#line 649
typedef union _LARGE_INTEGER {
	struct  {
		ULONG LowPart ;
		LONG HighPart ;
	}  ;
	struct  {
		ULONG LowPart ;
		LONG HighPart ;
	} u ;
	LONGLONG QuadPart ;
} LARGE_INTEGER ;

#line 662
typedef LARGE_INTEGER *  PLARGE_INTEGER ;

#line 668
typedef union _ULARGE_INTEGER {
	struct  {
		ULONG LowPart ;
		ULONG HighPart ;
	}  ;
	struct  {
		ULONG LowPart ;
		ULONG HighPart ;
	} u ;
	ULONGLONG QuadPart ;
} ULARGE_INTEGER ;

#line 681
typedef ULARGE_INTEGER *  PULARGE_INTEGER ;

#line 690
typedef struct _LUID {
	ULONG LowPart ;
	LONG HighPart ;
} LUID , *  PLUID ;

#line 696
typedef ULONGLONG DWORDLONG ;

#line 697
typedef DWORDLONG *  PDWORDLONG ;

#line 707
typedef LARGE_INTEGER PHYSICAL_ADDRESS , *  PPHYSICAL_ADDRESS ;

#line 809
ULONGLONG __stdcall Int64ShllMod32(ULONGLONG Value , ULONG ShiftCount ) ;
#line 816
LONGLONG __stdcall Int64ShraMod32(LONGLONG Value , ULONG ShiftCount ) ;
#line 823
ULONGLONG __stdcall Int64ShrlMod32(ULONGLONG Value , ULONG ShiftCount ) ;

#line 831

#pragma warning(push)

#pragma warning(disable:4035)
__inline ULONGLONG __stdcall Int64ShllMod32___0(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 842
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    
		};
}

#line 845
__inline LONGLONG __stdcall Int64ShraMod32___0(LONGLONG Value , ULONG ShiftCount
	)
{
	#line 852
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    
		};
}

#line 855
__inline ULONGLONG __stdcall Int64ShrlMod32___0(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 862
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    
		};
}


#pragma warning(pop)
#line 956
typedef enum _EVENT_TYPE {
	NotificationEvent,
	SynchronizationEvent
} EVENT_TYPE ;

#line 965
typedef enum _TIMER_TYPE {
	NotificationTimer,
	SynchronizationTimer
} TIMER_TYPE ;

#line 974
typedef enum _WAIT_TYPE {
	WaitAll,
	WaitAny
} WAIT_TYPE ;

#line 983
typedef CHAR *  PSZ ;

#line 984
typedef const char *  PCSZ ;

#line 991
typedef struct _STRING {
	USHORT Length ;
	USHORT MaximumLength ;
	PCHAR Buffer ;
} STRING ;

#line 999
typedef STRING *  PSTRING ;

typedef STRING ANSI_STRING ;

#line 1002
typedef PSTRING PANSI_STRING ;

typedef STRING OEM_STRING ;

#line 1005
typedef PSTRING POEM_STRING ;

#line 1011
typedef struct _CSTRING {
	USHORT Length ;
	USHORT MaximumLength ;
	const char *  Buffer ;
} CSTRING ;

#line 1016
typedef CSTRING *  PCSTRING ;

#line 1019
typedef STRING CANSI_STRING ;

#line 1020
typedef PSTRING PCANSI_STRING ;

#line 1027
typedef struct _UNICODE_STRING {
	USHORT Length ;
	USHORT MaximumLength ;
	PWSTR Buffer ;
} UNICODE_STRING ;

#line 1036
typedef UNICODE_STRING *  PUNICODE_STRING ;

#line 1037
typedef const UNICODE_STRING *  PCUNICODE_STRING ;

#line 1046
typedef UCHAR BOOLEAN ;

#line 1047
typedef BOOLEAN *  PBOOLEAN ;

#line 1057
typedef struct _LIST_ENTRY {
	struct _LIST_ENTRY *  Flink ;
	struct _LIST_ENTRY *  Blink ;
} LIST_ENTRY , *  PLIST_ENTRY , *  PRLIST_ENTRY ;

#line 1067
typedef struct _SINGLE_LIST_ENTRY {
	struct _SINGLE_LIST_ENTRY *  Next ;
} SINGLE_LIST_ENTRY , *  PSINGLE_LIST_ENTRY ;

#line 1078
typedef struct LIST_ENTRY32 {
	ULONG Flink ;
	ULONG Blink ;
} LIST_ENTRY32 ;

#line 1082
typedef LIST_ENTRY32 *  PLIST_ENTRY32 ;

typedef struct LIST_ENTRY64 {
	ULONGLONG Flink ;
	ULONGLONG Blink ;
} LIST_ENTRY64 ;

#line 1088
typedef LIST_ENTRY64 *  PLIST_ENTRY64 ;

#line 1094
__inline void ListEntry32To64(PLIST_ENTRY32 l32 , PLIST_ENTRY64 l64 )
{
	#line 1101
	l64->Flink = (ULONGLONG )((LONGLONG )((LONG )l32->Flink));
	l64->Blink = (ULONGLONG )((LONGLONG )((LONG )l32->Blink));
}

__inline void ListEntry64To32(PLIST_ENTRY64 l64 , PLIST_ENTRY32 l32 )
{
	#line 1112
	l32->Flink = (ULONG )l64->Flink;
	l32->Blink = (ULONG )l64->Blink;
}

#line 1127
typedef struct _STRING32 {
	USHORT Length ;
	USHORT MaximumLength ;
	ULONG Buffer ;
} STRING32 ;

#line 1132
typedef STRING32 *  PSTRING32 ;

typedef STRING32 UNICODE_STRING32 ;

#line 1135
typedef UNICODE_STRING32 *  PUNICODE_STRING32 ;

typedef STRING32 ANSI_STRING32 ;

#line 1138
typedef ANSI_STRING32 *  PANSI_STRING32 ;

#line 1141
typedef struct _STRING64 {
	USHORT Length ;
	USHORT MaximumLength ;
	ULONGLONG Buffer ;
} STRING64 ;

#line 1146
typedef STRING64 *  PSTRING64 ;

typedef STRING64 UNICODE_STRING64 ;

#line 1149
typedef UNICODE_STRING64 *  PUNICODE_STRING64 ;

typedef STRING64 ANSI_STRING64 ;

#line 1152
typedef ANSI_STRING64 *  PANSI_STRING64 ;

#line 1173
typedef struct _OBJECT_ATTRIBUTES {
	ULONG Length ;
	HANDLE RootDirectory ;
	PUNICODE_STRING ObjectName ;
	ULONG Attributes ;
	PVOID SecurityDescriptor ;
	PVOID SecurityQualityOfService ;
} OBJECT_ATTRIBUTES ;

#line 1181
typedef OBJECT_ATTRIBUTES *  POBJECT_ATTRIBUTES ;

#line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID {
	unsigned long Data1 ;
	unsigned short Data2 ;
	unsigned short Data3 ;
	unsigned char Data4[8] ;
} GUID ;

#line 70
typedef GUID *  LPGUID ;

#line 75
typedef const GUID *  LPCGUID ;

#line 81
typedef GUID IID ;

#line 82
typedef IID *  LPIID ;

#line 85
typedef GUID CLSID ;

#line 86
typedef CLSID *  LPCLSID ;

#line 89
typedef GUID FMTID ;

#line 90
typedef FMTID *  LPFMTID ;

#line 16 "C:/NTDDK/inc/string.h"

#pragma once
#line 93
void * __cdecl memcpy(void *  , const void *  , size_t ) ;
int __cdecl memcmp(const void *  , const void *  , size_t ) ;
void * __cdecl memset(void *  , int  , size_t ) ;
char * __cdecl _strset(char *  , int  ) ;
char * __cdecl strcpy(char *  , const char *  ) ;
char * __cdecl strcat(char *  , const char *  ) ;
int __cdecl strcmp(const char *  , const char *  ) ;
size_t __cdecl strlen(const char *  ) ;
#line 102
void * __cdecl _memccpy(void *  , const void *  , int  , size_t ) ;
void * __cdecl memchr(const void *  , int  , size_t ) ;
int __cdecl _memicmp(const void *  , const void *  , size_t ) ;
#line 110
void * __cdecl memmove(void *  , const void *  , size_t ) ;
#line 114
char * __cdecl strchr(const char *  , int  ) ;
int __cdecl _strcmpi(const char *  , const char *  ) ;
int __cdecl _stricmp(const char *  , const char *  ) ;
int __cdecl strcoll(const char *  , const char *  ) ;
int __cdecl _stricoll(const char *  , const char *  ) ;
int __cdecl _strncoll(const char *  , const char *  , size_t ) ;
int __cdecl _strnicoll(const char *  , const char *  , size_t ) ;
size_t __cdecl strcspn(const char *  , const char *  ) ;
char * __cdecl _strdup(const char *  ) ;
char * __cdecl _strerror(const char *  ) ;
char * __cdecl strerror(int  ) ;
char * __cdecl _strlwr(char *  ) ;
char * __cdecl strncat(char *  , const char *  , size_t ) ;
int __cdecl strncmp(const char *  , const char *  , size_t ) ;
int __cdecl _strnicmp(const char *  , const char *  , size_t ) ;
char * __cdecl strncpy(char *  , const char *  , size_t ) ;
char * __cdecl _strnset(char *  , int  , size_t ) ;
char * __cdecl strpbrk(const char *  , const char *  ) ;
char * __cdecl strrchr(const char *  , int  ) ;
char * __cdecl _strrev(char *  ) ;
size_t __cdecl strspn(const char *  , const char *  ) ;
char * __cdecl strstr(const char *  , const char *  ) ;
char * __cdecl strtok(char *  , const char *  ) ;
char * __cdecl _strupr(char *  ) ;
size_t __cdecl strxfrm(char *  , const char *  , size_t ) ;
#line 144
void * __cdecl memccpy(void *  , const void *  , int  , size_t ) ;
int __cdecl memicmp(const void *  , const void *  , size_t ) ;
int __cdecl strcmpi(const char *  , const char *  ) ;
int __cdecl stricmp(const char *  , const char *  ) ;
char * __cdecl strdup(const char *  ) ;
char * __cdecl strlwr(char *  ) ;
int __cdecl strnicmp(const char *  , const char *  , size_t ) ;
char * __cdecl strnset(char *  , int  , size_t ) ;
char * __cdecl strrev(char *  ) ;
char * __cdecl strset(char *  , int  ) ;
char * __cdecl strupr(char *  ) ;
#line 163
wchar_t * __cdecl wcscat(wchar_t *  , const wchar_t *  ) ;
wchar_t * __cdecl wcschr(const wchar_t *  , wchar_t ) ;
int __cdecl wcscmp(const wchar_t *  , const wchar_t *  ) ;
wchar_t * __cdecl wcscpy(wchar_t *  , const wchar_t *  ) ;
size_t __cdecl wcscspn(const wchar_t *  , const wchar_t *  ) ;
size_t __cdecl wcslen(const wchar_t *  ) ;
wchar_t * __cdecl wcsncat(wchar_t *  , const wchar_t *  , size_t ) ;
int __cdecl wcsncmp(const wchar_t *  , const wchar_t *  , size_t ) ;
wchar_t * __cdecl wcsncpy(wchar_t *  , const wchar_t *  , size_t ) ;
wchar_t * __cdecl wcspbrk(const wchar_t *  , const wchar_t *  ) ;
wchar_t * __cdecl wcsrchr(const wchar_t *  , wchar_t ) ;
size_t __cdecl wcsspn(const wchar_t *  , const wchar_t *  ) ;
wchar_t * __cdecl wcsstr(const wchar_t *  , const wchar_t *  ) ;
wchar_t * __cdecl wcstok(wchar_t *  , const wchar_t *  ) ;
#line 178
wchar_t * __cdecl _wcsdup(const wchar_t *  ) ;
int __cdecl _wcsicmp(const wchar_t *  , const wchar_t *  ) ;
int __cdecl _wcsnicmp(const wchar_t *  , const wchar_t *  , size_t ) ;
wchar_t * __cdecl _wcsnset(wchar_t *  , wchar_t , size_t ) ;
wchar_t * __cdecl _wcsrev(wchar_t *  ) ;
wchar_t * __cdecl _wcsset(wchar_t *  , wchar_t ) ;
#line 185
wchar_t * __cdecl _wcslwr(wchar_t *  ) ;
wchar_t * __cdecl _wcsupr(wchar_t *  ) ;
size_t __cdecl wcsxfrm(wchar_t *  , const wchar_t *  , size_t ) ;
int __cdecl wcscoll(const wchar_t *  , const wchar_t *  ) ;
int __cdecl _wcsicoll(const wchar_t *  , const wchar_t *  ) ;
int __cdecl _wcsncoll(const wchar_t *  , const wchar_t *  , size_t ) ;
int __cdecl _wcsnicoll(const wchar_t *  , const wchar_t *  , size_t ) ;
#line 199
wchar_t * __cdecl wcsdup(const wchar_t *  ) ;
int __cdecl wcsicmp(const wchar_t *  , const wchar_t *  ) ;
int __cdecl wcsnicmp(const wchar_t *  , const wchar_t *  , size_t ) ;
wchar_t * __cdecl wcsnset(wchar_t *  , wchar_t , size_t ) ;
wchar_t * __cdecl wcsrev(wchar_t *  ) ;
wchar_t * __cdecl wcsset(wchar_t *  , wchar_t ) ;
wchar_t * __cdecl wcslwr(wchar_t *  ) ;
wchar_t * __cdecl wcsupr(wchar_t *  ) ;
int __cdecl wcsicoll(const wchar_t *  , const wchar_t *  ) ;

#line 1233 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECTID {
	GUID Lineage ;
	ULONG Uniquifier ;
} OBJECTID ;

#line 1288
struct _CONTEXT ;

#line 1289
struct _EXCEPTION_RECORD ;

typedef EXCEPTION_DISPOSITION ( *  PEXCEPTION_ROUTINE
	)(struct _EXCEPTION_RECORD *  ExceptionRecord , PVOID EstablisherFrame ,
	struct _CONTEXT *  ContextRecord , PVOID DispatcherContext ) ;

#line 1306
typedef UCHAR KIRQL ;

typedef KIRQL *  PKIRQL ;

#line 1316
typedef enum _NT_PRODUCT_TYPE {
	NtProductWinNt = 1,
	NtProductLanManNt,
	NtProductServer
} NT_PRODUCT_TYPE , *  PNT_PRODUCT_TYPE ;

#line 1329
typedef enum _SUITE_TYPE {
	SmallBusiness,
	Enterprise,
	BackOffice,
	CommunicationServer,
	TerminalServer,
	SmallBusinessRestricted,
	EmbeddedNT,
	DataCenter,
	SingleUserTS,
	MaxSuiteType
} SUITE_TYPE ;

#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD *  PKTHREAD ;

#line 76
typedef struct _ETHREAD *  PETHREAD ;

#line 77
typedef struct _EPROCESS *  PEPROCESS ;

#line 78
typedef struct _PEB *  PPEB ;

#line 79
typedef struct _KINTERRUPT *  PKINTERRUPT ;

#line 80
typedef struct _IO_TIMER *  PIO_TIMER ;

#line 81
typedef struct _OBJECT_TYPE *  POBJECT_TYPE ;

#line 82
typedef struct _CALLBACK_OBJECT *  PCALLBACK_OBJECT___0 ;

#line 83
typedef struct _DEVICE_HANDLER_OBJECT *  PDEVICE_HANDLER_OBJECT ;

#line 84
typedef struct _BUS_HANDLER *  PBUS_HANDLER ;

#line 101
PKTHREAD __stdcall KeGetCurrentThread() ;
#line 124
extern PCCHAR KeNumberProcessors ;

#line 143
typedef union _SLIST_HEADER {
	ULONGLONG Alignment ;
	struct  {
		SINGLE_LIST_ENTRY Next ;
		USHORT Depth ;
		USHORT Sequence ;
	}  ;
} SLIST_HEADER , *  PSLIST_HEADER ;

#line 204
typedef CCHAR KPROCESSOR_MODE ;

typedef enum _MODE {
	KernelMode,
	UserMode,
	MaximumMode
} MODE ;

#line 222
struct _KAPC ;

typedef void ( *  PKNORMAL_ROUTINE )(PVOID NormalContext , PVOID SystemArgument1
	, PVOID SystemArgument2 ) ;

#line 232
typedef void ( *  PKKERNEL_ROUTINE )(struct _KAPC *  Apc , PKNORMAL_ROUTINE * 
	NormalRoutine , PVOID *  NormalContext , PVOID *  SystemArgument1 ,
	PVOID *  SystemArgument2 ) ;

#line 242
typedef void ( *  PKRUNDOWN_ROUTINE )(struct _KAPC *  Apc ) ;

#line 248
typedef BOOLEAN ( *  PKSYNCHRONIZE_ROUTINE )(PVOID SynchronizeContext ) ;

#line 254
typedef BOOLEAN ( *  PKTRANSFER_ROUTINE )(void  ) ;

#line 265
typedef struct _KAPC {
	CSHORT Type ;
	CSHORT Size ;
	ULONG Spare0 ;
	struct _KTHREAD *  Thread ;
	LIST_ENTRY ApcListEntry ;
	PKKERNEL_ROUTINE KernelRoutine ;
	PKRUNDOWN_ROUTINE RundownRoutine ;
	PKNORMAL_ROUTINE NormalRoutine ;
	PVOID NormalContext ;
	PVOID SystemArgument1 ;
	PVOID SystemArgument2 ;
	CCHAR ApcStateIndex ;
	KPROCESSOR_MODE ApcMode ;
	BOOLEAN Inserted ;
} KAPC , *  PKAPC , *  PRKAPC ;

#line 292
struct _KDPC ;

typedef void ( *  PKDEFERRED_ROUTINE )(struct _KDPC *  Dpc , PVOID
	DeferredContext , PVOID SystemArgument1 , PVOID SystemArgument2 ) ;

#line 351
typedef enum _KDPC_IMPORTANCE {
	LowImportance,
	MediumImportance,
	HighImportance
} KDPC_IMPORTANCE ;

#line 361
typedef struct _KDPC {
	CSHORT Type ;
	UCHAR Number ;
	UCHAR Importance ;
	LIST_ENTRY DpcListEntry ;
	PKDEFERRED_ROUTINE DeferredRoutine ;
	PVOID DeferredContext ;
	PVOID SystemArgument1 ;
	PVOID SystemArgument2 ;
	PULONG_PTR Lock ;
} KDPC , *  PKDPC , *  PRKDPC ;

#line 377
typedef PVOID PKIPI_CONTEXT ;

typedef void ( *  PKIPI_WORKER )(PKIPI_CONTEXT PacketContext , PVOID Parameter1
	, PVOID Parameter2 , PVOID Parameter3 ) ;

#line 392
typedef struct _KIPI_COUNTS {
	ULONG Freeze ;
	ULONG Packet ;
	ULONG DPC ;
	ULONG APC ;
	ULONG FlushSingleTb ;
	ULONG FlushMultipleTb ;
	ULONG FlushEntireTb ;
	ULONG GenericCall ;
	ULONG ChangeColor ;
	ULONG SweepDcache ;
	ULONG SweepIcache ;
	ULONG SweepIcacheRange ;
	ULONG FlushIoBuffers ;
	ULONG GratuitousDPC ;
} KIPI_COUNTS , *  PKIPI_COUNTS ;

#line 443
typedef struct _MDL {
	struct _MDL *  Next ;
	CSHORT Size ;
	CSHORT MdlFlags ;
	struct _EPROCESS *  Process ;
	PVOID MappedSystemVa ;
	PVOID StartVa ;
	ULONG ByteCount ;
	ULONG ByteOffset ;
} MDL , *  PMDL ;

#line 532
typedef PVOID PACCESS_TOKEN ;

#line 538
typedef PVOID PSECURITY_DESCRIPTOR ;

#line 544
typedef PVOID PSID ;

typedef ULONG ACCESS_MASK ;

#line 547
typedef ACCESS_MASK *  PACCESS_MASK ;

#line 597
typedef struct _GENERIC_MAPPING {
	ACCESS_MASK GenericRead ;
	ACCESS_MASK GenericWrite ;
	ACCESS_MASK GenericExecute ;
	ACCESS_MASK GenericAll ;
} GENERIC_MAPPING ;

#line 603
typedef GENERIC_MAPPING *  PGENERIC_MAPPING ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES {
	LUID Luid ;
	ULONG Attributes ;
} LUID_AND_ATTRIBUTES , *  PLUID_AND_ATTRIBUTES ;

#line 622
typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[1] ;

#line 623
typedef LUID_AND_ATTRIBUTES_ARRAY *  PLUID_AND_ATTRIBUTES_ARRAY ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 642 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACL {
	UCHAR AclRevision ;
	UCHAR Sbz1 ;
	USHORT AclSize ;
	USHORT AceCount ;
	USHORT Sbz2 ;
} ACL ;

#line 649
typedef ACL *  PACL ;

#line 681
typedef struct _PRIVILEGE_SET {
	ULONG PrivilegeCount ;
	ULONG Control ;
	LUID_AND_ATTRIBUTES Privilege[1] ;
} PRIVILEGE_SET , *  PPRIVILEGE_SET ;

#line 735
typedef enum _SECURITY_IMPERSONATION_LEVEL {
	SecurityAnonymous,
	SecurityIdentification,
	SecurityImpersonation,
	SecurityDelegation
} SECURITY_IMPERSONATION_LEVEL , *  PSECURITY_IMPERSONATION_LEVEL ;

#line 753
typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE , * 
	PSECURITY_CONTEXT_TRACKING_MODE ;

#line 762
typedef struct _SECURITY_QUALITY_OF_SERVICE {
	ULONG Length ;
	SECURITY_IMPERSONATION_LEVEL ImpersonationLevel ;
	SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode ;
	BOOLEAN EffectiveOnly ;
} SECURITY_QUALITY_OF_SERVICE , *  PSECURITY_QUALITY_OF_SERVICE ;

#line 774
typedef struct _SE_IMPERSONATION_STATE {
	PACCESS_TOKEN Token ;
	BOOLEAN CopyOnOpen ;
	BOOLEAN EffectiveOnly ;
	SECURITY_IMPERSONATION_LEVEL Level ;
} SE_IMPERSONATION_STATE , *  PSE_IMPERSONATION_STATE ;

#line 782
typedef ULONG SECURITY_INFORMATION , *  PSECURITY_INFORMATION ;

#line 809
typedef ULONG KAFFINITY ;

#line 810
typedef KAFFINITY *  PKAFFINITY ;

#line 816
typedef LONG KPRIORITY ;

#line 824
typedef ULONG_PTR KSPIN_LOCK ;

#line 825
typedef KSPIN_LOCK *  PKSPIN_LOCK ;

#line 833
typedef void ( *  PKINTERRUPT_ROUTINE )(void  ) ;

#line 842
typedef enum _KPROFILE_SOURCE {
	ProfileTime,
	ProfileAlignmentFixup,
	ProfileTotalIssues,
	ProfilePipelineDry,
	ProfileLoadInstructions,
	ProfilePipelineFrozen,
	ProfileBranchInstructions,
	ProfileTotalNonissues,
	ProfileDcacheMisses,
	ProfileIcacheMisses,
	ProfileCacheMisses,
	ProfileBranchMispredictions,
	ProfileStoreInstructions,
	ProfileFpInstructions,
	ProfileIntegerInstructions,
	Profile2Issue,
	Profile3Issue,
	Profile4Issue,
	ProfileSpecialInstructions,
	ProfileTotalCycles,
	ProfileIcacheIssues,
	ProfileDcacheAccesses,
	ProfileMemoryBarrierCycles,
	ProfileLoadLinkedIssues,
	ProfileMaximum
} KPROFILE_SOURCE ;

#line 1058
__declspec(dllimport) void __stdcall RtlGetCallersAddress(PVOID * 
	CallersAddress , PVOID *  CallersCaller ) ;
#line 1067
__declspec(dllimport) ULONG __stdcall RtlWalkFrameChain(PVOID *  Callers , ULONG
	Count , ULONG Flags ) ;

#line 1079
typedef NTSTATUS (__stdcall *  PRTL_QUERY_REGISTRY_ROUTINE )(PWSTR ValueName ,
	ULONG ValueType , PVOID ValueData , ULONG ValueLength , PVOID Context ,
	PVOID EntryContext ) ;

#line 1088
typedef struct _RTL_QUERY_REGISTRY_TABLE {
	PRTL_QUERY_REGISTRY_ROUTINE QueryRoutine ;
	ULONG Flags ;
	PWSTR Name ;
	PVOID EntryContext ;
	ULONG DefaultType ;
	PVOID DefaultData ;
	ULONG DefaultLength ;
} RTL_QUERY_REGISTRY_TABLE , *  PRTL_QUERY_REGISTRY_TABLE ;

#line 1136
__declspec(dllimport) NTSTATUS __stdcall RtlQueryRegistryValues(ULONG RelativeTo
	, PCWSTR Path , PRTL_QUERY_REGISTRY_TABLE QueryTable , PVOID Context ,
	PVOID Environment ) ;
#line 1147
__declspec(dllimport) NTSTATUS __stdcall RtlWriteRegistryValue(ULONG RelativeTo
	, PCWSTR Path , PCWSTR ValueName , ULONG ValueType , PVOID ValueData ,
	ULONG ValueLength ) ;
#line 1159
__declspec(dllimport) NTSTATUS __stdcall RtlDeleteRegistryValue(ULONG RelativeTo
	, PCWSTR Path , PCWSTR ValueName ) ;
#line 1170
__declspec(dllimport) NTSTATUS __stdcall RtlCreateRegistryKey(ULONG RelativeTo ,
	PWSTR Path ) ;
#line 1178
__declspec(dllimport) NTSTATUS __stdcall RtlCheckRegistryKey(ULONG RelativeTo ,
	PWSTR Path ) ;
#line 1202
__declspec(dllimport) NTSTATUS __stdcall RtlCharToInteger(PCSZ String , ULONG
	Base , PULONG Value ) ;
#line 1211
__declspec(dllimport) NTSTATUS __stdcall RtlIntegerToUnicodeString(ULONG Value ,
	ULONG Base , PUNICODE_STRING String ) ;
#line 1220
__declspec(dllimport) NTSTATUS __stdcall RtlInt64ToUnicodeString(ULONGLONG Value
	, ULONG Base , PUNICODE_STRING String ) ;
#line 1235
__declspec(dllimport) NTSTATUS __stdcall
	RtlUnicodeStringToInteger(PUNICODE_STRING String , ULONG Base , PULONG
	Value ) ;
#line 1261
extern BOOLEAN ( *  NlsMbCodePageTag ) ;
extern BOOLEAN ( *  NlsMbOemCodePageTag ) ;
#line 1264
__declspec(dllimport) void __stdcall RtlInitString(PSTRING DestinationString ,
	PCSZ SourceString ) ;
#line 1272
__declspec(dllimport) void __stdcall RtlInitAnsiString(PANSI_STRING
	DestinationString , PCSZ SourceString ) ;
#line 1280
__declspec(dllimport) void __stdcall RtlInitUnicodeString(PUNICODE_STRING
	DestinationString , PCWSTR SourceString ) ;
#line 1289
__declspec(dllimport) void __stdcall RtlCopyString(PSTRING DestinationString ,
	PSTRING SourceString ) ;
#line 1297
__declspec(dllimport) CHAR __stdcall RtlUpperChar(CHAR Character ) ;
#line 1304
__declspec(dllimport) LONG __stdcall RtlCompareString(PSTRING String1 , PSTRING
	String2 , BOOLEAN CaseInSensitive ) ;
#line 1313
__declspec(dllimport) BOOLEAN __stdcall RtlEqualString(PSTRING String1 , PSTRING
	String2 , BOOLEAN CaseInSensitive ) ;
#line 1323
__declspec(dllimport) void __stdcall RtlUpperString(PSTRING DestinationString ,
	PSTRING SourceString ) ;
#line 1335
__declspec(dllimport) NTSTATUS __stdcall
	RtlAnsiStringToUnicodeString(PUNICODE_STRING DestinationString ,
	PANSI_STRING SourceString , BOOLEAN AllocateDestinationString ) ;
#line 1345
__declspec(dllimport) NTSTATUS __stdcall
	RtlUnicodeStringToAnsiString(PANSI_STRING DestinationString ,
	PUNICODE_STRING SourceString , BOOLEAN AllocateDestinationString ) ;
#line 1355
__declspec(dllimport) LONG __stdcall RtlCompareUnicodeString(PUNICODE_STRING
	String1 , PUNICODE_STRING String2 , BOOLEAN CaseInSensitive ) ;
#line 1364
__declspec(dllimport) BOOLEAN __stdcall RtlEqualUnicodeString(const
	UNICODE_STRING *  String1 , const UNICODE_STRING *  String2 , BOOLEAN
	CaseInSensitive ) ;
#line 1375
__declspec(dllimport) BOOLEAN __stdcall RtlPrefixUnicodeString(PUNICODE_STRING
	String1 , PUNICODE_STRING String2 , BOOLEAN CaseInSensitive ) ;
#line 1384
__declspec(dllimport) NTSTATUS __stdcall RtlUpcaseUnicodeString(PUNICODE_STRING
	DestinationString , PCUNICODE_STRING SourceString , BOOLEAN
	AllocateDestinationString ) ;
#line 1394
__declspec(dllimport) void __stdcall RtlCopyUnicodeString(PUNICODE_STRING
	DestinationString , PUNICODE_STRING SourceString ) ;
#line 1402
__declspec(dllimport) NTSTATUS __stdcall
	RtlAppendUnicodeStringToString(PUNICODE_STRING Destination ,
	PUNICODE_STRING Source ) ;
#line 1410
__declspec(dllimport) NTSTATUS __stdcall
	RtlAppendUnicodeToString(PUNICODE_STRING Destination , PCWSTR Source ) ;
#line 1420
__declspec(dllimport) WCHAR __stdcall RtlUpcaseUnicodeChar(WCHAR SourceCharacter
	) ;
#line 1429
__declspec(dllimport) void __stdcall RtlFreeUnicodeString(PUNICODE_STRING
	UnicodeString ) ;
#line 1436
__declspec(dllimport) void __stdcall RtlFreeAnsiString(PANSI_STRING AnsiString )
	;
#line 1444
__declspec(dllimport) ULONG __stdcall RtlxAnsiStringToUnicodeSize(PANSI_STRING
	AnsiString ) ;
#line 1494
__declspec(dllimport) NTSTATUS __stdcall RtlStringFromGUID(const GUID * const
	Guid , PUNICODE_STRING GuidString ) ;
#line 1502
__declspec(dllimport) NTSTATUS __stdcall RtlGUIDFromString(PUNICODE_STRING
	GuidString , GUID *  Guid ) ;
#line 1516
__declspec(dllimport) SIZE_T __stdcall RtlCompareMemory(const void *  Source1 ,
	const void *  Source2 , SIZE_T Length ) ;
#line 1641
void __stdcall DbgBreakPoint(void  ) ;
#line 1649
__declspec(dllimport) void __stdcall DbgBreakPointWithStatus(ULONG Status ) ;
#line 1690
ULONG _cdecl DbgPrint(PCH Format , ...) ;
#line 1699
ULONG _cdecl DbgPrintReturnControlC(PCH Format , ...) ;

#line 1718
__inline LARGE_INTEGER __stdcall RtlLargeIntegerAdd(LARGE_INTEGER Addend1 ,
	LARGE_INTEGER Addend2 )
{
	#line 1726
	LARGE_INTEGER Sum ;
	#line 1728
	Sum.QuadPart = Addend1.QuadPart + Addend2.QuadPart;
	return Sum;
}

#line 1736
__inline LARGE_INTEGER __stdcall RtlEnlargedIntegerMultiply(LONG Multiplicand ,
	LONG Multiplier )
{
	#line 1744
	LARGE_INTEGER Product ;
	#line 1746
	Product.QuadPart = (LONGLONG )Multiplicand * (ULONGLONG )Multiplier;
	return Product;
}

#line 1754
__inline LARGE_INTEGER __stdcall RtlEnlargedUnsignedMultiply(ULONG Multiplicand
	, ULONG Multiplier )
{
	#line 1762
	LARGE_INTEGER Product ;
	#line 1764
	Product.QuadPart = (ULONGLONG )Multiplicand * (ULONGLONG )Multiplier;
	return Product;
}

#line 1772
__inline ULONG __stdcall RtlEnlargedUnsignedDivide(ULARGE_INTEGER Dividend ,
	ULONG Divisor , PULONG Remainder )
{
	#line 1781
	ULONG Quotient ;
	#line 1783
	Quotient = (ULONG )(Dividend.QuadPart / Divisor);
	if((CHAR *  )Remainder != (CHAR *  )((void *  )0))
	{
		* Remainder = (ULONG )(Dividend.QuadPart % Divisor);
	}
	#line 1789
	return Quotient;
}

#line 1796
__inline LARGE_INTEGER __stdcall RtlLargeIntegerNegate(LARGE_INTEGER Subtrahend
	)
{
	#line 1803
	LARGE_INTEGER Difference ;
	#line 1805
	Difference.QuadPart = - Subtrahend.QuadPart;
	return Difference;
}

#line 1813
__inline LARGE_INTEGER __stdcall RtlLargeIntegerSubtract(LARGE_INTEGER Minuend ,
	LARGE_INTEGER Subtrahend )
{
	#line 1821
	LARGE_INTEGER Difference ;
	#line 1823
	Difference.QuadPart = Minuend.QuadPart - Subtrahend.QuadPart;
	return Difference;
}

#line 1833
__declspec(dllimport) LARGE_INTEGER __stdcall
	RtlExtendedMagicDivide(LARGE_INTEGER Dividend , LARGE_INTEGER
	MagicDivisor , CCHAR ShiftCount ) ;
#line 1846
__declspec(dllimport) LARGE_INTEGER __stdcall
	RtlExtendedLargeIntegerDivide(LARGE_INTEGER Dividend , ULONG Divisor ,
	PULONG Remainder ) ;
#line 1860
__declspec(dllimport) LARGE_INTEGER __stdcall
	RtlLargeIntegerDivide(LARGE_INTEGER Dividend , LARGE_INTEGER Divisor ,
	PLARGE_INTEGER Remainder ) ;
#line 1874
__declspec(dllimport) LARGE_INTEGER __stdcall
	RtlExtendedIntegerMultiply(LARGE_INTEGER Multiplicand , LONG Multiplier
	) ;

#line 1952

#pragma warning(push)

#pragma warning(disable:4035)
#line 1960
__inline LARGE_INTEGER __stdcall RtlConvertLongToLargeInteger(LONG SignedInteger
	)
{
	#line 1966
	__asm {
        mov     eax, SignedInteger
        cdq                 ; (edx:eax) = signed LargeInt
    
		};
}

#line 1973
__inline LARGE_INTEGER __stdcall RtlConvertUlongToLargeInteger(ULONG
	UnsignedInteger )
{
	#line 1979
	__asm {
        sub     edx, edx    ; zero highpart
        mov     eax, UnsignedInteger
    
		};
}

#line 1986
__inline LARGE_INTEGER __stdcall RtlLargeIntegerShiftLeft(LARGE_INTEGER
	LargeInteger , CCHAR ShiftCount )
{
	#line 1993
	__asm {
        mov     cl, ShiftCount
        and     cl, 0x3f                    ; mod 64

        cmp     cl, 32
        jc      short sl10

        mov     edx, LargeInteger.LowPart   ; ShiftCount >= 32
        xor     eax, eax                    ; lowpart is zero
        shl     edx, cl                     ; store highpart
        jmp     short done

sl10:
        mov     eax, LargeInteger.LowPart   ; ShiftCount < 32
        mov     edx, LargeInteger.HighPart
        shld    edx, eax, cl
        shl     eax, cl
done:
    
		};
}

__inline LARGE_INTEGER __stdcall RtlLargeIntegerShiftRight(LARGE_INTEGER
	LargeInteger , CCHAR ShiftCount )
{
	#line 2004
	__asm {
        mov     cl, ShiftCount
        and     cl, 0x3f               ; mod 64

        cmp     cl, 32
        jc      short sr10

        mov     eax, LargeInteger.HighPart  ; ShiftCount >= 32
        xor     edx, edx                    ; lowpart is zero
        shr     eax, cl                     ; store highpart
        jmp     short done

sr10:
        mov     eax, LargeInteger.LowPart   ; ShiftCount < 32
        mov     edx, LargeInteger.HighPart
        shrd    eax, edx, cl
        shr     edx, cl
done:
    
		};
}

__inline LARGE_INTEGER __stdcall RtlLargeIntegerArithmeticShift(LARGE_INTEGER
	LargeInteger , CCHAR ShiftCount )
{
	#line 2015
	__asm {
        mov     cl, ShiftCount
        and     cl, 3fh                 ; mod 64

        cmp     cl, 32
        jc      short sar10

        mov     eax, LargeInteger.HighPart
        sar     eax, cl
        bt      eax, 31                     ; sign bit set?
        sbb     edx, edx                    ; duplicate sign bit into highpart
        jmp     short done
sar10:
        mov     eax, LargeInteger.LowPart   ; (eax) = LargeInteger.LowPart
        mov     edx, LargeInteger.HighPart  ; (edx) = LargeInteger.HighPart
        shrd    eax, edx, cl
        sar     edx, cl
done:
    
		};
}


#pragma warning(pop)
#line 2214
typedef struct _TIME_FIELDS {
	CSHORT Year ;
	CSHORT Month ;
	CSHORT Day ;
	CSHORT Hour ;
	CSHORT Minute ;
	CSHORT Second ;
	CSHORT Milliseconds ;
	CSHORT Weekday ;
} TIME_FIELDS ;

#line 2224
typedef TIME_FIELDS *  PTIME_FIELDS ;

#line 2227
__declspec(dllimport) void __stdcall RtlTimeToTimeFields(PLARGE_INTEGER Time ,
	PTIME_FIELDS TimeFields ) ;
#line 2239
__declspec(dllimport) BOOLEAN __stdcall RtlTimeFieldsToTime(PTIME_FIELDS
	TimeFields , PLARGE_INTEGER Time ) ;

#line 2499
typedef struct _RTL_BITMAP {
	ULONG SizeOfBitMap ;
	PULONG Buffer ;
} RTL_BITMAP ;

#line 2503
typedef RTL_BITMAP *  PRTL_BITMAP ;

#line 2511
__declspec(dllimport) void __stdcall RtlInitializeBitMap(PRTL_BITMAP
	BitMapHeader , PULONG BitMapBuffer , ULONG SizeOfBitMap ) ;
#line 2525
__declspec(dllimport) void __stdcall RtlClearAllBits(PRTL_BITMAP BitMapHeader )
	;
#line 2532
__declspec(dllimport) void __stdcall RtlSetAllBits(PRTL_BITMAP BitMapHeader ) ;
#line 2549
__declspec(dllimport) ULONG __stdcall RtlFindClearBits(PRTL_BITMAP BitMapHeader
	, ULONG NumberToFind , ULONG HintIndex ) ;
#line 2558
__declspec(dllimport) ULONG __stdcall RtlFindSetBits(PRTL_BITMAP BitMapHeader ,
	ULONG NumberToFind , ULONG HintIndex ) ;
#line 2578
__declspec(dllimport) ULONG __stdcall RtlFindClearBitsAndSet(PRTL_BITMAP
	BitMapHeader , ULONG NumberToFind , ULONG HintIndex ) ;
#line 2587
__declspec(dllimport) ULONG __stdcall RtlFindSetBitsAndClear(PRTL_BITMAP
	BitMapHeader , ULONG NumberToFind , ULONG HintIndex ) ;
#line 2601
__declspec(dllimport) void __stdcall RtlClearBits(PRTL_BITMAP BitMapHeader ,
	ULONG StartingIndex , ULONG NumberToClear ) ;
#line 2610
__declspec(dllimport) void __stdcall RtlSetBits(PRTL_BITMAP BitMapHeader , ULONG
	StartingIndex , ULONG NumberToSet ) ;

#line 2627
typedef struct _RTL_BITMAP_RUN {
	ULONG StartingIndex ;
	ULONG NumberOfBits ;
} RTL_BITMAP_RUN ;

#line 2633
typedef RTL_BITMAP_RUN *  PRTL_BITMAP_RUN ;

__declspec(dllimport) ULONG __stdcall RtlFindClearRuns(PRTL_BITMAP BitMapHeader
	, PRTL_BITMAP_RUN RunArray , ULONG SizeOfRunArray , BOOLEAN
	LocateLongestRuns ) ;
#line 2652
__declspec(dllimport) ULONG __stdcall RtlFindLongestRunClear(PRTL_BITMAP
	BitMapHeader , PULONG StartingIndex ) ;
#line 2667
__declspec(dllimport) ULONG __stdcall RtlFindFirstRunClear(PRTL_BITMAP
	BitMapHeader , PULONG StartingIndex ) ;
#line 2699
__declspec(dllimport) ULONG __stdcall RtlNumberOfClearBits(PRTL_BITMAP
	BitMapHeader ) ;
#line 2706
__declspec(dllimport) ULONG __stdcall RtlNumberOfSetBits(PRTL_BITMAP
	BitMapHeader ) ;
#line 2718
__declspec(dllimport) BOOLEAN __stdcall RtlAreBitsClear(PRTL_BITMAP BitMapHeader
	, ULONG StartingIndex , ULONG Length ) ;
#line 2727
__declspec(dllimport) BOOLEAN __stdcall RtlAreBitsSet(PRTL_BITMAP BitMapHeader ,
	ULONG StartingIndex , ULONG Length ) ;
#line 2736
__declspec(dllimport) ULONG __stdcall RtlFindNextForwardRunClear(PRTL_BITMAP
	BitMapHeader , ULONG FromIndex , PULONG StartingRunIndex ) ;
#line 2745
__declspec(dllimport) ULONG __stdcall RtlFindLastBackwardRunClear(PRTL_BITMAP
	BitMapHeader , ULONG FromIndex , PULONG StartingRunIndex ) ;
#line 2760
__declspec(dllimport) CCHAR __stdcall RtlFindLeastSignificantBit(ULONGLONG Set )
	;
#line 2767
__declspec(dllimport) CCHAR __stdcall RtlFindMostSignificantBit(ULONGLONG Set )
	;

#line 2796
__inline LUID __stdcall RtlConvertLongToLuid(LONG Long )
{
	#line 2802
	LUID TempLuid ;
	LARGE_INTEGER TempLi ;
	#line 2805
	TempLi = RtlConvertLongToLargeInteger(Long);
	TempLuid.LowPart = TempLi.LowPart;
	TempLuid.HighPart = TempLi.HighPart;
	return TempLuid;
}

__inline LUID __stdcall RtlConvertUlongToLuid(ULONG Ulong )
{
	#line 2817
	LUID TempLuid ;
	#line 2819
	TempLuid.LowPart = Ulong;
	TempLuid.HighPart = 0;
	return TempLuid;
}

#line 2826
__declspec(dllimport) void __stdcall RtlMapGenericMask(PACCESS_MASK AccessMask ,
	PGENERIC_MAPPING GenericMapping ) ;
#line 2837
__declspec(dllimport) NTSTATUS __stdcall
	RtlCreateSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor ,
	ULONG Revision ) ;
#line 2846
__declspec(dllimport) BOOLEAN __stdcall
	RtlValidSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor ) ;
#line 2854
__declspec(dllimport) ULONG __stdcall
	RtlLengthSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor ) ;
#line 2861
__declspec(dllimport) BOOLEAN __stdcall
	RtlValidRelativeSecurityDescriptor(PSECURITY_DESCRIPTOR
	SecurityDescriptorInput , ULONG SecurityDescriptorLength ,
	SECURITY_INFORMATION RequiredInformation ) ;
#line 2871
__declspec(dllimport) NTSTATUS __stdcall
	RtlSetDaclSecurityDescriptor(PSECURITY_DESCRIPTOR SecurityDescriptor ,
	BOOLEAN DaclPresent , PACL Dacl , BOOLEAN DaclDefaulted ) ;

#line 2886
typedef struct _RTL_RANGE {
	ULONGLONG Start ;
	ULONGLONG End ;
	PVOID UserData ;
	PVOID Owner ;
	UCHAR Attributes ;
	UCHAR Flags ;
} RTL_RANGE , *  PRTL_RANGE ;

#line 2924
typedef struct _RTL_RANGE_LIST {
	LIST_ENTRY ListHead ;
	ULONG Flags ;
	ULONG Count ;
	ULONG Stamp ;
} RTL_RANGE_LIST , *  PRTL_RANGE_LIST ;

#line 2950
typedef struct _RANGE_LIST_ITERATOR {
	PLIST_ENTRY RangeListHead ;
	PLIST_ENTRY MergedHead ;
	PVOID Current ;
	ULONG Stamp ;
} RTL_RANGE_LIST_ITERATOR , *  PRTL_RANGE_LIST_ITERATOR ;

#line 2960
__declspec(dllimport) void __stdcall RtlInitializeRangeList(PRTL_RANGE_LIST
	RangeList ) ;
#line 2967
__declspec(dllimport) void __stdcall RtlFreeRangeList(PRTL_RANGE_LIST RangeList
	) ;
#line 2974
__declspec(dllimport) NTSTATUS __stdcall RtlCopyRangeList(PRTL_RANGE_LIST
	CopyRangeList , PRTL_RANGE_LIST RangeList ) ;
#line 2985
__declspec(dllimport) NTSTATUS __stdcall RtlAddRange(PRTL_RANGE_LIST RangeList ,
	ULONGLONG Start , ULONGLONG End , UCHAR Attributes , ULONG Flags , PVOID
	UserData , PVOID Owner ) ;
#line 2998
__declspec(dllimport) NTSTATUS __stdcall RtlDeleteRange(PRTL_RANGE_LIST
	RangeList , ULONGLONG Start , ULONGLONG End , PVOID Owner ) ;
#line 3008
__declspec(dllimport) NTSTATUS __stdcall RtlDeleteOwnersRanges(PRTL_RANGE_LIST
	RangeList , PVOID Owner ) ;

#line 3019
typedef BOOLEAN ( *  PRTL_CONFLICT_RANGE_CALLBACK )(PVOID Context , PRTL_RANGE
	Range ) ;

#line 3026
__declspec(dllimport) NTSTATUS __stdcall RtlFindRange(PRTL_RANGE_LIST RangeList
	, ULONGLONG Minimum , ULONGLONG Maximum , ULONG Length , ULONG Alignment
	, ULONG Flags , UCHAR AttributeAvailableMask , PVOID Context ,
	PRTL_CONFLICT_RANGE_CALLBACK Callback , PULONGLONG Start ) ;
#line 3042
__declspec(dllimport) NTSTATUS __stdcall RtlIsRangeAvailable(PRTL_RANGE_LIST
	RangeList , ULONGLONG Start , ULONGLONG End , ULONG Flags , UCHAR
	AttributeAvailableMask , PVOID Context , PRTL_CONFLICT_RANGE_CALLBACK
	Callback , PBOOLEAN Available ) ;
#line 3068
__declspec(dllimport) NTSTATUS __stdcall RtlGetFirstRange(PRTL_RANGE_LIST
	RangeList , PRTL_RANGE_LIST_ITERATOR Iterator , PRTL_RANGE *  Range ) ;
#line 3077
__declspec(dllimport) NTSTATUS __stdcall RtlGetLastRange(PRTL_RANGE_LIST
	RangeList , PRTL_RANGE_LIST_ITERATOR Iterator , PRTL_RANGE *  Range ) ;
#line 3086
__declspec(dllimport) NTSTATUS __stdcall
	RtlGetNextRange(PRTL_RANGE_LIST_ITERATOR Iterator , PRTL_RANGE *  Range
	, BOOLEAN MoveForwards ) ;
#line 3097
__declspec(dllimport) NTSTATUS __stdcall RtlMergeRangeLists(PRTL_RANGE_LIST
	MergedRangeList , PRTL_RANGE_LIST RangeList1 , PRTL_RANGE_LIST
	RangeList2 , ULONG Flags ) ;
#line 3107
__declspec(dllimport) NTSTATUS __stdcall RtlInvertRangeList(PRTL_RANGE_LIST
	InvertedRangeList , PRTL_RANGE_LIST RangeList ) ;
#line 3124
USHORT _fastcall RtlUshortByteSwap(USHORT Source ) ;
#line 3130
ULONG _fastcall RtlUlongByteSwap(ULONG Source ) ;
#line 3136
ULONGLONG _fastcall RtlUlonglongByteSwap(ULONGLONG Source ) ;
#line 3147
__declspec(dllimport) NTSTATUS __stdcall RtlVolumeDeviceToDosName(PVOID
	VolumeDeviceObject , PUNICODE_STRING DosName ) ;

#line 3155
typedef struct _OSVERSIONINFOA {
	ULONG dwOSVersionInfoSize ;
	ULONG dwMajorVersion ;
	ULONG dwMinorVersion ;
	ULONG dwBuildNumber ;
	ULONG dwPlatformId ;
	CHAR szCSDVersion[128] ;
} OSVERSIONINFOA , *  POSVERSIONINFOA , *  LPOSVERSIONINFOA ;

typedef struct _OSVERSIONINFOW {
	ULONG dwOSVersionInfoSize ;
	ULONG dwMajorVersion ;
	ULONG dwMinorVersion ;
	ULONG dwBuildNumber ;
	ULONG dwPlatformId ;
	WCHAR szCSDVersion[128] ;
} OSVERSIONINFOW , *  POSVERSIONINFOW , *  LPOSVERSIONINFOW , RTL_OSVERSIONINFOW
	, *  PRTL_OSVERSIONINFOW ;

#line 3177
typedef OSVERSIONINFOA OSVERSIONINFO ;

#line 3178
typedef POSVERSIONINFOA POSVERSIONINFO ;

#line 3179
typedef LPOSVERSIONINFOA LPOSVERSIONINFO ;

#line 3182
typedef struct _OSVERSIONINFOEXA {
	ULONG dwOSVersionInfoSize ;
	ULONG dwMajorVersion ;
	ULONG dwMinorVersion ;
	ULONG dwBuildNumber ;
	ULONG dwPlatformId ;
	CHAR szCSDVersion[128] ;
	USHORT wServicePackMajor ;
	USHORT wServicePackMinor ;
	USHORT wSuiteMask ;
	UCHAR wProductType ;
	UCHAR wReserved ;
} OSVERSIONINFOEXA , *  POSVERSIONINFOEXA , *  LPOSVERSIONINFOEXA ;

#line 3195
typedef struct _OSVERSIONINFOEXW {
	ULONG dwOSVersionInfoSize ;
	ULONG dwMajorVersion ;
	ULONG dwMinorVersion ;
	ULONG dwBuildNumber ;
	ULONG dwPlatformId ;
	WCHAR szCSDVersion[128] ;
	USHORT wServicePackMajor ;
	USHORT wServicePackMinor ;
	USHORT wSuiteMask ;
	UCHAR wProductType ;
	UCHAR wReserved ;
} OSVERSIONINFOEXW , *  POSVERSIONINFOEXW , *  LPOSVERSIONINFOEXW ,
	RTL_OSVERSIONINFOEXW , *  PRTL_OSVERSIONINFOEXW ;

#line 3213
typedef OSVERSIONINFOEXA OSVERSIONINFOEX ;

#line 3214
typedef POSVERSIONINFOEXA POSVERSIONINFOEX ;

#line 3215
typedef LPOSVERSIONINFOEXA LPOSVERSIONINFOEX ;

#line 3275
ULONGLONG __stdcall VerSetConditionMask(ULONGLONG ConditionMask , ULONG TypeMask
	, UCHAR Condition ) ;
#line 3286
__declspec(dllimport) NTSTATUS RtlGetVersion(PRTL_OSVERSIONINFOW
	lpVersionInformation ) ;
#line 3292
__declspec(dllimport) NTSTATUS RtlVerifyVersionInfo(PRTL_OSVERSIONINFOEXW
	VersionInfo , ULONG TypeMask , ULONGLONG ConditionMask ) ;

#line 3648
typedef struct _IO_STATUS_BLOCK {
	union  {
		NTSTATUS Status ;
		PVOID Pointer ;
	}  ;
	ULONG_PTR Information ;
} IO_STATUS_BLOCK , *  PIO_STATUS_BLOCK ;

#line 3669
typedef void (__stdcall *  PIO_APC_ROUTINE )(PVOID ApcContext , PIO_STATUS_BLOCK
	IoStatusBlock , ULONG Reserved ) ;

#line 3685
typedef enum _FILE_INFORMATION_CLASS {
	FileDirectoryInformation = 1,
	FileFullDirectoryInformation,
	FileBothDirectoryInformation,
	FileBasicInformation,
	FileStandardInformation,
	FileInternalInformation,
	FileEaInformation,
	FileAccessInformation,
	FileNameInformation,
	FileRenameInformation,
	FileLinkInformation,
	FileNamesInformation,
	FileDispositionInformation,
	FilePositionInformation,
	FileFullEaInformation,
	FileModeInformation,
	FileAlignmentInformation,
	FileAllInformation,
	FileAllocationInformation,
	FileEndOfFileInformation,
	FileAlternateNameInformation,
	FileStreamInformation,
	FilePipeInformation,
	FilePipeLocalInformation,
	FilePipeRemoteInformation,
	FileMailslotQueryInformation,
	FileMailslotSetInformation,
	FileCompressionInformation,
	FileObjectIdInformation,
	FileCompletionInformation,
	FileMoveClusterInformation,
	FileQuotaInformation,
	FileReparsePointInformation,
	FileNetworkOpenInformation,
	FileAttributeTagInformation,
	FileTrackingInformation,
	FileMaximumInformation
} FILE_INFORMATION_CLASS , *  PFILE_INFORMATION_CLASS ;

#line 3731
typedef struct _FILE_BASIC_INFORMATION {
	LARGE_INTEGER CreationTime ;
	LARGE_INTEGER LastAccessTime ;
	LARGE_INTEGER LastWriteTime ;
	LARGE_INTEGER ChangeTime ;
	ULONG FileAttributes ;
} FILE_BASIC_INFORMATION , *  PFILE_BASIC_INFORMATION ;

typedef struct _FILE_STANDARD_INFORMATION {
	LARGE_INTEGER AllocationSize ;
	LARGE_INTEGER EndOfFile ;
	ULONG NumberOfLinks ;
	BOOLEAN DeletePending ;
	BOOLEAN Directory ;
} FILE_STANDARD_INFORMATION , *  PFILE_STANDARD_INFORMATION ;

typedef struct _FILE_POSITION_INFORMATION {
	LARGE_INTEGER CurrentByteOffset ;
} FILE_POSITION_INFORMATION , *  PFILE_POSITION_INFORMATION ;

typedef struct _FILE_ALIGNMENT_INFORMATION {
	ULONG AlignmentRequirement ;
} FILE_ALIGNMENT_INFORMATION , *  PFILE_ALIGNMENT_INFORMATION ;

typedef struct _FILE_NAME_INFORMATION {
	ULONG FileNameLength ;
	WCHAR FileName[1] ;
} FILE_NAME_INFORMATION , *  PFILE_NAME_INFORMATION ;

typedef struct _FILE_NETWORK_OPEN_INFORMATION {
	LARGE_INTEGER CreationTime ;
	LARGE_INTEGER LastAccessTime ;
	LARGE_INTEGER LastWriteTime ;
	LARGE_INTEGER ChangeTime ;
	LARGE_INTEGER AllocationSize ;
	LARGE_INTEGER EndOfFile ;
	ULONG FileAttributes ;
} FILE_NETWORK_OPEN_INFORMATION , *  PFILE_NETWORK_OPEN_INFORMATION ;

typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION {
	ULONG FileAttributes ;
	ULONG ReparseTag ;
} FILE_ATTRIBUTE_TAG_INFORMATION , *  PFILE_ATTRIBUTE_TAG_INFORMATION ;

typedef struct _FILE_DISPOSITION_INFORMATION {
	BOOLEAN DeleteFile ;
} FILE_DISPOSITION_INFORMATION , *  PFILE_DISPOSITION_INFORMATION ;

typedef struct _FILE_END_OF_FILE_INFORMATION {
	LARGE_INTEGER EndOfFile ;
} FILE_END_OF_FILE_INFORMATION , *  PFILE_END_OF_FILE_INFORMATION ;

#line 3784
typedef struct _FILE_FULL_EA_INFORMATION {
	ULONG NextEntryOffset ;
	UCHAR Flags ;
	UCHAR EaNameLength ;
	USHORT EaValueLength ;
	CHAR EaName[1] ;
} FILE_FULL_EA_INFORMATION , *  PFILE_FULL_EA_INFORMATION ;

#line 3798
typedef enum _FSINFOCLASS {
	FileFsVolumeInformation = 1,
	FileFsLabelInformation,
	FileFsSizeInformation,
	FileFsDeviceInformation,
	FileFsAttributeInformation,
	FileFsControlInformation,
	FileFsFullSizeInformation,
	FileFsObjectIdInformation,
	FileFsMaximumInformation
} FS_INFORMATION_CLASS , *  PFS_INFORMATION_CLASS ;

typedef struct _FILE_FS_DEVICE_INFORMATION {
	ULONG DeviceType ;
	ULONG Characteristics ;
} FILE_FS_DEVICE_INFORMATION , *  PFILE_FS_DEVICE_INFORMATION ;

#line 3820
typedef union _FILE_SEGMENT_ELEMENT {
	PVOID64 Buffer ;
	ULONGLONG Alignment ;
} FILE_SEGMENT_ELEMENT , *  PFILE_SEGMENT_ELEMENT ;

#line 3829
typedef enum _INTERFACE_TYPE {
	InterfaceTypeUndefined = - 1,
	Internal,
	Isa,
	Eisa,
	MicroChannel,
	TurboChannel,
	PCIBus,
	VMEBus,
	NuBus,
	PCMCIABus,
	CBus,
	MPIBus,
	MPSABus,
	ProcessorInternal,
	InternalPowerBus,
	PNPISABus,
	PNPBus,
	MaximumInterfaceType
} INTERFACE_TYPE , *  PINTERFACE_TYPE ;

#line 3854
typedef enum _DMA_WIDTH {
	Width8Bits,
	Width16Bits,
	Width32Bits,
	MaximumDmaWidth
} DMA_WIDTH , *  PDMA_WIDTH ;

#line 3865
typedef enum _DMA_SPEED {
	Compatible,
	TypeA,
	TypeB,
	TypeC,
	TypeF,
	MaximumDmaSpeed
} DMA_SPEED , *  PDMA_SPEED ;

#line 3879
typedef void ( *  PINTERFACE_REFERENCE )(PVOID Context ) ;

#line 3880
typedef void ( *  PINTERFACE_DEREFERENCE )(PVOID Context ) ;

#line 3888
typedef enum _BUS_DATA_TYPE {
	ConfigurationSpaceUndefined = - 1,
	Cmos,
	EisaConfiguration,
	Pos,
	CbusConfiguration,
	PCIConfiguration,
	VMEConfiguration,
	NuBusConfiguration,
	PCMCIAConfiguration,
	MPIConfiguration,
	MPSAConfiguration,
	PNPISAConfiguration,
	SgiInternalConfiguration,
	MaximumBusDataType
} BUS_DATA_TYPE , *  PBUS_DATA_TYPE ;

#line 3910
typedef struct _IO_ERROR_LOG_PACKET {
	UCHAR MajorFunctionCode ;
	UCHAR RetryCount ;
	USHORT DumpDataSize ;
	USHORT NumberOfStrings ;
	USHORT StringOffset ;
	USHORT EventCategory ;
	NTSTATUS ErrorCode ;
	ULONG UniqueErrorValue ;
	NTSTATUS FinalStatus ;
	ULONG SequenceNumber ;
	ULONG IoControlCode ;
	LARGE_INTEGER DeviceOffset ;
	ULONG DumpData[1] ;
} IO_ERROR_LOG_PACKET , *  PIO_ERROR_LOG_PACKET ;

#line 3931
typedef struct _IO_ERROR_LOG_MESSAGE {
	USHORT Type ;
	USHORT Size ;
	USHORT DriverNameLength ;
	LARGE_INTEGER TimeStamp ;
	ULONG DriverNameOffset ;
	IO_ERROR_LOG_PACKET EntryData ;
} IO_ERROR_LOG_MESSAGE , *  PIO_ERROR_LOG_MESSAGE ;

#line 4074
typedef struct _KEY_BASIC_INFORMATION {
	LARGE_INTEGER LastWriteTime ;
	ULONG TitleIndex ;
	ULONG NameLength ;
	WCHAR Name[1] ;
} KEY_BASIC_INFORMATION , *  PKEY_BASIC_INFORMATION ;

typedef struct _KEY_NODE_INFORMATION {
	LARGE_INTEGER LastWriteTime ;
	ULONG TitleIndex ;
	ULONG ClassOffset ;
	ULONG ClassLength ;
	ULONG NameLength ;
	WCHAR Name[1] ;
} KEY_NODE_INFORMATION , *  PKEY_NODE_INFORMATION ;

#line 4091
typedef struct _KEY_FULL_INFORMATION {
	LARGE_INTEGER LastWriteTime ;
	ULONG TitleIndex ;
	ULONG ClassOffset ;
	ULONG ClassLength ;
	ULONG SubKeys ;
	ULONG MaxNameLen ;
	ULONG MaxClassLen ;
	ULONG Values ;
	ULONG MaxValueNameLen ;
	ULONG MaxValueDataLen ;
	WCHAR Class[1] ;
} KEY_FULL_INFORMATION , *  PKEY_FULL_INFORMATION ;

#line 4106
typedef struct _KEY_NAME_INFORMATION {
	ULONG NameLength ;
	WCHAR Name[1] ;
} KEY_NAME_INFORMATION , *  PKEY_NAME_INFORMATION ;

#line 4112
typedef enum _KEY_INFORMATION_CLASS {
	KeyBasicInformation,
	KeyNodeInformation,
	KeyFullInformation,
	KeyNameInformation
} KEY_INFORMATION_CLASS ;

#line 4122
typedef struct _KEY_WRITE_TIME_INFORMATION {
	LARGE_INTEGER LastWriteTime ;
} KEY_WRITE_TIME_INFORMATION , *  PKEY_WRITE_TIME_INFORMATION ;

typedef enum _KEY_SET_INFORMATION_CLASS {
	KeyWriteTimeInformation
} KEY_SET_INFORMATION_CLASS ;

#line 4134
typedef struct _KEY_VALUE_BASIC_INFORMATION {
	ULONG TitleIndex ;
	ULONG Type ;
	ULONG NameLength ;
	WCHAR Name[1] ;
} KEY_VALUE_BASIC_INFORMATION , *  PKEY_VALUE_BASIC_INFORMATION ;

typedef struct _KEY_VALUE_FULL_INFORMATION {
	ULONG TitleIndex ;
	ULONG Type ;
	ULONG DataOffset ;
	ULONG DataLength ;
	ULONG NameLength ;
	WCHAR Name[1] ;
} KEY_VALUE_FULL_INFORMATION , *  PKEY_VALUE_FULL_INFORMATION ;

#line 4151
typedef struct _KEY_VALUE_PARTIAL_INFORMATION {
	ULONG TitleIndex ;
	ULONG Type ;
	ULONG DataLength ;
	UCHAR Data[1] ;
} KEY_VALUE_PARTIAL_INFORMATION , *  PKEY_VALUE_PARTIAL_INFORMATION ;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 {
	ULONG Type ;
	ULONG DataLength ;
	UCHAR Data[1] ;
} KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 , * 
	PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ;

#line 4164
typedef struct _KEY_VALUE_ENTRY {
	PUNICODE_STRING ValueName ;
	ULONG DataLength ;
	ULONG DataOffset ;
	ULONG Type ;
} KEY_VALUE_ENTRY , *  PKEY_VALUE_ENTRY ;

typedef enum _KEY_VALUE_INFORMATION_CLASS {
	KeyValueBasicInformation,
	KeyValueFullInformation,
	KeyValuePartialInformation,
	KeyValueFullInformationAlign64,
	KeyValuePartialInformationAlign64
} KEY_VALUE_INFORMATION_CLASS ;

#line 4210
typedef struct _OBJECT_NAME_INFORMATION {
	UNICODE_STRING Name ;
} OBJECT_NAME_INFORMATION , *  POBJECT_NAME_INFORMATION ;

#line 4221
typedef enum _SECTION_INHERIT {
	ViewShare = 1,
	ViewUnmap = 2
} SECTION_INHERIT ;

#line 4294
typedef struct _CLIENT_ID {
	HANDLE UniqueProcess ;
	HANDLE UniqueThread ;
} CLIENT_ID ;

#line 4298
typedef CLIENT_ID *  PCLIENT_ID ;

#line 4315
typedef struct _NT_TIB {
	struct _EXCEPTION_REGISTRATION_RECORD *  ExceptionList ;
	PVOID StackBase ;
	PVOID StackLimit ;
	PVOID SubSystemTib ;
	union  {
		PVOID FiberData ;
		ULONG Version ;
	}  ;
	PVOID ArbitraryUserPointer ;
	struct _NT_TIB *  Self ;
} NT_TIB ;

#line 4327
typedef NT_TIB *  PNT_TIB ;

#line 4332
typedef enum _PROCESSINFOCLASS {
	ProcessBasicInformation,
	ProcessQuotaLimits,
	ProcessIoCounters,
	ProcessVmCounters,
	ProcessTimes,
	ProcessBasePriority,
	ProcessRaisePriority,
	ProcessDebugPort,
	ProcessExceptionPort,
	ProcessAccessToken,
	ProcessLdtInformation,
	ProcessLdtSize,
	ProcessDefaultHardErrorMode,
	ProcessIoPortHandlers,
	ProcessPooledUsageAndLimits,
	ProcessWorkingSetWatch,
	ProcessUserModeIOPL,
	ProcessEnableAlignmentFaultFixup,
	ProcessPriorityClass,
	ProcessWx86Information,
	ProcessHandleCount,
	ProcessAffinityMask,
	ProcessPriorityBoost,
	ProcessDeviceMap,
	ProcessSessionInformation,
	ProcessForegroundInformation,
	ProcessWow64Information,
	MaxProcessInfoClass
} PROCESSINFOCLASS ;

#line 4366
typedef enum _THREADINFOCLASS {
	ThreadBasicInformation,
	ThreadTimes,
	ThreadPriority,
	ThreadBasePriority,
	ThreadAffinityMask,
	ThreadImpersonationToken,
	ThreadDescriptorTableEntry,
	ThreadEnableAlignmentFaultFixup,
	ThreadEventPair_Reusable,
	ThreadQuerySetWin32StartAddress,
	ThreadZeroTlsCell,
	ThreadPerformanceCount,
	ThreadAmILastThread,
	ThreadIdealProcessor,
	ThreadPriorityBoost,
	ThreadSetTlsArrayAddress,
	ThreadIsIoPending,
	ThreadHideFromDebugger,
	MaxThreadInfoClass
} THREADINFOCLASS ;

#line 4395
typedef struct _PROCESS_WS_WATCH_INFORMATION {
	PVOID FaultingPc ;
	PVOID FaultingVa ;
} PROCESS_WS_WATCH_INFORMATION , *  PPROCESS_WS_WATCH_INFORMATION ;

#line 4405
typedef struct _PROCESS_BASIC_INFORMATION {
	NTSTATUS ExitStatus ;
	PPEB PebBaseAddress ;
	ULONG_PTR AffinityMask ;
	KPRIORITY BasePriority ;
	ULONG_PTR UniqueProcessId ;
	ULONG_PTR InheritedFromUniqueProcessId ;
} PROCESS_BASIC_INFORMATION ;

#line 4413
typedef PROCESS_BASIC_INFORMATION *  PPROCESS_BASIC_INFORMATION ;

#line 4422
typedef struct _PROCESS_DEVICEMAP_INFORMATION {
	union  {
		struct  {
			HANDLE DirectoryHandle ;
		} Set ;
		struct  {
			ULONG DriveMap ;
			UCHAR DriveType[32] ;
		} Query ;
	}  ;
} PROCESS_DEVICEMAP_INFORMATION , *  PPROCESS_DEVICEMAP_INFORMATION ;

#line 4440
typedef struct _PROCESS_SESSION_INFORMATION {
	ULONG SessionId ;
} PROCESS_SESSION_INFORMATION , *  PPROCESS_SESSION_INFORMATION ;

#line 4454
typedef struct _QUOTA_LIMITS {
	SIZE_T PagedPoolLimit ;
	SIZE_T NonPagedPoolLimit ;
	SIZE_T MinimumWorkingSetSize ;
	SIZE_T MaximumWorkingSetSize ;
	SIZE_T PagefileLimit ;
	LARGE_INTEGER TimeLimit ;
} QUOTA_LIMITS ;

#line 4462
typedef QUOTA_LIMITS *  PQUOTA_LIMITS ;

#line 4472
typedef struct _IO_COUNTERS {
	ULONGLONG ReadOperationCount ;
	ULONGLONG WriteOperationCount ;
	ULONGLONG OtherOperationCount ;
	ULONGLONG ReadTransferCount ;
	ULONGLONG WriteTransferCount ;
	ULONGLONG OtherTransferCount ;
} IO_COUNTERS ;

#line 4480
typedef IO_COUNTERS *  PIO_COUNTERS ;

#line 4488
typedef struct _VM_COUNTERS {
	SIZE_T PeakVirtualSize ;
	SIZE_T VirtualSize ;
	ULONG PageFaultCount ;
	SIZE_T PeakWorkingSetSize ;
	SIZE_T WorkingSetSize ;
	SIZE_T QuotaPeakPagedPoolUsage ;
	SIZE_T QuotaPagedPoolUsage ;
	SIZE_T QuotaPeakNonPagedPoolUsage ;
	SIZE_T QuotaNonPagedPoolUsage ;
	SIZE_T PagefileUsage ;
	SIZE_T PeakPagefileUsage ;
} VM_COUNTERS ;

#line 4501
typedef VM_COUNTERS *  PVM_COUNTERS ;

#line 4508
typedef struct _POOLED_USAGE_AND_LIMITS {
	SIZE_T PeakPagedPoolUsage ;
	SIZE_T PagedPoolUsage ;
	SIZE_T PagedPoolLimit ;
	SIZE_T PeakNonPagedPoolUsage ;
	SIZE_T NonPagedPoolUsage ;
	SIZE_T NonPagedPoolLimit ;
	SIZE_T PeakPagefileUsage ;
	SIZE_T PagefileUsage ;
	SIZE_T PagefileLimit ;
} POOLED_USAGE_AND_LIMITS ;

#line 4519
typedef POOLED_USAGE_AND_LIMITS *  PPOOLED_USAGE_AND_LIMITS ;

#line 4528
typedef struct _PROCESS_ACCESS_TOKEN {
	HANDLE Token ;
	HANDLE Thread ;
} PROCESS_ACCESS_TOKEN , *  PPROCESS_ACCESS_TOKEN ;

#line 4555
typedef struct _KERNEL_USER_TIMES {
	LARGE_INTEGER CreateTime ;
	LARGE_INTEGER ExitTime ;
	LARGE_INTEGER KernelTime ;
	LARGE_INTEGER UserTime ;
} KERNEL_USER_TIMES ;

#line 4561
typedef KERNEL_USER_TIMES *  PKERNEL_USER_TIMES ;

#line 4562
__declspec(dllimport) NTSTATUS __stdcall NtOpenProcess(PHANDLE ProcessHandle ,
	ACCESS_MASK DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes ,
	PCLIENT_ID ClientId ) ;
#line 4572
__declspec(dllimport) NTSTATUS __stdcall NtQueryInformationProcess(HANDLE
	ProcessHandle , PROCESSINFOCLASS ProcessInformationClass , PVOID
	ProcessInformation , ULONG ProcessInformationLength , PULONG
	ReturnLength ) ;

#line 4587
typedef enum _SYSTEM_POWER_STATE {
	PowerSystemUnspecified = 0,
	PowerSystemWorking,
	PowerSystemSleeping1,
	PowerSystemSleeping2,
	PowerSystemSleeping3,
	PowerSystemHibernate,
	PowerSystemShutdown,
	PowerSystemMaximum
} SYSTEM_POWER_STATE , *  PSYSTEM_POWER_STATE ;

typedef enum  {
	PowerActionNone = 0,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
} POWER_ACTION , *  PPOWER_ACTION ;

typedef enum _DEVICE_POWER_STATE {
	PowerDeviceUnspecified = 0,
	PowerDeviceD0,
	PowerDeviceD1,
	PowerDeviceD2,
	PowerDeviceD3,
	PowerDeviceMaximum
} DEVICE_POWER_STATE , *  PDEVICE_POWER_STATE ;

typedef union _POWER_STATE {
	SYSTEM_POWER_STATE SystemState ;
	DEVICE_POWER_STATE DeviceState ;
} POWER_STATE , *  PPOWER_STATE ;

typedef enum _POWER_STATE_TYPE {
	SystemPowerState = 0,
	DevicePowerState
} POWER_STATE_TYPE , *  PPOWER_STATE_TYPE ;

#line 4654
typedef ULONG EXECUTION_STATE ;

typedef enum  {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
} LATENCY_TIME ;

#line 4663
typedef enum  {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation
} POWER_INFORMATION_LEVEL ;

#line 4690
typedef ULONG PFN_COUNT ;

typedef LONG SPFN_NUMBER , *  PSPFN_NUMBER ;

#line 4693
typedef ULONG PFN_NUMBER , *  PPFN_NUMBER ;

#line 4719
typedef union _MCI_STATS {
	struct  {
		USHORT McaCod ;
		USHORT MsCod ;
		ULONG OtherInfo  : 25;
		ULONG Damage  : 1;
		ULONG AddressValid  : 1;
		ULONG MiscValid  : 1;
		ULONG Enabled  : 1;
		ULONG UnCorrected  : 1;
		ULONG OverFlow  : 1;
		ULONG Valid  : 1;
	} MciStats ;
	ULONGLONG QuadPart ;
} MCI_STATS , *  PMCI_STATS ;

#line 4768
__declspec(dllimport) UCHAR READ_REGISTER_UCHAR(PUCHAR Register ) ;
#line 4774
__declspec(dllimport) USHORT READ_REGISTER_USHORT(PUSHORT Register ) ;
#line 4780
__declspec(dllimport) ULONG READ_REGISTER_ULONG(PULONG Register ) ;
#line 4786
__declspec(dllimport) void READ_REGISTER_BUFFER_UCHAR(PUCHAR Register , PUCHAR
	Buffer , ULONG Count ) ;
#line 4794
__declspec(dllimport) void READ_REGISTER_BUFFER_USHORT(PUSHORT Register ,
	PUSHORT Buffer , ULONG Count ) ;
#line 4802
__declspec(dllimport) void READ_REGISTER_BUFFER_ULONG(PULONG Register , PULONG
	Buffer , ULONG Count ) ;
#line 4811
__declspec(dllimport) void WRITE_REGISTER_UCHAR(PUCHAR Register , UCHAR Value )
	;
#line 4818
__declspec(dllimport) void WRITE_REGISTER_USHORT(PUSHORT Register , USHORT Value
	) ;
#line 4825
__declspec(dllimport) void WRITE_REGISTER_ULONG(PULONG Register , ULONG Value )
	;
#line 4832
__declspec(dllimport) void WRITE_REGISTER_BUFFER_UCHAR(PUCHAR Register , PUCHAR
	Buffer , ULONG Count ) ;
#line 4840
__declspec(dllimport) void WRITE_REGISTER_BUFFER_USHORT(PUSHORT Register ,
	PUSHORT Buffer , ULONG Count ) ;
#line 4848
__declspec(dllimport) void WRITE_REGISTER_BUFFER_ULONG(PULONG Register , PULONG
	Buffer , ULONG Count ) ;
#line 4856
__declspec(dllimport) UCHAR READ_PORT_UCHAR(PUCHAR Port ) ;
#line 4862
__declspec(dllimport) USHORT READ_PORT_USHORT(PUSHORT Port ) ;
#line 4868
__declspec(dllimport) ULONG READ_PORT_ULONG(PULONG Port ) ;
#line 4874
__declspec(dllimport) void READ_PORT_BUFFER_UCHAR(PUCHAR Port , PUCHAR Buffer ,
	ULONG Count ) ;
#line 4882
__declspec(dllimport) void READ_PORT_BUFFER_USHORT(PUSHORT Port , PUSHORT Buffer
	, ULONG Count ) ;
#line 4890
__declspec(dllimport) void READ_PORT_BUFFER_ULONG(PULONG Port , PULONG Buffer ,
	ULONG Count ) ;
#line 4898
__declspec(dllimport) void WRITE_PORT_UCHAR(PUCHAR Port , UCHAR Value ) ;
#line 4905
__declspec(dllimport) void WRITE_PORT_USHORT(PUSHORT Port , USHORT Value ) ;
#line 4912
__declspec(dllimport) void WRITE_PORT_ULONG(PULONG Port , ULONG Value ) ;
#line 4919
__declspec(dllimport) void WRITE_PORT_BUFFER_UCHAR(PUCHAR Port , PUCHAR Buffer ,
	ULONG Count ) ;
#line 4927
__declspec(dllimport) void WRITE_PORT_BUFFER_USHORT(PUSHORT Port , PUSHORT
	Buffer , ULONG Count ) ;
#line 4935
__declspec(dllimport) void WRITE_PORT_BUFFER_ULONG(PULONG Port , PULONG Buffer ,
	ULONG Count ) ;

#line 4978
typedef struct _KPCR {
	NT_TIB NtTib ;
	struct _KPCR *  SelfPcr ;
	struct _KPRCB *  Prcb ;
	KIRQL Irql ;
	ULONG IRR ;
	ULONG IrrActive ;
	ULONG IDR ;
	ULONG Reserved2 ;
	struct _KIDTENTRY *  IDT ;
	struct _KGDTENTRY *  GDT ;
	struct _KTSS *  TSS ;
	USHORT MajorVersion ;
	USHORT MinorVersion ;
	KAFFINITY SetMember ;
	ULONG StallScaleFactor ;
	UCHAR DebugActive ;
	UCHAR Number ;
} KPCR ;

#line 5006
typedef KPCR *  PKPCR ;

#line 5012
typedef struct _KFLOATING_SAVE {
	ULONG ControlWord ;
	ULONG StatusWord ;
	ULONG ErrorOffset ;
	ULONG ErrorSelector ;
	ULONG DataOffset ;
	ULONG DataSelector ;
	ULONG Cr0NpxState ;
	ULONG Spare1 ;
} KFLOATING_SAVE , *  PKFLOATING_SAVE ;

#line 5069
extern PVOID *  MmHighestUserAddress ;
extern PVOID *  MmSystemRangeStart ;
extern ULONG *  MmUserProbeAddress ;

#line 5153
typedef enum _INTERLOCKED_RESULT {
	ResultNegative = 0x8000 & ~ 0x4000 & (0x8000 | 0x4000),
	ResultZero = ~ 0x8000 & 0x4000 & (0x8000 | 0x4000),
	ResultPositive = ~ 0x8000 & ~ 0x4000 & (0x8000 | 0x4000)
} INTERLOCKED_RESULT ;

__declspec(dllimport) INTERLOCKED_RESULT _fastcall
	Exfi386InterlockedIncrementLong(PLONG Addend ) ;
#line 5166
__declspec(dllimport) INTERLOCKED_RESULT _fastcall
	Exfi386InterlockedDecrementLong(PLONG Addend ) ;
#line 5173
__declspec(dllimport) LARGE_INTEGER
	ExInterlockedExchangeAddLargeInteger(PLARGE_INTEGER Addend ,
	LARGE_INTEGER Increment , PKSPIN_LOCK Lock ) ;
#line 5181
__declspec(dllimport) ULONG _fastcall Exfi386InterlockedExchangeUlong(PULONG
	Target , ULONG Value ) ;
#line 5197
__declspec(dllimport) LONG _fastcall InterlockedIncrement(PLONG Addend ) ;
#line 5204
__declspec(dllimport) LONG _fastcall InterlockedDecrement(PLONG Addend ) ;
#line 5211
__declspec(dllimport) LONG _fastcall InterlockedExchange(PLONG Target , LONG
	Value ) ;
#line 5222
LONG _fastcall InterlockedExchangeAdd(PLONG Addend , LONG Increment ) ;
#line 5229
__declspec(dllimport) LONG _fastcall InterlockedCompareExchange(PLONG
	Destination , LONG ExChange , LONG Comperand ) ;

#line 5252

#pragma warning(disable:4035)
#line 5262
__declspec(dllimport) KIRQL KeGetCurrentIrql() ;

#line 5271
__inline ULONG KeGetCurrentProcessorNumber(void  )
{
	__asm {  movzx eax, fs:[0] KPCR.Number  };
}

#line 5280
__declspec(dllimport) NTSTATUS __stdcall
	KeSaveFloatingPointState(PKFLOATING_SAVE FloatSave ) ;
#line 5287
__declspec(dllimport) NTSTATUS __stdcall
	KeRestoreFloatingPointState(PKFLOATING_SAVE FloatSave ) ;

#line 6994
typedef struct _KSYSTEM_TIME {
	ULONG LowPart ;
	LONG High1Time ;
	LONG High2Time ;
} KSYSTEM_TIME , *  PKSYSTEM_TIME ;

#line 7014

#pragma warning(push)

#pragma warning(disable:4164)
#line 7019

#pragma function(_enable)
#line 7020

#pragma function(_disable)
#line 7024

#pragma warning(pop)
#line 7085
typedef struct _FLOATING_SAVE_AREA {
	ULONG ControlWord ;
	ULONG StatusWord ;
	ULONG TagWord ;
	ULONG ErrorOffset ;
	ULONG ErrorSelector ;
	ULONG DataOffset ;
	ULONG DataSelector ;
	UCHAR RegisterArea[80] ;
	ULONG Cr0NpxState ;
} FLOATING_SAVE_AREA ;

typedef FLOATING_SAVE_AREA *  PFLOATING_SAVE_AREA ;

#line 7109
typedef struct _CONTEXT {
	ULONG ContextFlags ;
	ULONG Dr0 ;
	ULONG Dr1 ;
	ULONG Dr2 ;
	ULONG Dr3 ;
	ULONG Dr6 ;
	ULONG Dr7 ;
	FLOATING_SAVE_AREA FloatSave ;
	ULONG SegGs ;
	ULONG SegFs ;
	ULONG SegEs ;
	ULONG SegDs ;
	ULONG Edi ;
	ULONG Esi ;
	ULONG Ebx ;
	ULONG Edx ;
	ULONG Ecx ;
	ULONG Eax ;
	ULONG Ebp ;
	ULONG Eip ;
	ULONG SegCs ;
	ULONG EFlags ;
	ULONG Esp ;
	ULONG SegSs ;
	UCHAR ExtendedRegisters[512] ;
} CONTEXT ;

#line 7197
typedef CONTEXT *  PCONTEXT ;

#line 7826
typedef void ( *  PTIMER_APC_ROUTINE )(PVOID TimerContext , ULONG TimerLowValue
	, LONG TimerHighValue ) ;

#line 7850
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE {
	StandardDesign,
	NEC98x86,
	EndAlternatives
} ALTERNATIVE_ARCHITECTURE_TYPE ;

#line 7899
typedef struct _KUSER_SHARED_DATA {
	volatile ULONG TickCountLow ;
	ULONG TickCountMultiplier ;
	volatile KSYSTEM_TIME InterruptTime ;
	volatile KSYSTEM_TIME SystemTime ;
	volatile KSYSTEM_TIME TimeZoneBias ;
	USHORT ImageNumberLow ;
	USHORT ImageNumberHigh ;
	WCHAR NtSystemRoot[260] ;
	ULONG MaxStackTraceDepth ;
	ULONG CryptoExponent ;
	ULONG TimeZoneId ;
	ULONG Reserved2[8] ;
	NT_PRODUCT_TYPE NtProductType ;
	BOOLEAN ProductTypeIsValid ;
	ULONG NtMajorVersion ;
	ULONG NtMinorVersion ;
	BOOLEAN ProcessorFeatures[64] ;
	ULONG Reserved1 ;
	ULONG Reserved3 ;
	volatile ULONG TimeSlip ;
	ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture ;
	LARGE_INTEGER SystemExpirationDate ;
	ULONG SuiteMask ;
	BOOLEAN KdDebuggerEnabled ;
} KUSER_SHARED_DATA , *  PKUSER_SHARED_DATA ;

#line 8123
typedef enum _CM_SERVICE_NODE_TYPE {
	DriverType = 0x00000001,
	FileSystemType = 0x00000002,
	Win32ServiceOwnProcess = 0x00000010,
	Win32ServiceShareProcess = 0x00000020,
	AdapterType = 0x00000004,
	RecognizerType = 0x00000008
} SERVICE_NODE_TYPE ;

typedef enum _CM_SERVICE_LOAD_TYPE {
	BootLoad = 0x00000000,
	SystemLoad = 0x00000001,
	AutoLoad = 0x00000002,
	DemandLoad = 0x00000003,
	DisableLoad = 0x00000004
} SERVICE_LOAD_TYPE ;

typedef enum _CM_ERROR_CONTROL_TYPE {
	IgnoreError = 0x00000000,
	NormalError = 0x00000001,
	SevereError = 0x00000002,
	CriticalError = 0x00000003
} SERVICE_ERROR_TYPE ;

#line 8172
typedef int CM_RESOURCE_TYPE ;

#line 8198
typedef enum _CM_SHARE_DISPOSITION {
	CmResourceShareUndetermined = 0,
	CmResourceShareDeviceExclusive,
	CmResourceShareDriverExclusive,
	CmResourceShareShared
} CM_SHARE_DISPOSITION ;

#line 8211
typedef PVOID PASSIGNED_RESOURCE ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
	UCHAR Type ;
	UCHAR ShareDisposition ;
	USHORT Flags ;
	union  {
		struct  {
			PHYSICAL_ADDRESS Start ;
			ULONG Length ;
		} Generic ;
		struct  {
			PHYSICAL_ADDRESS Start ;
			ULONG Length ;
		} Port ;
		struct  {
			ULONG Level ;
			ULONG Vector ;
			ULONG Affinity ;
		} Interrupt ;
		struct  {
			PHYSICAL_ADDRESS Start ;
			ULONG Length ;
		} Memory ;
		struct  {
			ULONG Channel ;
			ULONG Port ;
			ULONG Reserved1 ;
		} Dma ;
		struct  {
			ULONG Data[3] ;
		} DevicePrivate ;
		struct  {
			ULONG Start ;
			ULONG Length ;
			ULONG Reserved ;
		} BusNumber ;
		struct  {
			ULONG DataSize ;
			ULONG Reserved1 ;
			ULONG Reserved2 ;
		} DeviceSpecificData ;
	} u ;
} CM_PARTIAL_RESOURCE_DESCRIPTOR , *  PCM_PARTIAL_RESOURCE_DESCRIPTOR ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST {
	USHORT Version ;
	USHORT Revision ;
	ULONG Count ;
	CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1] ;
} CM_PARTIAL_RESOURCE_LIST , *  PCM_PARTIAL_RESOURCE_LIST ;

#line 8443
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR {
	INTERFACE_TYPE InterfaceType ;
	ULONG BusNumber ;
	CM_PARTIAL_RESOURCE_LIST PartialResourceList ;
} CM_FULL_RESOURCE_DESCRIPTOR , *  PCM_FULL_RESOURCE_DESCRIPTOR ;

#line 8454
typedef struct _CM_RESOURCE_LIST {
	ULONG Count ;
	CM_FULL_RESOURCE_DESCRIPTOR List[1] ;
} CM_RESOURCE_LIST , *  PCM_RESOURCE_LIST ;

#line 8471
typedef struct _DEVICE_FLAGS {
	ULONG Failed  : 1;
	ULONG ReadOnly  : 1;
	ULONG Removable  : 1;
	ULONG ConsoleIn  : 1;
	ULONG ConsoleOut  : 1;
	ULONG Input  : 1;
	ULONG Output  : 1;
} DEVICE_FLAGS , *  PDEVICE_FLAGS ;

#line 8485
typedef struct _CM_COMPONENT_INFORMATION {
	DEVICE_FLAGS Flags ;
	ULONG Version ;
	ULONG Key ;
	ULONG AffinityMask ;
} CM_COMPONENT_INFORMATION , *  PCM_COMPONENT_INFORMATION ;

#line 8503
typedef struct _CM_ROM_BLOCK {
	ULONG Address ;
	ULONG Size ;
} CM_ROM_BLOCK , *  PCM_ROM_BLOCK ;

#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 8518 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_INT13_DRIVE_PARAMETER {
	USHORT DriveSelect ;
	ULONG MaxCylinders ;
	USHORT SectorsPerTrack ;
	USHORT MaxHeads ;
	USHORT NumberDrives ;
} CM_INT13_DRIVE_PARAMETER , *  PCM_INT13_DRIVE_PARAMETER ;

#line 8532
typedef struct _CM_MCA_POS_DATA {
	USHORT AdapterId ;
	UCHAR PosData1 ;
	UCHAR PosData2 ;
	UCHAR PosData3 ;
	UCHAR PosData4 ;
} CM_MCA_POS_DATA , *  PCM_MCA_POS_DATA ;

#line 8544
typedef struct _EISA_MEMORY_TYPE {
	UCHAR ReadWrite  : 1;
	UCHAR Cached  : 1;
	UCHAR Reserved0  : 1;
	UCHAR Type  : 2;
	UCHAR Shared  : 1;
	UCHAR Reserved1  : 1;
	UCHAR MoreEntries  : 1;
} EISA_MEMORY_TYPE , *  PEISA_MEMORY_TYPE ;

typedef struct _EISA_MEMORY_CONFIGURATION {
	EISA_MEMORY_TYPE ConfigurationByte ;
	UCHAR DataSize ;
	USHORT AddressLowWord ;
	UCHAR AddressHighByte ;
	USHORT MemorySize ;
} EISA_MEMORY_CONFIGURATION , *  PEISA_MEMORY_CONFIGURATION ;

#line 8567
typedef struct _EISA_IRQ_DESCRIPTOR {
	UCHAR Interrupt  : 4;
	UCHAR Reserved  : 1;
	UCHAR LevelTriggered  : 1;
	UCHAR Shared  : 1;
	UCHAR MoreEntries  : 1;
} EISA_IRQ_DESCRIPTOR , *  PEISA_IRQ_DESCRIPTOR ;

typedef struct _EISA_IRQ_CONFIGURATION {
	EISA_IRQ_DESCRIPTOR ConfigurationByte ;
	UCHAR Reserved ;
} EISA_IRQ_CONFIGURATION , *  PEISA_IRQ_CONFIGURATION ;

#line 8585
typedef struct _DMA_CONFIGURATION_BYTE0 {
	UCHAR Channel  : 3;
	UCHAR Reserved  : 3;
	UCHAR Shared  : 1;
	UCHAR MoreEntries  : 1;
} DMA_CONFIGURATION_BYTE0 ;

typedef struct _DMA_CONFIGURATION_BYTE1 {
	UCHAR Reserved0  : 2;
	UCHAR TransferSize  : 2;
	UCHAR Timing  : 2;
	UCHAR Reserved1  : 2;
} DMA_CONFIGURATION_BYTE1 ;

typedef struct _EISA_DMA_CONFIGURATION {
	DMA_CONFIGURATION_BYTE0 ConfigurationByte0 ;
	DMA_CONFIGURATION_BYTE1 ConfigurationByte1 ;
} EISA_DMA_CONFIGURATION , *  PEISA_DMA_CONFIGURATION ;

#line 8609
typedef struct _EISA_PORT_DESCRIPTOR {
	UCHAR NumberPorts  : 5;
	UCHAR Reserved  : 1;
	UCHAR Shared  : 1;
	UCHAR MoreEntries  : 1;
} EISA_PORT_DESCRIPTOR , *  PEISA_PORT_DESCRIPTOR ;

typedef struct _EISA_PORT_CONFIGURATION {
	EISA_PORT_DESCRIPTOR Configuration ;
	USHORT PortAddress ;
} EISA_PORT_CONFIGURATION , *  PEISA_PORT_CONFIGURATION ;

#line 8628
typedef struct _CM_EISA_SLOT_INFORMATION {
	UCHAR ReturnCode ;
	UCHAR ReturnFlags ;
	UCHAR MajorRevision ;
	UCHAR MinorRevision ;
	USHORT Checksum ;
	UCHAR NumberFunctions ;
	UCHAR FunctionInformation ;
	ULONG CompressedId ;
} CM_EISA_SLOT_INFORMATION , *  PCM_EISA_SLOT_INFORMATION ;

#line 8644
typedef struct _CM_EISA_FUNCTION_INFORMATION {
	ULONG CompressedId ;
	UCHAR IdSlotFlags1 ;
	UCHAR IdSlotFlags2 ;
	UCHAR MinorRevision ;
	UCHAR MajorRevision ;
	UCHAR Selections[26] ;
	UCHAR FunctionFlags ;
	UCHAR TypeString[80] ;
	EISA_MEMORY_CONFIGURATION EisaMemory[9] ;
	EISA_IRQ_CONFIGURATION EisaIrq[7] ;
	EISA_DMA_CONFIGURATION EisaDma[4] ;
	EISA_PORT_CONFIGURATION EisaPort[20] ;
	UCHAR InitializationData[60] ;
} CM_EISA_FUNCTION_INFORMATION , *  PCM_EISA_FUNCTION_INFORMATION ;

#line 8678
typedef struct _CM_PNP_BIOS_DEVICE_NODE {
	USHORT Size ;
	UCHAR Node ;
	ULONG ProductId ;
	UCHAR DeviceType[3] ;
	USHORT DeviceAttributes ;
} CM_PNP_BIOS_DEVICE_NODE , *  PCM_PNP_BIOS_DEVICE_NODE ;

#line 8692
typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK {
	UCHAR Signature[4] ;
	UCHAR Revision ;
	UCHAR Length ;
	USHORT ControlField ;
	UCHAR Checksum ;
	ULONG EventFlagAddress ;
	USHORT RealModeEntryOffset ;
	USHORT RealModeEntrySegment ;
	USHORT ProtectedModeEntryOffset ;
	ULONG ProtectedModeCodeBaseAddress ;
	ULONG OemDeviceId ;
	USHORT RealModeDataBaseAddress ;
	ULONG ProtectedModeDataBaseAddress ;
} CM_PNP_BIOS_INSTALLATION_CHECK , *  PCM_PNP_BIOS_INSTALLATION_CHECK ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8761 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_SCSI_DEVICE_DATA {
	USHORT Version ;
	USHORT Revision ;
	UCHAR HostIdentifier ;
} CM_SCSI_DEVICE_DATA , *  PCM_SCSI_DEVICE_DATA ;

#line 8775
typedef struct _CM_VIDEO_DEVICE_DATA {
	USHORT Version ;
	USHORT Revision ;
	ULONG VideoClock ;
} CM_VIDEO_DEVICE_DATA , *  PCM_VIDEO_DEVICE_DATA ;

#line 8785
typedef struct _CM_SONIC_DEVICE_DATA {
	USHORT Version ;
	USHORT Revision ;
	USHORT DataConfigurationRegister ;
	UCHAR EthernetAddress[8] ;
} CM_SONIC_DEVICE_DATA , *  PCM_SONIC_DEVICE_DATA ;

#line 8796
typedef struct _CM_SERIAL_DEVICE_DATA {
	USHORT Version ;
	USHORT Revision ;
	ULONG BaudClock ;
} CM_SERIAL_DEVICE_DATA , *  PCM_SERIAL_DEVICE_DATA ;

#line 8810
typedef struct _CM_MONITOR_DEVICE_DATA {
	USHORT Version ;
	USHORT Revision ;
	USHORT HorizontalScreenSize ;
	USHORT VerticalScreenSize ;
	USHORT HorizontalResolution ;
	USHORT VerticalResolution ;
	USHORT HorizontalDisplayTimeLow ;
	USHORT HorizontalDisplayTime ;
	USHORT HorizontalDisplayTimeHigh ;
	USHORT HorizontalBackPorchLow ;
	USHORT HorizontalBackPorch ;
	USHORT HorizontalBackPorchHigh ;
	USHORT HorizontalFrontPorchLow ;
	USHORT HorizontalFrontPorch ;
	USHORT HorizontalFrontPorchHigh ;
	USHORT HorizontalSyncLow ;
	USHORT HorizontalSync ;
	USHORT HorizontalSyncHigh ;
	USHORT VerticalBackPorchLow ;
	USHORT VerticalBackPorch ;
	USHORT VerticalBackPorchHigh ;
	USHORT VerticalFrontPorchLow ;
	USHORT VerticalFrontPorch ;
	USHORT VerticalFrontPorchHigh ;
	USHORT VerticalSyncLow ;
	USHORT VerticalSync ;
	USHORT VerticalSyncHigh ;
} CM_MONITOR_DEVICE_DATA , *  PCM_MONITOR_DEVICE_DATA ;

#line 8844
typedef struct _CM_FLOPPY_DEVICE_DATA {
	USHORT Version ;
	USHORT Revision ;
	CHAR Size[8] ;
	ULONG MaxDensity ;
	ULONG MountDensity ;
	UCHAR StepRateHeadUnloadTime ;
	UCHAR HeadLoadTime ;
	UCHAR MotorOffTime ;
	UCHAR SectorLengthCode ;
	UCHAR SectorPerTrack ;
	UCHAR ReadWriteGapLength ;
	UCHAR DataTransferLength ;
	UCHAR FormatGapLength ;
	UCHAR FormatFillCharacter ;
	UCHAR HeadSettleTime ;
	UCHAR MotorSettleTime ;
	UCHAR MaximumTrackValue ;
	UCHAR DataTransferRate ;
} CM_FLOPPY_DEVICE_DATA , *  PCM_FLOPPY_DEVICE_DATA ;

#line 8881
typedef struct _CM_KEYBOARD_DEVICE_DATA {
	USHORT Version ;
	USHORT Revision ;
	UCHAR Type ;
	UCHAR Subtype ;
	USHORT KeyboardFlags ;
} CM_KEYBOARD_DEVICE_DATA , *  PCM_KEYBOARD_DEVICE_DATA ;

#line 8893
typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA {
	ULONG BytesPerSector ;
	ULONG NumberOfCylinders ;
	ULONG SectorsPerTrack ;
	ULONG NumberOfHeads ;
} CM_DISK_GEOMETRY_DEVICE_DATA , *  PCM_DISK_GEOMETRY_DEVICE_DATA ;

#line 8905
typedef struct _CM_PCCARD_DEVICE_DATA {
	UCHAR Flags ;
	UCHAR ErrorCode ;
	USHORT Reserved ;
	ULONG BusData ;
	ULONG DeviceId ;
	ULONG LegacyBaseAddress ;
	UCHAR IRQMap[16] ;
} CM_PCCARD_DEVICE_DATA , *  PCM_PCCARD_DEVICE_DATA ;

#line 8944
typedef struct _IO_RESOURCE_DESCRIPTOR {
	UCHAR Option ;
	UCHAR Type ;
	UCHAR ShareDisposition ;
	UCHAR Spare1 ;
	USHORT Flags ;
	USHORT Spare2 ;
	union  {
		struct  {
			ULONG Length ;
			ULONG Alignment ;
			PHYSICAL_ADDRESS MinimumAddress ;
			PHYSICAL_ADDRESS MaximumAddress ;
		} Port ;
		struct  {
			ULONG Length ;
			ULONG Alignment ;
			PHYSICAL_ADDRESS MinimumAddress ;
			PHYSICAL_ADDRESS MaximumAddress ;
		} Memory ;
		struct  {
			ULONG MinimumVector ;
			ULONG MaximumVector ;
		} Interrupt ;
		struct  {
			ULONG MinimumChannel ;
			ULONG MaximumChannel ;
		} Dma ;
		struct  {
			ULONG Length ;
			ULONG Alignment ;
			PHYSICAL_ADDRESS MinimumAddress ;
			PHYSICAL_ADDRESS MaximumAddress ;
		} Generic ;
		struct  {
			ULONG Data[3] ;
		} DevicePrivate ;
		struct  {
			ULONG Length ;
			ULONG MinBusNumber ;
			ULONG MaxBusNumber ;
			ULONG Reserved ;
		} BusNumber ;
		struct  {
			PASSIGNED_RESOURCE AssignedResource ;
		} AssignedResource ;
		struct  {
			UCHAR Type ;
			UCHAR Reserved[3] ;
			PASSIGNED_RESOURCE AssignedResource ;
			PHYSICAL_ADDRESS Transformation ;
		} SubAllocateFrom ;
		struct  {
			ULONG Priority ;
			ULONG Reserved1 ;
			ULONG Reserved2 ;
		} ConfigData ;
	} u ;
} IO_RESOURCE_DESCRIPTOR , *  PIO_RESOURCE_DESCRIPTOR ;

#line 9027
typedef struct _IO_RESOURCE_LIST {
	USHORT Version ;
	USHORT Revision ;
	ULONG Count ;
	IO_RESOURCE_DESCRIPTOR Descriptors[1] ;
} IO_RESOURCE_LIST , *  PIO_RESOURCE_LIST ;

#line 9036
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST {
	ULONG ListSize ;
	INTERFACE_TYPE InterfaceType ;
	ULONG BusNumber ;
	ULONG SlotNumber ;
	ULONG Reserved[3] ;
	ULONG AlternativeLists ;
	IO_RESOURCE_LIST List[1] ;
} IO_RESOURCE_REQUIREMENTS_LIST , *  PIO_RESOURCE_REQUIREMENTS_LIST ;

#line 9065
typedef struct _EXCEPTION_RECORD {
	NTSTATUS ExceptionCode ;
	ULONG ExceptionFlags ;
	struct _EXCEPTION_RECORD *  ExceptionRecord ;
	PVOID ExceptionAddress ;
	ULONG NumberParameters ;
	ULONG_PTR ExceptionInformation[15] ;
} EXCEPTION_RECORD ;

typedef EXCEPTION_RECORD *  PEXCEPTION_RECORD ;

typedef struct _EXCEPTION_RECORD32 {
	NTSTATUS ExceptionCode ;
	ULONG ExceptionFlags ;
	ULONG ExceptionRecord ;
	ULONG ExceptionAddress ;
	ULONG NumberParameters ;
	ULONG ExceptionInformation[15] ;
} EXCEPTION_RECORD32 , *  PEXCEPTION_RECORD32 ;

typedef struct _EXCEPTION_RECORD64 {
	NTSTATUS ExceptionCode ;
	ULONG ExceptionFlags ;
	ULONG64 ExceptionRecord ;
	ULONG64 ExceptionAddress ;
	ULONG NumberParameters ;
	ULONG __unusedAlignment ;
	ULONG64 ExceptionInformation[15] ;
} EXCEPTION_RECORD64 , *  PEXCEPTION_RECORD64 ;

#line 9099
typedef struct _EXCEPTION_POINTERS {
	PEXCEPTION_RECORD ExceptionRecord ;
	PCONTEXT ContextRecord ;
} EXCEPTION_POINTERS , *  PEXCEPTION_POINTERS ;

#line 9111
typedef enum _CONFIGURATION_TYPE {
	ArcSystem,
	CentralProcessor,
	FloatingPointProcessor,
	PrimaryIcache,
	PrimaryDcache,
	SecondaryIcache,
	SecondaryDcache,
	SecondaryCache,
	EisaAdapter,
	TcAdapter,
	ScsiAdapter,
	DtiAdapter,
	MultiFunctionAdapter,
	DiskController,
	TapeController,
	CdromController,
	WormController,
	SerialController,
	NetworkController,
	DisplayController,
	ParallelController,
	PointerController,
	KeyboardController,
	AudioController,
	OtherController,
	DiskPeripheral,
	FloppyDiskPeripheral,
	TapePeripheral,
	ModemPeripheral,
	MonitorPeripheral,
	PrinterPeripheral,
	PointerPeripheral,
	KeyboardPeripheral,
	TerminalPeripheral,
	OtherPeripheral,
	LinePeripheral,
	NetworkPeripheral,
	SystemMemory,
	DockingInformation,
	RealModeIrqRoutingTable,
	MaximumType
} CONFIGURATION_TYPE , *  PCONFIGURATION_TYPE ;

#line 9161
typedef enum _KINTERRUPT_MODE {
	LevelSensitive,
	Latched
} KINTERRUPT_MODE ;

#line 9170
typedef enum _KWAIT_REASON {
	Executive,
	FreePage,
	PageIn,
	PoolAllocation,
	DelayExecution,
	Suspended,
	UserRequest,
	WrExecutive,
	WrFreePage,
	WrPageIn,
	WrPoolAllocation,
	WrDelayExecution,
	WrSuspended,
	WrUserRequest,
	WrEventPair,
	WrQueue,
	WrLpcReceive,
	WrLpcReply,
	WrVirtualMemory,
	WrPageOut,
	WrRendezvous,
	Spare2,
	Spare3,
	Spare4,
	Spare5,
	Spare6,
	WrKernel,
	MaximumWaitReason
} KWAIT_REASON ;

#line 9207
typedef struct _DISPATCHER_HEADER {
	UCHAR Type ;
	UCHAR Absolute ;
	UCHAR Size ;
	UCHAR Inserted ;
	LONG SignalState ;
	LIST_ENTRY WaitListHead ;
} DISPATCHER_HEADER ;

#line 9217
typedef struct _KWAIT_BLOCK {
	LIST_ENTRY WaitListEntry ;
	struct _KTHREAD *  Thread ;
	PVOID Object ;
	struct _KWAIT_BLOCK *  NextWaitBlock ;
	USHORT WaitKey ;
	USHORT WaitType ;
} KWAIT_BLOCK , *  PKWAIT_BLOCK , *  PRKWAIT_BLOCK ;

#line 9230
typedef void ( *  PKSTART_ROUTINE )(PVOID StartContext ) ;

#line 9244
typedef struct _KDEVICE_QUEUE {
	CSHORT Type ;
	CSHORT Size ;
	LIST_ENTRY DeviceListHead ;
	KSPIN_LOCK Lock ;
	BOOLEAN Busy ;
} KDEVICE_QUEUE , *  PKDEVICE_QUEUE , *  PRKDEVICE_QUEUE ;

typedef struct _KDEVICE_QUEUE_ENTRY {
	LIST_ENTRY DeviceListEntry ;
	ULONG SortKey ;
	BOOLEAN Inserted ;
} KDEVICE_QUEUE_ENTRY , *  PKDEVICE_QUEUE_ENTRY , *  PRKDEVICE_QUEUE_ENTRY ;

#line 9263
typedef struct _KEVENT {
	DISPATCHER_HEADER Header ;
} KEVENT , *  PKEVENT , *  PRKEVENT ;

#line 9271
typedef BOOLEAN ( *  PKSERVICE_ROUTINE )(struct _KINTERRUPT *  Interrupt , PVOID
	ServiceContext ) ;

#line 9281
typedef struct _KMUTANT {
	DISPATCHER_HEADER Header ;
	LIST_ENTRY MutantListEntry ;
	struct _KTHREAD *  OwnerThread ;
	BOOLEAN Abandoned ;
	UCHAR ApcDisable ;
} KMUTANT , *  PKMUTANT , *  PRKMUTANT , KMUTEX , *  PKMUTEX , *  PRKMUTEX ;

#line 9294
typedef struct _KSEMAPHORE {
	DISPATCHER_HEADER Header ;
	LONG Limit ;
} KSEMAPHORE , *  PKSEMAPHORE , *  PRKSEMAPHORE ;

#line 9304
typedef struct _KTIMER {
	DISPATCHER_HEADER Header ;
	ULARGE_INTEGER DueTime ;
	LIST_ENTRY TimerListEntry ;
	struct _KDPC *  Dpc ;
	LONG Period ;
} KTIMER , *  PKTIMER , *  PRKTIMER ;

#line 9316
__declspec(dllimport) void KeInitializeDpc(PRKDPC Dpc , PKDEFERRED_ROUTINE
	DeferredRoutine , PVOID DeferredContext ) ;
#line 9324
__declspec(dllimport) BOOLEAN KeInsertQueueDpc(PRKDPC Dpc , PVOID
	SystemArgument1 , PVOID SystemArgument2 ) ;
#line 9332
__declspec(dllimport) BOOLEAN KeRemoveQueueDpc(PRKDPC Dpc ) ;
#line 9340
__declspec(dllimport) void KeSetImportanceDpc(PRKDPC Dpc , KDPC_IMPORTANCE
	Importance ) ;
#line 9347
__declspec(dllimport) void KeSetTargetProcessorDpc(PRKDPC Dpc , CCHAR Number ) ;
#line 9359
__declspec(dllimport) void KeInitializeDeviceQueue(PKDEVICE_QUEUE DeviceQueue )
	;
#line 9365
__declspec(dllimport) BOOLEAN KeInsertDeviceQueue(PKDEVICE_QUEUE DeviceQueue ,
	PKDEVICE_QUEUE_ENTRY DeviceQueueEntry ) ;
#line 9372
__declspec(dllimport) BOOLEAN KeInsertByKeyDeviceQueue(PKDEVICE_QUEUE
	DeviceQueue , PKDEVICE_QUEUE_ENTRY DeviceQueueEntry , ULONG SortKey ) ;
#line 9380
__declspec(dllimport) PKDEVICE_QUEUE_ENTRY KeRemoveDeviceQueue(PKDEVICE_QUEUE
	DeviceQueue ) ;
#line 9386
__declspec(dllimport) PKDEVICE_QUEUE_ENTRY
	KeRemoveByKeyDeviceQueue(PKDEVICE_QUEUE DeviceQueue , ULONG SortKey ) ;
#line 9393
__declspec(dllimport) BOOLEAN KeRemoveEntryDeviceQueue(PKDEVICE_QUEUE
	DeviceQueue , PKDEVICE_QUEUE_ENTRY DeviceQueueEntry ) ;
#line 9400
__declspec(dllimport) BOOLEAN KeSynchronizeExecution(PKINTERRUPT Interrupt ,
	PKSYNCHRONIZE_ROUTINE SynchronizeRoutine , PVOID SynchronizeContext ) ;
#line 9415
__declspec(dllimport) void KeInitializeEvent(PRKEVENT Event , EVENT_TYPE Type ,
	BOOLEAN State ) ;
#line 9423
__declspec(dllimport) void KeClearEvent(PRKEVENT Event ) ;
#line 9429
__declspec(dllimport) LONG KePulseEvent(PRKEVENT Event , KPRIORITY Increment ,
	BOOLEAN Wait ) ;
#line 9437
__declspec(dllimport) LONG KeReadStateEvent(PRKEVENT Event ) ;
#line 9445
__declspec(dllimport) LONG KeResetEvent(PRKEVENT Event ) ;
#line 9451
__declspec(dllimport) LONG KeSetEvent(PRKEVENT Event , KPRIORITY Increment ,
	BOOLEAN Wait ) ;
#line 9463
__declspec(dllimport) void KeInitializeMutex(PRKMUTEX Mutex , ULONG Level ) ;
#line 9472
__declspec(dllimport) LONG KeReleaseMutex(PRKMUTEX Mutex , BOOLEAN Wait ) ;
#line 9483
__declspec(dllimport) void KeInitializeSemaphore(PRKSEMAPHORE Semaphore , LONG
	Count , LONG Limit ) ;
#line 9491
__declspec(dllimport) LONG KeReadStateSemaphore(PRKSEMAPHORE Semaphore ) ;
#line 9497
__declspec(dllimport) LONG KeReleaseSemaphore(PRKSEMAPHORE Semaphore , KPRIORITY
	Increment , LONG Adjustment , BOOLEAN Wait ) ;
#line 9506
__declspec(dllimport) NTSTATUS KeDelayExecutionThread(KPROCESSOR_MODE WaitMode ,
	BOOLEAN Alertable , PLARGE_INTEGER Interval ) ;
#line 9514
__declspec(dllimport) KPRIORITY KeQueryPriorityThread(PKTHREAD Thread ) ;
#line 9520
__declspec(dllimport) LONG KeSetBasePriorityThread(PKTHREAD Thread , LONG
	Increment ) ;
#line 9527
__declspec(dllimport) KPRIORITY KeSetPriorityThread(PKTHREAD Thread , KPRIORITY
	Priority ) ;
#line 9539
__declspec(dllimport) void KeEnterCriticalRegion(void  ) ;
#line 9545
__declspec(dllimport) void KeLeaveCriticalRegion(void  ) ;
#line 9623
__declspec(dllimport) void KeInitializeTimer(PKTIMER Timer ) ;
#line 9629
__declspec(dllimport) void KeInitializeTimerEx(PKTIMER Timer , TIMER_TYPE Type )
	;
#line 9636
__declspec(dllimport) BOOLEAN KeCancelTimer(PKTIMER ) ;
#line 9642
__declspec(dllimport) BOOLEAN KeReadStateTimer(PKTIMER Timer ) ;
#line 9648
__declspec(dllimport) BOOLEAN KeSetTimer(PKTIMER Timer , LARGE_INTEGER DueTime ,
	PKDPC Dpc ) ;
#line 9656
__declspec(dllimport) BOOLEAN KeSetTimerEx(PKTIMER Timer , LARGE_INTEGER DueTime
	, LONG Period , PKDPC Dpc ) ;
#line 9668
__declspec(dllimport) NTSTATUS KeWaitForMultipleObjects(ULONG Count , PVOID
	Object[] , WAIT_TYPE WaitType , KWAIT_REASON WaitReason ,
	KPROCESSOR_MODE WaitMode , BOOLEAN Alertable , PLARGE_INTEGER Timeout ,
	PKWAIT_BLOCK WaitBlockArray ) ;
#line 9681
__declspec(dllimport) NTSTATUS KeWaitForSingleObject(PVOID Object , KWAIT_REASON
	WaitReason , KPROCESSOR_MODE WaitMode , BOOLEAN Alertable ,
	PLARGE_INTEGER Timeout ) ;
#line 9711
__declspec(dllimport) void __stdcall KeInitializeSpinLock(PKSPIN_LOCK SpinLock )
	;
#line 9720
__declspec(dllimport) void _fastcall KefAcquireSpinLockAtDpcLevel(PKSPIN_LOCK
	SpinLock ) ;
#line 9727
__declspec(dllimport) void _fastcall KefReleaseSpinLockFromDpcLevel(PKSPIN_LOCK
	SpinLock ) ;
#line 9737
__declspec(dllimport) KIRQL _fastcall KfAcquireSpinLock(PKSPIN_LOCK SpinLock ) ;
#line 9744
__declspec(dllimport) void _fastcall KfReleaseSpinLock(PKSPIN_LOCK SpinLock ,
	KIRQL NewIrql ) ;
#line 9754
__declspec(dllimport) KIRQL _fastcall KeAcquireSpinLockRaiseToSynch(PKSPIN_LOCK
	SpinLock ) ;
#line 9808
__declspec(dllimport) void _fastcall KfLowerIrql(KIRQL NewIrql ) ;
#line 9815
__declspec(dllimport) KIRQL _fastcall KfRaiseIrql(KIRQL NewIrql ) ;
#line 9824
__declspec(dllimport) KIRQL KeRaiseIrqlToDpcLevel(void  ) ;
#line 9830
__declspec(dllimport) KIRQL KeRaiseIrqlToSynchLevel(void  ) ;
#line 9893
BOOLEAN KeGetBugMessageText(ULONG MessageId , PANSI_STRING ReturnedString ) ;

#line 9899
typedef enum _KBUGCHECK_BUFFER_DUMP_STATE {
	BufferEmpty,
	BufferInserted,
	BufferStarted,
	BufferFinished,
	BufferIncomplete
} KBUGCHECK_BUFFER_DUMP_STATE ;

typedef void ( *  PKBUGCHECK_CALLBACK_ROUTINE )(PVOID Buffer , ULONG Length ) ;

#line 9914
typedef struct _KBUGCHECK_CALLBACK_RECORD {
	LIST_ENTRY Entry ;
	PKBUGCHECK_CALLBACK_ROUTINE CallbackRoutine ;
	PVOID Buffer ;
	ULONG Length ;
	PUCHAR Component ;
	ULONG_PTR Checksum ;
	UCHAR State ;
} KBUGCHECK_CALLBACK_RECORD , *  PKBUGCHECK_CALLBACK_RECORD ;

__declspec(dllimport) __declspec(noreturn) void __stdcall KeBugCheck(ULONG
	BugCheckCode ) ;
#line 9934
__declspec(dllimport) __declspec(noreturn) void KeBugCheckEx(ULONG BugCheckCode
	, ULONG_PTR BugCheckParameter1 , ULONG_PTR BugCheckParameter2 ,
	ULONG_PTR BugCheckParameter3 , ULONG_PTR BugCheckParameter4 ) ;
#line 9950
__declspec(dllimport) BOOLEAN
	KeDeregisterBugCheckCallback(PKBUGCHECK_CALLBACK_RECORD CallbackRecord )
	;
#line 9956
__declspec(dllimport) BOOLEAN
	KeRegisterBugCheckCallback(PKBUGCHECK_CALLBACK_RECORD CallbackRecord ,
	PKBUGCHECK_CALLBACK_ROUTINE CallbackRoutine , PVOID Buffer , ULONG
	Length , PUCHAR Component ) ;
#line 9966
__declspec(dllimport) void KeEnterKernelDebugger(void  ) ;
#line 9973
__declspec(dllimport) ULONGLONG KeQueryInterruptTime(void  ) ;
#line 9979
__declspec(dllimport) void KeQuerySystemTime(PLARGE_INTEGER CurrentTime ) ;
#line 9985
__declspec(dllimport) ULONG KeQueryTimeIncrement(void  ) ;
#line 9992
__declspec(dllimport) KAFFINITY KeQueryActiveProcessors(void  ) ;

#line 10002
typedef void (_fastcall *  PSWAP_CONTEXT_NOTIFY_ROUTINE )(HANDLE OldThreadId ,
	HANDLE NewThreadId ) ;

#line 10009
__declspec(dllimport) void _fastcall
	KeSetSwapContextNotifyRoutine(PSWAP_CONTEXT_NOTIFY_ROUTINE NotifyRoutine
	) ;

#line 10020
typedef LOGICAL (_fastcall *  PTHREAD_SELECT_NOTIFY_ROUTINE )(HANDLE ThreadId )
	;

#line 10026
__declspec(dllimport) void _fastcall
	KeSetThreadSelectNotifyRoutine(PTHREAD_SELECT_NOTIFY_ROUTINE
	NotifyRoutine ) ;

#line 10037
typedef void (_fastcall *  PTIME_UPDATE_NOTIFY_ROUTINE )(HANDLE ThreadId ,
	KPROCESSOR_MODE Mode ) ;

#line 10044
__declspec(dllimport) void _fastcall
	KeSetTimeUpdateNotifyRoutine(PTIME_UPDATE_NOTIFY_ROUTINE NotifyRoutine )
	;
#line 10051
extern volatile KSYSTEM_TIME KeTickCount ;

typedef enum _MEMORY_CACHING_TYPE_ORIG {
	MmFrameBufferCached = 2
} MEMORY_CACHING_TYPE_ORIG ;

typedef enum _MEMORY_CACHING_TYPE {
	MmNonCached = 0,
	MmCached = 1,
	MmWriteCombined = MmFrameBufferCached,
	MmHardwareCoherentCached,
	MmNonCachedUnordered,
	MmUSWCCached,
	MmMaximumCacheType
} MEMORY_CACHING_TYPE ;

#line 10074
extern PBOOLEAN KdDebuggerNotPresent ;
extern PBOOLEAN KdDebuggerEnabled ;

#line 10087
typedef struct _DBGKD_DEBUG_DATA_HEADER64 *  PDBGKD_DEBUG_DATA_HEADER64 ;

BOOLEAN KdRegisterDebuggerDataBlock(ULONG Tag , PDBGKD_DEBUG_DATA_HEADER64
	DataHeader , ULONG Size ) ;
#line 10096
void KdDeregisterDebuggerDataBlock32(PDBGKD_DEBUG_DATA_HEADER64 DataHeader ) ;
#line 10101
void KdDisableDebugger(void  ) ;
#line 10106
void KdEnableDebugger(void  ) ;

#line 10115
typedef enum _POOL_TYPE {
	NonPagedPool,
	PagedPool,
	NonPagedPoolMustSucceed,
	DontUseThisType,
	NonPagedPoolCacheAligned,
	PagedPoolCacheAligned,
	NonPagedPoolCacheAlignedMustS,
	MaxPoolType,
	NonPagedPoolSession = 32,
	PagedPoolSession = NonPagedPoolSession + 1,
	NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
	DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
	NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
	PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
	NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1
} POOL_TYPE ;

#line 10145
__declspec(dllimport) PVOID ExAllocatePool(POOL_TYPE PoolType , SIZE_T
	NumberOfBytes ) ;
#line 10152
__declspec(dllimport) PVOID ExAllocatePoolWithQuota(POOL_TYPE PoolType , SIZE_T
	NumberOfBytes ) ;
#line 10159
__declspec(dllimport) PVOID __stdcall ExAllocatePoolWithTag(POOL_TYPE PoolType ,
	SIZE_T NumberOfBytes , ULONG Tag ) ;

#line 10195
typedef enum _EX_POOL_PRIORITY {
	LowPoolPriority,
	LowPoolPrioritySpecialPoolOverrun = 8,
	LowPoolPrioritySpecialPoolUnderrun = 9,
	NormalPoolPriority = 16,
	NormalPoolPrioritySpecialPoolOverrun = 24,
	NormalPoolPrioritySpecialPoolUnderrun = 25,
	HighPoolPriority = 32,
	HighPoolPrioritySpecialPoolOverrun = 40,
	HighPoolPrioritySpecialPoolUnderrun = 41
} EX_POOL_PRIORITY ;

#line 10208
__declspec(dllimport) PVOID __stdcall ExAllocatePoolWithTagPriority(POOL_TYPE
	PoolType , SIZE_T NumberOfBytes , ULONG Tag , EX_POOL_PRIORITY Priority
	) ;
#line 10224
__declspec(dllimport) PVOID ExAllocatePoolWithQuotaTag(POOL_TYPE PoolType ,
	SIZE_T NumberOfBytes , ULONG Tag ) ;
#line 10236
__declspec(dllimport) void __stdcall ExFreePool(PVOID P ) ;

#line 10247
typedef struct _FAST_MUTEX {
	LONG Count ;
	PKTHREAD Owner ;
	ULONG Contention ;
	KEVENT Event ;
	ULONG OldIrql ;
} FAST_MUTEX , *  PFAST_MUTEX ;

#line 10272
__declspec(dllimport) void _fastcall ExAcquireFastMutexUnsafe(PFAST_MUTEX
	FastMutex ) ;
#line 10279
__declspec(dllimport) void _fastcall ExReleaseFastMutexUnsafe(PFAST_MUTEX
	FastMutex ) ;
#line 10315
__declspec(dllimport) void _fastcall ExAcquireFastMutex(PFAST_MUTEX FastMutex )
	;
#line 10322
__declspec(dllimport) void _fastcall ExReleaseFastMutex(PFAST_MUTEX FastMutex )
	;
#line 10331
__declspec(dllimport) BOOLEAN _fastcall ExTryToAcquireFastMutex(PFAST_MUTEX
	FastMutex ) ;
#line 10348
__declspec(dllimport) void _fastcall
	ExInterlockedAddLargeStatistic(PLARGE_INTEGER Addend , ULONG Increment )
	;
#line 10358
__declspec(dllimport) LARGE_INTEGER ExInterlockedAddLargeInteger(PLARGE_INTEGER
	Addend , LARGE_INTEGER Increment , PKSPIN_LOCK Lock ) ;
#line 10367
__declspec(dllimport) ULONG _fastcall ExfInterlockedAddUlong(PULONG Addend ,
	ULONG Increment , PKSPIN_LOCK Lock ) ;
#line 10394
__declspec(dllimport) LONGLONG _fastcall
	ExInterlockedCompareExchange64(PLONGLONG Destination , PLONGLONG
	Exchange , PLONGLONG Comperand , PKSPIN_LOCK Lock ) ;
#line 10406
__declspec(dllimport) PLIST_ENTRY _fastcall
	ExfInterlockedInsertHeadList(PLIST_ENTRY ListHead , PLIST_ENTRY
	ListEntry , PKSPIN_LOCK Lock ) ;
#line 10415
__declspec(dllimport) PLIST_ENTRY _fastcall
	ExfInterlockedInsertTailList(PLIST_ENTRY ListHead , PLIST_ENTRY
	ListEntry , PKSPIN_LOCK Lock ) ;
#line 10424
__declspec(dllimport) PLIST_ENTRY _fastcall
	ExfInterlockedRemoveHeadList(PLIST_ENTRY ListHead , PKSPIN_LOCK Lock ) ;
#line 10432
__declspec(dllimport) PSINGLE_LIST_ENTRY _fastcall
	ExfInterlockedPopEntryList(PSINGLE_LIST_ENTRY ListHead , PKSPIN_LOCK
	Lock ) ;
#line 10440
__declspec(dllimport) PSINGLE_LIST_ENTRY _fastcall
	ExfInterlockedPushEntryList(PSINGLE_LIST_ENTRY ListHead ,
	PSINGLE_LIST_ENTRY ListEntry , PKSPIN_LOCK Lock ) ;
#line 10547
__declspec(dllimport) PSINGLE_LIST_ENTRY _fastcall
	ExInterlockedPopEntrySList(PSLIST_HEADER ListHead , PKSPIN_LOCK Lock ) ;
#line 10555
__declspec(dllimport) PSINGLE_LIST_ENTRY _fastcall
	ExInterlockedPushEntrySList(PSLIST_HEADER ListHead , PSINGLE_LIST_ENTRY
	ListEntry , PKSPIN_LOCK Lock ) ;
#line 10564
__declspec(dllimport) PSINGLE_LIST_ENTRY _fastcall
	ExInterlockedFlushSList(PSLIST_HEADER ListHead ) ;

#line 10574
typedef PVOID ( *  PALLOCATE_FUNCTION )(POOL_TYPE PoolType , SIZE_T
	NumberOfBytes , ULONG Tag ) ;

#line 10582
typedef void ( *  PFREE_FUNCTION )(PVOID Buffer ) ;

#line 10588
typedef struct _GENERAL_LOOKASIDE {
	SLIST_HEADER ListHead ;
	USHORT Depth ;
	USHORT MaximumDepth ;
	ULONG TotalAllocates ;
	union  {
		ULONG AllocateMisses ;
		ULONG AllocateHits ;
	}  ;
	ULONG TotalFrees ;
	union  {
		ULONG FreeMisses ;
		ULONG FreeHits ;
	}  ;
	POOL_TYPE Type ;
	ULONG Tag ;
	ULONG Size ;
	PALLOCATE_FUNCTION Allocate ;
	PFREE_FUNCTION Free ;
	LIST_ENTRY ListEntry ;
	ULONG LastTotalAllocates ;
	union  {
		ULONG LastAllocateMisses ;
		ULONG LastAllocateHits ;
	}  ;
	ULONG Future[2] ;
} GENERAL_LOOKASIDE , *  PGENERAL_LOOKASIDE ;

#line 10619
typedef struct _NPAGED_LOOKASIDE_LIST {
	GENERAL_LOOKASIDE L ;
	KSPIN_LOCK Lock ;
} NPAGED_LOOKASIDE_LIST , *  PNPAGED_LOOKASIDE_LIST ;

#line 10625
__declspec(dllimport)
	void ExInitializeNPagedLookasideList(PNPAGED_LOOKASIDE_LIST Lookaside ,
	PALLOCATE_FUNCTION Allocate , PFREE_FUNCTION Free , ULONG Flags , SIZE_T
	Size , ULONG Tag , USHORT Depth ) ;
#line 10637
__declspec(dllimport) void ExDeleteNPagedLookasideList(PNPAGED_LOOKASIDE_LIST
	Lookaside ) ;

#line 10643
__inline PVOID ExAllocateFromNPagedLookasideList(PNPAGED_LOOKASIDE_LIST
	Lookaside )
{
	#line 10670
	PVOID Entry ;
	#line 10672
	(Lookaside->L).TotalAllocates += 1;
	Entry = ExInterlockedPopEntrySList(& (Lookaside->L).ListHead, &
		Lookaside->Lock);
	#line 10674
	if(Entry == (void *  )0)
	{
		#line 10675
		(Lookaside->L).AllocateMisses += 1;
		Entry = ((Lookaside->L).Allocate)((Lookaside->L).Type,
			(Lookaside->L).Size, (Lookaside->L).Tag);
	}
	#line 10681
	return Entry;
}

__inline void ExFreeToNPagedLookasideList(PNPAGED_LOOKASIDE_LIST Lookaside ,
	PVOID Entry )
{
	#line 10713
	(Lookaside->L).TotalFrees += 1;
	if((USHORT )(& (Lookaside->L).ListHead)->Depth >= (Lookaside->L).Depth)
	{
		#line 10715
		(Lookaside->L).FreeMisses += 1;
		((Lookaside->L).Free)(Entry);
	}
	else
	{
		#line 10719
		ExInterlockedPushEntrySList(& (Lookaside->L).ListHead,
			(PSINGLE_LIST_ENTRY )Entry, & Lookaside->Lock);
	}
	#line 10724
	return;
}

#line 10729
typedef struct _PAGED_LOOKASIDE_LIST {
	GENERAL_LOOKASIDE L ;
	FAST_MUTEX Lock ;
} PAGED_LOOKASIDE_LIST , *  PPAGED_LOOKASIDE_LIST ;

__declspec(dllimport) void ExInitializePagedLookasideList(PPAGED_LOOKASIDE_LIST
	Lookaside , PALLOCATE_FUNCTION Allocate , PFREE_FUNCTION Free , ULONG
	Flags , SIZE_T Size , ULONG Tag , USHORT Depth ) ;
#line 10746
__declspec(dllimport) void ExDeletePagedLookasideList(PPAGED_LOOKASIDE_LIST
	Lookaside ) ;
#line 10754
__declspec(dllimport) PVOID
	ExAllocateFromPagedLookasideList(PPAGED_LOOKASIDE_LIST Lookaside ) ;
#line 10760
__declspec(dllimport) void ExFreeToPagedLookasideList(PPAGED_LOOKASIDE_LIST
	Lookaside , PVOID Entry ) ;
#line 10856
__declspec(dllimport) void __stdcall ProbeForRead(const void *  Address , ULONG
	Length , ULONG Alignment ) ;
#line 10869
__declspec(dllimport) void __stdcall ProbeForWrite(PVOID Address , ULONG Length
	, ULONG Alignment ) ;

#line 10882
typedef enum _WORK_QUEUE_TYPE {
	CriticalWorkQueue,
	DelayedWorkQueue,
	HyperCriticalWorkQueue,
	MaximumWorkQueue
} WORK_QUEUE_TYPE ;

typedef void ( *  PWORKER_THREAD_ROUTINE )(PVOID Parameter ) ;

#line 10895
typedef struct _WORK_QUEUE_ITEM {
	LIST_ENTRY List ;
	PWORKER_THREAD_ROUTINE WorkerRoutine ;
	PVOID Parameter ;
} WORK_QUEUE_ITEM , *  PWORK_QUEUE_ITEM ;

#line 10907
__declspec(dllimport) void ExQueueWorkItem(PWORK_QUEUE_ITEM WorkItem ,
	WORK_QUEUE_TYPE QueueType ) ;
#line 10916
__declspec(dllimport) BOOLEAN ExIsProcessorFeaturePresent(ULONG ProcessorFeature
	) ;

#line 10926
typedef struct _ZONE_SEGMENT_HEADER {
	SINGLE_LIST_ENTRY SegmentList ;
	PVOID Reserved ;
} ZONE_SEGMENT_HEADER , *  PZONE_SEGMENT_HEADER ;

typedef struct _ZONE_HEADER {
	SINGLE_LIST_ENTRY FreeList ;
	SINGLE_LIST_ENTRY SegmentList ;
	ULONG BlockSize ;
	ULONG TotalSegmentSize ;
} ZONE_HEADER , *  PZONE_HEADER ;

#line 10939
__declspec(dllimport) NTSTATUS ExInitializeZone(PZONE_HEADER Zone , ULONG
	BlockSize , PVOID InitialSegment , ULONG InitialSegmentSize ) ;
#line 10948
__declspec(dllimport) NTSTATUS ExExtendZone(PZONE_HEADER Zone , PVOID Segment ,
	ULONG SegmentSize ) ;
#line 10956
__declspec(dllimport) NTSTATUS ExInterlockedExtendZone(PZONE_HEADER Zone , PVOID
	Segment , ULONG SegmentSize , PKSPIN_LOCK Lock ) ;

#line 11156
typedef ULONG_PTR ERESOURCE_THREAD ;

#line 11157
typedef ERESOURCE_THREAD *  PERESOURCE_THREAD ;

typedef struct _OWNER_ENTRY {
	ERESOURCE_THREAD OwnerThread ;
	union  {
		LONG OwnerCount ;
		ULONG TableSize ;
	}  ;
} OWNER_ENTRY , *  POWNER_ENTRY ;

#line 11168
typedef struct _ERESOURCE {
	LIST_ENTRY SystemResourcesList ;
	POWNER_ENTRY OwnerTable ;
	SHORT ActiveCount ;
	USHORT Flag ;
	PKSEMAPHORE SharedWaiters ;
	PKEVENT ExclusiveWaiters ;
	OWNER_ENTRY OwnerThreads[2] ;
	ULONG ContentionCount ;
	USHORT NumberOfSharedWaiters ;
	USHORT NumberOfExclusiveWaiters ;
	union  {
		PVOID Address ;
		ULONG_PTR CreatorBackTraceIndex ;
	}  ;
	KSPIN_LOCK SpinLock ;
} ERESOURCE , *  PERESOURCE ;

#line 11197
typedef struct _RESOURCE_HASH_ENTRY {
	LIST_ENTRY ListEntry ;
	PVOID Address ;
	ULONG ContentionCount ;
	ULONG Number ;
} RESOURCE_HASH_ENTRY , *  PRESOURCE_HASH_ENTRY ;

typedef struct _RESOURCE_PERFORMANCE_DATA {
	ULONG ActiveResourceCount ;
	ULONG TotalResourceCount ;
	ULONG ExclusiveAcquire ;
	ULONG SharedFirstLevel ;
	ULONG SharedSecondLevel ;
	ULONG StarveFirstLevel ;
	ULONG StarveSecondLevel ;
	ULONG WaitForExclusive ;
	ULONG OwnerTableExpands ;
	ULONG MaximumTableExpand ;
	LIST_ENTRY HashTable[64] ;
} RESOURCE_PERFORMANCE_DATA , *  PRESOURCE_PERFORMANCE_DATA ;

#line 11222
__declspec(dllimport) NTSTATUS ExInitializeResourceLite(PERESOURCE Resource ) ;
#line 11228
__declspec(dllimport) NTSTATUS ExReinitializeResourceLite(PERESOURCE Resource )
	;
#line 11234
__declspec(dllimport) BOOLEAN ExAcquireResourceSharedLite(PERESOURCE Resource ,
	BOOLEAN Wait ) ;
#line 11241
__declspec(dllimport) BOOLEAN ExAcquireResourceExclusiveLite(PERESOURCE Resource
	, BOOLEAN Wait ) ;
#line 11248
__declspec(dllimport) BOOLEAN ExAcquireSharedStarveExclusive(PERESOURCE Resource
	, BOOLEAN Wait ) ;
#line 11255
__declspec(dllimport) BOOLEAN ExAcquireSharedWaitForExclusive(PERESOURCE
	Resource , BOOLEAN Wait ) ;
#line 11262
__declspec(dllimport) BOOLEAN ExTryToAcquireResourceExclusiveLite(PERESOURCE
	Resource ) ;
#line 11277
__declspec(dllimport) void _fastcall ExReleaseResourceLite(PERESOURCE Resource )
	;
#line 11284
__declspec(dllimport) void ExReleaseResourceForThreadLite(PERESOURCE Resource ,
	ERESOURCE_THREAD ResourceThreadId ) ;
#line 11291
__declspec(dllimport) void ExSetResourceOwnerPointer(PERESOURCE Resource , PVOID
	OwnerPointer ) ;
#line 11298
__declspec(dllimport) void ExConvertExclusiveToSharedLite(PERESOURCE Resource )
	;
#line 11304
__declspec(dllimport) NTSTATUS ExDeleteResourceLite(PERESOURCE Resource ) ;
#line 11310
__declspec(dllimport) ULONG ExGetExclusiveWaiterCount(PERESOURCE Resource ) ;
#line 11316
__declspec(dllimport) ULONG ExGetSharedWaiterCount(PERESOURCE Resource ) ;
#line 11330
__declspec(dllimport) BOOLEAN ExIsResourceAcquiredExclusiveLite(PERESOURCE
	Resource ) ;
#line 11336
__declspec(dllimport) ULONG ExIsResourceAcquiredSharedLite(PERESOURCE Resource )
	;
#line 11360
__declspec(dllimport) KPROCESSOR_MODE ExGetPreviousMode(void  ) ;
#line 11369
__declspec(dllimport) void __stdcall ExRaiseStatus(NTSTATUS Status ) ;
#line 11378
__declspec(dllimport) void ExRaiseDatatypeMisalignment(void  ) ;
#line 11384
__declspec(dllimport) void ExRaiseAccessViolation(void  ) ;
#line 11394
__declspec(dllimport) ULONG ExSetTimerResolution(ULONG DesiredTime , BOOLEAN
	SetResolution ) ;
#line 11406
__declspec(dllimport) void ExSystemTimeToLocalTime(PLARGE_INTEGER SystemTime ,
	PLARGE_INTEGER LocalTime ) ;
#line 11417
__declspec(dllimport) void ExLocalTimeToSystemTime(PLARGE_INTEGER LocalTime ,
	PLARGE_INTEGER SystemTime ) ;

#line 11429
typedef struct _CALLBACK_OBJECT *  PCALLBACK_OBJECT___0 ;

typedef void ( *  PCALLBACK_FUNCTION )(PVOID CallbackContext , PVOID Argument1 ,
	PVOID Argument2 ) ;

#line 11438
__declspec(dllimport) NTSTATUS ExCreateCallback(PCALLBACK_OBJECT___0 * 
	CallbackObject , POBJECT_ATTRIBUTES ObjectAttributes , BOOLEAN Create ,
	BOOLEAN AllowMultipleCallbacks ) ;
#line 11447
__declspec(dllimport) PVOID ExRegisterCallback(PCALLBACK_OBJECT___0
	CallbackObject , PCALLBACK_FUNCTION CallbackFunction , PVOID
	CallbackContext ) ;
#line 11455
__declspec(dllimport) void ExUnregisterCallback(PVOID CallbackRegistration ) ;
#line 11461
__declspec(dllimport) void ExNotifyCallback(PVOID CallbackObject , PVOID
	Argument1 , PVOID Argument2 ) ;

#line 11474
typedef GUID UUID ;

__declspec(dllimport) NTSTATUS ExUuidCreate(UUID *  Uuid ) ;
#line 11596
extern PBOOLEAN Mm64BitPhysicalAddress ;

#line 11862
typedef enum _MM_SYSTEM_SIZE {
	MmSmallSystem,
	MmMediumSystem,
	MmLargeSystem
} MM_SYSTEMSIZE ;

__declspec(dllimport) MM_SYSTEMSIZE MmQuerySystemSize(void  ) ;
#line 11876
__declspec(dllimport) BOOLEAN MmIsThisAnNtAsSystem(void  ) ;

#line 11884
typedef enum _LOCK_OPERATION {
	IoReadAccess,
	IoWriteAccess,
	IoModifyAccess
} LOCK_OPERATION ;

#line 11891
__declspec(dllimport) void MmProbeAndLockProcessPages(PMDL MemoryDescriptorList
	, PEPROCESS Process , KPROCESSOR_MODE AccessMode , LOCK_OPERATION
	Operation ) ;
#line 11906
__declspec(dllimport) void MmProbeAndLockPages(PMDL MemoryDescriptorList ,
	KPROCESSOR_MODE AccessMode , LOCK_OPERATION Operation ) ;
#line 11915
__declspec(dllimport) void MmUnlockPages(PMDL MemoryDescriptorList ) ;
#line 11921
__declspec(dllimport) void MmBuildMdlForNonPagedPool(PMDL MemoryDescriptorList )
	;
#line 11927
__declspec(dllimport) PVOID MmMapLockedPages(PMDL MemoryDescriptorList ,
	KPROCESSOR_MODE AccessMode ) ;
#line 11934
__declspec(dllimport) PVOID MmGetSystemRoutineAddress(PUNICODE_STRING
	SystemRoutineName ) ;
#line 11942
__declspec(dllimport) NTSTATUS MmMapUserAddressesToPage(PVOID BaseAddress ,
	SIZE_T NumberOfBytes , PVOID PageAddress ) ;

#line 11970
typedef enum _MM_PAGE_PRIORITY {
	LowPagePriority,
	NormalPagePriority = 16,
	HighPagePriority = 32
} MM_PAGE_PRIORITY ;

#line 11979
__declspec(dllimport) PVOID MmMapLockedPagesSpecifyCache(PMDL
	MemoryDescriptorList , KPROCESSOR_MODE AccessMode , MEMORY_CACHING_TYPE
	CacheType , PVOID BaseAddress , ULONG BugCheckOnFailure ,
	MM_PAGE_PRIORITY Priority ) ;
#line 11990
__declspec(dllimport) void MmUnmapLockedPages(PVOID BaseAddress , PMDL
	MemoryDescriptorList ) ;

#line 11999
typedef struct _PHYSICAL_MEMORY_RANGE {
	PHYSICAL_ADDRESS BaseAddress ;
	LARGE_INTEGER NumberOfBytes ;
} PHYSICAL_MEMORY_RANGE , *  PPHYSICAL_MEMORY_RANGE ;

__declspec(dllimport) NTSTATUS MmAddPhysicalMemory(PPHYSICAL_ADDRESS
	StartAddress , PLARGE_INTEGER NumberOfBytes ) ;
#line 12011
__declspec(dllimport) NTSTATUS MmRemovePhysicalMemory(PPHYSICAL_ADDRESS
	StartAddress , PLARGE_INTEGER NumberOfBytes ) ;
#line 12018
__declspec(dllimport) PPHYSICAL_MEMORY_RANGE MmGetPhysicalMemoryRanges(void  ) ;
#line 12024
__declspec(dllimport) PMDL MmAllocatePagesForMdl(PHYSICAL_ADDRESS LowAddress ,
	PHYSICAL_ADDRESS HighAddress , PHYSICAL_ADDRESS SkipBytes , SIZE_T
	TotalBytes ) ;
#line 12033
__declspec(dllimport) void MmFreePagesFromMdl(PMDL MemoryDescriptorList ) ;
#line 12041
__declspec(dllimport) PVOID MmMapIoSpace(PHYSICAL_ADDRESS PhysicalAddress ,
	SIZE_T NumberOfBytes , MEMORY_CACHING_TYPE CacheType ) ;
#line 12049
__declspec(dllimport) void MmUnmapIoSpace(PVOID BaseAddress , SIZE_T
	NumberOfBytes ) ;
#line 12057
__declspec(dllimport) PVOID MmMapVideoDisplay(PHYSICAL_ADDRESS PhysicalAddress ,
	SIZE_T NumberOfBytes , MEMORY_CACHING_TYPE CacheType ) ;
#line 12065
__declspec(dllimport) void MmUnmapVideoDisplay(PVOID BaseAddress , SIZE_T
	NumberOfBytes ) ;
#line 12072
__declspec(dllimport) PHYSICAL_ADDRESS MmGetPhysicalAddress(PVOID BaseAddress )
	;
#line 12078
__declspec(dllimport) PVOID MmGetVirtualForPhysical(PHYSICAL_ADDRESS
	PhysicalAddress ) ;
#line 12084
__declspec(dllimport) PVOID MmAllocateContiguousMemory(SIZE_T NumberOfBytes ,
	PHYSICAL_ADDRESS HighestAcceptableAddress ) ;
#line 12091
__declspec(dllimport) PVOID MmAllocateContiguousMemorySpecifyCache(SIZE_T
	NumberOfBytes , PHYSICAL_ADDRESS LowestAcceptableAddress ,
	PHYSICAL_ADDRESS HighestAcceptableAddress , PHYSICAL_ADDRESS
	BoundaryAddressMultiple , MEMORY_CACHING_TYPE CacheType ) ;
#line 12101
__declspec(dllimport) void MmFreeContiguousMemory(PVOID BaseAddress ) ;
#line 12107
__declspec(dllimport) void MmFreeContiguousMemorySpecifyCache(PVOID BaseAddress
	, SIZE_T NumberOfBytes , MEMORY_CACHING_TYPE CacheType ) ;
#line 12116
__declspec(dllimport) PVOID MmAllocateNonCachedMemory(SIZE_T NumberOfBytes ) ;
#line 12122
__declspec(dllimport) void MmFreeNonCachedMemory(PVOID BaseAddress , SIZE_T
	NumberOfBytes ) ;
#line 12129
__declspec(dllimport) BOOLEAN MmIsAddressValid(PVOID VirtualAddress ) ;
#line 12135
__declspec(dllimport) BOOLEAN MmIsNonPagedSystemAddressValid(PVOID
	VirtualAddress ) ;
#line 12143
__declspec(dllimport) SIZE_T MmSizeOfMdl(PVOID Base , SIZE_T Length ) ;
#line 12150
__declspec(dllimport) PMDL MmCreateMdl(PMDL MemoryDescriptorList , PVOID Base ,
	SIZE_T Length ) ;
#line 12158
__declspec(dllimport) PVOID MmLockPagableDataSection(PVOID AddressWithinSection
	) ;
#line 12166
__declspec(dllimport) void MmLockPagableSectionByHandle(PVOID ImageSectionHandle
	) ;
#line 12172
__declspec(dllimport) void MmResetDriverPaging(PVOID AddressWithinSection ) ;
#line 12179
__declspec(dllimport) PVOID MmPageEntireDriver(PVOID AddressWithinSection ) ;
#line 12185
__declspec(dllimport) void MmUnlockPagableImageSection(PVOID ImageSectionHandle
	) ;
#line 12193
__declspec(dllimport) HANDLE MmSecureVirtualMemory(PVOID Address , SIZE_T Size ,
	ULONG ProbeMode ) ;
#line 12201
__declspec(dllimport) void MmUnsecureVirtualMemory(HANDLE SecureHandle ) ;
#line 12207
__declspec(dllimport) NTSTATUS MmMapViewInSystemSpace(PVOID Section , PVOID * 
	MappedBase , PSIZE_T ViewSize ) ;
#line 12215
__declspec(dllimport) NTSTATUS MmUnmapViewInSystemSpace(PVOID MappedBase ) ;
#line 12221
__declspec(dllimport) NTSTATUS MmMapViewInSessionSpace(PVOID Section , PVOID * 
	MappedBase , PSIZE_T ViewSize ) ;
#line 12229
__declspec(dllimport) NTSTATUS MmUnmapViewInSessionSpace(PVOID MappedBase ) ;

#line 12385
typedef NTSTATUS ( *  PMM_DLL_INITIALIZE )(PUNICODE_STRING RegistryPath ) ;

#line 12389
typedef NTSTATUS ( *  PMM_DLL_UNLOAD )(void  ) ;

#line 12399
struct _DRIVER_OBJECT ;

__declspec(dllimport) LOGICAL MmIsDriverVerifying(struct _DRIVER_OBJECT * 
	DriverObject ) ;

#line 12411
typedef enum _SECURITY_OPERATION_CODE {
	SetSecurityDescriptor,
	QuerySecurityDescriptor,
	DeleteSecurityDescriptor,
	AssignSecurityDescriptor
} SECURITY_OPERATION_CODE , *  PSECURITY_OPERATION_CODE ;

#line 12426
typedef struct _SECURITY_SUBJECT_CONTEXT {
	PACCESS_TOKEN ClientToken ;
	SECURITY_IMPERSONATION_LEVEL ImpersonationLevel ;
	PACCESS_TOKEN PrimaryToken ;
	PVOID ProcessAuditId ;
} SECURITY_SUBJECT_CONTEXT , *  PSECURITY_SUBJECT_CONTEXT ;

#line 12448
typedef struct _INITIAL_PRIVILEGE_SET {
	ULONG PrivilegeCount ;
	ULONG Control ;
	LUID_AND_ATTRIBUTES Privilege[3] ;
} INITIAL_PRIVILEGE_SET , *  PINITIAL_PRIVILEGE_SET ;

#line 12462
typedef struct _ACCESS_STATE {
	LUID OperationID ;
	BOOLEAN SecurityEvaluated ;
	BOOLEAN GenerateAudit ;
	BOOLEAN GenerateOnClose ;
	BOOLEAN PrivilegesAllocated ;
	ULONG Flags ;
	ACCESS_MASK RemainingDesiredAccess ;
	ACCESS_MASK PreviouslyGrantedAccess ;
	ACCESS_MASK OriginalDesiredAccess ;
	SECURITY_SUBJECT_CONTEXT SubjectSecurityContext ;
	PSECURITY_DESCRIPTOR SecurityDescriptor ;
	PVOID AuxData ;
	union  {
		INITIAL_PRIVILEGE_SET InitialPrivilegeSet ;
		PRIVILEGE_SET PrivilegeSet ;
	} Privileges ;
	BOOLEAN AuditPrivileges ;
	UNICODE_STRING ObjectName ;
	UNICODE_STRING ObjectTypeName ;
} ACCESS_STATE , *  PACCESS_STATE ;

#line 12487
__declspec(dllimport) NTSTATUS SeAssignSecurity(PSECURITY_DESCRIPTOR
	ParentDescriptor , PSECURITY_DESCRIPTOR ExplicitDescriptor ,
	PSECURITY_DESCRIPTOR *  NewDescriptor , BOOLEAN IsDirectoryObject ,
	PSECURITY_SUBJECT_CONTEXT SubjectContext , PGENERIC_MAPPING
	GenericMapping , POOL_TYPE PoolType ) ;
#line 12499
__declspec(dllimport) NTSTATUS SeAssignSecurityEx(PSECURITY_DESCRIPTOR
	ParentDescriptor , PSECURITY_DESCRIPTOR ExplicitDescriptor ,
	PSECURITY_DESCRIPTOR *  NewDescriptor , GUID *  ObjectType , BOOLEAN
	IsDirectoryObject , ULONG AutoInheritFlags , PSECURITY_SUBJECT_CONTEXT
	SubjectContext , PGENERIC_MAPPING GenericMapping , POOL_TYPE PoolType )
	;
#line 12513
__declspec(dllimport) NTSTATUS SeDeassignSecurity(PSECURITY_DESCRIPTOR * 
	SecurityDescriptor ) ;
#line 12519
__declspec(dllimport) BOOLEAN SeAccessCheck(PSECURITY_DESCRIPTOR
	SecurityDescriptor , PSECURITY_SUBJECT_CONTEXT SubjectSecurityContext ,
	BOOLEAN SubjectContextLocked , ACCESS_MASK DesiredAccess , ACCESS_MASK
	PreviouslyGrantedAccess , PPRIVILEGE_SET *  Privileges ,
	PGENERIC_MAPPING GenericMapping , KPROCESSOR_MODE AccessMode ,
	PACCESS_MASK GrantedAccess , PNTSTATUS AccessStatus ) ;
#line 12535
__declspec(dllimport) BOOLEAN SeValidSecurityDescriptor(ULONG Length ,
	PSECURITY_DESCRIPTOR SecurityDescriptor ) ;
#line 12542
__declspec(dllimport) BOOLEAN SeSinglePrivilegeCheck(LUID PrivilegeValue ,
	KPROCESSOR_MODE PreviousMode ) ;
#line 12552
__declspec(dllimport) NTSTATUS PsCreateSystemThread(PHANDLE ThreadHandle , ULONG
	DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes , HANDLE
	ProcessHandle , PCLIENT_ID ClientId , PKSTART_ROUTINE StartRoutine ,
	PVOID StartContext ) ;
#line 12564
__declspec(dllimport) NTSTATUS PsTerminateSystemThread(NTSTATUS ExitStatus ) ;

#line 12571
typedef void ( *  PCREATE_PROCESS_NOTIFY_ROUTINE )(HANDLE ParentId , HANDLE
	ProcessId , BOOLEAN Create ) ;

#line 12579
NTSTATUS PsSetCreateProcessNotifyRoutine(PCREATE_PROCESS_NOTIFY_ROUTINE
	NotifyRoutine , BOOLEAN Remove ) ;

#line 12585
typedef void ( *  PCREATE_THREAD_NOTIFY_ROUTINE )(HANDLE ProcessId , HANDLE
	ThreadId , BOOLEAN Create ) ;

#line 12593
NTSTATUS PsSetCreateThreadNotifyRoutine(PCREATE_THREAD_NOTIFY_ROUTINE
	NotifyRoutine ) ;

#line 12602
typedef struct _IMAGE_INFO {
	union  {
		ULONG Properties ;
		struct  {
			ULONG ImageAddressingMode  : 8;
			ULONG SystemModeImage  : 1;
			ULONG ImageMappedToAllPids  : 1;
			ULONG Reserved  : 22;
		}  ;
	}  ;
	PVOID ImageBase ;
	ULONG ImageSelector ;
	SIZE_T ImageSize ;
	ULONG ImageSectionNumber ;
} IMAGE_INFO , *  PIMAGE_INFO ;

#line 12620
typedef void ( *  PLOAD_IMAGE_NOTIFY_ROUTINE )(PUNICODE_STRING FullImageName ,
	HANDLE ProcessId , PIMAGE_INFO ImageInfo ) ;

#line 12628
NTSTATUS PsSetLoadImageNotifyRoutine(PLOAD_IMAGE_NOTIFY_ROUTINE NotifyRoutine )
	;
#line 12633
HANDLE PsGetCurrentProcessId(void  ) ;
#line 12636
HANDLE PsGetCurrentThreadId(void  ) ;
#line 12639
BOOLEAN PsGetVersion(PULONG MajorVersion , PULONG MinorVersion , PULONG
	BuildNumber , PUNICODE_STRING CSDVersion ) ;

#line 12859
typedef NTSTATUS ( *  PIO_QUERY_DEVICE_ROUTINE )(PVOID Context , PUNICODE_STRING
	PathName , INTERFACE_TYPE BusType , ULONG BusNumber ,
	PKEY_VALUE_FULL_INFORMATION *  BusInformation , CONFIGURATION_TYPE
	ControllerType , ULONG ControllerNumber , PKEY_VALUE_FULL_INFORMATION * 
	ControllerInformation , CONFIGURATION_TYPE PeripheralType , ULONG
	PeripheralNumber , PKEY_VALUE_FULL_INFORMATION *  PeripheralInformation
	) ;

#line 12878
typedef enum _IO_QUERY_DEVICE_DATA_FORMAT {
	IoQueryDeviceIdentifier = 0,
	IoQueryDeviceConfigurationData,
	IoQueryDeviceComponentInformation,
	IoQueryDeviceMaxData
} IO_QUERY_DEVICE_DATA_FORMAT , *  PIO_QUERY_DEVICE_DATA_FORMAT ;

#line 12890
typedef enum _CREATE_FILE_TYPE {
	CreateFileTypeNone,
	CreateFileTypeNamedPipe,
	CreateFileTypeMailslot
} CREATE_FILE_TYPE ;

#line 12905
struct _DEVICE_DESCRIPTION ;

#line 12906
struct _DEVICE_OBJECT ;

#line 12907
struct _DMA_ADAPTER ;

#line 12908
struct _DRIVER_OBJECT ;

#line 12909
struct _DRIVE_LAYOUT_INFORMATION ;

#line 12910
struct _DISK_PARTITION ;

#line 12911
struct _FILE_OBJECT ;

#line 12912
struct _IRP ;

#line 12913
struct _SCSI_REQUEST_BLOCK ;

#line 12919
typedef void ( *  PIO_DPC_ROUTINE )(PKDPC Dpc , struct _DEVICE_OBJECT * 
	DeviceObject , struct _IRP *  Irp , PVOID Context ) ;

#line 12932
typedef void ( *  PIO_TIMER_ROUTINE )(struct _DEVICE_OBJECT *  DeviceObject ,
	PVOID Context ) ;

#line 12943
typedef NTSTATUS ( *  PDRIVER_INITIALIZE )(struct _DRIVER_OBJECT *  DriverObject
	, PUNICODE_STRING RegistryPath ) ;

#line 12955
typedef void ( *  PDRIVER_REINITIALIZE )(struct _DRIVER_OBJECT *  DriverObject ,
	PVOID Context , ULONG Count ) ;

#line 12968
typedef void ( *  PDRIVER_CANCEL )(struct _DEVICE_OBJECT *  DeviceObject ,
	struct _IRP *  Irp ) ;

#line 12979
typedef NTSTATUS ( *  PDRIVER_DISPATCH )(struct _DEVICE_OBJECT *  DeviceObject ,
	struct _IRP *  Irp ) ;

#line 12990
typedef void ( *  PDRIVER_STARTIO )(struct _DEVICE_OBJECT *  DeviceObject ,
	struct _IRP *  Irp ) ;

#line 13001
typedef void ( *  PDRIVER_UNLOAD )(struct _DRIVER_OBJECT *  DriverObject ) ;

#line 13011
typedef NTSTATUS ( *  PDRIVER_ADD_DEVICE )(struct _DRIVER_OBJECT *  DriverObject
	, struct _DEVICE_OBJECT *  PhysicalDeviceObject ) ;

#line 13025
typedef BOOLEAN ( *  PFAST_IO_CHECK_IF_POSSIBLE )(struct _FILE_OBJECT * 
	FileObject , PLARGE_INTEGER FileOffset , ULONG Length , BOOLEAN Wait ,
	ULONG LockKey , BOOLEAN CheckForReadOperation , PIO_STATUS_BLOCK
	IoStatus , struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13038
typedef BOOLEAN ( *  PFAST_IO_READ )(struct _FILE_OBJECT *  FileObject ,
	PLARGE_INTEGER FileOffset , ULONG Length , BOOLEAN Wait , ULONG LockKey
	, PVOID Buffer , PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT * 
	DeviceObject ) ;

#line 13051
typedef BOOLEAN ( *  PFAST_IO_WRITE )(struct _FILE_OBJECT *  FileObject ,
	PLARGE_INTEGER FileOffset , ULONG Length , BOOLEAN Wait , ULONG LockKey
	, PVOID Buffer , PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT * 
	DeviceObject ) ;

#line 13068
typedef BOOLEAN ( *  PFAST_IO_QUERY_BASIC_INFO )(struct _FILE_OBJECT * 
	FileObject , BOOLEAN Wait , PFILE_BASIC_INFORMATION Buffer ,
	PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13078
typedef BOOLEAN ( *  PFAST_IO_QUERY_STANDARD_INFO )(struct _FILE_OBJECT * 
	FileObject , BOOLEAN Wait , PFILE_STANDARD_INFORMATION Buffer ,
	PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13092
typedef BOOLEAN ( *  PFAST_IO_LOCK )(struct _FILE_OBJECT *  FileObject ,
	PLARGE_INTEGER FileOffset , PLARGE_INTEGER Length , PEPROCESS ProcessId
	, ULONG Key , BOOLEAN FailImmediately , BOOLEAN ExclusiveLock ,
	PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13106
typedef BOOLEAN ( *  PFAST_IO_UNLOCK_SINGLE )(struct _FILE_OBJECT *  FileObject
	, PLARGE_INTEGER FileOffset , PLARGE_INTEGER Length , PEPROCESS
	ProcessId , ULONG Key , PIO_STATUS_BLOCK IoStatus ,
	struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13118
typedef BOOLEAN ( *  PFAST_IO_UNLOCK_ALL )(struct _FILE_OBJECT *  FileObject ,
	PEPROCESS ProcessId , PIO_STATUS_BLOCK IoStatus ,
	struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13127
typedef BOOLEAN ( *  PFAST_IO_UNLOCK_ALL_BY_KEY )(struct _FILE_OBJECT * 
	FileObject , PVOID ProcessId , ULONG Key , PIO_STATUS_BLOCK IoStatus ,
	struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13141
typedef BOOLEAN ( *  PFAST_IO_DEVICE_CONTROL )(struct _FILE_OBJECT *  FileObject
	, BOOLEAN Wait , PVOID InputBuffer , ULONG InputBufferLength , PVOID
	OutputBuffer , ULONG OutputBufferLength , ULONG IoControlCode ,
	PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13161
typedef void ( *  PFAST_IO_ACQUIRE_FILE )(struct _FILE_OBJECT *  FileObject ) ;

#line 13167
typedef void ( *  PFAST_IO_RELEASE_FILE )(struct _FILE_OBJECT *  FileObject ) ;

#line 13179
typedef void ( *  PFAST_IO_DETACH_DEVICE )(struct _DEVICE_OBJECT *  SourceDevice
	, struct _DEVICE_OBJECT *  TargetDevice ) ;

#line 13193
typedef BOOLEAN ( *  PFAST_IO_QUERY_NETWORK_OPEN_INFO )(struct _FILE_OBJECT * 
	FileObject , BOOLEAN Wait , struct _FILE_NETWORK_OPEN_INFORMATION * 
	Buffer , struct _IO_STATUS_BLOCK *  IoStatus , struct _DEVICE_OBJECT * 
	DeviceObject ) ;

#line 13207
typedef BOOLEAN ( *  PFAST_IO_MDL_READ )(struct _FILE_OBJECT *  FileObject ,
	PLARGE_INTEGER FileOffset , ULONG Length , ULONG LockKey , PMDL * 
	MdlChain , PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT * 
	DeviceObject ) ;

#line 13219
typedef BOOLEAN ( *  PFAST_IO_MDL_READ_COMPLETE )(struct _FILE_OBJECT * 
	FileObject , PMDL MdlChain , struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13227
typedef BOOLEAN ( *  PFAST_IO_PREPARE_MDL_WRITE )(struct _FILE_OBJECT * 
	FileObject , PLARGE_INTEGER FileOffset , ULONG Length , ULONG LockKey ,
	PMDL *  MdlChain , PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT * 
	DeviceObject ) ;

#line 13239
typedef BOOLEAN ( *  PFAST_IO_MDL_WRITE_COMPLETE )(struct _FILE_OBJECT * 
	FileObject , PLARGE_INTEGER FileOffset , PMDL MdlChain ,
	struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13253
typedef NTSTATUS ( *  PFAST_IO_ACQUIRE_FOR_MOD_WRITE )(struct _FILE_OBJECT * 
	FileObject , PLARGE_INTEGER EndingOffset , struct _ERESOURCE *  * 
	ResourceToRelease , struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13262
typedef NTSTATUS ( *  PFAST_IO_RELEASE_FOR_MOD_WRITE )(struct _FILE_OBJECT * 
	FileObject , struct _ERESOURCE *  ResourceToRelease ,
	struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13275
typedef NTSTATUS ( *  PFAST_IO_ACQUIRE_FOR_CCFLUSH )(struct _FILE_OBJECT * 
	FileObject , struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13282
typedef NTSTATUS ( *  PFAST_IO_RELEASE_FOR_CCFLUSH )(struct _FILE_OBJECT * 
	FileObject , struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13289
typedef BOOLEAN ( *  PFAST_IO_READ_COMPRESSED )(struct _FILE_OBJECT * 
	FileObject , PLARGE_INTEGER FileOffset , ULONG Length , ULONG LockKey ,
	PVOID Buffer , PMDL *  MdlChain , PIO_STATUS_BLOCK IoStatus ,
	struct _COMPRESSED_DATA_INFO *  CompressedDataInfo , ULONG
	CompressedDataInfoLength , struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13304
typedef BOOLEAN ( *  PFAST_IO_WRITE_COMPRESSED )(struct _FILE_OBJECT * 
	FileObject , PLARGE_INTEGER FileOffset , ULONG Length , ULONG LockKey ,
	PVOID Buffer , PMDL *  MdlChain , PIO_STATUS_BLOCK IoStatus ,
	struct _COMPRESSED_DATA_INFO *  CompressedDataInfo , ULONG
	CompressedDataInfoLength , struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13319
typedef BOOLEAN ( *  PFAST_IO_MDL_READ_COMPLETE_COMPRESSED
	)(struct _FILE_OBJECT *  FileObject , PMDL MdlChain ,
	struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13327
typedef BOOLEAN ( *  PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED
	)(struct _FILE_OBJECT *  FileObject , PLARGE_INTEGER FileOffset , PMDL
	MdlChain , struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13336
typedef BOOLEAN ( *  PFAST_IO_QUERY_OPEN )(struct _IRP *  Irp ,
	PFILE_NETWORK_OPEN_INFORMATION NetworkInformation ,
	struct _DEVICE_OBJECT *  DeviceObject ) ;

#line 13350
typedef struct _FAST_IO_DISPATCH {
	ULONG SizeOfFastIoDispatch ;
	PFAST_IO_CHECK_IF_POSSIBLE FastIoCheckIfPossible ;
	PFAST_IO_READ FastIoRead ;
	PFAST_IO_WRITE FastIoWrite ;
	PFAST_IO_QUERY_BASIC_INFO FastIoQueryBasicInfo ;
	PFAST_IO_QUERY_STANDARD_INFO FastIoQueryStandardInfo ;
	PFAST_IO_LOCK FastIoLock ;
	PFAST_IO_UNLOCK_SINGLE FastIoUnlockSingle ;
	PFAST_IO_UNLOCK_ALL FastIoUnlockAll ;
	PFAST_IO_UNLOCK_ALL_BY_KEY FastIoUnlockAllByKey ;
	PFAST_IO_DEVICE_CONTROL FastIoDeviceControl ;
	PFAST_IO_ACQUIRE_FILE AcquireFileForNtCreateSection ;
	PFAST_IO_RELEASE_FILE ReleaseFileForNtCreateSection ;
	PFAST_IO_DETACH_DEVICE FastIoDetachDevice ;
	PFAST_IO_QUERY_NETWORK_OPEN_INFO FastIoQueryNetworkOpenInfo ;
	PFAST_IO_ACQUIRE_FOR_MOD_WRITE AcquireForModWrite ;
	PFAST_IO_MDL_READ MdlRead ;
	PFAST_IO_MDL_READ_COMPLETE MdlReadComplete ;
	PFAST_IO_PREPARE_MDL_WRITE PrepareMdlWrite ;
	PFAST_IO_MDL_WRITE_COMPLETE MdlWriteComplete ;
	PFAST_IO_READ_COMPRESSED FastIoReadCompressed ;
	PFAST_IO_WRITE_COMPRESSED FastIoWriteCompressed ;
	PFAST_IO_MDL_READ_COMPLETE_COMPRESSED MdlReadCompleteCompressed ;
	PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED MdlWriteCompleteCompressed ;
	PFAST_IO_QUERY_OPEN FastIoQueryOpen ;
	PFAST_IO_RELEASE_FOR_MOD_WRITE ReleaseForModWrite ;
	PFAST_IO_ACQUIRE_FOR_CCFLUSH AcquireForCcFlush ;
	PFAST_IO_RELEASE_FOR_CCFLUSH ReleaseForCcFlush ;
} FAST_IO_DISPATCH , *  PFAST_IO_DISPATCH ;

#line 13386
typedef enum _IO_ALLOCATION_ACTION {
	KeepObject = 1,
	DeallocateObject,
	DeallocateObjectKeepRegisters
} IO_ALLOCATION_ACTION , *  PIO_ALLOCATION_ACTION ;

#line 13396
typedef IO_ALLOCATION_ACTION ( *  PDRIVER_CONTROL )(struct _DEVICE_OBJECT * 
	DeviceObject , struct _IRP *  Irp , PVOID MapRegisterBase , PVOID
	Context ) ;

#line 13410
typedef struct _IO_SECURITY_CONTEXT {
	PSECURITY_QUALITY_OF_SERVICE SecurityQos ;
	PACCESS_STATE AccessState ;
	ACCESS_MASK DesiredAccess ;
	ULONG FullCreateOptions ;
} IO_SECURITY_CONTEXT , *  PIO_SECURITY_CONTEXT ;

#line 13434
typedef struct _VPB {
	CSHORT Type ;
	CSHORT Size ;
	USHORT Flags ;
	USHORT VolumeLabelLength ;
	struct _DEVICE_OBJECT *  DeviceObject ;
	struct _DEVICE_OBJECT *  RealDevice ;
	ULONG SerialNumber ;
	ULONG ReferenceCount ;
	WCHAR VolumeLabel[32 * sizeof(WCHAR ) / sizeof(WCHAR )] ;
} VPB , *  PVPB ;

#line 13482
typedef struct _ADAPTER_OBJECT *  PADAPTER_OBJECT ;

#line 13491
typedef struct _WAIT_CONTEXT_BLOCK {
	KDEVICE_QUEUE_ENTRY WaitQueueEntry ;
	PDRIVER_CONTROL DeviceRoutine ;
	PVOID DeviceContext ;
	ULONG NumberOfMapRegisters ;
	PVOID DeviceObject ;
	PVOID CurrentIrp ;
	PKDPC BufferChainingDpc ;
} WAIT_CONTEXT_BLOCK , *  PWAIT_CONTEXT_BLOCK ;

#line 13503
typedef struct _CONTROLLER_OBJECT {
	CSHORT Type ;
	CSHORT Size ;
	PVOID ControllerExtension ;
	KDEVICE_QUEUE DeviceWaitQueue ;
	ULONG Spare1 ;
	LARGE_INTEGER Spare2 ;
} CONTROLLER_OBJECT , *  PCONTROLLER_OBJECT ;

#line 13537
typedef struct _DEVICE_OBJECT {
	CSHORT Type ;
	USHORT Size ;
	LONG ReferenceCount ;
	struct _DRIVER_OBJECT *  DriverObject ;
	struct _DEVICE_OBJECT *  NextDevice ;
	struct _DEVICE_OBJECT *  AttachedDevice ;
	struct _IRP *  CurrentIrp ;
	PIO_TIMER Timer ;
	ULONG Flags ;
	ULONG Characteristics ;
	PVPB Vpb ;
	PVOID DeviceExtension ;
	ULONG DeviceType ;
	CCHAR StackSize ;
	union  {
		LIST_ENTRY ListEntry ;
		WAIT_CONTEXT_BLOCK Wcb ;
	} Queue ;
	ULONG AlignmentRequirement ;
	KDEVICE_QUEUE DeviceQueue ;
	KDPC Dpc ;
	ULONG ActiveThreadCount ;
	PSECURITY_DESCRIPTOR SecurityDescriptor ;
	KEVENT DeviceLock ;
	USHORT SectorSize ;
	USHORT Spare1 ;
	struct _DEVOBJ_EXTENSION *  DeviceObjectExtension ;
	PVOID Reserved ;
} DEVICE_OBJECT ;

#line 13575
typedef struct _DEVICE_OBJECT *  PDEVICE_OBJECT ;

#line 13578
struct _DEVICE_OBJECT_POWER_EXTENSION ;

typedef struct _DEVOBJ_EXTENSION {
	CSHORT Type ;
	USHORT Size ;
	PDEVICE_OBJECT DeviceObject ;
} DEVOBJ_EXTENSION , *  PDEVOBJ_EXTENSION ;

#line 13608
typedef struct _DRIVER_EXTENSION {
	struct _DRIVER_OBJECT *  DriverObject ;
	PDRIVER_ADD_DEVICE AddDevice ;
	ULONG Count ;
	UNICODE_STRING ServiceKeyName ;
} DRIVER_EXTENSION , *  PDRIVER_EXTENSION ;

#line 13645
typedef struct _DRIVER_OBJECT {
	CSHORT Type ;
	CSHORT Size ;
	PDEVICE_OBJECT DeviceObject ;
	ULONG Flags ;
	PVOID DriverStart ;
	ULONG DriverSize ;
	PVOID DriverSection ;
	PDRIVER_EXTENSION DriverExtension ;
	UNICODE_STRING DriverName ;
	PUNICODE_STRING HardwareDatabase ;
	PFAST_IO_DISPATCH FastIoDispatch ;
	PDRIVER_INITIALIZE DriverInit ;
	PDRIVER_STARTIO DriverStartIo ;
	PDRIVER_UNLOAD DriverUnload ;
	PDRIVER_DISPATCH MajorFunction[0x1b + 1] ;
} DRIVER_OBJECT ;

#line 13706
typedef struct _DRIVER_OBJECT *  PDRIVER_OBJECT ;

#line 13715
typedef struct _SECTION_OBJECT_POINTERS {
	PVOID DataSectionObject ;
	PVOID SharedCacheMap ;
	PVOID ImageSectionObject ;
} SECTION_OBJECT_POINTERS ;

#line 13720
typedef SECTION_OBJECT_POINTERS *  PSECTION_OBJECT_POINTERS ;

#line 13726
typedef struct _IO_COMPLETION_CONTEXT {
	PVOID Port ;
	PVOID Key ;
} IO_COMPLETION_CONTEXT , *  PIO_COMPLETION_CONTEXT ;

#line 13759
typedef struct _FILE_OBJECT {
	CSHORT Type ;
	CSHORT Size ;
	PDEVICE_OBJECT DeviceObject ;
	PVPB Vpb ;
	PVOID FsContext ;
	PVOID FsContext2 ;
	PSECTION_OBJECT_POINTERS SectionObjectPointer ;
	PVOID PrivateCacheMap ;
	NTSTATUS FinalStatus ;
	struct _FILE_OBJECT *  RelatedFileObject ;
	BOOLEAN LockOperation ;
	BOOLEAN DeletePending ;
	BOOLEAN ReadAccess ;
	BOOLEAN WriteAccess ;
	BOOLEAN DeleteAccess ;
	BOOLEAN SharedRead ;
	BOOLEAN SharedWrite ;
	BOOLEAN SharedDelete ;
	ULONG Flags ;
	UNICODE_STRING FileName ;
	LARGE_INTEGER CurrentByteOffset ;
	ULONG Waiters ;
	ULONG Busy ;
	PVOID LastLock ;
	KEVENT Lock ;
	KEVENT Event ;
	PIO_COMPLETION_CONTEXT CompletionContext ;
} FILE_OBJECT ;

#line 13788
typedef struct _FILE_OBJECT *  PFILE_OBJECT ;

#line 13828
typedef struct _IRP {
	CSHORT Type ;
	USHORT Size ;
	PMDL MdlAddress ;
	ULONG Flags ;
	union  {
		struct _IRP *  MasterIrp ;
		LONG IrpCount ;
		PVOID SystemBuffer ;
	} AssociatedIrp ;
	LIST_ENTRY ThreadListEntry ;
	IO_STATUS_BLOCK IoStatus ;
	KPROCESSOR_MODE RequestorMode ;
	BOOLEAN PendingReturned ;
	CHAR StackCount ;
	CHAR CurrentLocation ;
	BOOLEAN Cancel ;
	KIRQL CancelIrql ;
	CCHAR ApcEnvironment ;
	UCHAR AllocationFlags ;
	PIO_STATUS_BLOCK UserIosb ;
	PKEVENT UserEvent ;
	union  {
		struct  {
			PIO_APC_ROUTINE UserApcRoutine ;
			PVOID UserApcContext ;
		} AsynchronousParameters ;
		LARGE_INTEGER AllocationSize ;
	} Overlay ;
	PDRIVER_CANCEL CancelRoutine ;
	PVOID UserBuffer ;
	union  {
		struct  {
			union  {
				KDEVICE_QUEUE_ENTRY DeviceQueueEntry ;
				struct  {
					PVOID DriverContext[4] ;
				}  ;
			}  ;
			PETHREAD Thread ;
			PCHAR AuxiliaryBuffer ;
			struct  {
				LIST_ENTRY ListEntry ;
				union  {
					struct _IO_STACK_LOCATION * 
						CurrentStackLocation ;
					ULONG PacketType ;
				}  ;
			}  ;
			PFILE_OBJECT OriginalFileObject ;
		} Overlay ;
		KAPC Apc ;
		PVOID CompletionKey ;
	} Tail ;
} IRP , *  PIRP ;

#line 14078
typedef NTSTATUS ( *  PIO_COMPLETION_ROUTINE )(PDEVICE_OBJECT DeviceObject ,
	PIRP Irp , PVOID Context ) ;

#line 14163
typedef enum _DEVICE_RELATION_TYPE {
	BusRelations,
	EjectionRelations,
	PowerRelations,
	RemovalRelations,
	TargetDeviceRelation
} DEVICE_RELATION_TYPE , *  PDEVICE_RELATION_TYPE ;

typedef struct _DEVICE_RELATIONS {
	ULONG Count ;
	PDEVICE_OBJECT Objects[1] ;
} DEVICE_RELATIONS , *  PDEVICE_RELATIONS ;

typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE {
	DeviceUsageTypeUndefined,
	DeviceUsageTypePaging,
	DeviceUsageTypeHibernation,
	DeviceUsageTypeDumpFile
} DEVICE_USAGE_NOTIFICATION_TYPE ;

#line 14185
typedef struct _INTERFACE {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
} INTERFACE , *  PINTERFACE ;

#line 14196
typedef struct _DEVICE_CAPABILITIES {
	USHORT Size ;
	USHORT Version ;
	ULONG DeviceD1  : 1;
	ULONG DeviceD2  : 1;
	ULONG LockSupported  : 1;
	ULONG EjectSupported  : 1;
	ULONG Removable  : 1;
	ULONG DockDevice  : 1;
	ULONG UniqueID  : 1;
	ULONG SilentInstall  : 1;
	ULONG RawDeviceOK  : 1;
	ULONG SurpriseRemovalOK  : 1;
	ULONG WakeFromD0  : 1;
	ULONG WakeFromD1  : 1;
	ULONG WakeFromD2  : 1;
	ULONG WakeFromD3  : 1;
	ULONG HardwareDisabled  : 1;
	ULONG NonDynamic  : 1;
	ULONG WarmEjectSupported  : 1;
	ULONG Reserved  : 15;
	ULONG Address ;
	ULONG UINumber ;
	DEVICE_POWER_STATE DeviceState[PowerSystemMaximum] ;
	SYSTEM_POWER_STATE SystemWake ;
	DEVICE_POWER_STATE DeviceWake ;
	ULONG D1Latency ;
	ULONG D2Latency ;
	ULONG D3Latency ;
} DEVICE_CAPABILITIES , *  PDEVICE_CAPABILITIES ;

#line 14229
typedef struct _POWER_SEQUENCE {
	ULONG SequenceD1 ;
	ULONG SequenceD2 ;
	ULONG SequenceD3 ;
} POWER_SEQUENCE , *  PPOWER_SEQUENCE ;

typedef enum  {
	BusQueryDeviceID = 0,
	BusQueryHardwareIDs = 1,
	BusQueryCompatibleIDs = 2,
	BusQueryInstanceID = 3,
	BusQueryDeviceSerialNumber = 4
} BUS_QUERY_ID_TYPE , *  PBUS_QUERY_ID_TYPE ;

typedef ULONG PNP_DEVICE_STATE , *  PPNP_DEVICE_STATE ;

#line 14252
typedef enum  {
	DeviceTextDescription = 0,
	DeviceTextLocationInformation = 1
} DEVICE_TEXT_TYPE , *  PDEVICE_TEXT_TYPE ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION {
	UCHAR MajorFunction ;
	UCHAR MinorFunction ;
	UCHAR Flags ;
	UCHAR Control ;
	union  {
		struct  {
			PIO_SECURITY_CONTEXT SecurityContext ;
			ULONG Options ;
			USHORT FileAttributes ;
			USHORT ShareAccess ;
			ULONG EaLength ;
		} Create ;
		struct  {
			ULONG Length ;
			ULONG Key ;
			LARGE_INTEGER ByteOffset ;
		} Read ;
		struct  {
			ULONG Length ;
			ULONG Key ;
			LARGE_INTEGER ByteOffset ;
		} Write ;
		struct  {
			ULONG Length ;
			FILE_INFORMATION_CLASS FileInformationClass ;
		} QueryFile ;
		struct  {
			ULONG Length ;
			FILE_INFORMATION_CLASS FileInformationClass ;
			PFILE_OBJECT FileObject ;
			union  {
				struct  {
					BOOLEAN ReplaceIfExists ;
					BOOLEAN AdvanceOnly ;
				}  ;
				ULONG ClusterCount ;
				HANDLE DeleteHandle ;
			}  ;
		} SetFile ;
		struct  {
			ULONG Length ;
			FS_INFORMATION_CLASS FsInformationClass ;
		} QueryVolume ;
		struct  {
			ULONG OutputBufferLength ;
			ULONG InputBufferLength ;
			ULONG IoControlCode ;
			PVOID Type3InputBuffer ;
		} DeviceIoControl ;
		struct  {
			SECURITY_INFORMATION SecurityInformation ;
			ULONG Length ;
		} QuerySecurity ;
		struct  {
			SECURITY_INFORMATION SecurityInformation ;
			PSECURITY_DESCRIPTOR SecurityDescriptor ;
		} SetSecurity ;
		struct  {
			PVPB Vpb ;
			PDEVICE_OBJECT DeviceObject ;
		} MountVolume ;
		struct  {
			PVPB Vpb ;
			PDEVICE_OBJECT DeviceObject ;
		} VerifyVolume ;
		struct  {
			struct _SCSI_REQUEST_BLOCK *  Srb ;
		} Scsi ;
		struct  {
			DEVICE_RELATION_TYPE Type ;
		} QueryDeviceRelations ;
		struct  {
			const GUID *  InterfaceType ;
			USHORT Size ;
			USHORT Version ;
			PINTERFACE Interface ;
			PVOID InterfaceSpecificData ;
		} QueryInterface ;
		struct  {
			PDEVICE_CAPABILITIES Capabilities ;
		} DeviceCapabilities ;
		struct  {
			PIO_RESOURCE_REQUIREMENTS_LIST IoResourceRequirementList
				;
		} FilterResourceRequirements ;
		struct  {
			ULONG WhichSpace ;
			PVOID Buffer ;
			ULONG Offset ;
			ULONG Length ;
		} ReadWriteConfig ;
		struct  {
			BOOLEAN Lock ;
		} SetLock ;
		struct  {
			BUS_QUERY_ID_TYPE IdType ;
		} QueryId ;
		struct  {
			DEVICE_TEXT_TYPE DeviceTextType ;
			LCID LocaleId ;
		} QueryDeviceText ;
		struct  {
			BOOLEAN InPath ;
			BOOLEAN Reserved[3] ;
			DEVICE_USAGE_NOTIFICATION_TYPE Type ;
		} UsageNotification ;
		struct  {
			SYSTEM_POWER_STATE PowerState ;
		} WaitWake ;
		struct  {
			PPOWER_SEQUENCE PowerSequence ;
		} PowerSequence ;
		struct  {
			ULONG SystemContext ;
			POWER_STATE_TYPE Type ;
			POWER_STATE State ;
			POWER_ACTION ShutdownType ;
		} Power ;
		struct  {
			PCM_RESOURCE_LIST AllocatedResources ;
			PCM_RESOURCE_LIST AllocatedResourcesTranslated ;
		} StartDevice ;
		struct  {
			ULONG_PTR ProviderId ;
			PVOID DataPath ;
			ULONG BufferSize ;
			PVOID Buffer ;
		} WMI ;
		struct  {
			PVOID Argument1 ;
			PVOID Argument2 ;
			PVOID Argument3 ;
			PVOID Argument4 ;
		} Others ;
	} Parameters ;
	PDEVICE_OBJECT DeviceObject ;
	PFILE_OBJECT FileObject ;
	PIO_COMPLETION_ROUTINE CompletionRoutine ;
	PVOID Context ;
} IO_STACK_LOCATION , *  PIO_STACK_LOCATION ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 14615 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SHARE_ACCESS {
	ULONG OpenCount ;
	ULONG Readers ;
	ULONG Writers ;
	ULONG Deleters ;
	ULONG SharedRead ;
	ULONG SharedWrite ;
	ULONG SharedDelete ;
} SHARE_ACCESS , *  PSHARE_ACCESS ;

#line 14635
typedef struct _CONFIGURATION_INFORMATION {
	ULONG DiskCount ;
	ULONG FloppyCount ;
	ULONG CdRomCount ;
	ULONG TapeCount ;
	ULONG ScsiPortCount ;
	ULONG SerialCount ;
	ULONG ParallelCount ;
	BOOLEAN AtDiskPrimaryAddressClaimed ;
	BOOLEAN AtDiskSecondaryAddressClaimed ;
	ULONG Version ;
	ULONG MediumChangerCount ;
} CONFIGURATION_INFORMATION , *  PCONFIGURATION_INFORMATION ;

#line 14681
__declspec(dllimport) void IoAcquireCancelSpinLock(PKIRQL Irql ) ;
#line 14688
__declspec(dllimport) NTSTATUS IoAllocateAdapterChannel(PADAPTER_OBJECT
	AdapterObject , PDEVICE_OBJECT DeviceObject , ULONG NumberOfMapRegisters
	, PDRIVER_CONTROL ExecutionRoutine , PVOID Context ) ;
#line 14698
__declspec(dllimport) void IoAllocateController(PCONTROLLER_OBJECT
	ControllerObject , PDEVICE_OBJECT DeviceObject , PDRIVER_CONTROL
	ExecutionRoutine , PVOID Context ) ;
#line 14709
__declspec(dllimport) NTSTATUS IoAllocateDriverObjectExtension(PDRIVER_OBJECT
	DriverObject , PVOID ClientIdentificationAddress , ULONG
	DriverObjectExtensionSize , PVOID *  DriverObjectExtension ) ;
#line 14720
__declspec(dllimport) PVOID IoAllocateErrorLogEntry(PVOID IoObject , UCHAR
	EntrySize ) ;
#line 14727
__declspec(dllimport) PIRP IoAllocateIrp(CCHAR StackSize , BOOLEAN ChargeQuota )
	;
#line 14734
__declspec(dllimport) PMDL IoAllocateMdl(PVOID VirtualAddress , ULONG Length ,
	BOOLEAN SecondaryBuffer , BOOLEAN ChargeQuota , PIRP Irp ) ;
#line 14776
__declspec(dllimport) NTSTATUS IoAssignResources(PUNICODE_STRING RegistryPath ,
	PUNICODE_STRING DriverClassName , PDRIVER_OBJECT DriverObject ,
	PDEVICE_OBJECT DeviceObject , PIO_RESOURCE_REQUIREMENTS_LIST
	RequestedResources , PCM_RESOURCE_LIST *  AllocatedResources ) ;
#line 14788
__declspec(dllimport) NTSTATUS IoAttachDevice(PDEVICE_OBJECT SourceDevice ,
	PUNICODE_STRING TargetDevice , PDEVICE_OBJECT *  AttachedDevice ) ;
#line 14798
__declspec(dllimport) NTSTATUS IoAttachDeviceByPointer(PDEVICE_OBJECT
	SourceDevice , PDEVICE_OBJECT TargetDevice ) ;
#line 14807
__declspec(dllimport) PDEVICE_OBJECT IoAttachDeviceToDeviceStack(PDEVICE_OBJECT
	SourceDevice , PDEVICE_OBJECT TargetDevice ) ;
#line 14814
__declspec(dllimport) PIRP IoBuildAsynchronousFsdRequest(ULONG MajorFunction ,
	PDEVICE_OBJECT DeviceObject , PVOID Buffer , ULONG Length ,
	PLARGE_INTEGER StartingOffset , PIO_STATUS_BLOCK IoStatusBlock ) ;
#line 14825
__declspec(dllimport) PIRP IoBuildDeviceIoControlRequest(ULONG IoControlCode ,
	PDEVICE_OBJECT DeviceObject , PVOID InputBuffer , ULONG
	InputBufferLength , PVOID OutputBuffer , ULONG OutputBufferLength ,
	BOOLEAN InternalDeviceIoControl , PKEVENT Event , PIO_STATUS_BLOCK
	IoStatusBlock ) ;
#line 14839
__declspec(dllimport) void IoBuildPartialMdl(PMDL SourceMdl , PMDL TargetMdl ,
	PVOID VirtualAddress , ULONG Length ) ;

#line 14848
typedef struct _BOOTDISK_INFORMATION {
	LONGLONG BootPartitionOffset ;
	LONGLONG SystemPartitionOffset ;
	ULONG BootDeviceSignature ;
	ULONG SystemDeviceSignature ;
} BOOTDISK_INFORMATION , *  PBOOTDISK_INFORMATION ;

__declspec(dllimport) NTSTATUS IoGetBootDiskInformation(PBOOTDISK_INFORMATION
	BootDiskInformation , ULONG Size ) ;
#line 14863
__declspec(dllimport) PIRP IoBuildSynchronousFsdRequest(ULONG MajorFunction ,
	PDEVICE_OBJECT DeviceObject , PVOID Buffer , ULONG Length ,
	PLARGE_INTEGER StartingOffset , PKEVENT Event , PIO_STATUS_BLOCK
	IoStatusBlock ) ;
#line 14875
__declspec(dllimport) NTSTATUS _fastcall IofCallDriver(PDEVICE_OBJECT
	DeviceObject , PIRP Irp ) ;
#line 14886
__declspec(dllimport) BOOLEAN IoCancelIrp(PIRP Irp ) ;
#line 14893
__declspec(dllimport) NTSTATUS IoCheckShareAccess(ACCESS_MASK DesiredAccess ,
	ULONG DesiredShareAccess , PFILE_OBJECT FileObject , PSHARE_ACCESS
	ShareAccess , BOOLEAN Update ) ;
#line 14903
__declspec(dllimport) void _fastcall IofCompleteRequest(PIRP Irp , CCHAR
	PriorityBoost ) ;
#line 14916
__declspec(dllimport) NTSTATUS IoConnectInterrupt(PKINTERRUPT *  InterruptObject
	, PKSERVICE_ROUTINE ServiceRoutine , PVOID ServiceContext , PKSPIN_LOCK
	SpinLock , ULONG Vector , KIRQL Irql , KIRQL SynchronizeIrql ,
	KINTERRUPT_MODE InterruptMode , BOOLEAN ShareVector , KAFFINITY
	ProcessorEnableMask , BOOLEAN FloatingSave ) ;
#line 14934
__declspec(dllimport) PCONTROLLER_OBJECT IoCreateController(ULONG Size ) ;
#line 14942
__declspec(dllimport) NTSTATUS IoCreateDevice(PDRIVER_OBJECT DriverObject ,
	ULONG DeviceExtensionSize , PUNICODE_STRING DeviceName , ULONG
	DeviceType , ULONG DeviceCharacteristics , BOOLEAN Exclusive ,
	PDEVICE_OBJECT *  DeviceObject ) ;
#line 14957
__declspec(dllimport) BOOLEAN IoIsWdmVersionAvailable(UCHAR MajorVersion , UCHAR
	MinorVersion ) ;
#line 14966
__declspec(dllimport) NTSTATUS IoCreateFile(PHANDLE FileHandle , ACCESS_MASK
	DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes , PIO_STATUS_BLOCK
	IoStatusBlock , PLARGE_INTEGER AllocationSize , ULONG FileAttributes ,
	ULONG ShareAccess , ULONG Disposition , ULONG CreateOptions , PVOID
	EaBuffer , ULONG EaLength , CREATE_FILE_TYPE CreateFileType , PVOID
	ExtraCreateParameters , ULONG Options ) ;
#line 14986
__declspec(dllimport) PKEVENT IoCreateNotificationEvent(PUNICODE_STRING
	EventName , PHANDLE EventHandle ) ;
#line 14993
__declspec(dllimport) NTSTATUS IoCreateSymbolicLink(PUNICODE_STRING
	SymbolicLinkName , PUNICODE_STRING DeviceName ) ;
#line 15002
__declspec(dllimport) PKEVENT IoCreateSynchronizationEvent(PUNICODE_STRING
	EventName , PHANDLE EventHandle ) ;
#line 15011
__declspec(dllimport) NTSTATUS IoCreateUnprotectedSymbolicLink(PUNICODE_STRING
	SymbolicLinkName , PUNICODE_STRING DeviceName ) ;
#line 15049
__declspec(dllimport) void IoDeleteController(PCONTROLLER_OBJECT
	ControllerObject ) ;
#line 15057
__declspec(dllimport) void IoDeleteDevice(PDEVICE_OBJECT DeviceObject ) ;
#line 15063
__declspec(dllimport) NTSTATUS IoDeleteSymbolicLink(PUNICODE_STRING
	SymbolicLinkName ) ;
#line 15069
__declspec(dllimport) void IoDetachDevice(PDEVICE_OBJECT TargetDevice ) ;
#line 15077
__declspec(dllimport) void IoDisconnectInterrupt(PKINTERRUPT InterruptObject ) ;
#line 15084
__declspec(dllimport) void IoFreeController(PCONTROLLER_OBJECT ControllerObject
	) ;
#line 15092
__declspec(dllimport) void IoFreeIrp(PIRP Irp ) ;
#line 15098
__declspec(dllimport) void IoFreeMdl(PMDL Mdl ) ;
#line 15104
__declspec(dllimport) PDEVICE_OBJECT IoGetAttachedDeviceReference(PDEVICE_OBJECT
	DeviceObject ) ;
#line 15110
__declspec(dllimport) PCONFIGURATION_INFORMATION
	IoGetConfigurationInformation(void  ) ;
#line 15141
__declspec(dllimport) PDEVICE_OBJECT IoGetDeviceToVerify(PETHREAD Thread ) ;
#line 15149
__declspec(dllimport) PVOID IoGetDriverObjectExtension(PDRIVER_OBJECT
	DriverObject , PVOID ClientIdentificationAddress ) ;
#line 15156
__declspec(dllimport) PEPROCESS IoGetCurrentProcess(void  ) ;
#line 15164
__declspec(dllimport) NTSTATUS IoGetDeviceObjectPointer(PUNICODE_STRING
	ObjectName , ACCESS_MASK DesiredAccess , PFILE_OBJECT *  FileObject ,
	PDEVICE_OBJECT *  DeviceObject ) ;
#line 15173
__declspec(dllimport) struct _DMA_ADAPTER *  IoGetDmaAdapter(PDEVICE_OBJECT
	PhysicalDeviceObject , struct _DEVICE_DESCRIPTION *  DeviceDescription ,
	PULONG NumberOfMapRegisters ) ;
#line 15183
__declspec(dllimport) PGENERIC_MAPPING IoGetFileObjectGenericMapping(void  ) ;
#line 15228
__declspec(dllimport) PVOID IoGetInitialStack(void  ) ;
#line 15234
__declspec(dllimport) void IoGetStackLimits(PULONG_PTR LowLimit , PULONG_PTR
	HighLimit ) ;

#line 15246
__inline ULONG_PTR IoGetRemainingStackSize(void  )
{
	#line 15252
	ULONG_PTR Top ;
	ULONG_PTR Bottom ;
	#line 15255
	IoGetStackLimits(& Bottom, & Top);
	return (ULONG_PTR )(& Top) - Bottom;
}

#line 15286
__declspec(dllimport) PDEVICE_OBJECT IoGetRelatedDeviceObject(PFILE_OBJECT
	FileObject ) ;
#line 15326
__declspec(dllimport) void IoInitializeIrp(PIRP Irp , USHORT PacketSize , CCHAR
	StackSize ) ;
#line 15334
__declspec(dllimport) NTSTATUS IoInitializeTimer(PDEVICE_OBJECT DeviceObject ,
	PIO_TIMER_ROUTINE TimerRoutine , PVOID Context ) ;
#line 15343
__declspec(dllimport) void IoReuseIrp(PIRP Irp , NTSTATUS Iostatus ) ;
#line 15351
__declspec(dllimport) void IoCancelFileOpen(PDEVICE_OBJECT DeviceObject ,
	PFILE_OBJECT FileObject ) ;
#line 15390
__declspec(dllimport) PIRP IoMakeAssociatedIrp(PIRP Irp , CCHAR StackSize ) ;
#line 15426
__declspec(dllimport) NTSTATUS IoQueryDeviceDescription(PINTERFACE_TYPE BusType
	, PULONG BusNumber , PCONFIGURATION_TYPE ControllerType , PULONG
	ControllerNumber , PCONFIGURATION_TYPE PeripheralType , PULONG
	PeripheralNumber , PIO_QUERY_DEVICE_ROUTINE CalloutRoutine , PVOID
	Context ) ;
#line 15439
__declspec(dllimport) void IoRaiseHardError(PIRP Irp , PVPB Vpb , PDEVICE_OBJECT
	RealDeviceObject ) ;
#line 15447
__declspec(dllimport) BOOLEAN IoRaiseInformationalHardError(NTSTATUS ErrorStatus
	, PUNICODE_STRING String , PKTHREAD Thread ) ;
#line 15455
__declspec(dllimport) BOOLEAN IoSetThreadHardErrorMode(BOOLEAN EnableHardErrors
	) ;
#line 15461
__declspec(dllimport) void IoRegisterBootDriverReinitialization(PDRIVER_OBJECT
	DriverObject , PDRIVER_REINITIALIZE DriverReinitializationRoutine ,
	PVOID Context ) ;
#line 15469
__declspec(dllimport) void IoRegisterDriverReinitialization(PDRIVER_OBJECT
	DriverObject , PDRIVER_REINITIALIZE DriverReinitializationRoutine ,
	PVOID Context ) ;
#line 15478
__declspec(dllimport) NTSTATUS IoRegisterShutdownNotification(PDEVICE_OBJECT
	DeviceObject ) ;
#line 15484
__declspec(dllimport) NTSTATUS
	IoRegisterLastChanceShutdownNotification(PDEVICE_OBJECT DeviceObject ) ;
#line 15492
__declspec(dllimport) void IoReleaseCancelSpinLock(KIRQL Irql ) ;
#line 15499
__declspec(dllimport) void IoRemoveShareAccess(PFILE_OBJECT FileObject ,
	PSHARE_ACCESS ShareAccess ) ;
#line 15507
__declspec(dllimport) NTSTATUS IoReportResourceUsage(PUNICODE_STRING
	DriverClassName , PDRIVER_OBJECT DriverObject , PCM_RESOURCE_LIST
	DriverList , ULONG DriverListSize , PDEVICE_OBJECT DeviceObject ,
	PCM_RESOURCE_LIST DeviceList , ULONG DeviceListSize , BOOLEAN
	OverrideConflict , PBOOLEAN ConflictDetected ) ;
#line 15641
__declspec(dllimport) void IoSetHardErrorOrVerifyDevice(PIRP Irp ,
	PDEVICE_OBJECT DeviceObject ) ;
#line 15743
__declspec(dllimport) void IoSetShareAccess(ACCESS_MASK DesiredAccess , ULONG
	DesiredShareAccess , PFILE_OBJECT FileObject , PSHARE_ACCESS ShareAccess
	) ;

#line 15754
typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK *  PIO_REMOVE_LOCK_TRACKING_BLOCK
	;

#line 15756
typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK {
	BOOLEAN Removed ;
	BOOLEAN Reserved[3] ;
	LONG IoCount ;
	KEVENT RemoveEvent ;
} IO_REMOVE_LOCK_COMMON_BLOCK ;

#line 15764
typedef struct _IO_REMOVE_LOCK_DBG_BLOCK {
	LONG Signature ;
	LONG HighWatermark ;
	LONGLONG MaxLockedTicks ;
	LONG AllocateTag ;
	LIST_ENTRY LockList ;
	KSPIN_LOCK Spin ;
	LONG LowMemoryCount ;
	ULONG Reserved1[4] ;
	PVOID Reserved2 ;
	PIO_REMOVE_LOCK_TRACKING_BLOCK Blocks ;
} IO_REMOVE_LOCK_DBG_BLOCK ;

typedef struct _IO_REMOVE_LOCK {
	IO_REMOVE_LOCK_COMMON_BLOCK Common ;
} IO_REMOVE_LOCK , *  PIO_REMOVE_LOCK ;

#line 15787
__declspec(dllimport) void __stdcall IoInitializeRemoveLockEx(PIO_REMOVE_LOCK
	Lock , ULONG AllocateTag , ULONG MaxLockedMinutes , ULONG HighWatermark
	, ULONG RemlockSize ) ;
#line 15808
__declspec(dllimport) NTSTATUS __stdcall IoAcquireRemoveLockEx(PIO_REMOVE_LOCK
	RemoveLock , PVOID Tag , PCSTR File , ULONG Line , ULONG RemlockSize ) ;
#line 15857
__declspec(dllimport) void __stdcall IoReleaseRemoveLockEx(PIO_REMOVE_LOCK
	RemoveLock , PVOID Tag , ULONG RemlockSize ) ;
#line 15893
__declspec(dllimport) void __stdcall
	IoReleaseRemoveLockAndWaitEx(PIO_REMOVE_LOCK RemoveLock , PVOID Tag ,
	ULONG RemlockSize ) ;
#line 15949
__declspec(dllimport) void IoStartNextPacket(PDEVICE_OBJECT DeviceObject ,
	BOOLEAN Cancelable ) ;
#line 15956
__declspec(dllimport) void IoStartNextPacketByKey(PDEVICE_OBJECT DeviceObject ,
	BOOLEAN Cancelable , ULONG Key ) ;
#line 15964
__declspec(dllimport) void IoStartPacket(PDEVICE_OBJECT DeviceObject , PIRP Irp
	, PULONG Key , PDRIVER_CANCEL CancelFunction ) ;
#line 15975
__declspec(dllimport) void IoStartTimer(PDEVICE_OBJECT DeviceObject ) ;
#line 15981
__declspec(dllimport) void IoStopTimer(PDEVICE_OBJECT DeviceObject ) ;
#line 15988
__declspec(dllimport) void IoUnregisterShutdownNotification(PDEVICE_OBJECT
	DeviceObject ) ;
#line 15996
__declspec(dllimport) void IoUpdateShareAccess(PFILE_OBJECT FileObject ,
	PSHARE_ACCESS ShareAccess ) ;
#line 16003
__declspec(dllimport) void IoWriteErrorLogEntry(PVOID ElEntry ) ;

#line 16009
typedef struct _IO_WORKITEM *  PIO_WORKITEM ;

typedef void ( *  PIO_WORKITEM_ROUTINE )(PDEVICE_OBJECT DeviceObject , PVOID
	Context ) ;

#line 16018
PIO_WORKITEM IoAllocateWorkItem(PDEVICE_OBJECT DeviceObject ) ;
#line 16023
void IoFreeWorkItem(PIO_WORKITEM IoWorkItem ) ;
#line 16028
void IoQueueWorkItem(PIO_WORKITEM IoWorkItem , PIO_WORKITEM_ROUTINE
	WorkerRoutine , WORK_QUEUE_TYPE QueueType , PVOID Context ) ;
#line 16040
__declspec(dllimport) NTSTATUS IoWMIRegistrationControl(PDEVICE_OBJECT
	DeviceObject , ULONG Action ) ;
#line 16064
__declspec(dllimport) NTSTATUS IoWMIAllocateInstanceIds(GUID *  Guid , ULONG
	InstanceCount , ULONG *  FirstInstanceId ) ;
#line 16072
__declspec(dllimport) NTSTATUS IoWMISuggestInstanceName(PDEVICE_OBJECT
	PhysicalDeviceObject , PUNICODE_STRING SymbolicLinkName , BOOLEAN
	CombineNames , PUNICODE_STRING SuggestedInstanceName ) ;
#line 16081
__declspec(dllimport) NTSTATUS IoWMIWriteEvent(PVOID WnodeEventItem ) ;

#line 16100
typedef enum  {
	DevicePropertyDeviceDescription,
	DevicePropertyHardwareID,
	DevicePropertyCompatibleIDs,
	DevicePropertyBootConfiguration,
	DevicePropertyBootConfigurationTranslated,
	DevicePropertyClassName,
	DevicePropertyClassGuid,
	DevicePropertyDriverKeyName,
	DevicePropertyManufacturer,
	DevicePropertyFriendlyName,
	DevicePropertyLocationInformation,
	DevicePropertyPhysicalDeviceObjectName,
	DevicePropertyBusTypeGuid,
	DevicePropertyLegacyBusType,
	DevicePropertyBusNumber,
	DevicePropertyEnumeratorName,
	DevicePropertyAddress,
	DevicePropertyUINumber
} DEVICE_REGISTRY_PROPERTY ;

typedef BOOLEAN ( *  PTRANSLATE_BUS_ADDRESS )(PVOID Context , PHYSICAL_ADDRESS
	BusAddress , ULONG Length , PULONG AddressSpace , PPHYSICAL_ADDRESS
	TranslatedAddress ) ;

#line 16129
typedef struct _DMA_ADAPTER *  ( *  PGET_DMA_ADAPTER )(PVOID Context ,
	struct _DEVICE_DESCRIPTION *  DeviceDescriptor , PULONG
	NumberOfMapRegisters ) ;

#line 16135
typedef ULONG ( *  PGET_SET_DEVICE_DATA )(PVOID Context , ULONG DataType , PVOID
	Buffer , ULONG Offset , ULONG Length ) ;

#line 16148
typedef struct _PNP_BUS_INFORMATION {
	GUID BusTypeGuid ;
	INTERFACE_TYPE LegacyBusType ;
	ULONG BusNumber ;
} PNP_BUS_INFORMATION , *  PPNP_BUS_INFORMATION ;

#line 16162
typedef struct _LEGACY_BUS_INFORMATION {
	GUID BusTypeGuid ;
	INTERFACE_TYPE LegacyBusType ;
	ULONG BusNumber ;
} LEGACY_BUS_INFORMATION , *  PLEGACY_BUS_INFORMATION ;

typedef struct _BUS_INTERFACE_STANDARD {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PTRANSLATE_BUS_ADDRESS TranslateBusAddress ;
	PGET_DMA_ADAPTER GetDmaAdapter ;
	PGET_SET_DEVICE_DATA SetBusData ;
	PGET_SET_DEVICE_DATA GetBusData ;
} BUS_INTERFACE_STANDARD , *  PBUS_INTERFACE_STANDARD ;

#line 16190
typedef BOOLEAN ( *  PGPE_SERVICE_ROUTINE )(PVOID , PVOID ) ;

#line 16194
typedef NTSTATUS ( *  PGPE_CONNECT_VECTOR )(PDEVICE_OBJECT , ULONG ,
	KINTERRUPT_MODE , BOOLEAN , PGPE_SERVICE_ROUTINE , PVOID , PVOID ) ;

#line 16203
typedef NTSTATUS ( *  PGPE_DISCONNECT_VECTOR )(PVOID ) ;

#line 16206
typedef NTSTATUS ( *  PGPE_ENABLE_EVENT )(PDEVICE_OBJECT , PVOID ) ;

#line 16210
typedef NTSTATUS ( *  PGPE_DISABLE_EVENT )(PDEVICE_OBJECT , PVOID ) ;

#line 16214
typedef NTSTATUS ( *  PGPE_CLEAR_STATUS )(PDEVICE_OBJECT , PVOID ) ;

#line 16218
typedef void ( *  PDEVICE_NOTIFY_CALLBACK )(PVOID , ULONG ) ;

#line 16222
typedef NTSTATUS ( *  PREGISTER_FOR_DEVICE_NOTIFICATIONS )(PDEVICE_OBJECT ,
	PDEVICE_NOTIFY_CALLBACK , PVOID ) ;

#line 16227
typedef void ( *  PUNREGISTER_FOR_DEVICE_NOTIFICATIONS )(PDEVICE_OBJECT ,
	PDEVICE_NOTIFY_CALLBACK ) ;

#line 16231
typedef struct _ACPI_INTERFACE_STANDARD {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PGPE_CONNECT_VECTOR GpeConnectVector ;
	PGPE_DISCONNECT_VECTOR GpeDisconnectVector ;
	PGPE_ENABLE_EVENT GpeEnableEvent ;
	PGPE_DISABLE_EVENT GpeDisableEvent ;
	PGPE_CLEAR_STATUS GpeClearStatus ;
	PREGISTER_FOR_DEVICE_NOTIFICATIONS RegisterForDeviceNotifications ;
	PUNREGISTER_FOR_DEVICE_NOTIFICATIONS UnregisterForDeviceNotifications ;
} ACPI_INTERFACE_STANDARD , *  PACPI_INTERFACE_STANDARD ;

#line 16255
typedef enum _ACPI_REG_TYPE {
	PM1a_ENABLE,
	PM1b_ENABLE,
	PM1a_STATUS,
	PM1b_STATUS,
	PM1a_CONTROL,
	PM1b_CONTROL,
	GP_STATUS,
	GP_ENABLE,
	SMI_CMD,
	MaxRegType
} ACPI_REG_TYPE , *  PACPI_REG_TYPE ;

typedef USHORT ( *  PREAD_ACPI_REGISTER )(ACPI_REG_TYPE AcpiReg , ULONG Register
	) ;

#line 16272
typedef void ( *  PWRITE_ACPI_REGISTER )(ACPI_REG_TYPE AcpiReg , ULONG Register
	, USHORT Value ) ;

#line 16278
typedef struct ACPI_REGS_INTERFACE_STANDARD {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PREAD_ACPI_REGISTER ReadAcpiRegister ;
	PWRITE_ACPI_REGISTER WriteAcpiRegister ;
} ACPI_REGS_INTERFACE_STANDARD , *  PACPI_REGS_INTERFACE_STANDARD ;

#line 16300
typedef struct  {
	PVOID LinkNode ;
	ULONG StaticVector ;
	UCHAR Flags ;
} ROUTING_TOKEN , *  PROUTING_TOKEN ;

#line 16314
typedef NTSTATUS ( *  PGET_INTERRUPT_ROUTING )(PDEVICE_OBJECT Pdo , ULONG *  Bus
	, ULONG *  PciSlot , UCHAR *  InterruptLine , UCHAR *  InterruptPin ,
	UCHAR *  ClassCode , UCHAR *  SubClassCode , PDEVICE_OBJECT *  ParentPdo
	, ROUTING_TOKEN *  RoutingToken , UCHAR *  Flags ) ;

#line 16329
typedef NTSTATUS ( *  PSET_INTERRUPT_ROUTING_TOKEN )(PDEVICE_OBJECT Pdo ,
	PROUTING_TOKEN RoutingToken ) ;

#line 16336
typedef void ( *  PUPDATE_INTERRUPT_LINE )(PDEVICE_OBJECT Pdo , UCHAR
	LineRegister ) ;

#line 16343
typedef struct _INT_ROUTE_INTERFACE_STANDARD {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PGET_INTERRUPT_ROUTING GetInterruptRouting ;
	PSET_INTERRUPT_ROUTING_TOKEN SetInterruptRoutingToken ;
	PUPDATE_INTERRUPT_LINE UpdateInterruptLine ;
} INT_ROUTE_INTERFACE_STANDARD , *  PINT_ROUTE_INTERFACE_STANDARD ;

#line 16366
typedef struct _IO_ASSIGNED_RESOURCES {
	ULONG Count ;
	PASSIGNED_RESOURCE AssignedResources[1] ;
} IO_ASSIGNED_RESOURCES , *  PIO_ASSIGNED_RESOURCES ;

__declspec(dllimport) NTSTATUS
	IoGetAssignedResourcesForSuballocation(INTERFACE_TYPE InterfaceType ,
	ULONG BusNumber , ULONG SlotNumber , PIO_RESOURCE_DESCRIPTOR
	ResourceDescriptor , PIO_ASSIGNED_RESOURCES *  List ) ;
#line 16381
__declspec(dllimport) NTSTATUS IoReportDetectedDevice(PDRIVER_OBJECT
	DriverObject , INTERFACE_TYPE LegacyBusType , ULONG BusNumber , ULONG
	SlotNumber , PCM_RESOURCE_LIST ResourceList ,
	PIO_RESOURCE_REQUIREMENTS_LIST ResourceRequirements , BOOLEAN
	ResourceAssigned , PDEVICE_OBJECT *  DeviceObject ) ;
#line 16396
__declspec(dllimport) void IoInvalidateDeviceRelations(PDEVICE_OBJECT
	DeviceObject , DEVICE_RELATION_TYPE Type ) ;
#line 16403
__declspec(dllimport) void IoRequestDeviceEject(PDEVICE_OBJECT
	PhysicalDeviceObject ) ;
#line 16409
__declspec(dllimport) NTSTATUS IoGetDeviceProperty(PDEVICE_OBJECT DeviceObject ,
	DEVICE_REGISTRY_PROPERTY DeviceProperty , ULONG BufferLength , PVOID
	PropertyBuffer , PULONG ResultLength ) ;
#line 16427
__declspec(dllimport) NTSTATUS IoOpenDeviceRegistryKey(PDEVICE_OBJECT
	DeviceObject , ULONG DevInstKeyType , ACCESS_MASK DesiredAccess ,
	PHANDLE DevInstRegKey ) ;
#line 16436
__declspec(dllimport) NTSTATUS __stdcall
	IoRegisterDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject , const
	GUID *  InterfaceClassGuid , PUNICODE_STRING ReferenceString ,
	PUNICODE_STRING SymbolicLinkName ) ;
#line 16446
__declspec(dllimport) NTSTATUS IoOpenDeviceInterfaceRegistryKey(PUNICODE_STRING
	SymbolicLinkName , ACCESS_MASK DesiredAccess , PHANDLE
	DeviceInterfaceKey ) ;
#line 16456
__declspec(dllimport) NTSTATUS IoSetDeviceInterfaceState(PUNICODE_STRING
	SymbolicLinkName , BOOLEAN Enable ) ;
#line 16465
__declspec(dllimport) NTSTATUS __stdcall IoGetDeviceInterfaces(const GUID * 
	InterfaceClassGuid , PDEVICE_OBJECT PhysicalDeviceObject , ULONG Flags ,
	PWSTR *  SymbolicLinkList ) ;
#line 16477
__declspec(dllimport) NTSTATUS __stdcall
	IoGetDeviceInterfaceAlias(PUNICODE_STRING SymbolicLinkName , const GUID
	*  AliasInterfaceClassGuid , PUNICODE_STRING AliasSymbolicLinkName ) ;

#line 16490
typedef enum _IO_NOTIFICATION_EVENT_CATEGORY {
	EventCategoryReserved,
	EventCategoryHardwareProfileChange,
	EventCategoryDeviceInterfaceChange,
	EventCategoryTargetDeviceChange
} IO_NOTIFICATION_EVENT_CATEGORY ;

#line 16504
typedef NTSTATUS ( *  PDRIVER_NOTIFICATION_CALLBACK_ROUTINE )(PVOID
	NotificationStructure , PVOID Context ) ;

#line 16512
__declspec(dllimport) NTSTATUS
	IoRegisterPlugPlayNotification(IO_NOTIFICATION_EVENT_CATEGORY
	EventCategory , ULONG EventCategoryFlags , PVOID EventCategoryData ,
	PDRIVER_OBJECT DriverObject , PDRIVER_NOTIFICATION_CALLBACK_ROUTINE
	CallbackRoutine , PVOID Context , PVOID *  NotificationEntry ) ;
#line 16524
__declspec(dllimport) NTSTATUS IoUnregisterPlugPlayNotification(PVOID
	NotificationEntry ) ;
#line 16530
__declspec(dllimport) NTSTATUS IoReportTargetDeviceChange(PDEVICE_OBJECT
	PhysicalDeviceObject , PVOID NotificationStructure ) ;

#line 16537
typedef void ( *  PDEVICE_CHANGE_COMPLETE_CALLBACK )(PVOID Context ) ;

#line 16543
__declspec(dllimport) void IoInvalidateDeviceState(PDEVICE_OBJECT
	PhysicalDeviceObject ) ;
#line 16559
__declspec(dllimport) NTSTATUS
	IoReportTargetDeviceChangeAsynchronous(PDEVICE_OBJECT
	PhysicalDeviceObject , PVOID NotificationStructure ,
	PDEVICE_CHANGE_COMPLETE_CALLBACK Callback , PVOID Context ) ;

#line 16573
typedef enum _ARBITER_ACTION {
	ArbiterActionTestAllocation,
	ArbiterActionRetestAllocation,
	ArbiterActionCommitAllocation,
	ArbiterActionRollbackAllocation,
	ArbiterActionQueryAllocatedResources,
	ArbiterActionWriteReservedResources,
	ArbiterActionQueryConflict,
	ArbiterActionQueryArbitrate,
	ArbiterActionAddReserved,
	ArbiterActionBootAllocation
} ARBITER_ACTION , *  PARBITER_ACTION ;

typedef struct _ARBITER_CONFLICT_INFO {
	PDEVICE_OBJECT OwningObject ;
	ULONGLONG Start ;
	ULONGLONG End ;
} ARBITER_CONFLICT_INFO , *  PARBITER_CONFLICT_INFO ;

#line 16608
typedef struct _ARBITER_PARAMETERS {
	union  {
		struct  {
			PLIST_ENTRY ArbitrationList ;
			ULONG AllocateFromCount ;
			PCM_PARTIAL_RESOURCE_DESCRIPTOR AllocateFrom ;
		} TestAllocation ;
		struct  {
			PLIST_ENTRY ArbitrationList ;
			ULONG AllocateFromCount ;
			PCM_PARTIAL_RESOURCE_DESCRIPTOR AllocateFrom ;
		} RetestAllocation ;
		struct  {
			PLIST_ENTRY ArbitrationList ;
		} BootAllocation ;
		struct  {
			PCM_PARTIAL_RESOURCE_LIST *  AllocatedResources ;
		} QueryAllocatedResources ;
		struct  {
			PDEVICE_OBJECT PhysicalDeviceObject ;
			PIO_RESOURCE_DESCRIPTOR ConflictingResource ;
			PULONG ConflictCount ;
			PARBITER_CONFLICT_INFO *  Conflicts ;
		} QueryConflict ;
		struct  {
			PLIST_ENTRY ArbitrationList ;
		} QueryArbitrate ;
		struct  {
			PDEVICE_OBJECT ReserveDevice ;
		} AddReserved ;
	} Parameters ;
} ARBITER_PARAMETERS , *  PARBITER_PARAMETERS ;

#line 16719
typedef enum _ARBITER_REQUEST_SOURCE {
	ArbiterRequestUndefined = - 1,
	ArbiterRequestLegacyReported,
	ArbiterRequestHalReported,
	ArbiterRequestLegacyAssigned,
	ArbiterRequestPnpDetected,
	ArbiterRequestPnpEnumerated
} ARBITER_REQUEST_SOURCE ;

#line 16731
typedef enum _ARBITER_RESULT {
	ArbiterResultUndefined = - 1,
	ArbiterResultSuccess,
	ArbiterResultExternalConflict,
	ArbiterResultNullRequest
} ARBITER_RESULT ;

#line 16748
__declspec(dllimport) NTSTATUS IoReportResourceForDetection(PDRIVER_OBJECT
	DriverObject , PCM_RESOURCE_LIST DriverList , ULONG DriverListSize ,
	PDEVICE_OBJECT DeviceObject , PCM_RESOURCE_LIST DeviceList , ULONG
	DeviceListSize , PBOOLEAN ConflictDetected ) ;

#line 16761
typedef struct _ARBITER_LIST_ENTRY {
	LIST_ENTRY ListEntry ;
	ULONG AlternativeCount ;
	PIO_RESOURCE_DESCRIPTOR Alternatives ;
	PDEVICE_OBJECT PhysicalDeviceObject ;
	ARBITER_REQUEST_SOURCE RequestSource ;
	ULONG Flags ;
	LONG_PTR WorkSpace ;
	INTERFACE_TYPE InterfaceType ;
	ULONG SlotNumber ;
	ULONG BusNumber ;
	PCM_PARTIAL_RESOURCE_DESCRIPTOR Assignment ;
	PIO_RESOURCE_DESCRIPTOR SelectedAlternative ;
	ARBITER_RESULT Result ;
} ARBITER_LIST_ENTRY , *  PARBITER_LIST_ENTRY ;

#line 16832
typedef NTSTATUS ( *  PARBITER_HANDLER )(PVOID Context , ARBITER_ACTION Action ,
	PARBITER_PARAMETERS Parameters ) ;

#line 16853
typedef struct _ARBITER_INTERFACE {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PARBITER_HANDLER ArbiterHandler ;
	ULONG Flags ;
} ARBITER_INTERFACE , *  PARBITER_INTERFACE ;

#line 16880
typedef enum _RESOURCE_TRANSLATION_DIRECTION {
	TranslateChildToParent,
	TranslateParentToChild
} RESOURCE_TRANSLATION_DIRECTION ;

#line 16889
typedef NTSTATUS ( *  PTRANSLATE_RESOURCE_HANDLER )(PVOID Context ,
	PCM_PARTIAL_RESOURCE_DESCRIPTOR Source , RESOURCE_TRANSLATION_DIRECTION
	Direction , ULONG AlternativesCount , IO_RESOURCE_DESCRIPTOR
	Alternatives[] , PDEVICE_OBJECT PhysicalDeviceObject ,
	PCM_PARTIAL_RESOURCE_DESCRIPTOR Target ) ;

#line 16901
typedef NTSTATUS ( *  PTRANSLATE_RESOURCE_REQUIREMENTS_HANDLER )(PVOID Context ,
	PIO_RESOURCE_DESCRIPTOR Source , PDEVICE_OBJECT PhysicalDeviceObject ,
	PULONG TargetCount , PIO_RESOURCE_DESCRIPTOR *  Target ) ;

#line 16915
typedef struct _TRANSLATOR_INTERFACE {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PTRANSLATE_RESOURCE_HANDLER TranslateResources ;
	PTRANSLATE_RESOURCE_REQUIREMENTS_HANDLER TranslateResourceRequirements ;
} TRANSLATOR_INTERFACE , *  PTRANSLATOR_INTERFACE ;

#line 16931
typedef NTSTATUS ( *  PLEGACY_DEVICE_DETECTION_HANDLER )(PVOID Context ,
	INTERFACE_TYPE LegacyBusType , ULONG BusNumber , ULONG SlotNumber ,
	PDEVICE_OBJECT *  PhysicalDeviceObject ) ;

#line 16945
typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PLEGACY_DEVICE_DETECTION_HANDLER LegacyDeviceDetection ;
} LEGACY_DEVICE_DETECTION_INTERFACE , *  PLEGACY_DEVICE_DETECTION_INTERFACE ;

#line 16959
typedef struct _PLUGPLAY_NOTIFICATION_HEADER {
	USHORT Version ;
	USHORT Size ;
	GUID Event ;
} PLUGPLAY_NOTIFICATION_HEADER , *  PPLUGPLAY_NOTIFICATION_HEADER ;

#line 16972
typedef struct _HWPROFILE_CHANGE_NOTIFICATION {
	USHORT Version ;
	USHORT Size ;
	GUID Event ;
} HWPROFILE_CHANGE_NOTIFICATION , *  PHWPROFILE_CHANGE_NOTIFICATION ;

#line 16986
typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION {
	USHORT Version ;
	USHORT Size ;
	GUID Event ;
	GUID InterfaceClassGuid ;
	PUNICODE_STRING SymbolicLinkName ;
} DEVICE_INTERFACE_CHANGE_NOTIFICATION , * 
	PDEVICE_INTERFACE_CHANGE_NOTIFICATION ;

#line 17006
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION {
	USHORT Version ;
	USHORT Size ;
	GUID Event ;
	PFILE_OBJECT FileObject ;
} TARGET_DEVICE_REMOVAL_NOTIFICATION , *  PTARGET_DEVICE_REMOVAL_NOTIFICATION ;

#line 17026
typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION {
	USHORT Version ;
	USHORT Size ;
	GUID Event ;
	PFILE_OBJECT FileObject ;
	LONG NameBufferOffset ;
	UCHAR CustomDataBuffer[1] ;
} TARGET_DEVICE_CUSTOM_NOTIFICATION , *  PTARGET_DEVICE_CUSTOM_NOTIFICATION ;

#line 17054
typedef struct _DEVICE_DESCRIPTION {
	ULONG Version ;
	BOOLEAN Master ;
	BOOLEAN ScatterGather ;
	BOOLEAN DemandMode ;
	BOOLEAN AutoInitialize ;
	BOOLEAN Dma32BitAddresses ;
	BOOLEAN IgnoreCount ;
	BOOLEAN Reserved1 ;
	BOOLEAN Dma64BitAddresses ;
	ULONG BusNumber ;
	ULONG DmaChannel ;
	INTERFACE_TYPE InterfaceType ;
	DMA_WIDTH DmaWidth ;
	DMA_SPEED DmaSpeed ;
	ULONG MaximumLength ;
	ULONG DmaPort ;
} DEVICE_DESCRIPTION , *  PDEVICE_DESCRIPTION ;

#line 17086
typedef BOOLEAN ( *  PHAL_RESET_DISPLAY_PARAMETERS )(ULONG Columns , ULONG Rows
	) ;

#line 17093
__declspec(dllimport)
	void HalAcquireDisplayOwnership(PHAL_RESET_DISPLAY_PARAMETERS
	ResetDisplayParameters ) ;
#line 17114
__declspec(dllimport) void KeFlushWriteBuffer(void  ) ;
#line 17124
__declspec(dllimport) NTSTATUS HalAssignSlotResources(PUNICODE_STRING
	RegistryPath , PUNICODE_STRING DriverClassName , PDRIVER_OBJECT
	DriverObject , PDEVICE_OBJECT DeviceObject , INTERFACE_TYPE BusType ,
	ULONG BusNumber , ULONG SlotNumber , PCM_RESOURCE_LIST * 
	AllocatedResources ) ;
#line 17137
__declspec(dllimport) ULONG HalGetInterruptVector(INTERFACE_TYPE InterfaceType ,
	ULONG BusNumber , ULONG BusInterruptLevel , ULONG BusInterruptVector ,
	PKIRQL Irql , PKAFFINITY Affinity ) ;
#line 17148
__declspec(dllimport) ULONG HalSetBusData(BUS_DATA_TYPE BusDataType , ULONG
	BusNumber , ULONG SlotNumber , PVOID Buffer , ULONG Length ) ;
#line 17159
__declspec(dllimport) ULONG HalSetBusDataByOffset(BUS_DATA_TYPE BusDataType ,
	ULONG BusNumber , ULONG SlotNumber , PVOID Buffer , ULONG Offset , ULONG
	Length ) ;
#line 17170
__declspec(dllimport) BOOLEAN HalTranslateBusAddress(INTERFACE_TYPE
	InterfaceType , ULONG BusNumber , PHYSICAL_ADDRESS BusAddress , PULONG
	AddressSpace , PPHYSICAL_ADDRESS TranslatedAddress ) ;
#line 17196
__declspec(dllimport) PVOID HalAllocateCrashDumpRegisters(PADAPTER_OBJECT
	AdapterObject , PULONG NumberOfMapRegisters ) ;
#line 17204
__declspec(dllimport) ULONG HalGetBusData(BUS_DATA_TYPE BusDataType , ULONG
	BusNumber , ULONG SlotNumber , PVOID Buffer , ULONG Length ) ;
#line 17215
__declspec(dllimport) ULONG HalGetBusDataByOffset(BUS_DATA_TYPE BusDataType ,
	ULONG BusNumber , ULONG SlotNumber , PVOID Buffer , ULONG Offset , ULONG
	Length ) ;
#line 17226
__declspec(dllimport) PADAPTER_OBJECT HalGetAdapter(PDEVICE_DESCRIPTION
	DeviceDescription , PULONG NumberOfMapRegisters ) ;
#line 17237
__declspec(dllimport) BOOLEAN HalMakeBeep(ULONG Frequency ) ;
#line 17282
__declspec(dllimport) NTSTATUS IoReadPartitionTable(PDEVICE_OBJECT DeviceObject
	, ULONG SectorSize , BOOLEAN ReturnRecognizedPartitions ,
	struct _DRIVE_LAYOUT_INFORMATION *  *  PartitionBuffer ) ;
#line 17291
__declspec(dllimport) NTSTATUS IoSetPartitionInformation(PDEVICE_OBJECT
	DeviceObject , ULONG SectorSize , ULONG PartitionNumber , ULONG
	PartitionType ) ;
#line 17300
__declspec(dllimport) NTSTATUS IoWritePartitionTable(PDEVICE_OBJECT DeviceObject
	, ULONG SectorSize , ULONG SectorsPerTrack , ULONG NumberOfHeads ,
	struct _DRIVE_LAYOUT_INFORMATION *  PartitionBuffer ) ;
#line 17315
__declspec(dllimport) LARGE_INTEGER KeQueryPerformanceCounter(PLARGE_INTEGER
	PerformanceFrequency ) ;
#line 17326
__declspec(dllimport) void KeStallExecutionProcessor(ULONG MicroSeconds ) ;

#line 17333
typedef void ( *  PDEVICE_CONTROL_COMPLETION )(struct _DEVICE_CONTROL_CONTEXT * 
	ControlContext ) ;

#line 17339
typedef struct _DEVICE_CONTROL_CONTEXT {
	NTSTATUS Status ;
	PDEVICE_HANDLER_OBJECT DeviceHandler ;
	PDEVICE_OBJECT DeviceObject ;
	ULONG ControlCode ;
	PVOID Buffer ;
	PULONG BufferLength ;
	PVOID Context ;
} DEVICE_CONTROL_CONTEXT , *  PDEVICE_CONTROL_CONTEXT ;

typedef PBUS_HANDLER (_fastcall *  pHalHandlerForBus )(INTERFACE_TYPE
	InterfaceType , ULONG BusNumber ) ;

#line 17355
typedef void (_fastcall *  pHalReferenceBusHandler )(PBUS_HANDLER BusHandler ) ;

#line 17365
typedef enum _HAL_QUERY_INFORMATION_CLASS {
	HalInstalledBusInformation,
	HalProfileSourceInformation,
	HalInformationClassUnused1,
	HalPowerInformation,
	HalProcessorSpeedInformation,
	HalCallbackInformation,
	HalMapRegisterInformation,
	HalMcaLogInformation,
	HalFrameBufferCachingInformation,
	HalDisplayBiosInformation,
	HalProcessorFeatureInformation
} HAL_QUERY_INFORMATION_CLASS , *  PHAL_QUERY_INFORMATION_CLASS ;

#line 17381
typedef enum _HAL_SET_INFORMATION_CLASS {
	HalProfileSourceInterval,
	HalProfileSourceInterruptHandler,
	HalMcaRegisterDriver
} HAL_SET_INFORMATION_CLASS , *  PHAL_SET_INFORMATION_CLASS ;

#line 17388
typedef NTSTATUS ( *  pHalQuerySystemInformation )(HAL_QUERY_INFORMATION_CLASS
	InformationClass , ULONG BufferSize , PVOID Buffer , PULONG
	ReturnedLength ) ;

#line 17397
NTSTATUS HaliQuerySystemInformation(HAL_SET_INFORMATION_CLASS InformationClass ,
	ULONG BufferSize , PVOID Buffer , PULONG ReturnedLength ) ;

#line 17405
typedef NTSTATUS ( *  pHalSetSystemInformation )(HAL_SET_INFORMATION_CLASS
	InformationClass , ULONG BufferSize , PVOID Buffer ) ;

#line 17413
NTSTATUS HaliSetSystemInformation(HAL_SET_INFORMATION_CLASS InformationClass ,
	ULONG BufferSize , PVOID Buffer ) ;

#line 17420
typedef void (_fastcall *  pHalExamineMBR )(PDEVICE_OBJECT DeviceObject , ULONG
	SectorSize , ULONG MBRTypeIdentifier , PVOID *  Buffer ) ;

#line 17429
typedef void (_fastcall *  pHalIoAssignDriveLetters
	)(struct _LOADER_PARAMETER_BLOCK *  LoaderBlock , PSTRING NtDeviceName ,
	PUCHAR NtSystemPath , PSTRING NtSystemPathString ) ;

#line 17438
typedef NTSTATUS (_fastcall *  pHalIoReadPartitionTable )(PDEVICE_OBJECT
	DeviceObject , ULONG SectorSize , BOOLEAN ReturnRecognizedPartitions ,
	struct _DRIVE_LAYOUT_INFORMATION *  *  PartitionBuffer ) ;

#line 17447
typedef NTSTATUS (_fastcall *  pHalIoSetPartitionInformation )(PDEVICE_OBJECT
	DeviceObject , ULONG SectorSize , ULONG PartitionNumber , ULONG
	PartitionType ) ;

#line 17456
typedef NTSTATUS (_fastcall *  pHalIoWritePartitionTable )(PDEVICE_OBJECT
	DeviceObject , ULONG SectorSize , ULONG SectorsPerTrack , ULONG
	NumberOfHeads , struct _DRIVE_LAYOUT_INFORMATION *  PartitionBuffer ) ;

#line 17466
typedef NTSTATUS ( *  pHalQueryBusSlots )(PBUS_HANDLER BusHandler , ULONG
	BufferSize , PULONG SlotNumbers , PULONG ReturnedLength ) ;

#line 17475
typedef NTSTATUS ( *  pHalInitPnpDriver )(void  ) ;

#line 17481
NTSTATUS HaliInitPnpDriver(void  ) ;

#line 17486
typedef struct _PM_DISPATCH_TABLE {
	ULONG Signature ;
	ULONG Version ;
	PVOID Function[1] ;
} PM_DISPATCH_TABLE , *  PPM_DISPATCH_TABLE ;

typedef NTSTATUS ( *  pHalInitPowerManagement )(PPM_DISPATCH_TABLE
	PmDriverDispatchTable , PPM_DISPATCH_TABLE *  PmHalDispatchTable ) ;

#line 17499
NTSTATUS HaliInitPowerManagement(PPM_DISPATCH_TABLE PmDriverDispatchTable ,
	PPM_DISPATCH_TABLE *  PmHalDispatchTable ) ;

#line 17505
typedef struct _DMA_ADAPTER *  ( *  pHalGetDmaAdapter )(PVOID Context ,
	struct _DEVICE_DESCRIPTION *  DeviceDescriptor , PULONG
	NumberOfMapRegisters ) ;

#line 17513
struct _DMA_ADAPTER *  HaliGetDmaAdapter(PVOID Context ,
	struct _DEVICE_DESCRIPTION *  DeviceDescriptor , PULONG
	NumberOfMapRegisters ) ;

#line 17520
typedef NTSTATUS ( *  pHalGetInterruptTranslator )(INTERFACE_TYPE
	ParentInterfaceType , ULONG ParentBusNumber , INTERFACE_TYPE
	BridgeInterfaceType , USHORT Size , USHORT Version ,
	PTRANSLATOR_INTERFACE Translator , PULONG BridgeBusNumber ) ;

#line 17532
NTSTATUS HaliGetInterruptTranslator(INTERFACE_TYPE ParentInterfaceType , ULONG
	ParentBusNumber , INTERFACE_TYPE BridgeInterfaceType , USHORT Size ,
	USHORT Version , PTRANSLATOR_INTERFACE Translator , PULONG
	BridgeBusNumber ) ;

#line 17543
typedef BOOLEAN ( *  pHalTranslateBusAddress )(INTERFACE_TYPE InterfaceType ,
	ULONG BusNumber , PHYSICAL_ADDRESS BusAddress , PULONG AddressSpace ,
	PPHYSICAL_ADDRESS TranslatedAddress ) ;

#line 17553
typedef NTSTATUS ( *  pHalAssignSlotResources )(PUNICODE_STRING RegistryPath ,
	PUNICODE_STRING DriverClassName , PDRIVER_OBJECT DriverObject ,
	PDEVICE_OBJECT DeviceObject , INTERFACE_TYPE BusType , ULONG BusNumber ,
	ULONG SlotNumber , PCM_RESOURCE_LIST *  AllocatedResources ) ;

#line 17566
typedef void ( *  pHalHaltSystem )(void  ) ;

#line 17572
typedef void ( *  pHalResetDisplay )(void  ) ;

#line 17578
typedef BOOLEAN ( *  pHalFindBusAddressTranslation )(PHYSICAL_ADDRESS BusAddress
	, PULONG AddressSpace , PPHYSICAL_ADDRESS TranslatedAddress , PULONG_PTR
	Context , BOOLEAN NextBus ) ;

#line 17588
typedef struct  {
	ULONG Version ;
	pHalQuerySystemInformation HalQuerySystemInformation ;
	pHalSetSystemInformation HalSetSystemInformation ;
	pHalQueryBusSlots HalQueryBusSlots ;
	ULONG Spare1 ;
	pHalExamineMBR HalExamineMBR ;
	pHalIoAssignDriveLetters HalIoAssignDriveLetters ;
	pHalIoReadPartitionTable HalIoReadPartitionTable ;
	pHalIoSetPartitionInformation HalIoSetPartitionInformation ;
	pHalIoWritePartitionTable HalIoWritePartitionTable ;
	pHalHandlerForBus HalReferenceHandlerForBus ;
	pHalReferenceBusHandler HalReferenceBusHandler ;
	pHalReferenceBusHandler HalDereferenceBusHandler ;
	pHalInitPnpDriver HalInitPnpDriver ;
	pHalInitPowerManagement HalInitPowerManagement ;
	pHalGetDmaAdapter HalGetDmaAdapter ;
	pHalGetInterruptTranslator HalGetInterruptTranslator ;
} HAL_DISPATCH , *  PHAL_DISPATCH ;

#line 17613
extern PHAL_DISPATCH HalDispatchTable ;

#line 17650
typedef struct _HAL_BUS_INFORMATION {
	INTERFACE_TYPE BusType ;
	BUS_DATA_TYPE ConfigurationType ;
	ULONG BusNumber ;
	ULONG Reserved ;
} HAL_BUS_INFORMATION , *  PHAL_BUS_INFORMATION ;

#line 17658
typedef struct _HAL_PROFILE_SOURCE_INFORMATION {
	KPROFILE_SOURCE Source ;
	BOOLEAN Supported ;
	ULONG Interval ;
} HAL_PROFILE_SOURCE_INFORMATION , *  PHAL_PROFILE_SOURCE_INFORMATION ;

#line 17665
typedef struct _HAL_PROFILE_SOURCE_INTERVAL {
	KPROFILE_SOURCE Source ;
	ULONG_PTR Interval ;
} HAL_PROFILE_SOURCE_INTERVAL , *  PHAL_PROFILE_SOURCE_INTERVAL ;

#line 17671
typedef enum _HAL_DISPLAY_BIOS_INFORMATION {
	HalDisplayInt10Bios,
	HalDisplayEmulatedBios,
	HalDisplayNoBios
} HAL_DISPLAY_BIOS_INFORMATION , *  PHAL_DISPLAY_BIOS_INFORMATION ;

#line 17678
typedef struct _HAL_POWER_INFORMATION {
	ULONG TBD ;
} HAL_POWER_INFORMATION , *  PHAL_POWER_INFORMATION ;

#line 17683
typedef struct _HAL_PROCESSOR_SPEED_INFO {
	ULONG TBD ;
} HAL_PROCESSOR_SPEED_INFORMATION , *  PHAL_PROCESSOR_SPEED_INFORMATION ;

#line 17688
typedef struct _HAL_CALLBACKS {
	PCALLBACK_OBJECT___0 SetSystemInformation ;
	PCALLBACK_OBJECT___0 BusCheck ;
} HAL_CALLBACKS , *  PHAL_CALLBACKS ;

#line 17694
typedef struct _HAL_PROCESSOR_FEATURE {
	ULONG UsableFeatureBits ;
} HAL_PROCESSOR_FEATURE ;

#line 17706
typedef union _MCI_ADDR {
	struct  {
		ULONG Address ;
		ULONG Reserved ;
	}  ;
	ULONGLONG QuadPart ;
} MCI_ADDR , *  PMCI_ADDR ;

#line 17716
typedef enum  {
	HAL_MCE_RECORD,
	HAL_MCA_RECORD
} MCA_EXCEPTION_TYPE ;

#line 17726
typedef struct _MCA_EXCEPTION {
	ULONG VersionNumber ;
	MCA_EXCEPTION_TYPE ExceptionType ;
	LARGE_INTEGER TimeStamp ;
	ULONG ProcessorNumber ;
	union  {
		struct  {
			UCHAR BankNumber ;
			MCI_STATS Status ;
			MCI_ADDR Address ;
			ULONGLONG Misc ;
		} Mca ;
		struct  {
			ULONGLONG Address ;
			ULONGLONG Type ;
		} Mce ;
	} u ;
} MCA_EXCEPTION , *  PMCA_EXCEPTION ;

#line 17752
typedef void ( *  PDRIVER_EXCPTN_CALLBACK )(PVOID Context , PMCA_EXCEPTION
	BankLog ) ;

#line 17762
typedef struct _MCA_DRIVER_INFO {
	PDRIVER_EXCPTN_CALLBACK ExceptionCallback ;
	PKDEFERRED_ROUTINE DpcCallback ;
	PVOID DeviceContext ;
} MCA_DRIVER_INFO , *  PMCA_DRIVER_INFO ;

#line 17772
typedef struct _SCATTER_GATHER_ELEMENT {
	PHYSICAL_ADDRESS Address ;
	ULONG Length ;
	ULONG_PTR Reserved ;
} SCATTER_GATHER_ELEMENT , *  PSCATTER_GATHER_ELEMENT ;


#pragma warning(disable:4200)
#line 17779
typedef struct _SCATTER_GATHER_LIST {
	ULONG NumberOfElements ;
	ULONG_PTR Reserved ;
	SCATTER_GATHER_ELEMENT Elements[] ;
} SCATTER_GATHER_LIST , *  PSCATTER_GATHER_LIST ;

#line 17784

#pragma warning(default:4200)
#line 17788
typedef struct _DMA_OPERATIONS *  PDMA_OPERATIONS ;

typedef struct _DMA_ADAPTER {
	USHORT Version ;
	USHORT Size ;
	PDMA_OPERATIONS DmaOperations ;
} DMA_ADAPTER , *  PDMA_ADAPTER ;

#line 17797
typedef void ( *  PPUT_DMA_ADAPTER )(PDMA_ADAPTER DmaAdapter ) ;

#line 17801
typedef PVOID ( *  PALLOCATE_COMMON_BUFFER )(PDMA_ADAPTER DmaAdapter , ULONG
	Length , PPHYSICAL_ADDRESS LogicalAddress , BOOLEAN CacheEnabled ) ;

#line 17808
typedef void ( *  PFREE_COMMON_BUFFER )(PDMA_ADAPTER DmaAdapter , ULONG Length ,
	PHYSICAL_ADDRESS LogicalAddress , PVOID VirtualAddress , BOOLEAN
	CacheEnabled ) ;

#line 17816
typedef NTSTATUS ( *  PALLOCATE_ADAPTER_CHANNEL )(PDMA_ADAPTER DmaAdapter ,
	PDEVICE_OBJECT DeviceObject , ULONG NumberOfMapRegisters ,
	PDRIVER_CONTROL ExecutionRoutine , PVOID Context ) ;

#line 17824
typedef BOOLEAN ( *  PFLUSH_ADAPTER_BUFFERS )(PDMA_ADAPTER DmaAdapter , PMDL Mdl
	, PVOID MapRegisterBase , PVOID CurrentVa , ULONG Length , BOOLEAN
	WriteToDevice ) ;

#line 17833
typedef void ( *  PFREE_ADAPTER_CHANNEL )(PDMA_ADAPTER DmaAdapter ) ;

#line 17837
typedef void ( *  PFREE_MAP_REGISTERS )(PDMA_ADAPTER DmaAdapter , PVOID
	MapRegisterBase , ULONG NumberOfMapRegisters ) ;

#line 17843
typedef PHYSICAL_ADDRESS ( *  PMAP_TRANSFER )(PDMA_ADAPTER DmaAdapter , PMDL Mdl
	, PVOID MapRegisterBase , PVOID CurrentVa , PULONG Length , BOOLEAN
	WriteToDevice ) ;

#line 17852
typedef ULONG ( *  PGET_DMA_ALIGNMENT )(PDMA_ADAPTER DmaAdapter ) ;

#line 17856
typedef ULONG ( *  PREAD_DMA_COUNTER )(PDMA_ADAPTER DmaAdapter ) ;

#line 17860
typedef void ( *  PDRIVER_LIST_CONTROL )(struct _DEVICE_OBJECT *  DeviceObject ,
	struct _IRP *  Irp , PSCATTER_GATHER_LIST ScatterGather , PVOID Context
	) ;

#line 17868
typedef NTSTATUS ( *  PGET_SCATTER_GATHER_LIST )(PDMA_ADAPTER DmaAdapter ,
	PDEVICE_OBJECT DeviceObject , PMDL Mdl , PVOID CurrentVa , ULONG Length
	, PDRIVER_LIST_CONTROL ExecutionRoutine , PVOID Context , BOOLEAN
	WriteToDevice ) ;

#line 17880
typedef void ( *  PPUT_SCATTER_GATHER_LIST )(PDMA_ADAPTER DmaAdapter ,
	PSCATTER_GATHER_LIST ScatterGather , BOOLEAN WriteToDevice ) ;

#line 17887
typedef struct _DMA_OPERATIONS {
	ULONG Size ;
	PPUT_DMA_ADAPTER PutDmaAdapter ;
	PALLOCATE_COMMON_BUFFER AllocateCommonBuffer ;
	PFREE_COMMON_BUFFER FreeCommonBuffer ;
	PALLOCATE_ADAPTER_CHANNEL AllocateAdapterChannel ;
	PFLUSH_ADAPTER_BUFFERS FlushAdapterBuffers ;
	PFREE_ADAPTER_CHANNEL FreeAdapterChannel ;
	PFREE_MAP_REGISTERS FreeMapRegisters ;
	PMAP_TRANSFER MapTransfer ;
	PGET_DMA_ALIGNMENT GetDmaAlignment ;
	PREAD_DMA_COUNTER ReadDmaCounter ;
	PGET_SCATTER_GATHER_LIST GetScatterGatherList ;
	PPUT_SCATTER_GATHER_LIST PutScatterGatherList ;
} DMA_OPERATIONS ;

#line 18126
__declspec(dllimport) NTSTATUS HalAllocateAdapterChannel(PADAPTER_OBJECT
	AdapterObject , PWAIT_CONTEXT_BLOCK Wcb , ULONG NumberOfMapRegisters ,
	PDRIVER_CONTROL ExecutionRoutine ) ;
#line 18135
__declspec(dllimport) PVOID HalAllocateCommonBuffer(PADAPTER_OBJECT
	AdapterObject , ULONG Length , PPHYSICAL_ADDRESS LogicalAddress ,
	BOOLEAN CacheEnabled ) ;
#line 18144
__declspec(dllimport) void HalFreeCommonBuffer(PADAPTER_OBJECT AdapterObject ,
	ULONG Length , PHYSICAL_ADDRESS LogicalAddress , PVOID VirtualAddress ,
	BOOLEAN CacheEnabled ) ;
#line 18154
__declspec(dllimport) ULONG HalReadDmaCounter(PADAPTER_OBJECT AdapterObject ) ;
#line 18160
__declspec(dllimport) BOOLEAN IoFlushAdapterBuffers(PADAPTER_OBJECT
	AdapterObject , PMDL Mdl , PVOID MapRegisterBase , PVOID CurrentVa ,
	ULONG Length , BOOLEAN WriteToDevice ) ;
#line 18171
__declspec(dllimport) void IoFreeAdapterChannel(PADAPTER_OBJECT AdapterObject )
	;
#line 18177
__declspec(dllimport) void IoFreeMapRegisters(PADAPTER_OBJECT AdapterObject ,
	PVOID MapRegisterBase , ULONG NumberOfMapRegisters ) ;
#line 18185
__declspec(dllimport) PHYSICAL_ADDRESS IoMapTransfer(PADAPTER_OBJECT
	AdapterObject , PMDL Mdl , PVOID MapRegisterBase , PVOID CurrentVa ,
	PULONG Length , BOOLEAN WriteToDevice ) ;
#line 18197
NTSTATUS HalGetScatterGatherList(PADAPTER_OBJECT DmaAdapter , PDEVICE_OBJECT
	DeviceObject , PMDL Mdl , PVOID CurrentVa , ULONG Length ,
	PDRIVER_LIST_CONTROL ExecutionRoutine , PVOID Context , BOOLEAN
	WriteToDevice ) ;
#line 18209
void HalPutScatterGatherList(PADAPTER_OBJECT DmaAdapter , PSCATTER_GATHER_LIST
	ScatterGather , BOOLEAN WriteToDevice ) ;
#line 18216
void HalPutDmaAdapter(PADAPTER_OBJECT DmaAdapter ) ;
#line 18222
__declspec(dllimport) void PoSetSystemState(EXECUTION_STATE Flags ) ;
#line 18228
__declspec(dllimport) PVOID PoRegisterSystemState(PVOID StateHandle ,
	EXECUTION_STATE Flags ) ;

#line 18235
typedef void ( *  PREQUEST_POWER_COMPLETE )(PDEVICE_OBJECT DeviceObject , UCHAR
	MinorFunction , POWER_STATE PowerState , PVOID Context ,
	PIO_STATUS_BLOCK IoStatus ) ;

#line 18245
__declspec(dllimport) NTSTATUS PoRequestPowerIrp(PDEVICE_OBJECT DeviceObject ,
	UCHAR MinorFunction , POWER_STATE PowerState , PREQUEST_POWER_COMPLETE
	CompletionFunction , PVOID Context , PIRP *  Irp ) ;
#line 18256
__declspec(dllimport) void PoUnregisterSystemState(PVOID StateHandle ) ;
#line 18263
__declspec(dllimport) POWER_STATE PoSetPowerState(PDEVICE_OBJECT DeviceObject ,
	POWER_STATE_TYPE Type , POWER_STATE State ) ;
#line 18271
__declspec(dllimport) NTSTATUS PoCallDriver(PDEVICE_OBJECT DeviceObject , PIRP
	Irp ) ;
#line 18278
__declspec(dllimport) void PoStartNextPowerIrp(PIRP Irp ) ;
#line 18285
__declspec(dllimport) PULONG PoRegisterDeviceForIdleDetection(PDEVICE_OBJECT
	DeviceObject , ULONG ConservationIdleTime , ULONG PerformanceIdleTime ,
	DEVICE_POWER_STATE State ) ;
#line 18311
__declspec(dllimport) BOOLEAN FsRtlIsTotalDeviceFailure(NTSTATUS Status ) ;

#line 18321
typedef struct _OBJECT_HANDLE_INFORMATION {
	ULONG HandleAttributes ;
	ACCESS_MASK GrantedAccess ;
} OBJECT_HANDLE_INFORMATION , *  POBJECT_HANDLE_INFORMATION ;

__declspec(dllimport) NTSTATUS ObReferenceObjectByHandle(HANDLE Handle ,
	ACCESS_MASK DesiredAccess , POBJECT_TYPE ObjectType , KPROCESSOR_MODE
	AccessMode , PVOID *  Object , POBJECT_HANDLE_INFORMATION
	HandleInformation ) ;
#line 18342
__declspec(dllimport) void _fastcall ObfReferenceObject(PVOID Object ) ;
#line 18350
__declspec(dllimport) NTSTATUS ObReferenceObjectByPointer(PVOID Object ,
	ACCESS_MASK DesiredAccess , POBJECT_TYPE ObjectType , KPROCESSOR_MODE
	AccessMode ) ;
#line 18359
__declspec(dllimport) void _fastcall ObfDereferenceObject(PVOID Object ) ;
#line 18366
NTSTATUS ObGetObjectSecurity(PVOID Object , PSECURITY_DESCRIPTOR * 
	SecurityDescriptor , PBOOLEAN MemoryAllocated ) ;
#line 18373
void ObReleaseObjectSecurity(PSECURITY_DESCRIPTOR SecurityDescriptor , BOOLEAN
	MemoryAllocated ) ;

#line 18402
typedef struct _PCI_SLOT_NUMBER {
	union  {
		struct  {
			ULONG DeviceNumber  : 5;
			ULONG FunctionNumber  : 3;
			ULONG Reserved  : 24;
		} bits ;
		ULONG AsULONG ;
	} u ;
} PCI_SLOT_NUMBER , *  PPCI_SLOT_NUMBER ;

#line 18418
typedef struct _PCI_COMMON_CONFIG {
	USHORT VendorID ;
	USHORT DeviceID ;
	USHORT Command ;
	USHORT Status ;
	UCHAR RevisionID ;
	UCHAR ProgIf ;
	UCHAR SubClass ;
	UCHAR BaseClass ;
	UCHAR CacheLineSize ;
	UCHAR LatencyTimer ;
	UCHAR HeaderType ;
	UCHAR BIST ;
	union  {
		struct _PCI_HEADER_TYPE_0 {
			ULONG BaseAddresses[6] ;
			ULONG CIS ;
			USHORT SubVendorID ;
			USHORT SubSystemID ;
			ULONG ROMBaseAddress ;
			UCHAR CapabilitiesPtr ;
			UCHAR Reserved1[3] ;
			ULONG Reserved2 ;
			UCHAR InterruptLine ;
			UCHAR InterruptPin ;
			UCHAR MinimumGrant ;
			UCHAR MaximumLatency ;
		} type0 ;
		struct _PCI_HEADER_TYPE_1 {
			ULONG BaseAddresses[2] ;
			UCHAR PrimaryBus ;
			UCHAR SecondaryBus ;
			UCHAR SubordinateBus ;
			UCHAR SecondaryLatency ;
			UCHAR IOBase ;
			UCHAR IOLimit ;
			USHORT SecondaryStatus ;
			USHORT MemoryBase ;
			USHORT MemoryLimit ;
			USHORT PrefetchBase ;
			USHORT PrefetchLimit ;
			ULONG PrefetchBaseUpper32 ;
			ULONG PrefetchLimitUpper32 ;
			USHORT IOBaseUpper16 ;
			USHORT IOLimitUpper16 ;
			UCHAR CapabilitiesPtr ;
			UCHAR Reserved1[3] ;
			ULONG ROMBaseAddress ;
			UCHAR InterruptLine ;
			UCHAR InterruptPin ;
			USHORT BridgeControl ;
		} type1 ;
		struct _PCI_HEADER_TYPE_2 {
			ULONG SocketRegistersBaseAddress ;
			UCHAR CapabilitiesPtr ;
			UCHAR Reserved ;
			USHORT SecondaryStatus ;
			UCHAR PrimaryBus ;
			UCHAR SecondaryBus ;
			UCHAR SubordinateBus ;
			UCHAR SecondaryLatency ;
			struct  {
				ULONG Base ;
				ULONG Limit ;
			} Range[5 - 1] ;
			UCHAR InterruptLine ;
			UCHAR InterruptPin ;
			USHORT BridgeControl ;
		} type2 ;
	} u ;
	UCHAR DeviceSpecific[192] ;
} PCI_COMMON_CONFIG , *  PPCI_COMMON_CONFIG ;

#line 18591
typedef struct _PCI_CAPABILITIES_HEADER {
	UCHAR CapabilityID ;
	UCHAR Next ;
} PCI_CAPABILITIES_HEADER , *  PPCI_CAPABILITIES_HEADER ;

#line 18600
typedef struct _PCI_PMC {
	UCHAR Version  : 3;
	UCHAR PMEClock  : 1;
	UCHAR Rsvd1  : 1;
	UCHAR DeviceSpecificInitialization  : 1;
	UCHAR Rsvd2  : 2;
	struct _PM_SUPPORT {
		UCHAR Rsvd2  : 1;
		UCHAR D1  : 1;
		UCHAR D2  : 1;
		UCHAR PMED0  : 1;
		UCHAR PMED1  : 1;
		UCHAR PMED2  : 1;
		UCHAR PMED3Hot  : 1;
		UCHAR PMED3Cold  : 1;
	} Support ;
} PCI_PMC , *  PPCI_PMC ;

typedef struct _PCI_PMCSR {
	USHORT PowerState  : 2;
	USHORT Rsvd1  : 6;
	USHORT PMEEnable  : 1;
	USHORT DataSelect  : 4;
	USHORT DataScale  : 2;
	USHORT PMEStatus  : 1;
} PCI_PMCSR , *  PPCI_PMCSR ;

#line 18628
typedef struct _PCI_PMCSR_BSE {
	UCHAR Rsvd1  : 6;
	UCHAR D3HotSupportsStopClock  : 1;
	UCHAR BusPowerClockControlEnabled  : 1;
} PCI_PMCSR_BSE , *  PPCI_PMCSR_BSE ;

#line 18635
typedef struct _PCI_PM_CAPABILITY {
	PCI_CAPABILITIES_HEADER Header ;
	union  {
		PCI_PMC Capabilities ;
		USHORT AsUSHORT ;
	} PMC ;
	union  {
		PCI_PMCSR ControlStatus ;
		USHORT AsUSHORT ;
	} PMCSR ;
	union  {
		PCI_PMCSR_BSE BridgeSupport ;
		UCHAR AsUCHAR ;
	} PMCSR_BSE ;
	UCHAR Data ;
} PCI_PM_CAPABILITY , *  PPCI_PM_CAPABILITY ;

#line 18679
typedef struct _PCI_AGP_CAPABILITY {
	PCI_CAPABILITIES_HEADER Header ;
	USHORT Minor  : 4;
	USHORT Major  : 4;
	USHORT Rsvd1  : 8;
	struct _PCI_AGP_STATUS {
		ULONG Rate  : 3;
		ULONG Rsvd1  : 1;
		ULONG FastWrite  : 1;
		ULONG FourGB  : 1;
		ULONG Rsvd2  : 3;
		ULONG SideBandAddressing  : 1;
		ULONG Rsvd3  : 14;
		ULONG RequestQueueDepthMaximum  : 8;
	} AGPStatus ;
	struct _PCI_AGP_COMMAND {
		ULONG Rate  : 3;
		ULONG Rsvd1  : 1;
		ULONG FastWriteEnable  : 1;
		ULONG FourGBEnable  : 1;
		ULONG Rsvd2  : 2;
		ULONG AGPEnable  : 1;
		ULONG SBAEnable  : 1;
		ULONG Rsvd3  : 14;
		ULONG RequestQueueDepth  : 8;
	} AGPCommand ;
} PCI_AGP_CAPABILITY , *  PPCI_AGP_CAPABILITY ;

#line 18720
typedef struct _PCI_MSI_CAPABILITY {
	PCI_CAPABILITIES_HEADER Header ;
	struct _PCI_MSI_MESSAGE_CONTROL {
		USHORT MSIEnable  : 1;
		USHORT MultipleMessageCapable  : 3;
		USHORT MultipleMessageEnable  : 3;
		USHORT CapableOf64Bits  : 1;
		USHORT Reserved  : 8;
	} MessageControl ;
	union  {
		struct _PCI_MSI_MESSAGE_ADDRESS {
			ULONG_PTR Reserved  : 2;
			ULONG_PTR Address  : 30;
		} Register ;
		ULONG_PTR Raw ;
	} MessageAddress ;
	union  {
		struct _PCI_MSI_64BIT_DATA {
			ULONG MessageUpperAddress ;
			USHORT MessageData ;
		} Bit64 ;
		struct _PCI_MSI_32BIT_DATA {
			USHORT MessageData ;
			ULONG Unused ;
		} Bit32 ;
	} Data ;
} PCI_MSI_CAPABILITY , *  PPCI_PCI_CAPABILITY ;

#line 18946
typedef void ( *  PciPin2Line )(struct _BUS_HANDLER *  BusHandler ,
	struct _BUS_HANDLER *  RootHandler , PCI_SLOT_NUMBER SlotNumber ,
	PPCI_COMMON_CONFIG PciData ) ;

#line 18954
typedef void ( *  PciLine2Pin )(struct _BUS_HANDLER *  BusHandler ,
	struct _BUS_HANDLER *  RootHandler , PCI_SLOT_NUMBER SlotNumber ,
	PPCI_COMMON_CONFIG PciNewData , PPCI_COMMON_CONFIG PciOldData ) ;

#line 18963
typedef void ( *  PciReadWriteConfig )(struct _BUS_HANDLER *  BusHandler ,
	PCI_SLOT_NUMBER Slot , PVOID Buffer , ULONG Offset , ULONG Length ) ;

#line 18975
typedef struct _PCIBUSDATA {
	ULONG Tag ;
	ULONG Version ;
	PciReadWriteConfig ReadConfig ;
	PciReadWriteConfig WriteConfig ;
	PciPin2Line Pin2Line ;
	PciLine2Pin Line2Pin ;
	PCI_SLOT_NUMBER ParentSlot ;
	PVOID Reserved[4] ;
} PCIBUSDATA , *  PPCIBUSDATA ;

typedef ULONG ( *  PCI_READ_WRITE_CONFIG )(PVOID Context , UCHAR BusOffset ,
	ULONG Slot , PVOID Buffer , ULONG Offset , ULONG Length ) ;

#line 18995
typedef void ( *  PCI_PIN_TO_LINE )(PVOID Context , PPCI_COMMON_CONFIG PciData )
	;

#line 19000
typedef void ( *  PCI_LINE_TO_PIN )(PVOID Context , PPCI_COMMON_CONFIG
	PciNewData , PPCI_COMMON_CONFIG PciOldData ) ;

#line 19006
typedef struct _PCI_BUS_INTERFACE_STANDARD {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PCI_READ_WRITE_CONFIG ReadConfig ;
	PCI_READ_WRITE_CONFIG WriteConfig ;
	PCI_PIN_TO_LINE PinToLine ;
	PCI_LINE_TO_PIN LineToPin ;
} PCI_BUS_INTERFACE_STANDARD , *  PPCI_BUS_INTERFACE_STANDARD ;

#line 19028
typedef BOOLEAN ( *  PPCI_IS_DEVICE_PRESENT )(USHORT VendorID , USHORT DeviceID
	, UCHAR RevisionID , USHORT SubVendorID , USHORT SubSystemID , ULONG
	Flags ) ;

#line 19043
typedef struct _PCI_DEVICE_PRESENT_INTERFACE {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PPCI_IS_DEVICE_PRESENT IsDevicePresent ;
} PCI_DEVICE_PRESENT_INTERFACE , *  PPCI_DEVICE_PRESENT_INTERFACE ;

#line 19066
extern POBJECT_TYPE *  IoFileObjectType ;
extern POBJECT_TYPE *  ExEventObjectType ;
extern POBJECT_TYPE *  ExSemaphoreObjectType ;
#line 19074
__declspec(dllimport) NTSTATUS __stdcall ZwCreateFile(PHANDLE FileHandle ,
	ACCESS_MASK DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes ,
	PIO_STATUS_BLOCK IoStatusBlock , PLARGE_INTEGER AllocationSize , ULONG
	FileAttributes , ULONG ShareAccess , ULONG CreateDisposition , ULONG
	CreateOptions , PVOID EaBuffer , ULONG EaLength ) ;
#line 19091
__declspec(dllimport) NTSTATUS __stdcall ZwOpenFile(PHANDLE FileHandle ,
	ACCESS_MASK DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes ,
	PIO_STATUS_BLOCK IoStatusBlock , ULONG ShareAccess , ULONG OpenOptions )
	;
#line 19103
__declspec(dllimport) NTSTATUS __stdcall ZwQueryInformationFile(HANDLE
	FileHandle , PIO_STATUS_BLOCK IoStatusBlock , PVOID FileInformation ,
	ULONG Length , FILE_INFORMATION_CLASS FileInformationClass ) ;
#line 19114
__declspec(dllimport) NTSTATUS __stdcall ZwSetInformationFile(HANDLE FileHandle
	, PIO_STATUS_BLOCK IoStatusBlock , PVOID FileInformation , ULONG Length
	, FILE_INFORMATION_CLASS FileInformationClass ) ;
#line 19125
__declspec(dllimport) NTSTATUS __stdcall ZwReadFile(HANDLE FileHandle , HANDLE
	Event , PIO_APC_ROUTINE ApcRoutine , PVOID ApcContext , PIO_STATUS_BLOCK
	IoStatusBlock , PVOID Buffer , ULONG Length , PLARGE_INTEGER ByteOffset
	, PULONG Key ) ;
#line 19140
__declspec(dllimport) NTSTATUS __stdcall ZwWriteFile(HANDLE FileHandle , HANDLE
	Event , PIO_APC_ROUTINE ApcRoutine , PVOID ApcContext , PIO_STATUS_BLOCK
	IoStatusBlock , PVOID Buffer , ULONG Length , PLARGE_INTEGER ByteOffset
	, PULONG Key ) ;
#line 19155
__declspec(dllimport) NTSTATUS __stdcall ZwClose(HANDLE Handle ) ;
#line 19162
__declspec(dllimport) NTSTATUS __stdcall ZwCreateDirectoryObject(PHANDLE
	DirectoryHandle , ACCESS_MASK DesiredAccess , POBJECT_ATTRIBUTES
	ObjectAttributes ) ;
#line 19171
__declspec(dllimport) NTSTATUS __stdcall ZwMakeTemporaryObject(HANDLE Handle ) ;
#line 19178
__declspec(dllimport) NTSTATUS __stdcall ZwOpenSection(PHANDLE SectionHandle ,
	ACCESS_MASK DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes ) ;
#line 19187
__declspec(dllimport) NTSTATUS __stdcall ZwMapViewOfSection(HANDLE SectionHandle
	, HANDLE ProcessHandle , PVOID *  BaseAddress , ULONG ZeroBits , ULONG
	CommitSize , PLARGE_INTEGER SectionOffset , PSIZE_T ViewSize ,
	SECTION_INHERIT InheritDisposition , ULONG AllocationType , ULONG
	Protect ) ;
#line 19203
__declspec(dllimport) NTSTATUS __stdcall ZwUnmapViewOfSection(HANDLE
	ProcessHandle , PVOID BaseAddress ) ;
#line 19211
__declspec(dllimport) NTSTATUS __stdcall ZwSetInformationThread(HANDLE
	ThreadHandle , THREADINFOCLASS ThreadInformationClass , PVOID
	ThreadInformation , ULONG ThreadInformationLength ) ;
#line 19221
__declspec(dllimport) NTSTATUS __stdcall ZwCreateKey(PHANDLE KeyHandle ,
	ACCESS_MASK DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes , ULONG
	TitleIndex , PUNICODE_STRING Class , ULONG CreateOptions , PULONG
	Disposition ) ;
#line 19234
__declspec(dllimport) NTSTATUS __stdcall ZwOpenKey(PHANDLE KeyHandle ,
	ACCESS_MASK DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes ) ;
#line 19243
__declspec(dllimport) NTSTATUS __stdcall ZwDeleteKey(HANDLE KeyHandle ) ;
#line 19250
__declspec(dllimport) NTSTATUS __stdcall ZwEnumerateKey(HANDLE KeyHandle , ULONG
	Index , KEY_INFORMATION_CLASS KeyInformationClass , PVOID KeyInformation
	, ULONG Length , PULONG ResultLength ) ;
#line 19262
__declspec(dllimport) NTSTATUS __stdcall ZwEnumerateValueKey(HANDLE KeyHandle ,
	ULONG Index , KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass ,
	PVOID KeyValueInformation , ULONG Length , PULONG ResultLength ) ;
#line 19274
__declspec(dllimport) NTSTATUS __stdcall ZwFlushKey(HANDLE KeyHandle ) ;
#line 19281
__declspec(dllimport) NTSTATUS __stdcall ZwQueryKey(HANDLE KeyHandle ,
	KEY_INFORMATION_CLASS KeyInformationClass , PVOID KeyInformation , ULONG
	Length , PULONG ResultLength ) ;
#line 19292
__declspec(dllimport) NTSTATUS __stdcall ZwQueryValueKey(HANDLE KeyHandle ,
	PUNICODE_STRING ValueName , KEY_VALUE_INFORMATION_CLASS
	KeyValueInformationClass , PVOID KeyValueInformation , ULONG Length ,
	PULONG ResultLength ) ;
#line 19304
__declspec(dllimport) NTSTATUS __stdcall ZwSetValueKey(HANDLE KeyHandle ,
	PUNICODE_STRING ValueName , ULONG TitleIndex , ULONG Type , PVOID Data ,
	ULONG DataSize ) ;
#line 19316
__declspec(dllimport) NTSTATUS __stdcall ZwOpenSymbolicLinkObject(PHANDLE
	LinkHandle , ACCESS_MASK DesiredAccess , POBJECT_ATTRIBUTES
	ObjectAttributes ) ;
#line 19325
__declspec(dllimport) NTSTATUS __stdcall ZwQuerySymbolicLinkObject(HANDLE
	LinkHandle , PUNICODE_STRING LinkTarget , PULONG ReturnedLength ) ;
#line 19334
NTSTATUS ZwCreateTimer(PHANDLE TimerHandle , ACCESS_MASK DesiredAccess ,
	POBJECT_ATTRIBUTES ObjectAttributes , TIMER_TYPE TimerType ) ;
#line 19342
NTSTATUS ZwOpenTimer(PHANDLE TimerHandle , ACCESS_MASK DesiredAccess ,
	POBJECT_ATTRIBUTES ObjectAttributes ) ;
#line 19349
NTSTATUS ZwCancelTimer(HANDLE TimerHandle , PBOOLEAN CurrentState ) ;
#line 19355
NTSTATUS ZwSetTimer(HANDLE TimerHandle , PLARGE_INTEGER DueTime ,
	PTIMER_APC_ROUTINE TimerApcRoutine , PVOID TimerContext , BOOLEAN
	WakeTimer , LONG Period , PBOOLEAN PreviousState ) ;

#line 22 "C:/NTDDK/inc/ntdddisk.h"

#pragma once
#line 44 "C:/NTDDK/inc/ntddstor.h"
extern const GUID DiskClassGuid ;
extern const GUID CdRomClassGuid ;
extern const GUID PartitionClassGuid ;
extern const GUID TapeClassGuid ;
extern const GUID WriteOnceDiskClassGuid ;
extern const GUID VolumeClassGuid ;
extern const GUID MediumChangerClassGuid ;
extern const GUID FloppyClassGuid ;
extern const GUID CdChangerClassGuid ;
extern const GUID StoragePortClassGuid ;

#line 128
typedef struct _STORAGE_DEVICE_NUMBER {
	ULONG DeviceType ;
	ULONG DeviceNumber ;
	ULONG PartitionNumber ;
} STORAGE_DEVICE_NUMBER , *  PSTORAGE_DEVICE_NUMBER ;

#line 154
typedef struct _STORAGE_BUS_RESET_REQUEST {
	UCHAR PathId ;
} STORAGE_BUS_RESET_REQUEST , *  PSTORAGE_BUS_RESET_REQUEST ;

#line 168
typedef struct _PREVENT_MEDIA_REMOVAL {
	BOOLEAN PreventMediaRemoval ;
} PREVENT_MEDIA_REMOVAL , *  PPREVENT_MEDIA_REMOVAL ;

#line 175
typedef struct _TAPE_STATISTICS {
	ULONG Version ;
	ULONG Flags ;
	LARGE_INTEGER RecoveredWrites ;
	LARGE_INTEGER UnrecoveredWrites ;
	LARGE_INTEGER RecoveredReads ;
	LARGE_INTEGER UnrecoveredReads ;
	UCHAR CompressionRatioReads ;
	UCHAR CompressionRatioWrites ;
} TAPE_STATISTICS , *  PTAPE_STATISTICS ;

#line 193
typedef struct _TAPE_GET_STATISTICS {
	ULONG Operation ;
} TAPE_GET_STATISTICS , *  PTAPE_GET_STATISTICS ;

#line 206
typedef enum _STORAGE_MEDIA_TYPE {
	DDS_4mm = 0x20,
	MiniQic,
	Travan,
	QIC,
	MP_8mm,
	AME_8mm,
	AIT1_8mm,
	DLT,
	NCTP,
	IBM_3480,
	IBM_3490E,
	IBM_Magstar_3590,
	IBM_Magstar_MP,
	STK_DATA_D3,
	SONY_DTF,
	DV_6mm,
	DMI,
	SONY_D2,
	CLEANER_CARTRIDGE,
	CD_ROM,
	CD_R,
	CD_RW,
	DVD_ROM,
	DVD_R,
	DVD_RW,
	MO_3_RW,
	MO_5_WO,
	MO_5_RW,
	MO_5_LIMDOW,
	PC_5_WO,
	PC_5_RW,
	PD_5_RW,
	ABL_5_WO,
	PINNACLE_APEX_5_RW,
	SONY_12_WO,
	PHILIPS_12_WO,
	HITACHI_12_WO,
	CYGNET_12_WO,
	KODAK_14_WO,
	MO_NFR_525,
	NIKON_12_RW,
	IOMEGA_ZIP,
	IOMEGA_JAZ,
	SYQUEST_EZ135,
	SYQUEST_EZFLYER,
	SYQUEST_SYJET,
	AVATAR_F2,
	MP2_8mm,
	DST_S,
	DST_M,
	DST_L,
	VXATape_1,
	VXATape_2,
	STK_EAGLE,
	LTO_Ultrium,
	LTO_Accelis
} STORAGE_MEDIA_TYPE , *  PSTORAGE_MEDIA_TYPE ;

#line 306
typedef enum _STORAGE_BUS_TYPE {
	BusTypeUnknown = 0x00,
	BusTypeScsi,
	BusTypeAtapi,
	BusTypeAta,
	BusType1394,
	BusTypeSsa,
	BusTypeFibre,
	BusTypeUsb,
	BusTypeRAID,
	BusTypeMaxReserved = 0x7F
} STORAGE_BUS_TYPE , *  PSTORAGE_BUS_TYPE ;

typedef struct _DEVICE_MEDIA_INFO {
	union  {
		struct  {
			LARGE_INTEGER Cylinders ;
			STORAGE_MEDIA_TYPE MediaType ;
			ULONG TracksPerCylinder ;
			ULONG SectorsPerTrack ;
			ULONG BytesPerSector ;
			ULONG NumberMediaSides ;
			ULONG MediaCharacteristics ;
		} DiskInfo ;
		struct  {
			LARGE_INTEGER Cylinders ;
			STORAGE_MEDIA_TYPE MediaType ;
			ULONG TracksPerCylinder ;
			ULONG SectorsPerTrack ;
			ULONG BytesPerSector ;
			ULONG NumberMediaSides ;
			ULONG MediaCharacteristics ;
		} RemovableDiskInfo ;
		struct  {
			STORAGE_MEDIA_TYPE MediaType ;
			ULONG MediaCharacteristics ;
			ULONG CurrentBlockSize ;
			STORAGE_BUS_TYPE BusType ;
			union  {
				struct  {
					UCHAR MediumType ;
					UCHAR DensityCode ;
				} ScsiInformation ;
			} BusSpecificData ;
		} TapeInfo ;
	} DeviceSpecific ;
} DEVICE_MEDIA_INFO , *  PDEVICE_MEDIA_INFO ;

#line 362
typedef struct _GET_MEDIA_TYPES {
	ULONG DeviceType ;
	ULONG MediaInfoCount ;
	DEVICE_MEDIA_INFO MediaInfo[1] ;
} GET_MEDIA_TYPES , *  PGET_MEDIA_TYPES ;

#line 381
typedef struct _STORAGE_PREDICT_FAILURE {
	ULONG PredictFailure ;
	UCHAR VendorSpecific[512] ;
} STORAGE_PREDICT_FAILURE , *  PSTORAGE_PREDICT_FAILURE ;

#line 414
typedef enum _STORAGE_QUERY_TYPE {
	PropertyStandardQuery = 0,
	PropertyExistsQuery,
	PropertyMaskQuery,
	PropertyQueryMaxDefined
} STORAGE_QUERY_TYPE , *  PSTORAGE_QUERY_TYPE ;

#line 425
typedef enum _STORAGE_PROPERTY_ID {
	StorageDeviceProperty = 0,
	StorageAdapterProperty
} STORAGE_PROPERTY_ID , *  PSTORAGE_PROPERTY_ID ;

#line 435
typedef struct _STORAGE_PROPERTY_QUERY {
	STORAGE_PROPERTY_ID PropertyId ;
	STORAGE_QUERY_TYPE QueryType ;
	UCHAR AdditionalParameters[1] ;
} STORAGE_PROPERTY_QUERY , *  PSTORAGE_PROPERTY_QUERY ;

#line 462
typedef struct _STORAGE_DESCRIPTOR_HEADER {
	ULONG Version ;
	ULONG Size ;
} STORAGE_DESCRIPTOR_HEADER , *  PSTORAGE_DESCRIPTOR_HEADER ;

#line 478
typedef struct _STORAGE_DEVICE_DESCRIPTOR {
	ULONG Version ;
	ULONG Size ;
	UCHAR DeviceType ;
	UCHAR DeviceTypeModifier ;
	BOOLEAN RemovableMedia ;
	BOOLEAN CommandQueueing ;
	ULONG VendorIdOffset ;
	ULONG ProductIdOffset ;
	ULONG ProductRevisionOffset ;
	ULONG SerialNumberOffset ;
	STORAGE_BUS_TYPE BusType ;
	ULONG RawPropertiesLength ;
	UCHAR RawDeviceProperties[1] ;
} STORAGE_DEVICE_DESCRIPTOR , *  PSTORAGE_DEVICE_DESCRIPTOR ;

#line 581
typedef struct _STORAGE_ADAPTER_DESCRIPTOR {
	ULONG Version ;
	ULONG Size ;
	ULONG MaximumTransferLength ;
	ULONG MaximumPhysicalPages ;
	ULONG AlignmentMask ;
	BOOLEAN AdapterUsesPio ;
	BOOLEAN AdapterScansDown ;
	BOOLEAN CommandQueueing ;
	BOOLEAN AcceleratedTransfer ;
	BOOLEAN BusType ;
	USHORT BusMajorVersion ;
	USHORT BusMinorVersion ;
} STORAGE_ADAPTER_DESCRIPTOR , *  PSTORAGE_ADAPTER_DESCRIPTOR ;

#line 248 "C:/NTDDK/inc/ntdddisk.h"
typedef enum _MEDIA_TYPE {
	Unknown,
	F5_1Pt2_512,
	F3_1Pt44_512,
	F3_2Pt88_512,
	F3_20Pt8_512,
	F3_720_512,
	F5_360_512,
	F5_320_512,
	F5_320_1024,
	F5_180_512,
	F5_160_512,
	RemovableMedia,
	FixedMedia,
	F3_120M_512,
	F3_640_512,
	F5_640_512,
	F5_720_512,
	F3_1Pt2_512,
	F3_1Pt23_1024,
	F5_1Pt23_1024,
	F3_128Mb_512,
	F3_230Mb_512,
	F8_256_128
} MEDIA_TYPE , *  PMEDIA_TYPE ;

#line 279
typedef struct _FORMAT_PARAMETERS {
	MEDIA_TYPE MediaType ;
	ULONG StartCylinderNumber ;
	ULONG EndCylinderNumber ;
	ULONG StartHeadNumber ;
	ULONG EndHeadNumber ;
} FORMAT_PARAMETERS , *  PFORMAT_PARAMETERS ;

#line 294
typedef USHORT BAD_TRACK_NUMBER ;

#line 295
typedef USHORT *  PBAD_TRACK_NUMBER ;

#line 302
typedef struct _FORMAT_EX_PARAMETERS {
	MEDIA_TYPE MediaType ;
	ULONG StartCylinderNumber ;
	ULONG EndCylinderNumber ;
	ULONG StartHeadNumber ;
	ULONG EndHeadNumber ;
	USHORT FormatGapLength ;
	USHORT SectorsPerTrack ;
	USHORT SectorNumber[1] ;
} FORMAT_EX_PARAMETERS , *  PFORMAT_EX_PARAMETERS ;

#line 319
typedef struct _DISK_GEOMETRY {
	LARGE_INTEGER Cylinders ;
	MEDIA_TYPE MediaType ;
	ULONG TracksPerCylinder ;
	ULONG SectorsPerTrack ;
	ULONG BytesPerSector ;
} DISK_GEOMETRY , *  PDISK_GEOMETRY ;

#line 341
typedef struct _PARTITION_INFORMATION {
	LARGE_INTEGER StartingOffset ;
	LARGE_INTEGER PartitionLength ;
	ULONG HiddenSectors ;
	ULONG PartitionNumber ;
	UCHAR PartitionType ;
	BOOLEAN BootIndicator ;
	BOOLEAN RecognizedPartition ;
	BOOLEAN RewritePartition ;
} PARTITION_INFORMATION , *  PPARTITION_INFORMATION ;

#line 358
typedef struct _SET_PARTITION_INFORMATION {
	UCHAR PartitionType ;
} SET_PARTITION_INFORMATION , *  PSET_PARTITION_INFORMATION ;

#line 367
typedef struct _DRIVE_LAYOUT_INFORMATION {
	ULONG PartitionCount ;
	ULONG Signature ;
	PARTITION_INFORMATION PartitionEntry[1] ;
} DRIVE_LAYOUT_INFORMATION , *  PDRIVE_LAYOUT_INFORMATION ;

#line 378
typedef struct _VERIFY_INFORMATION {
	LARGE_INTEGER StartingOffset ;
	ULONG Length ;
} VERIFY_INFORMATION , *  PVERIFY_INFORMATION ;

#line 388
typedef struct _REASSIGN_BLOCKS {
	USHORT Reserved ;
	USHORT Count ;
	ULONG BlockNumber[1] ;
} REASSIGN_BLOCKS , *  PREASSIGN_BLOCKS ;

#line 401
typedef struct _DISK_CONTROLLER_NUMBER {
	ULONG ControllerNumber ;
	ULONG DiskNumber ;
} DISK_CONTROLLER_NUMBER , *  PDISK_CONTROLLER_NUMBER ;

#line 424
typedef enum  {
	EqualPriority,
	KeepPrefetchedData,
	KeepReadData
} DISK_CACHE_RETENTION_PRIORITY ;

#line 431
typedef struct _DISK_CACHE_INFORMATION {
	BOOLEAN ParametersSavable ;
	BOOLEAN ReadCacheEnabled ;
	BOOLEAN WriteCacheEnabled ;
	DISK_CACHE_RETENTION_PRIORITY ReadRetentionPriority ;
	DISK_CACHE_RETENTION_PRIORITY WriteRetentionPriority ;
	USHORT DisablePrefetchTransferLength ;
	BOOLEAN PrefetchScalar ;
	union  {
		struct  {
			USHORT Minimum ;
			USHORT Maximum ;
			USHORT MaximumBlocks ;
		} ScalarPrefetch ;
		struct  {
			USHORT Minimum ;
			USHORT Maximum ;
		} BlockPrefetch ;
	}  ;
} DISK_CACHE_INFORMATION , *  PDISK_CACHE_INFORMATION ;

#line 508
typedef struct _DISK_GROW_PARTITION {
	ULONG PartitionNumber ;
	LARGE_INTEGER BytesToGrow ;
} DISK_GROW_PARTITION , *  PDISK_GROW_PARTITION ;

#line 532
typedef struct _HISTOGRAM_BUCKET {
	ULONG Reads ;
	ULONG Writes ;
} HISTOGRAM_BUCKET , *  PHISTOGRAM_BUCKET ;

#line 539
typedef struct _DISK_HISTOGRAM {
	LARGE_INTEGER DiskSize ;
	LARGE_INTEGER Start ;
	LARGE_INTEGER End ;
	LARGE_INTEGER Average ;
	LARGE_INTEGER AverageRead ;
	LARGE_INTEGER AverageWrite ;
	ULONG Granularity ;
	ULONG Size ;
	ULONG ReadCount ;
	ULONG WriteCount ;
	PHISTOGRAM_BUCKET Histogram ;
} DISK_HISTOGRAM , *  PDISK_HISTOGRAM ;

#line 575
typedef struct _DISK_PERFORMANCE {
	LARGE_INTEGER BytesRead ;
	LARGE_INTEGER BytesWritten ;
	LARGE_INTEGER ReadTime ;
	LARGE_INTEGER WriteTime ;
	LARGE_INTEGER IdleTime ;
	ULONG ReadCount ;
	ULONG WriteCount ;
	ULONG QueueDepth ;
	ULONG SplitCount ;
	LARGE_INTEGER QueryTime ;
	ULONG StorageDeviceNumber ;
	WCHAR StorageManagerName[8] ;
} DISK_PERFORMANCE , *  PDISK_PERFORMANCE ;

#line 596
typedef struct _DISK_RECORD {
	LARGE_INTEGER ByteOffset ;
	LARGE_INTEGER StartTime ;
	LARGE_INTEGER EndTime ;
	PVOID VirtualAddress ;
	ULONG NumberOfBytes ;
	UCHAR DeviceNumber ;
	BOOLEAN ReadRequest ;
} DISK_RECORD , *  PDISK_RECORD ;

#line 611
typedef struct _DISK_LOGGING {
	UCHAR Function ;
	PVOID BufferAddress ;
	ULONG BufferSize ;
} DISK_LOGGING , *  PDISK_LOGGING ;

#line 653
typedef enum _BIN_TYPES {
	RequestSize,
	RequestLocation
} BIN_TYPES ;

#line 662
typedef struct _BIN_RANGE {
	LARGE_INTEGER StartValue ;
	LARGE_INTEGER Length ;
} BIN_RANGE , *  PBIN_RANGE ;

#line 671
typedef struct _PERF_BIN {
	ULONG NumberOfBins ;
	ULONG TypeOfBin ;
	BIN_RANGE BinsRanges[1] ;
} PERF_BIN , *  PPERF_BIN ;

#line 681
typedef struct _BIN_COUNT {
	BIN_RANGE BinRange ;
	ULONG BinCount ;
} BIN_COUNT , *  PBIN_COUNT ;

#line 690
typedef struct _BIN_RESULTS {
	ULONG NumberOfBins ;
	BIN_COUNT BinCounts[1] ;
} BIN_RESULTS , *  PBIN_RESULTS ;

#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 704 "C:/NTDDK/inc/ntdddisk.h"
typedef struct _GETVERSIONINPARAMS {
	UCHAR bVersion ;
	UCHAR bRevision ;
	UCHAR bReserved ;
	UCHAR bIDEDeviceMap ;
	ULONG fCapabilities ;
	ULONG dwReserved[4] ;
} GETVERSIONINPARAMS , *  PGETVERSIONINPARAMS , *  LPGETVERSIONINPARAMS ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 727 "C:/NTDDK/inc/ntdddisk.h"
typedef struct _IDEREGS {
	UCHAR bFeaturesReg ;
	UCHAR bSectorCountReg ;
	UCHAR bSectorNumberReg ;
	UCHAR bCylLowReg ;
	UCHAR bCylHighReg ;
	UCHAR bDriveHeadReg ;
	UCHAR bCommandReg ;
	UCHAR bReserved ;
} IDEREGS , *  PIDEREGS , *  LPIDEREGS ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 763 "C:/NTDDK/inc/ntdddisk.h"
typedef struct _SENDCMDINPARAMS {
	ULONG cBufferSize ;
	IDEREGS irDriveRegs ;
	UCHAR bDriveNumber ;
	UCHAR bReserved[3] ;
	ULONG dwReserved[4] ;
	UCHAR bBuffer[1] ;
} SENDCMDINPARAMS , *  PSENDCMDINPARAMS , *  LPSENDCMDINPARAMS ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 779 "C:/NTDDK/inc/ntdddisk.h"
typedef struct _DRIVERSTATUS {
	UCHAR bDriverError ;
	UCHAR bIDEError ;
	UCHAR bReserved[2] ;
	ULONG dwReserved[2] ;
} DRIVERSTATUS , *  PDRIVERSTATUS , *  LPDRIVERSTATUS ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 808 "C:/NTDDK/inc/ntdddisk.h"
typedef struct _SENDCMDOUTPARAMS {
	ULONG cBufferSize ;
	DRIVERSTATUS DriverStatus ;
	UCHAR bBuffer[1] ;
} SENDCMDOUTPARAMS , *  PSENDCMDOUTPARAMS , *  LPSENDCMDOUTPARAMS ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 849 "C:/NTDDK/inc/ntdddisk.h"
typedef struct _MAPPED_ADDRESS {
	struct _MAPPED_ADDRESS *  NextMappedAddress ;
	PVOID MappedAddress ;
	ULONG NumberOfBytes ;
	LARGE_INTEGER IoAddress ;
	ULONG BusNumber ;
} MAPPED_ADDRESS , *  PMAPPED_ADDRESS ;

#line 164 "C:/NTDDK/src/storage/fdc/inc/ntddfdc.h"
typedef struct _TRANSFER_BUFFER {
	PHYSICAL_ADDRESS Logical ;
	PVOID Virtual ;
} TRANSFER_BUFFER , *  PTRANSFER_BUFFER ;

#line 180
typedef struct _ACPI_FDI_DATA {
	ULONG DriveNumber ;
	ULONG DeviceType ;
	ULONG MaxCylinderNumber ;
	ULONG MaxSectorNumber ;
	ULONG MaxHeadNumber ;
	ULONG StepRateHeadUnloadTime ;
	ULONG HeadLoadTime ;
	ULONG MotorOffTime ;
	ULONG SectorLengthCode ;
	ULONG SectorPerTrack ;
	ULONG ReadWriteGapLength ;
	ULONG DataTransferLength ;
	ULONG FormatGapLength ;
	ULONG FormatFillCharacter ;
	ULONG HeadSettleTime ;
	ULONG MotorSettleTime ;
} ACPI_FDI_DATA , *  PACPI_FDI_DATA ;

#line 201
typedef enum _ACPI_FDI_DEVICE_TYPE {
	CmosProblem = 0,
	Form525Capacity360,
	Form525Capacity1200,
	Form35Capacity720,
	Form35Capacity1440,
	Form35Capacity2880
} ACPI_FDI_DEVICE_TYPE ;

#line 212
typedef struct _FDC_INFO {
	UCHAR FloppyControllerType ;
	UCHAR SpeedsAvailable ;
	ULONG AdapterBufferSize ;
	INTERFACE_TYPE BusType ;
	ULONG BusNumber ;
	ULONG ControllerNumber ;
	ULONG PeripheralNumber ;
	ULONG UnitNumber ;
	ULONG MaxTransferSize ;
	BOOLEAN AcpiBios ;
	BOOLEAN AcpiFdiSupported ;
	ACPI_FDI_DATA AcpiFdiData ;
	ULONG BufferCount ;
	ULONG BufferSize ;
	TRANSFER_BUFFER BufferAddress[] ;
} FDC_INFO , *  PFDC_INFO ;

#line 240
typedef struct _FDC_ENABLE_PARMS {
	UCHAR DriveOnValue ;
	USHORT TimeToWait ;
	BOOLEAN MotorStarted ;
} FDC_ENABLE_PARMS ;

typedef FDC_ENABLE_PARMS *  PFDC_ENABLE_PARMS ;

#line 252
typedef struct _FDC_DISK_CHANGE_PARMS {
	UCHAR DriveStatus ;
	UCHAR DriveOnValue ;
} FDC_DISK_CHANGE_PARMS , *  PFDC_DISK_CHANGE_PARMS ;

#line 261
typedef struct _ISSUE_FDC_COMMAND_PARMS {
	PUCHAR FifoInBuffer ;
	PUCHAR FifoOutBuffer ;
	PVOID IoHandle ;
	ULONG IoOffset ;
	ULONG TransferBytes ;
	ULONG TimeOut ;
} ISSUE_FDC_COMMAND_PARMS , *  PISSUE_FDC_COMMAND_PARMS ;

#line 274
typedef struct _ISSUE_FDC_ADAPTER_BUFFER_PARMS {
	PVOID IoBuffer ;
	USHORT TransferBytes ;
	PVOID Handle ;
} ISSUE_FDC_ADAPTER_BUFFER_PARMS , *  PISSUE_FDC_ADAPTER_BUFFER_PARMS ;

#line 291
typedef struct _SET_HD_BIT_PARMS {
	BOOLEAN DriveType144MB ;
	BOOLEAN Media144MB ;
	BOOLEAN More120MB ;
	UCHAR DeviceUnit ;
	BOOLEAN ChangedHdBit ;
} SET_HD_BIT_PARMS , *  PSET_HD_BIT_PARMS ;

#line 12 "C:/NTDDK/inc/initguid.h"

#pragma once
#line 26 "C:/NTDDK/inc/mountmgr.h"

#pragma once
#line 61
typedef struct _MOUNTMGR_CREATE_POINT_INPUT {
	USHORT SymbolicLinkNameOffset ;
	USHORT SymbolicLinkNameLength ;
	USHORT DeviceNameOffset ;
	USHORT DeviceNameLength ;
} MOUNTMGR_CREATE_POINT_INPUT , *  PMOUNTMGR_CREATE_POINT_INPUT ;

#line 73
typedef struct _MOUNTMGR_MOUNT_POINT {
	ULONG SymbolicLinkNameOffset ;
	USHORT SymbolicLinkNameLength ;
	ULONG UniqueIdOffset ;
	USHORT UniqueIdLength ;
	ULONG DeviceNameOffset ;
	USHORT DeviceNameLength ;
} MOUNTMGR_MOUNT_POINT , *  PMOUNTMGR_MOUNT_POINT ;

#line 87
typedef struct _MOUNTMGR_MOUNT_POINTS {
	ULONG Size ;
	ULONG NumberOfMountPoints ;
	MOUNTMGR_MOUNT_POINT MountPoints[1] ;
} MOUNTMGR_MOUNT_POINTS , *  PMOUNTMGR_MOUNT_POINTS ;

#line 97
typedef struct _MOUNTMGR_DRIVE_LETTER_TARGET {
	USHORT DeviceNameLength ;
	WCHAR DeviceName[1] ;
} MOUNTMGR_DRIVE_LETTER_TARGET , *  PMOUNTMGR_DRIVE_LETTER_TARGET ;

#line 106
typedef struct _MOUNTMGR_DRIVE_LETTER_INFORMATION {
	BOOLEAN DriveLetterWasAssigned ;
	UCHAR CurrentDriveLetter ;
} MOUNTMGR_DRIVE_LETTER_INFORMATION , *  PMOUNTMGR_DRIVE_LETTER_INFORMATION ;

#line 116
typedef struct _MOUNTMGR_VOLUME_MOUNT_POINT {
	USHORT SourceVolumeNameOffset ;
	USHORT SourceVolumeNameLength ;
	USHORT TargetVolumeNameOffset ;
	USHORT TargetVolumeNameLength ;
} MOUNTMGR_VOLUME_MOUNT_POINT , *  PMOUNTMGR_VOLUME_MOUNT_POINT ;

#line 128
typedef struct _MOUNTMGR_CHANGE_NOTIFY_INFO {
	ULONG EpicNumber ;
} MOUNTMGR_CHANGE_NOTIFY_INFO , *  PMOUNTMGR_CHANGE_NOTIFY_INFO ;

#line 137
typedef struct _MOUNTMGR_TARGET_NAME {
	USHORT DeviceNameLength ;
	WCHAR DeviceName[1] ;
} MOUNTMGR_TARGET_NAME , *  PMOUNTMGR_TARGET_NAME ;

#line 202
typedef struct _MOUNTDEV_NAME {
	USHORT NameLength ;
	WCHAR Name[1] ;
} MOUNTDEV_NAME , *  PMOUNTDEV_NAME ;

#line 212
extern const GUID __declspec(selectany) MOUNTDEV_MOUNTED_DEVICE_GUID
	= {0x53f5630d, 0xb6bf, 0x11d0, {0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e,
	0xfb, 0x8b}};

#line 38 "C:/NTDDK/inc/ddk/mountdev.h"
typedef struct _MOUNTDEV_UNIQUE_ID {
	USHORT UniqueIdLength ;
	UCHAR UniqueId[1] ;
} MOUNTDEV_UNIQUE_ID , *  PMOUNTDEV_UNIQUE_ID ;

#line 47
typedef struct _MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT {
	ULONG Size ;
	USHORT OldUniqueIdOffset ;
	USHORT OldUniqueIdLength ;
	USHORT NewUniqueIdOffset ;
	USHORT NewUniqueIdLength ;
} MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT , * 
	PMOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT ;

#line 66
typedef struct _MOUNTDEV_SUGGESTED_LINK_NAME {
	BOOLEAN UseOnlyIfThereAreNoOtherLinks ;
	USHORT NameLength ;
	WCHAR Name[1] ;
} MOUNTDEV_SUGGESTED_LINK_NAME , *  PMOUNTDEV_SUGGESTED_LINK_NAME ;

#line 27 "C:/NTDDK/inc/ddk/wdm/acpiioct.h"

#pragma once
#line 46
typedef struct _ACPI_EVAL_INPUT_BUFFER {
	ULONG Signature ;
	union  {
		UCHAR MethodName[4] ;
		ULONG MethodNameAsUlong ;
	}  ;
} ACPI_EVAL_INPUT_BUFFER , *  PACPI_EVAL_INPUT_BUFFER ;

typedef struct _ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER {
	ULONG Signature ;
	union  {
		UCHAR MethodName[4] ;
		ULONG MethodNameAsUlong ;
	}  ;
	ULONG IntegerArgument ;
} ACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER , * 
	PACPI_EVAL_INPUT_BUFFER_SIMPLE_INTEGER ;

#line 63
typedef struct _ACPI_EVAL_INPUT_BUFFER_SIMPLE_STRING {
	ULONG Signature ;
	union  {
		UCHAR MethodName[4] ;
		ULONG MethodNameAsUlong ;
	}  ;
	ULONG StringLength ;
	UCHAR String[1] ;
} ACPI_EVAL_INPUT_BUFFER_SIMPLE_STRING , * 
	PACPI_EVAL_INPUT_BUFFER_SIMPLE_STRING ;

#line 73
typedef struct _ACPI_METHOD_ARGUMENT {
	USHORT Type ;
	USHORT DataLength ;
	union  {
		ULONG Argument ;
		UCHAR Data[1] ;
	}  ;
} ACPI_METHOD_ARGUMENT , *  PACPI_METHOD_ARGUMENT ;

#line 93
typedef struct _ACPI_EVAL_INPUT_BUFFER_COMPLEX {
	ULONG Signature ;
	union  {
		UCHAR MethodName[4] ;
		ULONG MethodNameAsUlong ;
	}  ;
	ULONG Size ;
	ULONG ArgumentCount ;
	ACPI_METHOD_ARGUMENT Argument[1] ;
} ACPI_EVAL_INPUT_BUFFER_COMPLEX , *  PACPI_EVAL_INPUT_BUFFER_COMPLEX ;

typedef struct _ACPI_EVAL_OUTPUT_BUFFER {
	ULONG Signature ;
	ULONG Length ;
	ULONG Count ;
	ACPI_METHOD_ARGUMENT Argument[1] ;
} ACPI_EVAL_OUTPUT_BUFFER , *  PACPI_EVAL_OUTPUT_BUFFER ;

#line 125
typedef struct _ACPI_MANIPULATE_GLOBAL_LOCK_BUFFER {
	ULONG Signature ;
	PVOID LockObject ;
} ACPI_MANIPULATE_GLOBAL_LOCK_BUFFER , *  PACPI_MANIPULATE_GLOBAL_LOCK_BUFFER ;

#line 105 "./flo_data.h"
typedef struct _BOOT_SECTOR_INFO {
	UCHAR JumpByte[1] ;
	UCHAR Ignore1[2] ;
	UCHAR OemData[8] ;
	UCHAR BytesPerSector[2] ;
	UCHAR Ignore2[6] ;
	UCHAR NumberOfSectors[2] ;
	UCHAR MediaByte[1] ;
	UCHAR Ignore3[2] ;
	UCHAR SectorsPerTrack[2] ;
	UCHAR NumberOfHeads[2] ;
} BOOT_SECTOR_INFO , *  PBOOT_SECTOR_INFO ;

#line 194
typedef enum _DRIVE_MEDIA_TYPE {
	Drive360Media160,
	Drive360Media180,
	Drive360Media320,
	Drive360Media32X,
	Drive360Media360,
	Drive720Media720,
	Drive120Media160,
	Drive120Media180,
	Drive120Media320,
	Drive120Media32X,
	Drive120Media360,
	Drive120Media120,
	Drive144Media720,
	Drive144Media144,
	Drive288Media720,
	Drive288Media144,
	Drive288Media288
} DRIVE_MEDIA_TYPE ;

#line 217
typedef enum _DRIVE_MEDIA_TYPE_NEC98 {
	Drive360Media160Nec98,
	Drive360Media180Nec98,
	Drive360Media320Nec98,
	Drive360Media32XNec98,
	Drive360Media360Nec98,
	Drive120Media160Nec98,
	Drive120Media180Nec98,
	Drive120Media320Nec98,
	Drive120Media32XNec98,
	Drive120Media360Nec98,
	Drive120Media640Nec98,
	Drive120Media720Nec98,
	Drive120Media120Nec98,
	Drive120Media123Nec98,
	Drive144Media640Nec98,
	Drive144Media720Nec98,
	Drive144Media120Nec98,
	Drive144Media123Nec98,
	Drive144Media144Nec98,
	Drive12EMedia120Nec98,
	Drive12EMedia123Nec98
} DRIVE_MEDIA_TYPE_NEC98 ;

#line 260
typedef struct _DRIVE_MEDIA_LIMITS {
	DRIVE_MEDIA_TYPE HighestDriveMediaType ;
	DRIVE_MEDIA_TYPE LowestDriveMediaType ;
} DRIVE_MEDIA_LIMITS , *  PDRIVE_MEDIA_LIMITS ;

DRIVE_MEDIA_LIMITS _DriveMediaLimits[5] = {{Drive360Media360, Drive360Media160},
	{Drive120Media120, Drive120Media160}, {Drive720Media720,
	Drive720Media720}, {Drive144Media144, Drive144Media720},
	{Drive288Media288, Drive288Media720}};

#line 277
typedef struct _DRIVE_MEDIA_LIMITS_NEC98 {
	DRIVE_MEDIA_TYPE_NEC98 HighestDriveMediaType ;
	DRIVE_MEDIA_TYPE_NEC98 LowestDriveMediaType ;
} DRIVE_MEDIA_LIMITS_NEC98 , *  PDRIVE_MEDIA_LIMITS_NEC98 ;

DRIVE_MEDIA_LIMITS_NEC98 _DriveMediaLimits_NEC98[6] = {{Drive360Media360Nec98,
	Drive360Media160Nec98}, {Drive120Media123Nec98, Drive120Media160Nec98},
	{Drive120Media720Nec98, Drive120Media160Nec98}, {Drive144Media144Nec98,
	Drive144Media640Nec98}, {Drive144Media144Nec98, Drive144Media640Nec98},
	{Drive12EMedia123Nec98, Drive12EMedia120Nec98}};
#line 292
PDRIVE_MEDIA_LIMITS DriveMediaLimits ;

#line 298
typedef struct _DRIVE_MEDIA_CONSTANTS {
	MEDIA_TYPE MediaType ;
	UCHAR StepRateHeadUnloadTime ;
	UCHAR HeadLoadTime ;
	UCHAR MotorOffTime ;
	UCHAR SectorLengthCode ;
	USHORT BytesPerSector ;
	UCHAR SectorsPerTrack ;
	UCHAR ReadWriteGapLength ;
	UCHAR FormatGapLength ;
	UCHAR FormatFillCharacter ;
	UCHAR HeadSettleTime ;
	USHORT MotorSettleTimeRead ;
	USHORT MotorSettleTimeWrite ;
	UCHAR MaximumTrack ;
	UCHAR CylinderShift ;
	UCHAR DataTransferRate ;
	UCHAR NumberOfHeads ;
	UCHAR DataLength ;
	UCHAR MediaByte ;
	UCHAR SkewDelta ;
} DRIVE_MEDIA_CONSTANTS , *  PDRIVE_MEDIA_CONSTANTS ;

#line 334
DRIVE_MEDIA_CONSTANTS _DriveMediaConstants[17] = {{F5_160_512, 0xdf, 0x2, 0x25,
	0x2, 0x200, 0x08, 0x2a, 0x50, 0xf6, 0xf, 1000, 1000, 0x27, 0, 0x2, 0x1,
	0xff, 0xfe, 0}, {F5_180_512, 0xdf, 0x2, 0x25, 0x2, 0x200, 0x09, 0x2a,
	0x50, 0xf6, 0xf, 1000, 1000, 0x27, 0, 0x2, 0x1, 0xff, 0xfc, 0},
	{F5_320_512, 0xdf, 0x2, 0x25, 0x2, 0x200, 0x08, 0x2a, 0x50, 0xf6, 0xf,
	1000, 1000, 0x27, 0, 0x2, 0x2, 0xff, 0xff, 0}, {F5_320_1024, 0xdf, 0x2,
	0x25, 0x3, 0x400, 0x04, 0x80, 0xf0, 0xf6, 0xf, 1000, 1000, 0x27, 0, 0x2,
	0x2, 0xff, 0xff, 0}, {F5_360_512, 0xdf, 0x2, 0x25, 0x2, 0x200, 0x09,
	0x2a, 0x50, 0xf6, 0xf, 250, 1000, 0x27, 0, 0x2, 0x2, 0xff, 0xfd, 0},
	{F3_720_512, 0xdf, 0x2, 0x25, 0x2, 0x200, 0x09, 0x2a, 0x50, 0xf6, 0xf,
	500, 1000, 0x4f, 0, 0x2, 0x2, 0xff, 0xf9, 2}, {F5_160_512, 0xdf, 0x2,
	0x25, 0x2, 0x200, 0x08, 0x2a, 0x50, 0xf6, 0xf, 1000, 1000, 0x27, 1, 0x1,
	0x1, 0xff, 0xfe, 0}, {F5_180_512, 0xdf, 0x2, 0x25, 0x2, 0x200, 0x09,
	0x2a, 0x50, 0xf6, 0xf, 1000, 1000, 0x27, 1, 0x1, 0x1, 0xff, 0xfc, 0},
	{F5_320_512, 0xdf, 0x2, 0x25, 0x2, 0x200, 0x08, 0x2a, 0x50, 0xf6, 0xf,
	1000, 1000, 0x27, 1, 0x1, 0x2, 0xff, 0xff, 0}, {F5_320_1024, 0xdf, 0x2,
	0x25, 0x3, 0x400, 0x04, 0x80, 0xf0, 0xf6, 0xf, 1000, 1000, 0x27, 1, 0x1,
	0x2, 0xff, 0xff, 0}, {F5_360_512, 0xdf, 0x2, 0x25, 0x2, 0x200, 0x09,
	0x2a, 0x50, 0xf6, 0xf, 625, 1000, 0x27, 1, 0x1, 0x2, 0xff, 0xfd, 0},
	{F5_1Pt2_512, 0xdf, 0x2, 0x25, 0x2, 0x200, 0x0f, 0x1b, 0x54, 0xf6, 0xf,
	625, 1000, 0x4f, 0, 0x0, 0x2, 0xff, 0xf9, 0}, {F3_720_512, 0xdf, 0x2,
	0x25, 0x2, 0x200, 0x09, 0x2a, 0x50, 0xf6, 0xf, 500, 1000, 0x4f, 0, 0x2,
	0x2, 0xff, 0xf9, 2}, {F3_1Pt44_512, 0xaf, 0x2, 0x25, 0x2, 0x200, 0x12,
	0x1b, 0x65, 0xf6, 0xf, 500, 1000, 0x4f, 0, 0x0, 0x2, 0xff, 0xf0, 3},
	{F3_720_512, 0xe1, 0x2, 0x25, 0x2, 0x200, 0x09, 0x2a, 0x50, 0xf6, 0xf,
	500, 1000, 0x4f, 0, 0x2, 0x2, 0xff, 0xf9, 2}, {F3_1Pt44_512, 0xd1, 0x2,
	0x25, 0x2, 0x200, 0x12, 0x1b, 0x65, 0xf6, 0xf, 500, 1000, 0x4f, 0, 0x0,
	0x2, 0xff, 0xf0, 3}, {F3_2Pt88_512, 0xa1, 0x2, 0x25, 0x2, 0x200, 0x24,
	0x38, 0x53, 0xf6, 0xf, 500, 1000, 0x4f, 0, 0x3, 0x2, 0xff, 0xf0, 6}};
#line 358
DRIVE_MEDIA_CONSTANTS _DriveMediaConstants_NEC98[21] = {{F5_160_512, 0xdf, 0x2,
	0x25, 0x2, 0x200, 0x08, 0x2a, 0x50, 0xf6, 0xf, 1000, 1000, 0x27, 0, 0x2,
	0x1, 0xff, 0xfe, 0}, {F5_180_512, 0xdf, 0x2, 0x25, 0x2, 0x200, 0x09,
	0x2a, 0x50, 0xf6, 0xf, 1000, 1000, 0x27, 0, 0x2, 0x1, 0xff, 0xfc, 0},
	{F5_320_512, 0xdf, 0x2, 0x25, 0x2, 0x200, 0x08, 0x2a, 0x50, 0xf6, 0xf,
	1000, 1000, 0x27, 0, 0x2, 0x2, 0xff, 0xff, 0}, {F5_320_1024, 0xdf, 0x2,
	0x25, 0x3, 0x400, 0x04, 0x80, 0xf0, 0xf6, 0xf, 1000, 1000, 0x27, 0, 0x2,
	0x2, 0xff, 0xff, 0}, {F5_360_512, 0xdf, 0x2, 0x25, 0x2, 0x200, 0x09,
	0x2a, 0x50, 0xf6, 0xf, 250, 1000, 0x27, 0, 0x2, 0x2, 0xff, 0xfd, 0},
	{F5_160_512, 0xdf, 0x16, 0x25, 0x2, 0x200, 0x08, 0x2a, 0x50, 0xe5, 0xf,
	1000, 1000, 0x27, 1, 0x2, 0x1, 0xff, 0xfe, 0}, {F5_180_512, 0xdf, 0x16,
	0x25, 0x2, 0x200, 0x09, 0x2a, 0x50, 0xe5, 0xf, 1000, 1000, 0x27, 1, 0x2,
	0x1, 0xff, 0xfc, 0}, {F5_320_512, 0xdf, 0x16, 0x25, 0x2, 0x200, 0x08,
	0x2a, 0x50, 0xe5, 0xf, 1000, 1000, 0x27, 1, 0x2, 0x2, 0xff, 0xff, 0},
	{F5_320_1024, 0xdf, 0x16, 0x25, 0x3, 0x400, 0x04, 0x80, 0xf0, 0xe5, 0xf,
	1000, 1000, 0x27, 1, 0x2, 0x2, 0xff, 0xff, 0}, {F5_360_512, 0xdf, 0x16,
	0x25, 0x2, 0x200, 0x09, 0x2a, 0x50, 0xe5, 0xf, 1000, 1000, 0x27, 1, 0x2,
	0x2, 0xff, 0xfd, 0}, {F5_640_512, 0xdf, 0x16, 0x25, 0x2, 0x200, 0x08,
	0x2a, 0x50, 0xe5, 0xf, 1000, 1000, 0x4f, 0, 0x0, 0x2, 0xff, 0xfb, 0},
	{F5_720_512, 0xdf, 0x16, 0x25, 0x2, 0x200, 0x09, 0x2a, 0x50, 0xe5, 0xf,
	1000, 1000, 0x4f, 0, 0x0, 0x2, 0xff, 0xf9, 2}, {F5_1Pt2_512, 0xcf, 0x24,
	0x25, 0x2, 0x200, 0x0f, 0x1b, 0x54, 0xe5, 0xf, 1000, 1000, 0x4f, 0, 0x0,
	0x2, 0xff, 0xf9, 0}, {F5_1Pt23_1024, 0xcf, 0x24, 0x25, 0x3, 0x400, 0x08,
	0x35, 0x74, 0xe5, 0xf, 1000, 1000, 0x4c, 0, 0x0, 0x2, 0xff, 0xfe, 0},
	{F3_640_512, 0xdf, 0x16, 0x25, 0x2, 0x200, 0x08, 0x2a, 0x50, 0xe5, 0xf,
	1000, 1000, 0x4f, 0, 0x0, 0x2, 0xff, 0xfb, 0}, {F3_720_512, 0xdf, 0x16,
	0x25, 0x2, 0x200, 0x09, 0x2a, 0x50, 0xe5, 0xf, 1000, 1000, 0x4f, 0, 0x0,
	0x2, 0xff, 0xf9, 2}, {F3_1Pt2_512, 0xcf, 0x24, 0x25, 0x2, 0x200, 0x0f,
	0x1b, 0x54, 0xe5, 0xf, 1000, 1000, 0x4f, 0, 0x0, 0x2, 0xff, 0xf9, 0},
	{F3_1Pt23_1024, 0xcf, 0x24, 0x25, 0x3, 0x400, 0x08, 0x35, 0x74, 0xe5,
	0xf, 1000, 1000, 0x4c, 0, 0x0, 0x2, 0xff, 0xfe, 0}, {F3_1Pt44_512, 0xdf,
	0x24, 0x25, 0x2, 0x200, 0x12, 0x1b, 0x6c, 0xe5, 0xf, 1000, 1000, 0x4f,
	0, 0x0, 0x2, 0xff, 0xf0, 3}, {F5_1Pt2_512, 0xbf, 0x32, 0x25, 0x2, 0x200,
	0x0f, 0x1b, 0x54, 0xe5, 0xf, 1000, 1000, 0x4f, 0, 0x0, 0x2, 0xff, 0xf9,
	0}, {F5_1Pt23_1024, 0xbf, 0x32, 0x25, 0x3, 0x400, 0x08, 0x35, 0x74,
	0xe5, 0xf, 1000, 1000, 0x4c, 0, 0x0, 0x2, 0xff, 0xfe, 0}};
#line 399
PDRIVE_MEDIA_CONSTANTS DriveMediaConstants ;

#line 528
typedef struct _DISKETTE_EXTENSION {
	KSPIN_LOCK FlCancelSpinLock ;
	PDEVICE_OBJECT UnderlyingPDO ;
	PDEVICE_OBJECT TargetObject ;
	BOOLEAN IsStarted ;
	BOOLEAN IsRemoved ;
	BOOLEAN HoldNewRequests ;
	LIST_ENTRY NewRequestQueue ;
	KSPIN_LOCK NewRequestQueueSpinLock ;
	PDEVICE_OBJECT DeviceObject ;
	KSEMAPHORE RequestSemaphore ;
	KSPIN_LOCK ListSpinLock ;
	FAST_MUTEX ThreadReferenceMutex ;
	LONG ThreadReferenceCount ;
	PKTHREAD FloppyThread ;
	LIST_ENTRY ListEntry ;
	BOOLEAN HardwareFailed ;
	UCHAR HardwareFailCount ;
	ULONG MaxTransferSize ;
	UCHAR FifoBuffer[10] ;
	PUCHAR IoBuffer ;
	PMDL IoBufferMdl ;
	ULONG IoBufferSize ;
	PDRIVER_OBJECT DriverObject ;
	DRIVE_MEDIA_TYPE LastDriveMediaType ;
	BOOLEAN FloppyControllerAllocated ;
	BOOLEAN ACPI_BIOS ;
	UCHAR DriveType ;
	ULONG BytesPerSector ;
	ULONG ByteCapacity ;
	MEDIA_TYPE MediaType ;
	DRIVE_MEDIA_TYPE DriveMediaType ;
	UCHAR DeviceUnit ;
	UCHAR DriveOnValue ;
	BOOLEAN IsReadOnly ;
	DRIVE_MEDIA_CONSTANTS BiosDriveMediaConstants ;
	DRIVE_MEDIA_CONSTANTS DriveMediaConstants ;
	UCHAR PerpendicularMode ;
	BOOLEAN ControllerConfigurable ;
	UNICODE_STRING DeviceName ;
	UNICODE_STRING InterfaceString ;
	UNICODE_STRING ArcName ;
	BOOLEAN ReleaseFdcWithMotorRunning ;
	BOOLEAN PoweringDown ;
	FAST_MUTEX PowerDownMutex ;
	FAST_MUTEX HoldNewReqMutex ;
} DISKETTE_EXTENSION ;

#line 584
typedef DISKETTE_EXTENSION *  PDISKETTE_EXTENSION ;

#line 591
typedef struct _SENSE_DEVISE_STATUS_PTOS {
	UCHAR ST3_PTOS ;
} SENSE_DEVISE_STATUS_PTOS , *  PSENSE_DEVISE_STATUS_PTOS ;

SENSE_DEVISE_STATUS_PTOS Result_Status3_PTOS[4] ;
#line 603
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject , PUNICODE_STRING RegistryPath
	) ;
#line 609
void FloppyUnload(PDRIVER_OBJECT DriverObject ) ;
#line 614
NTSTATUS FlConfigCallBack(PVOID Context , PUNICODE_STRING PathName ,
	INTERFACE_TYPE BusType , ULONG BusNumber , PKEY_VALUE_FULL_INFORMATION
	*  BusInformation , CONFIGURATION_TYPE ControllerType , ULONG
	ControllerNumber , PKEY_VALUE_FULL_INFORMATION *  ControllerInformation
	, CONFIGURATION_TYPE PeripheralType , ULONG PeripheralNumber ,
	PKEY_VALUE_FULL_INFORMATION *  PeripheralInformation ) ;
#line 629
NTSTATUS FlInitializeControllerHardware(PDISKETTE_EXTENSION disketteExtension )
	;
#line 634
NTSTATUS FloppyCreateClose(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 640
NTSTATUS FloppyDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 646
NTSTATUS FloppyReadWrite(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 652
NTSTATUS FlRecalibrateDrive(PDISKETTE_EXTENSION DisketteExtension ) ;
#line 657
NTSTATUS FlDatarateSpecifyConfigure(PDISKETTE_EXTENSION DisketteExtension ) ;
#line 662
NTSTATUS FlStartDrive(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp , BOOLEAN
	WriteOperation , BOOLEAN SetUpMedia , BOOLEAN IgnoreChange ) ;
#line 671
void FlFinishOperation(PIRP Irp , PDISKETTE_EXTENSION DisketteExtension ) ;
#line 677
NTSTATUS FlDetermineMediaType(PDISKETTE_EXTENSION DisketteExtension ) ;
#line 682
void FloppyThread(PVOID Context ) ;
#line 687
NTSTATUS FlReadWrite(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp , BOOLEAN
	DriveStarted ) ;
#line 694
NTSTATUS FlFormat(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp ) ;
#line 700
NTSTATUS FlIssueCommand(PDISKETTE_EXTENSION DisketteExtension , PUCHAR
	FifoInBuffer , PUCHAR FifoOutBuffer , PMDL IoMdl , ULONG IoBuffer ,
	ULONG TransferBytes ) ;
#line 710
BOOLEAN FlCheckFormatParameters(PDISKETTE_EXTENSION DisketteExtension ,
	PFORMAT_PARAMETERS Fp ) ;
#line 716
void FlLogErrorDpc(PKDPC Dpc , PVOID DeferredContext , PVOID SystemContext1 ,
	PVOID SystemContext2 ) ;
#line 724
NTSTATUS FlQueueIrpToThread(PIRP Irp , PDISKETTE_EXTENSION DisketteExtension ) ;
#line 730
NTSTATUS FlInterpretError(UCHAR StatusRegister1 , UCHAR StatusRegister2 ) ;
#line 736
void FlAllocateIoBuffer(PDISKETTE_EXTENSION DisketteExtension , ULONG BufferSize
	) ;
#line 742
void FlFreeIoBuffer(PDISKETTE_EXTENSION DisketteExtension ) ;
#line 747
void FlConsolidateMediaTypeWithBootSector(PDISKETTE_EXTENSION DisketteExtension
	, PBOOT_SECTOR_INFO BootSector ) ;
#line 753
void FlCheckBootSector(PDISKETTE_EXTENSION DisketteExtension ) ;
#line 758
NTSTATUS FlReadWriteTrack(PDISKETTE_EXTENSION DisketteExtension , PMDL IoMdl ,
	ULONG IoOffset , BOOLEAN WriteOperation , UCHAR Cylinder , UCHAR Head ,
	UCHAR Sector , UCHAR NumberOfSectors , BOOLEAN NeedSeek ) ;
#line 771
NTSTATUS FlFdcDeviceIo(PDEVICE_OBJECT DeviceObject , ULONG Ioctl , PVOID Data )
	;
#line 778
NTSTATUS FloppyAddDevice(PDRIVER_OBJECT DriverObject , PDEVICE_OBJECT
	PhysicalDeviceObject ) ;
#line 784
NTSTATUS FloppyPnp(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 790
NTSTATUS FloppyPower(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 796
NTSTATUS FloppyPnpComplete(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID
	Context ) ;
#line 803
NTSTATUS FloppyQueueRequest(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp ) ;
#line 809
NTSTATUS FloppyStartDevice(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 815
void FloppyProcessQueuedRequests(PDISKETTE_EXTENSION DisketteExtension ) ;
#line 820
void FloppyCancelQueuedRequest(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
#line 826
NTSTATUS FlAcpiConfigureFloppy(PDISKETTE_EXTENSION DisketteExtension , PFDC_INFO
	FdcInfo ) ;
#line 832
NTSTATUS FlHdbit(PDISKETTE_EXTENSION DisketteExtension ) ;

#line 46 "floppy.c"

#pragma alloc_text(INIT, DriverEntry)

#pragma alloc_text(PAGE, FloppyAddDevice)
#line 49

#pragma alloc_text(PAGE, FloppyPnp)
#line 50

#pragma alloc_text(PAGE, FloppyPower)
#line 51

#pragma alloc_text(PAGE, FlConfigCallBack)
#line 52

#pragma alloc_text(PAGE, FlInitializeControllerHardware)
#line 53

#pragma alloc_text(PAGE, FlInterpretError)
#line 54

#pragma alloc_text(PAGE, FlDatarateSpecifyConfigure)
#line 55

#pragma alloc_text(PAGE, FlRecalibrateDrive)
#line 56

#pragma alloc_text(PAGE, FlDetermineMediaType)
#line 57

#pragma alloc_text(PAGE, FlCheckBootSector)
#line 58

#pragma alloc_text(PAGE, FlConsolidateMediaTypeWithBootSector)
#line 59

#pragma alloc_text(PAGE, FlIssueCommand)
#line 60

#pragma alloc_text(PAGE, FlReadWriteTrack)
#line 61

#pragma alloc_text(PAGE, FlReadWrite)
#line 62

#pragma alloc_text(PAGE, FlFormat)
#line 63

#pragma alloc_text(PAGE, FlFinishOperation)
#line 64

#pragma alloc_text(PAGE, FlStartDrive)
#line 65

#pragma alloc_text(PAGE, FloppyThread)
#line 66

#pragma alloc_text(PAGE, FlAllocateIoBuffer)
#line 67

#pragma alloc_text(PAGE, FlFreeIoBuffer)
#line 68

#pragma alloc_text(PAGE, FloppyCreateClose)
#line 69

#pragma alloc_text(PAGE, FloppyDeviceControl)
#line 70

#pragma alloc_text(PAGE, FloppyReadWrite)
#line 71

#pragma alloc_text(PAGE, FlCheckFormatParameters)
#line 72

#pragma alloc_text(PAGE, FlFdcDeviceIo)
#line 73

#pragma alloc_text(PAGE, FlHdbit)
#line 94

void errorFn()
{
	#line 97
	ERROR:
		#line 97
		goto ERROR;
}

#line 101
NTSTATUS myStatus; // shadows Irp->IoStatus.Status

int s ;
int UNLOADED , NP , DC , SKIP1 , SKIP2 , MPR1 , MPR3 , IPC ;
int pended ;
PIO_COMPLETION_ROUTINE compFptr ;
int compRegistered ;
int lowerDriverReturn ;
int setEventCalled ;
int customIrp ;

void _BLAST_init()
{
	#line 111
	UNLOADED = 0;
	NP = 1;
	DC = 2;
	SKIP1 = 3;
	SKIP2 = 4;
	MPR1 = 5;
	MPR3 = 6;
	IPC = 7;
	#line 121
	s = UNLOADED;
	pended = 0;
	compFptr = 0;
	compRegistered = 0;
	lowerDriverReturn = 0;
	setEventCalled = 0;
	customIrp = 0;
}

#line 135
ULONG PagingReferenceCount = 0;
PFAST_MUTEX PagingMutex = (void *  )0;

#line 139
NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject , PUNICODE_STRING RegistryPath
	)
{
	#line 170
	NTSTATUS ntStatus = (NTSTATUS )0x00000000L;
	#line 242
	do
	{
		#line 242
		;
	}
	while(0);
	#line 247
	(DriverObject->MajorFunction)[0x00] = FloppyCreateClose;
	(DriverObject->MajorFunction)[0x02] = FloppyCreateClose;
	(DriverObject->MajorFunction)[0x03] = FloppyReadWrite;
	(DriverObject->MajorFunction)[0x04] = FloppyReadWrite;
	(DriverObject->MajorFunction)[0x0e] = FloppyDeviceControl;
	(DriverObject->MajorFunction)[0x1b] = FloppyPnp;
	(DriverObject->MajorFunction)[0x16] = FloppyPower;
	#line 255
	DriverObject->DriverUnload = FloppyUnload;
	#line 257
	(DriverObject->DriverExtension)->AddDevice = FloppyAddDevice;
	#line 262
	PagingMutex = ExAllocatePoolWithTag(NonPagedPool, sizeof(FAST_MUTEX ),
		'polF');
	if(PagingMutex == (void *  )0)
	{
		return (NTSTATUS )0xC000009AL;
	}
	#line 269
	PagingMutex->Count = 1;
	#line 269
	PagingMutex->Contention = 0;
	#line 269
	KeInitializeEvent(& PagingMutex->Event, SynchronizationEvent, 0);
	#line 269
	;
	#line 274
	MmPageEntireDriver(DriverEntry);
	#line 276
	DriveMediaLimits = ((KUSER_SHARED_DATA * const
		)0xffdf0000)->AlternativeArchitecture == NEC98x86
		? (PDRIVE_MEDIA_LIMITS )(& _DriveMediaLimits_NEC98[0]) : &
		_DriveMediaLimits[0];
	#line 279
	DriveMediaConstants = ((KUSER_SHARED_DATA * const
		)0xffdf0000)->AlternativeArchitecture == NEC98x86
		? (PDRIVE_MEDIA_CONSTANTS )(& _DriveMediaConstants_NEC98[0]) : &
		_DriveMediaConstants[0];
	#line 282
	return ntStatus;
}

void FloppyUnload(PDRIVER_OBJECT DriverObject )
{
	#line 308
	do
	{
		#line 308
		;
	}
	while(0);
	#line 313
	;
	#line 318
	ExFreePool(PagingMutex);
	#line 320
	return;
}

NTSTATUS FloppyAddDevice(PDRIVER_OBJECT DriverObject , PDEVICE_OBJECT
	PhysicalDeviceObject )
{
	#line 353
	NTSTATUS ntStatus ;
	PDEVICE_OBJECT deviceObject ;
	PDISKETTE_EXTENSION disketteExtension ;
	FDC_INFO fdcInfo ;
	UCHAR arcNameBuffer[256] ;
	STRING arcNameString ;
	WCHAR deviceNameBuffer[20] ;
	UNICODE_STRING deviceName ;
	#line 363
	ntStatus = (NTSTATUS )0x00000000L;
	#line 365
	do
	{
		#line 365
		;
	}
	while(0);
	#line 370
	fdcInfo.BufferCount = 0;
	fdcInfo.BufferSize = 0;
	#line 373
	ntStatus = FlFdcDeviceIo(PhysicalDeviceObject,
		0x00000007 << 16 | 0 << 14 | 0x302 << 2 | 3, & fdcInfo);
	#line 377
	if((NTSTATUS )ntStatus >= 0)
	{
		USHORT i = 0;
		#line 385
		do
		{
			swprintf(deviceNameBuffer,
				"\134\0D\0e\0v\0i\0c\0e\0\134\0F\0l\0o\0p\0p\0y\0%\0d\0",
				i++);
			#line 388
			RtlInitUnicodeString(& deviceName, deviceNameBuffer);
			ntStatus = IoCreateDevice(DriverObject,
				sizeof(DISKETTE_EXTENSION ), & deviceName,
				0x00000007, 0x00000001 | 0x00000004 |
				0x00000100, 0, & deviceObject);
		}
		while(ntStatus == (NTSTATUS )0xC0000035L);
		#line 401
		if((NTSTATUS )ntStatus >= 0)
		{
			disketteExtension = (PDISKETTE_EXTENSION
				)deviceObject->DeviceExtension;
			#line 409
			do
			{
				#line 409
				;
			}
			while(0);
			#line 411
			(disketteExtension->DeviceName).Buffer =
				ExAllocatePoolWithTag(PagedPool,
				deviceName.Length, 'polF');
			#line 412
			if((disketteExtension->DeviceName).Buffer == (void * 
				)0)
			{
				#line 414
				IoDeleteDevice(deviceObject);
				return (NTSTATUS )0xC000009AL;
			}
			(disketteExtension->DeviceName).Length = 0;
			(disketteExtension->DeviceName).MaximumLength =
				deviceName.Length;
			#line 419
			RtlCopyUnicodeString(& disketteExtension->DeviceName, &
				deviceName);
			(IoGetConfigurationInformation())->FloppyCount++;
			#line 429
			sprintf(arcNameBuffer, "%s(%d)disk(%d)fdisk(%d)",
				"\134ArcName\134multi", fdcInfo.BusNumber,
				fdcInfo.ControllerNumber,
				fdcInfo.PeripheralNumber);
			#line 436
			RtlInitString(& arcNameString, arcNameBuffer);
			#line 438
			ntStatus =
				RtlAnsiStringToUnicodeString(&
				disketteExtension->ArcName, & arcNameString, 1);
			#line 442
			if((NTSTATUS )ntStatus >= 0)
			{
				IoCreateSymbolicLink(&
					disketteExtension->ArcName, &
					deviceName);
			}
			#line 447
			deviceObject->Flags |= 0x00000010 | 0x00002000;
			#line 449
			if(deviceObject->AlignmentRequirement < 0x00000001)
			{
				deviceObject->AlignmentRequirement = 0x00000001;
			}
			#line 454
			deviceObject->Flags &= ~ 0x00000080;
			#line 456
			disketteExtension->DriverObject = DriverObject;
			#line 459
			disketteExtension->UnderlyingPDO = PhysicalDeviceObject;
			#line 464
			do
			{
				#line 464
				;
			}
			while(0);
			#line 466
			disketteExtension->TargetObject =
				IoAttachDeviceToDeviceStack(deviceObject,
				PhysicalDeviceObject);
			#line 472
			do
			{
				#line 472
				;
			}
			while(0);
			#line 474
			KeInitializeSemaphore(&
				disketteExtension->RequestSemaphore, 0L,
				0x7fffffff);
			#line 478
			(& disketteExtension->PowerDownMutex)->Count = 1;
			#line 478
			(& disketteExtension->PowerDownMutex)->Contention = 0;
			#line 478
			KeInitializeEvent(& (&
				disketteExtension->PowerDownMutex)->Event,
				SynchronizationEvent, 0);
			#line 478
			;
			#line 480
			KeInitializeSpinLock(& disketteExtension->ListSpinLock);
			#line 482
			(& disketteExtension->ThreadReferenceMutex)->Count = 1;
			#line 482
			(& disketteExtension->ThreadReferenceMutex)->Contention
				= 0;
			#line 482
			KeInitializeEvent(& (&
				disketteExtension->ThreadReferenceMutex)->Event,
				SynchronizationEvent, 0);
			#line 482
			;
			#line 484
			(& disketteExtension->HoldNewReqMutex)->Count = 1;
			#line 484
			(& disketteExtension->HoldNewReqMutex)->Contention = 0;
			#line 484
			KeInitializeEvent(& (&
				disketteExtension->HoldNewReqMutex)->Event,
				SynchronizationEvent, 0);
			#line 484
			;
			#line 486
			(& disketteExtension->ListEntry)->Flink = ((&
				disketteExtension->ListEntry)->Blink = &
				disketteExtension->ListEntry);
			#line 488
			disketteExtension->ThreadReferenceCount = - 1;
			#line 490
			disketteExtension->IsStarted = 0;
			disketteExtension->IsRemoved = 0;
			disketteExtension->HoldNewRequests = 0;
			(& disketteExtension->NewRequestQueue)->Flink = ((&
				disketteExtension->NewRequestQueue)->Blink = &
				disketteExtension->NewRequestQueue);
			#line 494
			KeInitializeSpinLock(&
				disketteExtension->NewRequestQueueSpinLock);
			#line 495
			KeInitializeSpinLock(&
				disketteExtension->FlCancelSpinLock);
			disketteExtension->FloppyControllerAllocated = 0;
			disketteExtension->ReleaseFdcWithMotorRunning = 0;
			disketteExtension->DeviceObject = deviceObject;
			#line 501
			disketteExtension->IsReadOnly = 0;
			#line 503
			disketteExtension->MediaType = - 1;
			#line 505
			disketteExtension->ControllerConfigurable =
				((KUSER_SHARED_DATA * const
				)0xffdf0000)->AlternativeArchitecture ==
				NEC98x86 ? 0 : 1;
		}
	}
	#line 509
	return ntStatus;
}

NTSTATUS FlConfigCallBack(PVOID Context , PUNICODE_STRING PathName ,
	INTERFACE_TYPE BusType , ULONG BusNumber , PKEY_VALUE_FULL_INFORMATION
	*  BusInformation , CONFIGURATION_TYPE ControllerType , ULONG
	ControllerNumber , PKEY_VALUE_FULL_INFORMATION *  ControllerInformation
	, CONFIGURATION_TYPE PeripheralType , ULONG PeripheralNumber ,
	PKEY_VALUE_FULL_INFORMATION *  PeripheralInformation )
{
	#line 577
	PDISKETTE_EXTENSION disketteExtension = Context;
	#line 582
	ULONG i ;
	#line 584
	PCM_FULL_RESOURCE_DESCRIPTOR peripheralData ;
	#line 586
	NTSTATUS ntStatus ;
	#line 588
	;
	;
	#line 596
	if(! ((PUCHAR )PeripheralInformation[IoQueryDeviceConfigurationData] +
		(PeripheralInformation[IoQueryDeviceConfigurationData])->DataLength
		))
	{
		#line 599
		;
		return (NTSTATUS )0xC000000DL;
	}
	#line 604
	peripheralData = (PCM_FULL_RESOURCE_DESCRIPTOR )((PUCHAR
		)PeripheralInformation[IoQueryDeviceConfigurationData] +
		(PeripheralInformation[IoQueryDeviceConfigurationData])->DataOffset
		);
	#line 619
	for(i = 0; i < (peripheralData->PartialResourceList).Count; i++)
	{
		PCM_PARTIAL_RESOURCE_DESCRIPTOR partial = &
			((peripheralData->PartialResourceList).PartialDescriptors
			)[i];
		if(partial->Type == 5)
		{
			#line 631
			PCM_FLOPPY_DEVICE_DATA fDeviceData ;
			UCHAR driveType ;
			PDRIVE_MEDIA_CONSTANTS biosDriveMediaConstants = &
				disketteExtension->BiosDriveMediaConstants;
			#line 637
			fDeviceData = (PCM_FLOPPY_DEVICE_DATA )(partial + 1);
			#line 643
			switch(fDeviceData->MaxDensity)
			{
			case 360:
					#line 645
					;
				#line 645
				driveType = 0;
				#line 645
				break;
			case 1200:
					#line 646
					;
				#line 646
				driveType = 1;
				#line 646
				break;
			case 1185:
					#line 647
					;
				#line 647
				driveType = 1;
				#line 647
				break;
			case 1423:
					#line 648
					;
				#line 648
				driveType = 3;
				#line 648
				break;
			case 1440:
					#line 649
					;
				#line 649
				driveType = 3;
				#line 649
				break;
			case 2880:
					#line 650
					;
				#line 650
				driveType = 4;
				#line 650
				break;
			case 1201:
					#line 651
					;
				#line 651
				if(((KUSER_SHARED_DATA * const
					)0xffdf0000)->AlternativeArchitecture ==
					NEC98x86)
				{
					#line 652
					driveType = 5;
					#line 652
					break;
				}
				#line 655
			default :
					#line 655
					;
				#line 662
				do
				{
					#line 662
					;
				}
				while(0);
				#line 664
				driveType = 1;
				#line 671
				do
				{
					#line 671
					;
				}
				while(0);
				#line 673
				break;
			}
			#line 677
			disketteExtension->DriveType = driveType;
			#line 684
			* biosDriveMediaConstants =
				DriveMediaConstants[(DriveMediaLimits[driveType]
				).HighestDriveMediaType];
			#line 693
			if(fDeviceData->Version >= 2)
			{
				#line 698
				biosDriveMediaConstants->StepRateHeadUnloadTime
					= fDeviceData->StepRateHeadUnloadTime;
				#line 701
				biosDriveMediaConstants->HeadLoadTime =
					fDeviceData->HeadLoadTime;
				#line 704
				biosDriveMediaConstants->MotorOffTime =
					fDeviceData->MotorOffTime;
				#line 707
				biosDriveMediaConstants->SectorLengthCode =
					fDeviceData->SectorLengthCode;
				#line 712
				if(fDeviceData->SectorPerTrack == 0)
				{
					#line 716
					return (NTSTATUS )0x00000000L;
				}
				#line 719
				if(fDeviceData->MaxDensity == 0)
				{
					#line 727
					return (NTSTATUS )0x00000000L;
				}
				#line 730
				biosDriveMediaConstants->SectorsPerTrack =
					fDeviceData->SectorPerTrack;
				#line 733
				biosDriveMediaConstants->ReadWriteGapLength =
					fDeviceData->ReadWriteGapLength;
				#line 736
				biosDriveMediaConstants->FormatGapLength =
					fDeviceData->FormatGapLength;
				#line 739
				biosDriveMediaConstants->FormatFillCharacter =
					fDeviceData->FormatFillCharacter;
				#line 742
				biosDriveMediaConstants->HeadSettleTime =
					fDeviceData->HeadSettleTime;
				#line 745
				biosDriveMediaConstants->MotorSettleTimeRead =
					fDeviceData->MotorSettleTime * 1000 / 8;
				#line 748
				biosDriveMediaConstants->MotorSettleTimeWrite =
					fDeviceData->MotorSettleTime * 1000 / 8;
				#line 751
				if(fDeviceData->MaximumTrackValue == 0)
				{
					#line 755
					return (NTSTATUS )0x00000000L;
				}
				#line 758
				biosDriveMediaConstants->MaximumTrack =
					fDeviceData->MaximumTrackValue;
				#line 761
				biosDriveMediaConstants->DataLength =
					fDeviceData->DataTransferLength;
			}
		}
	}
	#line 767
	return (NTSTATUS )0x00000000L;
}

NTSTATUS FlAcpiConfigureFloppy(PDISKETTE_EXTENSION DisketteExtension , PFDC_INFO
	FdcInfo )
{
	#line 787
	UCHAR driveType ;
	#line 789
	PDRIVE_MEDIA_CONSTANTS biosDriveMediaConstants = &
		DisketteExtension->BiosDriveMediaConstants;
	#line 792
	if(! FdcInfo->AcpiFdiSupported)
	{
		return (NTSTATUS )0xC0000001L;
	}
	#line 802
	switch((ACPI_FDI_DEVICE_TYPE )(FdcInfo->AcpiFdiData).DeviceType)
	{
	case Form525Capacity360:
			#line 804
			;
		#line 804
		driveType = 0;
		#line 804
		break;
	case Form525Capacity1200:
			#line 805
			;
		#line 805
		driveType = 1;
		#line 805
		break;
	case Form35Capacity720:
			#line 806
			;
		#line 806
		driveType = 2;
		#line 806
		break;
	case Form35Capacity1440:
			#line 807
			;
		#line 807
		driveType = 3;
		#line 807
		break;
	case Form35Capacity2880:
			#line 808
			;
		#line 808
		driveType = 4;
		#line 808
		break;
		#line 810
	default :
			#line 810
			;
		#line 810
		driveType = 1;
		#line 810
		break;
	}
	#line 814
	DisketteExtension->DriveType = driveType;
	#line 821
	* biosDriveMediaConstants =
		DriveMediaConstants[(DriveMediaLimits[driveType]).HighestDriveMediaType
		];
	biosDriveMediaConstants->StepRateHeadUnloadTime = (UCHAR
		)(FdcInfo->AcpiFdiData).StepRateHeadUnloadTime;
	#line 825
	biosDriveMediaConstants->HeadLoadTime = (UCHAR
		)(FdcInfo->AcpiFdiData).HeadLoadTime;
	#line 826
	biosDriveMediaConstants->MotorOffTime = (UCHAR
		)(FdcInfo->AcpiFdiData).MotorOffTime;
	#line 827
	biosDriveMediaConstants->SectorLengthCode = (UCHAR
		)(FdcInfo->AcpiFdiData).SectorLengthCode;
	#line 828
	biosDriveMediaConstants->SectorsPerTrack = (UCHAR
		)(FdcInfo->AcpiFdiData).SectorPerTrack;
	#line 829
	biosDriveMediaConstants->ReadWriteGapLength = (UCHAR
		)(FdcInfo->AcpiFdiData).ReadWriteGapLength;
	#line 830
	biosDriveMediaConstants->FormatGapLength = (UCHAR
		)(FdcInfo->AcpiFdiData).FormatGapLength;
	#line 831
	biosDriveMediaConstants->FormatFillCharacter = (UCHAR
		)(FdcInfo->AcpiFdiData).FormatFillCharacter;
	#line 832
	biosDriveMediaConstants->HeadSettleTime = (UCHAR
		)(FdcInfo->AcpiFdiData).HeadSettleTime;
	#line 833
	biosDriveMediaConstants->MotorSettleTimeRead = (UCHAR
		)(FdcInfo->AcpiFdiData).MotorSettleTime * 1000 / 8;
	#line 834
	biosDriveMediaConstants->MotorSettleTimeWrite = (USHORT
		)(FdcInfo->AcpiFdiData).MotorSettleTime * 1000 / 8;
	#line 835
	biosDriveMediaConstants->MaximumTrack = (UCHAR
		)(FdcInfo->AcpiFdiData).MaxCylinderNumber;
	#line 836
	biosDriveMediaConstants->DataLength = (UCHAR
		)(FdcInfo->AcpiFdiData).DataTransferLength;
	return (NTSTATUS )0x00000000L;
}

NTSTATUS FlQueueIrpToThread(PIRP Irp , PDISKETTE_EXTENSION DisketteExtension )
{
	#line 868
	KIRQL oldIrql ;
	NTSTATUS status ;
	HANDLE threadHandle ;
	PIO_STACK_LOCATION irpSp = ((Irp->Tail).Overlay).CurrentStackLocation;
	#line 878
	ExAcquireFastMutex(& DisketteExtension->PowerDownMutex);
	if(DisketteExtension->PoweringDown == 1)
	{
		#line 880
		ExReleaseFastMutex(& DisketteExtension->PowerDownMutex);
		#line 882
		do
		{
			#line 882
			;
		}
		while(0);
		#line 884
		myStatus = (NTSTATUS) 0xC00002D3L;

		(Irp->IoStatus).Status = (NTSTATUS )0xC00002D3L;
		(Irp->IoStatus).Information = 0;
		return (NTSTATUS )0xC00002D3L;
	}
	ExReleaseFastMutex(& DisketteExtension->PowerDownMutex);
	do
	{
		#line 889
		;
	}
	while(0);
	#line 891
	ExAcquireFastMutex(& DisketteExtension->ThreadReferenceMutex);
	#line 893
	if(++ DisketteExtension->ThreadReferenceCount == 0)
	{
		#line 894
		OBJECT_ATTRIBUTES ObjAttributes ;
		#line 896
		DisketteExtension->ThreadReferenceCount++;
		{
			ExAcquireFastMutex(PagingMutex);
			#line 898
			if(++ PagingReferenceCount == 1)
			{
				#line 898
				MmResetDriverPaging(DriverEntry);
			}
			#line 898
			ExReleaseFastMutex(PagingMutex);
		}
		#line 898
		;
		#line 903
		;
		{
			#line 907
			(& ObjAttributes)->Length = sizeof(OBJECT_ATTRIBUTES );
			#line 907
			(& ObjAttributes)->RootDirectory = (void *  )0;
			#line 907
			(& ObjAttributes)->Attributes = 0x00000200L;
			#line 907
			(& ObjAttributes)->ObjectName = (void *  )0;
			#line 907
			(& ObjAttributes)->SecurityDescriptor = (void *  )0;
			#line 907
			(& ObjAttributes)->SecurityQualityOfService = (void * 
				)0;
		}
		#line 907
		;
		#line 909
		status = PsCreateSystemThread(& threadHandle, (ACCESS_MASK )0L,
			& ObjAttributes, (HANDLE )0L, (void *  )0, FloppyThread,
			DisketteExtension);
		#line 917
		if(! ((NTSTATUS )status >= 0))
		{
			#line 918
			DisketteExtension->ThreadReferenceCount = - 1;
			{
				ExAcquireFastMutex(PagingMutex);
				#line 920
				if(-- PagingReferenceCount == 0)
				{
					#line 920
					MmPageEntireDriver(DriverEntry);
				}
				#line 920
				ExReleaseFastMutex(PagingMutex);
			}
			#line 920
			;
			#line 922
			ExReleaseFastMutex(&
				DisketteExtension->ThreadReferenceMutex);
			#line 923
			return status;
		}
		#line 926
		status = ObReferenceObjectByHandle(threadHandle, 0x00100000L,
			(void *  )0, KernelMode, &
			DisketteExtension->FloppyThread, (void *  )0);
		#line 933
		;
		#line 935
		ZwClose(threadHandle);
		#line 937
		ExReleaseFastMutex(& DisketteExtension->ThreadReferenceMutex);
		#line 939
		if(! ((NTSTATUS )status >= 0))
		{
			#line 940
			return status;
		}
	}
	else
	{
		#line 944
		ExReleaseFastMutex(& DisketteExtension->ThreadReferenceMutex);
	}
	#line 947
	(((Irp->Tail).Overlay).CurrentStackLocation)->Control |= 0x01;
	if(pended == 0)
		#line 948
		pended = 1;
	else
		#line 949
		errorFn();
	#line 952
	ExfInterlockedInsertTailList(& DisketteExtension->ListEntry, &
		((Irp->Tail).Overlay).ListEntry, &
		DisketteExtension->ListSpinLock);
	#line 957
	KeReleaseSemaphore(& DisketteExtension->RequestSemaphore, (KPRIORITY )0,
		1, 0);
	#line 963
	return (NTSTATUS )0x00000103L;
}

NTSTATUS FloppyCreateClose(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
	#line 994
	DeviceObject;
	#line 999
	do
	{
		#line 999
		;
	}
	while(0);
	#line 1007
	myStatus = (NTSTATUS) 0x00000000L;

	(Irp->IoStatus).Status = (NTSTATUS )0x00000000L;
	(Irp->IoStatus).Information = 0x00000001;
	#line 1010
	IofCompleteRequest(Irp, 0);
	#line 1012
	return (NTSTATUS )0x00000000L;
}

NTSTATUS FloppyDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
	#line 1043
	PIO_STACK_LOCATION irpSp ;
	PDISKETTE_EXTENSION disketteExtension ;
	PDISK_GEOMETRY outputBuffer ;
	NTSTATUS ntStatus ;
	ULONG outputBufferLength ;
	UCHAR i ;
	DRIVE_MEDIA_TYPE lowestDriveMediaType ;
	DRIVE_MEDIA_TYPE highestDriveMediaType ;
	ULONG formatExParametersSize ;
	PFORMAT_EX_PARAMETERS formatExParameters ;
	#line 1054
	do
	{
		#line 1054
		;
	}
	while(0);
	#line 1056
	disketteExtension = DeviceObject->DeviceExtension;
	irpSp = ((Irp->Tail).Overlay).CurrentStackLocation;
	#line 1062
	ExAcquireFastMutex(& disketteExtension->HoldNewReqMutex);
	if(disketteExtension->HoldNewRequests)
	{
		#line 1070
		if(((irpSp->Parameters).DeviceIoControl).IoControlCode !=
			(0x00000032 << 16 | (0x0001 | 0x0002) << 14 | 0 << 2 |
			0))
		{
			#line 1072
			ntStatus =
				FloppyQueueRequest(disketteExtension, Irp);
			ExReleaseFastMutex(&
				disketteExtension->HoldNewReqMutex);
			#line 1075
			return ntStatus;
		}
	}
	ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex);
	#line 1083
	if(disketteExtension->IsRemoved)
	{
		(Irp->IoStatus).Information = 0;
		(Irp->IoStatus).Status = (NTSTATUS )0xC0000056L;
		myStatus = (NTSTATUS )0xC0000056L;	
		IofCompleteRequest(Irp, 0);
		return (NTSTATUS )0xC0000056L;
	}
	#line 1095
	if(! disketteExtension->IsStarted)
	{
		if(s == NP)
			#line 1097
			s = SKIP1;
		else
			#line 1098
			errorFn();
		Irp->CurrentLocation++;
		#line 1099
		((Irp->Tail).Overlay).CurrentStackLocation++;
		#line 1099
		;
		return IofCallDriver(disketteExtension->TargetObject, Irp);
	}
	#line 1103
	switch(((irpSp->Parameters).DeviceIoControl).IoControlCode)
	{
	case (ULONG )'M' << 16 | 0 << 14 | 2 << 2 | 0:
			#line 1105
			;
		{
			PMOUNTDEV_NAME mountName ;
			#line 1109
			do
			{
				#line 1109
				;
			}
			while(0);
			#line 1110
			;
			#line 1112
			if(((irpSp->Parameters).DeviceIoControl).OutputBufferLength
				< sizeof(MOUNTDEV_NAME ))
			{
				ntStatus = (NTSTATUS
					)0xC000000DL;
				#line 1116
				break;
			}
			#line 1119
			mountName = (Irp->AssociatedIrp).SystemBuffer;
			mountName->NameLength =
				(disketteExtension->DeviceName).Length;
			if(((irpSp->Parameters).DeviceIoControl).OutputBufferLength
				< sizeof(USHORT ) + mountName->NameLength)
			{
				ntStatus = (NTSTATUS
					)0x80000005L;
				#line 1126
				(Irp->IoStatus).Information =
					sizeof(MOUNTDEV_NAME );
				#line 1127
				break;
			}
			#line 1131
			memcpy(mountName->Name,
				(disketteExtension->DeviceName).Buffer,
				mountName->NameLength);
			#line 1133
			ntStatus = (NTSTATUS )0x00000000L;
			(Irp->IoStatus).Information = sizeof(USHORT ) +
				mountName->NameLength;
			#line 1135
			break;
		}
		#line 1138
	case (ULONG )'M' << 16 | 0 << 14 | 0 << 2 | 0:
			#line 1138
			;
		{
			PMOUNTDEV_UNIQUE_ID uniqueId ;
			#line 1142
			do
			{
				#line 1142
				;
			}
			while(0);
			#line 1144
			if(! (disketteExtension->InterfaceString).Buffer ||
				((irpSp->Parameters).DeviceIoControl).OutputBufferLength
				< sizeof(MOUNTDEV_UNIQUE_ID ))
			{
				ntStatus = (NTSTATUS
					)0xC000000DL;
				#line 1149
				break;
			}
			#line 1152
			uniqueId = (Irp->AssociatedIrp).SystemBuffer;
			uniqueId->UniqueIdLength =
				(disketteExtension->InterfaceString).Length;
			#line 1156
			if(((irpSp->Parameters).DeviceIoControl).OutputBufferLength
				< sizeof(USHORT ) + uniqueId->UniqueIdLength)
			{
				ntStatus = (NTSTATUS
					)0x80000005L;
				#line 1160
				(Irp->IoStatus).Information =
					sizeof(MOUNTDEV_UNIQUE_ID );
				#line 1161
				break;
			}
			#line 1166
			memcpy(uniqueId->UniqueId,
				(disketteExtension->InterfaceString).Buffer,
				uniqueId->UniqueIdLength);
			#line 1168
			ntStatus = (NTSTATUS )0x00000000L;
			(Irp->IoStatus).Information = sizeof(USHORT ) +
				uniqueId->UniqueIdLength;
			break;
		}
		#line 1174
	case 0x00000007 << 16 | (0x0001 | 0x0002) << 14 | 0x0006 << 2 | 0:
			#line 1174
			;
	case 0x00000007 << 16 | (0x0001 | 0x0002) << 14 | 0x000b << 2 | 0:
			#line 1175
			;
		#line 1181
		if(((irpSp->Parameters).DeviceIoControl).InputBufferLength <
			sizeof(FORMAT_PARAMETERS ))
		{
			#line 1187
			do
			{
				#line 1187
				;
			}
			while(0);
			#line 1189
			ntStatus = (NTSTATUS )0xC000000DL;
			break;
		}
		#line 1197
		if(! FlCheckFormatParameters(disketteExtension,
			(PFORMAT_PARAMETERS )(Irp->AssociatedIrp).SystemBuffer))
		{
			#line 1204
			do
			{
				#line 1204
				;
			}
			while(0);
			#line 1206
			ntStatus = (NTSTATUS )0xC000000DL;
			break;
		}
		#line 1214
		if(((irpSp->Parameters).DeviceIoControl).IoControlCode ==
			(0x00000007 << 16 | (0x0001 | 0x0002) << 14 | 0x000b <<
			2 | 0))
		{
			#line 1217
			if(((irpSp->Parameters).DeviceIoControl).InputBufferLength
				< sizeof(FORMAT_EX_PARAMETERS ))
			{
				ntStatus = (NTSTATUS
					)0xC000000DL;
				#line 1221
				break;
			}
			#line 1224
			formatExParameters = (PFORMAT_EX_PARAMETERS
				)(Irp->AssociatedIrp).SystemBuffer;
			formatExParametersSize = (LONG )((LONG_PTR )(&
				((FORMAT_EX_PARAMETERS *  )0)->SectorNumber)) +
				formatExParameters->SectorsPerTrack *
				sizeof(USHORT );
			if(((irpSp->Parameters).DeviceIoControl).InputBufferLength
				< formatExParametersSize ||
				formatExParameters->FormatGapLength >= 0x100 ||
				formatExParameters->SectorsPerTrack >= 0x100)
			{
				ntStatus = (NTSTATUS
					)0xC000000DL;
				#line 1236
				break;
			}
		}
		#line 1244
	case 0x00000007 << 16 | 0x0001 << 14 | 0x0200 << 2 | 0:
			#line 1244
			;
	case 0x0000002d << 16 | 0x0001 << 14 | 0x0200 << 2 | 0:
			#line 1245
			;
	case 0x00000007 << 16 | 0 << 14 | 0x0000 << 2 | 0:
			#line 1246
			;
	case 0x00000007 << 16 | 0 << 14 | 0x0009 << 2 | 0:
			#line 1247
			;
		#line 1267
		do
		{
			#line 1267
			;
		}
		while(0);
		#line 1269
		ntStatus = FlQueueIrpToThread(Irp,
			disketteExtension);
		break;
		#line 1273
	case 0x00000007 << 16 | 0 << 14 | 0x0300 << 2 | 0:
			#line 1273
			;
	case 0x0000002d << 16 | 0 << 14 | 0x0300 << 2 | 0:
			#line 1274
			;
		{
			#line 1279
			do
			{
				#line 1279
				;
			}
			while(0);
			#line 1281
			lowestDriveMediaType =
				(DriveMediaLimits[disketteExtension->DriveType])
				.LowestDriveMediaType;
			#line 1283
			highestDriveMediaType =
				(DriveMediaLimits[disketteExtension->DriveType])
				.HighestDriveMediaType;
			outputBufferLength =
				((irpSp->Parameters).DeviceIoControl).OutputBufferLength
				;
			#line 1294
			if(outputBufferLength < sizeof(DISK_GEOMETRY ))
			{
				#line 1299
				do
				{
					#line 1299
					;
				}
				while(0);
				#line 1301
				ntStatus = (NTSTATUS
					)0xC0000023L;
				#line 1302
				break;
			}
			#line 1311
			ntStatus = (NTSTATUS )0x00000000L;
			#line 1313
			if(outputBufferLength < sizeof(DISK_GEOMETRY ) *
				(highestDriveMediaType - lowestDriveMediaType +
				1))
			{
				#line 1324
				do
				{
					#line 1324
					;
				}
				while(0);
				#line 1326
				ntStatus = (NTSTATUS
					)0x80000005L;
				highestDriveMediaType = (DRIVE_MEDIA_TYPE
					)(lowestDriveMediaType - 1 +
					outputBufferLength /
					sizeof(DISK_GEOMETRY ));
			}
			#line 1334
			outputBuffer = (PDISK_GEOMETRY
				)(Irp->AssociatedIrp).SystemBuffer;
			for(i = (UCHAR )lowestDriveMediaType; i <= (UCHAR
				)highestDriveMediaType; i++)
			{
				#line 1341
				outputBuffer->MediaType =
					(DriveMediaConstants[i]).MediaType;
				#line 1342
				(outputBuffer->Cylinders).LowPart =
					(DriveMediaConstants[i]).MaximumTrack +
					1;
				#line 1344
				(outputBuffer->Cylinders).HighPart = 0;
				outputBuffer->TracksPerCylinder =
					(DriveMediaConstants[i]).NumberOfHeads;
				outputBuffer->SectorsPerTrack =
					(DriveMediaConstants[i]).SectorsPerTrack
					;
				#line 1349
				outputBuffer->BytesPerSector =
					(DriveMediaConstants[i]).BytesPerSector;
				#line 1367
				do
				{
					#line 1367
					;
				}
				while(0);
				#line 1368
				outputBuffer++;
				#line 1370
				(Irp->IoStatus).Information +=
					sizeof(DISK_GEOMETRY );
			}
			break;
		}
		#line 1376
	case (ULONG )'M' << 16 | 0 << 14 | 3 << 2 | 0:
			#line 1376
			;
		{
			if(((KUSER_SHARED_DATA * const
				)0xffdf0000)->AlternativeArchitecture ==
				NEC98x86)
			{
				#line 1379
				PMOUNTDEV_SUGGESTED_LINK_NAME suggestedName ;
				WCHAR driveLetterNameBuffer[10] ;
				RTL_QUERY_REGISTRY_TABLE queryTable[2] ;
				PWSTR valueName ;
				UNICODE_STRING driveLetterName ;
				#line 1387
				do
				{
					#line 1387
					;
				}
				while(0);
				#line 1389
				if(! (DeviceObject->Characteristics &
					0x00000001))
				{
					#line 1391
					ntStatus = (NTSTATUS
						)0xC0000225L;
					#line 1392
					break;
				}
				#line 1395
				if(((irpSp->Parameters).DeviceIoControl).OutputBufferLength
					< sizeof(MOUNTDEV_SUGGESTED_LINK_NAME ))
				{
					ntStatus = (NTSTATUS
						)0xC000000DL;
					#line 1399
					break;
				}
				#line 1402
				valueName = ExAllocatePoolWithTag(PagedPool,
					sizeof(WCHAR ) * 64, 'polF');
				if(! valueName)
				{
					#line 1405
					ntStatus = (NTSTATUS
						)0xC000009AL;
					#line 1406
					break;
				}
				#line 1409
				memset(valueName, 0, sizeof(WCHAR ) * 64);
				#line 1412
				memcpy(valueName,
					(disketteExtension->DeviceName).Buffer,
					(disketteExtension->DeviceName).Length);
				#line 1414
				driveLetterName.Buffer = driveLetterNameBuffer;
				driveLetterName.MaximumLength = 20;
				driveLetterName.Length = 0;
				#line 1418
				memset(queryTable, 0, 2 *
					sizeof(RTL_QUERY_REGISTRY_TABLE ));
				#line 1419
				(queryTable[0]).Flags = 0x00000004 | 0x00000020;
				#line 1421
				(queryTable[0]).Name = valueName;
				(queryTable[0]).EntryContext = &
					driveLetterName;
				ntStatus =
					RtlQueryRegistryValues(0,
					"\134\0R\0e\0g\0i\0s\0t\0r\0y\0\134\0M\0a\0c\0h\0i\0n\0e\0\134\0S\0y\0s\0t\0e\0m\0\134\0D\0I\0S\0K\0",
					queryTable, (void *  )0, (void *  )0);
				if(! ((NTSTATUS )ntStatus >=
					0))
				{
					#line 1429
					ExFreePool(valueName);
					break;
				}
				#line 1433
				if(driveLetterName.Length != 4 ||
					(driveLetterName.Buffer)[0] < 'A' ||
					(driveLetterName.Buffer)[0] > 'Z' ||
					(driveLetterName.Buffer)[1] != ':')
				{
					ntStatus = (NTSTATUS
						)0xC0000225L;
					#line 1439
					ExFreePool(valueName);
					break;
				}
				#line 1443
				suggestedName =
					(Irp->AssociatedIrp).SystemBuffer;
				#line 1444
				suggestedName->UseOnlyIfThereAreNoOtherLinks =
					1;
				#line 1445
				suggestedName->NameLength = 28;
				#line 1447
				(Irp->IoStatus).Information = (LONG )((LONG_PTR
					)(& ((MOUNTDEV_SUGGESTED_LINK_NAME * 
					)0)->Name)) + 28;
				if(((irpSp->Parameters).DeviceIoControl).OutputBufferLength
					< (Irp->IoStatus).Information)
				{
					(Irp->IoStatus).Information =
						sizeof(MOUNTDEV_SUGGESTED_LINK_NAME
						);
					#line 1455
					ntStatus = (NTSTATUS
						)0x80000005L;
					#line 1456
					ExFreePool(valueName);
					break;
				}
				#line 1460
				RtlDeleteRegistryValue(0,
					"\134\0R\0e\0g\0i\0s\0t\0r\0y\0\134\0M\0a\0c\0h\0i\0n\0e\0\134\0S\0y\0s\0t\0e\0m\0\134\0D\0I\0S\0K\0",
					valueName);
				#line 1464
				ExFreePool(valueName);
				#line 1466
				memcpy(suggestedName->Name,
					"\134\0D\0o\0s\0D\0e\0v\0i\0c\0e\0s\0\134\0",
					24);
				#line 1467
				(suggestedName->Name)[12] =
					(driveLetterName.Buffer)[0];
				#line 1468
				(suggestedName->Name)[13] = ':';
				#line 1470
				break;
			}
		}
		#line 1476
	case 0x00000007 << 16 | 0 << 14 | 0x00f8 << 2 | 0:
			#line 1476
			;
		{
			if(((KUSER_SHARED_DATA * const
				)0xffdf0000)->AlternativeArchitecture ==
				NEC98x86)
			{
				do
				{
					#line 1482
					;
				}
				while(0);
				#line 1488
				if(((irpSp->Parameters).DeviceIoControl).OutputBufferLength
					< sizeof(SENSE_DEVISE_STATUS_PTOS ))
				{
					#line 1494
					do
					{
						#line 1494
						;
					}
					while(0);
					#line 1496
					ntStatus = (NTSTATUS
						)0xC000000DL;
					#line 1497
					break;
				}
				#line 1507
				do
				{
					#line 1507
					;
				}
				while(0);
				ntStatus =
					FlQueueIrpToThread(Irp,
					disketteExtension);
				#line 1512
				break;
			}
		}
		#line 1516
	default :
			#line 1516
			;
		{
			#line 1533
			if(s == NP)
				#line 1533
				s = SKIP1;
			else
				#line 1534
				errorFn();
			Irp->CurrentLocation++;
			#line 1535
			((Irp->Tail).Overlay).CurrentStackLocation++;
			#line 1535
			;
			ntStatus =
				IofCallDriver(disketteExtension->TargetObject,
				Irp);
			#line 1537
			return ntStatus;
		}
	}
	#line 1541
	if(ntStatus != (NTSTATUS )0x00000103L)
	{
		(Irp->IoStatus).Status = ntStatus;
		myStatus = ntStatus;

		if(! ((NTSTATUS )ntStatus >= 0) && (BOOLEAN
			)(ntStatus == (NTSTATUS )0xC00000A3L
			|| ntStatus == (NTSTATUS
			)0xC00000B5L || ntStatus ==
			(NTSTATUS )0xC00000A2L || ntStatus
			== (NTSTATUS )0xC0000013L ||
			ntStatus == (NTSTATUS )0x80000016L
			|| ntStatus == (NTSTATUS
			)0xC0000014L || ntStatus ==
			(NTSTATUS )0xC0000012L))
		{
			#line 1547
			IoSetHardErrorOrVerifyDevice(Irp, DeviceObject);
		}
		#line 1550
		IofCompleteRequest(Irp, 0);
	}
	#line 1553
	return ntStatus;
}

NTSTATUS FloppyPnp(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
	#line 1578
	PIO_STACK_LOCATION irpSp ;
	PDISKETTE_EXTENSION disketteExtension ;
	NTSTATUS ntStatus = (NTSTATUS )0x00000000L;
	ULONG i ;
	#line 1583
	do
	{
		#line 1583
		;
	}
	while(0);
	{
		#line 1588
		ExAcquireFastMutex(PagingMutex);
		#line 1588
		if(++ PagingReferenceCount == 1)
		{
			#line 1588
			MmResetDriverPaging(DriverEntry);
		}
		#line 1588
		ExReleaseFastMutex(PagingMutex);
	}
	#line 1588
	;
	#line 1591
	disketteExtension = DeviceObject->DeviceExtension;
	#line 1593
	irpSp = ((Irp->Tail).Overlay).CurrentStackLocation;
	#line 1595
	if(disketteExtension->IsRemoved)
	{
		#line 1601
		(Irp->IoStatus).Information = 0;
		(Irp->IoStatus).Status = (NTSTATUS )0xC0000056L;
		myStatus = (NTSTATUS )0xC0000056L;

		IofCompleteRequest(Irp, 0);
		return (NTSTATUS )0xC0000056L;
	}
	#line 1607
	switch(irpSp->MinorFunction)
	{
	case 0x00:
			#line 1609
			;
		#line 1611
		ntStatus = FloppyStartDevice(DeviceObject, Irp);
		break;
		#line 1614
	case 0x05:
			#line 1614
			;
	case 0x01:
			#line 1615
			;
		#line 1617
		if(irpSp->MinorFunction == 0x05)
		{
			#line 1618
			do
			{
				#line 1618
				;
			}
			while(0);
		}
		else
		{
			#line 1620
			do
			{
				#line 1620
				;
			}
			while(0);
		}
		#line 1623
		if(! disketteExtension->IsStarted)
		{
			#line 1627
			if(s == NP)
				#line 1627
				s = SKIP1;
			else
				#line 1627
				errorFn();
			Irp->CurrentLocation++;
			#line 1628
			((Irp->Tail).Overlay).CurrentStackLocation++;
			#line 1628
			;
			ntStatus =
				IofCallDriver(disketteExtension->TargetObject,
				Irp);
			#line 1631
			return ntStatus;
		}
		#line 1637
		ExAcquireFastMutex(& disketteExtension->HoldNewReqMutex);
		disketteExtension->HoldNewRequests = 1;
		ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex);
		#line 1646
		ntStatus = FlQueueIrpToThread(Irp, disketteExtension);
		#line 1652
		if(ntStatus == (NTSTATUS )0x00000103L)
		{
			;
			#line 1656
			KeWaitForSingleObject(disketteExtension->FloppyThread,
				Executive, KernelMode, 0, (void *  )0);
			#line 1666
			if(disketteExtension->FloppyThread != (void *  )0)
			{
				#line 1667
				ObfDereferenceObject(disketteExtension->FloppyThread
					);
			}
			disketteExtension->FloppyThread = (void *  )0;
			#line 1672
			(Irp->IoStatus).Status = (NTSTATUS )0x00000000L;
			myStatus = (NTSTATUS )0x00000000L;
			if(s == NP)
				#line 1673
				s = SKIP1;
			else
				#line 1673
				errorFn();
			Irp->CurrentLocation++;
			#line 1674
			((Irp->Tail).Overlay).CurrentStackLocation++;
			#line 1674
			;
			ntStatus =
				IofCallDriver(disketteExtension->TargetObject,
				Irp);
		}
		else
		{
			#line 1682
			ntStatus = (NTSTATUS )0xC0000001L;
			(Irp->IoStatus).Status = ntStatus;
			myStatus = ntStatus;

			(Irp->IoStatus).Information = 0;
			IofCompleteRequest(Irp, 0);
		}
		break;
		#line 1689
	case 0x06:
			#line 1689
			;
	case 0x03:
			#line 1690
			;
		#line 1692
		if(irpSp->MinorFunction == 0x06)
		{
			#line 1693
			do
			{
				#line 1693
				;
			}
			while(0);
		}
		else
		{
			#line 1695
			do
			{
				#line 1695
				;
			}
			while(0);
		}
		#line 1698
		if(! disketteExtension->IsStarted)
		{
			#line 1706
			(Irp->IoStatus).Status = (NTSTATUS )0x00000000L;
			myStatus = (NTSTATUS )0x00000000L;

			if(s == NP)
				#line 1707
				s = SKIP1;
			else
				#line 1707
				errorFn();
			Irp->CurrentLocation++;
			#line 1708
			((Irp->Tail).Overlay).CurrentStackLocation++;
			#line 1708
			;
			ntStatus =
				IofCallDriver(disketteExtension->TargetObject,
				Irp);
		}
		else
		{
			#line 1713
			KEVENT doneEvent ;
			#line 1718
			(Irp->IoStatus).Status = (NTSTATUS )0x00000000L;
			myStatus = (NTSTATUS )0x00000000L;
			{
				#line 1723
				PIO_STACK_LOCATION irpSp ;
				#line 1723
				PIO_STACK_LOCATION nextIrpSp ;
				#line 1723
				irpSp =
					((Irp->Tail).Overlay).CurrentStackLocation;
				#line 1723
				nextIrpSp =
					((Irp->Tail).Overlay).CurrentStackLocation
					- 1;
				#line 1723
				memcpy(nextIrpSp, irpSp, (LONG )((LONG_PTR )(&
					((IO_STACK_LOCATION * 
					)0)->CompletionRoutine)));
				#line 1723
				nextIrpSp->Control = 0;
			}
			#line 1723
			;
			#line 1729
			KeInitializeEvent(& doneEvent, SynchronizationEvent, 0);
			#line 1733
			if(s != NP)
				#line 1733
				errorFn();
			else
			{
				#line 1735
				if(compRegistered != 0)
					#line 1735
					errorFn();
				else
				{
					#line 1737
					compRegistered = 1;
					compFptr = FloppyPnpComplete;
				}
			}
			{
				#line 1744
				PIO_STACK_LOCATION irpSp ;
				#line 1744
				;
				#line 1744
				irpSp =
					((Irp->Tail).Overlay).CurrentStackLocation
					- 1;
				#line 1744
				irpSp->CompletionRoutine = FloppyPnpComplete;
				#line 1744
				irpSp->Context = & doneEvent;
				#line 1744
				irpSp->Control = 0;
				#line 1744
				if(1)
				{
					#line 1744
					irpSp->Control = 0x40;
				}
				#line 1744
				if(1)
				{
					#line 1744
					irpSp->Control |= 0x80;
				}
				#line 1744
				if(1)
				{
					#line 1744
					irpSp->Control |= 0x20;
				}
			}
			#line 1744
			;
			#line 1746
			ntStatus =
				IofCallDriver(disketteExtension->TargetObject,
				Irp);
			#line 1748
			if(ntStatus == (NTSTATUS )0x00000103L)
			{
				KeWaitForSingleObject(& doneEvent, Executive,
					KernelMode, 0, (void *  )0);
				#line 1756
				//BLAST ntStatus = (Irp->IoStatus).Status;
				ntStatus = myStatus;
			}
			#line 1759
			ExAcquireFastMutex(&
				disketteExtension->HoldNewReqMutex);
			#line 1760
			disketteExtension->HoldNewRequests = 0;
			ExReleaseFastMutex(&
				disketteExtension->HoldNewReqMutex);
			#line 1766
			FloppyProcessQueuedRequests(disketteExtension);
			#line 1772
			(Irp->IoStatus).Status = ntStatus;
			myStatus = ntStatus;

			(Irp->IoStatus).Information = 0;
			IofCompleteRequest(Irp, 0);
		}
		break;
		#line 1778
	case 0x04:
			#line 1778
			;
		#line 1780
		do
		{
			#line 1780
			;
		}
		while(0);
		#line 1782
		disketteExtension->IsStarted = 0;
		#line 1784
		(Irp->IoStatus).Status = (NTSTATUS )0x00000000L;
		myStatus = (NTSTATUS )0x00000000L;
		if(s == NP)
			#line 1785
			s = SKIP1;
		else
			#line 1785
			errorFn();
		Irp->CurrentLocation++;
		#line 1786
		((Irp->Tail).Overlay).CurrentStackLocation++;
		#line 1786
		;
		ntStatus =
			IofCallDriver(disketteExtension->TargetObject, Irp);
		break;
		#line 1791
	case 0x02:
			#line 1791
			;
		#line 1793
		do
		{
			#line 1793
			;
		}
		while(0);
		#line 1800
		ExAcquireFastMutex(& disketteExtension->HoldNewReqMutex);
		disketteExtension->HoldNewRequests = 0;
		ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex);
		#line 1804
		disketteExtension->IsStarted = 0;
		disketteExtension->IsRemoved = 1;
		#line 1815
		FloppyProcessQueuedRequests(disketteExtension);
		#line 1820
		if(s == NP)
			#line 1820
			s = SKIP1;
		else
			#line 1820
			errorFn();
		Irp->CurrentLocation++;
		#line 1821
		((Irp->Tail).Overlay).CurrentStackLocation++;
		#line 1821
		;
		(Irp->IoStatus).Status = (NTSTATUS )0x00000000L;
		myStatus = (NTSTATUS )0x00000000L;
		ntStatus =
			IofCallDriver(disketteExtension->TargetObject, Irp);
		#line 1828
		if((disketteExtension->InterfaceString).Buffer != (void *  )0)
		{
			IoSetDeviceInterfaceState(&
				disketteExtension->InterfaceString, 0);
			#line 1833
			RtlFreeUnicodeString(&
				disketteExtension->InterfaceString);
			#line 1834
			RtlInitUnicodeString(&
				disketteExtension->InterfaceString, (void * 
				)0);
		}
		#line 1837
		RtlFreeUnicodeString(& disketteExtension->DeviceName);
		RtlInitUnicodeString(& disketteExtension->DeviceName, (void * 
			)0);
		if((disketteExtension->ArcName).Length != 0)
		{
			IoDeleteSymbolicLink(& disketteExtension->ArcName);
			RtlFreeUnicodeString(& disketteExtension->ArcName);
			RtlInitUnicodeString(& disketteExtension->ArcName,
				(void *  )0);
		}
		#line 1850
		IoDetachDevice(disketteExtension->TargetObject);
		#line 1855
		IoDeleteDevice(DeviceObject);
		#line 1857
		(IoGetConfigurationInformation())->FloppyCount--;
		#line 1859
		break;
		#line 1861
	default :
			#line 1861
			;
		do
		{
			#line 1862
			;
		}
		while(0);
		#line 1863
		if(s == NP)
			#line 1863
			s = SKIP1;
		else
			#line 1863
			errorFn();
		Irp->CurrentLocation++;
		#line 1864
		((Irp->Tail).Overlay).CurrentStackLocation++;
		#line 1864
		;
		ntStatus =
			IofCallDriver(disketteExtension->TargetObject, Irp);
	}
	{
		#line 1871
		ExAcquireFastMutex(PagingMutex);
		#line 1871
		if(-- PagingReferenceCount == 0)
		{
			#line 1871
			MmPageEntireDriver(DriverEntry);
		}
		#line 1871
		ExReleaseFastMutex(PagingMutex);
	}
	#line 1871
	;
	#line 1873
	return ntStatus;
}

NTSTATUS FloppyStartDevice(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
	#line 1882
	NTSTATUS ntStatus ;
	NTSTATUS pnpStatus ;
	KEVENT doneEvent ;
	FDC_INFO fdcInfo ;
	#line 1887
	CONFIGURATION_TYPE Dc = DiskController;
	CONFIGURATION_TYPE Fp = FloppyDiskPeripheral;
	#line 1890
	PDISKETTE_EXTENSION disketteExtension = (PDISKETTE_EXTENSION
		)DeviceObject->DeviceExtension;
	#line 1891
	PIO_STACK_LOCATION irpSp = ((Irp->Tail).Overlay).CurrentStackLocation;
	#line 1893
	do
	{
		#line 1893
		;
	}
	while(0);
	#line 1894
	do
	{
		#line 1894
		;
	}
	while(0);
	#line 1895
	do
	{
		#line 1895
		;
	}
	while(0);
	#line 1900
	KeInitializeEvent(& doneEvent, NotificationEvent, 0);
	{
		PIO_STACK_LOCATION irpSp ;
		#line 1902
		PIO_STACK_LOCATION nextIrpSp ;
		#line 1902
		irpSp = ((Irp->Tail).Overlay).CurrentStackLocation;
		#line 1902
		nextIrpSp = ((Irp->Tail).Overlay).CurrentStackLocation - 1;
		#line 1902
		memcpy(nextIrpSp, irpSp, (LONG )((LONG_PTR )(&
			((IO_STACK_LOCATION *  )0)->CompletionRoutine)));
		#line 1902
		nextIrpSp->Control = 0;
	}
	#line 1902
	;
	#line 1904
	if(s != NP)
		#line 1904
		errorFn();
	else
	{
		#line 1906
		if(compRegistered != 0)
			#line 1906
			errorFn();
		else
		{
			#line 1908
			compRegistered = 1;
			compFptr = FloppyPnpComplete;
		}
	}
	{
		#line 1915
		PIO_STACK_LOCATION irpSp ;
		#line 1915
		;
		#line 1915
		irpSp = ((Irp->Tail).Overlay).CurrentStackLocation - 1;
		#line 1915
		irpSp->CompletionRoutine = FloppyPnpComplete;
		#line 1915
		irpSp->Context = & doneEvent;
		#line 1915
		irpSp->Control = 0;
		#line 1915
		if(1)
		{
			#line 1915
			irpSp->Control = 0x40;
		}
		#line 1915
		if(1)
		{
			#line 1915
			irpSp->Control |= 0x80;
		}
		#line 1915
		if(1)
		{
			#line 1915
			irpSp->Control |= 0x20;
		}
	}
	#line 1915
	;
	#line 1917
	ntStatus =
		IofCallDriver(disketteExtension->TargetObject, Irp);
	if(ntStatus == (NTSTATUS )0x00000103L)
	{
		ntStatus = KeWaitForSingleObject(& doneEvent,
			Executive, KernelMode, 0, (void *  )0);
		#line 1927
		;
		#line 1929
		//BLAST ntStatus = (Irp->IoStatus).Status;
		ntStatus = myStatus;
	}
	#line 1932
	fdcInfo.BufferCount = 0;
	fdcInfo.BufferSize = 0;
	#line 1935
	ntStatus =
		FlFdcDeviceIo(disketteExtension->TargetObject, 0x00000007 << 16
		| 0 << 14 | 0x302 << 2 | 3, & fdcInfo);
	#line 1939
	if((NTSTATUS )ntStatus >= 0)
	{
		disketteExtension->MaxTransferSize = fdcInfo.MaxTransferSize;
		#line 1943
		if(fdcInfo.AcpiBios && fdcInfo.AcpiFdiSupported)
		{
			#line 1946
			ntStatus =
				FlAcpiConfigureFloppy(disketteExtension, &
				fdcInfo);
			#line 1948
			if(disketteExtension->DriveType == 4)
			{
				disketteExtension->PerpendicularMode |= 1 <<
					fdcInfo.PeripheralNumber;
			}
		}
		else
		{
			#line 1955
			INTERFACE_TYPE InterfaceType ;
			#line 1957
			if(disketteExtension->DriveType == 4)
			{
				disketteExtension->PerpendicularMode |= 1 <<
					fdcInfo.PeripheralNumber;
			}
			#line 1966
			for(InterfaceType = 0; InterfaceType <
				MaximumInterfaceType; InterfaceType++)
			{
				#line 1970
				fdcInfo.BusType = InterfaceType;
				ntStatus =
					IoQueryDeviceDescription(&
					fdcInfo.BusType, & fdcInfo.BusNumber, &
					Dc, & fdcInfo.ControllerNumber, & Fp, &
					fdcInfo.PeripheralNumber,
					FlConfigCallBack, disketteExtension);
				#line 1980
				if((NTSTATUS )ntStatus >= 0)
				{
					#line 1985
					do
					{
						#line 1985
						;
					}
					while(0);
					#line 1986
					break;
				}
			}
		}
		#line 1991
		if((NTSTATUS )ntStatus >= 0)
		{
			if(((KUSER_SHARED_DATA * const
				)0xffdf0000)->AlternativeArchitecture ==
				NEC98x86)
			{
				#line 1994
				disketteExtension->DeviceUnit = (UCHAR
					)fdcInfo.UnitNumber;
				#line 1995
				disketteExtension->DriveOnValue = (UCHAR
					)fdcInfo.UnitNumber;
			}
			else
			{
				#line 1997
				disketteExtension->DeviceUnit = (UCHAR
					)fdcInfo.PeripheralNumber;
				#line 1998
				disketteExtension->DriveOnValue = (UCHAR
					)(fdcInfo.PeripheralNumber | 0x10 <<
					fdcInfo.PeripheralNumber);
			}
			pnpStatus =
				IoRegisterDeviceInterface(disketteExtension->UnderlyingPDO,
				(LPGUID )(& MOUNTDEV_MOUNTED_DEVICE_GUID),
				(void *  )0, &
				disketteExtension->InterfaceString);
			if((NTSTATUS )pnpStatus >= 0)
			{
				pnpStatus = IoSetDeviceInterfaceState(&
					disketteExtension->InterfaceString, 1);
			}
			#line 2013
			disketteExtension->IsStarted = 1;
			#line 2015
			ExAcquireFastMutex(&
				disketteExtension->HoldNewReqMutex);
			#line 2016
			disketteExtension->HoldNewRequests = 0;
			ExReleaseFastMutex(&
				disketteExtension->HoldNewReqMutex);
			FloppyProcessQueuedRequests(disketteExtension);
		}
	}
	#line 2023
	(Irp->IoStatus).Status = ntStatus;
	myStatus = ntStatus;
	IofCompleteRequest(Irp, 0);
	#line 2026
	return ntStatus;
}

NTSTATUS FloppyPnpComplete(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID
	Context )
{
	#line 2043
	KeSetEvent((PKEVENT )Context, 1, 0);
	#line 2047
	return (NTSTATUS )0xC0000016L;
}

NTSTATUS FloppyPower(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
	#line 2070
	PDISKETTE_EXTENSION disketteExtension ;
	NTSTATUS ntStatus = myStatus; //  BLAST (Irp->IoStatus).Status;
	PIO_STACK_LOCATION irpSp ;
	POWER_STATE_TYPE type ;
	POWER_STATE state ;
	BOOLEAN WaitForCompletion = 1;
	#line 2077
	do
	{
		#line 2077
		;
	}
	while(0);
	#line 2079
	disketteExtension = DeviceObject->DeviceExtension;
	irpSp = ((Irp->Tail).Overlay).CurrentStackLocation;
	#line 2082
	type = ((irpSp->Parameters).Power).Type;
	state = ((irpSp->Parameters).Power).State;
	#line 2085
	switch(irpSp->MinorFunction)
	{
	case 0x03:
			#line 2087
			;
		{
			#line 2090
			do
			{
				#line 2090
				;
			}
			while(0);
			#line 2092
			if(type == SystemPowerState && state.SystemState >
				PowerSystemHibernate)
			{
				#line 2097
				ntStatus = (NTSTATUS )0x00000000L;
				break;
			}
			#line 2107
			ExAcquireFastMutex(&
				disketteExtension->ThreadReferenceMutex);
			#line 2108
			if(disketteExtension->ThreadReferenceCount >= 0)
			{
				#line 2109
				ExReleaseFastMutex(&
					disketteExtension->ThreadReferenceMutex)
					;
				#line 2111
				do
				{
					#line 2111
					;
				}
				while(0);
				#line 2113
				PoStartNextPowerIrp(Irp);
				(Irp->IoStatus).Information = 0;
				(Irp->IoStatus).Status = (NTSTATUS )0x80000011L;
				myStatus = (NTSTATUS )0x80000011L;
				IofCompleteRequest(Irp, 0);
				return (NTSTATUS )0x80000011L;
			}
			ExReleaseFastMutex(&
				disketteExtension->ThreadReferenceMutex);
			ntStatus = (NTSTATUS )0x00000000L;
			break;
		}
		#line 2125
	case 0x02:
			#line 2125
			;
		{
			#line 2131
			if(type == SystemPowerState)
			{
				#line 2132
				ExAcquireFastMutex(&
					disketteExtension->PowerDownMutex);
				#line 2133
				if(state.SystemState == PowerSystemWorking)
				{
					#line 2134
					do
					{
						#line 2134
						;
					}
					while(0);
					#line 2135
					disketteExtension->PoweringDown = 0;
					WaitForCompletion = 0;
				}
				else
				{
					#line 2138
					do
					{
						#line 2138
						;
					}
					while(0);
					#line 2139
					WaitForCompletion = 1;
					disketteExtension->PoweringDown = 1;
				}
				ExReleaseFastMutex(&
					disketteExtension->PowerDownMutex);
				#line 2147
				if(disketteExtension->FloppyThread != (void * 
					)0 && WaitForCompletion == 1)
				{
					#line 2149
					KeWaitForSingleObject(disketteExtension->FloppyThread
						, Executive, KernelMode, 0,
						(void *  )0);
				}
			}
			#line 2157
			do
			{
				#line 2157
				;
			}
			while(0);
			#line 2158
			ntStatus = (NTSTATUS )0x00000000L;
			break;
		}
		#line 2162
	default :
			#line 2162
			;
		{
			#line 2163
			break;
		}
	}
	#line 2168
	PoStartNextPowerIrp(Irp);
	if(s == NP)
		#line 2169
		s = SKIP1;
	else
		#line 2169
		errorFn();
	Irp->CurrentLocation++;
	#line 2170
	((Irp->Tail).Overlay).CurrentStackLocation++;
	#line 2170
	;
	ntStatus = PoCallDriver(disketteExtension->TargetObject,
		Irp);
	return ntStatus;
}

NTSTATUS FloppyReadWrite(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
	#line 2204
	PIO_STACK_LOCATION irpSp ;
	NTSTATUS ntStatus ;
	PDISKETTE_EXTENSION disketteExtension ;
	#line 2208
	do
	{
		#line 2208
		;
	}
	while(0);
	#line 2210
	disketteExtension = DeviceObject->DeviceExtension;
	#line 2212
	irpSp = ((Irp->Tail).Overlay).CurrentStackLocation;
	#line 2218
	ExAcquireFastMutex(& disketteExtension->HoldNewReqMutex);
	if(disketteExtension->HoldNewRequests)
	{
		ntStatus = FloppyQueueRequest(disketteExtension, Irp);
		#line 2223
		ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex);
		return ntStatus;
	}
	ExReleaseFastMutex(& disketteExtension->HoldNewReqMutex);
	#line 2232
	if(disketteExtension->IsRemoved || ! disketteExtension->IsStarted)
	{
		if(disketteExtension->IsRemoved)
		{
			#line 2235
			ntStatus = (NTSTATUS )0xC0000056L;
		}
		else
		{
			#line 2237
			ntStatus = (NTSTATUS )0xC0000001L;
		}
		(Irp->IoStatus).Information = 0;
		(Irp->IoStatus).Status = ntStatus;
		myStatus = ntStatus;
		IofCompleteRequest(Irp, 0);
		return ntStatus;
	}
	#line 2245
	if(disketteExtension->MediaType > Unknown &&
		((((irpSp->Parameters).Read).ByteOffset).LowPart +
		((irpSp->Parameters).Read).Length >
		disketteExtension->ByteCapacity ||
		(((irpSp->Parameters).Read).Length &
		disketteExtension->BytesPerSector - 1) != 0))
	{
		do
		{
			#line 2252
			;
		}
		while(0);
		#line 2261
		do
		{
			#line 2261
			;
		}
		while(0);
		#line 2263
		ntStatus = (NTSTATUS )0xC000000DL;
	}
	else
	{
		#line 2272
		if(((irpSp->Parameters).Read).Length)
		{
			#line 2279
			do
			{
				#line 2279
				;
			}
			while(0);
			#line 2281
			ntStatus = FlQueueIrpToThread(Irp, disketteExtension);
		}
		else
		{
			#line 2288
			(Irp->IoStatus).Information = 0;
			(Irp->IoStatus).Status = (NTSTATUS )0x00000000L;
			myStatus = (NTSTATUS )0x00000000L;
			#line 2291
			do
			{
				#line 2291
				;
			}
			while(0);
			#line 2292
			IofCompleteRequest(Irp, 0);
			return (NTSTATUS )0x00000000L;
		}
	}
	#line 2297
	if(ntStatus != (NTSTATUS )0x00000103L)
	{
		#line 2298
		(Irp->IoStatus).Status = ntStatus;
		myStatus = ntStatus;
		#line 2301
		do
		{
			#line 2301
			;
		}
		while(0);
		#line 2302
		IofCompleteRequest(Irp, 0);
	}
	#line 2305
	return ntStatus;
}

NTSTATUS FlInterpretError(UCHAR StatusRegister1 , UCHAR StatusRegister2 )
{
	#line 2335
	if(StatusRegister1 & 0x20 || StatusRegister2 & 0x20)
	{
		#line 2341
		do
		{
			#line 2341
			;
		}
		while(0);
		#line 2342
		return (NTSTATUS )0xC000003FL;
	}
	#line 2345
	if(StatusRegister1 & 0x10)
	{
		#line 2350
		do
		{
			#line 2350
			;
		}
		while(0);
		#line 2351
		return (NTSTATUS )0xC000003CL;
	}
	#line 2354
	if(StatusRegister1 & 0x04 || StatusRegister1 & 0x80)
	{
		#line 2360
		do
		{
			#line 2360
			;
		}
		while(0);
		#line 2361
		return (NTSTATUS )0xC0000015L;
	}
	#line 2364
	if(StatusRegister2 & 0x01 || StatusRegister2 & 0x02 || StatusRegister2 &
		0x40)
	{
		#line 2371
		do
		{
			#line 2371
			;
		}
		while(0);
		#line 2372
		return (NTSTATUS )0xC000009CL;
	}
	#line 2375
	if(StatusRegister1 & 0x02)
	{
		#line 2380
		do
		{
			#line 2380
			;
		}
		while(0);
		#line 2381
		return (NTSTATUS )0xC00000A2L;
	}
	#line 2384
	if(StatusRegister1 & 0x01)
	{
		#line 2389
		do
		{
			#line 2389
			;
		}
		while(0);
		#line 2390
		return (NTSTATUS )0xC0000165L;
	}
	#line 2394
	if(StatusRegister2 & 0x10)
	{
		#line 2399
		do
		{
			#line 2399
			;
		}
		while(0);
		#line 2400
		return (NTSTATUS )0xC0000166L;
	}
	#line 2412
	do
	{
		#line 2412
		;
	}
	while(0);
	#line 2413
	return (NTSTATUS )0xC0000167L;
}

void FlFinishOperation(PIRP Irp , PDISKETTE_EXTENSION DisketteExtension )
{
	#line 2449
	NTSTATUS ntStatus ;
	#line 2454
	do
	{
		#line 2454
		;
	}
	while(0);
	#line 2460
//BLAST	if((Irp->IoStatus).Status != (NTSTATUS )0x00000000L &&
	if(myStatus != (NTSTATUS )0x00000000L &&
		DisketteExtension->HardwareFailed)
	{
		DisketteExtension->HardwareFailCount++;
		#line 2465
		if(DisketteExtension->HardwareFailCount < 2)
		{
			#line 2475
			ntStatus =
				FlInitializeControllerHardware(DisketteExtension)
				;
			#line 2477
			if((NTSTATUS )ntStatus >= 0)
			{
				#line 2482
				do
				{
					#line 2482
					;
				}
				while(0);
				#line 2490
				DisketteExtension->MediaType = - 1;
				#line 2496
				do
				{
					#line 2496
					;
				}
				while(0);
				#line 2498
				ExAcquireFastMutex(&
					DisketteExtension->ThreadReferenceMutex)
					;
				#line 2499
				;
				DisketteExtension->ThreadReferenceCount++;
				ExReleaseFastMutex(&
					DisketteExtension->ThreadReferenceMutex)
					;
				#line 2503
				ExfInterlockedInsertHeadList(&
					DisketteExtension->ListEntry, &
					((Irp->Tail).Overlay).ListEntry, &
					DisketteExtension->ListSpinLock);
				#line 2508
				return;
			}
			#line 2514
			do
			{
				#line 2514
				;
			}
			while(0);
		}
	}
	#line 2524
	DisketteExtension->HardwareFailCount = 0;
	#line 2532
/*BLAST	if(! ((NTSTATUS )(Irp->IoStatus).Status >= 0) && (BOOLEAN
		)((Irp->IoStatus).Status == (NTSTATUS )0xC00000A3L ||
		(Irp->IoStatus).Status == (NTSTATUS )0xC00000B5L ||
		(Irp->IoStatus).Status == (NTSTATUS )0xC00000A2L ||
		(Irp->IoStatus).Status == (NTSTATUS )0xC0000013L ||
		(Irp->IoStatus).Status == (NTSTATUS )0x80000016L ||
		(Irp->IoStatus).Status == (NTSTATUS )0xC0000014L ||
		(Irp->IoStatus).Status == (NTSTATUS )0xC0000012L))
*/
	if(! ((NTSTATUS )myStatus >= 0) && (BOOLEAN
		)(myStatus == (NTSTATUS )0xC00000A3L ||
		myStatus == (NTSTATUS )0xC00000B5L ||
		myStatus == (NTSTATUS )0xC00000A2L ||
		myStatus == (NTSTATUS )0xC0000013L ||
		myStatus == (NTSTATUS )0x80000016L ||
		myStatus == (NTSTATUS )0xC0000014L ||
		myStatus == (NTSTATUS )0xC0000012L))
	{
		#line 2535
		IoSetHardErrorOrVerifyDevice(Irp,
			DisketteExtension->DeviceObject);
	}
	#line 2544
/*BLAST
	if((Irp->IoStatus).Status != (NTSTATUS )0x00000000L &&
		(Irp->IoStatus).Status != (NTSTATUS )0x80000016L &&
		(Irp->IoStatus).Status != (NTSTATUS )0xC0000013L)
*/
	if(myStatus != (NTSTATUS )0x00000000L &&
		myStatus != (NTSTATUS )0x80000016L &&
		myStatus != (NTSTATUS )0xC0000013L)
	{
		#line 2551
		do
		{
			#line 2551
			;
		}
		while(0);
	}
	else
	{
		#line 2558
		do
		{
			#line 2558
			;
		}
		while(0);
	}
	#line 2564
	do
	{
		#line 2564
		;
	}
	while(0);
	#line 2569
	do
	{
		#line 2569
		;
	}
	while(0);
	#line 2579
	IofCompleteRequest(Irp, 1);
}

NTSTATUS FlStartDrive(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp , BOOLEAN
	WriteOperation , BOOLEAN SetUpMedia , BOOLEAN IgnoreChange )
{
	#line 2626
	LARGE_INTEGER delay ;
	BOOLEAN motorStarted ;
	BOOLEAN diskChanged ;
	UCHAR driveStatus ;
	NTSTATUS ntStatus = (NTSTATUS )0x00000000L;
	FDC_ENABLE_PARMS fdcEnableParms ;
	FDC_DISK_CHANGE_PARMS fdcDiskChangeParms ;
	#line 2637
	do
	{
		#line 2637
		;
	}
	while(0);
	#line 2654
	DriveMediaConstants[(DriveMediaLimits[DisketteExtension->DriveType]).HighestDriveMediaType
		] = DisketteExtension->BiosDriveMediaConstants;
	#line 2657
	if(DisketteExtension->MediaType == - 1 || DisketteExtension->MediaType
		== Unknown)
	{
		#line 2659
		DisketteExtension->DriveMediaConstants = DriveMediaConstants[0];
	}
	#line 2669
	fdcEnableParms.DriveOnValue = DisketteExtension->DriveOnValue;
	if(WriteOperation)
	{
		#line 2671
		fdcEnableParms.TimeToWait =
			(DisketteExtension->DriveMediaConstants).MotorSettleTimeWrite
			;
	}
	else
	{
		#line 2674
		fdcEnableParms.TimeToWait =
			(DisketteExtension->DriveMediaConstants).MotorSettleTimeRead
			;
	}
	ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, 0x00000007 <<
		16 | 0 << 14 | 0x306 << 2 | 3, & fdcEnableParms);
	#line 2682
	motorStarted = fdcEnableParms.MotorStarted;
	#line 2684
	if((NTSTATUS )ntStatus >= 0)
	{
		fdcDiskChangeParms.DriveOnValue =
			DisketteExtension->DriveOnValue;
		ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject,
			0x00000007 << 16 | 0 << 14 | 0x308 << 2 | 3, &
			fdcDiskChangeParms);
		#line 2692
		driveStatus = fdcDiskChangeParms.DriveStatus;
	}
	#line 2695
	if(! ((NTSTATUS )ntStatus >= 0))
	{
		#line 2696
		return ntStatus;
	}
	#line 2708
	if(DisketteExtension->DriveType == 0 && motorStarted ||
		DisketteExtension->DriveType != 0 && driveStatus & 0x80)
	{
		#line 2716
		do
		{
			#line 2716
			;
		}
		while(0);
		#line 2718
		DisketteExtension->MediaType = - 1;
		#line 2725
		if(((DisketteExtension->DeviceObject)->Vpb)->Flags & 0x00000001)
		{
			if(Irp)
			{
				#line 2728
				IoSetHardErrorOrVerifyDevice(Irp,
					DisketteExtension->DeviceObject);
			}
			(DisketteExtension->DeviceObject)->Flags |= 0x00000002;
		}
		#line 2741
		if(DisketteExtension->DriveType != 0)
		{
			if(((KUSER_SHARED_DATA * const
				)0xffdf0000)->AlternativeArchitecture ==
				NEC98x86)
			{
				#line 2749
				(DisketteExtension->FifoBuffer)[0] = 0x0E;
				(DisketteExtension->FifoBuffer)[1] =
					DisketteExtension->DeviceUnit;
				ntStatus = FlIssueCommand(DisketteExtension,
					DisketteExtension->FifoBuffer,
					DisketteExtension->FifoBuffer, (void * 
					)0, 0, 0);
				#line 2759
				if(! ((NTSTATUS )ntStatus >= 0))
				{
					#line 2764
					do
					{
						#line 2764
						;
					}
					while(0);
					#line 2766
					return ntStatus;
				}
				#line 2769
				if((DisketteExtension->FifoBuffer)[0] & 0x20)
				{
					driveStatus = 0x7f;
				}
				else
				{
					driveStatus = 0x80;
				}
				#line 2778
				if(driveStatus & 0x80)
				{
					#line 2788
					do
					{
						#line 2788
						;
					}
					while(0);
					#line 2795
					if(((DisketteExtension->DeviceObject)->Vpb
						)->Flags & 0x00000001)
					{
						#line 2797
						(DisketteExtension->DeviceObject
							)->Flags &= ~
							0x00000002;
					}
					return (NTSTATUS )0xC0000013L;
				}
			}
			#line 2815
			(DisketteExtension->FifoBuffer)[0] = 0x10;
			(DisketteExtension->FifoBuffer)[1] =
				DisketteExtension->DeviceUnit;
			#line 2817
			(DisketteExtension->FifoBuffer)[2] = 1;
			#line 2819
			ntStatus = FlIssueCommand(DisketteExtension,
				DisketteExtension->FifoBuffer,
				DisketteExtension->FifoBuffer, (void *  )0, 0,
				0);
			#line 2826
			if(! ((NTSTATUS )ntStatus >= 0))
			{
				#line 2829
				do
				{
					#line 2829
					;
				}
				while(0);
				#line 2831
				return ntStatus;
			}
			else
			{
				if(! ((DisketteExtension->FifoBuffer)[0] & 0x20)
					|| (DisketteExtension->FifoBuffer)[1] !=
					1)
				{
					#line 2841
					do
					{
						#line 2841
						;
					}
					while(0);
					#line 2843
					DisketteExtension->HardwareFailed = 1;
					#line 2845
					return (NTSTATUS )0xC0000168L;
				}
			}
			#line 2853
			(DisketteExtension->FifoBuffer)[0] = 0x10;
			(DisketteExtension->FifoBuffer)[1] =
				DisketteExtension->DeviceUnit;
			#line 2855
			(DisketteExtension->FifoBuffer)[2] = 0;
			#line 2862
			delay.LowPart = (ULONG )(- 900);
			delay.HighPart = - 1;
			KeDelayExecutionThread(KernelMode, 0, & delay);
			ntStatus = FlIssueCommand(DisketteExtension,
				DisketteExtension->FifoBuffer,
				DisketteExtension->FifoBuffer, (void *  )0, 0,
				0);
			#line 2875
			delay.LowPart = (ULONG )(- 5);
			delay.HighPart = - 1;
			KeDelayExecutionThread(KernelMode, 0, & delay);
			#line 2879
			if(! ((NTSTATUS )ntStatus >= 0))
			{
				#line 2882
				do
				{
					#line 2882
					;
				}
				while(0);
				#line 2884
				return ntStatus;
			}
			else
			{
				if(! ((DisketteExtension->FifoBuffer)[0] & 0x20)
					|| (DisketteExtension->FifoBuffer)[1] !=
					0)
				{
					#line 2894
					do
					{
						#line 2894
						;
					}
					while(0);
					#line 2896
					DisketteExtension->HardwareFailed = 1;
					#line 2898
					return (NTSTATUS )0xC0000168L;
				}
			}
			#line 2903
			if(((KUSER_SHARED_DATA * const
				)0xffdf0000)->AlternativeArchitecture ==
				NEC98x86)
			{
				#line 2909
				(DisketteExtension->FifoBuffer)[0] = 0x0E;
				(DisketteExtension->FifoBuffer)[1] =
					DisketteExtension->DeviceUnit;
				ntStatus = FlIssueCommand(DisketteExtension,
					DisketteExtension->FifoBuffer,
					DisketteExtension->FifoBuffer, (void * 
					)0, 0, 0);
				#line 2919
				if(! ((NTSTATUS )ntStatus >= 0))
				{
					#line 2924
					do
					{
						#line 2924
						;
					}
					while(0);
					#line 2926
					return ntStatus;
				}
				#line 2929
				if((DisketteExtension->FifoBuffer)[0] & 0x20)
				{
					driveStatus = 0x7f;
				}
				else
				{
					driveStatus = 0x80;
				}
			}
			else
			{
				#line 2939
				ntStatus =
					FlFdcDeviceIo(DisketteExtension->TargetObject,
					0x00000007 << 16 | 0 << 14 | 0x308 << 2
					| 3, & fdcDiskChangeParms);
				driveStatus = fdcDiskChangeParms.DriveStatus;
				#line 2945
				if(! ((NTSTATUS )ntStatus >= 0))
				{
					#line 2946
					return ntStatus;
				}
			}
			#line 2950
			if(driveStatus & 0x80)
			{
				#line 2960
				do
				{
					#line 2960
					;
				}
				while(0);
				#line 2967
				if(((DisketteExtension->DeviceObject)->Vpb)->Flags
					& 0x00000001)
				{
					#line 2969
					(DisketteExtension->DeviceObject)->Flags
						&= ~ 0x00000002;
				}
				#line 2973
				return (NTSTATUS )0xC0000013L;
			}
		}
		#line 2982
		if(IgnoreChange == 0)
		{
			if(((DisketteExtension->DeviceObject)->Vpb)->Flags &
				0x00000001)
			{
				#line 2994
				do
				{
					#line 2994
					;
				}
				while(0);
				#line 2996
				return (NTSTATUS )0x80000016L;
			}
			else
			{
				return (NTSTATUS )0xC0000185L;
			}
		}
	}
	else
	{
		#line 3004
		if(((KUSER_SHARED_DATA * const
			)0xffdf0000)->AlternativeArchitecture == NEC98x86)
		{
			#line 3006
			FlHdbit(DisketteExtension);
		}
	}
	#line 3011
	if(SetUpMedia)
	{
		if(DisketteExtension->MediaType == - 1)
		{
			ntStatus = FlDetermineMediaType(DisketteExtension);
		}
		else
		{
			if(DisketteExtension->MediaType == Unknown)
			{
				#line 3029
				do
				{
					#line 3029
					;
				}
				while(0);
				#line 3030
				return (NTSTATUS )0xC0000014L;
			}
			else
			{
				if(DisketteExtension->DriveMediaType !=
					DisketteExtension->LastDriveMediaType)
				{
					#line 3042
					ntStatus =
						FlDatarateSpecifyConfigure(DisketteExtension)
						;
					#line 3043
					if(! ((NTSTATUS )ntStatus >= 0))
					{
						#line 3050
						do
						{
							#line 3050
							;
						}
						while(0);
					}
				}
			}
		}
	}
	#line 3063
	if(WriteOperation && (NTSTATUS )ntStatus >= 0)
	{
		(DisketteExtension->FifoBuffer)[0] = 0x0E;
		(DisketteExtension->FifoBuffer)[1] =
			DisketteExtension->DeviceUnit;
		ntStatus = FlIssueCommand(DisketteExtension,
			DisketteExtension->FifoBuffer,
			DisketteExtension->FifoBuffer, (void *  )0, 0, 0);
		#line 3075
		if(! ((NTSTATUS )ntStatus >= 0))
		{
			#line 3080
			do
			{
				#line 3080
				;
			}
			while(0);
			#line 3082
			return ntStatus;
		}
		#line 3085
		if(((KUSER_SHARED_DATA * const
			)0xffdf0000)->AlternativeArchitecture == NEC98x86)
		{
			#line 3089
			if(! ((DisketteExtension->FifoBuffer)[0] & 0x20))
			{
				#line 3094
				do
				{
					#line 3094
					;
				}
				while(0);
				#line 3095
				return (NTSTATUS )0xC0000013L;
			}
		}
		#line 3099
		if((DisketteExtension->FifoBuffer)[0] & 0x40)
		{
			#line 3104
			do
			{
				#line 3104
				;
			}
			while(0);
			#line 3105
			return (NTSTATUS )0xC00000A2L;
		}
	}
	#line 3109
	return ntStatus;
}

NTSTATUS FlDatarateSpecifyConfigure(PDISKETTE_EXTENSION DisketteExtension )
{
	#line 3142
	NTSTATUS ntStatus = (NTSTATUS )0x00000000L;
	#line 3148
	if(DisketteExtension->ControllerConfigurable)
	{
		(DisketteExtension->FifoBuffer)[0] = 0x11;
		(DisketteExtension->FifoBuffer)[1] = 0;
		#line 3153
		(DisketteExtension->FifoBuffer)[2] = 0x0F;
		(DisketteExtension->FifoBuffer)[2] += 0x10;
		#line 3156
		if(! (DisketteExtension->DriveMediaConstants).CylinderShift)
		{
			#line 3157
			(DisketteExtension->FifoBuffer)[2] += 0x40;
		}
		#line 3160
		(DisketteExtension->FifoBuffer)[3] = 0;
		#line 3162
		ntStatus = FlIssueCommand(DisketteExtension,
			DisketteExtension->FifoBuffer,
			DisketteExtension->FifoBuffer, (void *  )0, 0, 0);
		#line 3169
		if(ntStatus == (NTSTATUS )0xC00000A3L)
		{
			DisketteExtension->ControllerConfigurable = 0;
			ntStatus = (NTSTATUS )0x00000000L;
		}
	}
	#line 3181
	if((NTSTATUS )ntStatus >= 0 || ntStatus == (NTSTATUS )0xC00000A3L)
	{
		#line 3184
		(DisketteExtension->FifoBuffer)[0] = 0x0D;
		(DisketteExtension->FifoBuffer)[1] =
			(DisketteExtension->DriveMediaConstants).StepRateHeadUnloadTime
			;
		(DisketteExtension->FifoBuffer)[2] =
			(DisketteExtension->DriveMediaConstants).HeadLoadTime;
		#line 3191
		ntStatus = FlIssueCommand(DisketteExtension,
			DisketteExtension->FifoBuffer,
			DisketteExtension->FifoBuffer, (void *  )0, 0, 0);
		#line 3198
		if((NTSTATUS )ntStatus >= 0)
		{
			#line 3204
			ntStatus =
				FlFdcDeviceIo(DisketteExtension->TargetObject,
				0x00000007 << 16 | 0 << 14 | 0x309 << 2 | 3, &
				(DisketteExtension->DriveMediaConstants).DataTransferRate
				);
			#line 3214
			if((NTSTATUS )ntStatus >= 0)
			{
				ntStatus =
					FlRecalibrateDrive(DisketteExtension);
			}
		}
		else
		{
			do
			{
				#line 3222
				;
			}
			while(0);
		}
	}
	else
	{
		#line 3228
		do
		{
			#line 3228
			;
		}
		while(0);
	}
	#line 3231
	if((NTSTATUS )ntStatus >= 0)
	{
		DisketteExtension->LastDriveMediaType =
			DisketteExtension->DriveMediaType;
	}
	else
	{
		DisketteExtension->LastDriveMediaType = Unknown;
		#line 3242
		do
		{
			#line 3242
			;
		}
		while(0);
	}
	#line 3245
	return ntStatus;
}

NTSTATUS FlRecalibrateDrive(PDISKETTE_EXTENSION DisketteExtension )
{
	#line 3275
	NTSTATUS ntStatus ;
	UCHAR recalibrateCount ;
	#line 3278
	recalibrateCount = 0;
	#line 3280
	do
	{
		#line 3286
		(DisketteExtension->FifoBuffer)[0] = 0x0B;
		(DisketteExtension->FifoBuffer)[1] =
			DisketteExtension->DeviceUnit;
		ntStatus = FlIssueCommand(DisketteExtension,
			DisketteExtension->FifoBuffer,
			DisketteExtension->FifoBuffer, (void *  )0, 0, 0);
		#line 3296
		if(! ((NTSTATUS )ntStatus >= 0))
		{
			#line 3301
			do
			{
				#line 3301
				;
			}
			while(0);
		}
		if((NTSTATUS )ntStatus >= 0)
		{
			if(((KUSER_SHARED_DATA * const
				)0xffdf0000)->AlternativeArchitecture ==
				NEC98x86)
			{
				#line 3308
				UCHAR fifoBuffer[2] ;
				#line 3313
				fifoBuffer[0] =
					(DisketteExtension->FifoBuffer)[0];
				#line 3314
				fifoBuffer[1] =
					(DisketteExtension->FifoBuffer)[1];
				#line 3319
				(DisketteExtension->FifoBuffer)[0] = 0x0E;
				(DisketteExtension->FifoBuffer)[1] =
					DisketteExtension->DeviceUnit;
				ntStatus = FlIssueCommand(DisketteExtension,
					DisketteExtension->FifoBuffer,
					DisketteExtension->FifoBuffer, (void * 
					)0, 0, 0);
				#line 3329
				if(! ((NTSTATUS )ntStatus >= 0))
				{
					#line 3334
					do
					{
						#line 3334
						;
					}
					while(0);
					#line 3336
					return ntStatus;
				}
				#line 3339
				(DisketteExtension->FifoBuffer)[0] =
					fifoBuffer[0];
				#line 3340
				(DisketteExtension->FifoBuffer)[1] =
					fifoBuffer[1];
			}
			#line 3344
			if(! ((DisketteExtension->FifoBuffer)[0] & 0x20) ||
				(DisketteExtension->FifoBuffer)[1] != 0)
			{
				#line 3350
				do
				{
					#line 3350
					;
				}
				while(0);
				#line 3352
				DisketteExtension->HardwareFailed = 1;
				#line 3354
				ntStatus = (NTSTATUS )0xC0000168L;
			}
		}
		#line 3358
		recalibrateCount++;
	}
	while(! ((NTSTATUS )ntStatus >= 0) && recalibrateCount < 2);
	#line 3365
	do
	{
		#line 3365
		;
	}
	while(0);
	#line 3367
	return ntStatus;
}

NTSTATUS FlDetermineMediaType(PDISKETTE_EXTENSION DisketteExtension )
{
	#line 3397
	NTSTATUS ntStatus ;
	PDRIVE_MEDIA_CONSTANTS driveMediaConstants ;
	BOOLEAN mediaTypesExhausted ;
	ULONG retries = 0;
	#line 3402
	USHORT sectorLengthCode ;
	PBOOT_SECTOR_INFO bootSector ;
	LARGE_INTEGER offset ;
	PIRP irp ;
	#line 3410
	do
	{
		#line 3410
		;
	}
	while(0);
	#line 3412
	DisketteExtension->IsReadOnly = 0;
	#line 3418
	for(retries = 0; retries < 3; retries++)
	{
		if(retries)
		{
			#line 3432
			do
			{
				#line 3432
				;
			}
			while(0);
			#line 3433
			FlInitializeControllerHardware(DisketteExtension);
		}
		#line 3443
		DisketteExtension->DriveMediaType =
			(DriveMediaLimits[DisketteExtension->DriveType]).HighestDriveMediaType
			;
		#line 3445
		DisketteExtension->DriveMediaConstants =
			DriveMediaConstants[DisketteExtension->DriveMediaType];
		#line 3448
		mediaTypesExhausted = 0;
		#line 3450
		do
		{
			if(((KUSER_SHARED_DATA * const
				)0xffdf0000)->AlternativeArchitecture ==
				NEC98x86)
			{
				#line 3453
				sectorLengthCode =
					(DriveMediaConstants[DisketteExtension->DriveMediaType
					]).SectorLengthCode;
				#line 3455
				FlHdbit(DisketteExtension);
			}
			#line 3459
			ntStatus =
				FlDatarateSpecifyConfigure(DisketteExtension);
			if(! ((NTSTATUS )ntStatus >= 0))
			{
				#line 3471
				do
				{
					#line 3471
					;
				}
				while(0);
				#line 3472
				mediaTypesExhausted = 1;
			}
			else
			{
				#line 3481
				driveMediaConstants = &
					DriveMediaConstants[DisketteExtension->DriveMediaType
					];
				#line 3488
				(DisketteExtension->FifoBuffer)[1] = (UCHAR
					)(DisketteExtension->DeviceUnit |
					driveMediaConstants->NumberOfHeads - 1
					<< 2);
				(DisketteExtension->FifoBuffer)[0] = 0x14 +
					0x40;
				#line 3495
				ntStatus = FlIssueCommand(DisketteExtension,
					DisketteExtension->FifoBuffer,
					DisketteExtension->FifoBuffer, (void * 
					)0, 0, 0);
				#line 3502
				if(! ((NTSTATUS )ntStatus >= 0) ||
					((DisketteExtension->FifoBuffer)[0] & ~
					0x20) != (UCHAR
					)(DisketteExtension->DeviceUnit |
					driveMediaConstants->NumberOfHeads - 1
					<< 2) ||
					(DisketteExtension->FifoBuffer)[1] != 0
					|| (DisketteExtension->FifoBuffer)[2] !=
					0 || ((KUSER_SHARED_DATA * const
					)0xffdf0000)->AlternativeArchitecture ==
					NEC98x86 &&
					(DisketteExtension->FifoBuffer)[6] !=
					sectorLengthCode)
				{
					#line 3522
					do
					{
						#line 3522
						;
					}
					while(0);
					#line 3524
					DisketteExtension->DriveMediaType--;
					DisketteExtension->DriveMediaConstants =
						DriveMediaConstants[DisketteExtension
						->DriveMediaType];
					if(ntStatus != (NTSTATUS )0xC00000A3L)
					{
						ntStatus = (NTSTATUS
							)0xC0000014L;
					}
					#line 3538
					if((CHAR
						)DisketteExtension->DriveMediaType
						< (CHAR
						)(DriveMediaLimits[DisketteExtension->DriveType
						]).LowestDriveMediaType)
					{
						#line 3542
						DisketteExtension->MediaType =
							Unknown;
						#line 3543
						mediaTypesExhausted = 1;
						#line 3548
						do
						{
							#line 3548
							;
						}
						while(0);
					}
				}
				else
				{
					#line 3553
					if(((KUSER_SHARED_DATA * const
						)0xffdf0000)->AlternativeArchitecture
						== NEC98x86)
					{
						#line 3558
						DisketteExtension->MediaType =
							driveMediaConstants->MediaType
							;
						#line 3560
						DisketteExtension->BytesPerSector
							=
							driveMediaConstants->BytesPerSector;
						#line 3566
						do
						{
							#line 3566
							;
						}
						while(0);
						#line 3568
						DisketteExtension->ByteCapacity
							=
							driveMediaConstants->BytesPerSector
							*
							driveMediaConstants->SectorsPerTrack
							* (1 +
							driveMediaConstants->MaximumTrack
							) *
							driveMediaConstants->NumberOfHeads;
						#line 3578
						DisketteExtension->DriveMediaConstants
							=
							DriveMediaConstants[DisketteExtension->DriveMediaType
							];
						#line 3588
						bootSector =
							ExAllocatePoolWithTag(NonPagedPoolCacheAligned
							, ((KUSER_SHARED_DATA
							* const
							)0xffdf0000)->AlternativeArchitecture
							== NEC98x86 ? 1024
							: 512, 'polF');
						#line 3589
						if(! bootSector)
						{
							#line 3590
							return (NTSTATUS
								)0xC000009AL;
						}
						offset.LowPart =
							(offset.HighPart = 0);
						#line 3594
						irp =
							IoBuildAsynchronousFsdRequest(
							0x03,
							DisketteExtension->DeviceObject,
							bootSector,
							((KUSER_SHARED_DATA
							* const
							)0xffdf0000)->AlternativeArchitecture
							== NEC98x86 ? 1024
							: 512, & offset,
							(void *  )0);
						#line 3600
						if(! irp)
						{
							#line 3603
							do
							{
	#line 3603
	;
							}
							while(0);
							#line 3604
							ExFreePool(bootSector);
							return (NTSTATUS
								)0xC000009AL;
						}
						#line 3607
						irp->CurrentLocation--;
						((irp->Tail).Overlay).CurrentStackLocation
							=
							((irp->Tail).Overlay).CurrentStackLocation
							- 1;
						#line 3613
						ntStatus =
							FlReadWrite(DisketteExtension,
							irp, 1);
						#line 3618
						do
						{
							#line 3618
							;
						}
						while(0);
						#line 3620
						MmUnlockPages(irp->MdlAddress);
						IoFreeMdl(irp->MdlAddress);
						IoFreeIrp(irp);
						ExFreePool(bootSector);
						#line 3625
						if(! ((NTSTATUS )ntStatus >= 0))
						{
							#line 3642
							do
							{
	#line 3642
	;
							}
							while(0);
							#line 3644
							DisketteExtension->DriveMediaType
								--;
							DisketteExtension->DriveMediaConstants
								=
								DriveMediaConstants[
								DisketteExtension
								->DriveMediaType
								];
							#line 3649
							if(ntStatus != (NTSTATUS
								)0xC00000A3L)
							{
	#line 3651
	ntStatus = (NTSTATUS )0xC0000014L;
							}
							#line 3660
							if((CHAR
								)DisketteExtension->DriveMediaType
								< (CHAR
								)(DriveMediaLimits[
								DisketteExtension
								->DriveType]).LowestDriveMediaType
								)
							{
	#line 3664
	DisketteExtension->MediaType = Unknown;
	mediaTypesExhausted = 1;
	#line 3670
	do
	{
		#line 3670
		;
	}
	while(0);
							}
						}
					}
				}
			}
		}
		while(! ((NTSTATUS )ntStatus >= 0) && ! mediaTypesExhausted);
		if((NTSTATUS )ntStatus >= 0)
		{
			#line 3689
			do
			{
				#line 3689
				;
			}
			while(0);
			#line 3690
			break;
		}
	}
	#line 3694
	if(! ((NTSTATUS )ntStatus >= 0) || mediaTypesExhausted)
	{
		#line 3701
		do
		{
			#line 3701
			;
		}
		while(0);
		#line 3702
		return ntStatus;
	}
	#line 3705
	DisketteExtension->MediaType = driveMediaConstants->MediaType;
	DisketteExtension->BytesPerSector = driveMediaConstants->BytesPerSector;
	#line 3708
	DisketteExtension->ByteCapacity = driveMediaConstants->BytesPerSector *
		driveMediaConstants->SectorsPerTrack * (1 +
		driveMediaConstants->MaximumTrack) *
		driveMediaConstants->NumberOfHeads;
	#line 3720
	do
	{
		#line 3720
		;
	}
	while(0);
	#line 3725
	DisketteExtension->DriveMediaConstants =
		DriveMediaConstants[DisketteExtension->DriveMediaType];
	#line 3731
	FlCheckBootSector(DisketteExtension);
	#line 3733
	return ntStatus;
}

void FlAllocateIoBuffer(PDISKETTE_EXTENSION DisketteExtension , ULONG BufferSize
	)
{
	#line 3761
	BOOLEAN allocateContiguous ;
	LARGE_INTEGER maxDmaAddress ;
	#line 3764
	if(DisketteExtension->IoBuffer)
	{
		#line 3765
		if(DisketteExtension->IoBufferSize >= BufferSize)
		{
			#line 3766
			return;
		}
		FlFreeIoBuffer(DisketteExtension);
	}
	#line 3771
	if(BufferSize > DisketteExtension->MaxTransferSize)
	{
		#line 3772
		allocateContiguous = 1;
	}
	else
	{
		#line 3774
		allocateContiguous = 0;
	}
	#line 3777
	if(allocateContiguous)
	{
		#line 3778
		maxDmaAddress.QuadPart = 0xFFFFFF;
		DisketteExtension->IoBuffer =
			MmAllocateContiguousMemory(BufferSize, maxDmaAddress);
	}
	else
	{
		#line 3782
		DisketteExtension->IoBuffer =
			ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
			BufferSize, 'polF');
	}
	if(! DisketteExtension->IoBuffer)
	{
		#line 3787
		return;
	}
	#line 3790
	DisketteExtension->IoBufferMdl =
		IoAllocateMdl(DisketteExtension->IoBuffer, BufferSize, 0, 0,
		(void *  )0);
	#line 3792
	if(! DisketteExtension->IoBufferMdl)
	{
		#line 3793
		if(allocateContiguous)
		{
			#line 3794
			MmFreeContiguousMemory(DisketteExtension->IoBuffer);
		}
		else
		{
			#line 3796
			ExFreePool(DisketteExtension->IoBuffer);
		}
		DisketteExtension->IoBuffer = (void *  )0;
		return;
	}
	{
		#line 3803
		MmProbeAndLockPages(DisketteExtension->IoBufferMdl, KernelMode,
			IoModifyAccess);
	}
	{
		#line 3809
		do
		{
			#line 3809
			;
		}
		while(0);
		#line 3810
		if(allocateContiguous)
		{
			#line 3811
			MmFreeContiguousMemory(DisketteExtension->IoBuffer);
		}
		else
		{
			#line 3813
			ExFreePool(DisketteExtension->IoBuffer);
		}
		DisketteExtension->IoBuffer = (void *  )0;
		return;
	}
	#line 3819
	DisketteExtension->IoBufferSize = BufferSize;
}

void FlFreeIoBuffer(PDISKETTE_EXTENSION DisketteExtension )
{
	#line 3844
	BOOLEAN contiguousBuffer ;
	#line 3846
	if(! DisketteExtension->IoBuffer)
	{
		#line 3847
		return;
	}
	#line 3850
	if(DisketteExtension->IoBufferSize > DisketteExtension->MaxTransferSize)
	{
		#line 3853
		contiguousBuffer = 1;
	}
	else
	{
		#line 3855
		contiguousBuffer = 0;
	}
	#line 3858
	DisketteExtension->IoBufferSize = 0;
	#line 3860
	MmUnlockPages(DisketteExtension->IoBufferMdl);
	IoFreeMdl(DisketteExtension->IoBufferMdl);
	DisketteExtension->IoBufferMdl = (void *  )0;
	if(contiguousBuffer)
	{
		#line 3864
		MmFreeContiguousMemory(DisketteExtension->IoBuffer);
	}
	else
	{
		#line 3866
		ExFreePool(DisketteExtension->IoBuffer);
	}
	DisketteExtension->IoBuffer = (void *  )0;
}

void FloppyThread(PVOID Context )
{
	#line 3901
	PIRP irp ;
	PIO_STACK_LOCATION irpSp ;
	PLIST_ENTRY request ;
	PDISKETTE_EXTENSION disketteExtension = Context;
	NTSTATUS ntStatus = (NTSTATUS )0x00000000L;
	NTSTATUS waitStatus ;
	LARGE_INTEGER queueWait ;
	LARGE_INTEGER acquireWait ;
	#line 3915
	KeSetPriorityThread(KeGetCurrentThread(), 16);
	#line 3917
	queueWait.QuadPart = - (3 * 1000 * 10000);
	acquireWait.QuadPart = - (15 * 1000 * 10000);
	#line 3920
	do
	{
		#line 3929
		waitStatus = KeWaitForSingleObject((PVOID )(&
			disketteExtension->RequestSemaphore), Executive,
			KernelMode, 0, & queueWait);
		#line 3936
		if(waitStatus == (NTSTATUS )0x00000102L)
		{
			if(! (((KUSER_SHARED_DATA * const
				)0xffdf0000)->AlternativeArchitecture ==
				NEC98x86) &&
				disketteExtension->FloppyControllerAllocated)
			{
				do
				{
					#line 3943
					;
				}
				while(0);
				#line 3944
				FlFdcDeviceIo(disketteExtension->TargetObject,
					0x00000007 << 16 | 0 << 14 | 0x307 << 2
					| 3, (void *  )0);
				#line 3948
				FlFdcDeviceIo(disketteExtension->TargetObject,
					0x00000007 << 16 | 0 << 14 | 0x301 << 2
					| 3, disketteExtension->DeviceObject);
				#line 3952
				disketteExtension->FloppyControllerAllocated =
					0;
			}
			#line 3956
			ExAcquireFastMutex(&
				disketteExtension->ThreadReferenceMutex);
			if(disketteExtension->ThreadReferenceCount == 0)
			{
				#line 3959
				disketteExtension->ThreadReferenceCount = - 1;
				#line 3961
				;
				#line 3969
				if(disketteExtension->FloppyThread != (void * 
					)0)
				{
					#line 3971
					ObfDereferenceObject(disketteExtension->FloppyThread
						);
					#line 3972
					disketteExtension->FloppyThread =
						(void *  )0;
				}
				ExReleaseFastMutex(&
					disketteExtension->ThreadReferenceMutex)
					;
				#line 3977
				if(((KUSER_SHARED_DATA * const
					)0xffdf0000)->AlternativeArchitecture ==
					NEC98x86)
				{
					#line 3978
					if(disketteExtension->ReleaseFdcWithMotorRunning
						)
					{
						#line 3979
						ntStatus =
							FlFdcDeviceIo(disketteExtension
							->TargetObject,
							0x00000007 << 16 | 0 <<
							14 | 0x300 << 2 | 3, &
							acquireWait);
						#line 3984
						FlFdcDeviceIo(disketteExtension->TargetObject
							, 0x00000007 << 16 | 0
							<< 14 | 0x307 << 2 | 3,
							(void *  )0);
						FlFdcDeviceIo(disketteExtension->TargetObject
							, 0x00000007 << 16 | 0
							<< 14 | 0x301 << 2 | 3,
							disketteExtension->DeviceObject
							);
						#line 3992
						disketteExtension->FloppyControllerAllocated
							= 0;
						#line 3993
						disketteExtension->ReleaseFdcWithMotorRunning
							= 0;
					}
				}
				{
					#line 3997
					ExAcquireFastMutex(PagingMutex);
					#line 3997
					if(-- PagingReferenceCount == 0)
					{
						#line 3997
						MmPageEntireDriver(DriverEntry);
					}
					#line 3997
					ExReleaseFastMutex(PagingMutex);
				}
				#line 3997
				;
				#line 4001
				do
				{
					#line 4001
					;
				}
				while(0);
				#line 4002
				PsTerminateSystemThread((NTSTATUS )0x00000000L);
			}
			#line 4005
			ExReleaseFastMutex(&
				disketteExtension->ThreadReferenceMutex);
			#line 4006
			continue;
		}
		#line 4009
		while(request = ExfInterlockedRemoveHeadList(&
			disketteExtension->ListEntry, &
			disketteExtension->ListSpinLock))
		{
			ExAcquireFastMutex(&
				disketteExtension->ThreadReferenceMutex);
			#line 4014
			;
			disketteExtension->ThreadReferenceCount--;
			ExReleaseFastMutex(&
				disketteExtension->ThreadReferenceMutex);
			disketteExtension->HardwareFailed = 0;
			#line 4020
			irp = (IRP *  )((PCHAR )request - (ULONG_PTR )(& ((((IRP
				*  )0)->Tail).Overlay).ListEntry));
			#line 4026
			ExAcquireFastMutex(& disketteExtension->PowerDownMutex);
			if(disketteExtension->PoweringDown == 1)
			{
				#line 4028
				ExReleaseFastMutex(&
					disketteExtension->PowerDownMutex);
				do
				{
					#line 4030
					;
				}
				while(0);
				#line 4032
				irp = (IRP *  )((PCHAR )request - (ULONG_PTR )(&
					((((IRP * 
					)0)->Tail).Overlay).ListEntry));
				#line 4033
				(irp->IoStatus).Status = (NTSTATUS )0xC00002D3L;
				(irp->IoStatus).Information = 0;
				IofCompleteRequest(irp, 0);
				continue;
			}
			ExReleaseFastMutex(& disketteExtension->PowerDownMutex);
			do
			{
				#line 4039
				;
			}
			while(0);
			#line 4041
			irpSp = ((irp->Tail).Overlay).CurrentStackLocation;
			#line 4047
			do
			{
				#line 4047
				;
			}
			while(0);
			#line 4048
			switch(irpSp->MajorFunction)
			{
			case 0x1b:
					#line 4050
					;
				#line 4052
				do
				{
					#line 4052
					;
				}
				while(0);
				#line 4054
				if(irpSp->MinorFunction == 0x01 ||
					irpSp->MinorFunction == 0x05)
				{
					if(((KUSER_SHARED_DATA * const
						)0xffdf0000)->AlternativeArchitecture
						== NEC98x86)
					{
						#line 4058
						if(disketteExtension->ReleaseFdcWithMotorRunning
							)
						{
							#line 4059
							FlFdcDeviceIo(disketteExtension
								->TargetObject,
								0x00000007 << 16
								| 0 << 14 |
								0x300 << 2 | 3,
								& acquireWait);
							#line 4063
							disketteExtension->ReleaseFdcWithMotorRunning
								= 0;
							#line 4064
							disketteExtension->FloppyControllerAllocated
								= 1;
						}
					}
					if(disketteExtension->FloppyControllerAllocated
						)
					{
						#line 4070
						FlFdcDeviceIo(disketteExtension->TargetObject
							, 0x00000007 << 16 | 0
							<< 14 | 0x307 << 2 | 3,
							(void *  )0);
						FlFdcDeviceIo(disketteExtension->TargetObject
							, 0x00000007 << 16 | 0
							<< 14 | 0x301 << 2 | 3,
							disketteExtension->DeviceObject
							);
						#line 4078
						disketteExtension->FloppyControllerAllocated
							= 0;
					}
					#line 4082
					ExAcquireFastMutex(&
						disketteExtension->ThreadReferenceMutex)
						;
					#line 4083
					;
					disketteExtension->ThreadReferenceCount
						= - 1;
					#line 4085
					ExReleaseFastMutex(&
						disketteExtension->ThreadReferenceMutex)
						;
					{
						#line 4087
						ExAcquireFastMutex(PagingMutex);
						#line 4087
						if(-- PagingReferenceCount == 0)
						{
							#line 4087
							MmPageEntireDriver(DriverEntry
								);
						}
						#line 4087
						ExReleaseFastMutex(PagingMutex);
					}
					#line 4087
					;
					#line 4089
					PsTerminateSystemThread((NTSTATUS
						)0x00000000L);
				}
				else
				{
					#line 4093
					ntStatus = (NTSTATUS
						)0xC0000010L;
				}
				#line 4095
				break;
				#line 4097
			case 0x03:
					#line 4097
					;
			case 0x04:
					#line 4098
					;
				{
					#line 4108
					if(!
						disketteExtension->FloppyControllerAllocated)
					{
						#line 4110
						ntStatus =
							FlFdcDeviceIo(disketteExtension
							->TargetObject,
							0x00000007 << 16 | 0 <<
							14 | 0x300 << 2 | 3, &
							acquireWait);
						#line 4115
						if((NTSTATUS
							)ntStatus
							>= 0)
						{
							#line 4116
							disketteExtension->FloppyControllerAllocated
								= 1;
							#line 4117
							if(((KUSER_SHARED_DATA
								* const
								)0xffdf0000)->AlternativeArchitecture
								== NEC98x86)
	#line 4117
	disketteExtension->ReleaseFdcWithMotorRunning = 0;
						}
						else
						{
							#line 4119
							break;
						}
					}
					#line 4128
					if((disketteExtension->DeviceObject)->Flags
						& 0x00000002 && ! (irpSp->Flags
						& 0x02))
					{
						#line 4136
						do
						{
							#line 4136
							;
						}
						while(0);
						#line 4145
						ntStatus =
							(NTSTATUS )0x80000016L;
					}
					else
					{
						#line 4149
						ntStatus =
							FlReadWrite(disketteExtension
							, irp, 0);
					}
					break;
				}
				#line 4156
			case 0x0e:
					#line 4156
					;
				{
					#line 4161
					if(!
						disketteExtension->FloppyControllerAllocated)
					{
						#line 4163
						ntStatus =
							FlFdcDeviceIo(disketteExtension
							->TargetObject,
							0x00000007 << 16 | 0 <<
							14 | 0x300 << 2 | 3, &
							acquireWait);
						#line 4168
						if((NTSTATUS
							)ntStatus
							>= 0)
						{
							#line 4169
							disketteExtension->FloppyControllerAllocated
								= 1;
							#line 4170
							if(((KUSER_SHARED_DATA
								* const
								)0xffdf0000)->AlternativeArchitecture
								== NEC98x86)
	#line 4170
	disketteExtension->ReleaseFdcWithMotorRunning = 0;
						}
						else
						{
							#line 4172
							break;
						}
					}
					#line 4180
					if((disketteExtension->DeviceObject)->Flags
						& 0x00000002 && ! (irpSp->Flags
						& 0x02))
					{
						#line 4188
						do
						{
							#line 4188
							;
						}
						while(0);
						#line 4196
						ntStatus =
							(NTSTATUS )0x80000016L;
					}
					else
					{
						#line 4200
						switch(((irpSp->Parameters).DeviceIoControl
							).IoControlCode)
						{
						case 0x0000002d << 16 | 0x0001
							<< 14 | 0x0200 << 2 | 0:
	#line 4203
	;
						case 0x00000007 << 16 | 0x0001
							<< 14 | 0x0200 << 2 | 0:
	#line 4204
	;
							{
	#line 4215
	do
	{
		#line 4215
		;
	}
	while(0);
	#line 4223
	ntStatus = FlStartDrive(disketteExtension, irp, 0, 0,
		(BOOLEAN )(! ! (irpSp->Flags & 0x02)));
	#line 4231
	break;
							}
							#line 4234
						case 0x00000007 << 16 | 0 << 14
							| 0x0009 << 2 | 0:
	#line 4234
	;
							{
	#line 4244
	do
	{
		#line 4244
		;
	}
	while(0);
	#line 4246
	if(disketteExtension->IsReadOnly)
	{
		ntStatus = (NTSTATUS )0xC000000DL;
	}
	else
	{
		ntStatus = FlStartDrive(disketteExtension, irp, 1,
			0, 1);
	}
	#line 4260
	break;
							}
							#line 4263
						case 0x00000007 << 16 | 0 << 14
							| 0x0000 << 2 | 0:
	#line 4263
	;
							{
	#line 4268
	do
	{
		#line 4268
		;
	}
	while(0);
	#line 4276
	if(((irpSp->Parameters).DeviceIoControl).OutputBufferLength <
		sizeof(DISK_GEOMETRY ))
	{
		#line 4280
		ntStatus = (NTSTATUS )0xC000000DL;
	}
	else
	{
		ntStatus = FlStartDrive(disketteExtension, irp, 0,
			1, (BOOLEAN )(! ! (irpSp->Flags & 0x02)));
	}
	#line 4299
	if((NTSTATUS )ntStatus >= 0 || ntStatus ==
		(NTSTATUS )0xC0000014L)
	{
		PDISK_GEOMETRY outputBuffer = (PDISK_GEOMETRY
			)(irp->AssociatedIrp).SystemBuffer;
		#line 4310
		ntStatus = (NTSTATUS )0x00000000L;
		#line 4312
		outputBuffer->MediaType = disketteExtension->MediaType;
		#line 4320
		if(disketteExtension->MediaType == Unknown)
		{
			#line 4326
			do
			{
				#line 4326
				;
			}
			while(0);
			#line 4333
			(outputBuffer->Cylinders).LowPart = 0;
			(outputBuffer->Cylinders).HighPart = 0;
			outputBuffer->TracksPerCylinder = 0;
			outputBuffer->SectorsPerTrack = 0;
			outputBuffer->BytesPerSector = 0;
		}
		else
		{
			#line 4349
			do
			{
				#line 4349
				;
			}
			while(0);
			#line 4350
			(outputBuffer->Cylinders).LowPart =
				(disketteExtension->DriveMediaConstants).MaximumTrack
				+ 1;
			#line 4354
			(outputBuffer->Cylinders).HighPart = 0;
			#line 4356
			outputBuffer->TracksPerCylinder =
				(disketteExtension->DriveMediaConstants).NumberOfHeads
				;
			#line 4360
			outputBuffer->SectorsPerTrack =
				(disketteExtension->DriveMediaConstants).SectorsPerTrack
				;
			#line 4364
			outputBuffer->BytesPerSector =
				(disketteExtension->DriveMediaConstants).BytesPerSector
				;
		}
		#line 4384
		do
		{
			#line 4384
			;
		}
		while(0);
	}
	(irp->IoStatus).Information = sizeof(DISK_GEOMETRY );
	#line 4391
	break;
							}
							#line 4394
						case 0x00000007 << 16 | (0x0001
							| 0x0002) << 14 | 0x000b
							<< 2 | 0:
	#line 4394
	;
						case 0x00000007 << 16 | (0x0001
							| 0x0002) << 14 | 0x0006
							<< 2 | 0:
	#line 4395
	;
							{
	#line 4400
	do
	{
		#line 4400
		;
	}
	while(0);
	#line 4407
	ntStatus = FlStartDrive(disketteExtension, irp, 1, 0, 0);
	#line 4420
	if((NTSTATUS )ntStatus >= 0 || ntStatus ==
		(NTSTATUS )0xC0000014L)
	{
		#line 4432
		FlAllocateIoBuffer(disketteExtension, 0x1000);
		#line 4435
		if(disketteExtension->IoBuffer)
		{
			#line 4436
			ntStatus = FlFormat(disketteExtension,
				irp);
		}
		else
		{
			#line 4439
			ntStatus = (NTSTATUS )0xC000009AL;
		}
	}
	#line 4443
	break;
							}
							#line 4446
						case 0x00000007 << 16 | 0 << 14
							| 0x00f8 << 2 | 0:
	#line 4446
	;
							{
	if(((KUSER_SHARED_DATA * const )0xffdf0000)->AlternativeArchitecture ==
		NEC98x86)
	{
		#line 4449
		(disketteExtension->FifoBuffer)[0] = 0x0E;
		(disketteExtension->FifoBuffer)[1] =
			disketteExtension->DeviceUnit;
		ntStatus = FlIssueCommand(disketteExtension,
			disketteExtension->FifoBuffer,
			disketteExtension->FifoBuffer, (void *  )0, 0, 0);
		#line 4459
		if((NTSTATUS )ntStatus >= 0)
		{
			PSENSE_DEVISE_STATUS_PTOS outputBuffer
				= (PSENSE_DEVISE_STATUS_PTOS
				)(irp->AssociatedIrp).SystemBuffer;
			#line 4463
			((PSENSE_DEVISE_STATUS_PTOS )outputBuffer)->ST3_PTOS =
				(Result_Status3_PTOS[0]).ST3_PTOS;
			#line 4466
			(irp->IoStatus).Information =
				sizeof(SENSE_DEVISE_STATUS_PTOS );
		}
		#line 4468
		break;
	}
							}
						}
					}
					#line 4475
					break;
				}
				#line 4478
			default :
					#line 4478
					;
				{
					#line 4483
					do
					{
						#line 4483
						;
					}
					while(0);
					#line 4485
					ntStatus = (NTSTATUS
						)0xC0000002L;
				}
			}
			#line 4490
			if(ntStatus == (NTSTATUS )0x80000011L)
			{
				#line 4496
				for(; ; )
				{
					disketteExtension->HardwareFailed = 0;
					#line 4500
					(irp->IoStatus).Status = (NTSTATUS
						)0x80000011L;
					IofCompleteRequest(irp, 1);
					#line 4504
					request = ExfInterlockedRemoveHeadList(&
						disketteExtension->ListEntry, &
						disketteExtension->ListSpinLock)
						;
					if(! request)
					{
						#line 4509
						break;
					}
					#line 4512
					ExAcquireFastMutex(&
						disketteExtension->ThreadReferenceMutex)
						;
					#line 4514
					;
					disketteExtension->ThreadReferenceCount--
						;
					#line 4516
					ExReleaseFastMutex(&
						disketteExtension->ThreadReferenceMutex)
						;
					irp = (IRP *  )((PCHAR )request -
						(ULONG_PTR )(& ((((IRP * 
						)0)->Tail).Overlay).ListEntry));
				}
			}
			else
			{
				#line 4531
				(irp->IoStatus).Status = ntStatus;
				#line 4536
				if(disketteExtension->IoBuffer)
				{
					#line 4537
					FlFreeIoBuffer(disketteExtension);
				}
				#line 4540
				FlFinishOperation(irp, disketteExtension);
			}
		}
		#line 4546
		if(((KUSER_SHARED_DATA * const
			)0xffdf0000)->AlternativeArchitecture == NEC98x86)
		{
			#line 4547
			if(disketteExtension->FloppyControllerAllocated)
			{
				#line 4548
				FlFdcDeviceIo(disketteExtension->TargetObject,
					0x00000007 << 16 | 0 << 14 | 0x301 << 2
					| 3, disketteExtension->DeviceObject);
				#line 4552
				disketteExtension->FloppyControllerAllocated =
					0;
				#line 4553
				disketteExtension->ReleaseFdcWithMotorRunning =
					1;
			}
		}
	}
	while(1);
}

#line 4560
void FlConsolidateMediaTypeWithBootSector(PDISKETTE_EXTENSION DisketteExtension
	, PBOOT_SECTOR_INFO BootSector )
{
	#line 4586
	USHORT bpbNumberOfSectors , bpbNumberOfHeads ;
	USHORT bpbSectorsPerTrack , bpbBytesPerSector ;
	USHORT bpbMediaByte , bpbMaximumTrack ;
	MEDIA_TYPE bpbMediaType ;
	ULONG i , n ;
	PDRIVE_MEDIA_CONSTANTS readidDriveMediaConstants ;
	BOOLEAN changeToBpbMedia ;
	#line 4598
	do
	{
		#line 4598
		;
	}
	while(0);
	#line 4600
	if((BootSector->JumpByte)[0] != 0xeb && (BootSector->JumpByte)[0] !=
		0xe9)
	{
		#line 4604
		return;
	}
	#line 4607
	bpbNumberOfSectors = (BootSector->NumberOfSectors)[1] * 0x100 +
		(BootSector->NumberOfSectors)[0];
	bpbNumberOfHeads = (BootSector->NumberOfHeads)[1] * 0x100 +
		(BootSector->NumberOfHeads)[0];
	bpbSectorsPerTrack = (BootSector->SectorsPerTrack)[1] * 0x100 +
		(BootSector->SectorsPerTrack)[0];
	bpbBytesPerSector = (BootSector->BytesPerSector)[1] * 0x100 +
		(BootSector->BytesPerSector)[0];
	bpbMediaByte = (BootSector->MediaByte)[0];
	#line 4617
	if(! bpbNumberOfHeads || ! bpbSectorsPerTrack)
	{
		return;
	}
	#line 4622
	bpbMaximumTrack = bpbNumberOfSectors / bpbNumberOfHeads /
		bpbSectorsPerTrack - 1;
	#line 4628
	bpbMediaType = Unknown;
	for(i = 0; i < (ULONG )(((KUSER_SHARED_DATA * const
		)0xffdf0000)->AlternativeArchitecture == NEC98x86 ? 21 : 17);
		i++)
	{
		#line 4631
		if(bpbBytesPerSector == (DriveMediaConstants[i]).BytesPerSector
			&& bpbSectorsPerTrack ==
			(DriveMediaConstants[i]).SectorsPerTrack &&
			bpbMaximumTrack == (DriveMediaConstants[i]).MaximumTrack
			&& bpbNumberOfHeads ==
			(DriveMediaConstants[i]).NumberOfHeads && bpbMediaByte
			== (DriveMediaConstants[i]).MediaByte)
		{
			#line 4637
			bpbMediaType = (DriveMediaConstants[i]).MediaType;
			break;
		}
	}
	#line 4647
	if(DisketteExtension->DriveType == 3)
	{
		#line 4648
		switch(bpbMediaType)
		{
			#line 4649
		case F5_640_512:
				#line 4649
				;
			#line 4649
			bpbMediaType = F3_640_512;
			#line 4649
			break;
		case F5_720_512:
				#line 4650
				;
			#line 4650
			bpbMediaType = F3_720_512;
			#line 4650
			break;
		case F5_1Pt2_512:
				#line 4651
				;
			#line 4651
			bpbMediaType = F3_1Pt2_512;
			#line 4651
			break;
		case F5_1Pt23_1024:
				#line 4652
				;
			#line 4652
			bpbMediaType = F3_1Pt23_1024;
			#line 4652
			break;
		default :
				#line 4653
				;
			#line 4653
			break;
		}
	}
	#line 4660
	do
	{
		#line 4660
		;
	}
	while(0);
	#line 4665
	do
	{
		#line 4665
		;
	}
	while(0);
	#line 4666
	if(bpbMediaType == DisketteExtension->MediaType)
	{
		#line 4670
		changeToBpbMedia = 0;
		#line 4674
		do
		{
			#line 4674
			;
		}
		while(0);
	}
	else
	{
		#line 4682
		readidDriveMediaConstants = &
			DisketteExtension->DriveMediaConstants;
		if(bpbBytesPerSector ==
			readidDriveMediaConstants->BytesPerSector &&
			bpbSectorsPerTrack < 0x100 && bpbMaximumTrack ==
			readidDriveMediaConstants->MaximumTrack &&
			bpbNumberOfHeads <=
			readidDriveMediaConstants->NumberOfHeads)
		{
			#line 4689
			changeToBpbMedia = 1;
		}
		else
		{
			#line 4692
			changeToBpbMedia = 0;
		}
		#line 4699
		do
		{
			#line 4699
			;
		}
		while(0);
		#line 4706
		if(bpbMediaType == Unknown)
		{
			#line 4707
			bpbMediaType = readidDriveMediaConstants->MediaType;
			(DisketteExtension->DriveMediaConstants).SkewDelta = 0;
		}
	}
	#line 4712
	if(changeToBpbMedia)
	{
		#line 4717
		i =
			(DriveMediaLimits[DisketteExtension->DriveType]).LowestDriveMediaType;
		#line 4718
		n =
			(DriveMediaLimits[DisketteExtension->DriveType]).HighestDriveMediaType;
		#line 4719
		for(; i <= n; i++)
		{
			if(bpbMediaType == (DriveMediaConstants[i]).MediaType)
			{
				#line 4722
				DisketteExtension->DriveMediaType = i;
				break;
			}
		}
		#line 4727
		DisketteExtension->MediaType = bpbMediaType;
		DisketteExtension->ByteCapacity = bpbNumberOfSectors *
			bpbBytesPerSector;
		#line 4729
		(DisketteExtension->DriveMediaConstants).SectorsPerTrack =
			(UCHAR )bpbSectorsPerTrack;
		(DisketteExtension->DriveMediaConstants).NumberOfHeads = (UCHAR
			)bpbNumberOfHeads;
		#line 4737
		if(RtlCompareMemory(BootSector->OemData, "MSDMF3.", 7) == 7)
		{
			#line 4738
			DisketteExtension->IsReadOnly = 1;
		}
	}
}

void FlCheckBootSector(PDISKETTE_EXTENSION DisketteExtension )
{
	#line 4768
	PBOOT_SECTOR_INFO bootSector ;
	LARGE_INTEGER offset ;
	PIRP irp ;
	NTSTATUS status ;
	#line 4776
	bootSector = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
		((KUSER_SHARED_DATA * const
		)0xffdf0000)->AlternativeArchitecture == NEC98x86 ? 1024 : 512,
		'polF');
	#line 4777
	if(! bootSector)
	{
		#line 4778
		return;
	}
	#line 4781
	offset.LowPart = (offset.HighPart = 0);
	irp = IoBuildAsynchronousFsdRequest(0x03,
		DisketteExtension->DeviceObject, bootSector, ((KUSER_SHARED_DATA
		* const )0xffdf0000)->AlternativeArchitecture == NEC98x86 ? 1024
		: 512, & offset, (void *  )0);
	#line 4788
	if(! irp)
	{
		#line 4789
		ExFreePool(bootSector);
		return;
	}
	irp->CurrentLocation--;
	((irp->Tail).Overlay).CurrentStackLocation =
		((irp->Tail).Overlay).CurrentStackLocation - 1;
	#line 4798
	status = FlReadWrite(DisketteExtension, irp, 1);
	#line 4800
	MmUnlockPages(irp->MdlAddress);
	IoFreeMdl(irp->MdlAddress);
	IoFreeIrp(irp);
	ExFreePool(bootSector);
}

NTSTATUS FlReadWriteTrack(PDISKETTE_EXTENSION DisketteExtension , PMDL IoMdl ,
	ULONG IoOffset , BOOLEAN WriteOperation , UCHAR Cylinder , UCHAR Head ,
	UCHAR Sector , UCHAR NumberOfSectors , BOOLEAN NeedSeek )
{
	#line 4853
	PDRIVE_MEDIA_CONSTANTS driveMediaConstants ;
	ULONG byteToSectorShift ;
	ULONG transferBytes ;
	LARGE_INTEGER headSettleTime ;
	NTSTATUS status ;
	ULONG seekRetry , ioRetry ;
	BOOLEAN recalibrateDrive = 0;
	UCHAR i ;
	#line 4869
	do
	{
		#line 4869
		;
	}
	while(0);
	#line 4871
	driveMediaConstants = & DisketteExtension->DriveMediaConstants;
	byteToSectorShift = 7 + driveMediaConstants->SectorLengthCode;
	#line 4874
	transferBytes = (ULONG )NumberOfSectors << byteToSectorShift;
	#line 4876
	headSettleTime.LowPart = - (10 * 1000 *
		driveMediaConstants->HeadSettleTime);
	#line 4877
	headSettleTime.HighPart = - 1;
	#line 4879
	for(seekRetry = 0, ioRetry = 0; seekRetry < 3; seekRetry++)
	{
		if(recalibrateDrive)
		{
			#line 4888
			do
			{
				#line 4888
				;
			}
			while(0);
			#line 4889
			FlRecalibrateDrive(DisketteExtension);
		}
		#line 4894
		if(recalibrateDrive || NeedSeek && (!
			DisketteExtension->ControllerConfigurable ||
			driveMediaConstants->CylinderShift != 0))
		{
			#line 4899
			(DisketteExtension->FifoBuffer)[0] = 0x10;
			(DisketteExtension->FifoBuffer)[1] = Head << 2 |
				DisketteExtension->DeviceUnit;
			(DisketteExtension->FifoBuffer)[2] = Cylinder <<
				driveMediaConstants->CylinderShift;
			#line 4905
			status = FlIssueCommand(DisketteExtension,
				DisketteExtension->FifoBuffer,
				DisketteExtension->FifoBuffer, (void *  )0, 0,
				0);
			#line 4912
			if((NTSTATUS )status >= 0)
			{
				#line 4916
				if(! ((DisketteExtension->FifoBuffer)[0] & 0x20)
					|| (DisketteExtension->FifoBuffer)[1] !=
					Cylinder <<
					driveMediaConstants->CylinderShift)
				{
					#line 4920
					DisketteExtension->HardwareFailed = 1;
					status = (NTSTATUS )0xC0000168L;
				}
				#line 4924
				if((NTSTATUS )status >= 0)
				{
					#line 4928
					KeDelayExecutionThread(KernelMode, 0, &
						headSettleTime);
					#line 4932
					(DisketteExtension->FifoBuffer)[0] =
						0x14 + 0x40;
					(DisketteExtension->FifoBuffer)[1] =
						Head << 2 |
						DisketteExtension->DeviceUnit;
					status =
						FlIssueCommand(DisketteExtension,
						DisketteExtension->FifoBuffer,
						DisketteExtension->FifoBuffer,
						(void *  )0, 0, 0);
					#line 4944
					if((NTSTATUS )status >= 0)
					{
						if(((KUSER_SHARED_DATA * const
							)0xffdf0000)->AlternativeArchitecture
							== NEC98x86)
						{
							#line 4947
							if((DisketteExtension->FifoBuffer
								)[0] & 0x08)
							{
	#line 4948
	return (NTSTATUS )0xC00000A3L;
							}
						}
						#line 4952
						if((DisketteExtension->FifoBuffer
							)[0] != (Head << 2 |
							DisketteExtension->DeviceUnit
							) ||
							(DisketteExtension->FifoBuffer)
							[1] != 0 ||
							(DisketteExtension->FifoBuffer
							)[2] != 0 ||
							(DisketteExtension->FifoBuffer
							)[3] != Cylinder)
						{
							#line 4958
							DisketteExtension->HardwareFailed
								= 1;
							status =
								FlInterpretError(
								(DisketteExtension
								->FifoBuffer)[1]
								,
								(DisketteExtension->FifoBuffer
								)[2]);
						}
					}
					else
					{
						#line 4968
						do
						{
							#line 4968
							;
						}
						while(0);
					}
				}
			}
			else
			{
				#line 4975
				do
				{
					#line 4975
					;
				}
				while(0);
			}
		}
		else
		{
			#line 4980
			status = (NTSTATUS )0x00000000L;
		}
		#line 4983
		if(! ((NTSTATUS )status >= 0))
		{
			#line 4990
			do
			{
				#line 4990
				;
			}
			while(0);
			#line 4991
			recalibrateDrive = 1;
			continue;
		}
		#line 4995
		for(; ; ioRetry++)
		{
			#line 5001
			(DisketteExtension->FifoBuffer)[1] = Head << 2 |
				DisketteExtension->DeviceUnit;
			(DisketteExtension->FifoBuffer)[2] = Cylinder;
			(DisketteExtension->FifoBuffer)[3] = Head;
			(DisketteExtension->FifoBuffer)[4] = Sector + 1;
			(DisketteExtension->FifoBuffer)[5] =
				driveMediaConstants->SectorLengthCode;
			(DisketteExtension->FifoBuffer)[6] = Sector +
				NumberOfSectors;
			#line 5009
			(DisketteExtension->FifoBuffer)[7] =
				driveMediaConstants->ReadWriteGapLength;
			(DisketteExtension->FifoBuffer)[8] =
				driveMediaConstants->DataLength;
			if(WriteOperation)
			{
				#line 5014
				(DisketteExtension->FifoBuffer)[0] = 0x02 +
					0x40;
			}
			else
			{
				#line 5017
				(DisketteExtension->FifoBuffer)[0] = 0x00 +
					0x40;
			}
			#line 5021
			status = FlIssueCommand(DisketteExtension,
				DisketteExtension->FifoBuffer,
				DisketteExtension->FifoBuffer, IoMdl, IoOffset,
				transferBytes);
			#line 5028
			if((NTSTATUS )status >= 0)
			{
				if(((KUSER_SHARED_DATA * const
					)0xffdf0000)->AlternativeArchitecture ==
					NEC98x86)
				{
					#line 5031
					if((DisketteExtension->FifoBuffer)[0] &
						0x08)
					{
						#line 5032
						return (NTSTATUS )0xC00000A3L;
					}
				}
				#line 5036
				if(((DisketteExtension->FifoBuffer)[0] & 0xC0)
					!= 0x00 &&
					(((DisketteExtension->FifoBuffer)[0] &
					0xC0) != 0x40 ||
					(DisketteExtension->FifoBuffer)[1] !=
					0x80 ||
					(DisketteExtension->FifoBuffer)[2] !=
					0x00))
				{
					#line 5044
					DisketteExtension->HardwareFailed = 1;
					#line 5046
					status =
						FlInterpretError((DisketteExtension->FifoBuffer
						)[1],
						(DisketteExtension->FifoBuffer)[
						2]);
				}
				else
				{
					if((DisketteExtension->FifoBuffer)[5] !=
						1)
					{
						#line 5056
						DisketteExtension->HardwareFailed
							= 1;
						#line 5057
						status = (NTSTATUS )0xC0000167L;
					}
				}
			}
			else
			{
				#line 5064
				do
				{
					#line 5064
					;
				}
				while(0);
			}
			#line 5067
			if((NTSTATUS )status >= 0)
			{
				#line 5068
				break;
			}
			#line 5071
			if(ioRetry >= 2)
			{
				do
				{
					#line 5073
					;
				}
				while(0);
				#line 5074
				break;
			}
		}
		#line 5078
		if((NTSTATUS )status >= 0)
		{
			#line 5079
			break;
		}
		#line 5083
		recalibrateDrive = 1;
	}
	#line 5086
	if(! ((NTSTATUS )status >= 0) && NumberOfSectors > 1)
	{
		#line 5091
		do
		{
			#line 5091
			;
		}
		while(0);
		#line 5093
		for(i = 0; i < NumberOfSectors; i++)
		{
			#line 5094
			status = FlReadWriteTrack(DisketteExtension, IoMdl,
				IoOffset + ((ULONG )i << byteToSectorShift),
				WriteOperation, Cylinder, Head, (UCHAR )(Sector
				+ i), 1, 0);
			#line 5104
			if(! ((NTSTATUS )status >= 0))
			{
				#line 5108
				do
				{
					#line 5108
					;
				}
				while(0);
				#line 5110
				DisketteExtension->HardwareFailed = 1;
				break;
			}
		}
	}
	#line 5116
	return status;
}

NTSTATUS FlReadWrite(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp , BOOLEAN
	DriveStarted )
{
	#line 5153
	PIO_STACK_LOCATION irpSp ;
	BOOLEAN writeOperation ;
	NTSTATUS status ;
	PDRIVE_MEDIA_CONSTANTS driveMediaConstants ;
	ULONG byteToSectorShift ;
	ULONG currentSector , firstSector , lastSector ;
	ULONG trackSize ;
	UCHAR sectorsPerTrack , numberOfHeads ;
	UCHAR currentHead , currentCylinder , trackSector ;
	PCHAR userBuffer ;
	UCHAR skew , skewDelta ;
	UCHAR numTransferSectors ;
	PMDL mdl ;
	PCHAR ioBuffer ;
	ULONG ioOffset ;
	#line 5169
	irpSp = ((Irp->Tail).Overlay).CurrentStackLocation;
	#line 5177
	do
	{
		#line 5177
		;
	}
	while(0);
	#line 5181
	if(irpSp->MajorFunction == 0x04)
	{
		#line 5182
		if(DisketteExtension->IsReadOnly)
		{
			#line 5183
			do
			{
				#line 5183
				;
			}
			while(0);
			#line 5184
			return (NTSTATUS )0xC000000DL;
		}
		writeOperation = 1;
	}
	else
	{
		#line 5188
		writeOperation = 0;
	}
	#line 5191
	do
	{
		#line 5191
		;
	}
	while(0);
	#line 5195
	if(DriveStarted)
	{
		#line 5196
		status = (NTSTATUS )0x00000000L;
	}
	else
	{
		#line 5198
		status = FlStartDrive(DisketteExtension, Irp, writeOperation, 1,
			(BOOLEAN )(! ! (irpSp->Flags & 0x02)));
	}
	#line 5206
	if(! ((NTSTATUS )status >= 0))
	{
		#line 5210
		do
		{
			#line 5210
			;
		}
		while(0);
		#line 5211
		return status;
	}
	#line 5214
	if(((KUSER_SHARED_DATA * const )0xffdf0000)->AlternativeArchitecture ==
		NEC98x86)
	{
		#line 5216
		FlHdbit(DisketteExtension);
	}
	#line 5220
	if(DisketteExtension->MediaType == Unknown)
	{
		#line 5221
		do
		{
			#line 5221
			;
		}
		while(0);
		#line 5222
		return (NTSTATUS )0xC0000014L;
	}
	#line 5228
	driveMediaConstants = & DisketteExtension->DriveMediaConstants;
	#line 5230
	byteToSectorShift = 7 + driveMediaConstants->SectorLengthCode;
	#line 5232
	firstSector = (((irpSp->Parameters).Read).ByteOffset).LowPart >>
		byteToSectorShift;
	lastSector = firstSector + (((irpSp->Parameters).Read).Length >>
		byteToSectorShift);
	sectorsPerTrack = driveMediaConstants->SectorsPerTrack;
	numberOfHeads = driveMediaConstants->NumberOfHeads;
	userBuffer = (Irp->MdlAddress)->MdlFlags & (0x0001 | 0x0004)
		? (Irp->MdlAddress)->MappedSystemVa
		: MmMapLockedPagesSpecifyCache(Irp->MdlAddress, KernelMode,
		MmCached, (void *  )0, 0, HighPagePriority);
	#line 5240
	if(userBuffer == (void *  )0)
	{
		#line 5243
		do
		{
			#line 5243
			;
		}
		while(0);
		#line 5244
		return (NTSTATUS )0xC000009AL;
	}
	#line 5247
	trackSize = (ULONG )sectorsPerTrack << byteToSectorShift;
	#line 5249
	skew = 0;
	skewDelta = driveMediaConstants->SkewDelta;
	for(currentSector = firstSector; currentSector < lastSector;
		currentSector += numTransferSectors)
	{
		#line 5257
		currentCylinder = (UCHAR )(currentSector / sectorsPerTrack /
			numberOfHeads);
		#line 5258
		trackSector = (UCHAR )(currentSector % sectorsPerTrack);
		currentHead = (UCHAR )(currentSector / sectorsPerTrack %
			numberOfHeads);
		#line 5260
		numTransferSectors = sectorsPerTrack - trackSector;
		if(lastSector - currentSector < numTransferSectors)
		{
			#line 5262
			numTransferSectors = (UCHAR )(lastSector -
				currentSector);
		}
		#line 5272
		if(trackSize > DisketteExtension->MaxTransferSize)
		{
			#line 5276
			do
			{
				#line 5276
				;
			}
			while(0);
			#line 5277
			FlAllocateIoBuffer(DisketteExtension, trackSize);
			if(! DisketteExtension->IoBuffer)
			{
				#line 5282
				do
				{
					#line 5282
					;
				}
				while(0);
				#line 5283
				return (NTSTATUS )0xC000009AL;
			}
			mdl = DisketteExtension->IoBufferMdl;
			ioBuffer = DisketteExtension->IoBuffer;
			ioOffset = 0;
			if(writeOperation)
			{
				#line 5292
				memmove(ioBuffer, userBuffer + (currentSector -
					firstSector << byteToSectorShift),
					(ULONG )numTransferSectors <<
					byteToSectorShift);
			}
		}
		else
		{
			#line 5295
			mdl = Irp->MdlAddress;
			ioOffset = currentSector - firstSector <<
				byteToSectorShift;
		}
		#line 5307
		if(skew >= numTransferSectors + trackSector)
		{
			#line 5308
			skew = 0;
		}
		#line 5311
		if(skew < trackSector)
		{
			#line 5312
			skew = trackSector;
		}
		#line 5317
		status = FlReadWriteTrack(DisketteExtension, mdl, ioOffset +
			((ULONG )skew - trackSector << byteToSectorShift),
			writeOperation, currentCylinder, currentHead, skew,
			(UCHAR )(numTransferSectors + trackSector - skew), 1);
		#line 5330
		if((NTSTATUS )status >= 0 && skew > trackSector)
		{
			#line 5331
			status = FlReadWriteTrack(DisketteExtension, mdl,
				ioOffset, writeOperation, currentCylinder,
				currentHead, trackSector, (UCHAR )(skew -
				trackSector), 0);
		}
		else
		{
			#line 5341
			skew = (numTransferSectors + trackSector) %
				sectorsPerTrack;
		}
		if(! ((NTSTATUS )status >= 0))
		{
			#line 5345
			break;
		}
		#line 5353
		if(! writeOperation && trackSize >
			DisketteExtension->MaxTransferSize)
		{
			#line 5359
			memmove(userBuffer + (currentSector - firstSector <<
				byteToSectorShift), ioBuffer, (ULONG
				)numTransferSectors << byteToSectorShift);
		}
		#line 5367
		skew = (skew + skewDelta) % sectorsPerTrack;
	}
	#line 5370
	(Irp->IoStatus).Information = currentSector - firstSector <<
		byteToSectorShift;
	#line 5377
	if((NTSTATUS )status >= 0 && firstSector == 0)
	{
		#line 5378
		FlConsolidateMediaTypeWithBootSector(DisketteExtension,
			(PBOOT_SECTOR_INFO )userBuffer);
	}
	#line 5385
	do
	{
		#line 5385
		;
	}
	while(0);
	#line 5386
	return status;
}

NTSTATUS FlFormat(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp )
{
	#line 5419
	LARGE_INTEGER headSettleTime ;
	PIO_STACK_LOCATION irpSp ;
	PBAD_TRACK_NUMBER badTrackBuffer ;
	PFORMAT_PARAMETERS formatParameters ;
	PFORMAT_EX_PARAMETERS formatExParameters ;
	PDRIVE_MEDIA_CONSTANTS driveMediaConstants ;
	NTSTATUS ntStatus ;
	ULONG badTrackBufferLength ;
	DRIVE_MEDIA_TYPE driveMediaType ;
	UCHAR driveStatus ;
	UCHAR numberOfBadTracks = 0;
	UCHAR currentTrack ;
	UCHAR endTrack ;
	UCHAR whichSector ;
	UCHAR retryCount ;
	BOOLEAN bufferOverflow = 0;
	FDC_DISK_CHANGE_PARMS fdcDiskChangeParms ;
	#line 5440
	do
	{
		#line 5440
		;
	}
	while(0);
	#line 5442
	irpSp = ((Irp->Tail).Overlay).CurrentStackLocation;
	formatParameters = (PFORMAT_PARAMETERS
		)(Irp->AssociatedIrp).SystemBuffer;
	#line 5444
	if(((irpSp->Parameters).DeviceIoControl).IoControlCode == (0x00000007 <<
		16 | (0x0001 | 0x0002) << 14 | 0x000b << 2 | 0))
	{
		#line 5446
		formatExParameters = (PFORMAT_EX_PARAMETERS
			)(Irp->AssociatedIrp).SystemBuffer;
	}
	else
	{
		#line 5449
		formatExParameters = (void *  )0;
	}
	#line 5464
	do
	{
		#line 5464
		;
	}
	while(0);
	#line 5466
	badTrackBufferLength =
		((irpSp->Parameters).DeviceIoControl).OutputBufferLength;
	#line 5475
	driveMediaType =
		(DriveMediaLimits[DisketteExtension->DriveType]).HighestDriveMediaType;
	#line 5478
	while((DriveMediaConstants[driveMediaType]).MediaType !=
		formatParameters->MediaType && driveMediaType >
		(DriveMediaLimits[DisketteExtension->DriveType]).LowestDriveMediaType
		)
	{
		driveMediaType--;
	}
	#line 5486
	driveMediaConstants = & DriveMediaConstants[driveMediaType];
	#line 5493
	DisketteExtension->MediaType = formatParameters->MediaType;
	DisketteExtension->DriveMediaType = driveMediaType;
	DisketteExtension->DriveMediaConstants =
		DriveMediaConstants[driveMediaType];
	#line 5498
	if(formatExParameters)
	{
		#line 5499
		(DisketteExtension->DriveMediaConstants).SectorsPerTrack =
			(UCHAR )formatExParameters->SectorsPerTrack;
		(DisketteExtension->DriveMediaConstants).FormatGapLength =
			(UCHAR )formatExParameters->FormatGapLength;
	}
	#line 5505
	driveMediaConstants = & DisketteExtension->DriveMediaConstants;
	#line 5507
	DisketteExtension->BytesPerSector = driveMediaConstants->BytesPerSector;
	#line 5509
	DisketteExtension->ByteCapacity = driveMediaConstants->BytesPerSector *
		driveMediaConstants->SectorsPerTrack * (1 +
		driveMediaConstants->MaximumTrack) *
		driveMediaConstants->NumberOfHeads;
	#line 5515
	currentTrack = (UCHAR )(formatParameters->StartCylinderNumber *
		driveMediaConstants->NumberOfHeads +
		formatParameters->StartHeadNumber);
	#line 5519
	endTrack = (UCHAR )(formatParameters->EndCylinderNumber *
		driveMediaConstants->NumberOfHeads +
		formatParameters->EndHeadNumber);
	#line 5528
	do
	{
		#line 5528
		;
	}
	while(0);
	#line 5535
	if(((KUSER_SHARED_DATA * const )0xffdf0000)->AlternativeArchitecture ==
		NEC98x86)
	{
		#line 5537
		FlHdbit(DisketteExtension);
	}
	#line 5541
	if(DisketteExtension->LastDriveMediaType != driveMediaType)
	{
		ntStatus = FlDatarateSpecifyConfigure(DisketteExtension);
		#line 5545
		if(! ((NTSTATUS )ntStatus >= 0))
		{
			return ntStatus;
		}
	}
	#line 5555
	DisketteExtension->IsReadOnly = 0;
	#line 5561
	do
	{
		#line 5567
		(DisketteExtension->FifoBuffer)[0] = 0x10;
		(DisketteExtension->FifoBuffer)[1] =
			DisketteExtension->DeviceUnit;
		#line 5569
		(DisketteExtension->FifoBuffer)[2] = (UCHAR )(currentTrack /
			driveMediaConstants->NumberOfHeads <<
			driveMediaConstants->CylinderShift);
		#line 5577
		do
		{
			#line 5577
			;
		}
		while(0);
		#line 5579
		ntStatus = FlIssueCommand(DisketteExtension,
			DisketteExtension->FifoBuffer,
			DisketteExtension->FifoBuffer, (void *  )0, 0, 0);
		#line 5586
		if((NTSTATUS )ntStatus >= 0)
		{
			if((DisketteExtension->FifoBuffer)[0] & 0x20 &&
				(DisketteExtension->FifoBuffer)[1] == (UCHAR
				)(currentTrack /
				driveMediaConstants->NumberOfHeads <<
				driveMediaConstants->CylinderShift))
			{
				#line 5598
				headSettleTime.LowPart = - (10 * 1000 *
					driveMediaConstants->HeadSettleTime);
				headSettleTime.HighPart = - 1;
				#line 5602
				KeDelayExecutionThread(KernelMode, 0, &
					headSettleTime);
				#line 5607
				if(((KUSER_SHARED_DATA * const
					)0xffdf0000)->AlternativeArchitecture ==
					NEC98x86)
				{
				}
				else
				{
					#line 5619
					(DisketteExtension->FifoBuffer)[0] =
						0x14 + 0x40;
					(DisketteExtension->FifoBuffer)[1] =
						DisketteExtension->DeviceUnit;
					#line 5624
					ntStatus =
						FlIssueCommand(DisketteExtension,
						DisketteExtension->FifoBuffer,
						DisketteExtension->FifoBuffer,
						(void *  )0, 0, 0);
				}
			}
			else
			{
				#line 5641
				do
				{
					#line 5641
					;
				}
				while(0);
				#line 5643
				DisketteExtension->HardwareFailed = 1;
				#line 5645
				ntStatus = (NTSTATUS )0xC0000168L;
			}
		}
		#line 5649
		if(! ((NTSTATUS )ntStatus >= 0))
		{
			#line 5654
			do
			{
				#line 5654
				;
			}
			while(0);
			#line 5656
			return ntStatus;
		}
		#line 5663
		for(whichSector = 0; whichSector <
			driveMediaConstants->SectorsPerTrack; whichSector++)
		{
			#line 5667
			(DisketteExtension->IoBuffer)[whichSector * 4] =
				currentTrack /
				driveMediaConstants->NumberOfHeads;
			#line 5669
			(DisketteExtension->IoBuffer)[whichSector * 4 + 1] =
				currentTrack %
				driveMediaConstants->NumberOfHeads;
			#line 5671
			if(formatExParameters)
			{
				#line 5672
				(DisketteExtension->IoBuffer)[whichSector * 4 +
					2] = (UCHAR
					)(formatExParameters->SectorNumber)[whichSector
					];
			}
			else
			{
				#line 5675
				(DisketteExtension->IoBuffer)[whichSector * 4 +
					2] = whichSector + 1;
			}
			(DisketteExtension->IoBuffer)[whichSector * 4 + 3] =
				driveMediaConstants->SectorLengthCode;
			#line 5689
			do
			{
				#line 5689
				;
			}
			while(0);
		}
		#line 5696
		retryCount = 0;
		#line 5698
		do
		{
			ULONG length ;
			#line 5702
			length = driveMediaConstants->BytesPerSector;
			#line 5708
			(DisketteExtension->FifoBuffer)[0] = 0x07 + 0x40;
			#line 5710
			(DisketteExtension->FifoBuffer)[1] = (UCHAR
				)(currentTrack %
				driveMediaConstants->NumberOfHeads << 2 |
				DisketteExtension->DeviceUnit);
			#line 5713
			(DisketteExtension->FifoBuffer)[2] =
				driveMediaConstants->SectorLengthCode;
			(DisketteExtension->FifoBuffer)[3] =
				driveMediaConstants->SectorsPerTrack;
			(DisketteExtension->FifoBuffer)[4] =
				driveMediaConstants->FormatGapLength;
			(DisketteExtension->FifoBuffer)[5] =
				driveMediaConstants->FormatFillCharacter;
			#line 5735
			do
			{
				#line 5735
				;
			}
			while(0);
			#line 5736
			ntStatus = FlIssueCommand(DisketteExtension,
				DisketteExtension->FifoBuffer,
				DisketteExtension->FifoBuffer,
				DisketteExtension->IoBufferMdl, 0, length);
			#line 5743
			if(! ((NTSTATUS )ntStatus >= 0))
			{
				#line 5748
				do
				{
					#line 5748
					;
				}
				while(0);
			}
			#line 5751
			if((NTSTATUS )ntStatus >= 0)
			{
				#line 5757
				if((DisketteExtension->FifoBuffer)[0] & (0x10 |
					0x80 | 0x40) ||
					(DisketteExtension->FifoBuffer)[1] &
					0x10 ||
					(DisketteExtension->FifoBuffer)[2] != 0)
				{
					#line 5775
					do
					{
						#line 5775
						;
					}
					while(0);
					#line 5777
					DisketteExtension->HardwareFailed = 1;
					#line 5779
					ntStatus =
						FlInterpretError((DisketteExtension->FifoBuffer
						)[1],
						(DisketteExtension->FifoBuffer)[
						2]);
				}
			}
		}
		while(! ((NTSTATUS )ntStatus >= 0) && retryCount++ < 3);
		if(! ((NTSTATUS )ntStatus >= 0))
		{
			if(((KUSER_SHARED_DATA * const
				)0xffdf0000)->AlternativeArchitecture ==
				NEC98x86)
			{
				#line 5791
				(DisketteExtension->FifoBuffer)[0] = 0x0E;
				(DisketteExtension->FifoBuffer)[1] =
					DisketteExtension->DeviceUnit;
				ntStatus = FlIssueCommand(DisketteExtension,
					DisketteExtension->FifoBuffer,
					DisketteExtension->FifoBuffer, (void * 
					)0, 0, 0);
				#line 5801
				if(! ((NTSTATUS )ntStatus >= 0))
				{
					#line 5806
					do
					{
						#line 5806
						;
					}
					while(0);
					#line 5808
					return ntStatus;
				}
				#line 5811
				if((DisketteExtension->FifoBuffer)[0] & 0x20)
				{
					driveStatus = 0x7f;
				}
				else
				{
					driveStatus = 0x80;
				}
			}
			else
			{
				ntStatus =
					FlFdcDeviceIo(DisketteExtension->TargetObject,
					0x00000007 << 16 | 0 << 14 | 0x308 << 2
					| 3, & fdcDiskChangeParms);
				driveStatus = fdcDiskChangeParms.DriveStatus;
			}
			#line 5829
			if(DisketteExtension->DriveType != 0 && driveStatus &
				0x80)
			{
				#line 5837
				return (NTSTATUS )0xC0000013L;
			}
			#line 5847
			do
			{
				#line 5847
				;
			}
			while(0);
			#line 5849
			if(badTrackBufferLength >= (ULONG )((numberOfBadTracks +
				1) * sizeof(BAD_TRACK_NUMBER )))
			{
				badTrackBuffer = (PBAD_TRACK_NUMBER
					)(Irp->AssociatedIrp).SystemBuffer;
				#line 5855
				badTrackBuffer[numberOfBadTracks] =
					(BAD_TRACK_NUMBER )currentTrack;
			}
			else
			{
				bufferOverflow = 1;
			}
			#line 5863
			numberOfBadTracks++;
		}
		#line 5866
		currentTrack++;
	}
	while(currentTrack <= endTrack);
	#line 5870
	if((NTSTATUS )ntStatus >= 0 && bufferOverflow)
	{
		ntStatus = (NTSTATUS )0x80000005L;
	}
	#line 5875
	return ntStatus;
}

BOOLEAN FlCheckFormatParameters(PDISKETTE_EXTENSION DisketteExtension ,
	PFORMAT_PARAMETERS FormatParameters )
{
	#line 5906
	PDRIVE_MEDIA_CONSTANTS driveMediaConstants ;
	DRIVE_MEDIA_TYPE driveMediaType ;
	#line 5913
	driveMediaType =
		(DriveMediaLimits[DisketteExtension->DriveType]).HighestDriveMediaType;
	#line 5916
	while((DriveMediaConstants[driveMediaType]).MediaType !=
		FormatParameters->MediaType && driveMediaType >
		(DriveMediaLimits[DisketteExtension->DriveType]).LowestDriveMediaType
		)
	{
		driveMediaType--;
	}
	#line 5924
	if((DriveMediaConstants[driveMediaType]).MediaType !=
		FormatParameters->MediaType)
	{
		return 0;
	}
	else
	{
		driveMediaConstants = & DriveMediaConstants[driveMediaType];
		#line 5933
		if(FormatParameters->StartHeadNumber > (ULONG
			)(driveMediaConstants->NumberOfHeads - 1) ||
			FormatParameters->EndHeadNumber > (ULONG
			)(driveMediaConstants->NumberOfHeads - 1) ||
			FormatParameters->StartCylinderNumber >
			driveMediaConstants->MaximumTrack ||
			FormatParameters->EndCylinderNumber >
			driveMediaConstants->MaximumTrack ||
			FormatParameters->EndCylinderNumber <
			FormatParameters->StartCylinderNumber)
		{
			return 0;
		}
		else
		{
			if(((KUSER_SHARED_DATA * const
				)0xffdf0000)->AlternativeArchitecture ==
				NEC98x86)
			{
				#line 5949
				if(FormatParameters->MediaType == F5_360_512 ||
					FormatParameters->MediaType ==
					F5_320_512 ||
					FormatParameters->MediaType ==
					F5_320_1024 ||
					FormatParameters->MediaType ==
					F5_180_512 ||
					FormatParameters->MediaType ==
					F5_160_512)
				{
					#line 5955
					return 0;
				}
			}
			#line 5959
			return 1;
		}
	}
}

NTSTATUS FlIssueCommand(PDISKETTE_EXTENSION DisketteExtension , PUCHAR
	FifoInBuffer , PUCHAR FifoOutBuffer , PMDL IoMdl , ULONG IoOffset ,
	ULONG TransferBytes )
{
	#line 6007
	NTSTATUS ntStatus ;
	UCHAR i ;
	PIRP irp ;
	KEVENT DoneEvent ;
	IO_STATUS_BLOCK IoStatus ;
	PIO_STACK_LOCATION irpSp ;
	ISSUE_FDC_COMMAND_PARMS issueCommandParms ;
	#line 6018
	issueCommandParms.FifoInBuffer = FifoInBuffer;
	issueCommandParms.FifoOutBuffer = FifoOutBuffer;
	issueCommandParms.IoHandle = (PVOID )IoMdl;
	issueCommandParms.IoOffset = IoOffset;
	issueCommandParms.TransferBytes = TransferBytes;
	issueCommandParms.TimeOut = 4;
	#line 6028
	do
	{
		#line 6028
		;
	}
	while(0);
	#line 6030
	ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, 0x00000007 <<
		16 | 0 << 14 | 0x303 << 2 | 3, & issueCommandParms);
	#line 6038
	if(ntStatus == (NTSTATUS )0xC00000A3L || ntStatus == (NTSTATUS
		)0xC0000168L)
	{
		DisketteExtension->HardwareFailed = 1;
	}
	#line 6044
	return ntStatus;
}

NTSTATUS FlInitializeControllerHardware(PDISKETTE_EXTENSION DisketteExtension )
{
	#line 6067
	NTSTATUS ntStatus ;
	#line 6069
	ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, 0x00000007 <<
		16 | 0 << 14 | 0x305 << 2 | 3, (void *  )0);
	#line 6073
	if((NTSTATUS )ntStatus >= 0)
	{
		if(DisketteExtension->PerpendicularMode != 0)
		{
			(DisketteExtension->FifoBuffer)[0] = 0x15;
			(DisketteExtension->FifoBuffer)[1] = (UCHAR )(0x80 |
				DisketteExtension->PerpendicularMode << 2);
			#line 6082
			ntStatus = FlIssueCommand(DisketteExtension,
				DisketteExtension->FifoBuffer,
				DisketteExtension->FifoBuffer, (void *  )0, 0,
				0);
		}
	}
	#line 6092
	return ntStatus;
}

NTSTATUS FlFdcDeviceIo(PDEVICE_OBJECT DeviceObject , ULONG Ioctl , PVOID Data )
{
	#line 6102
	NTSTATUS ntStatus ;
	PIRP irp ;
	PIO_STACK_LOCATION irpStack ;
	KEVENT doneEvent ;
	IO_STATUS_BLOCK ioStatus ;
	#line 6108
	do
	{
		#line 6108
		;
	}
	while(0);
	#line 6110
	KeInitializeEvent(& doneEvent, NotificationEvent, 0);
	#line 6117
	irp = IoBuildDeviceIoControlRequest(Ioctl, DeviceObject, (void *  )0, 0,
		(void *  )0, 0, 1, & doneEvent, & ioStatus);
	#line 6127
	if(irp == (void *  )0)
	{
		do
		{
			#line 6129
			;
		}
		while(0);
		#line 6135
		return (NTSTATUS )0xC000009AL;
	}
	#line 6138
	irpStack = ((irp->Tail).Overlay).CurrentStackLocation - 1;
	((irpStack->Parameters).DeviceIoControl).Type3InputBuffer = Data;
	#line 6144
	ntStatus = IofCallDriver(DeviceObject, irp);
	#line 6146
	if(ntStatus == (NTSTATUS )0x00000103L)
	{
		#line 6152
		KeWaitForSingleObject(& doneEvent, Suspended, KernelMode, 0,
			(void *  )0);
		#line 6158
		ntStatus = ioStatus.Status;
	}
	#line 6161
	return ntStatus;
}

#line 6165
NTSTATUS FlHdbit(PDISKETTE_EXTENSION DisketteExtension )
{
	#line 6189
	NTSTATUS ntStatus ;
	USHORT st ;
	USHORT st2 ;
	USHORT st3 ;
	USHORT st4 ;
	SHORT sel ;
	SHORT st5 = 0;
	LARGE_INTEGER motorOnDelay ;
	#line 6198
	USHORT lpc ;
	UCHAR resultStatus0Save[4] ;
	USHORT resultStatus0 ;
	ULONG getStatusRetryCount ;
	ULONG rqmReadyRetryCount ;
	#line 6204
	BOOLEAN media144MB ;
	BOOLEAN mediaUpTo120MB ;
	BOOLEAN supportDrive ;
	#line 6208
	SET_HD_BIT_PARMS setHdBitParameter ;
	#line 6210
	media144MB = 0;
	mediaUpTo120MB = 0;
	supportDrive = 1;
	#line 6217
	do
	{
		#line 6217
		;
	}
	while(0);
	#line 6219
	switch(DisketteExtension->DriveMediaType)
	{
		#line 6225
	case Drive144Media144Nec98:
			#line 6225
			;
		media144MB = 1;
		#line 6228
	case Drive144Media120Nec98:
			#line 6228
			;
	case Drive144Media123Nec98:
			#line 6229
			;
	case Drive120Media120Nec98:
			#line 6230
			;
	case Drive120Media123Nec98:
			#line 6231
			;
	case Drive12EMedia120Nec98:
			#line 6232
			;
	case Drive12EMedia123Nec98:
			#line 6233
			;
		mediaUpTo120MB = 1;
		#line 6236
	case Drive360Media160Nec98:
			#line 6236
			;
	case Drive360Media180Nec98:
			#line 6237
			;
	case Drive360Media320Nec98:
			#line 6238
			;
	case Drive360Media32XNec98:
			#line 6239
			;
	case Drive360Media360Nec98:
			#line 6240
			;
		#line 6242
	case Drive120Media160Nec98:
			#line 6242
			;
	case Drive120Media180Nec98:
			#line 6243
			;
	case Drive120Media320Nec98:
			#line 6244
			;
	case Drive120Media32XNec98:
			#line 6245
			;
	case Drive120Media360Nec98:
			#line 6246
			;
	case Drive120Media640Nec98:
			#line 6247
			;
	case Drive120Media720Nec98:
			#line 6248
			;
		#line 6250
	case Drive144Media640Nec98:
			#line 6250
			;
	case Drive144Media720Nec98:
			#line 6251
			;
		#line 6253
		break;
		#line 6255
	default :
			#line 6255
			;
		#line 6260
		mediaUpTo120MB = 1;
		#line 6262
		break;
	}
	#line 6265
	setHdBitParameter.Media144MB = media144MB;
	setHdBitParameter.More120MB = mediaUpTo120MB;
	setHdBitParameter.DeviceUnit = DisketteExtension->DeviceUnit;
	setHdBitParameter.DriveType144MB = DisketteExtension->DriveType == 3 ? 1
		: 0;
	#line 6271
	ntStatus = FlFdcDeviceIo(DisketteExtension->TargetObject, 0x00000007 <<
		16 | 0 << 14 | 0x311 << 2 | 3, & setHdBitParameter);
	#line 6275
	if(! ((NTSTATUS )ntStatus >= 0))
	{
		#line 6276
		return ntStatus;
	}
	#line 6279
	if(setHdBitParameter.ChangedHdBit)
	{
		ntStatus = FlDatarateSpecifyConfigure(DisketteExtension);
	}
	#line 6284
	return ntStatus;
}

#line 6286
NTSTATUS FloppyQueueRequest(PDISKETTE_EXTENSION DisketteExtension , PIRP Irp )
{
	#line 6312
	KIRQL oldIrql ;
	NTSTATUS ntStatus ;
	{
		#line 6318
		ExAcquireFastMutex(PagingMutex);
		#line 6318
		if(++ PagingReferenceCount == 1)
		{
			#line 6318
			MmResetDriverPaging(DriverEntry);
		}
		#line 6318
		ExReleaseFastMutex(PagingMutex);
	}
	#line 6318
	;
	#line 6323
	;
	#line 6333
	* & oldIrql = KfAcquireSpinLock(& DisketteExtension->FlCancelSpinLock);
	#line 6335
	(PDRIVER_CANCEL )((PVOID )InterlockedExchange((PLONG )((PVOID *  )(&
		Irp->CancelRoutine)), (LONG )((PVOID
		)FloppyCancelQueuedRequest)));
	#line 6340
	if(Irp->Cancel && (PDRIVER_CANCEL )((PVOID )InterlockedExchange((PLONG
		)((PVOID *  )(& Irp->CancelRoutine)), (LONG )((PVOID )((void * 
		)0)))))
	{
		#line 6345
		(Irp->IoStatus).Status = (NTSTATUS )0xC0000120L;
		myStatus = (NTSTATUS )0xC0000120L;
		(Irp->IoStatus).Information = 0;
		#line 6348
		KfReleaseSpinLock(& DisketteExtension->FlCancelSpinLock,
			oldIrql);
		#line 6349
		IofCompleteRequest(Irp, 0);
		{
			ExAcquireFastMutex(PagingMutex);
			#line 6351
			if(-- PagingReferenceCount == 0)
			{
				#line 6351
				MmPageEntireDriver(DriverEntry);
			}
			#line 6351
			ExReleaseFastMutex(PagingMutex);
		}
		#line 6351
		;
		#line 6353
		ntStatus = (NTSTATUS )0xC0000120L;
	}
	else
	{
		#line 6359
		(Irp->IoStatus).Status = (NTSTATUS )0x00000103L;
		myStatus = (NTSTATUS )0x00000103L;
		#line 6361
		(((Irp->Tail).Overlay).CurrentStackLocation)->Control |= 0x01;
		if(pended == 0)
			#line 6362
			pended = 1;
		else
			#line 6362
			errorFn();
		ExfInterlockedInsertTailList(&
			DisketteExtension->NewRequestQueue, &
			((Irp->Tail).Overlay).ListEntry, &
			DisketteExtension->NewRequestQueueSpinLock);
		#line 6368
		KfReleaseSpinLock(& DisketteExtension->FlCancelSpinLock,
			oldIrql);
		ntStatus = (NTSTATUS )0x00000103L;
	}
	#line 6373
	return ntStatus;
}

#line 6375
void FloppyCancelQueuedRequest(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
	#line 6402
	PDISKETTE_EXTENSION disketteExtension = DeviceObject->DeviceExtension;
	KIRQL oldIrql ;
	#line 6406
	do
	{
		#line 6406
		;
	}
	while(0);
	* & oldIrql = KfAcquireSpinLock(& disketteExtension->FlCancelSpinLock);
	#line 6411
	(Irp->IoStatus).Status = (NTSTATUS )0xC0000120L;
	myStatus = (NTSTATUS )0xC0000120L;
	(Irp->IoStatus).Information = 0;
	#line 6417
	if((((Irp->Tail).Overlay).ListEntry).Flink)
	{
		{
			#line 6418
			PLIST_ENTRY _EX_Blink ;
			#line 6418
			PLIST_ENTRY _EX_Flink ;
			#line 6418
			_EX_Flink = (& ((Irp->Tail).Overlay).ListEntry)->Flink;
			#line 6418
			_EX_Blink = (& ((Irp->Tail).Overlay).ListEntry)->Blink;
			#line 6418
			_EX_Blink->Flink = _EX_Flink;
			#line 6418
			_EX_Flink->Blink = _EX_Blink;
		}
		#line 6418
		;
	}
	#line 6422
	KfReleaseSpinLock(& disketteExtension->FlCancelSpinLock, oldIrql);
	#line 6424
	IoReleaseCancelSpinLock(Irp->CancelIrql);
	#line 6426
	IofCompleteRequest(Irp, 0);
	{
		ExAcquireFastMutex(PagingMutex);
		#line 6428
		if(-- PagingReferenceCount == 0)
		{
			#line 6428
			MmPageEntireDriver(DriverEntry);
		}
		#line 6428
		ExReleaseFastMutex(PagingMutex);
	}
	#line 6428
	;
	#line 6430
	return;
}

#line 6432
void FloppyProcessQueuedRequests(PDISKETTE_EXTENSION DisketteExtension )
{
	#line 6457
	KIRQL oldIrql ;
	PLIST_ENTRY headOfList ;
	PIRP currentIrp ;
	PIO_STACK_LOCATION irpSp ;
	#line 6470
	* & oldIrql = KfAcquireSpinLock(& DisketteExtension->FlCancelSpinLock);
	while((headOfList = ExfInterlockedRemoveHeadList(&
		DisketteExtension->NewRequestQueue, &
		DisketteExtension->NewRequestQueueSpinLock)) != (void *  )0)
	{
		currentIrp = (IRP *  )((PCHAR )headOfList - (ULONG_PTR )(&
			((((IRP *  )0)->Tail).Overlay).ListEntry));
		#line 6479
		if((PDRIVER_CANCEL )((PVOID )InterlockedExchange((PLONG )((PVOID
			*  )(& currentIrp->CancelRoutine)), (LONG )((PVOID
			)((void *  )0)))))
		{
			#line 6480
			irpSp =
				((currentIrp->Tail).Overlay).CurrentStackLocation;
		}
		else
		{
			#line 6487
			(((currentIrp->Tail).Overlay).ListEntry).Flink =
				(void *  )0;
			#line 6488
			currentIrp = (void *  )0;
		}
		#line 6492
		KfReleaseSpinLock(& DisketteExtension->FlCancelSpinLock,
			oldIrql);
		if(currentIrp)
		{
			#line 6495
			if(DisketteExtension->IsRemoved)
			{
				#line 6499
				(currentIrp->IoStatus).Information = 0;
				(currentIrp->IoStatus).Status = (NTSTATUS
					)0xC0000056L;
				#line 6501
				IofCompleteRequest(currentIrp, 0);
			}
			else
			{
				switch(irpSp->MajorFunction)
				{
				case 0x03:
						#line 6507
						;
				case 0x04:
						#line 6508
						;
					#line 6510
					(void )FloppyReadWrite(DisketteExtension
						->DeviceObject, currentIrp);
					#line 6511
					break;
					#line 6513
				case 0x0e:
						#line 6513
						;
					#line 6515
					(void )FloppyDeviceControl(DisketteExtension
						->DeviceObject, currentIrp);
					#line 6516
					break;
					#line 6518
				default :
						#line 6518
						;
					#line 6520
					(currentIrp->IoStatus).Information = 0;
					(currentIrp->IoStatus).Status =
						(NTSTATUS )0xC0000001L;
					#line 6522
					IofCompleteRequest(currentIrp, 0);
				}
			}
		}
		#line 6527
		if(currentIrp)
		{
			{
				#line 6531
				ExAcquireFastMutex(PagingMutex);
				#line 6531
				if(-- PagingReferenceCount == 0)
				{
					#line 6531
					MmPageEntireDriver(DriverEntry);
				}
				#line 6531
				ExReleaseFastMutex(PagingMutex);
			}
			#line 6531
			;
		}
		#line 6535
		* & oldIrql = KfAcquireSpinLock(&
			DisketteExtension->FlCancelSpinLock);
	}
	#line 6540
	KfReleaseSpinLock(& DisketteExtension->FlCancelSpinLock, oldIrql);
	#line 6542
	return;
}

#line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"

#pragma once
#line 32

#pragma pack(push, 8)
#line 72
typedef enum _EXCEPTION_DISPOSITION ;

#line 89
struct _EXCEPTION_RECORD ;

#line 90
struct _CONTEXT ;

#line 155

#pragma pack(pop)
#line 25 "C:/NTDDK/inc/ntdef.h"

#pragma once
#line 15 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"

#pragma once
#line 60
typedef unsigned short ;

#line 66
typedef wchar_t ;

#line 67
typedef wchar_t ;

#line 127 "C:/NTDDK/inc/ntdef.h"
typedef unsigned long ;

#line 25 "C:/NTDDK/inc/basetsd.h"

#pragma once
#line 36
typedef int ;

#line 37
typedef int ;

#line 43
typedef unsigned int ;

#line 44
typedef unsigned int ;

#line 45
typedef unsigned int ;

#line 84
typedef int ;

#line 85
typedef unsigned int ;

typedef long ;

#line 88
typedef unsigned long ;

#line 248
typedef unsigned short ;

#line 249
typedef short ;

#line 250
typedef unsigned long ;

#line 288
typedef ULONG_PTR ;

#line 289
typedef LONG_PTR ;

#line 295
typedef ULONG_PTR ;

#line 301
typedef __int64 ;

#line 302
typedef __int64 ;

#line 309
typedef unsigned __int64 ;

#line 310
typedef unsigned __int64 ;

#line 311
typedef unsigned __int64 ;

#line 217 "C:/NTDDK/inc/ntdef.h"
typedef void ;

#line 218
typedef void ;

#line 266
typedef char ;

#line 267
typedef short ;

#line 268
typedef long ;

#line 276
typedef wchar_t ;

#line 282
typedef WCHAR ;

#line 283
typedef WCHAR ;

#line 284
typedef const WCHAR ;

#line 285
typedef WCHAR ;

#line 286
typedef WCHAR ;

typedef const WCHAR ;

#line 293
typedef CHAR ;

#line 294
typedef CHAR ;

typedef const CHAR ;

#line 297
typedef CHAR ;

#line 298
typedef CHAR ;

#line 299
typedef const CHAR ;

#line 321
typedef char ;

#line 322
typedef unsigned char ;

#line 326
typedef LPSTR ;

#line 327
typedef LPSTR ;

#line 328
typedef LPCSTR ;

#line 337
typedef double ;

typedef struct _QUAD ;

#line 349
typedef SHORT ;

#line 350
typedef LONG ;

#line 351
typedef QUAD ;

#line 360
typedef unsigned char ;

#line 361
typedef unsigned short ;

#line 362
typedef unsigned long ;

#line 363
typedef QUAD ;

#line 369
typedef UCHAR ;

#line 370
typedef USHORT ;

#line 371
typedef ULONG ;

#line 372
typedef UQUAD ;

#line 378
typedef signed char ;

#line 379
typedef SCHAR ;

#line 394
typedef void ;

#line 400
typedef HANDLE ;

#line 406
typedef UCHAR ;

#line 407
typedef USHORT ;

#line 408
typedef ULONG ;

#line 414
typedef LONG ;

#line 478
typedef char ;

#line 479
typedef short ;

#line 480
typedef ULONG ;

typedef CCHAR ;

#line 483
typedef CSHORT ;

#line 484
typedef CLONG ;

#line 492
typedef ULONG ;

#line 493
typedef PULONG ;

#line 494
typedef USHORT ;

#line 500
typedef ULONG ;

#line 501
typedef ULONG ;

#line 508
typedef LONG ;

typedef NTSTATUS ;

#line 602
typedef struct _FLOAT128 ;

#line 607
typedef FLOAT128 ;

#line 621
typedef __int64 ;

#line 622
typedef unsigned __int64 ;

#line 639
typedef LONGLONG ;

#line 640
typedef ULONGLONG ;

#line 644
typedef LONGLONG ;

#line 649
typedef union _LARGE_INTEGER ;

#line 662
typedef LARGE_INTEGER ;

#line 668
typedef union _ULARGE_INTEGER ;

#line 681
typedef ULARGE_INTEGER ;

#line 690
typedef struct _LUID ;

#line 696
typedef ULONGLONG ;

#line 697
typedef DWORDLONG ;

#line 707
typedef LARGE_INTEGER ;

#line 831

#pragma warning(push)

#pragma warning(disable:4035)
__inline ULONGLONG __stdcall Int64ShllMod32___1(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 842
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    
		};
}

#line 845
__inline LONGLONG __stdcall Int64ShraMod32___1(LONGLONG Value , ULONG ShiftCount
	)
{
	#line 852
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    
		};
}

#line 855
__inline ULONGLONG __stdcall Int64ShrlMod32___1(ULONGLONG Value , ULONG
	ShiftCount )
{
	#line 862
	__asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    
		};
}


#pragma warning(pop)
#line 956
typedef enum _EVENT_TYPE ;

#line 965
typedef enum _TIMER_TYPE ;

#line 974
typedef enum _WAIT_TYPE ;

#line 983
typedef CHAR ;

#line 984
typedef const char ;

#line 991
typedef struct _STRING ;

#line 999
typedef STRING ;

typedef STRING ;

#line 1002
typedef PSTRING ;

typedef STRING ;

#line 1005
typedef PSTRING ;

#line 1011
typedef struct _CSTRING ;

#line 1016
typedef CSTRING ;

#line 1019
typedef STRING ;

#line 1020
typedef PSTRING ;

#line 1027
typedef struct _UNICODE_STRING ;

#line 1036
typedef UNICODE_STRING ;

#line 1037
typedef const UNICODE_STRING ;

#line 1046
typedef UCHAR ;

#line 1047
typedef BOOLEAN ;

#line 1057
typedef struct _LIST_ENTRY ;

#line 1067
typedef struct _SINGLE_LIST_ENTRY ;

#line 1078
typedef struct LIST_ENTRY32 ;

#line 1082
typedef LIST_ENTRY32 ;

typedef struct LIST_ENTRY64 ;

#line 1088
typedef LIST_ENTRY64 ;

#line 1127
typedef struct _STRING32 ;

#line 1132
typedef STRING32 ;

typedef STRING32 ;

#line 1135
typedef UNICODE_STRING32 ;

typedef STRING32 ;

#line 1138
typedef ANSI_STRING32 ;

#line 1141
typedef struct _STRING64 ;

#line 1146
typedef STRING64 ;

typedef STRING64 ;

#line 1149
typedef UNICODE_STRING64 ;

typedef STRING64 ;

#line 1152
typedef ANSI_STRING64 ;

#line 1173
typedef struct _OBJECT_ATTRIBUTES ;

#line 1181
typedef OBJECT_ATTRIBUTES ;

#line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID ;

#line 70
typedef GUID ;

#line 75
typedef const GUID ;

#line 81
typedef GUID ;

#line 82
typedef IID ;

#line 85
typedef GUID ;

#line 86
typedef CLSID ;

#line 89
typedef GUID ;

#line 90
typedef FMTID ;

#line 16 "C:/NTDDK/inc/string.h"

#pragma once
#line 54
typedef unsigned int ;

#line 1233 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECTID ;

#line 1288
struct _CONTEXT ;

#line 1289
struct _EXCEPTION_RECORD ;

typedef EXCEPTION_DISPOSITION ;

#line 1306
typedef UCHAR ;

typedef KIRQL ;

#line 1316
typedef enum _NT_PRODUCT_TYPE ;

#line 1329
typedef enum _SUITE_TYPE ;

#line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD ;

#line 76
typedef struct _ETHREAD ;

#line 77
typedef struct _EPROCESS ;

#line 78
typedef struct _PEB ;

#line 79
typedef struct _KINTERRUPT ;

#line 80
typedef struct _IO_TIMER ;

#line 81
typedef struct _OBJECT_TYPE ;

#line 82
typedef struct _CALLBACK_OBJECT ;

#line 83
typedef struct _DEVICE_HANDLER_OBJECT ;

#line 84
typedef struct _BUS_HANDLER ;

#line 143
typedef union _SLIST_HEADER ;

#line 204
typedef CCHAR ;

typedef enum _MODE ;

#line 222
struct _KAPC ;

typedef void ;

#line 232
typedef void ;

#line 242
typedef void ;

#line 248
typedef BOOLEAN ;

#line 254
typedef BOOLEAN ;

#line 265
typedef struct _KAPC ;

#line 292
struct _KDPC ;

typedef void ;

#line 351
typedef enum _KDPC_IMPORTANCE ;

#line 361
typedef struct _KDPC ;

#line 377
typedef PVOID ;

typedef void ;

#line 392
typedef struct _KIPI_COUNTS ;

#line 443
typedef struct _MDL ;

#line 532
typedef PVOID ;

#line 538
typedef PVOID ;

#line 544
typedef PVOID ;

typedef ULONG ;

#line 547
typedef ACCESS_MASK ;

#line 597
typedef struct _GENERIC_MAPPING ;

#line 603
typedef GENERIC_MAPPING ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES ;

#line 622
typedef LUID_AND_ATTRIBUTES ;

#line 623
typedef LUID_AND_ATTRIBUTES_ARRAY ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 642 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACL ;

#line 649
typedef ACL ;

#line 681
typedef struct _PRIVILEGE_SET ;

#line 735
typedef enum _SECURITY_IMPERSONATION_LEVEL ;

#line 753
typedef BOOLEAN ;

#line 762
typedef struct _SECURITY_QUALITY_OF_SERVICE ;

#line 774
typedef struct _SE_IMPERSONATION_STATE ;

#line 782
typedef ULONG ;

#line 809
typedef ULONG ;

#line 810
typedef KAFFINITY ;

#line 816
typedef LONG ;

#line 824
typedef ULONG_PTR ;

#line 825
typedef KSPIN_LOCK ;

#line 833
typedef void ;

#line 842
typedef enum _KPROFILE_SOURCE ;

#line 1079
typedef NTSTATUS ;

#line 1088
typedef struct _RTL_QUERY_REGISTRY_TABLE ;

#line 1952

#pragma warning(push)

#pragma warning(disable:4035)
#line 2019

#pragma warning(pop)
#line 2214
typedef struct _TIME_FIELDS ;

#line 2224
typedef TIME_FIELDS ;

#line 2499
typedef struct _RTL_BITMAP ;

#line 2503
typedef RTL_BITMAP ;

#line 2627
typedef struct _RTL_BITMAP_RUN ;

#line 2633
typedef RTL_BITMAP_RUN ;

#line 2886
typedef struct _RTL_RANGE ;

#line 2924
typedef struct _RTL_RANGE_LIST ;

#line 2950
typedef struct _RANGE_LIST_ITERATOR ;

#line 3019
typedef BOOLEAN ;

#line 3155
typedef struct _OSVERSIONINFOA ;

#line 3164
typedef struct _OSVERSIONINFOW ;

#line 3177
typedef OSVERSIONINFOA ;

#line 3178
typedef POSVERSIONINFOA ;

#line 3179
typedef LPOSVERSIONINFOA ;

#line 3182
typedef struct _OSVERSIONINFOEXA ;

#line 3195
typedef struct _OSVERSIONINFOEXW ;

#line 3213
typedef OSVERSIONINFOEXA ;

#line 3214
typedef POSVERSIONINFOEXA ;

#line 3215
typedef LPOSVERSIONINFOEXA ;

#line 3648
typedef struct _IO_STATUS_BLOCK ;

#line 3669
typedef void ;

#line 3685
typedef enum _FILE_INFORMATION_CLASS ;

#line 3731
typedef struct _FILE_BASIC_INFORMATION ;

#line 3739
typedef struct _FILE_STANDARD_INFORMATION ;

#line 3747
typedef struct _FILE_POSITION_INFORMATION ;

#line 3751
typedef struct _FILE_ALIGNMENT_INFORMATION ;

#line 3755
typedef struct _FILE_NAME_INFORMATION ;

#line 3760
typedef struct _FILE_NETWORK_OPEN_INFORMATION ;

#line 3770
typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION ;

#line 3775
typedef struct _FILE_DISPOSITION_INFORMATION ;

#line 3779
typedef struct _FILE_END_OF_FILE_INFORMATION ;

#line 3784
typedef struct _FILE_FULL_EA_INFORMATION ;

#line 3798
typedef enum _FSINFOCLASS ;

#line 3810
typedef struct _FILE_FS_DEVICE_INFORMATION ;

#line 3820
typedef union _FILE_SEGMENT_ELEMENT ;

#line 3829
typedef enum _INTERFACE_TYPE ;

#line 3854
typedef enum _DMA_WIDTH ;

#line 3865
typedef enum _DMA_SPEED ;

#line 3879
typedef void ;

#line 3880
typedef void ;

#line 3888
typedef enum _BUS_DATA_TYPE ;

#line 3910
typedef struct _IO_ERROR_LOG_PACKET ;

#line 3931
typedef struct _IO_ERROR_LOG_MESSAGE ;

#line 4074
typedef struct _KEY_BASIC_INFORMATION ;

#line 4081
typedef struct _KEY_NODE_INFORMATION ;

#line 4091
typedef struct _KEY_FULL_INFORMATION ;

#line 4106
typedef struct _KEY_NAME_INFORMATION ;

#line 4112
typedef enum _KEY_INFORMATION_CLASS ;

#line 4122
typedef struct _KEY_WRITE_TIME_INFORMATION ;

#line 4126
typedef enum _KEY_SET_INFORMATION_CLASS ;

#line 4134
typedef struct _KEY_VALUE_BASIC_INFORMATION ;

#line 4141
typedef struct _KEY_VALUE_FULL_INFORMATION ;

#line 4151
typedef struct _KEY_VALUE_PARTIAL_INFORMATION ;

#line 4158
typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ;

#line 4164
typedef struct _KEY_VALUE_ENTRY ;

#line 4171
typedef enum _KEY_VALUE_INFORMATION_CLASS ;

#line 4210
typedef struct _OBJECT_NAME_INFORMATION ;

#line 4221
typedef enum _SECTION_INHERIT ;

#line 4294
typedef struct _CLIENT_ID ;

#line 4298
typedef CLIENT_ID ;

#line 4315
typedef struct _NT_TIB ;

#line 4327
typedef NT_TIB ;

#line 4332
typedef enum _PROCESSINFOCLASS ;

#line 4366
typedef enum _THREADINFOCLASS ;

#line 4395
typedef struct _PROCESS_WS_WATCH_INFORMATION ;

#line 4405
typedef struct _PROCESS_BASIC_INFORMATION ;

#line 4413
typedef PROCESS_BASIC_INFORMATION ;

#line 4422
typedef struct _PROCESS_DEVICEMAP_INFORMATION ;

#line 4440
typedef struct _PROCESS_SESSION_INFORMATION ;

#line 4454
typedef struct _QUOTA_LIMITS ;

#line 4462
typedef QUOTA_LIMITS ;

#line 4472
typedef struct _IO_COUNTERS ;

#line 4480
typedef IO_COUNTERS ;

#line 4488
typedef struct _VM_COUNTERS ;

#line 4501
typedef VM_COUNTERS ;

#line 4508
typedef struct _POOLED_USAGE_AND_LIMITS ;

#line 4519
typedef POOLED_USAGE_AND_LIMITS ;

#line 4528
typedef struct _PROCESS_ACCESS_TOKEN ;

#line 4555
typedef struct _KERNEL_USER_TIMES ;

#line 4561
typedef KERNEL_USER_TIMES ;

#line 4587
typedef enum _SYSTEM_POWER_STATE ;

#line 4598
typedef enum  {
	PowerActionNone = 0,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
} ;

typedef enum _DEVICE_POWER_STATE ;

#line 4618
typedef union _POWER_STATE ;

#line 4623
typedef enum _POWER_STATE_TYPE ;

#line 4654
typedef ULONG ;

typedef enum  {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
} ;

#line 4663
typedef enum  {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation
} ;

#line 4690
typedef ULONG ;

typedef LONG ;

#line 4693
typedef ULONG ;

#line 4719
typedef union _MCI_STATS ;

#line 4978
typedef struct _KPCR ;

#line 5006
typedef KPCR ;

#line 5012
typedef struct _KFLOATING_SAVE ;

#line 5153
typedef enum _INTERLOCKED_RESULT ;

#line 5252

#pragma warning(disable:4035)
#line 6994
typedef struct _KSYSTEM_TIME ;

#line 7014

#pragma warning(push)

#pragma warning(disable:4164)
#line 7019

#pragma function(_enable)
#line 7020

#pragma function(_disable)
#line 7024

#pragma warning(pop)
#line 7085
typedef struct _FLOATING_SAVE_AREA ;

#line 7097
typedef FLOATING_SAVE_AREA ;

#line 7109
typedef struct _CONTEXT ;

#line 7197
typedef CONTEXT ;

#line 7826
typedef void ;

#line 7850
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE ;

#line 7899
typedef struct _KUSER_SHARED_DATA ;

#line 8123
typedef enum _CM_SERVICE_NODE_TYPE ;

#line 8132
typedef enum _CM_SERVICE_LOAD_TYPE ;

#line 8140
typedef enum _CM_ERROR_CONTROL_TYPE ;

#line 8172
typedef int ;

#line 8198
typedef enum _CM_SHARE_DISPOSITION ;

#line 8211
typedef PVOID ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST ;

#line 8443
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR ;

#line 8454
typedef struct _CM_RESOURCE_LIST ;

#line 8471
typedef struct _DEVICE_FLAGS ;

#line 8485
typedef struct _CM_COMPONENT_INFORMATION ;

#line 8503
typedef struct _CM_ROM_BLOCK ;

#line 24 "C:/NTDDK/inc/pshpack1.h"

#pragma warning(disable:4103)

#pragma pack(push, 1)
#line 8518 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_INT13_DRIVE_PARAMETER ;

#line 8532
typedef struct _CM_MCA_POS_DATA ;

#line 8544
typedef struct _EISA_MEMORY_TYPE ;

#line 8554
typedef struct _EISA_MEMORY_CONFIGURATION ;

#line 8567
typedef struct _EISA_IRQ_DESCRIPTOR ;

#line 8575
typedef struct _EISA_IRQ_CONFIGURATION ;

#line 8585
typedef struct _DMA_CONFIGURATION_BYTE0 ;

#line 8592
typedef struct _DMA_CONFIGURATION_BYTE1 ;

#line 8599
typedef struct _EISA_DMA_CONFIGURATION ;

#line 8609
typedef struct _EISA_PORT_DESCRIPTOR ;

#line 8616
typedef struct _EISA_PORT_CONFIGURATION ;

#line 8628
typedef struct _CM_EISA_SLOT_INFORMATION ;

#line 8644
typedef struct _CM_EISA_FUNCTION_INFORMATION ;

#line 8678
typedef struct _CM_PNP_BIOS_DEVICE_NODE ;

#line 8692
typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 8761 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_SCSI_DEVICE_DATA ;

#line 8775
typedef struct _CM_VIDEO_DEVICE_DATA ;

#line 8785
typedef struct _CM_SONIC_DEVICE_DATA ;

#line 8796
typedef struct _CM_SERIAL_DEVICE_DATA ;

#line 8810
typedef struct _CM_MONITOR_DEVICE_DATA ;

#line 8844
typedef struct _CM_FLOPPY_DEVICE_DATA ;

#line 8881
typedef struct _CM_KEYBOARD_DEVICE_DATA ;

#line 8893
typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA ;

#line 8905
typedef struct _CM_PCCARD_DEVICE_DATA ;

#line 8944
typedef struct _IO_RESOURCE_DESCRIPTOR ;

#line 9027
typedef struct _IO_RESOURCE_LIST ;

#line 9036
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST ;

#line 9065
typedef struct _EXCEPTION_RECORD ;

#line 9074
typedef EXCEPTION_RECORD ;

typedef struct _EXCEPTION_RECORD32 ;

#line 9085
typedef struct _EXCEPTION_RECORD64 ;

#line 9099
typedef struct _EXCEPTION_POINTERS ;

#line 9111
typedef enum _CONFIGURATION_TYPE ;

#line 9161
typedef enum _KINTERRUPT_MODE ;

#line 9170
typedef enum _KWAIT_REASON ;

#line 9207
typedef struct _DISPATCHER_HEADER ;

#line 9217
typedef struct _KWAIT_BLOCK ;

#line 9230
typedef void ;

#line 9244
typedef struct _KDEVICE_QUEUE ;

#line 9252
typedef struct _KDEVICE_QUEUE_ENTRY ;

#line 9263
typedef struct _KEVENT ;

#line 9271
typedef BOOLEAN ;

#line 9281
typedef struct _KMUTANT ;

#line 9294
typedef struct _KSEMAPHORE ;

#line 9304
typedef struct _KTIMER ;

#line 9899
typedef enum _KBUGCHECK_BUFFER_DUMP_STATE ;

#line 9907
typedef void ;

#line 9914
typedef struct _KBUGCHECK_CALLBACK_RECORD ;

#line 10002
typedef void ;

#line 10020
typedef LOGICAL ;

#line 10037
typedef void ;

#line 10053
typedef enum _MEMORY_CACHING_TYPE_ORIG ;

#line 10057
typedef enum _MEMORY_CACHING_TYPE ;

#line 10087
typedef struct _DBGKD_DEBUG_DATA_HEADER64 ;

#line 10115
typedef enum _POOL_TYPE ;

#line 10195
typedef enum _EX_POOL_PRIORITY ;

#line 10247
typedef struct _FAST_MUTEX ;

#line 10574
typedef PVOID ;

#line 10582
typedef void ;

#line 10588
typedef struct _GENERAL_LOOKASIDE ;

#line 10619
typedef struct _NPAGED_LOOKASIDE_LIST ;

#line 10729
typedef struct _PAGED_LOOKASIDE_LIST ;

#line 10882
typedef enum _WORK_QUEUE_TYPE ;

#line 10889
typedef void ;

#line 10895
typedef struct _WORK_QUEUE_ITEM ;

#line 10926
typedef struct _ZONE_SEGMENT_HEADER ;

#line 10931
typedef struct _ZONE_HEADER ;

#line 11156
typedef ULONG_PTR ;

#line 11157
typedef ERESOURCE_THREAD ;

typedef struct _OWNER_ENTRY ;

#line 11168
typedef struct _ERESOURCE ;

#line 11197
typedef struct _RESOURCE_HASH_ENTRY ;

#line 11204
typedef struct _RESOURCE_PERFORMANCE_DATA ;

#line 11429
typedef struct _CALLBACK_OBJECT ;

typedef void ;

#line 11474
typedef GUID ;

#line 11862
typedef enum _MM_SYSTEM_SIZE ;

#line 11884
typedef enum _LOCK_OPERATION ;

#line 11970
typedef enum _MM_PAGE_PRIORITY ;

#line 11999
typedef struct _PHYSICAL_MEMORY_RANGE ;

#line 12385
typedef NTSTATUS ;

#line 12389
typedef NTSTATUS ;

#line 12399
struct _DRIVER_OBJECT ;

#line 12411
typedef enum _SECURITY_OPERATION_CODE ;

#line 12426
typedef struct _SECURITY_SUBJECT_CONTEXT ;

#line 12448
typedef struct _INITIAL_PRIVILEGE_SET ;

#line 12462
typedef struct _ACCESS_STATE ;

#line 12571
typedef void ;

#line 12585
typedef void ;

#line 12602
typedef struct _IMAGE_INFO ;

#line 12620
typedef void ;

#line 12859
typedef NTSTATUS ;

#line 12878
typedef enum _IO_QUERY_DEVICE_DATA_FORMAT ;

#line 12890
typedef enum _CREATE_FILE_TYPE ;

#line 12905
struct _DEVICE_DESCRIPTION ;

#line 12906
struct _DEVICE_OBJECT ;

#line 12907
struct _DMA_ADAPTER ;

#line 12908
struct _DRIVER_OBJECT ;

#line 12909
struct _DRIVE_LAYOUT_INFORMATION ;

#line 12910
struct _DISK_PARTITION ;

#line 12911
struct _FILE_OBJECT ;

#line 12912
struct _IRP ;

#line 12913
struct _SCSI_REQUEST_BLOCK ;

#line 12919
typedef void ;

#line 12932
typedef void ;

#line 12943
typedef NTSTATUS ;

#line 12955
typedef void ;

#line 12968
typedef void ;

#line 12979
typedef NTSTATUS ;

#line 12990
typedef void ;

#line 13001
typedef void ;

#line 13011
typedef NTSTATUS ;

#line 13025
typedef BOOLEAN ;

#line 13038
typedef BOOLEAN ;

#line 13051
typedef BOOLEAN ;

#line 13068
typedef BOOLEAN ;

#line 13078
typedef BOOLEAN ;

#line 13092
typedef BOOLEAN ;

#line 13106
typedef BOOLEAN ;

#line 13118
typedef BOOLEAN ;

#line 13127
typedef BOOLEAN ;

#line 13141
typedef BOOLEAN ;

#line 13161
typedef void ;

#line 13167
typedef void ;

#line 13179
typedef void ;

#line 13193
typedef BOOLEAN ;

#line 13207
typedef BOOLEAN ;

#line 13219
typedef BOOLEAN ;

#line 13227
typedef BOOLEAN ;

#line 13239
typedef BOOLEAN ;

#line 13253
typedef NTSTATUS ;

#line 13262
typedef NTSTATUS ;

#line 13275
typedef NTSTATUS ;

#line 13282
typedef NTSTATUS ;

#line 13289
typedef BOOLEAN ;

#line 13304
typedef BOOLEAN ;

#line 13319
typedef BOOLEAN ;

#line 13327
typedef BOOLEAN ;

#line 13336
typedef BOOLEAN ;

#line 13350
typedef struct _FAST_IO_DISPATCH ;

#line 13386
typedef enum _IO_ALLOCATION_ACTION ;

#line 13396
typedef IO_ALLOCATION_ACTION ;

#line 13410
typedef struct _IO_SECURITY_CONTEXT ;

#line 13434
typedef struct _VPB ;

#line 13482
typedef struct _ADAPTER_OBJECT ;

#line 13491
typedef struct _WAIT_CONTEXT_BLOCK ;

#line 13503
typedef struct _CONTROLLER_OBJECT ;

#line 13537
typedef struct _DEVICE_OBJECT ;

#line 13575
typedef struct _DEVICE_OBJECT ;

#line 13578
struct _DEVICE_OBJECT_POWER_EXTENSION ;

typedef struct _DEVOBJ_EXTENSION ;

#line 13608
typedef struct _DRIVER_EXTENSION ;

#line 13645
typedef struct _DRIVER_OBJECT ;

#line 13706
typedef struct _DRIVER_OBJECT ;

#line 13715
typedef struct _SECTION_OBJECT_POINTERS ;

#line 13720
typedef SECTION_OBJECT_POINTERS ;

#line 13726
typedef struct _IO_COMPLETION_CONTEXT ;

#line 13759
typedef struct _FILE_OBJECT ;

#line 13788
typedef struct _FILE_OBJECT ;

#line 13828
typedef struct _IRP ;

#line 14078
typedef NTSTATUS ;

#line 14163
typedef enum _DEVICE_RELATION_TYPE ;

#line 14171
typedef struct _DEVICE_RELATIONS ;

#line 14176
typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE ;

#line 14185
typedef struct _INTERFACE ;

#line 14196
typedef struct _DEVICE_CAPABILITIES ;

#line 14229
typedef struct _POWER_SEQUENCE ;

#line 14235
typedef enum  {
	BusQueryDeviceID = 0,
	BusQueryHardwareIDs = 1,
	BusQueryCompatibleIDs = 2,
	BusQueryInstanceID = 3,
	BusQueryDeviceSerialNumber = 4
} ;

typedef ULONG ;

#line 14252
typedef enum  {
	DeviceTextDescription = 0,
	DeviceTextLocationInformation = 1
} ;

#line 24 "C:/NTDDK/inc/pshpack4.h"

#pragma warning(disable:4103)

#pragma pack(push, 4)
#line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION ;

#line 27 "C:/NTDDK/inc/poppack.h"

#pragma warning(disable:4103)

#pragma pack(pop)
#line 14615 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SHARE_ACCESS ;

#line 14635
typedef struct _CONFIGURATION_INFORMATION ;

#line 14848
typedef struct _BOOTDISK_INFORMATION ;

#line 15754
typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK ;

typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK ;

#line 15764
typedef struct _IO_REMOVE_LOCK_DBG_BLOCK ;

#line 15777
typedef struct _IO_REMOVE_LOCK ;

#line 16009
typedef struct _IO_WORKITEM ;

typedef void ;

#line 16100
typedef enum  {
	DevicePropertyDeviceDescription,
	DevicePropertyHardwareID,
	DevicePropertyCompatibleIDs,
	DevicePropertyBootConfiguration,
	DevicePropertyBootConfigurationTranslated,
	DevicePropertyClassName,
	DevicePropertyClassGuid,
	DevicePropertyDriverKeyName,
	DevicePropertyManufacturer,
	DevicePropertyFriendlyName,
	DevicePropertyLocationInformation,
	DevicePropertyPhysicalDeviceObjectName,
	DevicePropertyBusTypeGuid,
	DevicePropertyLegacyBusType,
	DevicePropertyBusNumber,
	DevicePropertyEnumeratorName,
	DevicePropertyAddress,
	DevicePropertyUINumber
} ;

typedef BOOLEAN ;

#line 16129
typedef struct _DMA_ADAPTER ;

#line 16135
typedef ULONG ;

#line 16148
typedef struct _PNP_BUS_INFORMATION ;

#line 16162
typedef struct _LEGACY_BUS_INFORMATION ;

#line 16168
typedef struct _BUS_INTERFACE_STANDARD ;

#line 16190
typedef BOOLEAN ;

#line 16194
typedef NTSTATUS ;

#line 16203
typedef NTSTATUS ;

#line 16206
typedef NTSTATUS ;

#line 16210
typedef NTSTATUS ;

#line 16214
typedef NTSTATUS ;

#line 16218
typedef void ;

#line 16222
typedef NTSTATUS ;

#line 16227
typedef void ;

#line 16231
typedef struct _ACPI_INTERFACE_STANDARD ;

#line 16255
typedef enum _ACPI_REG_TYPE ;

#line 16268
typedef USHORT ;

#line 16272
typedef void ;

#line 16278
typedef struct ACPI_REGS_INTERFACE_STANDARD ;

#line 16300
typedef struct  {
	PVOID LinkNode ;
	ULONG StaticVector ;
	UCHAR Flags ;
} ;

#line 16314
typedef NTSTATUS ;

#line 16329
typedef NTSTATUS ;

#line 16336
typedef void ;

#line 16343
typedef struct _INT_ROUTE_INTERFACE_STANDARD ;

#line 16366
typedef struct _IO_ASSIGNED_RESOURCES ;

#line 16490
typedef enum _IO_NOTIFICATION_EVENT_CATEGORY ;

#line 16504
typedef NTSTATUS ;

#line 16537
typedef void ;

#line 16573
typedef enum _ARBITER_ACTION ;

#line 16586
typedef struct _ARBITER_CONFLICT_INFO ;

#line 16608
typedef struct _ARBITER_PARAMETERS ;

#line 16719
typedef enum _ARBITER_REQUEST_SOURCE ;

#line 16731
typedef enum _ARBITER_RESULT ;

#line 16761
typedef struct _ARBITER_LIST_ENTRY ;

#line 16832
typedef NTSTATUS ;

#line 16853
typedef struct _ARBITER_INTERFACE ;

#line 16880
typedef enum _RESOURCE_TRANSLATION_DIRECTION ;

#line 16889
typedef NTSTATUS ;

#line 16901
typedef NTSTATUS ;

#line 16915
typedef struct _TRANSLATOR_INTERFACE ;

#line 16931
typedef NTSTATUS ;

#line 16945
typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE ;

#line 16959
typedef struct _PLUGPLAY_NOTIFICATION_HEADER ;

#line 16972
typedef struct _HWPROFILE_CHANGE_NOTIFICATION ;

#line 16986
typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION ;

#line 17006
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION ;

#line 17026
typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION ;

#line 17054
typedef struct _DEVICE_DESCRIPTION ;

#line 17086
typedef BOOLEAN ;

#line 17333
typedef void ;

#line 17339
typedef struct _DEVICE_CONTROL_CONTEXT ;

#line 17349
typedef PBUS_HANDLER ;

#line 17355
typedef void ;

#line 17365
typedef enum _HAL_QUERY_INFORMATION_CLASS ;

#line 17381
typedef enum _HAL_SET_INFORMATION_CLASS ;

#line 17388
typedef NTSTATUS ;

#line 17405
typedef NTSTATUS ;

#line 17420
typedef void ;

#line 17429
typedef void ;

#line 17438
typedef NTSTATUS ;

#line 17447
typedef NTSTATUS ;

#line 17456
typedef NTSTATUS ;

#line 17466
typedef NTSTATUS ;

#line 17475
typedef NTSTATUS ;

#line 17486
typedef struct _PM_DISPATCH_TABLE ;

#line 17492
typedef NTSTATUS ;

#line 17505
typedef struct _DMA_ADAPTER ;

#line 17520
typedef NTSTATUS ;

#line 17543
typedef BOOLEAN ;

#line 17553
typedef NTSTATUS ;

#line 17566
typedef void ;

#line 17572
typedef void ;

#line 17578
typedef BOOLEAN ;

#line 17588
typedef struct  {
	ULONG Version ;
	pHalQuerySystemInformation HalQuerySystemInformation ;
	pHalSetSystemInformation HalSetSystemInformation ;
	pHalQueryBusSlots HalQueryBusSlots ;
	ULONG Spare1 ;
	pHalExamineMBR HalExamineMBR ;
	pHalIoAssignDriveLetters HalIoAssignDriveLetters ;
	pHalIoReadPartitionTable HalIoReadPartitionTable ;
	pHalIoSetPartitionInformation HalIoSetPartitionInformation ;
	pHalIoWritePartitionTable HalIoWritePartitionTable ;
	pHalHandlerForBus HalReferenceHandlerForBus ;
	pHalReferenceBusHandler HalReferenceBusHandler ;
	pHalReferenceBusHandler HalDereferenceBusHandler ;
	pHalInitPnpDriver HalInitPnpDriver ;
	pHalInitPowerManagement HalInitPowerManagement ;
	pHalGetDmaAdapter HalGetDmaAdapter ;
	pHalGetInterruptTranslator HalGetInterruptTranslator ;
} ;

#line 17650
typedef struct _HAL_BUS_INFORMATION ;

#line 17658
typedef struct _HAL_PROFILE_SOURCE_INFORMATION ;

#line 17665
typedef struct _HAL_PROFILE_SOURCE_INTERVAL ;

#line 17671
typedef enum _HAL_DISPLAY_BIOS_INFORMATION ;

#line 17678
typedef struct _HAL_POWER_INFORMATION ;

#line 17683
typedef struct _HAL_PROCESSOR_SPEED_INFO ;

#line 17688
typedef struct _HAL_CALLBACKS ;

#line 17694
typedef struct _HAL_PROCESSOR_FEATURE ;

#line 17706
typedef union _MCI_ADDR ;

#line 17716
typedef enum  {
	HAL_MCE_RECORD,
	HAL_MCA_RECORD
} ;

#line 17726
typedef struct _MCA_EXCEPTION ;

#line 17752
typedef void ;

#line 17762
typedef struct _MCA_DRIVER_INFO ;

#line 17772
typedef struct _SCATTER_GATHER_ELEMENT ;

#line 17778

#pragma warning(disable:4200)
#line 17779
typedef struct _SCATTER_GATHER_LIST ;

#line 17784

#pragma warning(default:4200)
#line 17788
typedef struct _DMA_OPERATIONS ;

typedef struct _DMA_ADAPTER ;

#line 17797
typedef void ;

#line 17801
typedef PVOID ;

#line 17808
typedef void ;

#line 17816
typedef NTSTATUS ;

#line 17824
typedef BOOLEAN ;

#line 17833
typedef void ;

#line 17837
typedef void ;

#line 17843
typedef PHYSICAL_ADDRESS ;

#line 17852
typedef ULONG ;

#line 17856
typedef ULONG ;

#line 17860
typedef void ;

#line 17868
typedef NTSTATUS ;

#line 17880
typedef void ;

#line 17887
typedef struct _DMA_OPERATIONS ;

#line 18235
typedef void ;

#line 18321
typedef struct _OBJECT_HANDLE_INFORMATION ;

#line 18402
typedef struct _PCI_SLOT_NUMBER ;

#line 18418
typedef struct _PCI_COMMON_CONFIG ;

#line 18591
typedef struct _PCI_CAPABILITIES_HEADER ;

#line 18600
typedef struct _PCI_PMC ;

#line 18618
typedef struct _PCI_PMCSR ;

#line 18628
typedef struct _PCI_PMCSR_BSE ;

#line 18635
typedef struct _PCI_PM_CAPABILITY ;

#line 18679
typedef struct _PCI_AGP_CAPABILITY ;

#line 18720
typedef struct _PCI_MSI_CAPABILITY ;

#line 18946
typedef void ;

#line 18954
typedef void ;

#line 18963
typedef void ;

#line 18975
typedef struct _PCIBUSDATA ;

#line 18986
typedef ULONG ;

#line 18995
typedef void ;

#line 19000
typedef void ;

#line 19006
typedef struct _PCI_BUS_INTERFACE_STANDARD ;

#line 19028
typedef BOOLEAN ;

#line 19043
typedef struct _PCI_DEVICE_PRESENT_INTERFACE ;

#line 15 "../slam-kernel.c"
#line 17
extern void errorFn() ;
#line 20
extern int s ;
extern int UNLOADED , NP , DC , SKIP1 , SKIP2 , MPR1 , MPR3 , IPC ;
extern int pended ;
extern PIO_COMPLETION_ROUTINE compFptr ;
extern int compRegistered ;
extern int lowerDriverReturn ;
extern int setEventCalled ;
extern int customIrp ;
#line 29
extern void _BLAST_init() ;
#line 33
extern NTSTATUS DriverEntry(PDRIVER_OBJECT , PUNICODE_STRING ) ;
#line 37
IRP *pirp ;

void stub_driver_init()
{
	s = NP;
/*
	pended = (compFptr = (compRegistered = (lowerDriverReturn =
		(setEventCalled = (customIrp = 0)))));
*/
	pended = 0;
        compFptr = 0;
        compRegistered = 0;
        lowerDriverReturn = 0;
	setEventCalled = 0;
	customIrp = 0;
}

#line 48
int main()
{
	#line 49
	DRIVER_OBJECT d ;
	UNICODE_STRING u ;
	NTSTATUS status = 0;
	int we_should_unload ;
	IRP irp;
	pirp = &irp;
	#line 54
	_BLAST_init();
	#line 56
	status = DriverEntry(& d, & u);
	#line 58
	if((NTSTATUS )status >= 0)
	{
		#line 59
		int __BLAST_NONDET ;
		int idx ;
		int irp_choice ;
		DEVICE_OBJECT devobj ;
		#line 68
		extern NTSTATUS FloppyAddDevice(PDRIVER_OBJECT , PDEVICE_OBJECT
			) ;
		#line 71
		s = NP;
		pended = (compFptr = (compRegistered = (lowerDriverReturn =
			(setEventCalled = (customIrp = 0)))));
		#line 75
		(pirp->IoStatus).Status = (NTSTATUS )0x00000000L;
		myStatus = (NTSTATUS)0x00000000L;
		if(irp_choice == 0)
		{
			#line 77
			(pirp->IoStatus).Status = (NTSTATUS )0xC00000BBL;
			myStatus = (NTSTATUS )0xC00000BBL;
		}
		#line 80
  		status = FloppyAddDevice(& d, & devobj);
		#line 82
		stub_driver_init();
		#line 84
		if(! ((NTSTATUS )status >= 0))
			#line 84
			return - 1;
		#line 88
		switch(__BLAST_NONDET)
		{
		case 0:
				#line 90
				;
			{
				#line 91
				extern NTSTATUS FloppyCreateClose(PDEVICE_OBJECT
					, PIRP ) ;
				#line 92
				status = FloppyCreateClose(& devobj, pirp);
			}
			#line 93
			break;
			#line 96
		case 1:
				#line 96
				;
			{
				#line 97
				extern NTSTATUS FloppyCreateClose(PDEVICE_OBJECT
					, PIRP ) ;
				#line 98
				status = FloppyCreateClose(& devobj, pirp);
			}
			#line 99
			break;
			#line 102
		case 2:
				#line 102
				;
			{
				#line 103
				extern NTSTATUS
					FloppyDeviceControl(PDEVICE_OBJECT ,
					PIRP ) ;
				#line 104
				status = FloppyDeviceControl(& devobj, pirp);
			}
			#line 105
			break;
			#line 108
		case 3:
				#line 108
				;
			{
				#line 109
				extern NTSTATUS FloppyPnp(PDEVICE_OBJECT , PIRP
					) ;
				#line 110
				status = FloppyPnp(& devobj, pirp);
			}
			#line 111
			break;
			#line 114
		case 4:
				#line 114
				;
			{
				#line 115
				extern NTSTATUS FloppyPower(PDEVICE_OBJECT ,
					PIRP ) ;
				#line 116
				status = FloppyPower(& devobj, pirp);
			}
			#line 117
			break;
			#line 179
		default :
				#line 179
				;
			return - 1;
		}
		#line 185
		if(we_should_unload)
		{
			#line 186
			extern void FloppyUnload(PDRIVER_OBJECT ) ;
			FloppyUnload(& d);
		}
	}
	#line 191
	RETPT:
	{
		#line 192
		if(pended == 1 && s == NP)
		{
			#line 193
			s = NP;
		}
		else
		{
			#line 195
			if(pended == 1 && s == MPR3)
			{
				#line 196
				s = MPR3;
			}
			else
			{
				#line 198
				if(s == UNLOADED || status == - 1)
				{
					#line 199
					;
				}
				else
				{
					#line 201
					if(s != SKIP2 && s != IPC && s != DC)
						#line 201
						errorFn();
					else
					{
						#line 203
						if(pended == 1)
						{
							#line 204
							if(status != 259)
	#line 204
			status = 0;//BLAST slice			errorFn();
						}
						else
						{
							#line 206
							if(s == DC)
							{
	#line 207
	if(status == 259)
		#line 207
		errorFn();
							}
							else
							{
	#line 209
	if(status != lowerDriverReturn)
		#line 209
		errorFn();
							}
						}
					}
				}
			}
		}
	}
	#line 216
	status = 0;
	return status;
}

char _SLAM_alloc_dummy ;

char *  malloc(int i )
{
	#line 222
	return & _SLAM_alloc_dummy;
}

#line 230
__declspec(dllimport) void ExAcquireFastMutex(PFAST_MUTEX FastMutex )
{
	#line 237
	return;
}

__declspec(dllimport) void ExReleaseFastMutex(PFAST_MUTEX FastMutex )
{
	#line 247
	return;
}

#line 264
__declspec(dllimport) PVOID __stdcall ExAllocatePoolWithTag(POOL_TYPE PoolType ,
	SIZE_T NumberOfBytes , ULONG Tag )
{
	#line 273
	PVOID x ;
	x = malloc(NumberOfBytes);
	return x;
}

#line 279
__declspec(dllimport) void __stdcall ExFreePool(PVOID P )
{
	#line 285
	return;
}

__declspec(dllimport) PLIST_ENTRY ExfInterlockedInsertHeadList(PLIST_ENTRY
	ListHead , PLIST_ENTRY ListEntry , PKSPIN_LOCK Lock )
{
	#line 296
	return (void *  )0;
}

__declspec(dllimport) PLIST_ENTRY ExfInterlockedInsertTailList(PLIST_ENTRY
	ListHead , PLIST_ENTRY ListEntry , PKSPIN_LOCK Lock )
{
	#line 308
	return (void *  )0;
}

__declspec(dllimport) PLIST_ENTRY ExfInterlockedRemoveHeadList(PLIST_ENTRY
	ListHead , PKSPIN_LOCK Lock )
{
	#line 319
	return (void *  )0;
}

#line 335
__declspec(dllimport) PMDL IoAllocateMdl(PVOID VirtualAddress , ULONG Length ,
	BOOLEAN SecondaryBuffer , BOOLEAN ChargeQuota , PIRP Irp )
{
	#line 345
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 347
	case 0:
			#line 347
			;
		#line 347
		return (void *  )malloc(sizeof(MDL ));
	default :
			#line 348
			;
		#line 348
		return (void *  )0;
	}
}

__declspec(dllimport) PDEVICE_OBJECT IoAttachDeviceToDeviceStack(PDEVICE_OBJECT
	SourceDevice , PDEVICE_OBJECT TargetDevice )
{
	#line 359
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 361
	case 0:
			#line 361
			;
		#line 361
		return TargetDevice;
	default :
			#line 362
			;
		#line 362
		return (void *  )0;
	}
}

__declspec(dllimport) PIRP IoBuildAsynchronousFsdRequest(ULONG MajorFunction ,
	PDEVICE_OBJECT DeviceObject , PVOID Buffer , ULONG Length ,
	PLARGE_INTEGER StartingOffset , PIO_STATUS_BLOCK IoStatusBlock )
{
	#line 377
	int __BLAST_NONDET ;
	customIrp = 1;
	#line 380
	switch(__BLAST_NONDET)
	{
		#line 381
	case 0:
			#line 381
			;
		#line 381
		return (void *  )malloc(sizeof(IRP ));
	default :
			#line 382
			;
		#line 382
		return (void *  )0;
	}
}

#line 397
__declspec(dllimport) PIRP IoBuildDeviceIoControlRequest(ULONG IoControlCode ,
	PDEVICE_OBJECT DeviceObject , PVOID InputBuffer , ULONG
	InputBufferLength , PVOID OutputBuffer , ULONG OutputBufferLength ,
	BOOLEAN InternalDeviceIoControl , PKEVENT Event , PIO_STATUS_BLOCK
	IoStatusBlock )
{
	#line 411
	int __BLAST_NONDET ;
	customIrp = 1;
	#line 414
	switch(__BLAST_NONDET)
	{
		#line 415
	case 0:
			#line 415
			;
		#line 415
		return (void *  )malloc(sizeof(IRP ));
	default :
			#line 416
			;
		#line 416
		return (void *  )0;
	}
}

__declspec(dllimport) NTSTATUS IoCreateDevice(PDRIVER_OBJECT DriverObject ,
	ULONG DeviceExtensionSize , PUNICODE_STRING DeviceName , ULONG
	DeviceType , ULONG DeviceCharacteristics , BOOLEAN Exclusive ,
	PDEVICE_OBJECT *  DeviceObject )
{
	#line 432
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 434
	case 0:
			#line 434
			;
		#line 434
		* DeviceObject = (void *  )malloc(sizeof(DEVICE_OBJECT ));
		return (NTSTATUS )0x00000000L;
		#line 441
	default :
			#line 441
			;
		#line 441
		return (NTSTATUS )0xC0000001L;
	}
}

#line 446
__declspec(dllimport) NTSTATUS IoCreateSymbolicLink(PUNICODE_STRING
	SymbolicLinkName , PUNICODE_STRING DeviceName )
{
	#line 453
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 455
	case 0:
			#line 455
			;
		#line 455
		return (NTSTATUS )0x00000000L;
	default :
			#line 456
			;
		#line 456
		return (NTSTATUS )0xC0000001L;
	}
}

__declspec(dllimport) void IoDeleteDevice(PDEVICE_OBJECT DeviceObject )
{
}

#line 469
__declspec(dllimport) NTSTATUS IoDeleteSymbolicLink(PUNICODE_STRING
	SymbolicLinkName )
{
	#line 475
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 477
	case 0:
			#line 477
			;
		#line 477
		return (NTSTATUS )0x00000000L;
	default :
			#line 478
			;
		#line 478
		return (NTSTATUS )0xC0000001L;
	}
}

__declspec(dllimport) void IoDetachDevice(PDEVICE_OBJECT TargetDevice )
{
}

#line 491
__declspec(dllimport) void IoFreeIrp(PIRP Irp )
{
}

#line 500
__declspec(dllimport) void IoFreeMdl(PMDL Mdl )
{
}

#line 509
__declspec(dllimport) PCONFIGURATION_INFORMATION
	IoGetConfigurationInformation(void  )
{
	#line 514
	return (void *  )malloc(sizeof(CONFIGURATION_INFORMATION ));
}

__declspec(dllimport) NTSTATUS IoQueryDeviceDescription(PINTERFACE_TYPE BusType
	, PULONG BusNumber , PCONFIGURATION_TYPE ControllerType , PULONG
	ControllerNumber , PCONFIGURATION_TYPE PeripheralType , PULONG
	PeripheralNumber , PIO_QUERY_DEVICE_ROUTINE CalloutRoutine , PVOID
	Context )
{
	#line 530
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 532
	case 0:
			#line 532
			;
		#line 532
		return (NTSTATUS )0x00000000L;
	default :
			#line 533
			;
		#line 533
		return (NTSTATUS )0xC0000001L;
	}
}

__declspec(dllimport) NTSTATUS __stdcall
	IoRegisterDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject , const
	GUID *  InterfaceClassGuid , PUNICODE_STRING ReferenceString ,
	PUNICODE_STRING SymbolicLinkName )
{
	#line 547
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 549
	case 0:
			#line 549
			;
		#line 549
		return (NTSTATUS )0x00000000L;
	default :
			#line 550
			;
		#line 550
		return (NTSTATUS )0xC0000010L;
	}
}

__declspec(dllimport) void IoReleaseCancelSpinLock(KIRQL Irql )
{
}

#line 563
__declspec(dllimport) NTSTATUS IoSetDeviceInterfaceState(PUNICODE_STRING
	SymbolicLinkName , BOOLEAN Enable )
{
	#line 570
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 572
	case 0:
			#line 572
			;
		#line 572
		return (NTSTATUS )0x00000000L;
		#line 577
	default :
			#line 577
			;
		#line 577
		return (NTSTATUS )0xC0000001L;
	}
}

#line 582
__declspec(dllimport) void IoSetHardErrorOrVerifyDevice(PIRP Irp ,
	PDEVICE_OBJECT DeviceObject )
{
}

#line 595
void stubMoreProcessingRequired()
{
	#line 598
	if(s == NP)
		#line 598
		s = MPR1;
	else
		#line 599
		errorFn();
}

__declspec(dllimport) NTSTATUS IofCallDriver(PDEVICE_OBJECT DeviceObject , PIRP
	Irp )
{
	#line 610
	int __BLAST_NONDET ;
	NTSTATUS returnVal2 ;
	int compRetStatus1 ;
	PVOID lcontext ;
	#line 615
	if(compRegistered)
	{
		#line 616
/*
		compRetStatus1 = (* compFptr)(DeviceObject, Irp, lcontext);
*/
		compRetStatus1 = FloppyPnpComplete(DeviceObject, Irp, lcontext);

		if(compRetStatus1 == (NTSTATUS )0xC0000016L)
			#line 617
			stubMoreProcessingRequired();
	}
	#line 622
	switch(__BLAST_NONDET)
	{
		#line 623
	case 0:
			#line 623
			;
		#line 623
		returnVal2 = (NTSTATUS )0x00000000L;
		#line 623
		break;
		#line 625
	case 1:
			#line 625
			;
		#line 625
		returnVal2 = (NTSTATUS )0xC0000001L;
		#line 625
		break;
		#line 627
	default :
			#line 627
			;
		#line 627
		returnVal2 = (NTSTATUS )0x00000103L;
		#line 627
		break;
	}
	if(s == NP)
	{
		#line 630
		s = IPC;
		#line 630
		lowerDriverReturn = returnVal2;
	}
	else
	{
		#line 632
		if(s == MPR1)
		{
			#line 633
			if(returnVal2 == 259)
			{
				#line 634
				s = MPR3;
				#line 634
				lowerDriverReturn = returnVal2;
			}
			else
			{
				#line 636
				s = NP;
				#line 636
				lowerDriverReturn = returnVal2;
			}
		}
		else
		{
			#line 639
			if(s == SKIP1) {
				#line 639
				s = SKIP2; lowerDriverReturn = returnVal2;
			}
			else
				#line 640
				errorFn();
		}
	}
	return returnVal2;
}

#line 665
__declspec(dllimport) void IofCompleteRequest(PIRP Irp , CCHAR PriorityBoost )
{
	#line 673
	if(s == NP)
		#line 673
		s = DC;
	else
		#line 674
		errorFn();
}

__declspec(dllimport) KIRQL KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK SpinLock )
{
}

#line 686
__declspec(dllimport) NTSTATUS KeDelayExecutionThread(KPROCESSOR_MODE WaitMode ,
	BOOLEAN Alertable , PLARGE_INTEGER Interval )
{
	#line 694
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 696
	case 0:
			#line 696
			;
		#line 696
		return (NTSTATUS )0x00000000L;
		#line 701
	default :
			#line 701
			;
		#line 701
		return (NTSTATUS )0xC0000001L;
	}
}

#line 706
__declspec(dllimport) void KeInitializeEvent(PRKEVENT Event , EVENT_TYPE Type ,
	BOOLEAN State )
{
}

#line 717
__declspec(dllimport) void KeInitializeSemaphore(PRKSEMAPHORE Semaphore , LONG
	Count , LONG Limit )
{
}

#line 728
__declspec(dllimport) void __stdcall KeInitializeSpinLock(PKSPIN_LOCK SpinLock )
{
}

#line 738
__declspec(dllimport) LONG KeReleaseSemaphore(PRKSEMAPHORE Semaphore , KPRIORITY
	Increment , LONG Adjustment , BOOLEAN Wait )
{
	#line 747
	LONG r ;
	return r;
}

__declspec(dllimport) void KfReleaseSpinLock(PKSPIN_LOCK SpinLock , KIRQL
	NewIrql )
{
}

#line 762
__declspec(dllimport) LONG KeSetEvent(PRKEVENT Event , KPRIORITY Increment ,
	BOOLEAN Wait )
{
	#line 770
	LONG l ;
	#line 772
	setEventCalled = 1;
	#line 774
	return l;
}

__declspec(dllimport) NTSTATUS KeWaitForSingleObject(PVOID Object , KWAIT_REASON
	WaitReason , KPROCESSOR_MODE WaitMode , BOOLEAN Alertable ,
	PLARGE_INTEGER Timeout )
{
	#line 787
	int __BLAST_NONDET ;
	if(s == MPR3 && setEventCalled == 1)
	{
		#line 789
		s = NP;
		#line 789
		setEventCalled = 0;
	}
	else
	{
		#line 791
		if(customIrp == 1)
		{
			#line 792
			s = NP;
			#line 792
			customIrp = 0;
		}
		else
		{
			#line 794
			if(s == MPR3)
				#line 794
				errorFn();
		}
	}
	#line 798
	switch(__BLAST_NONDET)
	{
		#line 799
	case 0:
			#line 799
			;
		#line 799
		return (NTSTATUS )0x00000000L;
		#line 805
	default :
			#line 805
			;
		#line 805
		return (NTSTATUS )0xC0000001L;
	}
}

#line 810
__declspec(dllimport) PVOID MmAllocateContiguousMemory(SIZE_T NumberOfBytes ,
	PHYSICAL_ADDRESS HighestAcceptableAddress )
{
	#line 816
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 818
	case 0:
			#line 818
			;
		#line 818
		return malloc(NumberOfBytes);
	case 1:
			#line 819
			;
		#line 819
		return (void *  )0;
	}
}

__declspec(dllimport) void MmFreeContiguousMemory(PVOID BaseAddress )
{
}

#line 832
__declspec(dllimport) PVOID MmMapLockedPagesSpecifyCache(PMDL
	MemoryDescriptorList , KPROCESSOR_MODE AccessMode , MEMORY_CACHING_TYPE
	CacheType , PVOID BaseAddress , ULONG BugCheckOnFailure ,
	MM_PAGE_PRIORITY Priority )
{
	#line 843
	return (void *  )0;
}

__declspec(dllimport) PVOID MmPageEntireDriver(PVOID AddressWithinSection )
{
	#line 852
	return (void *  )0;
}

__declspec(dllimport) void MmResetDriverPaging(PVOID AddressWithinSection )
{
}

#line 865
__declspec(dllimport) void MmUnlockPages(PMDL MemoryDescriptorList )
{
}

#line 874
__declspec(dllimport) NTSTATUS ObReferenceObjectByHandle(HANDLE Handle ,
	ACCESS_MASK DesiredAccess , POBJECT_TYPE ObjectType , KPROCESSOR_MODE
	AccessMode , PVOID *  Object , POBJECT_HANDLE_INFORMATION
	HandleInformation )
{
	#line 885
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 887
	case 0:
			#line 887
			;
		#line 887
		return (NTSTATUS )0x00000000L;
		#line 893
	default :
			#line 893
			;
		#line 893
		return (NTSTATUS )0xC0000001L;
	}
}

#line 899
__declspec(dllimport) void ObfDereferenceObject(PVOID Object )
{
}

#line 909
__declspec(dllimport) NTSTATUS PoCallDriver(PDEVICE_OBJECT DeviceObject , PIRP
	Irp )
{
	#line 916
	int __BLAST_NONDET ;
	int compRetStatus ;
	NTSTATUS returnVal ;
	#line 920
	PVOID lcontext ;
	#line 922
	if(compRegistered)
	{
		#line 923
/*BLAST
		compRetStatus = (* compFptr)(DeviceObject, Irp, lcontext);
*/
		compRetStatus = FloppyPnpComplete(DeviceObject, Irp, lcontext);
		if(compRetStatus == (NTSTATUS )0xC0000016L)
			#line 924
			stubMoreProcessingRequired();
	}
	#line 929
	switch(__BLAST_NONDET)
	{
		#line 930
	case 0:
			#line 930
			;
		returnVal = (NTSTATUS )0x00000000L;
		break;
	case 1:
			#line 933
			;
		returnVal = (NTSTATUS )0xC0000001L;
		break;
	default :
			#line 936
			;
		returnVal = (NTSTATUS )0x00000103L;
		#line 937
		break;
	}
	if(s == NP)
	{
		#line 940
		s = IPC;
		#line 940
		lowerDriverReturn = returnVal;
	}
	else
	{
		#line 942
		if(s == MPR1)
		{
			#line 943
			if(returnVal == (NTSTATUS )0x00000103L)
			{
				#line 944
				s = MPR3;
				#line 944
				lowerDriverReturn = returnVal;
			}
			else
			{
				#line 946
				s = NP;
				#line 946
				lowerDriverReturn = returnVal;
			}
		}
		else
		{
			#line 949
			if(s == SKIP1) {
				#line 949
				s = SKIP2; lowerDriverReturn = returnVal;
			}
			else
				#line 950
				errorFn();
		}
	}
	return returnVal;
}

__declspec(dllimport) void PoStartNextPowerIrp(PIRP Irp )
{
}

#line 965
__declspec(dllimport) NTSTATUS PsCreateSystemThread(PHANDLE ThreadHandle , ULONG
	DesiredAccess , POBJECT_ATTRIBUTES ObjectAttributes , HANDLE
	ProcessHandle , PCLIENT_ID ClientId , PKSTART_ROUTINE StartRoutine ,
	PVOID StartContext )
{
	#line 977
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 979
	case 0:
			#line 979
			;
		#line 979
		return (NTSTATUS )0x00000000L;
	default :
			#line 980
			;
		#line 980
		return (NTSTATUS )0xC0000001L;
	}
}

__declspec(dllimport) NTSTATUS PsTerminateSystemThread(NTSTATUS ExitStatus )
{
	#line 990
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 992
	case 0:
			#line 992
			;
		#line 992
		return (NTSTATUS )0x00000000L;
	default :
			#line 993
			;
		#line 993
		return (NTSTATUS )0xC0000001L;
	}
}

#line 998
__declspec(dllimport) NTSTATUS __stdcall
	RtlAnsiStringToUnicodeString(PUNICODE_STRING DestinationString ,
	PANSI_STRING SourceString , BOOLEAN AllocateDestinationString )
{
	#line 1007
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 1009
	case 0:
			#line 1009
			;
		#line 1009
		return (NTSTATUS )0x00000000L;
	default :
			#line 1010
			;
		#line 1010
		return (NTSTATUS )0xC0000001L;
	}
}

__declspec(dllimport) SIZE_T __stdcall RtlCompareMemory(const void *  Source1 ,
	const void *  Source2 , SIZE_T Length )
{
	#line 1023
	SIZE_T r ;
	return r;
}

__declspec(dllimport) void __stdcall RtlCopyUnicodeString(PUNICODE_STRING
	DestinationString , PUNICODE_STRING SourceString )
{
}

#line 1038
__declspec(dllimport) NTSTATUS __stdcall RtlDeleteRegistryValue(ULONG RelativeTo
	, PCWSTR Path , PCWSTR ValueName )
{
	#line 1047
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 1049
	case 0:
			#line 1049
			;
		#line 1049
		return (NTSTATUS )0x00000000L;
	default :
			#line 1050
			;
		#line 1050
		return (NTSTATUS )0xC0000001L;
	}
}

__declspec(dllimport) void __stdcall RtlFreeUnicodeString(PUNICODE_STRING
	UnicodeString )
{
}

#line 1064
__declspec(dllimport) void __stdcall RtlInitString(PSTRING DestinationString ,
	PCSZ SourceString )
{
}

#line 1075
__declspec(dllimport) void __stdcall RtlInitUnicodeString(PUNICODE_STRING
	DestinationString , PCWSTR SourceString )
{
}

#line 1087
__declspec(dllimport) NTSTATUS __stdcall RtlQueryRegistryValues(ULONG RelativeTo
	, PCWSTR Path , PRTL_QUERY_REGISTRY_TABLE QueryTable , PVOID Context ,
	PVOID Environment )
{
	#line 1098
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 1100
	case 0:
			#line 1100
			;
		#line 1100
		return (NTSTATUS )0x00000000L;
		#line 1105
	default :
			#line 1105
			;
		#line 1105
		return (NTSTATUS )0xC0000001L;
	}
}

__declspec(dllimport) NTSTATUS __stdcall ZwClose(HANDLE Handle )
{
	#line 1116
	int __BLAST_NONDET ;
	switch(__BLAST_NONDET)
	{
		#line 1118
	case 0:
			#line 1118
			;
		#line 1118
		return (NTSTATUS )0x00000000L;
		#line 1124
	default :
			#line 1124
			;
		#line 1124
		return (NTSTATUS )0xC0000001L;
	}
}


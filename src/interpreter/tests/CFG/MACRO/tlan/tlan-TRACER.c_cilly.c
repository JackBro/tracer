/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */

typedef int size_t;
struct __anonstruct_spinlock_t_1 {
   unsigned int lock ;
};
typedef struct __anonstruct_spinlock_t_1 spinlock_t;
struct __anonstruct_atomic_t_2 {
   int counter ;
};
typedef struct __anonstruct_atomic_t_2 atomic_t;
typedef unsigned short umode_t;
typedef char __s8;
typedef unsigned char __u8;
typedef short __s16;
typedef unsigned short __u16;
typedef int __s32;
typedef unsigned int __u32;
typedef long long __s64;
typedef unsigned long long __u64;
typedef signed char s8;
typedef unsigned char u8;
typedef short s16;
typedef unsigned short u16;
typedef int s32;
typedef unsigned int u32;
typedef long long s64;
typedef unsigned long long u64;
typedef u32 dma_addr_t;
typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;
typedef unsigned char unchar;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;
typedef __u8 u_int8_t;
typedef __s8 int8_t;
typedef __u16 u_int16_t;
typedef __s16 int16_t;
typedef __u32 u_int32_t;
typedef __s32 int32_t;
typedef __u8 uint8_t;
typedef __u16 uint16_t;
typedef __u32 uint32_t;
typedef __u64 uint64_t;
typedef __u64 u_int64_t;
typedef __s64 int64_t;
struct tlan_adapter_entry {
   u16 vendorId ;
   u16 deviceId ;
   char *deviceLabel ;
   u32 flags ;
   u16 addrOfs ;
};
typedef struct tlan_adapter_entry TLanAdapterEntry;
struct tlan_buffer_ref_tag {
   u32 count ;
   u32 address ;
};
typedef struct tlan_buffer_ref_tag TLanBufferRef;
struct tlan_list_tag {
   u32 forward ;
   u16 cStat ;
   u16 frameSize ;
   TLanBufferRef buffer[10] ;
};
typedef struct tlan_list_tag TLanList;
struct list_head {
   struct list_head *next ;
   struct list_head *prev ;
};
struct timer_list {
   struct list_head list ;
   unsigned long expires ;
   unsigned long data ;
   void (*function)(unsigned long  ) ;
};
typedef long time_t;
typedef long suseconds_t;
struct timeval {
   time_t tv_sec ;
   suseconds_t tv_usec ;
};
struct sk_buff;
struct sk_buff_head {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   __u32 qlen ;
   spinlock_t lock ;
};
struct sock;
struct net_device;
struct tcphdr;
struct udphdr;
struct icmphdr;
struct igmphdr;
struct iphdr;
struct spxhdr;
union __anonunion_h_3 {
   struct tcphdr *th ;
   struct udphdr *uh ;
   struct icmphdr *icmph ;
   struct igmphdr *igmph ;
   struct iphdr *ipiph ;
   struct spxhdr *spxh ;
   unsigned char *raw ;
};
struct ipv6hdr;
struct arphdr;
struct ipxhdr;
union __anonunion_nh_4 {
   struct iphdr *iph ;
   struct ipv6hdr *ipv6h ;
   struct arphdr *arph ;
   struct ipxhdr *ipxh ;
   unsigned char *raw ;
};
struct ethhdr;
union __anonunion_mac_5 {
   struct ethhdr *ethernet ;
   unsigned char *raw ;
};
struct dst_entry;
struct sk_buff {
   struct sk_buff *next ;
   struct sk_buff *prev ;
   struct sk_buff_head *list ;
   struct sock *sk ;
   struct timeval stamp ;
   struct net_device *dev ;
   union __anonunion_h_3 h ;
   union __anonunion_nh_4 nh ;
   union __anonunion_mac_5 mac ;
   struct dst_entry *dst ;
   char cb[48] ;
   unsigned int len ;
   unsigned int data_len ;
   unsigned int csum ;
   unsigned char __unused ;
   unsigned char cloned ;
   unsigned char pkt_type ;
   unsigned char ip_summed ;
   __u32 priority ;
   atomic_t users ;
   unsigned short protocol ;
   unsigned short security ;
   unsigned int truesize ;
   unsigned char *head ;
   unsigned char *data ;
   unsigned char *tail ;
   unsigned char *end ;
   void (*destructor)(struct sk_buff * ) ;
};
struct net_device_stats {
   unsigned long rx_packets ;
   unsigned long tx_packets ;
   unsigned long rx_bytes ;
   unsigned long tx_bytes ;
   unsigned long rx_errors ;
   unsigned long tx_errors ;
   unsigned long rx_dropped ;
   unsigned long tx_dropped ;
   unsigned long multicast ;
   unsigned long collisions ;
   unsigned long rx_length_errors ;
   unsigned long rx_over_errors ;
   unsigned long rx_crc_errors ;
   unsigned long rx_frame_errors ;
   unsigned long rx_fifo_errors ;
   unsigned long rx_missed_errors ;
   unsigned long tx_aborted_errors ;
   unsigned long tx_carrier_errors ;
   unsigned long tx_fifo_errors ;
   unsigned long tx_heartbeat_errors ;
   unsigned long tx_window_errors ;
   unsigned long rx_compressed ;
   unsigned long tx_compressed ;
};
struct board {
   char *deviceLabel ;
   u32 flags ;
   u16 addrOfs ;
};
typedef u8 TLanBuffer[1600];
struct tq_struct {
   struct list_head list ;
   unsigned long sync ;
   void (*routine)(void * ) ;
   void *data ;
};
struct dev_mc_list {
   struct dev_mc_list *next ;
   __u8 dmi_addr[8] ;
   unsigned char dmi_addrlen ;
   int dmi_users ;
   int dmi_gusers ;
};
struct Qdisc;
struct module;
struct net_bridge_port;
struct net_device {
   char name[16] ;
   unsigned long rmem_end ;
   unsigned long rmem_start ;
   unsigned long mem_end ;
   unsigned long mem_start ;
   unsigned long base_addr ;
   unsigned int irq ;
   unsigned char if_port ;
   unsigned char dma ;
   unsigned long state ;
   struct net_device *next ;
   struct net_device *next_sched ;
   int ifindex ;
   int iflink ;
   unsigned long trans_start ;
   unsigned long last_rx ;
   unsigned short flags ;
   unsigned short gflags ;
   unsigned int mtu ;
   unsigned short type ;
   unsigned short hard_header_len ;
   void *priv ;
   struct net_device *master ;
   unsigned char broadcast[8] ;
   unsigned char dev_addr[8] ;
   unsigned char addr_len ;
   struct dev_mc_list *mc_list ;
   int mc_count ;
   int promiscuity ;
   int allmulti ;
   int watchdog_timeo ;
   struct timer_list watchdog_timer ;
   void *atalk_ptr ;
   void *ip_ptr ;
   void *dn_ptr ;
   void *ip6_ptr ;
   void *ec_ptr ;
   struct Qdisc *qdisc ;
   struct Qdisc *qdisc_sleeping ;
   struct Qdisc *qdisc_list ;
   struct Qdisc *qdisc_ingress ;
   unsigned long tx_queue_len ;
   spinlock_t xmit_lock ;
   int xmit_lock_owner ;
   spinlock_t queue_lock ;
   atomic_t refcnt ;
   int deadbeaf ;
   int features ;
   struct module *owner ;
   struct net_bridge_port *br_port ;
};
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct pt_regs {
   long ebx ;
   long ecx ;
   long edx ;
   long esi ;
   long edi ;
   long ebp ;
   long eax ;
   int xds ;
   int xes ;
   long orig_eax ;
   long eip ;
   int xcs ;
   long eflags ;
   long esp ;
   int xss ;
};
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
union __anonunion_ifr_ifrn_6 {
   char ifrn_name[16] ;
};
union __anonunion_ifr_ifru_7 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   char *ifru_data ;
};
struct ifreq {
   union __anonunion_ifr_ifrn_6 ifr_ifrn ;
   union __anonunion_ifr_ifru_7 ifr_ifru ;
};
typedef struct list_head task_queue;
enum __anonenum_8 {
    TIMER_BH = 0,
    TQUEUE_BH = 1,
    DIGI_BH = 2,
    SERIAL_BH = 3,
    RISCOM8_BH = 4,
    SPECIALIX_BH = 5,
    AURORA_BH = 6,
    ESP_BH = 7,
    SCSI_BH = 8,
    IMMEDIATE_BH = 9,
    CYCLADES_BH = 10,
    CM206_BH = 11,
    JS_BH = 12,
    MACSERIAL_BH = 13,
    ISICOM_BH = 14
} ;
struct tlan_private_tag {
   struct net_device *nextDevice ;
   void *dmaStorage ;
   u8 *padBuffer ;
   TLanList *rxList ;
   u8 *rxBuffer ;
   u32 rxHead ;
   u32 rxTail ;
   u32 rxEocCount ;
   TLanList *txList ;
   u8 *txBuffer ;
   u32 txHead ;
   u32 txInProgress ;
   u32 txTail ;
   u32 txBusyCount ;
   u32 phyOnline ;
   u32 timerSetAt ;
   u32 timerType ;
   struct timer_list timer ;
   struct net_device_stats stats ;
   struct board *adapter ;
   u32 adapterRev ;
   u32 aui ;
   u32 debug ;
   u32 duplex ;
   u32 phy[2] ;
   u32 phyNum ;
   u32 speed ;
   u8 tlanRev ;
   u8 tlanFullDuplex ;
   char devName[8] ;
   spinlock_t lock ;
   u8 link ;
   u8 is_eisa ;
   struct tq_struct tlan_tqueue ;
   u8 neg_be_verbose ;
};
typedef struct tlan_private_tag TLanPrivateInfo;
typedef int (*__init_module_func_t)(void);
typedef void (*__cleanup_module_func_t)(void);
struct resource {
   char *name ;
   unsigned long start ;
   unsigned long end ;
   unsigned long flags ;
   struct resource *parent ;
   struct resource *sibling ;
   struct resource *child ;
};
struct pci_dev;
struct resource_list {
   struct resource_list *next ;
   struct resource *res ;
   struct pci_dev *dev ;
};
enum pci_mmap_state {
    pci_mmap_io = 0,
    pci_mmap_mem = 1
} ;
struct pci_bus;
struct proc_dir_entry;
struct pci_driver;
struct pci_dev {
   struct list_head global_list ;
   struct list_head bus_list ;
   struct pci_bus *bus ;
   struct pci_bus *subordinate ;
   void *sysdata ;
   struct proc_dir_entry *procent ;
   unsigned int devfn ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned short subsystem_vendor ;
   unsigned short subsystem_device ;
   unsigned int class ;
   u8 hdr_type ;
   u8 rom_base_reg ;
   struct pci_driver *driver ;
   void *driver_data ;
   dma_addr_t dma_mask ;
   u32 current_state ;
   unsigned short vendor_compatible[4] ;
   unsigned short device_compatible[4] ;
   unsigned int irq ;
   struct resource resource[12] ;
   struct resource dma_resource[2] ;
   struct resource irq_resource[2] ;
   char name[80] ;
   char slot_name[8] ;
   int active ;
   int ro ;
   unsigned short regs ;
};
struct pci_ops;
struct pci_bus {
   struct list_head node ;
   struct pci_bus *parent ;
   struct list_head children ;
   struct list_head devices ;
   struct pci_dev *self ;
   struct resource *resource[4] ;
   struct pci_ops *ops ;
   void *sysdata ;
   struct proc_dir_entry *procdir ;
   unsigned char number ;
   unsigned char primary ;
   unsigned char secondary ;
   unsigned char subordinate ;
   char name[48] ;
   unsigned short vendor ;
   unsigned short device ;
   unsigned int serial ;
   unsigned char pnpver ;
   unsigned char productver ;
   unsigned char checksum ;
   unsigned char pad1 ;
};
struct pci_ops {
   int read_byte ;
   int read_word ;
   int read_dword ;
   int write_byte ;
   int write_word ;
   int write_dword ;
};
struct pbus_set_ranges_data {
   int found_vga ;
   unsigned long io_start ;
   unsigned long io_end ;
   unsigned long mem_start ;
   unsigned long mem_end ;
};
struct pci_device_id {
   unsigned int vendor ;
   unsigned int device ;
   unsigned int subvendor ;
   unsigned int subdevice ;
   unsigned int class ;
   unsigned int class_mask ;
   unsigned long driver_data ;
};
struct pci_driver {
   struct list_head node ;
   char *name ;
   struct pci_device_id *id_table ;
};
struct scatterlist {
   char *address ;
   char *alt_address ;
   unsigned int length ;
};
struct pci_dev;
struct mii_ioctl_data {
   u16 phy_id ;
   u16 reg_num ;
   u16 val_in ;
   u16 val_out ;
};
typedef u32 TLanIntVectorFunc(struct net_device * , u16  );
/* compiler builtin: 
   void __builtin_varargs_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned int  , unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_exp(double  ) ;  */
/* compiler builtin: 
   long double __builtin_nanl(char const   * ) ;  */
/* compiler builtin: 
   double __builtin_cos(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   float __builtin_atan2f(float  , float  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned int  , unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_asin(double  ) ;  */
/* compiler builtin: 
   int __builtin_ctz(unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin_stpcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpckhps(float __attribute__((____vector_size____(16)))   , float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   double __builtin_nans(char const   * ) ;  */
/* compiler builtin: 
   long double __builtin_atan2l(long double  , long double  ) ;  */
/* compiler builtin: 
   float __builtin_logf(float  ) ;  */
/* compiler builtin: 
   int __builtin___fprintf_chk(void * , int  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned int  , unsigned int  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_subps(float __attribute__((____vector_size____(16)))   , float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   float __builtin_log10f(float  ) ;  */
/* compiler builtin: 
   double __builtin_atan(double  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned int  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_strncmp(char const   * , char const   * , unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_sin(double  ) ;  */
/* compiler builtin: 
   long double __builtin_logl(long double  ) ;  */
/* compiler builtin: 
   float __builtin_coshf(float  ) ;  */
/* compiler builtin: 
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned int  , unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned int  ) ;  */
/* compiler builtin: 
   float __builtin_nansf(char const   * ) ;  */
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_sinhf(float  ) ;  */
/* compiler builtin: 
   long double __builtin_log10l(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_coshl(long double  ) ;  */
/* compiler builtin: 
   unsigned int __builtin_strlen(char const   * ) ;  */
/* compiler builtin: 
   int __builtin_ffs(unsigned int  ) ;  */
/* compiler builtin: 
   float __builtin_asinf(float  ) ;  */
/* compiler builtin: 
   long double __builtin_nansl(char const   * ) ;  */
/* compiler builtin: 
   double __builtin_frexp(double  , int * ) ;  */
/* compiler builtin: 
   double __builtin_tan(double  ) ;  */
/* compiler builtin: 
   long double __builtin_sinhl(long double  ) ;  */
/* compiler builtin: 
   float __builtin_frexpf(float  , int * ) ;  */
/* compiler builtin: 
   long double __builtin_asinl(long double  ) ;  */
/* compiler builtin: 
   void *__builtin_frame_address(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_floor(double  ) ;  */
/* compiler builtin: 
   float __builtin_tanhf(float  ) ;  */
/* compiler builtin: 
   int __builtin_parityl(unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_clzl(unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_powi(double  , int  ) ;  */
/* compiler builtin: 
   long double __builtin_frexpl(long double  , int * ) ;  */
/* compiler builtin: 
   float __builtin_atanf(float  ) ;  */
/* compiler builtin: 
   float __builtin_huge_valf(void) ;  */
/* compiler builtin: 
   float __builtin_sqrtf(float  ) ;  */
/* compiler builtin: 
   float __builtin_fmodf(float  ) ;  */
/* compiler builtin: 
   unsigned int __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned int  , void * ) ;  */
/* compiler builtin: 
   void __builtin_stdarg_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_mulps(float __attribute__((____vector_size____(16)))   , float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   long double __builtin_tanhl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_nan(char const   * ) ;  */
/* compiler builtin: 
   void __builtin_return(void const   * ) ;  */
/* compiler builtin: 
   long double __builtin_atanl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_huge_vall(void) ;  */
/* compiler builtin: 
   float __builtin_inff(void) ;  */
/* compiler builtin: 
   long double __builtin_sqrtl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_fmodl(long double  ) ;  */
/* compiler builtin: 
   int __builtin___printf_chk(int  , char const   *  , ...) ;  */
/* compiler builtin: 
   float __builtin_floorf(float  ) ;  */
/* compiler builtin: 
   float __builtin_fabsf(float  ) ;  */
/* compiler builtin: 
   int __builtin_popcountll(unsigned long long  ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned int  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vprintf_chk(int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_maxps(float __attribute__((____vector_size____(16)))   , float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned int  , int  , unsigned int  , char const   *  , ...) ;  */
/* compiler builtin: 
   long double __builtin_infl(void) ;  */
/* compiler builtin: 
   void *__builtin_mempcpy(void * , void const   * , unsigned int  ) ;  */
/* compiler builtin: 
   long double __builtin_floorl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_ctzl(unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_fabsl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_fabs(double  ) ;  */
/* compiler builtin: 
   int __builtin_popcount(unsigned int  ) ;  */
/* compiler builtin: 
   void __builtin_bcopy(void const   * , void * , unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_ceil(double  ) ;  */
/* compiler builtin: 
   double __builtin_ldexp(double  , int  ) ;  */
/* compiler builtin: 
   float __builtin_sinf(float  ) ;  */
/* compiler builtin: 
   float __builtin_acosf(float  ) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned int  , int  , unsigned int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   double __builtin_sinh(double  ) ;  */
/* compiler builtin: 
   int __builtin_ffsll(unsigned long long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_inf(void) ;  */
/* compiler builtin: 
   void __builtin_prefetch(void const   *  , ...) ;  */
/* compiler builtin: 
   long double __builtin_sinl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_acosl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_sqrt(double  ) ;  */
/* compiler builtin: 
   double __builtin_fmod(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   float __builtin_ceilf(float  ) ;  */
/* compiler builtin: 
   void *__builtin_return_address(unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned int  ) ;  */
/* compiler builtin: 
   float __builtin_tanf(float  ) ;  */
/* compiler builtin: 
   int __builtin_parityll(unsigned long long  ) ;  */
/* compiler builtin: 
   float __builtin_ldexpf(float  , int  ) ;  */
/* compiler builtin: 
   int __builtin_types_compatible_p(unsigned int  , unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_log10(double  ) ;  */
/* compiler builtin: 
   float __builtin_expf(float  ) ;  */
/* compiler builtin: 
   int __builtin_clzll(unsigned long long  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpcklps(float __attribute__((____vector_size____(16)))   , float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   double __builtin_tanh(double  ) ;  */
/* compiler builtin: 
   int __builtin_constant_p(int c ) ;  */
/* compiler builtin: 
   long double __builtin_ceill(long double  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
/* compiler builtin: 
   void *__builtin_apply(void (*)() , void * , unsigned int  ) ;  */
/* compiler builtin: 
   long double __builtin_tanl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_log(double  ) ;  */
/* compiler builtin: 
   long double __builtin_ldexpl(long double  , int  ) ;  */
/* compiler builtin: 
   int __builtin_popcountl(unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_expl(long double  ) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned int  , unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned int  , unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_huge_val(void) ;  */
/* compiler builtin: 
   __builtin_va_list __builtin_next_arg(void) ;  */
/* compiler builtin: 
   void *__builtin_apply_args(void) ;  */
/* compiler builtin: 
   float __builtin_powif(float  , int  ) ;  */
/* compiler builtin: 
   int __builtin___vfprintf_chk(void * , int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_modff(float  , float * ) ;  */
/* compiler builtin: 
   double __builtin_atan2(double  , double  ) ;  */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned int  ) ;  */
/* compiler builtin: 
   long double __builtin_powil(long double  , int  ) ;  */
/* compiler builtin: 
   float __builtin_cosf(float  ) ;  */
/* compiler builtin: 
   void __builtin_bzero(void * , unsigned int  ) ;  */
/* compiler builtin: 
   unsigned int __builtin_strspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   long double __builtin_modfl(long double  , long double * ) ;  */
/* compiler builtin: 
   int __builtin_parity(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_cosh(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strncat(char * , char const   * , unsigned int  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   double __builtin_acos(double  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_addps(float __attribute__((____vector_size____(16)))   , float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   long double __builtin_cosl(long double  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_ctzll(unsigned long long  ) ;  */
/* compiler builtin: 
   unsigned int __builtin_strcspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   int __builtin_ffsl(unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_nanf(char const   * ) ;  */
extern unsigned char inb(unsigned short port ) ;
extern unsigned char inb_p(unsigned short port ) ;
extern unsigned short inw(unsigned short port ) ;
extern unsigned short inw_p(unsigned short port ) ;
extern unsigned int inl(unsigned short port ) ;
extern unsigned int inl_p(unsigned short port ) ;
extern void *memcpy(void *to , void const   *from , size_t n ) ;
extern void outb(unsigned char value , unsigned short port ) ;
extern void outb_p(unsigned char value , unsigned short port ) ;
extern void outw(unsigned short value , unsigned short port ) ;
extern void outw_p(unsigned short value , unsigned short port ) ;
extern void outl(unsigned int value , unsigned short port ) ;
extern void outl_p(unsigned int value , unsigned short port ) ;
extern void insb(unsigned short port , void *addr , unsigned long count ) ;
extern void insw(unsigned short port , void *addr , unsigned long count ) ;
extern void insl(unsigned short port , void *addr , unsigned long count ) ;
extern void outsb(unsigned short port , void *addr , unsigned long count ) ;
extern void outsw(unsigned short port , void *addr , unsigned long count ) ;
extern void outsl(unsigned short port , void *addr , unsigned long count ) ;
unsigned long jiffies_Rsmp_0da02d67  ;
struct board board_info[]  ;
task_queue tq_immediate_Rsmp_0da0dcd1  ;
void netif_start_queue(struct net_device *dev ) 
{ 

  {
  return;
}
}
int netif_rx_Rsmp_4eecbd7e(struct sk_buff *skb ) 
{ int x ;

  {
  return (x);
}
}
void netif_stop_queue(struct net_device *dev ) 
{ 

  {
  return;
}
}
void netif_wake_queue(struct net_device *dev ) 
{ 

  {
  return;
}
}
int netif_queue_stopped(struct net_device *dev ) 
{ int res_ ;

  {
  return (res_);
}
}
unsigned long virt_to_phys(void *address ) 
{ 

  {
  return ((unsigned long )address - 3221225472UL);
}
}
int queue_task(struct tq_struct *bh_pointer , task_queue *bh_list ) 
{ int x ;

  {
  return (x);
}
}
void mark_bh(int nr ) 
{ 

  {
  return;
}
}
u8 TLan_DioRead8(u16 base_addr , u16 internal_addr ) 
{ u16 temp_1 ;
  u16 temp_2 ;
  unsigned char temp_3 ;

  {
  temp_1 = (unsigned short )((int )base_addr + 8);
  outw(internal_addr, temp_1);
  temp_2 = (unsigned short )(((int )base_addr + 12) + ((int )internal_addr & 3));
  temp_3 = inb(temp_2);
  return (temp_3);
}
}
u16 TLan_DioRead16(u16 base_addr , u16 internal_addr ) 
{ u16 temp_1 ;
  u16 temp_2 ;
  unsigned short temp_3 ;

  {
  temp_1 = (unsigned short )((int )base_addr + 8);
  outw(internal_addr, temp_1);
  temp_2 = (unsigned short )(((int )base_addr + 12) + ((int )internal_addr & 2));
  temp_3 = inw(temp_2);
  return (temp_3);
}
}
u32 TLan_DioRead32(u16 base_addr , u16 internal_addr ) 
{ u16 temp_1 ;
  u16 temp_2 ;
  unsigned int temp_3 ;

  {
  temp_1 = (unsigned short )((int )base_addr + 8);
  outw(internal_addr, temp_1);
  temp_2 = (unsigned short )((int )base_addr + 12);
  temp_3 = inl(temp_2);
  return (temp_3);
}
}
void TLan_DioWrite8(u16 base_addr , u16 internal_addr , u8 data ) 
{ u16 temp_1 ;
  u16 temp_2 ;

  {
  temp_1 = (unsigned short )((int )base_addr + 8);
  outw(internal_addr, temp_1);
  temp_2 = (unsigned short )(((int )base_addr + 12) + ((int )internal_addr & 3));
  return;
}
}
void TLan_DioWrite16(u16 base_addr , u16 internal_addr , u16 data ) 
{ u16 temp_1 ;
  u16 temp_2 ;

  {
  temp_1 = (unsigned short )((int )base_addr + 8);
  outw(internal_addr, temp_1);
  temp_2 = (unsigned short )(((int )base_addr + 12) + ((int )internal_addr & 2));
  outw(data, temp_2);
  return;
}
}
void TLan_DioWrite32(u16 base_addr , u16 internal_addr , u32 data ) 
{ u16 temp_1 ;
  u16 temp_2 ;

  {
  temp_1 = (unsigned short )((int )base_addr + 8);
  outw(internal_addr, temp_1);
  temp_2 = (unsigned short )(((int )base_addr + 12) + ((int )internal_addr & 2));
  return;
}
}
int capable(int cap ) 
{ int NONDET ;
  int res_ ;

  {
  switch (NONDET) {
  case 0: 
  res_ = 0;
  break;
  default: 
  res_ = 1;
  break;
  }
  return (res_);
}
}
u32 xor(u32 a , u32 b ) 
{ int tmp ;

  {
  if (a) {
    if (! b) {
      tmp = 1;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    if (! a) {
      if (b) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    } else {
      tmp = 0;
    }
  }
  return ((unsigned int )tmp);
}
}
u32 TLan_HashFunc(u8 *a ) 
{ u32 hash ;

  {
  return (hash);
}
}
struct resource ioport_resource_Rsmp_865ebccd  ;
struct resource iomem_resource_Rsmp_9efed5af  ;
struct resource *__request_region_Rsmp_1a1a4f09(struct resource *reso , unsigned long start , unsigned long n , char *name ) 
{ struct resource *res ;

  {
  return (res);
}
}
void __release_region_Rsmp_d49501d4(struct resource *reso , unsigned long p1 , unsigned long p2 ) 
{ 

  {
  return;
}
}
struct list_head pci_root_buses_Rsmp_082c3213  ;
struct list_head pci_devices_Rsmp_7a84b102  ;
int pci_read_config_byte_Rsmp_e426c0e8(struct pci_dev *dev , int where , u8 *val ) 
{ int res__ ;

  {
  return (res__);
}
}
int pci_enable_device_Rsmp_d04fea08(struct pci_dev *dev ) 
{ int res__ ;

  {
  return (res__);
}
}
void pci_set_master_Rsmp_2d0760ae(struct pci_dev *dev ) 
{ 

  {
  return;
}
}
int pci_register_driver_Rsmp_de7b2751(struct pci_driver *dev ) 
{ int res__ ;

  {
  return (res__);
}
}
void pci_unregister_driver_Rsmp_836ea211(struct pci_driver *dev ) 
{ 

  {
  return;
}
}
unsigned long pci_mem_start_Rsmp_3da171f9  ;
static int pci_module_init(struct pci_driver *drv ) 
{ int rc ;

  {
  rc = pci_register_driver_Rsmp_de7b2751(drv);
  if (rc > 0) {
    return (0);
  }
  if (rc == 0) {
    rc = -19;
  }
  pci_unregister_driver_Rsmp_836ea211(drv);
  return (rc);
}
}
static void *pci_get_drvdata(struct pci_dev *pdev ) 
{ 

  {
  return (pdev->driver_data);
}
}
static void pci_set_drvdata(struct pci_dev *pdev , void *data ) 
{ 

  {
  pdev->driver_data = data;
  return;
}
}
int pci_pci_problems_Rsmp_dc14eda7  ;
unsigned short eth_type_trans_Rsmp_ef9f8c35(struct sk_buff *skb , struct net_device *dev ) 
{ unsigned short res__ ;

  {
  return (res__);
}
}
unsigned long loops_per_jiffy_Rsmp_ba497f13  ;
char tlan_banner[]  ;
int printk_Rsmp_1b7d4074(char const   *fmt  , ...) 
{ int res__ ;

  {
  return (res__);
}
}
struct net_device *init_etherdev_Rsmp_5ef105a6(struct net_device *dev , int sizeof_priv ) 
{ struct net_device *res__ ;

  {
  return (res__);
}
}
int mod_timer_Rsmp_1f13d309(struct timer_list *timer , unsigned long expires ) 
{ int res__ ;

  {
  return (res__);
}
}
void udelay(unsigned long usecs ) 
{ 

  {
  return;
}
}
void add_timer_Rsmp_a19eacf8(struct timer_list *timer ) 
{ 

  {
  return;
}
}
int del_timer_sync_Rsmp_daff266a(struct timer_list *timer ) 
{ int x ;

  {
  return (x);
}
}
void unregister_netdev_Rsmp_99639e9a(struct net_device *dev ) 
{ 

  {
  return;
}
}
void kfree_Rsmp_037a0cba(void const   *p ) 
{ 

  {
  return;
}
}
void dev_kfree_skb_irq(struct sk_buff *skb ) 
{ 

  {
  return;
}
}
void dev_kfree_skb_any(struct sk_buff *skb ) 
{ 

  {
  return;
}
}
void *kmalloc_Rsmp_93d4cfe6(size_t ss , int pp ) 
{ int x ;

  {
  return ((void *)x);
}
}
int request_irq_Rsmp_0c60f2e0(unsigned int aa , void (*handler)(int  , void * , struct pt_regs * ) , unsigned long cc , char const   *dd , void *ee ) 
{ int res_ ;

  {
  return (res_);
}
}
void free_irq_Rsmp_f20dabd8(unsigned int aa , void *bb ) 
{ 

  {
  return;
}
}
void spin_lock(spinlock_t *lock ) 
{ 

  {
  return;
}
}
void spin_unlock(spinlock_t *lock ) 
{ 

  {
  return;
}
}
struct sk_buff *dev_alloc_skb(unsigned int length ) 
{ struct sk_buff *res__ ;

  {
  return (res__);
}
}
void skb_reserve(struct sk_buff *skb , unsigned int len ) 
{ 

  {
  skb->data = skb->data + len;
  skb->tail = skb->tail + len;
  return;
}
}
unsigned char *skb_put(struct sk_buff *skb , unsigned int len ) 
{ unsigned char *res__ ;

  {
  return (res__);
}
}
void skb_trim(struct sk_buff *skb , unsigned int len ) 
{ 

  {
  return;
}
}
int in_irq  ;
int BLAST_NONDET  ;
int lockStatus  ;
void _BLAST_init(void) 
{ 

  {
  lockStatus = 0;
  if (BLAST_NONDET) {
    in_irq = 1;
  } else {
    in_irq = 0;
  }
  return;
}
}
void spin_lock_irqsave(void *a , void *b ) 
{ 

  {
  lockStatus = 1;
  return;
}
}
void spin_unlock_irqrestore(void *a , void *b ) 
{ 

  {
  lockStatus = 0;
  return;
}
}
static struct net_device *TLan_Eisa_Devices  ;
static int TLanDevicesInstalled  ;
static int aui[8]  ;
static int duplex[8]  ;
static int speed[8]  ;
static int boards_found  ;
static int debug  ;
static int bbuf  ;
static u8 *TLanPadBuffer  ;
char TLanSignature[]  ;
static int tlan_have_pci  ;
static int tlan_have_eisa  ;
char *media[]  ;
int media_map[]  ;
static struct pci_device_id tlan_pci_tbl[]  ;
static int TLan_Init(struct net_device *dev ) ;
static int TLan_Open(struct net_device *dev ) ;
static void TLan_EisaProbe(void) ;
static void TLan_Eisa_Cleanup(void) ;
static int TLan_StartTx(struct sk_buff *skb , struct net_device *dev ) ;
static int TLan_ioctl(struct net_device *dev , struct ifreq *rq , int cmd ) ;
static struct net_device_stats *TLan_GetStats(struct net_device *dev ) ;
static int TLan_Close(struct net_device *dev ) ;
static void TLan_HandleInterrupt(int irq , void *dev_id , struct pt_regs *regs ) ;
static int TLan_probe1(struct pci_dev *pdev , long ioaddr , int irq , int rev , struct pci_device_id *ent ) ;
static void TLan_tx_timeout(struct net_device *dev ) ;
static int tlan_init_one(struct pci_dev *pdev , struct pci_device_id *ent ) ;
static void TLan_ResetLists(struct net_device *dev ) ;
static void TLan_ResetAdapter(struct net_device *dev ) ;
static void TLan_ReadAndClearStats(struct net_device *dev , int record ) ;
static int TLan_MiiReadReg(struct net_device *dev , u16 phy , u16 reg , u16 *val ) ;
static void TLan_MiiWriteReg(struct net_device *dev , u16 phy , u16 reg , u16 val ) ;
static void TLan_FreeLists(struct net_device *dev ) ;
static void TLan_PrintList(TLanList *list , char *type , int num ) ;
static void TLan_PrintDio(u16 io_base ) ;
static void TLan_PhyPrint(struct net_device *dev ) ;
static void TLan_SetMulticastList(struct net_device *dev ) ;
static u32 TLan_HandleInvalid(struct net_device *dev , u16 host_int ) ;
static u32 TLan_HandleTxEOF(struct net_device *dev , u16 host_int ) ;
static u32 TLan_HandleStatOverflow(struct net_device *dev , u16 host_int ) ;
static u32 TLan_HandleRxEOF(struct net_device *dev , u16 host_int ) ;
static u32 TLan_HandleDummy(struct net_device *dev , u16 host_int ) ;
static u32 TLan_HandleTxEOC(struct net_device *dev , u16 host_int ) ;
static u32 TLan_HandleStatusCheck(struct net_device *dev , u16 host_int ) ;
static u32 TLan_HandleRxEOC(struct net_device *dev , u16 host_int ) ;
static void TLan_Timer(unsigned long data ) ;
static void TLan_FinishReset(struct net_device *dev ) ;
static void TLan_SetMac(struct net_device *dev , int areg , char *mac ) ;
static void TLan_PhyDetect(struct net_device *dev ) ;
static void TLan_PhyPowerDown(struct net_device *dev ) ;
static void TLan_PhyPowerUp(struct net_device *dev ) ;
static void TLan_PhyReset(struct net_device *dev ) ;
static void TLan_PhyStartLink(struct net_device *dev ) ;
static void TLan_PhyFinishAutoNeg(struct net_device *dev ) ;
static void TLan_MiiSendData(u16 base_port , u32 data , unsigned int num_bits ) ;
static void TLan_MiiSync(u16 base_port ) ;
static void TLan_EeSendStart(u16 io_base ) ;
static int TLan_EeSendByte(u16 io_base , u8 data , int stop ) ;
static void TLan_EeReceiveByte(u16 io_base , u8 *data , int stop ) ;
static int TLan_EeReadByte(struct net_device *dev , u8 ee_addr , u8 *data ) ;
static TLanIntVectorFunc *TLanIntVector[8]  ;
static void TLan_SetTimer(struct net_device *dev , u32 ticks , u32 type ) 
{ register TLanPrivateInfo *priv ;
  register unsigned long flags ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  flags = 0UL;
  if (! in_irq) {
    spin_lock_irqsave((void *)(& priv->lock), (void *)flags);
  }
  if ((unsigned int )priv->timer.function != (unsigned int )((void *)0)) {
    if (priv->timerType != 2U) {
      if (! in_irq) {
        spin_unlock_irqrestore((void *)(& priv->lock), (void *)flags);
      }
      return;
    }
  }
  if (! in_irq) {
    spin_unlock_irqrestore((void *)(& priv->lock), (void *)flags);
  }
  priv->timer.data = (unsigned long )dev;
  priv->timerSetAt = (unsigned int )jiffies_Rsmp_0da02d67;
  priv->timerType = type;
  mod_timer_Rsmp_1f13d309(& priv->timer, jiffies_Rsmp_0da02d67 + (unsigned long )ticks);
  return;
}
}
static void tlan_remove_one(struct pci_dev *pdev ) 
{ register struct net_device *dev ;
  register TLanPrivateInfo *priv ;
  void *tmp ;

  {
  tmp = pci_get_drvdata(pdev);
  dev = (struct net_device *)tmp;
  priv = (TLanPrivateInfo *)dev->priv;
  unregister_netdev_Rsmp_99639e9a(dev);
  if (priv->dmaStorage) {
    kfree_Rsmp_037a0cba((void const   *)priv->dmaStorage);
  }
  __release_region_Rsmp_d49501d4(& ioport_resource_Rsmp_865ebccd, dev->base_addr, 16UL);
  kfree_Rsmp_037a0cba((void const   *)dev);
  pci_set_drvdata(pdev, (void *)0);
  return;
}
}
static struct pci_driver tlan_driver  ;
void *__constant_c_and_count_memset(void *s , unsigned long pattern , size_t count ) 
{ 

  {
  return ((void *)0);
}
}
void *__constant_c_memset(void *s , unsigned long c , size_t count ) 
{ 

  {
  return ((void *)0);
}
}
void *__memset_generic(void *s , char c , size_t count ) 
{ 

  {
  return ((void *)0);
}
}
int __builtin_constant_p(int c ) 
{ int res__ ;

  {
  return (res__);
}
}
void init_timer(struct timer_list *timer ) 
{ 

  {
  return;
}
}
static int tlan_probe(void) 
{ register int pad_allocated ;
  register int temp_1 ;
  register int temp_2 ;
  register int temp_3 ;
  register int temp_4 ;
  void *tmp ;
  char const   *tmp___0 ;

  {
  printk_Rsmp_1b7d4074("<6>%s", tlan_banner);
  tmp = kmalloc_Rsmp_93d4cfe6(64, 240);
  TLanPadBuffer = (u8 *)tmp;
  if ((unsigned int )TLanPadBuffer == (unsigned int )((void *)0)) {
    printk_Rsmp_1b7d4074("<3>TLAN: Could not allocate memory for pad buffer.\n");
    return (-12);
  }
  temp_1 = 1;
  if (temp_1) {
    temp_2 = 1;
    if (temp_2) {
      __constant_c_and_count_memset((void *)TLanPadBuffer, 0UL, 64);
    } else {
      __constant_c_memset((void *)TLanPadBuffer, 0UL, 64);
    }
  } else {
    temp_3 = 1;
    if (temp_3) {
      __memset_generic((void *)TLanPadBuffer, (char)0, 64);
    } else {
      __memset_generic((void *)TLanPadBuffer, (char)0, 64);
    }
  }
  pad_allocated = 1;
  if (debug & 16) {
    printk_Rsmp_1b7d4074("<7>TLAN: Starting PCI Probe....\n");
  }
  pci_module_init(& tlan_driver);
  if (debug & 16) {
    printk_Rsmp_1b7d4074("<7>TLAN: Starting EISA Probe....\n");
  }
  TLan_EisaProbe();
  if (TLanDevicesInstalled == 1) {
    tmp___0 = "";
  } else {
    tmp___0 = "s";
  }
  printk_Rsmp_1b7d4074("<6>TLAN: %d device%s installed, PCI: %d  EISA: %d\n", TLanDevicesInstalled, tmp___0, tlan_have_pci, tlan_have_eisa);
  if (TLanDevicesInstalled == 0) {
    kfree_Rsmp_037a0cba((void const   *)TLanPadBuffer);
    return (-19);
  }
  return (0);
}
}
static int tlan_init_one(struct pci_dev *pdev , struct pci_device_id *ent ) 
{ int tmp ;

  {
  tmp = TLan_probe1(pdev, -1L, -1, 0, ent);
  return (tmp);
}
}
static int TLan_probe1(struct pci_dev *pdev , long ioaddr , int irq , int rev , struct pci_device_id *ent ) 
{ register struct net_device *dev ;
  register TLanPrivateInfo *priv ;
  u8 pci_rev ;
  register u16 device_id ;
  register int reg ;
  register u32 pci_io_base ;
  register int temp_1 ;
  register int temp_2 ;

  {
  temp_1 = pci_enable_device_Rsmp_d04fea08(pdev);
  if (pdev) {
    if (temp_1) {
      return (-5);
    }
  }
  dev = init_etherdev_Rsmp_5ef105a6((struct net_device *)((void *)0), (int )sizeof(TLanPrivateInfo ));
  if ((unsigned int )dev == (unsigned int )((void *)0)) {
    printk_Rsmp_1b7d4074("<3>TLAN: Could not allocate memory for device.\n");
    return (-12);
  }
  priv = (TLanPrivateInfo *)dev->priv;
  if (pdev) {
    pci_io_base = 0U;
    priv->adapter = & board_info[ent->driver_data];
    pci_read_config_byte_Rsmp_e426c0e8(pdev, 8, & pci_rev);
    if (pdev->resource[reg].flags & 256UL) {
      pci_io_base = (unsigned int )pdev->resource[reg].start;
      if (debug & 1) {
        printk_Rsmp_1b7d4074("<7>TLAN: IO mapping is available at %x.\n", pci_io_base);
      }
    }
    if (! pci_io_base) {
      printk_Rsmp_1b7d4074("<3>TLAN: No IO mappings available\n");
      unregister_netdev_Rsmp_99639e9a(dev);
      kfree_Rsmp_037a0cba((void const   *)dev);
      return (-19);
    }
    dev->base_addr = (unsigned long )pci_io_base;
    dev->irq = pdev->irq;
    priv->adapterRev = (unsigned int )pci_rev;
    pci_set_master_Rsmp_2d0760ae(pdev);
    pci_set_drvdata(pdev, (void *)dev);
  } else {
    device_id = inw((unsigned short )(ioaddr + 3202L));
    priv->is_eisa = (unsigned char)1;
    if ((int )device_id == 8433) {
      priv->adapter = & board_info[13];
      priv->adapterRev = 23U;
    } else {
      priv->adapter = & board_info[14];
      priv->adapterRev = 10U;
    }
    dev->base_addr = (unsigned long )ioaddr;
    dev->irq = (unsigned int )irq;
  }
  if (dev->mem_start) {
    priv->aui = (unsigned int )(dev->mem_start & 1UL);
    if (priv->speed == 1U) {
      priv->speed = 10U;
    } else {
      if (priv->speed == 2U) {
        priv->speed = 100U;
      }
    }
    debug = (int )dev->mem_end;
    priv->debug = (unsigned int )dev->mem_end;
  } else {
    priv->aui = (unsigned int )aui[boards_found];
    priv->speed = (unsigned int )speed[boards_found];
    priv->duplex = (unsigned int )duplex[boards_found];
    priv->debug = (unsigned int )debug;
  }
  priv->tlan_tqueue.sync = 0UL;
  priv->tlan_tqueue.data = (void *)dev;
  temp_2 = TLan_Init(dev);
  if (temp_2) {
    printk_Rsmp_1b7d4074("<3>TLAN: Could not register device.\n");
    unregister_netdev_Rsmp_99639e9a(dev);
    kfree_Rsmp_037a0cba((void const   *)dev);
    return (-11);
  } else {
    TLanDevicesInstalled = TLanDevicesInstalled + 1;
    boards_found = boards_found + 1;
    if (pdev) {
      tlan_have_pci = tlan_have_pci + 1;
    } else {
      priv->nextDevice = TLan_Eisa_Devices;
      TLan_Eisa_Devices = dev;
      tlan_have_eisa = tlan_have_eisa + 1;
    }
    printk_Rsmp_1b7d4074("<6>TLAN: %s irq=%2d, io=%04x, %s, Rev. %d\n", dev->name, (int )dev->irq, (int )dev->base_addr, (priv->adapter)->deviceLabel, priv->adapterRev);
    return (0);
  }
}
}
static void TLan_Eisa_Cleanup(void) 
{ register struct net_device *dev ;
  register TLanPrivateInfo *priv ;

  {
  while (tlan_have_eisa) {
    dev = TLan_Eisa_Devices;
    priv = (TLanPrivateInfo *)dev->priv;
    if (priv->dmaStorage) {
      kfree_Rsmp_037a0cba((void const   *)priv->dmaStorage);
    }
    __release_region_Rsmp_d49501d4(& ioport_resource_Rsmp_865ebccd, dev->base_addr, 16UL);
    unregister_netdev_Rsmp_99639e9a(dev);
    TLan_Eisa_Devices = priv->nextDevice;
    kfree_Rsmp_037a0cba((void const   *)dev);
    tlan_have_eisa = tlan_have_eisa - 1;
  }
  return;
}
}
static void tlan_exit(void) 
{ 

  {
  if (tlan_have_pci) {
    pci_unregister_driver_Rsmp_836ea211(& tlan_driver);
  }
  if (tlan_have_eisa) {
    TLan_Eisa_Cleanup();
  }
  kfree_Rsmp_037a0cba((void const   *)TLanPadBuffer);
  return;
}
}
extern int init_module(void) ;
extern void cleanup_module(void) ;
static void TLan_EisaProbe(void) 
{ register long ioaddr ;
  register int rc ;
  register int irq ;
  register u16 device_id ;
  register struct resource *temp_1 ;
  register unsigned char temp_2 ;
  register unsigned char temp_3 ;
  register unsigned char temp_4 ;
  unsigned short tmp ;
  unsigned short tmp___0 ;
  unsigned short tmp___1 ;

  {
  rc = -19;
  if (debug & 16) {
    printk_Rsmp_1b7d4074("<7>TLAN: No EISA bus present\n");
  }
  return;
  if (debug & 16) {
    tmp = inw((unsigned short )(ioaddr + 3200L));
    printk_Rsmp_1b7d4074("<7>TLAN: EISA_ID 0x%4x: 0x%4x\n", (int )ioaddr + 3200, tmp);
  }
  if (debug & 16) {
    tmp___0 = inw((unsigned short )(ioaddr + 3202L));
    printk_Rsmp_1b7d4074("<7>TLAN: EISA_ID 0x%4x: 0x%4x\n", (int )ioaddr + 3202, tmp___0);
  }
  if (debug & 16) {
    printk_Rsmp_1b7d4074("<7>TLAN: Probing for EISA adapter at IO: 0x%4x : ", (int )ioaddr);
  }
  temp_1 = __request_region_Rsmp_1a1a4f09(& ioport_resource_Rsmp_865ebccd, (unsigned long )ioaddr, 16UL, TLanSignature);
  if ((unsigned int )temp_1 == (unsigned int )((void *)0)) {
    goto out;
  }
  tmp___1 = inw((unsigned short )(ioaddr + 3200L));
  temp_2 = (unsigned char )tmp___1;
  if ((int )temp_2 != 4366) {
    __release_region_Rsmp_d49501d4(& ioport_resource_Rsmp_865ebccd, (unsigned long )ioaddr, 16UL);
    goto out;
  }
  device_id = inw((unsigned short )(ioaddr + 3202L));
  if ((int )device_id != 8433) {
    if ((int )device_id != 16625) {
      __release_region_Rsmp_d49501d4(& ioport_resource_Rsmp_865ebccd, (unsigned long )ioaddr, 16UL);
      goto out;
    }
  }
  temp_3 = inb((unsigned short )(ioaddr + 3204L));
  if ((int )temp_3 != 1) {
    __release_region_Rsmp_d49501d4(& ioport_resource_Rsmp_865ebccd, (unsigned long )ioaddr, 16UL);
    goto out2;
  }
  if (debug == 16) {
    printk_Rsmp_1b7d4074("Found one\n");
  }
  temp_4 = inb((unsigned short )(ioaddr + 3264L));
  switch ((int )temp_4) {
  case 16: 
  irq = 5;
  break;
  case 32: 
  irq = 9;
  break;
  case 64: 
  irq = 10;
  break;
  case 128: 
  irq = 11;
  break;
  default: ;
  goto out;
  }
  rc = TLan_probe1((struct pci_dev *)((void *)0), ioaddr, irq, 12, (struct pci_device_id *)((void *)0));
  out: 
  if (debug == 16) {
    printk_Rsmp_1b7d4074("None found\n");
  }
  out2: 
  if (debug == 16) {
    printk_Rsmp_1b7d4074("Card found but it is not enabled, skipping\n");
  }
  return;
}
}
static int TLan_Init(struct net_device *dev ) 
{ register int dma_size ;
  register int err ;
  register int i ;
  register TLanPrivateInfo *priv ;
  register int temp_1 ;
  register int temp_2 ;
  register int temp_3 ;
  register struct resource *temp_4 ;
  void *tmp ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  if (! priv->is_eisa) {
    temp_4 = __request_region_Rsmp_1a1a4f09(& ioport_resource_Rsmp_865ebccd, dev->base_addr, 16UL, TLanSignature);
  }
  if (! temp_4) {
    printk_Rsmp_1b7d4074("<3>TLAN: %s: IO port region 0x%lx size 0x%x in use.\n", dev->name, dev->base_addr, 16);
    return (-5);
  }
  if (bbuf) {
    dma_size = (int )(96U * (sizeof(TLanList ) + 1600U));
  } else {
    dma_size = (int )(96U * sizeof(TLanList ));
  }
  tmp = kmalloc_Rsmp_93d4cfe6(dma_size, 241);
  priv->dmaStorage = tmp;
  if ((unsigned int )priv->dmaStorage == (unsigned int )((void *)0)) {
    printk_Rsmp_1b7d4074("<3>TLAN:  Could not allocate lists and buffers for %s.\n", dev->name);
    __release_region_Rsmp_d49501d4(& ioport_resource_Rsmp_865ebccd, dev->base_addr, 16UL);
    return (-12);
  }
  temp_1 = 1;
  if (temp_1) {
    temp_2 = 0;
    if (temp_2) {
      __constant_c_and_count_memset(priv->dmaStorage, 0UL, dma_size);
    } else {
      __constant_c_memset(priv->dmaStorage, 0UL, dma_size);
    }
  } else {
    temp_3 = 0;
    if (temp_3) {
      __memset_generic(priv->dmaStorage, (char)0, dma_size);
    } else {
      __memset_generic(priv->dmaStorage, (char)0, dma_size);
    }
  }
  priv->rxList = (TLanList *)(((unsigned int )priv->dmaStorage + 7U) & 4294967288U);
  priv->txList = priv->rxList + 32;
  if (bbuf) {
    priv->rxBuffer = (u8 *)(priv->txList + 64);
    priv->txBuffer = priv->rxBuffer + 51200;
  }
  err = 0;
  if (err) {
    printk_Rsmp_1b7d4074("<3>TLAN: %s: Error reading MAC from eeprom: %d\n", dev->name, err);
  }
  dev->addr_len = (unsigned char)6;
  dev->watchdog_timeo = 1000;
  return (0);
}
}
static int TLan_Open(struct net_device *dev ) 
{ register TLanPrivateInfo *priv ;
  register int err ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  priv->tlanRev = TLan_DioRead8((unsigned short )dev->base_addr, (unsigned short)12);
  err = request_irq_Rsmp_0c60f2e0(dev->irq, & TLan_HandleInterrupt, 67108864UL, (char const   *)(TLanSignature), (void *)dev);
  if (err) {
    printk_Rsmp_1b7d4074("<3>TLAN:  Cannot open %s because IRQ %d is already in use.\n", dev->name, dev->irq);
    return (err);
  }
  init_timer(& priv->timer);
  netif_start_queue(dev);
  TLan_ResetLists(dev);
  TLan_ReadAndClearStats(dev, 0);
  if (debug & 1) {
    printk_Rsmp_1b7d4074("<7>TLAN: %s: Opened.  TLAN Chip Rev: %x\n", dev->name, priv->tlanRev);
  }
  return (0);
}
}
static int TLan_ioctl(struct net_device *dev , struct ifreq *rq , int cmd ) 
{ register TLanPrivateInfo *priv ;
  register struct mii_ioctl_data *data ;
  register u32 phy ;
  register int temp_1 ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  data = (struct mii_ioctl_data *)(& rq->ifr_ifru.ifru_data);
  phy = priv->phy[priv->phyNum];
  if (! priv->phyOnline) {
    return (-11);
  }
  switch (cmd) {
  case 35143: 
  case 35312: 
  data->phy_id = (unsigned short )phy;
  case 35144: 
  case 35313: 
  TLan_MiiReadReg(dev, (unsigned short )((int )data->phy_id & 31), (unsigned short )((int )data->reg_num & 31), & data->val_out);
  return (0);
  case 35145: 
  case 35314: 
  temp_1 = capable(12);
  if (! temp_1) {
    return (-1);
  }
  TLan_MiiWriteReg(dev, (unsigned short )((int )data->phy_id & 31), (unsigned short )((int )data->reg_num & 31), data->val_in);
  return (0);
  default: ;
  return (-95);
  }
}
}
static void TLan_tx_timeout(struct net_device *dev ) 
{ 

  {
  if (debug & 1) {
    printk_Rsmp_1b7d4074("<7>TLAN: %s: Transmit timed out.\n", dev->name);
  }
  TLan_FreeLists(dev);
  TLan_ResetLists(dev);
  TLan_ReadAndClearStats(dev, 0);
  TLan_ResetAdapter(dev);
  dev->trans_start = jiffies_Rsmp_0da02d67;
  netif_wake_queue(dev);
  return;
}
}
static int TLan_StartTx(struct sk_buff *skb , struct net_device *dev ) 
{ register TLanPrivateInfo *priv ;
  register TLanList *tail_list ;
  register u8 *tail_buffer ;
  register int pad ;
  register unsigned long flags ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  if (! priv->phyOnline) {
    if (debug & 2) {
      printk_Rsmp_1b7d4074("<7>TLAN: TRANSMIT:  %s PHY is not ready\n", dev->name);
    }
    dev_kfree_skb_any(skb);
    return (0);
  }
  tail_list = priv->txList + priv->txTail;
  if ((int )tail_list->cStat != 32768) {
    if (debug & 2) {
      printk_Rsmp_1b7d4074("<7>TLAN: TRANSMIT:  %s is busy (Head=%d Tail=%d)\n", dev->name, priv->txHead, priv->txTail);
    }
    netif_stop_queue(dev);
    priv->txBusyCount = priv->txBusyCount + 1U;
    return (1);
  }
  tail_list->forward = 0U;
  if (bbuf) {
    tail_buffer = priv->txBuffer + priv->txTail * 1600U;
    memcpy((void *)tail_buffer, (void const   *)skb->data, (int )skb->len);
  } else {
    tmp = virt_to_phys((void *)skb->data);
    tail_list->buffer[0].address = (unsigned int )tmp;
    tail_list->buffer[9].address = (unsigned int )skb;
  }
  pad = (int )(64U - skb->len);
  if (pad > 0) {
    tail_list->frameSize = (unsigned short )((int )((unsigned short )skb->len) + pad);
    tail_list->buffer[0].count = skb->len;
    tail_list->buffer[1].count = 2147483648U | (unsigned int )pad;
    tmp___0 = virt_to_phys((void *)TLanPadBuffer);
    tail_list->buffer[1].address = (unsigned int )tmp___0;
  } else {
    tail_list->frameSize = (unsigned short )skb->len;
    tail_list->buffer[0].count = 2147483648U | skb->len;
    tail_list->buffer[1].count = 0U;
    tail_list->buffer[1].address = 0U;
  }
  spin_lock_irqsave((void *)(& priv->lock), (void *)flags);
  tail_list->cStat = (unsigned short)12288;
  if (! priv->txInProgress) {
    priv->txInProgress = 1U;
    if (debug & 2) {
      printk_Rsmp_1b7d4074("<7>TLAN: TRANSMIT:  Starting TX on buffer %d\n", priv->txTail);
    }
  } else {
    if (debug & 2) {
      printk_Rsmp_1b7d4074("<7>TLAN: TRANSMIT:  Adding buffer %d to TX channel\n", priv->txTail);
    }
    if (priv->txTail == 0U) {
      tmp___1 = virt_to_phys((void *)tail_list);
      (priv->txList + 63)->forward = (unsigned int )tmp___1;
    } else {
      tmp___2 = virt_to_phys((void *)tail_list);
      (priv->txList + (priv->txTail - 1U))->forward = (unsigned int )tmp___2;
    }
  }
  spin_unlock_irqrestore((void *)(& priv->lock), (void *)flags);
  priv->txTail = priv->txTail + 1U;
  if (priv->txTail >= 64U) {
    priv->txTail = 0U;
  }
  if (bbuf) {
    dev_kfree_skb_any(skb);
  }
  dev->trans_start = jiffies_Rsmp_0da02d67;
  return (0);
}
}
static void TLan_HandleInterrupt(int irq , void *dev_id , struct pt_regs *regs ) 
{ register u32 ack ;
  register struct net_device *dev ;
  register u32 host_cmd ;
  register u16 host_int ;
  register int type ;
  register TLanPrivateInfo *priv ;

  {
  dev = (struct net_device *)dev_id;
  priv = (TLanPrivateInfo *)dev->priv;
  spin_lock(& priv->lock);
  host_int = inw((unsigned short )(dev->base_addr + 10UL));
  outw(host_int, (unsigned short )(dev->base_addr + 10UL));
  type = ((int )host_int & 28) >> 2;
  ack = (*(TLanIntVector[type]))(dev, host_int);
  if (ack) {
    host_cmd = (536870912U | ack) | (unsigned int )(type << 18);
  }
  spin_unlock(& priv->lock);
  return;
}
}
static int TLan_Close(struct net_device *dev ) 
{ TLanPrivateInfo *priv ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  netif_stop_queue(dev);
  priv->neg_be_verbose = (unsigned char)0;
  TLan_ReadAndClearStats(dev, 1);
  if ((unsigned int )priv->timer.function != (unsigned int )((void *)0)) {
    del_timer_sync_Rsmp_daff266a(& priv->timer);
    priv->timer.function = (void (*)(unsigned long  ))((void *)0);
  }
  free_irq_Rsmp_f20dabd8(dev->irq, (void *)dev);
  TLan_FreeLists(dev);
  if (debug & 1) {
    printk_Rsmp_1b7d4074("<7>TLAN: Device %s closed.\n", dev->name);
  }
  return (0);
}
}
static struct net_device_stats *TLan_GetStats(struct net_device *dev ) 
{ TLanPrivateInfo *priv ;
  int i ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  TLan_ReadAndClearStats(dev, 1);
  if (debug & 4) {
    printk_Rsmp_1b7d4074("<7>TLAN: RECEIVE:  %s EOC count = %d\n", dev->name, priv->rxEocCount);
  }
  if (debug & 2) {
    printk_Rsmp_1b7d4074("<7>TLAN: TRANSMIT:  %s Busy count = %d\n", dev->name, priv->txBusyCount);
  }
  if (debug & 1) {
    TLan_PrintDio((unsigned short )dev->base_addr);
    TLan_PhyPrint(dev);
  }
  if (debug & 8) {
    TLan_PrintList(priv->rxList + i, (char *)"RX", i);
    TLan_PrintList(priv->txList + i, (char *)"TX", i);
  }
  return (& ((TLanPrivateInfo *)dev->priv)->stats);
}
}
static void TLan_SetMulticastList(struct net_device *dev ) 
{ register struct dev_mc_list *dmi ;
  register u32 hash1 ;
  register u32 hash2 ;
  register int i ;
  register u32 offset ;
  register u8 tmp ;

  {
  dmi = dev->mc_list;
  hash1 = 0U;
  hash2 = 0U;
  if ((int )dev->flags & 256) {
    tmp = TLan_DioRead8((unsigned short )dev->base_addr, (unsigned short)0);
    TLan_DioWrite8((unsigned short )dev->base_addr, (unsigned short)0, (unsigned char )((int )tmp | 16));
  } else {
    tmp = TLan_DioRead8((unsigned short )dev->base_addr, (unsigned short)0);
    TLan_DioWrite8((unsigned short )dev->base_addr, (unsigned short)0, tmp);
    if ((int )dev->flags & 512) {
      TLan_SetMac(dev, i + 1, (char *)((void *)0));
      TLan_DioWrite32((unsigned short )dev->base_addr, (unsigned short)40, 4294967295U);
      TLan_DioWrite32((unsigned short )dev->base_addr, (unsigned short)44, 4294967295U);
    } else {
      i = 0;
      while (i < dev->mc_count) {
        if (i < 3) {
          TLan_SetMac(dev, i + 1, (char *)(& dmi->dmi_addr));
        } else {
          offset = TLan_HashFunc((u8 *)(& dmi->dmi_addr));
          if (offset < 32U) {
            hash1 = hash1 | (unsigned int )(1 << offset);
          } else {
            hash2 = hash2 | (unsigned int )(1 << (offset - 32U));
          }
        }
        dmi = dmi->next;
        i = i + 1;
      }
      TLan_SetMac(dev, i + 1, (char *)((void *)0));
      TLan_DioWrite32((unsigned short )dev->base_addr, (unsigned short)40, hash1);
      TLan_DioWrite32((unsigned short )dev->base_addr, (unsigned short)44, hash2);
    }
  }
  return;
}
}
static u32 TLan_HandleInvalid(struct net_device *dev , u16 host_int ) 
{ 

  {
  return (0U);
}
}
static u32 TLan_HandleTxEOF(struct net_device *dev , u16 host_int ) 
{ register TLanPrivateInfo *priv ;
  register int eoc ;
  register TLanList *head_list ;
  register u32 ack ;
  register u16 tmpCStat ;
  register int temp_1 ;
  register int temp_2 ;
  register int temp_4 ;
  register int temp_5 ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  eoc = 0;
  ack = 0U;
  if (debug & 2) {
    printk_Rsmp_1b7d4074("<7>TLAN: TRANSMIT:  Handling TX EOF (Head=%d Tail=%d)\n", priv->txHead, priv->txTail);
  }
  head_list = priv->txList + priv->txHead;
  while (1) {
    if ((int )tmpCStat & 16384) {
      if (! (ack < 255U)) {
        break;
      }
    } else {
      break;
    }
    ack = ack + 1U;
    if (! bbuf) {
      dev_kfree_skb_any((struct sk_buff *)head_list->buffer[9].address);
      head_list->buffer[9].address = 0U;
    }
    temp_4 = (int )tmpCStat & 2048;
    if (temp_4) {
      eoc = 1;
    }
    priv->stats.tx_bytes = priv->stats.tx_bytes + (unsigned long )head_list->frameSize;
    head_list->cStat = (unsigned short)32768;
    netif_start_queue(dev);
    priv->txHead = priv->txHead + 1U;
    if (priv->txHead >= 64U) {
      priv->txHead = 0U;
    }
    head_list = priv->txList + priv->txHead;
  }
  if (! ack) {
    printk_Rsmp_1b7d4074("<6>TLAN: Received interrupt for uncompleted TX frame.\n");
  }
  if (eoc) {
    temp_5 = debug & 2;
    if (temp_5) {
      printk_Rsmp_1b7d4074("<7>TLAN: TRANSMIT:  Handling TX EOC (Head=%d Tail=%d)\n", priv->txHead, priv->txTail);
    }
    head_list = priv->txList + priv->txHead;
    temp_1 = (int )head_list->cStat & 12288;
    if (temp_1 == 12288) {
      ack = ack | 2147483648U;
    } else {
      priv->txInProgress = 0U;
    }
  }
  temp_2 = (int )((priv->adapter)->flags & 8U);
  if (temp_2) {
    TLan_DioWrite8((unsigned short )dev->base_addr, (unsigned short)68, (unsigned char)17);
    if ((unsigned int )priv->timer.function == (unsigned int )((void *)0)) {
      priv->timer.data = (unsigned long )dev;
      priv->timer.expires = jiffies_Rsmp_0da02d67 + 10UL;
      priv->timerSetAt = (unsigned int )jiffies_Rsmp_0da02d67;
      priv->timerType = 2U;
      add_timer_Rsmp_a19eacf8(& priv->timer);
    } else {
      if (priv->timerType == 2U) {
        priv->timerSetAt = (unsigned int )jiffies_Rsmp_0da02d67;
      }
    }
  }
  return (ack);
}
}
static u32 TLan_HandleStatOverflow(struct net_device *dev , u16 host_int ) 
{ 

  {
  TLan_ReadAndClearStats(dev, 1);
  return (1U);
}
}
static u32 TLan_HandleRxEOF(struct net_device *dev , u16 host_int ) 
{ register TLanPrivateInfo *priv ;
  register u32 ack ;
  register int eoc ;
  register u8 *head_buffer ;
  register TLanList *head_list ;
  register struct sk_buff *skb ;
  register TLanList *tail_list ;
  register void *t ;
  register u32 frameSize ;
  register u16 tmpCStat ;
  register struct sk_buff *new_skb ;
  unsigned char *tmp ;
  unsigned char *tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  ack = 0U;
  eoc = 0;
  if (debug & 4) {
    printk_Rsmp_1b7d4074("<7>TLAN: RECEIVE:  Handling RX EOF (Head=%d Tail=%d)\n", priv->rxHead, priv->rxTail);
  }
  head_list = priv->rxList + priv->rxHead;
  tmpCStat = head_list->cStat;
  while (1) {
    if ((int )tmpCStat & 16384) {
      if (! (ack < 255U)) {
        break;
      }
    } else {
      break;
    }
    frameSize = (unsigned int )head_list->frameSize;
    ack = ack + 1U;
    if ((int )tmpCStat & 2048) {
      eoc = 1;
    }
    if (bbuf) {
      skb = dev_alloc_skb(frameSize + 7U);
      if ((unsigned int )skb == (unsigned int )((void *)0)) {
        printk_Rsmp_1b7d4074("<6>TLAN: Couldn\'t allocate memory for received data.\n");
      } else {
        head_buffer = priv->rxBuffer + priv->rxHead * 1600U;
        skb->dev = dev;
        skb_reserve(skb, 2U);
        tmp = skb_put(skb, frameSize);
        t = (void *)tmp;
        priv->stats.rx_bytes = priv->stats.rx_bytes + (unsigned long )head_list->frameSize;
        memcpy(t, (void const   *)head_buffer, (int )frameSize);
        skb->protocol = eth_type_trans_Rsmp_ef9f8c35(skb, dev);
        netif_rx_Rsmp_4eecbd7e(skb);
      }
    } else {
      new_skb = dev_alloc_skb(1607U);
      if ((unsigned int )new_skb != (unsigned int )((void *)0)) {
        skb = (struct sk_buff *)head_list->buffer[9].address;
        skb_trim(skb, frameSize);
        priv->stats.rx_bytes = priv->stats.rx_bytes + (unsigned long )frameSize;
        skb->protocol = eth_type_trans_Rsmp_ef9f8c35(skb, dev);
        netif_rx_Rsmp_4eecbd7e(skb);
        new_skb->dev = dev;
        skb_reserve(new_skb, 2U);
        tmp___0 = skb_put(new_skb, 1600U);
        t = (void *)tmp___0;
        tmp___1 = virt_to_phys(t);
        head_list->buffer[0].address = (unsigned int )tmp___1;
        head_list->buffer[8].address = (unsigned int )t;
        head_list->buffer[9].address = (unsigned int )new_skb;
      } else {
        printk_Rsmp_1b7d4074("<4>TLAN:  Couldn\'t allocate memory for received data.\n");
      }
    }
    head_list->forward = 0U;
    head_list->cStat = (unsigned short)0;
    tail_list = priv->rxList + priv->rxTail;
    tmp___2 = virt_to_phys((void *)head_list);
    tail_list->forward = (unsigned int )tmp___2;
    priv->rxHead = priv->rxHead + 1U;
    if (priv->rxHead >= 32U) {
      priv->rxHead = 0U;
    }
    priv->rxTail = priv->rxTail + 1U;
    if (priv->rxTail >= 32U) {
      priv->rxTail = 0U;
    }
    head_list = priv->rxList + priv->rxHead;
    tmpCStat = head_list->cStat;
  }
  if (! ack) {
    printk_Rsmp_1b7d4074("<6>TLAN: Received interrupt for uncompleted RX frame.\n");
  }
  if (eoc) {
    if (debug & 4) {
      printk_Rsmp_1b7d4074("<7>TLAN: RECEIVE:  Handling RX EOC (Head=%d Tail=%d)\n", priv->rxHead, priv->rxTail);
    }
    head_list = priv->rxList + priv->rxHead;
    ack = (ack | 2147483648U) | 524288U;
    priv->rxEocCount = priv->rxEocCount + 1U;
  }
  if ((priv->adapter)->flags & 8U) {
    TLan_DioWrite8((unsigned short )dev->base_addr, (unsigned short)68, (unsigned char)17);
    if ((unsigned int )priv->timer.function == (unsigned int )((void *)0)) {
      priv->timer.data = (unsigned long )dev;
      priv->timer.expires = jiffies_Rsmp_0da02d67 + 10UL;
      priv->timerSetAt = (unsigned int )jiffies_Rsmp_0da02d67;
      priv->timerType = 2U;
      add_timer_Rsmp_a19eacf8(& priv->timer);
    } else {
      if (priv->timerType == 2U) {
        priv->timerSetAt = (unsigned int )jiffies_Rsmp_0da02d67;
      }
    }
  }
  dev->last_rx = jiffies_Rsmp_0da02d67;
  return (ack);
}
}
static u32 TLan_HandleDummy(struct net_device *dev , u16 host_int ) 
{ 

  {
  printk_Rsmp_1b7d4074("TLAN:  Test interrupt on %s.\n", dev->name);
  return (1U);
}
}
static u32 TLan_HandleTxEOC(struct net_device *dev , u16 host_int ) 
{ TLanPrivateInfo *priv ;
  TLanList *head_list ;
  u32 ack ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  ack = 1U;
  host_int = (unsigned short)0;
  if ((int )priv->tlanRev < 48) {
    if (debug & 2) {
      printk_Rsmp_1b7d4074("<7>TLAN: TRANSMIT:  Handling TX EOC (Head=%d Tail=%d) -- IRQ\n", priv->txHead, priv->txTail);
    }
    head_list = priv->txList + priv->txHead;
    if (((int )head_list->cStat & 12288) == 12288) {
      netif_stop_queue(dev);
      ack = ack | 2147483648U;
    } else {
      priv->txInProgress = 0U;
    }
  }
  return (ack);
}
}
static u32 TLan_HandleStatusCheck(struct net_device *dev , u16 host_int ) 
{ register TLanPrivateInfo *priv ;
  register u32 ack ;
  register u32 error ;
  register u8 net_sts ;
  register u32 phy ;
  u16 tlphy_ctl ;
  u16 tlphy_sts ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  ack = 1U;
  if ((int )host_int & 8160) {
    netif_stop_queue(dev);
    error = inl((unsigned short )(dev->base_addr + 4UL));
    printk_Rsmp_1b7d4074("TLAN:  %s: Adaptor Error = 0x%x\n", dev->name, error);
    TLan_ReadAndClearStats(dev, 1);
    queue_task(& priv->tlan_tqueue, & tq_immediate_Rsmp_0da0dcd1);
    mark_bh(9);
    netif_wake_queue(dev);
    ack = 0U;
  } else {
    if (debug & 1) {
      printk_Rsmp_1b7d4074("<7>TLAN: %s: Status Check\n", dev->name);
    }
    phy = priv->phy[priv->phyNum];
    net_sts = TLan_DioRead8((unsigned short )dev->base_addr, (unsigned short)2);
    if (net_sts) {
      TLan_DioWrite8((unsigned short )dev->base_addr, (unsigned short)2, net_sts);
      if (debug & 1) {
        printk_Rsmp_1b7d4074("<7>TLAN: %s:    Net_Sts = %x\n", dev->name, (unsigned int )net_sts);
      }
    }
    if ((int )net_sts & 128) {
      if (priv->phyNum == 0U) {
        TLan_MiiReadReg(dev, (unsigned short )phy, (unsigned short)18, & tlphy_sts);
        TLan_MiiReadReg(dev, (unsigned short )phy, (unsigned short)17, & tlphy_ctl);
        if (! ((int )tlphy_sts & 8192)) {
          if (! ((int )tlphy_ctl & 16384)) {
            tlphy_ctl = (unsigned short )((int )tlphy_ctl | 16384);
            TLan_MiiWriteReg(dev, (unsigned short )phy, (unsigned short)17, tlphy_ctl);
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          if ((int )tlphy_sts & 8192) {
            if ((int )tlphy_ctl & 16384) {
              TLan_MiiWriteReg(dev, (unsigned short )phy, (unsigned short)17, tlphy_ctl);
            }
          }
        }
        if (debug) {
          TLan_PhyPrint(dev);
        }
      }
    }
  }
  return (ack);
}
}
static u32 TLan_HandleRxEOC(struct net_device *dev , u16 host_int ) 
{ TLanPrivateInfo *priv ;
  TLanList *head_list ;
  u32 ack ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  ack = 1U;
  if ((int )priv->tlanRev < 48) {
    if (debug & 4) {
      printk_Rsmp_1b7d4074("<7>TLAN: RECEIVE:  Handling RX EOC (Head=%d Tail=%d) -- IRQ\n", priv->rxHead, priv->rxTail);
    }
    head_list = priv->rxList + priv->rxHead;
    ack = (ack | 2147483648U) | 524288U;
    priv->rxEocCount = priv->rxEocCount + 1U;
  }
  return (ack);
}
}
static void TLan_Timer(unsigned long data ) 
{ register struct net_device *dev ;
  register TLanPrivateInfo *priv ;
  register u32 elapsed ;
  register unsigned long flags ;

  {
  dev = (struct net_device *)data;
  priv = (TLanPrivateInfo *)dev->priv;
  flags = 0UL;
  priv->timer.function = (void (*)(unsigned long  ))((void *)0);
  switch ((int )priv->timerType) {
  case 3: 
  TLan_PhyPowerDown(dev);
  break;
  case 4: 
  TLan_PhyPowerUp(dev);
  break;
  case 5: 
  TLan_PhyReset(dev);
  break;
  case 6: 
  TLan_PhyStartLink(dev);
  break;
  case 7: 
  TLan_PhyFinishAutoNeg(dev);
  break;
  case 8: 
  TLan_FinishReset(dev);
  break;
  case 2: 
  spin_lock_irqsave((void *)(& priv->lock), (void *)flags);
  if ((unsigned int )priv->timer.function == (unsigned int )((void *)0)) {
    elapsed = (unsigned int )(jiffies_Rsmp_0da02d67 - (unsigned long )priv->timerSetAt);
    if (elapsed >= 10U) {
      TLan_DioWrite8((unsigned short )dev->base_addr, (unsigned short)68, (unsigned char)1);
    } else {
      priv->timer.function = & TLan_Timer;
      priv->timer.expires = (unsigned long )(priv->timerSetAt + 10U);
      spin_unlock_irqrestore((void *)(& priv->lock), (void *)flags);
      add_timer_Rsmp_a19eacf8(& priv->timer);
      break;
    }
  }
  spin_unlock_irqrestore((void *)(& priv->lock), (void *)flags);
  break;
  default: ;
  break;
  }
  return;
}
}
static void TLan_ResetLists(struct net_device *dev ) 
{ register TLanPrivateInfo *priv ;
  register int i ;
  register TLanList *list ;
  register struct sk_buff *skb ;
  register void *t ;
  unsigned long tmp ;
  unsigned long tmp___0 ;
  unsigned char *tmp___1 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  t = (void *)0;
  priv->txHead = 0U;
  priv->txTail = 0U;
  list = priv->txList + i;
  list->cStat = (unsigned short)32768;
  if (bbuf) {
    tmp = virt_to_phys((void *)(priv->txBuffer + i * 1600));
    list->buffer[0].address = (unsigned int )tmp;
  } else {
    list->buffer[0].address = 0U;
  }
  list->buffer[2].count = 0U;
  list->buffer[2].address = 0U;
  list->buffer[9].address = 0U;
  priv->rxHead = 0U;
  priv->rxTail = 31U;
  list = priv->rxList + i;
  list->cStat = (unsigned short)12288;
  list->frameSize = (unsigned short)1600;
  list->buffer[0].count = 2147485248U;
  if (bbuf) {
    tmp___0 = virt_to_phys((void *)(priv->rxBuffer + i * 1600));
    list->buffer[0].address = (unsigned int )tmp___0;
  } else {
    skb = dev_alloc_skb(1607U);
    if ((unsigned int )skb == (unsigned int )((void *)0)) {
      printk_Rsmp_1b7d4074("TLAN:  Couldn\'t allocate memory for received data.\n");
    } else {
      skb->dev = dev;
      skb_reserve(skb, 2U);
      tmp___1 = skb_put(skb, 1600U);
      t = (void *)tmp___1;
    }
    tmp___2 = virt_to_phys(t);
    list->buffer[0].address = (unsigned int )tmp___2;
    list->buffer[8].address = (unsigned int )t;
    list->buffer[9].address = (unsigned int )skb;
  }
  list->buffer[1].count = 0U;
  list->buffer[1].address = 0U;
  if (i < 31) {
    tmp___3 = virt_to_phys((void *)(list + 1));
    list->forward = (unsigned int )tmp___3;
  } else {
    list->forward = 0U;
  }
  return;
}
}
static void TLan_FreeLists(struct net_device *dev ) 
{ register TLanPrivateInfo *priv ;
  register int i ;
  register TLanList *list ;
  register struct sk_buff *skb ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  priv = (TLanPrivateInfo *)dev->priv;
  if (! bbuf) {
    list = priv->txList + i;
    skb = (struct sk_buff *)list->buffer[9].address;
    if (skb) {
      dev_kfree_skb_any(skb);
      list->buffer[9].address = 0U;
    }
    list = priv->rxList + i;
    skb = (struct sk_buff *)list->buffer[9].address;
    if (skb) {
      dev_kfree_skb_any(skb);
      list->buffer[9].address = 0U;
    }
  }
  return;
}
}
static void TLan_PrintDio(u16 io_base ) 
{ u32 data0 ;
  u32 data1 ;
  int i ;

  {
  printk_Rsmp_1b7d4074("TLAN:   Contents of internal registers for io base 0x%04hx.\n", io_base);
  printk_Rsmp_1b7d4074("TLAN:      Off.  +0         +4\n");
  data0 = TLan_DioRead32(io_base, (unsigned short )i);
  data1 = TLan_DioRead32(io_base, (unsigned short )(i + 4));
  printk_Rsmp_1b7d4074("TLAN:      0x%02x  0x%08x 0x%08x\n", i, data0, data1);
  return;
}
}
static void TLan_PrintList(TLanList *list , char *type , int num ) 
{ int i ;

  {
  printk_Rsmp_1b7d4074("TLAN:   %s List %d at 0x%08x\n", type, num, (unsigned int )list);
  printk_Rsmp_1b7d4074("TLAN:      Forward    = 0x%08x\n", list->forward);
  printk_Rsmp_1b7d4074("TLAN:      CSTAT      = 0x%04hx\n", list->cStat);
  printk_Rsmp_1b7d4074("TLAN:      Frame Size = 0x%04hx\n", list->frameSize);
  printk_Rsmp_1b7d4074("TLAN:      Buffer[%d].count, addr = 0x%08x, 0x%08x\n", i, list->buffer[i].count, list->buffer[i].address);
  return;
}
}
static void TLan_ReadAndClearStats(struct net_device *dev , int record ) 
{ register TLanPrivateInfo *priv ;
  register u32 tx_good ;
  register u32 tx_under ;
  register u32 rx_good ;
  register u32 rx_over ;
  register u32 def_tx ;
  register u32 crc ;
  register u32 code ;
  register u32 multi_col ;
  register u32 single_col ;
  register u32 excess_col ;
  register u32 late_col ;
  register u32 loss ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  unsigned char tmp___4 ;
  unsigned char tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  unsigned char tmp___8 ;
  unsigned char tmp___9 ;
  unsigned char tmp___10 ;
  unsigned char tmp___11 ;
  unsigned char tmp___12 ;
  unsigned char tmp___13 ;
  unsigned char tmp___14 ;
  unsigned char tmp___15 ;
  unsigned char tmp___16 ;
  unsigned char tmp___17 ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  outw((unsigned short)48, (unsigned short )(dev->base_addr + 8UL));
  tmp = inb((unsigned short )(dev->base_addr + 12UL));
  tx_good = (unsigned int )tmp;
  tmp___0 = inb((unsigned short )((dev->base_addr + 12UL) + 1UL));
  tx_good = tx_good + (u32 )((int )tmp___0 << 8);
  tmp___1 = inb((unsigned short )((dev->base_addr + 12UL) + 2UL));
  tx_good = tx_good + (u32 )((int )tmp___1 << 16);
  tmp___2 = inb((unsigned short )((dev->base_addr + 12UL) + 3UL));
  tx_under = (unsigned int )tmp___2;
  outw((unsigned short)52, (unsigned short )(dev->base_addr + 8UL));
  tmp___3 = inb((unsigned short )(dev->base_addr + 12UL));
  rx_good = (unsigned int )tmp___3;
  tmp___4 = inb((unsigned short )((dev->base_addr + 12UL) + 1UL));
  rx_good = rx_good + (u32 )((int )tmp___4 << 8);
  tmp___5 = inb((unsigned short )((dev->base_addr + 12UL) + 2UL));
  rx_good = rx_good + (u32 )((int )tmp___5 << 16);
  tmp___6 = inb((unsigned short )((dev->base_addr + 12UL) + 3UL));
  rx_over = (unsigned int )tmp___6;
  outw((unsigned short)56, (unsigned short )(dev->base_addr + 8UL));
  tmp___7 = inb((unsigned short )(dev->base_addr + 12UL));
  def_tx = (unsigned int )tmp___7;
  tmp___8 = inb((unsigned short )((dev->base_addr + 12UL) + 1UL));
  def_tx = def_tx + (u32 )((int )tmp___8 << 8);
  tmp___9 = inb((unsigned short )((dev->base_addr + 12UL) + 2UL));
  crc = (unsigned int )tmp___9;
  tmp___10 = inb((unsigned short )((dev->base_addr + 12UL) + 3UL));
  code = (unsigned int )tmp___10;
  outw((unsigned short)60, (unsigned short )(dev->base_addr + 8UL));
  tmp___11 = inb((unsigned short )(dev->base_addr + 12UL));
  multi_col = (unsigned int )tmp___11;
  tmp___12 = inb((unsigned short )((dev->base_addr + 12UL) + 1UL));
  multi_col = multi_col + (u32 )((int )tmp___12 << 8);
  tmp___13 = inb((unsigned short )((dev->base_addr + 12UL) + 2UL));
  single_col = (unsigned int )tmp___13;
  tmp___14 = inb((unsigned short )((dev->base_addr + 12UL) + 3UL));
  single_col = single_col + (u32 )((int )tmp___14 << 8);
  outw((unsigned short)64, (unsigned short )(dev->base_addr + 8UL));
  tmp___15 = inb((unsigned short )(dev->base_addr + 12UL));
  excess_col = (unsigned int )tmp___15;
  tmp___16 = inb((unsigned short )((dev->base_addr + 12UL) + 1UL));
  late_col = (unsigned int )tmp___16;
  tmp___17 = inb((unsigned short )((dev->base_addr + 12UL) + 2UL));
  loss = (unsigned int )tmp___17;
  if (record) {
    priv->stats.rx_packets = priv->stats.rx_packets + (unsigned long )rx_good;
    priv->stats.rx_errors = priv->stats.rx_errors + (unsigned long )((rx_over + crc) + code);
    priv->stats.tx_packets = priv->stats.tx_packets + (unsigned long )tx_good;
    priv->stats.tx_errors = priv->stats.tx_errors + (unsigned long )(tx_under + loss);
    priv->stats.collisions = priv->stats.collisions + (unsigned long )(((multi_col + single_col) + excess_col) + late_col);
    priv->stats.rx_over_errors = priv->stats.rx_over_errors + (unsigned long )rx_over;
    priv->stats.rx_crc_errors = priv->stats.rx_crc_errors + (unsigned long )crc;
    priv->stats.rx_frame_errors = priv->stats.rx_frame_errors + (unsigned long )code;
    priv->stats.tx_aborted_errors = priv->stats.tx_aborted_errors + (unsigned long )tx_under;
    priv->stats.tx_carrier_errors = priv->stats.tx_carrier_errors + (unsigned long )loss;
  }
  return;
}
}
static void TLan_ResetAdapter(struct net_device *dev ) 
{ register TLanPrivateInfo *priv ;
  register int i ;
  register u32 addr ;
  register u32 data ;
  register u8 data8 ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  priv->tlanFullDuplex = (unsigned char)0;
  priv->phyOnline = 0U;
  data = inl((unsigned short )dev->base_addr);
  data = data | 32768U;
  udelay(1000UL);
  data = inl((unsigned short )dev->base_addr);
  data = data | 2048U;
  TLan_DioWrite32((unsigned short )dev->base_addr, (unsigned short )i, 0U);
  data = 1664U;
  TLan_DioWrite16((unsigned short )dev->base_addr, (unsigned short)4, (unsigned short )data);
  outw((unsigned short)1, (unsigned short )(dev->base_addr + 8UL));
  addr = (unsigned int )((dev->base_addr + 12UL) + 1UL);
  if ((int )priv->tlanRev >= 48) {
    data8 = (unsigned char)5;
    TLan_DioWrite8((unsigned short )dev->base_addr, (unsigned short)72, data8);
  }
  TLan_PhyDetect(dev);
  data = 1536U;
  if ((priv->adapter)->flags & 2U) {
    data = data | 8192U;
    if (priv->aui == 1U) {
      TLan_DioWrite8((unsigned short )dev->base_addr, (unsigned short)67, (unsigned char)10);
    } else {
      if (priv->duplex == 2U) {
        TLan_DioWrite8((unsigned short )dev->base_addr, (unsigned short)67, (unsigned char)0);
        priv->tlanFullDuplex = (unsigned char)1;
      } else {
        TLan_DioWrite8((unsigned short )dev->base_addr, (unsigned short)67, (unsigned char)8);
      }
    }
  }
  if (priv->phyNum == 0U) {
    data = data | 128U;
  }
  TLan_DioWrite16((unsigned short )dev->base_addr, (unsigned short)4, (unsigned short )data);
  if ((priv->adapter)->flags & 1U) {
    TLan_FinishReset(dev);
  } else {
    TLan_PhyPowerDown(dev);
  }
  return;
}
}
static void TLan_FinishReset(struct net_device *dev ) 
{ register TLanPrivateInfo *priv ;
  register u8 data ;
  register u32 phy ;
  register u8 sio ;
  u16 status ;
  u16 partner ;
  u16 tlphy_ctl ;
  u16 tlphy_par ;
  u16 tlphy_id1 ;
  u16 tlphy_id2 ;
  register int i ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  priv = (TLanPrivateInfo *)dev->priv;
  phy = priv->phy[priv->phyNum];
  data = (unsigned char)192;
  if (priv->tlanFullDuplex) {
    data = (unsigned char )((int )data | 4);
  }
  TLan_DioWrite8((unsigned short )dev->base_addr, (unsigned short)0, data);
  data = (unsigned char)48;
  if (priv->phyNum == 0U) {
    data = (unsigned char )((int )data | 128);
  }
  TLan_DioWrite8((unsigned short )dev->base_addr, (unsigned short)3, data);
  TLan_DioWrite16((unsigned short )dev->base_addr, (unsigned short)70, (unsigned short)1543);
  TLan_MiiReadReg(dev, (unsigned short )phy, (unsigned short)2, & tlphy_id1);
  TLan_MiiReadReg(dev, (unsigned short )phy, (unsigned short)3, & tlphy_id2);
  if ((priv->adapter)->flags & 1U) {
    status = (unsigned short)4;
    printk_Rsmp_1b7d4074("TLAN:  %s: Link forced.\n", dev->name);
  } else {
    if (priv->aui) {
      status = (unsigned short)4;
      printk_Rsmp_1b7d4074("TLAN:  %s: Link forced.\n", dev->name);
    } else {
      TLan_MiiReadReg(dev, (unsigned short )phy, (unsigned short)1, & status);
      udelay(1000UL);
      TLan_MiiReadReg(dev, (unsigned short )phy, (unsigned short)1, & status);
      if ((int )status & 4) {
        if ((int )tlphy_id1 == 8192) {
          if ((int )tlphy_id2 == 23553) {
            TLan_MiiReadReg(dev, (unsigned short )phy, (unsigned short)5, & partner);
            TLan_MiiReadReg(dev, (unsigned short )phy, (unsigned short)25, & tlphy_par);
            printk_Rsmp_1b7d4074("TLAN: %s: Link active with ", dev->name);
            if (! ((int )tlphy_par & 1024)) {
              if ((int )tlphy_par & 128) {
                tmp = "Full";
              } else {
                tmp = "Half";
              }
              if ((int )tlphy_par & 64) {
                tmp___0 = "";
              } else {
                tmp___0 = "0";
              }
              printk_Rsmp_1b7d4074("forced 10%sMbps %s-Duplex\n", tmp___0, tmp);
            } else {
              if ((int )tlphy_par & 128) {
                tmp___1 = "Full";
              } else {
                tmp___1 = "Half";
              }
              if ((int )tlphy_par & 64) {
                tmp___2 = "";
              } else {
                tmp___2 = "0";
              }
              printk_Rsmp_1b7d4074("AutoNegotiation enabled, at 10%sMbps %s-Duplex\n", tmp___2, tmp___1);
              printk_Rsmp_1b7d4074("TLAN: Partner capability: ");
              if ((int )partner & (1 << i)) {
                printk_Rsmp_1b7d4074("%s", media[i - 5]);
              }
              printk_Rsmp_1b7d4074("\n");
            }
            TLan_DioWrite8((unsigned short )dev->base_addr, (unsigned short)68, (unsigned char)1);
          } else {
            goto _L___0;
          }
        } else {
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        _L: /* CIL Label */ 
        if ((int )status & 4) {
          printk_Rsmp_1b7d4074("TLAN: %s: Link active\n", dev->name);
          TLan_DioWrite8((unsigned short )dev->base_addr, (unsigned short)68, (unsigned char)1);
        }
      }
    }
  }
  if (priv->phyNum == 0U) {
    TLan_MiiReadReg(dev, (unsigned short )phy, (unsigned short)17, & tlphy_ctl);
    tlphy_ctl = (unsigned short )((int )tlphy_ctl | 2);
    TLan_MiiWriteReg(dev, (unsigned short )phy, (unsigned short)17, tlphy_ctl);
    sio = TLan_DioRead8((unsigned short )dev->base_addr, (unsigned short)1);
    sio = (unsigned char )((int )sio | 128);
    TLan_DioWrite8((unsigned short )dev->base_addr, (unsigned short)1, sio);
  }
  if ((int )status & 4) {
    TLan_SetMac(dev, 0, (char *)(dev->dev_addr));
    priv->phyOnline = 1U;
    if (debug >= 1) {
      if (debug != 16) {

      }
    }
  } else {
    printk_Rsmp_1b7d4074("TLAN: %s: Link inactive, will retry in 10 secs...\n", dev->name);
    TLan_SetTimer(dev, 1000U, 8U);
    return;
  }
  return;
}
}
static void TLan_SetMac(struct net_device *dev , int areg , char *mac ) 
{ register int i ;

  {
  areg = areg * 6;
  if ((unsigned int )mac != (unsigned int )((void *)0)) {
    TLan_DioWrite8((unsigned short )dev->base_addr, (unsigned short )((16 + areg) + i), (unsigned char )*(mac + i));
  } else {
    TLan_DioWrite8((unsigned short )dev->base_addr, (unsigned short )((16 + areg) + i), (unsigned char)0);
  }
  return;
}
}
static void TLan_PhyPrint(struct net_device *dev ) 
{ register TLanPrivateInfo *priv ;
  u16 i ;
  u16 data0 ;
  u16 data1 ;
  u16 data2 ;
  u16 data3 ;
  u16 phy ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  phy = (unsigned short )priv->phy[priv->phyNum];
  if ((priv->adapter)->flags & 1U) {
    printk_Rsmp_1b7d4074("TLAN:   Device %s, Unmanaged PHY.\n", dev->name);
  } else {
    if ((int )phy <= 31) {
      printk_Rsmp_1b7d4074("TLAN:   Device %s, PHY 0x%02x.\n", dev->name, phy);
      printk_Rsmp_1b7d4074("TLAN:      Off.  +0     +1     +2     +3 \n");
      printk_Rsmp_1b7d4074("TLAN:      0x%02x", i);
      TLan_MiiReadReg(dev, phy, i, & data0);
      printk_Rsmp_1b7d4074(" 0x%04hx", data0);
      TLan_MiiReadReg(dev, phy, (unsigned short )((int )i + 1), & data1);
      printk_Rsmp_1b7d4074(" 0x%04hx", data1);
      TLan_MiiReadReg(dev, phy, (unsigned short )((int )i + 2), & data2);
      printk_Rsmp_1b7d4074(" 0x%04hx", data2);
      TLan_MiiReadReg(dev, phy, (unsigned short )((int )i + 3), & data3);
      printk_Rsmp_1b7d4074(" 0x%04hx\n", data3);
    } else {
      printk_Rsmp_1b7d4074("TLAN:   Device %s, Invalid PHY.\n", dev->name);
    }
  }
  return;
}
}
static void TLan_PhyDetect(struct net_device *dev ) 
{ register TLanPrivateInfo *priv ;
  u16 control ;
  u16 hi ;
  u16 lo ;
  register u32 phy ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  priv = (TLanPrivateInfo *)dev->priv;
  if ((priv->adapter)->flags & 1U) {
    priv->phyNum = 65535U;
    return;
  }
  TLan_MiiReadReg(dev, (unsigned short)31, (unsigned short)2, & hi);
  if ((int )hi != 65535) {
    priv->phy[0] = 31U;
  } else {
    priv->phy[0] = 32U;
  }
  priv->phy[1] = 32U;
  TLan_MiiReadReg(dev, (unsigned short )phy, (unsigned short)0, & control);
  TLan_MiiReadReg(dev, (unsigned short )phy, (unsigned short)2, & hi);
  TLan_MiiReadReg(dev, (unsigned short )phy, (unsigned short)3, & lo);
  if ((int )control != 65535) {
    goto _L;
  } else {
    if ((int )hi != 65535) {
      goto _L;
    } else {
      if ((int )lo != 65535) {
        _L: /* CIL Label */ 
        if (debug & 1) {
          printk_Rsmp_1b7d4074("<7>TLAN: PHY found at %02x %04x %04x %04x\n", phy, control, hi, lo);
        }
        if (priv->phy[1] == 32U) {
          if (phy != 31U) {
            priv->phy[1] = phy;
          }
        }
      }
    }
  }
  if (priv->phy[1] != 32U) {
    priv->phyNum = 1U;
  } else {
    if (priv->phy[0] != 32U) {
      priv->phyNum = 0U;
    } else {
      printk_Rsmp_1b7d4074("TLAN:  Cannot initialize device, no PHY was found!\n");
    }
  }
  return;
}
}
static void TLan_PhyPowerDown(struct net_device *dev ) 
{ TLanPrivateInfo *priv ;
  u16 value ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  if (debug & 1) {
    printk_Rsmp_1b7d4074("<7>TLAN: %s: Powering down PHY(s).\n", dev->name);
  }
  value = (unsigned short)19456;
  TLan_MiiSync((unsigned short )dev->base_addr);
  TLan_MiiWriteReg(dev, (unsigned short )priv->phy[priv->phyNum], (unsigned short)0, value);
  if (priv->phyNum == 0U) {
    if (priv->phy[1] != 32U) {
      if (! ((priv->adapter)->flags & 4U)) {
        TLan_MiiSync((unsigned short )dev->base_addr);
        TLan_MiiWriteReg(dev, (unsigned short )priv->phy[1], (unsigned short)0, value);
      }
    }
  }
  TLan_SetTimer(dev, 5U, 4U);
  return;
}
}
static void TLan_PhyPowerUp(struct net_device *dev ) 
{ TLanPrivateInfo *priv ;
  u16 value ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  if (debug & 1) {
    printk_Rsmp_1b7d4074("<7>TLAN: %s: Powering up PHY.\n", dev->name);
  }
  TLan_MiiSync((unsigned short )dev->base_addr);
  value = (unsigned short)16384;
  TLan_MiiWriteReg(dev, (unsigned short )priv->phy[priv->phyNum], (unsigned short)0, value);
  TLan_MiiSync((unsigned short )dev->base_addr);
  TLan_SetTimer(dev, 5U, 5U);
  return;
}
}
static void TLan_PhyReset(struct net_device *dev ) 
{ register TLanPrivateInfo *priv ;
  register u16 phy ;
  u16 value ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  phy = (unsigned short )priv->phy[priv->phyNum];
  if (debug & 1) {
    printk_Rsmp_1b7d4074("<7>TLAN: %s: Reseting PHY.\n", dev->name);
  }
  TLan_MiiSync((unsigned short )dev->base_addr);
  value = (unsigned short)49152;
  TLan_MiiWriteReg(dev, phy, (unsigned short)0, value);
  TLan_MiiReadReg(dev, phy, (unsigned short)0, & value);
  while ((int )value & 32768) {
    TLan_MiiReadReg(dev, phy, (unsigned short)0, & value);
  }
  TLan_SetTimer(dev, 5U, 6U);
  return;
}
}
static void TLan_PhyStartLink(struct net_device *dev ) 
{ register TLanPrivateInfo *priv ;
  u16 ability ;
  register u16 control ;
  register u16 data ;
  register u16 phy ;
  u16 status ;
  u16 tctl ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  phy = (unsigned short )priv->phy[priv->phyNum];
  if (debug & 1) {
    printk_Rsmp_1b7d4074("<7>TLAN: %s: Trying to activate link.\n", dev->name);
  }
  TLan_MiiReadReg(dev, phy, (unsigned short)1, & status);
  TLan_MiiReadReg(dev, phy, (unsigned short)1, & ability);
  if ((int )status & 8) {
    if (! priv->aui) {
      ability = (unsigned short )((int )status >> 11);
      if (priv->speed == 10U) {
        if (priv->duplex == 1U) {
          TLan_MiiWriteReg(dev, phy, (unsigned short)0, (unsigned short)0);
        } else {
          goto _L___2;
        }
      } else {
        _L___2: /* CIL Label */ 
        if (priv->speed == 10U) {
          if (priv->duplex == 2U) {
            priv->tlanFullDuplex = (unsigned char)1;
            TLan_MiiWriteReg(dev, phy, (unsigned short)0, (unsigned short)256);
          } else {
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          if (priv->speed == 100U) {
            if (priv->duplex == 1U) {
              TLan_MiiWriteReg(dev, phy, (unsigned short)0, (unsigned short)8192);
            } else {
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
            if (priv->speed == 100U) {
              if (priv->duplex == 2U) {
                priv->tlanFullDuplex = (unsigned char)1;
                TLan_MiiWriteReg(dev, phy, (unsigned short)0, (unsigned short)8448);
              } else {
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              TLan_MiiWriteReg(dev, phy, (unsigned short)4, (unsigned short )(((int )ability << 5) | 1));
              TLan_MiiWriteReg(dev, phy, (unsigned short)0, (unsigned short)4096);
              TLan_MiiWriteReg(dev, phy, (unsigned short)0, (unsigned short)4608);
              printk_Rsmp_1b7d4074("TLAN: %s: Starting autonegotiation.\n", dev->name);
              TLan_SetTimer(dev, 200U, 7U);
              return;
            }
          }
        }
      }
    }
  }
  if (priv->aui) {
    if (priv->phyNum != 0U) {
      priv->phyNum = 0U;
      data = (unsigned short)1664;
      TLan_DioWrite16((unsigned short )dev->base_addr, (unsigned short)4, data);
      TLan_SetTimer(dev, 4U, 3U);
      return;
    } else {
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
    if (priv->phyNum == 0U) {
      TLan_MiiReadReg(dev, phy, (unsigned short)17, & tctl);
      if (priv->aui) {
        tctl = (unsigned short )((int )tctl | 8192);
      } else {
        tctl = (unsigned short )((int )tctl & 8192);
        control = (unsigned short)0;
        if (priv->duplex == 2U) {
          control = (unsigned short )((int )control | 256);
          priv->tlanFullDuplex = (unsigned char)1;
        }
        if (priv->speed == 100U) {
          control = (unsigned short )((int )control | 8192);
        }
        TLan_MiiWriteReg(dev, phy, (unsigned short)0, control);
      }
      TLan_MiiWriteReg(dev, phy, (unsigned short)17, tctl);
    }
  }
  TLan_SetTimer(dev, 400U, 8U);
  return;
}
}
static void TLan_PhyFinishAutoNeg(struct net_device *dev ) 
{ register TLanPrivateInfo *priv ;
  u16 an_adv ;
  u16 an_lpa ;
  register u16 data ;
  register u16 mode ;
  register u16 phy ;
  u16 status ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  phy = (unsigned short )priv->phy[priv->phyNum];
  TLan_MiiReadReg(dev, phy, (unsigned short)1, & status);
  udelay(1000UL);
  TLan_MiiReadReg(dev, phy, (unsigned short)1, & status);
  if (! ((int )status & 32)) {
    if (! priv->neg_be_verbose) {
      priv->neg_be_verbose = (u8 )((int )priv->neg_be_verbose + 1);
      printk_Rsmp_1b7d4074("<6>TLAN:  Giving autonegotiation more time.\n");
      printk_Rsmp_1b7d4074("<6>TLAN:  Please check that your adapter has\n");
      printk_Rsmp_1b7d4074("<6>TLAN:  been properly connected to a HUB or Switch.\n");
      printk_Rsmp_1b7d4074("<6>TLAN:  Trying to establish link in the background...\n");
    } else {
      priv->neg_be_verbose = (u8 )((int )priv->neg_be_verbose + 1);
    }
    TLan_SetTimer(dev, 800U, 7U);
    return;
  }
  printk_Rsmp_1b7d4074("TLAN: %s: Autonegotiation complete.\n", dev->name);
  TLan_MiiReadReg(dev, phy, (unsigned short)4, & an_adv);
  TLan_MiiReadReg(dev, phy, (unsigned short)5, & an_lpa);
  mode = (unsigned short )(((int )an_adv & (int )an_lpa) & 992);
  if ((int )mode & 256) {
    priv->tlanFullDuplex = (unsigned char)1;
  } else {
    if (! ((int )mode & 128)) {
      if ((int )mode & 64) {
        priv->tlanFullDuplex = (unsigned char)1;
      }
    }
  }
  if (! ((int )mode & 384)) {
    if ((priv->adapter)->flags & 4U) {
      if (priv->phyNum != 0U) {
        priv->phyNum = 0U;
        data = (unsigned short)1664;
        TLan_DioWrite16((unsigned short )dev->base_addr, (unsigned short)4, data);
        TLan_SetTimer(dev, 40U, 3U);
        return;
      }
    }
  }
  if (priv->phyNum == 0U) {
    if (priv->duplex == 2U) {
      TLan_MiiWriteReg(dev, phy, (unsigned short)0, (unsigned short)4352);
      printk_Rsmp_1b7d4074("TLAN:  Starting internal PHY with FULL-DUPLEX\n");
    } else {
      if (((int )an_adv & (int )an_lpa) & 64) {
        TLan_MiiWriteReg(dev, phy, (unsigned short)0, (unsigned short)4352);
        printk_Rsmp_1b7d4074("TLAN:  Starting internal PHY with FULL-DUPLEX\n");
      } else {
        TLan_MiiWriteReg(dev, phy, (unsigned short)0, (unsigned short)4096);
        printk_Rsmp_1b7d4074("TLAN:  Starting internal PHY with HALF-DUPLEX\n");
      }
    }
  }
  TLan_SetTimer(dev, 10U, 8U);
  return;
}
}
static int TLan_MiiReadReg(struct net_device *dev , u16 phy , u16 reg , u16 *val ) 
{ register u8 nack ;
  register u16 sio ;
  register u16 tmp ;
  register u32 i ;
  register int err ;
  register int minten ;
  register TLanPrivateInfo *priv ;
  register unsigned long flags ;
  register int temp_1 ;
  unsigned char tmp___0 ;
  unsigned char tmp___1 ;
  unsigned char tmp___2 ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  flags = 0UL;
  err = 0;
  outw((unsigned short)1, (unsigned short )(dev->base_addr + 8UL));
  sio = (unsigned short )((dev->base_addr + 12UL) + 1UL);
  if (! in_irq) {
    spin_lock_irqsave((void *)(& priv->lock), (void *)flags);
  }
  TLan_MiiSync((unsigned short )dev->base_addr);
  tmp___0 = inb_p(sio);
  minten = (int )tmp___0 & 128;
  if (minten) {

  }
  TLan_MiiSendData((unsigned short )dev->base_addr, 1U, 2U);
  TLan_MiiSendData((unsigned short )dev->base_addr, 2U, 2U);
  TLan_MiiSendData((unsigned short )dev->base_addr, (unsigned int )phy, 5U);
  TLan_MiiSendData((unsigned short )dev->base_addr, (unsigned int )reg, 5U);
  tmp___1 = inb_p(sio);
  nack = (unsigned char )((int )tmp___1 & 1);
  if (nack) {
    tmp = (unsigned short)65535;
    err = 1;
  } else {
    tmp___2 = inb_p(sio);
    temp_1 = (int )tmp___2;
    if (temp_1 & 1) {
      tmp = (unsigned short )((unsigned int )tmp | i);
    }
  }
  if (minten) {

  }
  *val = tmp;
  if (! in_irq) {
    spin_unlock_irqrestore((void *)(& priv->lock), (void *)flags);
  }
  return (err);
}
}
static void TLan_MiiSendData(u16 base_port , u32 data , unsigned int num_bits ) 
{ register u16 sio ;
  register u32 i ;
  register int TRACER_NONDET ;
  unsigned char tmp ;
  unsigned char tmp___0 ;

  {
  if (num_bits == 0U) {
    return;
  }
  outw((unsigned short)1, (unsigned short )((int )base_port + 8));
  sio = (unsigned short )(((int )base_port + 12) + 1);
  while (TRACER_NONDET) {
    tmp = inb_p(sio);
    if (data & i) {

    }
    tmp___0 = inb_p(sio);
  }
  return;
}
}
static void TLan_MiiSync(u16 base_port ) 
{ int i ;
  u16 sio ;

  {
  outw((unsigned short)1, (unsigned short )((int )base_port + 8));
  sio = (unsigned short )(((int )base_port + 12) + 1);
  return;
}
}
static void TLan_MiiWriteReg(struct net_device *dev , u16 phy , u16 reg , u16 val ) 
{ register u16 sio ;
  register int minten ;
  register unsigned long flags ;
  register TLanPrivateInfo *priv ;
  register unsigned char temp1 ;
  register unsigned char temp2 ;
  unsigned char tmp ;

  {
  flags = 0UL;
  priv = (TLanPrivateInfo *)dev->priv;
  outw((unsigned short)1, (unsigned short )(dev->base_addr + 8UL));
  sio = (unsigned short )((dev->base_addr + 12UL) + 1UL);
  if (! in_irq) {
    spin_lock_irqsave((void *)(& priv->lock), (void *)flags);
  }
  TLan_MiiSync((unsigned short )dev->base_addr);
  tmp = inb_p(sio);
  minten = (int )tmp & 128;
  if (minten) {

  }
  TLan_MiiSendData((unsigned short )dev->base_addr, 1U, 2U);
  TLan_MiiSendData((unsigned short )dev->base_addr, 1U, 2U);
  TLan_MiiSendData((unsigned short )dev->base_addr, (unsigned int )phy, 5U);
  TLan_MiiSendData((unsigned short )dev->base_addr, (unsigned int )reg, 5U);
  TLan_MiiSendData((unsigned short )dev->base_addr, 2U, 2U);
  TLan_MiiSendData((unsigned short )dev->base_addr, (unsigned int )val, 16U);
  if (minten) {
    temp1 = inb_p(sio);
    temp2 = (unsigned char )((int )temp1 | 128);
    outb_p(temp2, sio);
  }
  if (! in_irq) {
    spin_unlock_irqrestore((void *)(& priv->lock), (void *)flags);
  }
  return;
}
}
static void TLan_EeSendStart(u16 io_base ) 
{ u16 sio ;

  {
  outw((unsigned short)1, (unsigned short )((int )io_base + 8));
  sio = (unsigned short )(((int )io_base + 12) + 1);
  return;
}
}
static int TLan_EeSendByte(u16 io_base , u8 data , int stop ) 
{ register int err ;
  register u8 place ;
  register u16 sio ;
  unsigned char tmp ;

  {
  outw((unsigned short)1, (unsigned short )((int )io_base + 8));
  sio = (unsigned short )(((int )io_base + 12) + 1);
  if ((int )place & (int )data) {

  }
  tmp = inb_p(sio);
  err = (int )tmp & 16;
  if (! err) {
    if (stop) {

    }
  }
  return (err);
}
}
static void TLan_EeReceiveByte(u16 io_base , u8 *data , int stop ) 
{ register u8 place ;
  register u16 sio ;
  register int temp_1 ;
  unsigned char tmp ;

  {
  outw((unsigned short)1, (unsigned short )((int )io_base + 8));
  sio = (unsigned short )(((int )io_base + 12) + 1);
  *data = (unsigned char)0;
  tmp = inb_p(sio);
  temp_1 = (int )tmp;
  if (temp_1 & 16) {
    *data = (unsigned char )((int )*data | (int )place);
  }
  if (! stop) {

  }
  return;
}
}
static int TLan_EeReadByte(struct net_device *dev , u8 ee_addr , u8 *data ) 
{ register int err ;
  register TLanPrivateInfo *priv ;
  register unsigned long flags ;
  register int ret ;

  {
  priv = (TLanPrivateInfo *)dev->priv;
  flags = 0UL;
  ret = 0;
  spin_lock_irqsave((void *)(& priv->lock), (void *)flags);
  TLan_EeSendStart((unsigned short )dev->base_addr);
  err = TLan_EeSendByte((unsigned short )dev->base_addr, (unsigned char)160, 0);
  if (err) {
    ret = 1;
    spin_unlock_irqrestore((void *)(& priv->lock), (void *)flags);
    return (ret);
  }
  err = TLan_EeSendByte((unsigned short )dev->base_addr, ee_addr, 0);
  if (err) {
    ret = 2;
    spin_unlock_irqrestore((void *)(& priv->lock), (void *)flags);
    return (ret);
  }
  TLan_EeSendStart((unsigned short )dev->base_addr);
  err = TLan_EeSendByte((unsigned short )dev->base_addr, (unsigned char)161, 0);
  if (err) {
    ret = 3;
    spin_unlock_irqrestore((void *)(& priv->lock), (void *)flags);
    return (ret);
  }
  TLan_EeReceiveByte((unsigned short )dev->base_addr, data, 1);
  spin_unlock_irqrestore((void *)(& priv->lock), (void *)flags);
  return (ret);
}
}
int main(void) 
{ register struct net_device *dev ;
  register struct sk_buff *skb ;
  register int cmd ;
  register struct ifreq *rq ;

  {
  _BLAST_init();
  TLan_Init(dev);
  TLan_Open(dev);
  TLan_EisaProbe();
  TLan_Eisa_Cleanup();
  TLan_StartTx(skb, dev);
  TLan_ioctl(dev, rq, cmd);
  TLan_GetStats(dev);
  TLan_SetTimer(dev, 1024U, 1024U);
  TLan_Close(dev);
  return (0);
}
}

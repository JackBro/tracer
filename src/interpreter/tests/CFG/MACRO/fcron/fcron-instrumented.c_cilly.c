/* Generated by CIL v. 1.3.7 */
/* print_CIL_Input is true */


struct _IO_marker;
struct _IO_marker;
typedef long __off_t;
typedef long long __off64_t;
typedef void _IO_lock_t;
struct _IO_FILE {
   int BLAST_FLAG ;
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[(int )(15U * sizeof(int ) - 2U * sizeof(void *))] ;
};
typedef struct _IO_FILE FILE;
struct _IO_marker;
typedef unsigned int size_t;
typedef unsigned long long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned int __nlink_t;
typedef int __pid_t;
typedef unsigned int __id_t;
typedef long __time_t;
typedef long __suseconds_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef int __ssize_t;
typedef unsigned int __socklen_t;
typedef __gid_t gid_t;
typedef __mode_t mode_t;
typedef __uid_t uid_t;
typedef __pid_t pid_t;
typedef __id_t id_t;
typedef __ssize_t ssize_t;
typedef __time_t time_t;
struct __anonstruct___sigset_t_2 {
   unsigned long __val[(int )(1024U / (8U * sizeof(unsigned long )))] ;
};
typedef struct __anonstruct___sigset_t_2 __sigset_t;
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
typedef long __fd_mask;
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[(int )(1024U / (8U * sizeof(__fd_mask )))] ;
};
typedef struct __anonstruct_fd_set_3 fd_set;
struct __ccured_va_list;
typedef struct __ccured_va_list *__gnuc_va_list;
struct __ccured_va_list {
   int next ;
};
typedef struct __ccured_va_list *__ccured_va_list;
struct option {
   char *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
typedef void (*__sighandler_t)(int  );
struct sigaction {
   void (*sa_handler)(int  ) ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
typedef struct _IO_FILE _IO_FILE;
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   long ru_maxrss ;
   long ru_ixrss ;
   long ru_idrss ;
   long ru_isrss ;
   long ru_minflt ;
   long ru_majflt ;
   long ru_nswap ;
   long ru_inblock ;
   long ru_oublock ;
   long ru_msgsnd ;
   long ru_msgrcv ;
   long ru_nsignals ;
   long ru_nvcsw ;
   long ru_nivcsw ;
};
typedef int __priority_which_t;
struct __anonstruct___wait_terminated_39 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
struct __anonstruct___wait_stopped_40 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_39 __wait_terminated ;
   struct __anonstruct___wait_stopped_40 __wait_stopped ;
};
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char *tm_zone ;
};
typedef __socklen_t socklen_t;
struct pam_handle;
typedef struct pam_handle pam_handle_t;
struct pam_message {
   int msg_style ;
   char *msg ;
};
struct pam_response {
   char *resp ;
   int resp_retcode ;
};
struct pam_conv {
   int (*conv)(int num_msg , struct pam_message **msg , struct pam_response **resp , void *appdata_ptr ) ;
   void *appdata_ptr ;
};
typedef unsigned char bitstr_t;
struct env_t {
   char *e_val ;
   struct env_t *e_next ;
};
typedef struct env_t env_t;
struct cl_t;
struct cf_t {
   struct cf_t *cf_next ;
   struct cl_t *cf_line_base ;
   char *cf_user ;
   struct env_t *cf_env_base ;
   int cf_running ;
   signed char cf_tzdiff ;
};
typedef struct cf_t cf_t;
struct cl_t {
   struct cl_t *cl_next ;
   struct cf_t *cl_file ;
   char *cl_shell ;
   char *cl_runas ;
   char *cl_mailto ;
   long cl_id ;
   time_t cl_until ;
   time_t cl_first ;
   time_t cl_nextexe ;
   long cl_timefreq ;
   unsigned short cl_remain ;
   unsigned short cl_runfreq ;
   unsigned char cl_option[4] ;
   unsigned char cl_lavg[3] ;
   unsigned char cl_numexe ;
   char cl_nice ;
   bitstr_t cl_mins[8] ;
   bitstr_t cl_hrs[3] ;
   bitstr_t cl_days[4] ;
   bitstr_t cl_mons[2] ;
   bitstr_t cl_dow[1] ;
};
typedef struct cl_t cl_t;
struct job_t {
   struct cl_t *j_line ;
   struct job_t *j_next ;
};
typedef struct job_t job_t;
struct lavg_t {
   struct cl_t *l_line ;
   time_t l_until ;
};
typedef struct lavg_t lavg_t;
struct exe_t {
   struct cl_t *e_line ;
   pid_t e_ctrl_pid ;
   pid_t e_job_pid ;
};
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
struct __dirstream;
typedef struct __dirstream DIR;
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
struct spwd {
   char *sp_namp ;
   char *sp_pwdp ;
   long sp_lstchg ;
   long sp_min ;
   long sp_max ;
   long sp_warn ;
   long sp_inact ;
   long sp_expire ;
   unsigned long sp_flag ;
};
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
typedef struct timezone *__timezone_ptr_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
struct fcrondyn_cl {
   struct fcrondyn_cl *fcl_next ;
   int fcl_sock_fd ;
   char *fcl_user ;
   time_t fcl_idle_since ;
   int fcl_cmd_len ;
   long *fcl_cmd ;
};
typedef struct fcrondyn_cl fcrondyn_cl;
union __anonunion___u_47 {
   int __in ;
   int __i ;
};
union __anonunion___u_48 {
   int __in ;
   int __i ;
};
union __anonunion___u_49 {
   int __in ;
   int __i ;
};
union __anonunion___u_50 {
   int __in ;
   int __i ;
};
union __anonunion___u_51 {
   int __in ;
   int __i ;
};
union __anonunion___u_52 {
   int __in ;
   int __i ;
};
union __anonunion___u_53 {
   int __in ;
   int __i ;
};
union __anonunion___u_54 {
   int __in ;
   int __i ;
};
union __anonunion___u_55 {
   int __in ;
   int __i ;
};
union __anonunion___u_56 {
   int __in ;
   int __i ;
};
struct list_t {
   char *str ;
   struct list_t *next ;
};
typedef struct list_t list_t;
struct pam_handle;
struct __dirstream;
/* compiler builtin: 
   void __builtin_varargs_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_strcmp(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void *__builtin___memmove_chk(void * , void const   * , unsigned int  , unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin_strpbrk(char const   * , char const   * ) ;  */
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_exp(double  ) ;  */
/* compiler builtin: 
   long double __builtin_nanl(char const   * ) ;  */
/* compiler builtin: 
   double __builtin_cos(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strchr(char * , int  ) ;  */
/* compiler builtin: 
   float __builtin_atan2f(float  , float  ) ;  */
/* compiler builtin: 
   void *__builtin___memcpy_chk(void * , void const   * , unsigned int  , unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_asin(double  ) ;  */
/* compiler builtin: 
   int __builtin_ctz(unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin_stpcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpckhps(float __attribute__((____vector_size____(16)))   , float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   double __builtin_nans(char const   * ) ;  */
/* compiler builtin: 
   long double __builtin_atan2l(long double  , long double  ) ;  */
/* compiler builtin: 
   float __builtin_logf(float  ) ;  */
/* compiler builtin: 
   int __builtin___fprintf_chk(void * , int  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vsprintf_chk(char * , int  , unsigned int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   char *__builtin___strncpy_chk(char * , char const   * , unsigned int  , unsigned int  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_subps(float __attribute__((____vector_size____(16)))   , float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   float __builtin_log10f(float  ) ;  */
/* compiler builtin: 
   double __builtin_atan(double  ) ;  */
/* compiler builtin: 
   void *__builtin_alloca(unsigned int  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_strncmp(char const   * , char const   * , unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_sin(double  ) ;  */
/* compiler builtin: 
   long double __builtin_logl(long double  ) ;  */
/* compiler builtin: 
   float __builtin_coshf(float  ) ;  */
/* compiler builtin: 
   void *__builtin___mempcpy_chk(void * , void const   * , unsigned int  , unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin___strcat_chk(char * , char const   * , unsigned int  ) ;  */
/* compiler builtin: 
   float __builtin_nansf(char const   * ) ;  */
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_sinhf(float  ) ;  */
/* compiler builtin: 
   long double __builtin_log10l(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_coshl(long double  ) ;  */
/* compiler builtin: 
   unsigned int __builtin_strlen(char const   * ) ;  */
/* compiler builtin: 
   int __builtin_ffs(unsigned int  ) ;  */
/* compiler builtin: 
   float __builtin_asinf(float  ) ;  */
/* compiler builtin: 
   long double __builtin_nansl(char const   * ) ;  */
/* compiler builtin: 
   double __builtin_frexp(double  , int * ) ;  */
/* compiler builtin: 
   double __builtin_tan(double  ) ;  */
/* compiler builtin: 
   long double __builtin_sinhl(long double  ) ;  */
/* compiler builtin: 
   float __builtin_frexpf(float  , int * ) ;  */
/* compiler builtin: 
   long double __builtin_asinl(long double  ) ;  */
/* compiler builtin: 
   void *__builtin_frame_address(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_floor(double  ) ;  */
/* compiler builtin: 
   float __builtin_tanhf(float  ) ;  */
/* compiler builtin: 
   int __builtin_parityl(unsigned long  ) ;  */
/* compiler builtin: 
   int __builtin_clzl(unsigned long  ) ;  */
/* compiler builtin: 
   double __builtin_powi(double  , int  ) ;  */
/* compiler builtin: 
   long double __builtin_frexpl(long double  , int * ) ;  */
/* compiler builtin: 
   float __builtin_atanf(float  ) ;  */
/* compiler builtin: 
   float __builtin_huge_valf(void) ;  */
/* compiler builtin: 
   float __builtin_sqrtf(float  ) ;  */
/* compiler builtin: 
   float __builtin_fmodf(float  ) ;  */
/* compiler builtin: 
   unsigned int __builtin_object_size(void * , int  ) ;  */
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned int  , void * ) ;  */
/* compiler builtin: 
   void __builtin_stdarg_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_mulps(float __attribute__((____vector_size____(16)))   , float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   long double __builtin_tanhl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_nan(char const   * ) ;  */
/* compiler builtin: 
   void __builtin_return(void const   * ) ;  */
/* compiler builtin: 
   long double __builtin_atanl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_huge_vall(void) ;  */
/* compiler builtin: 
   float __builtin_inff(void) ;  */
/* compiler builtin: 
   long double __builtin_sqrtl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_fmodl(long double  ) ;  */
/* compiler builtin: 
   int __builtin___printf_chk(int  , char const   *  , ...) ;  */
/* compiler builtin: 
   float __builtin_floorf(float  ) ;  */
/* compiler builtin: 
   float __builtin_fabsf(float  ) ;  */
/* compiler builtin: 
   int __builtin_popcountll(unsigned long long  ) ;  */
/* compiler builtin: 
   int __builtin___sprintf_chk(char * , int  , unsigned int  , char const   *  , ...) ;  */
/* compiler builtin: 
   int __builtin___vprintf_chk(int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_maxps(float __attribute__((____vector_size____(16)))   , float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   int __builtin___snprintf_chk(char * , unsigned int  , int  , unsigned int  , char const   *  , ...) ;  */
/* compiler builtin: 
   long double __builtin_infl(void) ;  */
/* compiler builtin: 
   void *__builtin_mempcpy(void * , void const   * , unsigned int  ) ;  */
/* compiler builtin: 
   long double __builtin_floorl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_ctzl(unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_fabsl(long double  ) ;  */
/* compiler builtin: 
   int __builtin_clz(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_fabs(double  ) ;  */
/* compiler builtin: 
   int __builtin_popcount(unsigned int  ) ;  */
/* compiler builtin: 
   void __builtin_bcopy(void const   * , void * , unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_ceil(double  ) ;  */
/* compiler builtin: 
   double __builtin_ldexp(double  , int  ) ;  */
/* compiler builtin: 
   float __builtin_sinf(float  ) ;  */
/* compiler builtin: 
   float __builtin_acosf(float  ) ;  */
/* compiler builtin: 
   int __builtin___vsnprintf_chk(char * , unsigned int  , int  , unsigned int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   double __builtin_sinh(double  ) ;  */
/* compiler builtin: 
   int __builtin_ffsll(unsigned long long  ) ;  */
/* compiler builtin: 
   char *__builtin___strcpy_chk(char * , char const   * , unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_inf(void) ;  */
/* compiler builtin: 
   void __builtin_prefetch(void const   *  , ...) ;  */
/* compiler builtin: 
   long double __builtin_sinl(long double  ) ;  */
/* compiler builtin: 
   long double __builtin_acosl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_sqrt(double  ) ;  */
/* compiler builtin: 
   double __builtin_fmod(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strcpy(char * , char const   * ) ;  */
/* compiler builtin: 
   float __builtin_ceilf(float  ) ;  */
/* compiler builtin: 
   void *__builtin_return_address(unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin___stpcpy_chk(char * , char const   * , unsigned int  ) ;  */
/* compiler builtin: 
   float __builtin_tanf(float  ) ;  */
/* compiler builtin: 
   int __builtin_parityll(unsigned long long  ) ;  */
/* compiler builtin: 
   float __builtin_ldexpf(float  , int  ) ;  */
/* compiler builtin: 
   int __builtin_types_compatible_p(unsigned int  , unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_log10(double  ) ;  */
/* compiler builtin: 
   float __builtin_expf(float  ) ;  */
/* compiler builtin: 
   int __builtin_clzll(unsigned long long  ) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_unpcklps(float __attribute__((____vector_size____(16)))   , float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   double __builtin_tanh(double  ) ;  */
/* compiler builtin: 
   int __builtin_constant_p(int  ) ;  */
/* compiler builtin: 
   long double __builtin_ceill(long double  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack_len(void) ;  */
/* compiler builtin: 
   void *__builtin_apply(void (*)() , void * , unsigned int  ) ;  */
/* compiler builtin: 
   long double __builtin_tanl(long double  ) ;  */
/* compiler builtin: 
   double __builtin_log(double  ) ;  */
/* compiler builtin: 
   long double __builtin_ldexpl(long double  , int  ) ;  */
/* compiler builtin: 
   int __builtin_popcountl(unsigned long  ) ;  */
/* compiler builtin: 
   long double __builtin_expl(long double  ) ;  */
/* compiler builtin: 
   void *__builtin___memset_chk(void * , int  , unsigned int  , unsigned int  ) ;  */
/* compiler builtin: 
   char *__builtin___strncat_chk(char * , char const   * , unsigned int  , unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_huge_val(void) ;  */
/* compiler builtin: 
   __builtin_va_list __builtin_next_arg(void) ;  */
/* compiler builtin: 
   void *__builtin_apply_args(void) ;  */
/* compiler builtin: 
   float __builtin_powif(float  , int  ) ;  */
/* compiler builtin: 
   int __builtin___vfprintf_chk(void * , int  , char const   * , __builtin_va_list  ) ;  */
/* compiler builtin: 
   float __builtin_modff(float  , float * ) ;  */
/* compiler builtin: 
   double __builtin_atan2(double  , double  ) ;  */
/* compiler builtin: 
   char *__builtin_strncpy(char * , char const   * , unsigned int  ) ;  */
/* compiler builtin: 
   long double __builtin_powil(long double  , int  ) ;  */
/* compiler builtin: 
   float __builtin_cosf(float  ) ;  */
/* compiler builtin: 
   void __builtin_bzero(void * , unsigned int  ) ;  */
/* compiler builtin: 
   unsigned int __builtin_strspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   long double __builtin_modfl(long double  , long double * ) ;  */
/* compiler builtin: 
   int __builtin_parity(unsigned int  ) ;  */
/* compiler builtin: 
   double __builtin_cosh(double  ) ;  */
/* compiler builtin: 
   char *__builtin_strncat(char * , char const   * , unsigned int  ) ;  */
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
/* compiler builtin: 
   double __builtin_acos(double  ) ;  */
/* compiler builtin: 
   int __builtin_va_arg_pack(void) ;  */
/* compiler builtin: 
   float __attribute__((____vector_size____(16)))  __builtin_ia32_addps(float __attribute__((____vector_size____(16)))   , float __attribute__((____vector_size____(16)))   ) ;  */
/* compiler builtin: 
   long double __builtin_cosl(long double  ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   int __builtin_ctzll(unsigned long long  ) ;  */
/* compiler builtin: 
   unsigned int __builtin_strcspn(char const   * , char const   * ) ;  */
/* compiler builtin: 
   int __builtin_ffsl(unsigned long  ) ;  */
/* compiler builtin: 
   float __builtin_nanf(char const   * ) ;  */
extern FILE *stderr ;
extern FILE *stdout ;
int EXIT  ;
void exit(int status ) 
{ 

  {
  EXIT = 1;
  return;
}
}
int BLAST_error  ;
void BLAST_ERROR(void) 
{ 

  {
  BLAST_error = 0;
  return;
}
}
void __initialize__(void) ;
void *wrapperAlloc(unsigned int p ) 
{ void *x ;

  {
  return (x);
}
}
void *__ptrof_nocheck(void *ptr ) 
{ void *x ;

  {
  return (x);
}
}
void *__endof(void *ptr ) 
{ void *x ;

  {
  return (x);
}
}
void *__ptrof(void *ptr ) 
{ void *x ;

  {
  return (x);
}
}
void __verify_nul(char *ptr ) 
{ int x ;

  {
  return;
}
}
char *__stringof(char *ptr ) 
{ char *x ;

  {
  return (x);
}
}
void *__mkptr(void *p , void *phome ) 
{ void *x ;

  {
  return (x);
}
}
void *__mkptr_size(void *p , unsigned int len ) 
{ void *x ;

  {
  return (x);
}
}
char *__mkptr_string(char *p ) 
{ char *x ;

  {
  return (x);
}
}
void *__trusted_cast(void *p ) 
{ void *x ;

  {
  return (x);
}
}
void *__trusted_deepcast(void *p ) 
{ void *x ;

  {
  return (x);
}
}
int __ccured_has_empty_mangling(unsigned int p ) 
{ int x ;

  {
  return (x);
}
}
extern time_t time(time_t *__timer ) ;
extern int select(int __nfds , fd_set *__readfds , fd_set *__writefds , fd_set *__exceptfds , struct timeval *__timeout ) ;
extern int fcntl(int __fd , int __cmd  , ...) ;
extern int open(char *file , int flag  , ...) ;
extern void __ccured_va_start(__ccured_va_list  , unsigned long  ) ;
extern void __ccured_va_end(__ccured_va_list  ) ;
extern int unlink(char *__name ) ;
extern int GCC_STDARG_START() ;
extern int rename(char *__old , char *__new ) ;
int _get__ctype_b(int p ) 
{ int x ;

  {
  return (x);
}
}
extern int *__errno_location(void) ;
extern char *optarg ;
extern int optind ;
extern int getopt_long(int ___argc , char **___argv , char *__shortopts , struct option *__longopts , int *__longind ) ;
extern struct passwd *getpwuid(__uid_t __uid ) ;
extern struct passwd *getpwnam(char *__name ) ;
extern void *memcpy(void *__dest , void *__src , size_t __n ) ;
extern int memcmp(void *__s1 , void *__s2 , size_t __n ) ;
extern char *strcpy(char *__dest , char *__src ) ;
extern char *strncpy(char *__dest , char *__src , size_t __n ) ;
extern char *strcat(char *__dest , char *__src ) ;
extern char *strncat(char *__dest , char *__src , size_t __n ) ;
extern int strcmp(char *__s1 , char *__s2 ) ;
extern int strncmp(char *__s1 , char *__s2 , size_t __n ) ;
extern char *strchr(char *__s , int __c ) ;
extern char *strrchr(char *__s , int __c ) ;
extern size_t strcspn(char *__s , char *__reject ) ;
extern size_t strlen(char *__s ) ;
extern char *strerror(int __errnum ) ;
extern void bzero(void *__s , size_t __n ) ;
extern int strcasecmp(char *__s1 , char *__s2 ) ;
extern int strncasecmp(char *__s1 , char *__s2 , size_t __n ) ;
extern void *malloc(size_t __size ) ;
extern void *calloc(size_t __nmemb , size_t __size ) ;
extern void *realloc(void *__ptr , size_t __size ) ;
extern void free(void *__ptr ) ;
void *realloc_wrapper(void *b , int sz ) 
{ void *res ;
  void *tmp ;
  void *tmp___0 ;
  void *result ;
  void *tmp___1 ;

  {
  tmp___1 = __ptrof(b);
  tmp = tmp___1;
  tmp___0 = realloc(tmp, (unsigned int )sz);
  res = tmp___0;
  result = b;
  result = __mkptr_size(res, (unsigned int )sz);
  return (result);
}
}
void free_wrapper(void *x ) 
{ void *tmp ;
  void *tmp___0 ;

  {
  tmp___0 = __ptrof(x);
  tmp = tmp___0;
  free(tmp);
  return;
}
}
char *strrchr_wrapper(char *s , int chr ) 
{ char *result ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  tmp = __stringof(s);
  result = strrchr(tmp, chr);
  tmp___1 = __mkptr((void *)result, (void *)s);
  tmp___0 = (char *)tmp___1;
  return (tmp___0);
}
}
int strcasecmp_wrapper(char *s1 , char *s2 ) 
{ char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
  tmp = __stringof(s2);
  tmp___0 = __stringof(s1);
  tmp___1 = strcasecmp(tmp___0, tmp);
  return (tmp___1);
}
}
int strncasecmp_wrapper(char *s1 , char *s2 , unsigned int n ) 
{ void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
  tmp = __endof((void *)s1);
  tmp___0 = __ptrof_nocheck((void *)s1);
  if ((unsigned int )tmp - (unsigned int )tmp___0 < n) {
    __verify_nul(s1);
  }
  tmp___1 = __endof((void *)s2);
  tmp___2 = __ptrof_nocheck((void *)s2);
  if ((unsigned int )tmp___1 - (unsigned int )tmp___2 < n) {
    __verify_nul(s2);
  }
  tmp___6 = __ptrof((void *)s2);
  tmp___3 = (char *)tmp___6;
  tmp___7 = __ptrof((void *)s1);
  tmp___4 = (char *)tmp___7;
  tmp___5 = strncasecmp(tmp___4, tmp___3, n);
  return (tmp___5);
}
}
extern long strtol(char *__nptr , char **__endptr , int __base ) ;
extern int rand(void) ;
extern void srand(unsigned int __seed ) ;
extern char *getenv(char *__name ) ;
extern int putenv(char *__string ) ;
extern int setenv(char *__name , char *__value , int __replace ) ;
extern int mkstemp(char *__template ) ;
extern int getloadavg(double *result , int n ) ;
static void *q__qsort_base  ;
static int (*__qsort_compare)(void * , void * )  ;
static void *b__bsearch_base  ;
static void *b__bsearch_key  ;
static int (*__bsearch_compare)(void * , void * )  ;
static char *saved_str  ;
static struct passwd my_passwd_result  ;
extern __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
extern int kill(__pid_t __pid , int __sig ) ;
extern int siginterrupt(int __sig , int __interrupt ) ;
static void *__mkfat_sighandler(void *in ) 
{ void *tmp ;
  void *tmp___0 ;

  {
  if ((int )in == 1) {
    tmp = __mkptr(in, (void *)0);
    return (tmp);
  } else {
    tmp___0 = __mkptr_size(in, 1U);
    return (tmp___0);
  }
}
}
extern int _IO_getc(_IO_FILE *__fp ) ;
FILE *get_stdin(void) 
{ FILE *f ;

  {
  return (f);
}
}
FILE *get_stdout(void) 
{ FILE *f ;

  {
  return (f);
}
}
FILE *get_stderr(void) 
{ FILE *f ;

  {
  return (f);
}
}
extern int remove(char *__filename ) ;
extern int fclose(FILE *__stream ) ;
extern int fflush(FILE *__stream ) ;
extern FILE *fopen(char *__filename , char *__modes ) ;
extern FILE *freopen(char *__filename , char *__modes , FILE *__stream ) ;
extern FILE *fdopen(int __fd , char *__modes ) ;
extern void setlinebuf(FILE *__stream ) ;
extern int fprintf(FILE *__stream , char *__format  , ...) ;
extern int snprintf(char *__s , size_t __maxlen , char *__format  , ...) ;
extern int vsnprintf(char *__s , size_t __maxlen , char *__format , __gnuc_va_list __arg ) ;
extern int fscanf(FILE *__stream , char *__format  , ...) ;
extern char *fgets(char *__s , int __n , FILE *__stream ) ;
extern int fputs(char *__s , FILE *__stream ) ;
extern int fseek(FILE *__stream , long __off , int __whence ) ;
extern long ftell(FILE *__stream ) ;
extern void rewind(FILE *__stream ) ;
extern int ferror(FILE *__stream ) ;
extern void perror(char *__s ) ;
extern int fileno(FILE *__stream ) ;
void perror_wrapper(char *s ) 
{ char *tmp ;
  char *tmp___0 ;

  {
  tmp___0 = __stringof(s);
  tmp = tmp___0;
  perror(tmp);
  return;
}
}
extern int flock(int __fd , int __operation ) ;
extern int chmod(char *__file , __mode_t __mode ) ;
extern int fchmod(int __fd , __mode_t __mode ) ;
extern __mode_t umask(__mode_t __mask ) ;
extern int mkdir(char *__path , __mode_t __mode ) ;
extern int __fxstat(int __ver , int __fildes , struct stat *__stat_buf ) ;
static int fstat__extinline(int fd , struct stat *statbuf ) 
{ int tmp ;

  {
  tmp = __fxstat(3, fd, statbuf);
  return (tmp);
}
}
extern int setpriority(__priority_which_t __which , id_t __who , int __prio ) ;
extern __pid_t wait3(union wait *__stat_loc , int __options , struct rusage *__usage ) ;
extern void closelog(void) ;
extern void openlog(char *__ident , int __option , int __facility ) ;
extern void syslog(int __pri , char *__fmt  , ...) ;
extern time_t mktime(struct tm *__tp ) ;
extern size_t strftime(char *__s , size_t __maxsize , char *__format , struct tm *__tp ) ;
extern struct tm *localtime(time_t *__timer ) ;
extern int access(char *__name , int __type ) ;
extern int close(int __fd ) ;
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
extern ssize_t write(int __fd , void *__buf , size_t __n ) ;
extern int pipe(int *__pipedes ) ;
extern int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
extern int chdir(char *__path ) ;
extern int dup2(int __fd , int __fd2 ) ;
extern int execl(char *__path , char *__arg  , ...) ;
extern int execlp(char *__file , char *__arg  , ...) ;
extern int nice(int __inc ) ;
extern __pid_t getpid(void) ;
extern __pid_t setsid(void) ;
extern __uid_t getuid(void) ;
extern int setuid(__uid_t __uid ) ;
extern int setgid(__gid_t __gid ) ;
extern __pid_t fork(void) ;
extern int gethostname(char *__name , size_t __len ) ;
extern int ftruncate(int __fd , __off_t __length ) ;
char *pam_strerror(pam_handle_t *pamh , int errnum ) 
{ char *s ;

  {
  return (s);
}
}
char **pam_getenvlist(pam_handle_t *pamh ) 
{ char **x ;

  {
  return (x);
}
}
int pam_start(char *service_name , char *user , struct pam_conv *pam_conversation , pam_handle_t **pamh ) 
{ int x ;

  {
  return (x);
}
}
int pam_end(pam_handle_t *pamh , int pam_status ) 
{ int x ;

  {
  return (x);
}
}
int pam_authenticate(pam_handle_t *pamh , int flags ) 
{ int x ;

  {
  return (x);
}
}
int pam_setcred(pam_handle_t *pamh , int flags ) 
{ int x ;

  {
  return (x);
}
}
int pam_acct_mgmt(pam_handle_t *pamh , int flags ) 
{ int x ;

  {
  return (x);
}
}
int pam_open_session(pam_handle_t *pamh , int flags ) 
{ int x ;

  {
  return (x);
}
}
int pam_close_session(pam_handle_t *pamh , int flags ) 
{ int x ;

  {
  return (x);
}
}
pam_handle_t *pamh  ;
struct pam_conv apamconv  ;
int write_file_to_disk(int fd , struct cf_t *file , time_t time_date ) ;
int save_file_safe(cf_t *file , char *final_path , char *prog_name___0 , uid_t own_uid , gid_t own_gid , time_t save_date ) ;
void xcloselog(void) ;
void explain(char *fmt  , ...) ;
void warn(char *fmt  , ...) ;
void warn_fd(int fd , char *fmt  , ...) ;
void warn_e(char *fmt  , ...) ;
void error(char *fmt  , ...) ;
void error_fd(int fd , char *fmt  , ...) ;
void error_e(char *fmt  , ...) ;
void die(char *fmt  , ...) ;
void die_e(char *fmt  , ...) ;
void error_pame(pam_handle_t *pamh___0 , int pamerrno , char *fmt  , ...) ;
void die_pame(pam_handle_t *pamh___0 , int pamerrno , char *fmt  , ...) ;
void Debug(char *fmt  , ...) ;
void send_msg_fd_debug(int fd , char *fmt  , ...) ;
void send_msg_fd(int fd , char *fmt  , ...) ;
char *fcronconf  ;
char *fcronallow  ;
char *fcrondeny  ;
char *fcrontabs  ;
char *pidfile  ;
char *fifofile  ;
char *editor  ;
char *shell  ;
char *sendmail  ;
int remove_blanks(char *str ) ;
char *strdup2(char *str ) ;
int get_word(char **str ) ;
int temp_file(char **name ) ;
void read_conf(void) ;
void free_conf(void) ;
char *crypt(char *key , char *salt ) 
{ char *x ;

  {
  return (x);
}
}
extern DIR *opendir(char *__name ) ;
extern int closedir(DIR *__dirp ) ;
extern struct dirent *readdir(DIR *__dirp ) ;
extern struct group *getgrnam(char *__name ) ;
extern int initgroups(char *__user , __gid_t __group ) ;
static struct group my_group_result  ;
extern struct spwd *getspnam(char * ) ;
extern int ioctl(int __fd , unsigned long __request  , ...) ;
extern int gettimeofday(struct timeval *__tv , __timezone_ptr_t __tz ) ;
time_t now  ;
char debug_opt  ;
char foreground  ;
char dosyslog  ;
long first_sleep  ;
pid_t daemon_pid  ;
mode_t saved_umask  ;
char *prog_name  ;
struct cf_t *file_base  ;
struct job_t *queue_base  ;
unsigned long next_id  ;
struct cl_t **serial_array  ;
short serial_array_size  ;
short serial_array_index  ;
short serial_num  ;
short serial_running  ;
short serial_max_running  ;
short serial_queue_max  ;
short lavg_queue_max  ;
struct exe_t *exe_array  ;
short exe_array_size  ;
short exe_num  ;
struct lavg_t *lavg_array  ;
short lavg_array_size  ;
short lavg_num  ;
short lavg_serial_running  ;
void xexit(int exit_value ) ;
void test_jobs(void) ;
void wait_chld(void) ;
void wait_all(int *counter ) ;
time_t time_to_sleep(time_t lim ) ;
time_t check_lavg(time_t lim ) ;
extern void set_next_exe(struct cl_t *line , char option , int info_fd ) ;
void set_next_exe_notrun(struct cl_t *line , char context ) ;
void mail_notrun(struct cl_t *line , char context , struct tm *since ) ;
void insert_nextexe(struct cl_t *line ) ;
void run_normal_job(cl_t *line , int info_fd ) ;
void add_serial_job(struct cl_t *line , int info_fd ) ;
void add_lavg_job(struct cl_t *line , int info_fd ) ;
void run_serial_job(void) ;
void reload_all(char *dir_name ) ;
void synchronize_dir(char *dir_name ) ;
void delete_file(char *user_name ) ;
void save_file(struct cf_t *arg_file ) ;
int change_user(struct cl_t *cl ) ;
void run_job(struct exe_t *exeent ) ;
FILE *create_mail(struct cl_t *line , char *subject ) ;
void launch_mailer(struct cl_t *line , FILE *mailf ) ;
extern int socket(int __domain , int __type , int __protocol ) ;
extern int bind(int __fd , void *__addr , socklen_t __len ) ;
extern ssize_t send(int __fd , void *__buf , size_t __n , int __flags ) ;
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
extern int listen(int __fd , int __n ) ;
extern int accept(int __fd , void *__addr , socklen_t *__addr_len ) ;
extern int shutdown(int __fd , int __how ) ;
fd_set read_set  ;
int set_max_fd  ;
extern void init_socket(void) ;
void check_socket(int num ) ;
void close_socket(void) ;
void main_loop(void) ;
void check_signal(void) ;
void info(void) ;
void usage(void) ;
void print_schedule(void) ;
void sighup_handler(int x ) ;
void sigterm_handler(int x ) ;
void sigchild_handler(int x ) ;
void sigusr1_handler(int x ) ;
void sigusr2_handler(int x ) ;
int parseopt(int argc , char **argv ) ;
void get_lock(void) ;
void create_spooldir(char *dir ) ;
long save_time  ;
char once  ;
char *tmp_path  ;
char sig_conf  ;
char sig_chld  ;
char sig_debug  ;
time_t begin_sleep  ;
void info(void) 
{ FILE *tmp ;
  FILE *tmp___0 ;

  {
  tmp___0 = get_stderr();
  tmp = tmp___0;
  tmp->BLAST_FLAG = 1;
  if (! (tmp->BLAST_FLAG == 1)) {
    BLAST_ERROR();
  }
  fprintf(tmp, (char *)"fcron 2.9.5 - periodic command scheduler\nCopyright 2000-2004 Thibault Godouet <fcron@free.fr>\nThis program is free software distributed WITHOUT ANY WARRANTY.\nSee the GNU General Public License for more details.\n");
  exit(0);
  return;
}
}
void usage(void) 
{ FILE *tmp ;
  FILE *tmp___0 ;

  {
  tmp___0 = get_stderr();
  tmp = tmp___0;
  tmp->BLAST_FLAG = 1;
  if (! (tmp->BLAST_FLAG == 1)) {
    BLAST_ERROR();
  }
  fprintf(tmp, (char *)"\nfcron 2.9.5\n\nfcron [-d] [-f] [-b]\nfcron -h\n  -s t   --savetime t     Save fcrontabs on disk every t sec.\n  -l t   --firstsleep t   Sets the initial delay before any job is executed,\n                          default to %d seconds.\n  -m n   --maxserial n    Set to n the max number of running serial jobs.\n  -c f   --configfile f   Make fcron use config file f.\n  -n d   --newspooldir d  Create d as a new spool directory.\n  -f     --foreground     Stay in foreground.\n  -b     --background     Go to background.\n  -y     --nosyslog       Don\'t log to syslog at all.\n  -o     --once           Execute all jobs that need to be run, wait for them,\n                          then return. Sets firstsleep to 0.\n                          Especially useful with -f and -y.\n  -d     --debug          Set Debug mode.\n  -h     --help           Show this help message.\n  -V     --version        Display version & infos about fcron.\n", 20);
  exit(1);
  return;
}
}
void print_schedule(void) 
{ cf_t *cf ;
  cl_t *cl ;
  struct tm *ftime ;

  {
  explain((char *)"Printing schedule ...");
  cf = file_base;
  while (cf) {
    explain((char *)" File %s", cf->cf_user);
    cl = cf->cf_line_base;
    while (cl) {
      ftime = localtime(& cl->cl_nextexe);
      explain((char *)"  cmd %s next exec %d/%d/%d wday:%d %02d:%02d", cl->cl_shell, ftime->tm_mon + 1, ftime->tm_mday, ftime->tm_year + 1900, ftime->tm_wday, ftime->tm_hour, ftime->tm_min);
      cl = cl->cl_next;
    }
    cf = cf->cf_next;
  }
  explain((char *)"... end of printing schedule.");
  return;
}
}
void xexit(int exit_value ) 
{ cf_t *f ;

  {
  f = (cf_t *)((void *)0);
  now = time((time_t *)((void *)0));
  save_file((struct cf_t *)((void *)0));
  close_socket();
  f = file_base;
  while ((unsigned int )f != (unsigned int )((void *)0)) {
    if (f->cf_running > 0) {
      if (debug_opt) {
        Debug((char *)"waiting jobs for %s ...", f->cf_user);
      }
      wait_all(& f->cf_running);
      save_file(f);
    }
  }
  delete_file(f->cf_user);
  f = file_base;
  remove(pidfile);
  free_conf();
  explain((char *)"Exiting with code %d", exit_value);
  exit(exit_value);
  return;
}
}
void get_lock(void) 
{ int otherpid ;
  FILE *daemon_lockfp ;
  int fd ;
  int tmp ;
  __off_t tmp___0 ;
  int tmp___1 ;

  {
  otherpid = 0;
  daemon_lockfp = (FILE *)((void *)0);
  fd = open(pidfile, 66, 420);
  if (fd == -1) {
    die_e((char *)"can\'t open or create %s", pidfile);
  } else {
    daemon_lockfp = fdopen(fd, (char *)"r+");
    daemon_lockfp->BLAST_FLAG = 1;
    if ((unsigned int )daemon_lockfp == (unsigned int )((void *)0)) {
      die_e((char *)"can\'t open or create %s", pidfile);
    }
  }
  tmp = flock(fd, 6);
  if (tmp != 0) {
    fscanf(daemon_lockfp, (char *)"%d", & otherpid);
    die_e((char *)"can\'t lock %s, running daemon\'s pid may be %d", pidfile, otherpid);
  }
  fcntl(fd, 2, 1);
  rewind(daemon_lockfp);
  if (! (daemon_lockfp->BLAST_FLAG == 1)) {
    BLAST_ERROR();
  }
  fprintf(daemon_lockfp, (char *)"%d\n", daemon_pid);
  if (! (daemon_lockfp->BLAST_FLAG == 1)) {
    BLAST_ERROR();
  }
  fflush(daemon_lockfp);
  tmp___0 = ftell(daemon_lockfp);
  tmp___1 = fileno(daemon_lockfp);
  ftruncate(tmp___1, tmp___0);
  return;
}
}
static struct option opt[14]  ;
int parseopt(int argc , char **argv ) 
{ int c ;
  int i ;
  long tmp ;
  long tmp___0 ;

  {
  while (1) {
    c = getopt_long(argc, argv, (char *)"dfbyhVos:l:m:c:n:q:", opt, (int *)((void *)0));
    if (c == -1) {
      break;
    }
    switch ((int )((char )c)) {
    case 86: 
    info();
    break;
    case 104: 
    usage();
    break;
    case 100: 
    debug_opt = (char)1;
    break;
    case 102: 
    foreground = (char)1;
    break;
    case 98: 
    foreground = (char)0;
    break;
    case 121: 
    dosyslog = (char)0;
    break;
    case 111: 
    once = (char)1;
    first_sleep = 0L;
    break;
    case 115: 
    save_time = strtol(optarg, (char **)((void *)0), 10);
    if (save_time < 60L) {
      die((char *)"Save time can only be set between 60 and %d.", 2147483647L);
    } else {
      if (save_time >= 2147483647L) {
        die((char *)"Save time can only be set between 60 and %d.", 2147483647L);
      }
    }
    break;
    case 108: 
    first_sleep = strtol(optarg, (char **)((void *)0), 10);
    if (first_sleep < 0L) {
      die((char *)"First sleep can only be set between 0 and %d.", 2147483647L);
    } else {
      if (first_sleep >= 2147483647L) {
        die((char *)"First sleep can only be set between 0 and %d.", 2147483647L);
      }
    }
    break;
    case 109: 
    tmp = strtol(optarg, (char **)((void *)0), 10);
    serial_max_running = (short )tmp;
    if ((int )serial_max_running <= 0) {
      die((char *)"Max running can only be set between 1 and %d.", 32767);
    } else {
      if ((int )serial_max_running >= 32767) {
        die((char *)"Max running can only be set between 1 and %d.", 32767);
      }
    }
    break;
    case 99: 
    free((void *)fcronconf);
    fcronconf = strdup2(optarg);
    break;
    case 110: 
    create_spooldir(optarg);
    break;
    case 113: 
    tmp___0 = strtol(optarg, (char **)((void *)0), 10);
    serial_queue_max = (short )tmp___0;
    lavg_queue_max = serial_queue_max;
    if ((int )lavg_queue_max < 5) {
      die((char *)"Queue length can only be set between 5 and %d.", 32767);
    } else {
      if ((int )serial_queue_max >= 32767) {
        die((char *)"Queue length can only be set between 5 and %d.", 32767);
      }
    }
    break;
    case 58: 
    error((char *)"(parseopt) Missing parameter");
    usage();
    case 63: 
    usage();
    default: 
    warn((char *)"(parseopt) Warning: getopt returned %c", c);
    }
  }
  if (optind < argc) {
    i = optind;
    while (i <= argc) {
      error((char *)"Unknown argument \"%s\"", *(argv + i));
      i = i + 1;
    }
    usage();
  }
  return (0);
}
}
void create_spooldir(char *dir ) 
{ int dir_fd ;
  struct passwd *pass ;
  struct group *grp ;
  struct stat st ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  dir_fd = -1;
  pass = (struct passwd *)((void *)0);
  grp = (struct group *)((void *)0);
  tmp = mkdir(dir, 0U);
  if (tmp != 0) {
    tmp___0 = __errno_location();
    if (*tmp___0 != 17) {
      die_e((char *)"Cannot create dir %s", dir);
    }
  }
  dir_fd = open(dir, 0);
  if (dir_fd < 0) {
    die_e((char *)"Cannot open dir %s", dir);
  }
  tmp___1 = fstat__extinline(dir_fd, & st);
  if (tmp___1 != 0) {
    close(dir_fd);
    die_e((char *)"Cannot fstat %s", dir);
  }
  if (! ((st.st_mode & 61440U) == 16384U)) {
    close(dir_fd);
    die((char *)"%s exists and is not a directory", dir);
  }
  pass = getpwnam((char *)"fcron");
  if ((unsigned int )pass == (unsigned int )((void *)0)) {
    die_e((char *)"Cannot getpwnam(%s)", "fcron");
  }
  grp = getgrnam((char *)"fcron");
  if ((unsigned int )grp == (unsigned int )((void *)0)) {
    die_e((char *)"Cannot getgrnam(%s)", "fcron");
  }
  tmp___2 = fchown(dir_fd, pass->pw_uid, grp->gr_gid);
  if (tmp___2 != 0) {
    close(dir_fd);
    die_e((char *)"Cannot fchown dir %s to %s:%s", dir, "fcron", "fcron");
  }
  tmp___3 = fchmod(dir_fd, 504U);
  if (tmp___3 != 0) {
    close(dir_fd);
    die_e((char *)"Cannot change dir %s\'s mode to 770", dir);
  }
  close(dir_fd);
  exit(0);
  return;
}
}
void sigterm_handler(int x ) 
{ 

  {
  if (debug_opt) {
    Debug((char *)"");
  }
  explain((char *)"SIGTERM signal received");
  xexit(0);
  return;
}
}
void sighup_handler(int x ) 
{ 

  {
  sig_conf = (char)1;
  return;
}
}
void sigchild_handler(int x ) 
{ 

  {
  sig_chld = (char)1;
  return;
}
}
void sigusr1_handler(int x ) 
{ 

  {
  sig_conf = (char)2;
  return;
}
}
void sigusr2_handler(int x ) 
{ 

  {
  sig_debug = (char)1;
  return;
}
}
int main(int argc , char **argv ) 
{ char *tmp ;
  char *tmp___0 ;
  uid_t daemon_uid ;
  int tmp___1 ;
  FILE *tmp___2 ;
  int fd ;
  pid_t pid ;
  FILE *tmp___3 ;
  FILE *tmp___4 ;
  __pid_t tmp___5 ;
  unsigned int tmp___6 ;
  int slice_criteria ;
  FILE *tmp___7 ;
  FILE *tmp___8 ;
  FILE *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  time_t tmp___13 ;

  {
  __initialize__();
  saved_umask = umask(18U);
  tmp___0 = strrchr(*(argv + 0), '/');
  if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
    prog_name = *(argv + 0);
  } else {
    tmp = strrchr(*(argv + 0), '/');
    prog_name = tmp + 1;
  }
  daemon_uid = getuid();
  if (daemon_uid != 0U) {
    die((char *)"Fcron must be executed as root");
  }
  daemon_pid = getpid();
  parseopt(argc, argv);
  read_conf();
  tmp___1 = chdir(fcrontabs);
  if (tmp___1 != 0) {
    die_e((char *)"Could not change dir to %s", fcrontabs);
  }
  tmp___7 = get_stdin();
  tmp___2 = tmp___7;
  tmp___2->BLAST_FLAG = 1;
  freopen((char *)"/dev/null", (char *)"r", tmp___2);
  if ((int )foreground == 0) {
    pid = fork();
    switch (pid) {
    case -1: 
    die_e((char *)"fork");
    break;
    case 0: 
    break;
    default: 
    exit(0);
    }
    daemon_pid = getpid();
    fd = open((char *)"/dev/tty", 2);
    if (fd >= 0) {
      ioctl(fd, 21538UL, 0);
      close(fd);
    }
    tmp___8 = get_stdout();
    tmp___3 = tmp___8;
    tmp___3->BLAST_FLAG = 1;
    freopen((char *)"/dev/null", (char *)"w", tmp___3);
    tmp___9 = get_stderr();
    tmp___4 = tmp___9;
    tmp___4->BLAST_FLAG = 1;
    freopen((char *)"/dev/null", (char *)"w", tmp___4);
    xcloselog();
    fd = 3;
    while (fd < 250) {
      close(fd);
      fd = fd + 1;
    }
    tmp___5 = setsid();
    if (tmp___5 == -1) {
      error((char *)"Could not setsid()");
    }
  }
  get_lock();
  umask(54U);
  explain((char *)"%s[%d] 2.9.5 started", prog_name, daemon_pid);
  signal(15, & sigterm_handler);
  signal(1, & sighup_handler);
  siginterrupt(1, 0);
  signal(17, & sigchild_handler);
  siginterrupt(17, 0);
  signal(10, & sigusr1_handler);
  siginterrupt(10, 0);
  signal(12, & sigusr2_handler);
  siginterrupt(12, 0);
  signal(13, (void (*)(int  ))1);
  next_id = 0UL;
  exe_num = (short)0;
  exe_array_size = (short)6;
  tmp___10 = calloc((unsigned int )exe_array_size, sizeof(struct exe_t ));
  exe_array = (struct exe_t *)tmp___10;
  if ((unsigned int )exe_array == (unsigned int )((void *)0)) {
    die_e((char *)"could not calloc exe_array");
  }
  serial_running = (short)0;
  serial_array_index = (short)0;
  serial_num = (short)0;
  serial_array_size = (short)10;
  tmp___11 = calloc((unsigned int )serial_array_size, sizeof(cl_t *));
  serial_array = (struct cl_t **)tmp___11;
  if ((unsigned int )serial_array == (unsigned int )((void *)0)) {
    die_e((char *)"could not calloc serial_array");
  }
  lavg_num = (short)0;
  lavg_serial_running = (short)0;
  lavg_array_size = (short)10;
  tmp___12 = calloc((unsigned int )lavg_array_size, sizeof(lavg_t ));
  lavg_array = (struct lavg_t *)tmp___12;
  if ((unsigned int )lavg_array == (unsigned int )((void *)0)) {
    die_e((char *)"could not calloc lavg_array");
  }
  init_socket();
  tmp___13 = time((time_t *)((void *)0));
  tmp___6 = (unsigned int )tmp___13;
  srand(tmp___6);
  main_loop();
  slice_criteria = BLAST_error;
  return (0);
}
}
void check_signal(void) 
{ 

  {
  if ((int )sig_chld > 0) {
    wait_chld();
    sig_chld = (char)0;
    signal(17, & sigchild_handler);
    siginterrupt(17, 0);
  }
  if ((int )sig_conf > 0) {
    if ((int )sig_conf == 1) {
      synchronize_dir((char *)".");
      sig_conf = (char)0;
      signal(1, & sighup_handler);
      siginterrupt(1, 0);
    } else {
      reload_all((char *)".");
      sig_conf = (char)0;
      signal(10, & sigusr1_handler);
      siginterrupt(10, 0);
    }
  }
  if ((int )sig_debug > 0) {
    print_schedule();
    if ((int )debug_opt > 0) {
      debug_opt = (char)0;
    } else {
      debug_opt = (char)1;
    }
    explain((char *)"debug_opt = %d", debug_opt);
    sig_debug = (char)0;
    signal(12, & sigusr2_handler);
    siginterrupt(12, 0);
  }
  return;
}
}
void main_loop(void) 
{ time_t save ;
  time_t stime___0 ;
  struct timeval tv ;
  int retcode ;
  int *tmp ;
  int *tmp___0 ;

  {
  retcode = 0;
  if (debug_opt) {
    Debug((char *)"Entering main loop");
  }
  now = time((time_t *)((void *)0));
  synchronize_dir((char *)".");
  save = now + save_time;
  if ((int )serial_num > 0) {
    stime___0 = first_sleep;
  } else {
    if (once) {
      stime___0 = first_sleep;
    } else {
      stime___0 = time_to_sleep(save);
      if (stime___0 < first_sleep) {
        stime___0 = first_sleep;
      }
    }
  }
  gettimeofday(& tv, (struct timezone *)((void *)0));
  if (stime___0 > 1L) {
    tv.tv_sec = stime___0 - 1L;
  } else {
    tv.tv_sec = 0L;
  }
  tv.tv_usec = 1000000L - tv.tv_usec;
  retcode = select(set_max_fd + 1, & read_set, (fd_set *)((void *)0), (fd_set *)((void *)0), & tv);
  if (retcode < 0) {
    tmp___0 = __errno_location();
    if (*tmp___0 != 4) {
      tmp = __errno_location();
      die_e((char *)"select return %d", *tmp);
    }
  }
  now = time((time_t *)((void *)0));
  check_signal();
  if (debug_opt) {
    Debug((char *)"\n");
  }
  test_jobs();
  while (1) {
    if ((int )serial_num > 0) {
      if (! ((int )serial_running < (int )serial_max_running)) {
        break;
      }
    } else {
      break;
    }
    run_serial_job();
  }
  if (once) {
    explain((char *)"Running with option once : exiting ... ");
    xexit(0);
  }
  if (save <= now) {
    save = now + save_time;
    save_file((struct cf_t *)((void *)0));
  }
  check_socket(retcode);
  stime___0 = check_lavg(save);
  if (debug_opt) {
    Debug((char *)"next sleep time : %ld", stime___0);
  }
  check_signal();
  return;
}
}
void init_conf(void) ;
int remove_blanks(char *str ) 
{ char *c ;
  int tmp ;

  {
  c = str;
  while (*c) {
    c = c + 1;
  }
  while (1) {
    c = c - 1;
    if ((unsigned int )c >= (unsigned int )str) {
      tmp = _get__ctype_b((int )*c);
      if (! (tmp & 8192)) {
        break;
      }
    } else {
      break;
    }
  }
  if ((int )*c == 10) {
    *c = (char )'\000';
  } else {
    c = c + 1;
    *c = (char )'\000';
  }
  return (c - str);
}
}
char *strdup2(char *str ) 
{ char *ptr ;
  size_t tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  tmp = strlen(str);
  tmp___1 = malloc(tmp + 1U);
  tmp___0 = (char *)tmp___1;
  ptr = tmp___0;
  if (! ptr) {
    die_e((char *)"Could not calloc");
  }
  strcpy(ptr, str);
  return (ptr);
}
}
int get_word(char **str ) 
{ char *ptr ;
  int tmp ;
  int tmp___0 ;

  {
  while (1) {
    if (! ((int )*(*str) == 32)) {
      if (! ((int )*(*str) == 9)) {
        break;
      }
    }
    *str = *str + 1;
  }
  ptr = *str;
  while (1) {
    tmp = _get__ctype_b((int )*ptr);
    if (tmp & 8) {
      goto _L;
    } else {
      if ((int )*ptr == 95) {
        goto _L;
      } else {
        if ((int )*ptr == 45) {
          _L: 
          if ((int )*ptr != 61) {
            tmp___0 = _get__ctype_b((int )*ptr);
            if (tmp___0 & 8192) {
              break;
            }
          } else {
            break;
          }
        } else {
          break;
        }
      }
    }
    ptr = ptr + 1;
  }
  return (ptr - *str);
}
}
void init_conf(void) 
{ 

  {
  if ((unsigned int )fcronconf == (unsigned int )((void *)0)) {
    fcronconf = strdup2((char *)"/etc/fcron.conf");
  }
  fcrontabs = strdup2((char *)"/var/spool/fcron");
  pidfile = strdup2((char *)"/var/run/fcron.pid");
  fifofile = strdup2((char *)"/var/run/fcron.fifo");
  fcronallow = strdup2((char *)"/etc/fcron.allow");
  fcrondeny = strdup2((char *)"/etc/fcron.deny");
  shell = strdup2((char *)"/bin/sh");
  sendmail = strdup2((char *)"/usr/lib/sendmail");
  editor = strdup2((char *)"/bin/vi");
  return;
}
}
void free_conf(void) 
{ 

  {
  free((void *)fcronconf);
  free((void *)fcrontabs);
  free((void *)pidfile);
  free((void *)fifofile);
  free((void *)fcronallow);
  free((void *)fcrondeny);
  free((void *)shell);
  free((void *)sendmail);
  free((void *)editor);
  return;
}
}
void read_conf(void) 
{ FILE *f ;
  struct stat st ;
  char buf[1024] ;
  char *ptr1 ;
  char *ptr2 ;
  short namesize ;
  char err_on_enoent ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  f = (FILE *)((void *)0);
  ptr1 = (char *)((void *)0);
  ptr2 = (char *)((void *)0);
  namesize = (short)0;
  err_on_enoent = (char)0;
  if ((unsigned int )fcronconf != (unsigned int )((void *)0)) {
    err_on_enoent = (char)1;
  }
  init_conf();
  f = fopen(fcronconf, (char *)"r");
  if ((unsigned int )f != (unsigned int )((FILE *)0)) {
    f->BLAST_FLAG = 1;
  }
  if ((unsigned int )f == (unsigned int )((void *)0)) {
    tmp = __errno_location();
    if (*tmp == 2) {
      if (err_on_enoent) {
        die_e((char *)"Could not read %s", fcronconf);
      } else {
        return;
      }
    } else {
      error_e((char *)"Could not read %s : config file ignored", fcronconf);
      return;
    }
  }
  tmp___0 = fileno(f);
  tmp___1 = fstat__extinline(tmp___0, & st);
  if (tmp___1 != 0) {
    if (f->BLAST_FLAG == 1) {
      f->BLAST_FLAG = 0;
    } else {
      BLAST_ERROR();
    }
    fclose(f);
    return;
  } else {
    if (st.st_uid != 0U) {
      if (f->BLAST_FLAG == 1) {
        f->BLAST_FLAG = 0;
      } else {
        BLAST_ERROR();
      }
      fclose(f);
      return;
    } else {
      if (st.st_mode & 16U) {
        if (f->BLAST_FLAG == 1) {
          f->BLAST_FLAG = 0;
        } else {
          BLAST_ERROR();
        }
        fclose(f);
        return;
      } else {
        if (st.st_mode & 2U) {
          error((char *)"Conf file (%s) must be owned by root and (no more than) 644 : ignored", fcronconf);
          if (f->BLAST_FLAG == 1) {
            f->BLAST_FLAG = 0;
          } else {
            BLAST_ERROR();
          }
          fclose(f);
          return;
        }
      }
    }
  }
  while (1) {
    if (! (f->BLAST_FLAG == 1)) {
      BLAST_ERROR();
    }
    ptr1 = fgets(buf, (int )sizeof(buf), f);
    if (! ((unsigned int )ptr1 != (unsigned int )((void *)0))) {
      break;
    }
    while (1) {
      if (! ((int )*ptr1 == 32)) {
        if (! ((int )*ptr1 == 9)) {
          break;
        }
      }
      ptr1 = ptr1 + 1;
    }
    if ((int )*ptr1 == 35) {
      continue;
    } else {
      if ((int )*ptr1 == 10) {
        continue;
      } else {
        if ((int )*ptr1 == 0) {
          continue;
        }
      }
    }
    remove_blanks(ptr1);
    tmp___12 = get_word(& ptr1);
    namesize = (short )tmp___12;
    if ((int )namesize == 0) {
      error((char *)"Zero-length var name at line %s : line ignored", buf);
    }
    ptr2 = ptr1 + (int )namesize;
    while (1) {
      tmp___2 = _get__ctype_b((int )*ptr2);
      if (! (tmp___2 & 8192)) {
        break;
      }
      ptr2 = ptr2 + 1;
    }
    if ((int )*ptr2 == 61) {
      ptr2 = ptr2 + 1;
    }
    while (1) {
      tmp___3 = _get__ctype_b((int )*ptr2);
      if (! (tmp___3 & 8192)) {
        break;
      }
      ptr2 = ptr2 + 1;
    }
    tmp___11 = strncmp(ptr1, (char *)"fcrontabs", (unsigned int )namesize);
    if (tmp___11 == 0) {
      fcrontabs = strdup2(ptr2);
    } else {
      tmp___10 = strncmp(ptr1, (char *)"pidfile", (unsigned int )namesize);
      if (tmp___10 == 0) {
        pidfile = strdup2(ptr2);
      } else {
        tmp___9 = strncmp(ptr1, (char *)"fifofile", (unsigned int )namesize);
        if (tmp___9 == 0) {
          fifofile = strdup2(ptr2);
        } else {
          tmp___8 = strncmp(ptr1, (char *)"fcronallow", (unsigned int )namesize);
          if (tmp___8 == 0) {
            fcronallow = strdup2(ptr2);
          } else {
            tmp___7 = strncmp(ptr1, (char *)"fcrondeny", (unsigned int )namesize);
            if (tmp___7 == 0) {
              fcrondeny = strdup2(ptr2);
            } else {
              tmp___6 = strncmp(ptr1, (char *)"shell", (unsigned int )namesize);
              if (tmp___6 == 0) {
                shell = strdup2(ptr2);
              } else {
                tmp___5 = strncmp(ptr1, (char *)"sendmail", (unsigned int )namesize);
                if (tmp___5 == 0) {
                  sendmail = strdup2(ptr2);
                } else {
                  tmp___4 = strncmp(ptr1, (char *)"editor", (unsigned int )namesize);
                  if (tmp___4 == 0) {
                    editor = strdup2(ptr2);
                  } else {
                    error((char *)"Unknown var name at line %s : line ignored", buf);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (debug_opt) {
    if (debug_opt) {
      Debug((char *)"  fcronconf=%s", fcronconf);
    }
  }
  if (f->BLAST_FLAG == 1) {
    f->BLAST_FLAG = 0;
  } else {
    BLAST_ERROR();
  }
  fclose(f);
  return;
}
}
int write_buf_to_disk(int fd , char *write_buf , int *buf_used ) ;
int save_type(int fd , short type , char *write_buf , int *buf_used ) ;
int save_str(int fd , short type , char *str , char *write_buf , int *buf_used ) ;
int save_strn(int fd , short type , char *str , short size , char *write_buf , int *buf_used ) ;
int save_lint(int fd , short type , long value , char *write_buf , int *buf_used ) ;
int save_one_file(cf_t *file , char *filename , uid_t own_uid , gid_t own_gid , time_t save_date ) ;
int save_type(int fd , short type , char *write_buf , int *buf_used ) 
{ short size ;
  int write_len ;
  int tmp ;

  {
  size = (short)0;
  write_len = (int )(sizeof(type) + sizeof(size));
  if (write_len > 1024 - *buf_used) {
    tmp = write_buf_to_disk(fd, write_buf, buf_used);
    if (tmp == -1) {
      return (-1);
    }
  }
  memcpy((void *)(write_buf + *buf_used), (void *)(& type), sizeof(type));
  *buf_used = (int )((unsigned int )*buf_used + sizeof(type));
  memcpy((void *)(write_buf + *buf_used), (void *)(& size), sizeof(size));
  *buf_used = (int )((unsigned int )*buf_used + sizeof(size));
  return (0);
}
}
int save_str(int fd , short type , char *str , char *write_buf , int *buf_used ) 
{ short size ;
  short tmp ;
  int write_len ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
  tmp___1 = strlen(str);
  tmp = (short )tmp___1;
  size = tmp;
  write_len = (int )((sizeof(type) + sizeof(size)) + (unsigned int )size);
  if (write_len > 1024 - *buf_used) {
    tmp___0 = write_buf_to_disk(fd, write_buf, buf_used);
    if (tmp___0 == -1) {
      return (-1);
    }
  }
  memcpy((void *)(write_buf + *buf_used), (void *)(& type), sizeof(type));
  *buf_used = (int )((unsigned int )*buf_used + sizeof(type));
  memcpy((void *)(write_buf + *buf_used), (void *)(& size), sizeof(size));
  *buf_used = (int )((unsigned int )*buf_used + sizeof(size));
  memcpy((void *)(write_buf + *buf_used), (void *)str, (unsigned int )size);
  *buf_used = *buf_used + (int )size;
  return (0);
}
}
int save_strn(int fd , short type , char *str , short size , char *write_buf , int *buf_used ) 
{ int write_len ;
  int tmp ;

  {
  write_len = (int )((sizeof(type) + sizeof(size)) + (unsigned int )size);
  if (write_len > 1024 - *buf_used) {
    tmp = write_buf_to_disk(fd, write_buf, buf_used);
    if (tmp == -1) {
      return (-1);
    }
  }
  memcpy((void *)(write_buf + *buf_used), (void *)(& type), sizeof(type));
  *buf_used = (int )((unsigned int )*buf_used + sizeof(type));
  memcpy((void *)(write_buf + *buf_used), (void *)(& size), sizeof(size));
  *buf_used = (int )((unsigned int )*buf_used + sizeof(size));
  memcpy((void *)(write_buf + *buf_used), (void *)str, (unsigned int )size);
  *buf_used = *buf_used + (int )size;
  return (0);
}
}
int save_lint(int fd , short type , long value , char *write_buf , int *buf_used ) 
{ short size ;
  int write_len ;
  int tmp ;

  {
  size = (short )sizeof(value);
  write_len = (int )((sizeof(type) + sizeof(size)) + (unsigned int )size);
  if (write_len > 1024 - *buf_used) {
    tmp = write_buf_to_disk(fd, write_buf, buf_used);
    if (tmp == -1) {
      return (-1);
    }
  }
  memcpy((void *)(write_buf + *buf_used), (void *)(& type), sizeof(type));
  *buf_used = (int )((unsigned int )*buf_used + sizeof(type));
  memcpy((void *)(write_buf + *buf_used), (void *)(& size), sizeof(size));
  *buf_used = (int )((unsigned int )*buf_used + sizeof(size));
  memcpy((void *)(write_buf + *buf_used), (void *)(& value), (unsigned int )size);
  *buf_used = *buf_used + (int )size;
  return (0);
}
}
int write_buf_to_disk(int fd , char *write_buf , int *buf_used ) 
{ ssize_t to_write ;
  ssize_t written ;
  ssize_t return_val ;
  int num_retries ;
  int tmp ;

  {
  to_write = *buf_used;
  written = 0;
  num_retries = 0;
  while (written < to_write) {
    tmp = num_retries;
    num_retries = num_retries + 1;
    if (tmp > to_write / 2) {
      error((char *)"too many retries (%d) to write buf to disk : giving up.", num_retries);
      return (-1);
    }
    return_val = write(fd, (void *)(write_buf + written), (unsigned int )(to_write - written));
    if (return_val == -1) {
      error_e((char *)"could not write() buf to disk");
      return (-1);
    }
    written = written + return_val;
  }
  if (debug_opt) {
    Debug((char *)"write_buf_to_disk() : written %d/%d, %d (re)try(ies)", written, to_write, num_retries);
  }
  if (written == to_write) {
    *buf_used = 0;
    return (0);
  } else {
    error((char *)"write_buf_to_disk() : written %d bytes for %d requested.", written, to_write);
    return (-1);
  }
}
}
int write_file_to_disk(int fd , struct cf_t *file , time_t time_date ) 
{ cl_t *line ;
  env_t *env ;
  char write_buf[1024] ;
  int write_buf_used ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
  line = (cl_t *)((void *)0);
  env = (env_t *)((void *)0);
  write_buf_used = 0;
  tmp = save_lint(fd, (short)1, 100L, write_buf, & write_buf_used);
  if (tmp != 0) {
    error_e((char *)"Could not write lint : file %s has not been saved.", file->cf_user);
    return (-1);
  }
  tmp___0 = save_str(fd, (short)2, file->cf_user, write_buf, & write_buf_used);
  if (tmp___0 != 0) {
    error_e((char *)"Could not write str : file %s has not been saved.", file->cf_user);
    return (-1);
  }
  tmp___1 = save_lint(fd, (short)3, time_date, write_buf, & write_buf_used);
  if (tmp___1 != 0) {
    error_e((char *)"Could not write lint : file %s has not been saved.", file->cf_user);
    return (-1);
  }
  if ((int )file->cf_tzdiff != 0) {
    tmp___2 = save_lint(fd, (short)4, (long )file->cf_tzdiff, write_buf, & write_buf_used);
    if (tmp___2 != 0) {
      error_e((char *)"Could not write lint : file %s has not been saved.", file->cf_user);
      return (-1);
    }
  }
  env = file->cf_env_base;
  while (env) {
    tmp___3 = save_str(fd, (short)1000, env->e_val, write_buf, & write_buf_used);
    if (tmp___3 != 0) {
      error_e((char *)"Could not write str : file %s has not been saved.", file->cf_user);
      return (-1);
    }
    env = env->e_next;
  }
  line = file->cf_line_base;
  while (line) {
    tmp___4 = save_str(fd, (short)2001, line->cl_shell, write_buf, & write_buf_used);
    if (tmp___4 != 0) {
      error_e((char *)"Could not write str : file %s has not been saved.", file->cf_user);
      return (-1);
    }
    tmp___5 = save_str(fd, (short)2006, line->cl_runas, write_buf, & write_buf_used);
    if (tmp___5 != 0) {
      error_e((char *)"Could not write str : file %s has not been saved.", file->cf_user);
      return (-1);
    }
    tmp___6 = save_str(fd, (short)2007, line->cl_mailto, write_buf, & write_buf_used);
    if (tmp___6 != 0) {
      error_e((char *)"Could not write str : file %s has not been saved.", file->cf_user);
      return (-1);
    }
    tmp___7 = save_strn(fd, (short)2017, (char *)(line->cl_option), (short)4, write_buf, & write_buf_used);
    if (tmp___7 != 0) {
      error_e((char *)"Could not write strn : file %s has not been saved.", file->cf_user);
      return (-1);
    }
    if ((int )line->cl_option[3] & 1) {
      if ((int )line->cl_option[0] & 1) {
        tmp___8 = save_lint(fd, (short)2018, line->cl_first, write_buf, & write_buf_used);
        if (tmp___8 != 0) {
          error_e((char *)"Could not write lint : file %s has not been saved.", file->cf_user);
          return (-1);
        }
      } else {
        goto _L;
      }
    } else {
      _L: 
      tmp___9 = save_lint(fd, (short)2008, line->cl_nextexe, write_buf, & write_buf_used);
      if (tmp___9 != 0) {
        error_e((char *)"Could not write lint : file %s has not been saved.", file->cf_user);
        return (-1);
      }
    }
    if (line->cl_numexe) {
      tmp___10 = save_strn(fd, (short)2002, (char *)(& line->cl_numexe), (short)1, write_buf, & write_buf_used);
      if (tmp___10 != 0) {
        error_e((char *)"Could not write strn : file %s has not been saved.", file->cf_user);
        return (-1);
      }
    }
    if ((int )line->cl_option[0] & 2) {
      tmp___11 = save_strn(fd, (short)2003, (char *)(line->cl_lavg), (short)3, write_buf, & write_buf_used);
      if (tmp___11 != 0) {
        error_e((char *)"Could not write strn : file %s has not been saved.", file->cf_user);
        return (-1);
      }
    }
    if (line->cl_until > 0L) {
      tmp___12 = save_lint(fd, (short)2004, line->cl_until, write_buf, & write_buf_used);
      if (tmp___12 != 0) {
        error_e((char *)"Could not write lint : file %s has not been saved.", file->cf_user);
        return (-1);
      }
    }
    if ((int )line->cl_nice != 0) {
      tmp___13 = save_strn(fd, (short)2005, & line->cl_nice, (short)1, write_buf, & write_buf_used);
      if (tmp___13 != 0) {
        error_e((char *)"Could not write strn : file %s has not been saved.", file->cf_user);
        return (-1);
      }
    }
    if ((int )line->cl_runfreq > 0) {
      tmp___14 = save_lint(fd, (short)2011, (long )line->cl_runfreq, write_buf, & write_buf_used);
      if (tmp___14 != 0) {
        error_e((char *)"Could not write lint : file %s has not been saved.", file->cf_user);
        return (-1);
      }
      tmp___15 = save_lint(fd, (short)2009, (long )line->cl_remain, write_buf, & write_buf_used);
      if (tmp___15 != 0) {
        error_e((char *)"Could not write lint : file %s has not been saved.", file->cf_user);
        return (-1);
      }
    }
    if ((int )line->cl_option[0] & 1) {
      tmp___16 = save_lint(fd, (short)2010, line->cl_timefreq, write_buf, & write_buf_used);
      if (tmp___16 != 0) {
        error_e((char *)"Could not write lint : file %s has not been saved.", file->cf_user);
        return (-1);
      }
    } else {
      tmp___17 = save_strn(fd, (short)2012, (char *)(line->cl_mins), (short)8, write_buf, & write_buf_used);
      if (tmp___17 != 0) {
        error_e((char *)"Could not write strn : file %s has not been saved.", file->cf_user);
        return (-1);
      }
      tmp___18 = save_strn(fd, (short)2013, (char *)(line->cl_hrs), (short)3, write_buf, & write_buf_used);
      if (tmp___18 != 0) {
        error_e((char *)"Could not write strn : file %s has not been saved.", file->cf_user);
        return (-1);
      }
      tmp___19 = save_strn(fd, (short)2014, (char *)(line->cl_days), (short)4, write_buf, & write_buf_used);
      if (tmp___19 != 0) {
        error_e((char *)"Could not write strn : file %s has not been saved.", file->cf_user);
        return (-1);
      }
      tmp___20 = save_strn(fd, (short)2015, (char *)(line->cl_mons), (short)2, write_buf, & write_buf_used);
      if (tmp___20 != 0) {
        error_e((char *)"Could not write strn : file %s has not been saved.", file->cf_user);
        return (-1);
      }
      tmp___21 = save_strn(fd, (short)2016, (char *)(line->cl_dow), (short)1, write_buf, & write_buf_used);
      if (tmp___21 != 0) {
        error_e((char *)"Could not write strn : file %s has not been saved.", file->cf_user);
        return (-1);
      }
    }
    tmp___22 = save_type(fd, (short)2000, write_buf, & write_buf_used);
    if (tmp___22 != 0) {
      error_e((char *)"Could not write type : file %s has not been saved.", file->cf_user);
      return (-1);
    }
    line = line->cl_next;
  }
  tmp___23 = write_buf_to_disk(fd, write_buf, & write_buf_used);
  if (tmp___23 == -1) {
    return (-1);
  }
  return (0);
}
}
int save_one_file(cf_t *file , char *filename , uid_t own_uid , gid_t own_gid , time_t save_date ) 
{ int fd ;
  int tmp ;
  int tmp___0 ;

  {
  fd = open(filename, 4673, 384);
  if (fd == -1) {
    error_e((char *)"Could not open %s", filename);
    return (-1);
  }
  tmp = fchown(fd, own_uid, own_gid);
  if (tmp != 0) {
    error_e((char *)"Could not fchown %s to uid:%d gid:%d", filename, own_uid, own_gid);
    close(fd);
    remove(filename);
    return (-1);
  }
  tmp___0 = write_file_to_disk(fd, file, save_date);
  if (tmp___0 == -1) {
    close(fd);
    remove(filename);
    return (-1);
  }
  close(fd);
  return (0);
}
}
int save_file_safe(cf_t *file , char *final_path , char *prog_name___0 , uid_t own_uid , gid_t own_gid , time_t save_date ) 
{ char temp_path[516] ;
  int final_path_len ;
  int temp_path_index ;
  char *tmp_str ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  tmp_str = (char *)".tmp";
  tmp___2 = strlen(final_path);
  final_path_len = (int )tmp___2;
  strncpy(temp_path, final_path, sizeof(temp_path) - sizeof(tmp_str));
  if ((unsigned int )final_path_len > sizeof(temp_path) - sizeof(tmp_str)) {
    temp_path_index = (int )(sizeof(temp_path) - sizeof(tmp_str));
  } else {
    temp_path_index = final_path_len;
  }
  strcpy(& temp_path[temp_path_index], (char *)".tmp");
  tmp___1 = save_one_file(file, temp_path, own_uid, own_gid, save_date);
  if (tmp___1 == 0) {
    tmp___0 = rename(temp_path, final_path);
    if (tmp___0 != 0) {
      error_e((char *)"Cannot rename %s to %s", temp_path, final_path);
      error((char *)"%s will try to save the name to its definitive filename directly.", prog_name___0);
      error((char *)"If there is an error, root may consider to replace %s (which is a valid copy) by %s manually.", final_path, temp_path);
      tmp = save_one_file(file, final_path, own_uid, own_gid, save_date);
      if (tmp == -1) {
        return (-1);
      }
    }
  } else {
    error((char *)"Since %s has not been able to save %s\'s file, it will keep the previous version (if any) of %s.", prog_name___0, final_path, final_path);
    return (-1);
  }
  return (0);
}
}
int temp_file(char **name ) 
{ int fd ;
  char name_local[512] ;
  int tmp ;
  int tmp___0 ;

  {
  name_local[0] = (char )'\000';
  strncpy(name_local, tmp_path, sizeof(name_local) - 1U);
  name_local[sizeof(name_local) - 1U] = (char )'\000';
  strcat(name_local, (char *)"fcr-XXXXXX");
  fd = mkstemp(name_local);
  if (fd == -1) {
    die_e((char *)"Can\'t find a unique temporary filename");
  }
  tmp = fchmod(fd, 384U);
  if (tmp != 0) {
    die_e((char *)"Can\'t fchmod temp file");
  }
  if ((unsigned int )name == (unsigned int )((void *)0)) {
    tmp___0 = unlink(name_local);
    if (tmp___0 != 0) {
      die_e((char *)"Can\'t unlink temporary file %s", name_local);
    }
  }
  fcntl(fd, 2, 1);
  if ((unsigned int )name != (unsigned int )((void *)0)) {
    *name = strdup2(name_local);
  }
  return (fd);
}
}
static void xopenlog(void) ;
char *make_msg(char *append , char *fmt , __ccured_va_list args ) ;
void log_syslog_str(int priority , char *msg ) ;
void log_console_str(char *msg ) ;
void log_fd_str(int fd , char *msg ) ;
static void log_syslog(int priority , int fd , char *fmt , __ccured_va_list args ) ;
static void log_e(int priority , char *fmt , __ccured_va_list args ) ;
static void log_pame(int priority , pam_handle_t *pamh___0 , int pamerrno , char *fmt , __ccured_va_list args ) ;
static char truncated[13]  ;
static int log_open  ;
static void xopenlog(void) 
{ 

  {
  if (! log_open) {
    openlog(prog_name, 1, 72);
    log_open = 1;
  }
  return;
}
}
void xcloselog(void) 
{ 

  {
  if (log_open) {
    closelog();
  }
  log_open = 0;
  return;
}
}
char *make_msg(char *append , char *fmt , __ccured_va_list args ) 
{ int len ;
  char *msg ;
  size_t tmp ;
  void *tmp___0 ;

  {
  msg = (char *)((void *)0);
  tmp___0 = calloc(1U, 176U);
  msg = (char *)tmp___0;
  if ((unsigned int )msg == (unsigned int )((void *)0)) {
    return ((char *)((void *)0));
  }
  len = vsnprintf(msg, 176U, fmt, args);
  if ((unsigned int )append != (unsigned int )((void *)0)) {
    strncat(msg, (char *)": ", (unsigned int )(175 - len));
    strncat(msg, append, (unsigned int )(175 - len));
    tmp = strlen(append);
    len = (int )((unsigned int )len + (2U + tmp));
  }
  if (len >= 175) {
    strcpy((msg + 174) - sizeof(truncated), truncated);
  }
  return (msg);
}
}
void log_syslog_str(int priority , char *msg ) 
{ 

  {
  if (dosyslog) {
    xopenlog();
    syslog(priority, (char *)"%s", msg);
  }
  return;
}
}
void log_console_str(char *msg ) 
{ time_t t ;
  time_t tmp ;
  struct tm *ft ;
  char date[30] ;
  FILE *tmp___0 ;
  FILE *tmp___1 ;

  {
  if ((int )foreground == 1) {
    tmp = time((time_t *)((void *)0));
    t = tmp;
    ft = localtime(& t);
    date[0] = (char )'\000';
    strftime(date, sizeof(date), (char *)"%H:%M:%S", ft);
    tmp___1 = get_stderr();
    tmp___0 = tmp___1;
    tmp___0->BLAST_FLAG = 1;
    if (! (tmp___0->BLAST_FLAG == 1)) {
      BLAST_ERROR();
    }
    fprintf(tmp___0, (char *)"%s %s\n", date, msg);
  }
  return;
}
}
void log_fd_str(int fd , char *msg ) 
{ size_t tmp ;
  size_t tmp___0 ;

  {
  if (fd >= 0) {
    tmp = strlen(msg);
    send(fd, (void *)msg, tmp, 0);
    tmp___0 = strlen((char *)"\n");
    send(fd, (void *)"\n", tmp___0, 0);
  }
  return;
}
}
static void log_syslog(int priority , int fd , char *fmt , __ccured_va_list args ) 
{ char *msg ;

  {
  msg = make_msg((char *)((void *)0), fmt, args);
  if ((unsigned int )msg == (unsigned int )((void *)0)) {
    return;
  }
  log_syslog_str(priority, msg);
  log_console_str(msg);
  log_fd_str(fd, msg);
  free((void *)msg);
  return;
}
}
static void log_e(int priority , char *fmt , __ccured_va_list args ) 
{ int saved_errno ;
  char *msg ;
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  tmp = __errno_location();
  saved_errno = *tmp;
  tmp___1 = strerror(saved_errno);
  tmp___0 = tmp___1;
  msg = make_msg(tmp___0, fmt, args);
  if ((unsigned int )msg == (unsigned int )((void *)0)) {
    return;
  }
  log_syslog_str(priority, msg);
  log_console_str(msg);
  free((void *)msg);
  return;
}
}
static void log_pame(int priority , pam_handle_t *pamh___0 , int pamerrno , char *fmt , __ccured_va_list args ) 
{ char *msg ;
  char *tmp ;

  {
  tmp = pam_strerror(pamh___0, pamerrno);
  msg = make_msg(tmp, fmt, args);
  if ((unsigned int )msg == (unsigned int )((void *)0)) {
    return;
  }
  log_syslog_str(priority, msg);
  log_console_str(msg);
  xcloselog();
  free((void *)msg);
  return;
}
}
void explain(char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;

  {
  log_syslog(5, -1, fmt, args);
  return;
}
}
void explain_fd(int fd , char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;

  {
  log_syslog(5, fd, fmt, args);
  return;
}
}
void explain_e(char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;

  {
  log_e(5, fmt, args);
  return;
}
}
void warn(char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;

  {
  log_syslog(4, -1, fmt, args);
  return;
}
}
void warn_fd(int fd , char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;

  {
  log_syslog(4, fd, fmt, args);
  return;
}
}
void warn_e(char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;

  {
  log_e(4, fmt, args);
  return;
}
}
void error(char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;

  {
  log_syslog(3, -1, fmt, args);
  return;
}
}
void error_fd(int fd , char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;

  {
  log_syslog(3, fd, fmt, args);
  return;
}
}
void error_e(char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;

  {
  log_e(3, fmt, args);
  return;
}
}
void error_pame(pam_handle_t *pamh___0 , int pamerrno , char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;

  {
  xcloselog();
  log_pame(3, pamh___0, pamerrno, fmt, args);
  return;
}
}
void die(char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;
  __pid_t tmp___0 ;

  {
  log_syslog(3, -1, fmt, args);
  tmp___0 = getpid();
  if (tmp___0 == daemon_pid) {
    error((char *)"Aborted");
  }
  exit(1);
  return;
}
}
void die_e(char *fmt  , ...) 
{ __ccured_va_list args ;
  int err_no ;
  int *tmp ;
  unsigned long tmp___0 ;
  __pid_t tmp___1 ;

  {
  err_no = 0;
  tmp = __errno_location();
  err_no = *tmp;
  log_e(3, fmt, args);
  tmp___1 = getpid();
  if (tmp___1 == daemon_pid) {
    error((char *)"Aborted");
  }
  exit(err_no);
  return;
}
}
void die_pame(pam_handle_t *pamh___0 , int pamerrno , char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;
  __pid_t tmp___0 ;

  {
  xcloselog();
  log_pame(3, pamh___0, pamerrno, fmt, args);
  pam_end(pamh___0, pamerrno);
  tmp___0 = getpid();
  if (tmp___0 == daemon_pid) {
    error((char *)"Aborted");
  }
  exit(1);
  return;
}
}
void Debug(char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;

  {
  log_syslog(7, -1, fmt, args);
  return;
}
}
void send_msg_fd_debug(int fd , char *fmt  , ...) 
{ char *msg ;
  __ccured_va_list args ;
  unsigned long tmp ;

  {
  msg = make_msg((char *)((void *)0), fmt, args);
  if ((unsigned int )msg == (unsigned int )((void *)0)) {
    return;
  }
  if (debug_opt) {
    log_syslog_str(7, msg);
  }
  log_fd_str(fd, msg);
  free((void *)msg);
  return;
}
}
void send_msg_fd(int fd , char *fmt  , ...) 
{ char *msg ;
  __ccured_va_list args ;
  unsigned long tmp ;

  {
  msg = make_msg((char *)((void *)0), fmt, args);
  if ((unsigned int )msg == (unsigned int )((void *)0)) {
    return;
  }
  log_fd_str(fd, msg);
  free((void *)msg);
  return;
}
}
int is_leap_year(int year ) ;
int get_nb_mdays(int year , int mon ) ;
void set_wday(struct tm *date ) ;
extern void goto_non_matching(cl_t *line , struct tm *ftime , char option ) ;
void run_lavg_job(int i ) ;
void run_queue_job(cl_t *line ) ;
void resize_exe_array(void) ;
void test_jobs(void) 
{ struct job_t *j ;

  {
  if (debug_opt) {
    Debug((char *)"Looking for jobs to execute ...");
  }
  while (1) {
    j = queue_base;
    if (j) {
      if (! ((j->j_line)->cl_nextexe <= now)) {
        break;
      }
    } else {
      break;
    }
    if ((int )(j->j_line)->cl_remain > 0) {
      (j->j_line)->cl_remain = (unsigned short )((int )(j->j_line)->cl_remain - 1);
      if ((int )(j->j_line)->cl_remain > 0) {
        set_next_exe(j->j_line, (char)0, -1);
        if (debug_opt) {
          Debug((char *)"    cl_remain: %d", (j->j_line)->cl_remain);
        }
        continue;
      }
    }
    (j->j_line)->cl_remain = (j->j_line)->cl_runfreq;
    if ((int )(j->j_line)->cl_option[0] & 2) {
      add_lavg_job(j->j_line, -1);
    } else {
      if ((int )(j->j_line)->cl_option[0] & 32) {
        add_serial_job(j->j_line, -1);
      } else {
        run_normal_job(j->j_line, -1);
      }
    }
    set_next_exe(j->j_line, (char)0, -1);
  }
  return;
}
}
void run_normal_job(cl_t *line , int info_fd ) 
{ 

  {
  if ((int )line->cl_numexe <= 0) {
    line->cl_numexe = (unsigned char )((int )line->cl_numexe + 1);
    run_queue_job(line);
    send_msg_fd(info_fd, (char *)"Job %s started.", line->cl_shell);
  } else {
    if ((int )line->cl_option[1] & 4) {
      if ((int )line->cl_numexe < 255) {
        line->cl_numexe = (unsigned char )((int )line->cl_numexe + 1);
        run_queue_job(line);
        send_msg_fd(info_fd, (char *)"Job %s started.", line->cl_shell);
      } else {
        warn_fd(info_fd, (char *)"    process already running: %s\'s %s", (line->cl_file)->cf_user, line->cl_shell);
      }
    } else {
      warn_fd(info_fd, (char *)"    process already running: %s\'s %s", (line->cl_file)->cf_user, line->cl_shell);
    }
  }
  return;
}
}
void run_lavg_job(int i ) 
{ 

  {
  run_queue_job((lavg_array + i)->l_line);
  if ((int )((lavg_array + i)->l_line)->cl_option[0] & 32) {
    lavg_serial_running = (short )((int )lavg_serial_running + 1);
  }
  lavg_num = (short )((int )lavg_num - 1);
  if (i < (int )lavg_num) {
    *(lavg_array + i) = *(lavg_array + (int )lavg_num);
    (lavg_array + (int )lavg_num)->l_line = (struct cl_t *)((void *)0);
  } else {
    (lavg_array + i)->l_line = (struct cl_t *)((void *)0);
  }
  return;
}
}
void run_serial_job(void) 
{ 

  {
  if (debug_opt) {
    Debug((char *)"num: %d running:%d  index:%d", serial_num, serial_running, serial_array_index);
  }
  if ((int )serial_num != 0) {
    run_queue_job(*(serial_array + (int )serial_array_index));
    *(serial_array + (int )serial_array_index) = (struct cl_t *)((void *)0);
    serial_running = (short )((int )serial_running + 1);
    serial_array_index = (short )((int )serial_array_index + 1);
    if ((int )serial_array_index >= (int )serial_array_size) {
      serial_array_index = (short )((int )serial_array_index - (int )serial_array_size);
    }
    serial_num = (short )((int )serial_num - 1);
  }
  return;
}
}
void resize_exe_array(void) 
{ struct exe_t *ptr ;
  short old_size ;
  void *tmp ;

  {
  ptr = (struct exe_t *)((void *)0);
  old_size = exe_array_size;
  if (debug_opt) {
    Debug((char *)"Resizing exe_array");
  }
  exe_array_size = (short )((int )exe_array_size + 5);
  tmp = calloc((unsigned int )exe_array_size, sizeof(struct exe_t ));
  ptr = (struct exe_t *)tmp;
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
    die_e((char *)"could not calloc exe_array");
  }
  memcpy((void *)ptr, (void *)exe_array, sizeof(struct exe_t ) * (unsigned int )old_size);
  free((void *)exe_array);
  exe_array = ptr;
  return;
}
}
void run_queue_job(cl_t *line ) 
{ short tmp ;

  {
  if ((int )exe_num >= (int )exe_array_size) {
    resize_exe_array();
  }
  (exe_array + (int )exe_num)->e_line = line;
  tmp = exe_num;
  exe_num = (short )((int )exe_num + 1);
  run_job(exe_array + (int )tmp);
  return;
}
}
void insert_nextexe(struct cl_t *line ) 
{ struct job_t *newjob ;
  struct job_t *j ;
  struct job_t *jprev ;
  struct job_t *old_entry ;
  void *tmp ;
  void *tmp___0 ;

  {
  if ((unsigned int )queue_base != (unsigned int )((void *)0)) {
    jprev = (struct job_t *)((void *)0);
    old_entry = (struct job_t *)((void *)0);
    j = queue_base;
    while ((unsigned int )j != (unsigned int )((void *)0)) {
      if ((unsigned int )j->j_line == (unsigned int )line) {
        old_entry = j;
        if ((unsigned int )jprev != (unsigned int )((void *)0)) {
          jprev->j_next = j->j_next;
          j = jprev;
        } else {
          queue_base = j->j_next;
          j = queue_base;
        }
        break;
      } else {
        jprev = j;
      }
      j = j->j_next;
    }
    jprev = (struct job_t *)((void *)0);
    if ((unsigned int )j == (unsigned int )((void *)0)) {
      j = queue_base;
    } else {
      if (line->cl_nextexe < (j->j_line)->cl_nextexe) {
        j = queue_base;
      }
    }
    while (1) {
      if ((unsigned int )j != (unsigned int )((void *)0)) {
        if (! (line->cl_nextexe >= (j->j_line)->cl_nextexe)) {
          break;
        }
      } else {
        break;
      }
      jprev = j;
      j = j->j_next;
    }
    if ((unsigned int )old_entry == (unsigned int )((void *)0)) {
      tmp = calloc(1U, sizeof(job_t ));
      newjob = (struct job_t *)tmp;
      if ((unsigned int )newjob == (unsigned int )((void *)0)) {
        die_e((char *)"Could not calloc.");
      }
      newjob->j_line = line;
    } else {
      newjob = old_entry;
    }
    newjob->j_next = j;
    if ((unsigned int )jprev == (unsigned int )((void *)0)) {
      queue_base = newjob;
    } else {
      jprev->j_next = newjob;
    }
  } else {
    tmp___0 = calloc(1U, sizeof(job_t ));
    newjob = (struct job_t *)tmp___0;
    if ((unsigned int )newjob == (unsigned int )((void *)0)) {
      die_e((char *)"Could not calloc.");
    }
    newjob->j_line = line;
    queue_base = newjob;
  }
  return;
}
}
void add_serial_job(struct cl_t *line , int info_fd ) 
{ short i ;
  cl_t **ptr ;
  short old_size ;
  void *tmp ;

  {
  if ((int )line->cl_option[1] & 8) {
    _L: 
    if ((int )line->cl_option[1] & 8) {
      if ((int )line->cl_numexe > 0) {
        send_msg_fd_debug(info_fd, (char *)"already in serial queue %s", line->cl_shell);
        return;
      }
    }
  } else {
    if ((int )line->cl_numexe >= 255) {
      send_msg_fd_debug(info_fd, (char *)"already in serial queue %s", line->cl_shell);
      return;
    } else {
      goto _L;
    }
  }
  send_msg_fd_debug(info_fd, (char *)"inserting in serial queue %s", line->cl_shell);
  if ((int )serial_num >= (int )serial_array_size) {
    if ((int )serial_num >= (int )serial_queue_max) {
      error_fd(info_fd, (char *)"Could not add job : serial queue is full (%d jobs). Consider using option serialonce, fcron\'s option -m and/or -q : %s", serial_queue_max, line->cl_shell);
      if ((int )line->cl_option[2] & 32) {
        mail_notrun(line, (char)3, (struct tm *)((void *)0));
      }
      return;
    } else {
      ptr = (cl_t **)((void *)0);
      old_size = serial_array_size;
      if (debug_opt) {
        Debug((char *)"Resizing serial_array");
      }
      serial_array_size = (short )((int )serial_array_size + 10);
      tmp = calloc((unsigned int )serial_array_size, sizeof(cl_t *));
      ptr = (cl_t **)tmp;
      if ((unsigned int )ptr == (unsigned int )((void *)0)) {
        die_e((char *)"could not calloc serial_array");
      }
      memcpy((void *)(ptr + (int )serial_array_index), (void *)serial_array, sizeof(cl_t *) * (unsigned int )((int )old_size - (int )serial_array_index));
      memcpy((void *)ptr, (void *)(serial_array + ((int )old_size - (int )serial_array_index)), sizeof(cl_t *) * (unsigned int )serial_array_index);
      serial_array_index = (short)0;
      free((void *)serial_array);
      serial_array = ptr;
    }
  }
  i = (short )((int )serial_array_index + (int )serial_num);
  if ((int )i >= (int )serial_array_size) {
    i = (short )((int )i - (int )serial_array_size);
  }
  *(serial_array + (int )i) = line;
  serial_num = (short )((int )serial_num + 1);
  line->cl_numexe = (unsigned char )((int )line->cl_numexe + 1);
  send_msg_fd_debug(info_fd, (char *)"serial num: %d size:%d index:%d curline:%d running:%d (%s)", serial_num, serial_array_size, serial_array_index, i, serial_running, line->cl_shell);
  return;
}
}
void add_lavg_job(struct cl_t *line , int info_fd ) 
{ struct lavg_t *ptr ;
  short old_size ;
  struct tm *ft ;
  struct tm ftime ;
  time_t begin_of_cur_int ;
  time_t end_of_cur_int ;
  time_t tmp ;
  void *tmp___0 ;

  {
  if ((int )line->cl_option[1] & 16) {
    if ((int )line->cl_numexe >= 255) {
      send_msg_fd_debug(info_fd, (char *)"already in lavg queue %s", line->cl_shell);
      return;
    } else {
      goto _L;
    }
  } else {
    _L: 
    if (! ((int )line->cl_option[1] & 16)) {
      if ((int )line->cl_numexe > 0) {
        send_msg_fd_debug(info_fd, (char *)"already in lavg queue %s", line->cl_shell);
        return;
      }
    }
  }
  send_msg_fd_debug(info_fd, (char *)"inserting in lavg queue %s", line->cl_shell);
  if ((int )lavg_num >= (int )lavg_array_size) {
    if ((int )lavg_num >= (int )lavg_queue_max) {
      error_fd(info_fd, (char *)"Could not add job : lavg queue is full (%d jobs). Consider using options lavgonce, until, strict and/or fcron\'s option -q.", lavg_queue_max, line->cl_shell);
      if ((int )line->cl_option[2] & 32) {
        mail_notrun(line, (char)3, (struct tm *)((void *)0));
      }
      return;
    } else {
      ptr = (struct lavg_t *)((void *)0);
      old_size = lavg_array_size;
      if (debug_opt) {
        Debug((char *)"Resizing lavg_array");
      }
      lavg_array_size = (short )((int )lavg_array_size + 10);
      tmp___0 = calloc((unsigned int )lavg_array_size, sizeof(lavg_t ));
      ptr = (struct lavg_t *)tmp___0;
      if ((unsigned int )ptr == (unsigned int )((void *)0)) {
        die_e((char *)"could not calloc lavg_array");
      }
      memcpy((void *)ptr, (void *)lavg_array, sizeof(lavg_t ) * (unsigned int )old_size);
      free((void *)lavg_array);
      lavg_array = ptr;
    }
  }
  (lavg_array + (int )lavg_num)->l_line = line;
  line->cl_numexe = (unsigned char )((int )line->cl_numexe + 1);
  line->cl_option[1] = (unsigned char )((int )line->cl_option[1] | 2);
  if ((int )line->cl_option[2] & 16) {
    _L___0: 
    if (line->cl_until > 0L) {
      (lavg_array + (int )lavg_num)->l_until = now + line->cl_until;
    } else {
      (lavg_array + (int )lavg_num)->l_until = 0L;
    }
  } else {
    if ((int )line->cl_runfreq == 1) {
      end_of_cur_int = 0L;
      begin_of_cur_int = line->cl_nextexe - (long )((int )(line->cl_file)->cf_tzdiff * 3600);
      ft = localtime(& begin_of_cur_int);
      memcpy((void *)(& ftime), (void *)ft, sizeof(struct tm ));
      goto_non_matching(line, & ftime, (char)1);
      tmp = mktime(& ftime);
      end_of_cur_int = tmp + (long )((int )(line->cl_file)->cf_tzdiff * 3600);
      if (line->cl_until > 0L) {
        if (line->cl_until + now < end_of_cur_int) {
          (lavg_array + (int )lavg_num)->l_until = line->cl_until + now;
        } else {
          (lavg_array + (int )lavg_num)->l_until = end_of_cur_int;
          line->cl_option[1] = (unsigned char )((int )line->cl_option[1] & -3);
        }
      } else {
        (lavg_array + (int )lavg_num)->l_until = end_of_cur_int;
        line->cl_option[1] = (unsigned char )((int )line->cl_option[1] & -3);
      }
    } else {
      goto _L___0;
    }
  }
  lavg_num = (short )((int )lavg_num + 1);
  return;
}
}
void wait_chld(void) 
{ short i ;
  int pid ;
  cl_t *line ;

  {
  i = (short)0;
  line = (cl_t *)((void *)0);
  while (1) {
    pid = wait3((union wait *)((void *)0), 1, (struct rusage *)((void *)0));
    if (! (pid > 0)) {
      break;
    }
    i = (short)0;
    while ((int )i < (int )exe_num) {
      if (pid == (exe_array + (int )i)->e_ctrl_pid) {
        if ((unsigned int )(exe_array + (int )i)->e_line == (unsigned int )((void *)0)) {
          if (debug_opt) {
            Debug((char *)"job finished: pid %d", pid);
          }
        } else {
          line = (exe_array + (int )i)->e_line;
          line->cl_numexe = (unsigned char )((int )line->cl_numexe - 1);
          (line->cl_file)->cf_running = (line->cl_file)->cf_running - 1;
          if ((int )line->cl_option[0] & 64) {
            line->cl_option[0] = (unsigned char )((int )line->cl_option[0] & -65);
            serial_running = (short )((int )serial_running - 1);
            if ((int )serial_running < (int )serial_max_running) {
              run_serial_job();
            }
          } else {
            if ((int )line->cl_option[0] & 32) {
              if ((int )line->cl_option[0] & 2) {
                goto _L;
              } else {
                serial_running = (short )((int )serial_running - 1);
                if ((int )serial_running < (int )serial_max_running) {
                  run_serial_job();
                }
              }
            } else {
              _L: 
              if ((int )line->cl_option[0] & 2) {
                if ((int )line->cl_option[0] & 32) {
                  lavg_serial_running = (short )((int )lavg_serial_running - 1);
                }
              }
            }
          }
        }
        exe_num = (short )((int )exe_num - 1);
        if ((int )i < (int )exe_num) {
          *(exe_array + (int )i) = *(exe_array + (int )exe_num);
          (exe_array + (int )exe_num)->e_line = (struct cl_t *)((void *)0);
        } else {
          (exe_array + (int )i)->e_line = (struct cl_t *)((void *)0);
        }
        break;
      }
      i = (short )((int )i + 1);
    }
  }
  return;
}
}
void wait_all(int *counter ) 
{ short i ;
  int pid ;

  {
  i = (short)0;
  if (debug_opt) {
    Debug((char *)"Waiting for all jobs");
  }
  while (1) {
    if (*counter > 0) {
      pid = wait3((union wait *)((void *)0), 0, (struct rusage *)((void *)0));
      if (! (pid > 0)) {
        break;
      }
    } else {
      break;
    }
    i = (short)0;
    while ((int )i < (int )exe_num) {
      if (pid == (exe_array + (int )i)->e_ctrl_pid) {
        if ((unsigned int )(exe_array + (int )i)->e_line == (unsigned int )((void *)0)) {
          if (debug_opt) {
            Debug((char *)"job finished: pid %d", pid);
          }
        } else {
          if (debug_opt) {
            Debug((char *)"job finished: %s", ((exe_array + (int )i)->e_line)->cl_shell);
          }
          ((exe_array + (int )i)->e_line)->cl_numexe = (unsigned char )((int )((exe_array + (int )i)->e_line)->cl_numexe - 1);
          (((exe_array + (int )i)->e_line)->cl_file)->cf_running = (((exe_array + (int )i)->e_line)->cl_file)->cf_running - 1;
          if ((int )((exe_array + (int )i)->e_line)->cl_option[0] & 64) {
            ((exe_array + (int )i)->e_line)->cl_option[0] = (unsigned char )((int )((exe_array + (int )i)->e_line)->cl_option[0] & -65);
          }
        }
        exe_num = (short )((int )exe_num - 1);
        if ((int )i < (int )exe_num) {
          *(exe_array + (int )i) = *(exe_array + (int )exe_num);
          (exe_array + (int )exe_num)->e_line = (struct cl_t *)((void *)0);
        } else {
          (exe_array + (int )i)->e_line = (struct cl_t *)((void *)0);
        }
        break;
      }
      i = (short )((int )i + 1);
    }
  }
  return;
}
}
int is_leap_year(int year ) 
{ int tmp ;

  {
  if (year % 4 == 0) {
    if (year % 100 != 0) {
      tmp = 1;
    } else {
      if (year % 400 == 0) {
        tmp = 1;
      } else {
        tmp = 0;
      }
    }
  } else {
    tmp = 0;
  }
  return (tmp);
}
}
int get_nb_mdays(int year , int mon ) 
{ int tmp ;

  {
  if (mon == 1) {
    tmp = is_leap_year(year);
    if (tmp) {
      return (29);
    } else {
      return (28);
    }
  } else {
    if (mon <= 6) {
      if (mon % 2 == 0) {
        return (31);
      } else {
        return (30);
      }
    } else {
      if (mon % 2 == 0) {
        return (30);
      } else {
        return (31);
      }
    }
  }
}
}
void set_wday(struct tm *date ) 
{ long nod ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int UNK ;

  {
  nod = 0L;
  i = date->tm_year - 1;
  while (i >= 100) {
    tmp___1 = is_leap_year(i + 1900);
    if (tmp___1) {
      tmp___0 = 366;
    } else {
      tmp___0 = 365;
    }
    nod = nod + (long )tmp___0;
    i = i - 1;
  }
  i = date->tm_mon - 1;
  while (i >= 0) {
    tmp___2 = get_nb_mdays(date->tm_year + 1900, i);
    nod = nod + (long )tmp___2;
    i = i - 1;
  }
  nod = nod + (long )(date->tm_mday - 1);
  date->tm_wday = UNK;
  if (date->tm_wday >= 7) {
    date->tm_wday = date->tm_wday - 7;
  }
  return;
}
}
void set_next_exe_notrun(struct cl_t *line , char context ) 
{ time_t previous_period ;
  time_t next_period ;
  struct tm *ft ;
  struct tm ftime ;
  struct tm last_nextexe ;
  char set_next_exe_opt ;
  time_t tmp ;

  {
  previous_period = 0L;
  next_period = 0L;
  ft = (struct tm *)((void *)0);
  set_next_exe_opt = (char)0;
  if ((int )context == 2) {
    previous_period = line->cl_nextexe - (long )((int )(line->cl_file)->cf_tzdiff * 3600);
    set_next_exe_opt = (char)1;
  } else {
    previous_period = now - (long )((int )(line->cl_file)->cf_tzdiff * 3600);
    set_next_exe_opt = (char)2;
  }
  ft = localtime(& previous_period);
  memcpy((void *)(& ftime), (void *)ft, sizeof(ftime));
  memcpy((void *)(& last_nextexe), (void *)ft, sizeof(last_nextexe));
  ftime.tm_sec = 0;
  goto_non_matching(line, & ftime, (char)0);
  tmp = mktime(& ftime);
  next_period = tmp + (long )((int )(line->cl_file)->cf_tzdiff * 3600);
  set_next_exe(line, set_next_exe_opt, -1);
  if (line->cl_nextexe >= next_period) {
    mail_notrun(line, context, & last_nextexe);
  }
  return;
}
}
void mail_notrun(struct cl_t *line , char context , struct tm *since ) 
{ int pid ;
  FILE *mailf ;
  struct tm *time2 ;
  struct tm time___0 ;
  int tmp ;

  {
  pid = 0;
  mailf = (FILE *)0;
  time2 = (struct tm *)((void *)0);
  pid = fork();
  switch (pid) {
  case -1: 
  error_e((char *)"Fork error : could not mail for not run %s", line->cl_shell);
  return;
  case 0: 
  break;
  default: ;
  if ((int )exe_num >= (int )exe_array_size) {
    resize_exe_array();
  }
  (exe_array + (int )exe_num)->e_line = (struct cl_t *)((void *)0);
  (exe_array + (int )exe_num)->e_ctrl_pid = pid;
  exe_num = (short )((int )exe_num + 1);
  return;
  }
  if ((int )context == 3) {
    time2 = localtime(& now);
  } else {
    time2 = localtime(& line->cl_nextexe);
  }
  memcpy((void *)(& time___0), (void *)time2, sizeof(time___0));
  mailf = create_mail(line, (char *)"Non-execution of fcron job");
  switch ((int )context) {
  case 2: 
  fprintf(mailf, (char *)"Line %s has not run since and including %d/%d/%d wday:%d %02d:%02d\ndue to system\'s down state.\n", line->cl_shell, since->tm_mon + 1, since->tm_mday, since->tm_year + 1900, since->tm_wday, since->tm_hour, since->tm_min);
  fprintf(mailf, (char *)"It will be next executed at %d/%d/%d wday:%d %02d:%02d\n", time___0.tm_mon + 1, time___0.tm_mday, time___0.tm_year + 1900, time___0.tm_wday, time___0.tm_hour, time___0.tm_min);
  break;
  case 1: 
  fprintf(mailf, (char *)"Line %s has not run since and including %d/%d/%d wday:%d %02d:%02d\n", line->cl_shell, since->tm_mon + 1, since->tm_mday, since->tm_year + 1900, since->tm_wday, since->tm_hour, since->tm_min);
  if (! (mailf->BLAST_FLAG == 1)) {
    BLAST_ERROR();
  }
  fprintf(mailf, (char *)"due to a too high system load average or too many lavg-serial jobs.\n");
  fprintf(mailf, (char *)"It will be next executed at %d/%d/%d wday:%d %02d:%02d\n", time___0.tm_mon + 1, time___0.tm_mday, time___0.tm_year + 1900, time___0.tm_wday, time___0.tm_hour, time___0.tm_min);
  break;
  case 3: 
  fprintf(mailf, (char *)"Line %s couldn\'t be added to lavg or serial queue which is full ( %d/%d/%d wday:%d %02d:%02d ).\n", line->cl_shell, time___0.tm_mon + 1, time___0.tm_mday, time___0.tm_year + 1900, time___0.tm_wday, time___0.tm_hour, time___0.tm_min);
  if (! (mailf->BLAST_FLAG == 1)) {
    BLAST_ERROR();
  }
  fprintf(mailf, (char *)"Consider using options lavgonce, until, strict, serialonce and/or fcron\'s option -m.\n");
  if (! (mailf->BLAST_FLAG == 1)) {
    BLAST_ERROR();
  }
  fprintf(mailf, (char *)"Note that job %s has not run.\n", line->cl_shell);
  break;
  }
  tmp = change_user(line);
  if (tmp < 0) {
    return;
  }
  launch_mailer(line, mailf);
  error((char *)"mail_notrun : launch_mailer failed");
  return;
}
}
time_t check_lavg(time_t lim ) 
{ time_t tts ;
  int i ;
  double l_avg[3] ;
  char *tmp ;
  time_t tmp___0 ;

  {
  tts = 0L;
  i = 0;
  l_avg[0] = (double )0;
  l_avg[1] = (double )0;
  l_avg[2] = (double )0;
  while (i < (int )lavg_num) {
    if (((lavg_array + i)->l_line)->cl_until > 0L) {
      goto _L;
    } else {
      if ((int )((lavg_array + i)->l_line)->cl_runfreq == 1) {
        _L: 
        if ((lavg_array + i)->l_until < now) {
          if ((int )((lavg_array + i)->l_line)->cl_option[1] & 2) {
            if (debug_opt) {
              Debug((char *)"until %s %d", ((lavg_array + i)->l_line)->cl_shell, (lavg_array + i)->l_until);
            }
            run_lavg_job(i);
          } else {
            if (! ((int )((lavg_array + i)->l_line)->cl_option[2] & 64)) {
              explain((char *)"Interval of execution exceeded : %s (not run)", ((lavg_array + i)->l_line)->cl_shell);
            }
            if ((int )((lavg_array + i)->l_line)->cl_option[0] & 1) {
              set_next_exe((lavg_array + i)->l_line, (char)2, -1);
            } else {
              if ((int )((lavg_array + i)->l_line)->cl_option[2] & 32) {
                set_next_exe_notrun((lavg_array + i)->l_line, (char)1);
              } else {
                set_next_exe((lavg_array + i)->l_line, (char)2, -1);
              }
            }
            ((lavg_array + i)->l_line)->cl_numexe = (unsigned char )((int )((lavg_array + i)->l_line)->cl_numexe - 1);
            lavg_num = (short )((int )lavg_num - 1);
            if (i < (int )lavg_num) {
              *(lavg_array + i) = *(lavg_array + (int )lavg_num);
              (lavg_array + (int )lavg_num)->l_line = (struct cl_t *)((void *)0);
            } else {
              (lavg_array + i)->l_line = (struct cl_t *)((void *)0);
            }
          }
        } else {
          i = i + 1;
        }
      } else {
        i = i + 1;
      }
    }
  }
  tts = time_to_sleep(lim);
  if ((int )lavg_num == 0) {
    return (tts);
  }
  i = getloadavg(l_avg, 3);
  if (i != 3) {
    if (debug_opt) {
      Debug((char *)"got only %d lavg values", i);
    }
  }
  if (debug_opt) {
    Debug((char *)"get_lavg: %lf, %lf, %lf", l_avg[0], l_avg[1], l_avg[2]);
  }
  l_avg[0] = l_avg[0] * (double )10;
  l_avg[1] = l_avg[1] * (double )10;
  l_avg[2] = l_avg[2] * (double )10;
  i = 0;
  while (i < (int )lavg_num) {
    if ((int )lavg_serial_running >= (int )serial_max_running) {
      if ((int )((lavg_array + i)->l_line)->cl_option[0] & 32) {
        i = i + 1;
        continue;
      }
    }
    if ((int )((lavg_array + i)->l_line)->cl_option[0] & 4) {
      _L___5: 
      if ((int )((lavg_array + i)->l_line)->cl_option[0] & 4) {
        if (l_avg[0] < (double )((lavg_array + i)->l_line)->cl_lavg[0]) {
          goto _L___1;
        } else {
          if (l_avg[1] < (double )((lavg_array + i)->l_line)->cl_lavg[1]) {
            goto _L___1;
          } else {
            if (l_avg[2] < (double )((lavg_array + i)->l_line)->cl_lavg[2]) {
              _L___1: 
              if (debug_opt) {
                if ((int )((lavg_array + i)->l_line)->cl_option[0] & 4) {
                  tmp = (char *)"or";
                } else {
                  tmp = (char *)"and";
                }
                Debug((char *)"lavg %s %s %.0f:%d %.0f:%d %.0f:%d", ((lavg_array + i)->l_line)->cl_shell, tmp, l_avg[0], ((lavg_array + i)->l_line)->cl_lavg[0], l_avg[1], ((lavg_array + i)->l_line)->cl_lavg[1], l_avg[2], ((lavg_array + i)->l_line)->cl_lavg[2]);
              }
              run_lavg_job(i);
            } else {
              i = i + 1;
            }
          }
        }
      } else {
        i = i + 1;
      }
    } else {
      if (l_avg[0] < (double )((lavg_array + i)->l_line)->cl_lavg[0]) {
        goto _L___6;
      } else {
        if ((int )((lavg_array + i)->l_line)->cl_lavg[0] == 0) {
          _L___6: 
          if (l_avg[1] < (double )((lavg_array + i)->l_line)->cl_lavg[1]) {
            goto _L___4;
          } else {
            if ((int )((lavg_array + i)->l_line)->cl_lavg[1] == 0) {
              _L___4: 
              if (l_avg[2] < (double )((lavg_array + i)->l_line)->cl_lavg[2]) {
                goto _L___1;
              } else {
                if ((int )((lavg_array + i)->l_line)->cl_lavg[2] == 0) {
                  goto _L___1;
                } else {
                  goto _L___5;
                }
              }
            } else {
              goto _L___5;
            }
          }
        } else {
          goto _L___5;
        }
      }
    }
  }
  if ((int )lavg_num == 0) {
    return (tts);
  } else {
    if (30L < tts) {
      tmp___0 = 30L;
    } else {
      tmp___0 = tts;
    }
    return (tmp___0);
  }
}
}
time_t time_to_sleep(time_t lim ) 
{ time_t tts ;
  time_t ti ;
  time_t tmp ;

  {
  tts = lim;
  tmp = time((time_t *)((void *)0));
  ti = tmp;
  if ((unsigned int )queue_base != (unsigned int )((void *)0)) {
    if ((queue_base->j_line)->cl_nextexe < lim) {
      tts = (queue_base->j_line)->cl_nextexe;
    }
  }
  tts = tts - ti;
  if (tts < 0L) {
    tts = 0L;
  }
  return (tts);
}
}
void sig_dfl(void) ;
void end_job(cl_t *line , int status , FILE *mailf , short mailpos ) ;
void die_mail_pame(cl_t *cl , int pamerrno , struct passwd *pas , char *str ) ;
void die_mail_pame(cl_t *cl , int pamerrno , struct passwd *pas , char *str ) 
{ char buf[175] ;
  size_t tmp ;
  FILE *mailf ;
  FILE *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  strncpy(buf, str, sizeof(buf) - 1U);
  tmp = strlen(buf);
  strncat(buf, (char *)" for \'%s\'", (sizeof(buf) - tmp) - 1U);
  buf[sizeof(buf) - 1U] = (char )'\000';
  if ((int )cl->cl_option[0] & 128) {
    die_pame(pamh, pamerrno, buf, cl->cl_shell);
  } else {
    tmp___0 = create_mail(cl, (char *)"Could not run fcron job");
    mailf = tmp___0;
    tmp___1 = fileno(mailf);
    tmp___2 = dup2(tmp___1, 1);
    if (tmp___2 != 1) {
      die_e((char *)"dup2() error");
    } else {
      tmp___3 = dup2(1, 2);
      if (tmp___3 != 2) {
        die_e((char *)"dup2() error");
      }
    }
    foreground = (char)1;
    error_pame(pamh, pamerrno, buf, cl->cl_shell);
    error((char *)"Job \'%s\' has *not* run.", cl->cl_shell);
    foreground = (char)0;
    pam_end(pamh, pamerrno);
    tmp___4 = initgroups(pas->pw_name, pas->pw_gid);
    if (tmp___4 < 0) {
      die_e((char *)"initgroups failed: %s", pas->pw_name);
    }
    tmp___5 = setgid(pas->pw_gid);
    if (tmp___5 < 0) {
      die((char *)"setgid failed: %s %d", pas->pw_name, pas->pw_gid);
    }
    tmp___6 = setuid(pas->pw_uid);
    if (tmp___6 < 0) {
      die((char *)"setuid failed: %s %d", pas->pw_name, pas->pw_uid);
    }
    launch_mailer(cl, mailf);
  }
  return;
}
}
int change_user(struct cl_t *cl ) 
{ struct passwd *pas ;
  int retcode ;
  char **env ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char **tmp ;

  {
  retcode = 0;
  umask(saved_umask);
  pas = getpwnam(cl->cl_runas);
  if ((unsigned int )pas == (unsigned int )((void *)0)) {
    die((char *)"failed to get passwd fields for user \"%s\"", cl->cl_runas);
  }
  setenv((char *)"USER", pas->pw_name, 1);
  setenv((char *)"HOME", pas->pw_dir, 1);
  setenv((char *)"SHELL", pas->pw_shell, 1);
  retcode = pam_start((char *)"fcron", pas->pw_name, & apamconv, & pamh);
  if (retcode != 0) {
    die_pame(pamh, retcode, (char *)"Could not start PAM for %s", cl->cl_shell);
  }
  retcode = pam_authenticate(pamh, 32768);
  if (retcode != 0) {
    die_mail_pame(cl, retcode, pas, (char *)"Could not authenticate PAM user");
  }
  retcode = pam_acct_mgmt(pamh, 32768);
  if (retcode != 0) {
    die_mail_pame(cl, retcode, pas, (char *)"Could not init PAM account management");
  }
  retcode = pam_setcred(pamh, 32770);
  if (retcode != 0) {
    die_mail_pame(cl, retcode, pas, (char *)"Could not set PAM credentials");
  }
  retcode = pam_open_session(pamh, 32768);
  if (retcode != 0) {
    die_mail_pame(cl, retcode, pas, (char *)"Could not open PAM session");
  }
  tmp = pam_getenvlist(pamh);
  env = tmp;
  while (1) {
    if (env) {
      if (! *env) {
        break;
      }
    } else {
      break;
    }
    tmp___0 = putenv(*env);
    if (tmp___0) {
      die_e((char *)"Could not copy PAM environment");
    }
    env = env + 1;
  }
  xcloselog();
  tmp___1 = initgroups(pas->pw_name, pas->pw_gid);
  if (tmp___1 < 0) {
    die_e((char *)"initgroups failed: %s", pas->pw_name);
  }
  tmp___2 = setgid(pas->pw_gid);
  if (tmp___2 < 0) {
    die((char *)"setgid failed: %s %d", pas->pw_name, pas->pw_gid);
  }
  tmp___3 = setuid(pas->pw_uid);
  if (tmp___3 < 0) {
    die((char *)"setuid failed: %s %d", pas->pw_name, pas->pw_uid);
  }
  return ((int )pas->pw_uid);
}
}
void sig_dfl(void) 
{ 

  {
  signal(15, (void (*)(int  ))0);
  signal(17, (void (*)(int  ))0);
  signal(1, (void (*)(int  ))0);
  signal(10, (void (*)(int  ))0);
  signal(12, (void (*)(int  ))0);
  signal(13, (void (*)(int  ))0);
  return;
}
}
FILE *create_mail(struct cl_t *line , char *subject ) 
{ int mailfd ;
  int tmp ;
  FILE *mailf ;
  FILE *tmp___0 ;
  char hostname[128] ;
  char complete_adr ;
  int i ;
  int tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  tmp = temp_file((char **)((void *)0));
  mailfd = tmp;
  tmp___0 = fdopen(mailfd, (char *)"r+");
  tmp___0->BLAST_FLAG = 1;
  mailf = tmp___0;
  complete_adr = (char)0;
  if ((unsigned int )mailf == (unsigned int )((void *)0)) {
    die_e((char *)"Could not fdopen() mailfd");
  }
  if (! (mailf->BLAST_FLAG == 1)) {
    BLAST_ERROR();
  }
  fprintf(mailf, (char *)"To: %s", line->cl_mailto);
  tmp___1 = gethostname(hostname, sizeof(hostname));
  if (tmp___1 != 0) {
    error_e((char *)"Could not get hostname");
    hostname[0] = (char )'\000';
  } else {
    hostname[127] = (char )'\000';
    i = 0;
    while ((int )*(line->cl_mailto + i) != 0) {
      if ((int )*(line->cl_mailto + i) == 64) {
        complete_adr = (char)1;
        break;
      }
      i = i + 1;
    }
    if (! complete_adr) {
      if (! (mailf->BLAST_FLAG == 1)) {
        BLAST_ERROR();
      }
      fprintf(mailf, (char *)"@%s", hostname);
    }
  }
  if (subject) {
    if ((int )hostname[0] != 0) {
      tmp___2 = hostname;
    } else {
      tmp___2 = (char *)"?";
    }
    if (! (mailf->BLAST_FLAG == 1)) {
      BLAST_ERROR();
    }
    fprintf(mailf, (char *)"\nSubject: fcron <%s@%s> %s: %s\n\n", (line->cl_file)->cf_user, tmp___2, subject, line->cl_shell);
  } else {
    if ((int )hostname[0] != 0) {
      tmp___3 = hostname;
    } else {
      tmp___3 = (char *)"?";
    }
    if (! (mailf->BLAST_FLAG == 1)) {
      BLAST_ERROR();
    }
    fprintf(mailf, (char *)"\nSubject: fcron <%s@%s> %s\n\n", (line->cl_file)->cf_user, tmp___3, line->cl_shell);
  }
  return (mailf);
}
}
void run_job(struct exe_t *exeent ) 
{ pid_t pid ;
  cl_t *line ;
  int pipe_pid_fd[2] ;
  int i ;
  int j ;
  int tmp ;
  char *curshell ;
  char *home ;
  env_t *env ;
  FILE *mailf ;
  int status ;
  int to_stdout ;
  int tmp___0 ;
  int pipe_fd[2] ;
  short mailpos ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  FILE *tmp___8 ;
  FILE *tmp___9 ;
  FILE *tmp___10 ;
  FILE *tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  int tmp___19 ;
  ssize_t tmp___20 ;
  char mailbuf[196] ;
  FILE *pipef ;
  FILE *tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  int *tmp___24 ;
  long tmp___25 ;
  FILE *tmp___26 ;
  FILE *tmp___27 ;

  {
  line = exeent->e_line;
  i = 0;
  tmp = pipe(pipe_pid_fd);
  if (tmp != 0) {
    error_e((char *)"pipe(pipe_pid_fd) : setting job_pid to -1");
    exeent->e_job_pid = -1;
  }
  pid = fork();
  switch (pid) {
  case -1: 
  break;
  case 0: 
  mailf = (FILE *)((void *)0);
  status = 0;
  if (foreground) {
    if ((int )line->cl_option[3] & 2) {
      tmp___0 = 1;
    }
  } else {
    tmp___0 = 0;
  }
  to_stdout = tmp___0;
  mailpos = (short)0;
  if (debug_opt) {
    if ((int )line->cl_option[3] & 2) {
      tmp___1 = (char *)"stdout";
    } else {
      tmp___1 = (char *)"normal";
    }
    if (foreground) {
      tmp___2 = (char *)"running in foreground";
    } else {
      tmp___2 = (char *)"running in background";
    }
    if (to_stdout) {
      tmp___3 = (char *)"stdout";
    } else {
      tmp___3 = (char *)"file";
    }
  }
  if (! to_stdout) {
    if (! ((int )line->cl_option[0] & 128)) {
      mailf = create_mail(line, (char *)((void *)0));
      tmp___25 = ftell(mailf);
      mailpos = (short )tmp___25;
      tmp___4 = pipe(pipe_fd);
      if (tmp___4 != 0) {
        die_e((char *)"could not pipe()");
      }
    }
  }
  tmp___5 = change_user(line);
  if (tmp___5 < 0) {
    return;
  }
  sig_dfl();
  pid = fork();
  switch (pid) {
  case -1: 
  break;
  case 0: 
  if (! to_stdout) {
    if ((int )line->cl_option[0] & 128) {
      if (foreground) {
        tmp___26 = get_stdout();
        tmp___10 = tmp___26;
        tmp___10->BLAST_FLAG = 1;
        freopen((char *)"/dev/null", (char *)"w", tmp___10);
        tmp___27 = get_stderr();
        tmp___11 = tmp___27;
        tmp___11->BLAST_FLAG = 1;
        freopen((char *)"/dev/null", (char *)"w", tmp___11);
      }
    } else {
      tmp___6 = dup2(pipe_fd[1], 1);
      if (tmp___6 != 1) {
        die_e((char *)"dup2() error");
      } else {
        tmp___7 = dup2(1, 2);
        if (tmp___7 != 2) {
          die_e((char *)"dup2() error");
        }
      }
      close(pipe_fd[0]);
      close(pipe_fd[1]);
      tmp___8 = get_stdout();
      tmp___8->BLAST_FLAG = 1;
      setlinebuf(tmp___8);
      tmp___9 = get_stderr();
      tmp___9->BLAST_FLAG = 1;
      setlinebuf(tmp___9);
    }
  }
  foreground = (char)1;
  if ((int )line->cl_nice != 0) {
    tmp___12 = __errno_location();
    *tmp___12 = 0;
    tmp___13 = nice((int )line->cl_nice);
    if (tmp___13 == -1) {
      tmp___14 = __errno_location();
      if (*tmp___14 != 0) {
        error_e((char *)"could not set nice value");
      }
    }
  }
  xcloselog();
  env = (line->cl_file)->cf_env_base;
  while (env) {
    tmp___15 = putenv(env->e_val);
    if (tmp___15 != 0) {
      error((char *)"could not putenv()");
    }
    env = env->e_next;
  }
  home = getenv((char *)"HOME");
  if ((unsigned int )home != (unsigned int )((void *)0)) {
    tmp___17 = chdir(home);
    if (tmp___17 != 0) {
      error_e((char *)"Could not chdir to HOME dir \"%s\"", home);
      tmp___16 = chdir((char *)"/");
      if (tmp___16 < 0) {
        die_e((char *)"Could not chdir to HOME dir /");
      }
    }
  }
  curshell = getenv((char *)"SHELL");
  if ((unsigned int )curshell == (unsigned int )((void *)0)) {
    curshell = shell;
  } else {
    tmp___19 = access(curshell, 1);
    if (tmp___19 != 0) {
      tmp___18 = __errno_location();
      if (*tmp___18 == 2) {
        error((char *)"shell \"%s\" : no file or directory. SHELL set to %s", curshell, shell);
      } else {
        error_e((char *)"shell \"%s\" not valid : SHELL set to %s", curshell, shell);
      }
      curshell = shell;
    }
  }
  execl(curshell, curshell, "-c", line->cl_shell, (void *)0);
  error_e((char *)"Can\'t find \"%s\". Trying a execlp(\"sh\",...)", curshell);
  execlp((char *)"sh", (char *)"sh", "-c", line->cl_shell, (void *)0);
  die_e((char *)"execl() \"%s -c %s\" error", curshell, line->cl_shell);
  default: 
  close(pipe_fd[1]);
  close(pipe_pid_fd[0]);
  tmp___20 = write(pipe_pid_fd[1], (void *)(& pid), sizeof(pid));
  if (tmp___20 < 0) {
    error_e((char *)"could not write child pid to pipe_pid_fd[1]");
  }
  close(pipe_pid_fd[1]);
  if (! ((int )line->cl_option[2] & 64)) {
    explain((char *)"Job %s started for user %s (pid %d)", line->cl_shell, (line->cl_file)->cf_user, pid);
  }
  if (! to_stdout) {
    if (! ((int )line->cl_option[0] & 128)) {
      tmp___21 = fdopen(pipe_fd[0], (char *)"r");
      tmp___21->BLAST_FLAG = 1;
      pipef = tmp___21;
      if ((unsigned int )pipef == (unsigned int )((void *)0)) {
        die_e((char *)"Could not fdopen() pipe_fd[0]");
      }
      mailbuf[sizeof(mailbuf) - 1U] = (char )'\000';
      while (1) {
        if (! (pipef->BLAST_FLAG == 1)) {
          BLAST_ERROR();
          break;
        }
        tmp___23 = fgets(mailbuf, (int )sizeof(mailbuf), pipef);
      }
      if (! ((unsigned int )tmp___23 != (unsigned int )((void *)0))) {
        break;
      }
      tmp___22 = fputs(mailbuf, mailf);
      if (tmp___22 < 0) {
        warn((char *)"fputs() failed to write to mail file for job %s (pid %d)", line->cl_shell, pid);
      }
    }
    if (pipef->BLAST_FLAG == 1) {
      pipef->BLAST_FLAG = 0;
    } else {
      BLAST_ERROR();
    }
  }
  fclose(pipef);
  }
  while (1) {
    pid = wait3((union wait *)(& status), 0, (struct rusage *)((void *)0));
    if (! (pid > 0)) {
      break;
    }
    end_job(line, status, mailf, mailpos);
  }
  default: 
  close(pipe_pid_fd[1]);
  exeent->e_ctrl_pid = pid;
  (line->cl_file)->cf_running = (line->cl_file)->cf_running + 1;
  while ((unsigned int )i < sizeof(pid_t )) {
    j = read(pipe_pid_fd[0], (void *)((char *)(& exeent->e_job_pid) + i), sizeof(pid_t ));
    if (j <= 0) {
      tmp___24 = __errno_location();
      if (*tmp___24 != 4) {
        error_e((char *)"Could not read job pid : setting it to -1");
        exeent->e_job_pid = -1;
        break;
      }
    }
    i = i + j;
  }
  close(pipe_pid_fd[0]);
  }
  return;
}
}
void end_job(cl_t *line , int status , FILE *mailf , short mailpos ) 
{ char mail_output ;
  char *m ;
  int tmp ;
  long tmp___0 ;
  union __anonunion___u_47 u__u ;
  union __anonunion___u_48 u__u___0 ;
  union __anonunion___u_49 u__u___1 ;
  union __anonunion___u_50 u__u___2 ;
  union __anonunion___u_51 u__u___3 ;
  union __anonunion___u_52 u__u___4 ;
  int x__status ;
  union __anonunion___u_53 u__u___5 ;
  int tmp___1 ;
  union __anonunion___u_54 u__u___6 ;
  union __anonunion___u_55 u__u___7 ;
  union __anonunion___u_56 u__u___8 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  if ((unsigned int )mailf != (unsigned int )((void *)0)) {
    if ((int )line->cl_option[1] & 1) {
      mail_output = (char)1;
    } else {
      if ((int )line->cl_option[0] & 128) {
        mail_output = (char)0;
      } else {
        tmp = fseek(mailf, 0L, 2);
        if (tmp == 0) {
          tmp___0 = ftell(mailf);
          if (tmp___0 > (long )mailpos) {
            mail_output = (char)1;
          } else {
            goto _L;
          }
        } else {
          _L: 
          u__u.__in = status;
          if ((u__u.__i & 127) == 0) {
            u__u___0.__in = status;
            if ((u__u___0.__i & 65280) >> 8 == 0) {
              mail_output = (char)0;
            } else {
              mail_output = (char)1;
            }
          } else {
            mail_output = (char)1;
          }
        }
      }
    }
  } else {
    mail_output = (char)0;
  }
  if ((int )mail_output == 1) {
    m = (char *)" (mailing output)";
  } else {
    m = (char *)"";
  }
  u__u___7.__in = status;
  if ((u__u___7.__i & 127) == 0) {
    u__u___8.__in = status;
    if ((u__u___8.__i & 65280) >> 8 == 0) {
      if (! ((int )line->cl_option[2] & 64)) {
        explain((char *)"Job %s completed%s", line->cl_shell, m);
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: 
    u__u___6.__in = status;
    if ((u__u___6.__i & 127) == 0) {
      u__u___1.__in = status;
      warn((char *)"Job %s terminated (exit status: %d)%s", line->cl_shell, (u__u___1.__i & 65280) >> 8, m);
      if ((unsigned int )mailf != (unsigned int )((void *)0)) {
        u__u___2.__in = status;
        if (! (mailf->BLAST_FLAG == 1)) {
          BLAST_ERROR();
        }
        fprintf(mailf, (char *)"Job %s terminated (exit status: %d)%s", line->cl_shell, (u__u___2.__i & 65280) >> 8, m);
      }
    } else {
      u__u___5.__in = status;
      x__status = u__u___5.__i;
      if ((x__status & 255) == 127) {
        tmp___1 = 0;
      } else {
        if ((x__status & 127) == 0) {
          tmp___1 = 0;
        } else {
          tmp___1 = 1;
        }
      }
      if (tmp___1) {
        u__u___3.__in = status;
        error((char *)"Job %s terminated due to signal %d%s", line->cl_shell, u__u___3.__i & 127, m);
        if ((unsigned int )mailf != (unsigned int )((void *)0)) {
          u__u___4.__in = status;
          if (! (mailf->BLAST_FLAG == 1)) {
            BLAST_ERROR();
          }
          fprintf(mailf, (char *)"Job %s terminated due to signal %d%s", line->cl_shell, u__u___4.__i & 127, m);
        }
      } else {
        error((char *)"Job %s terminated abnormally %s", line->cl_shell, m);
        if ((unsigned int )mailf != (unsigned int )((void *)0)) {
          if (! (mailf->BLAST_FLAG == 1)) {
            BLAST_ERROR();
          }
          fprintf(mailf, (char *)"Job %s terminated abnormally %s", line->cl_shell, m);
        }
      }
    }
  }
  pam_setcred(pamh, 32772);
  tmp___2 = pam_close_session(pamh, 32768);
  pam_end(pamh, tmp___2);
  if ((int )mail_output == 1) {
    launch_mailer(line, mailf);
    die_e((char *)"Internal error: launch_mailer returned");
  }
  if ((unsigned int )mailf != (unsigned int )((void *)0)) {
    tmp___3 = fclose(mailf);
    if (tmp___3 != 0) {
      die_e((char *)"Can\'t close file mailf");
    }
  }
  exit(0);
  return;
}
}
void launch_mailer(struct cl_t *line , FILE *mailf ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  foreground = (char)0;
  tmp = fseek(mailf, 0L, 0);
  if (tmp != 0) {
    die_e((char *)"Can\'t fseek()");
  }
  tmp___0 = fileno(mailf);
  tmp___1 = dup2(tmp___0, 0);
  if (tmp___1 != 0) {
    die_e((char *)"Can\'t dup2(fileno(mailf))");
  }
  xcloselog();
  tmp___2 = chdir((char *)"/");
  if (tmp___2 < 0) {
    die_e((char *)"Could not chdir to /");
  }
  execl(sendmail, sendmail, "-Ffcron", "-odi", line->cl_mailto, (void *)0);
  error_e((char *)"Can\'t find \"%s\". Trying a execlp(\"sendmail\")", sendmail);
  execlp((char *)"sendmail", (char *)"sendmail", "-Ffcron", "-odi", line->cl_mailto, (void *)0);
  die_e((char *)"Can\'t exec /usr/lib/sendmail");
  return;
}
}
int read_file(char *file_name , cf_t *cf ) ;
int add_line_to_file(cl_t *cl , cf_t *cf , uid_t runas , char *runas_str , time_t t_save ) ;
int read_strn(int fd , char **str , short size ) ;
int read_type(int fd , short *type , short *size ) ;
void synchronize_file(char *file_name ) ;
void reload_all(char *dir_name ) 
{ cf_t *f ;

  {
  f = (cf_t *)((void *)0);
  explain((char *)"Removing current configuration from memory");
  f = file_base;
  while ((unsigned int )f != (unsigned int )((void *)0)) {
    if (f->cf_running > 0) {
      wait_all(& f->cf_running);
    }
    save_file(f);
    delete_file(f->cf_user);
    f = file_base;
  }
  synchronize_dir(dir_name);
  return;
}
}
void synchronize_dir(char *dir_name ) 
{ list_t *rm_list ;
  list_t *new_list ;
  list_t *file_list ;
  list_t *list_cur ;
  DIR *dir ;
  struct dirent *den ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  struct passwd *tmp___7 ;
  int tmp___8 ;
  struct passwd *tmp___9 ;
  int tmp___10 ;
  list_t *l ;
  list_t *next ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;

  {
  rm_list = (list_t *)((void *)0);
  new_list = (list_t *)((void *)0);
  file_list = (list_t *)((void *)0);
  list_cur = (list_t *)((void *)0);
  tmp = strcmp(dir_name, (char *)".");
  if (tmp == 0) {
    explain((char *)"updating configuration from %s", fcrontabs);
  } else {
    explain((char *)"updating configuration from %s", dir_name);
  }
  dir = opendir((char *)".");
  if (dir) {
    while (1) {
      den = readdir(dir);
      if (! den) {
        break;
      }
      tmp___2 = strncmp(den->d_name, (char *)"rm.", 3U);
      if (tmp___2 == 0) {
        tmp___11 = calloc(1U, sizeof(list_t ));
        list_cur = (list_t *)tmp___11;
        if ((unsigned int )list_cur == (unsigned int )((void *)0)) {
          die_e((char *)"Could not calloc.");
        }
        list_cur->str = strdup2(den->d_name);
        list_cur->next = rm_list;
        rm_list = list_cur;
      } else {
        tmp___1 = strncmp(den->d_name, (char *)"new.", 4U);
        if (tmp___1 == 0) {
          tmp___12 = calloc(1U, sizeof(list_t ));
          list_cur = (list_t *)tmp___12;
          if ((unsigned int )list_cur == (unsigned int )((void *)0)) {
            die_e((char *)"Could not calloc.");
          }
          list_cur->str = strdup2(den->d_name);
          list_cur->next = new_list;
          new_list = list_cur;
        } else {
          tmp___0 = strchr(den->d_name, '.');
          if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
            continue;
          } else {
            if ((unsigned int )file_base == (unsigned int )((void *)0)) {
              tmp___13 = calloc(1U, sizeof(list_t ));
              list_cur = (list_t *)tmp___13;
              if ((unsigned int )list_cur == (unsigned int )((void *)0)) {
                die_e((char *)"Could not calloc.");
              }
              list_cur->str = strdup2(den->d_name);
              list_cur->next = file_list;
              file_list = list_cur;
            }
          }
        }
      }
    }
    closedir(dir);
  } else {
    die((char *)"Unable to open current dir!");
  }
  list_cur = rm_list;
  while (list_cur) {
    explain((char *)"removing file %s", list_cur->str + 3);
    delete_file(list_cur->str + 3);
    tmp___3 = remove(list_cur->str + 3);
    if (tmp___3 != 0) {
      tmp___4 = __errno_location();
      if (*tmp___4 != 2) {
        error_e((char *)"Could not remove %s", list_cur->str + 3);
      }
    }
    tmp___5 = remove(list_cur->str);
    if (tmp___5 != 0) {
      tmp___6 = __errno_location();
      if (*tmp___6 != 2) {
        error_e((char *)"Could not remove %s", list_cur->str);
      }
    }
    list_cur = list_cur->next;
  }
  list_cur = file_list;
  while (list_cur) {
    tmp___7 = getpwnam(list_cur->str);
    if (tmp___7) {
      explain((char *)"adding file %s", list_cur->str);
      synchronize_file(list_cur->str);
    } else {
      tmp___8 = strcmp(list_cur->str, (char *)"systab");
      if (tmp___8 == 0) {
        explain((char *)"adding file %s", list_cur->str);
        synchronize_file(list_cur->str);
      } else {
        error((char *)"ignoring file \"%s\" : not in passwd file.", list_cur->str);
      }
    }
    list_cur = list_cur->next;
  }
  list_cur = new_list;
  while (list_cur) {
    tmp___9 = getpwnam(list_cur->str + 4);
    if (tmp___9) {
      explain((char *)"adding new file %s", list_cur->str + 4);
      synchronize_file(list_cur->str);
    } else {
      tmp___10 = strcmp(list_cur->str + 4, (char *)"systab");
      if (tmp___10 == 0) {
        explain((char *)"adding new file %s", list_cur->str + 4);
        synchronize_file(list_cur->str);
      } else {
        error((char *)"ignoring file %s : not in passwd file.", list_cur->str + 4);
      }
    }
    list_cur = list_cur->next;
  }
  l = (list_t *)((void *)0);
  next = (list_t *)((void *)0);
  next = rm_list;
  while (1) {
    l = next;
    if (! ((unsigned int )l != (unsigned int )((void *)0))) {
      break;
    }
    next = l->next;
    free((void *)l->str);
    free((void *)l);
  }
  next = new_list;
  while (1) {
    l = next;
    if (! ((unsigned int )l != (unsigned int )((void *)0))) {
      break;
    }
    next = l->next;
    free((void *)l->str);
    free((void *)l);
  }
  next = file_list;
  while (1) {
    l = next;
    if (! ((unsigned int )l != (unsigned int )((void *)0))) {
      break;
    }
    next = l->next;
    free((void *)l->str);
    free((void *)l);
  }
  return;
}
}
void synchronize_file(char *file_name ) 
{ cf_t *cur_f ;
  char *user ;
  cf_t *prev ;
  int tmp ;
  cf_t *old ;
  cl_t *old_l ;
  cl_t *new_l ;
  size_t size ;
  int tmp___0 ;
  struct tm *ftime ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;

  {
  cur_f = (cf_t *)((void *)0);
  user = (char *)((void *)0);
  tmp___7 = strchr(file_name, '.');
  if ((unsigned int )tmp___7 != (unsigned int )((void *)0)) {
    prev = (cf_t *)((void *)0);
    user = file_name + 4;
    cur_f = file_base;
    while (cur_f) {
      tmp = strcmp(user, cur_f->cf_user);
      if (tmp == 0) {
        break;
      }
      prev = cur_f;
      cur_f = cur_f->cf_next;
    }
    if ((unsigned int )cur_f != (unsigned int )((void *)0)) {
      old = (cf_t *)((void *)0);
      old_l = (cl_t *)((void *)0);
      new_l = (cl_t *)((void *)0);
      size = 18U;
      old = cur_f;
      tmp___8 = calloc(1U, sizeof(cf_t ));
      cur_f = (cf_t *)tmp___8;
      if ((unsigned int )cur_f == (unsigned int )((void *)0)) {
        die_e((char *)"Could not calloc.");
      }
      tmp___0 = read_file(file_name, cur_f);
      if (tmp___0 != 0) {
        return;
      }
      if ((unsigned int )prev != (unsigned int )((void *)0)) {
        prev->cf_next = old->cf_next;
        old->cf_next = file_base;
        file_base = old;
      }
      new_l = cur_f->cf_line_base;
      while (new_l) {
        old_l = old->cf_line_base;
        while (old_l) {
          tmp___1 = strcmp(new_l->cl_shell, old_l->cl_shell);
          if (tmp___1 == 0) {
            if ((int )new_l->cl_option[0] & 1) {
              if (new_l->cl_timefreq == old_l->cl_timefreq) {
                goto _L;
              } else {
                goto _L___0;
              }
            } else {
              _L___0: 
              if (! ((int )new_l->cl_option[0] & 1)) {
                tmp___2 = memcmp((void *)(& new_l->cl_mins), (void *)(& old_l->cl_mins), size);
                if (tmp___2 == 0) {
                  if (((int )new_l->cl_option[0] & 8) == ((int )old_l->cl_option[0] & 8)) {
                    _L: 
                    if ((int )new_l->cl_runfreq == (int )old_l->cl_runfreq) {
                      new_l->cl_remain = old_l->cl_remain;
                    }
                    if ((int )(new_l->cl_file)->cf_tzdiff != (int )(old_l->cl_file)->cf_tzdiff) {
                      if ((old_l->cl_nextexe - (long )(old_l->cl_file)->cf_tzdiff) + (long )(new_l->cl_file)->cf_tzdiff > now) {
                        new_l->cl_nextexe = (old_l->cl_nextexe - (long )(old_l->cl_file)->cf_tzdiff) + (long )(new_l->cl_file)->cf_tzdiff;
                      } else {
                        new_l->cl_nextexe = old_l->cl_nextexe;
                      }
                    } else {
                      new_l->cl_nextexe = old_l->cl_nextexe;
                    }
                    insert_nextexe(new_l);
                    if (debug_opt) {
                      ftime = localtime(& new_l->cl_nextexe);
                      if (debug_opt) {
                        Debug((char *)"  from last conf: %s next exec %d/%d/%d wday:%d %02d:%02d", new_l->cl_shell, ftime->tm_mon + 1, ftime->tm_mday, ftime->tm_year + 1900, ftime->tm_wday, ftime->tm_hour, ftime->tm_min);
                      }
                    }
                    break;
                  }
                }
              }
            }
          }
          old_l = old_l->cl_next;
        }
        new_l = new_l->cl_next;
      }
      delete_file(user);
      cur_f->cf_next = file_base;
      file_base = cur_f;
      save_file(cur_f);
      tmp___3 = remove(file_name);
      if (tmp___3 != 0) {
        error_e((char *)"could not remove %s", file_name);
      }
    } else {
      tmp___9 = calloc(1U, sizeof(cf_t ));
      cur_f = (cf_t *)tmp___9;
      if ((unsigned int )cur_f == (unsigned int )((void *)0)) {
        die_e((char *)"Could not calloc.");
      }
      tmp___4 = read_file(file_name, cur_f);
      if (tmp___4 != 0) {
        return;
      }
      cur_f->cf_next = file_base;
      file_base = cur_f;
      save_file(cur_f);
      tmp___5 = remove(file_name);
      if (tmp___5 != 0) {
        error_e((char *)"could not remove %s", file_name);
      }
    }
  } else {
    tmp___10 = calloc(1U, sizeof(cf_t ));
    cur_f = (cf_t *)tmp___10;
    if ((unsigned int )cur_f == (unsigned int )((void *)0)) {
      die_e((char *)"Could not calloc.");
    }
    tmp___6 = read_file(file_name, cur_f);
    if (tmp___6 != 0) {
      return;
    }
    cur_f->cf_next = file_base;
    file_base = cur_f;
  }
  return;
}
}
int read_strn(int fd , char **str , short size ) 
{ ssize_t tmp ;
  void *tmp___0 ;

  {
  tmp___0 = calloc((unsigned int )((int )size + 1), sizeof(char ));
  *str = (char *)tmp___0;
  if ((unsigned int )*str == (unsigned int )((void *)0)) {
    goto err;
  }
  tmp = read(fd, (void *)*str, (unsigned int )size);
  if (tmp < (int )size) {
    goto err;
  }
  *(*str + (int )size) = (char )'\000';
  return (0);
  err: 
  if (*str) {
    free((void *)*str);
  }
  *str = (char *)((void *)0);
  return (-1);
}
}
int read_type(int fd , short *type , short *size ) 
{ ssize_t tmp ;
  ssize_t tmp___0 ;

  {
  tmp = read(fd, (void *)type, sizeof(short ));
  if ((unsigned int )tmp < sizeof(short )) {
    goto err;
  }
  tmp___0 = read(fd, (void *)size, sizeof(short ));
  if ((unsigned int )tmp___0 < sizeof(short )) {
    goto err;
  }
  return (0);
  err: 
  return (-1);
}
}
int read_file(char *file_name , cf_t *cf ) 
{ FILE *ff ;
  cl_t *cl ;
  env_t *env ;
  char buf[1024] ;
  long bufi ;
  time_t t_save ;
  uid_t runas ;
  char *runas_str ;
  struct stat file_stat ;
  struct passwd *pass ;
  short type ;
  short size ;
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  ssize_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  ssize_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  ssize_t tmp___24 ;
  int tmp___25 ;
  ssize_t tmp___26 ;
  int tmp___27 ;
  ssize_t tmp___28 ;
  int tmp___29 ;
  ssize_t tmp___30 ;
  int tmp___31 ;
  ssize_t tmp___32 ;
  int tmp___33 ;
  ssize_t tmp___34 ;
  int tmp___35 ;
  ssize_t tmp___36 ;
  int tmp___37 ;
  ssize_t tmp___38 ;
  int tmp___39 ;
  ssize_t tmp___40 ;
  int tmp___41 ;
  ssize_t tmp___42 ;
  int tmp___43 ;
  ssize_t tmp___44 ;
  int tmp___45 ;
  ssize_t tmp___46 ;
  int tmp___47 ;
  ssize_t tmp___48 ;
  int tmp___49 ;
  ssize_t tmp___50 ;
  int tmp___51 ;
  ssize_t tmp___52 ;
  int tmp___53 ;
  int i ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  void *tmp___58 ;
  void *tmp___59 ;
  void *tmp___60 ;

  {
  ff = (FILE *)((void *)0);
  cl = (cl_t *)((void *)0);
  env = (env_t *)((void *)0);
  bufi = 0L;
  t_save = 0L;
  runas = 0U;
  runas_str = (char *)((void *)0);
  pass = (struct passwd *)((void *)0);
  type = (short)0;
  size = (short)0;
  ff = fopen(file_name, (char *)"r");
  if ((unsigned int )ff != (unsigned int )((FILE *)0)) {
    ff->BLAST_FLAG = 1;
  }
  if ((unsigned int )ff == (unsigned int )((void *)0)) {
    warn_e((char *)"Could not read %s (may have just been removed)", file_name);
    goto err;
  }
  tmp = fileno(ff);
  rc = fstat__extinline(tmp, & file_stat);
  if (rc != 0) {
    error_e((char *)"Could not stat %s", file_name);
    goto err;
  }
  tmp___0 = strncmp(file_name, (char *)"new.", 4U);
  if (tmp___0 == 0) {
    if (file_stat.st_uid == 0U) {
      runas = 0U;
    } else {
      runas = file_stat.st_uid;
      pass = getpwuid(file_stat.st_uid);
      if ((unsigned int )pass == (unsigned int )((void *)0)) {
        error_e((char *)"Could not getpwuid(%d)", file_stat.st_uid);
        goto err;
      }
      runas_str = strdup2(pass->pw_name);
    }
    cf->cf_user = strdup2(file_name + 4);
  } else {
    if (! cf->cf_user) {
      cf->cf_user = strdup2(file_name);
    }
    if (file_stat.st_uid == 0U) {
      runas = 0U;
    } else {
      error((char *)"Non-new file %s owned by someone else than root", file_name);
      goto err;
    }
  }
  if (debug_opt) {
    Debug((char *)"User %s Entry", file_name);
  }
  bzero((void *)(buf), sizeof(buf));
  tmp___1 = fileno(ff);
  tmp___2 = read_type(tmp___1, & type, & size);
  if (tmp___2 != 0) {
    error((char *)"File %s is not valid: ignored.", file_name);
    error((char *)"This file may have been generated by an old version of fcron.");
    error((char *)"In that case, you should try to use the converter given in the source package, or install it again using fcrontab.");
    goto err;
  } else {
    if ((int )type != 1) {
      error((char *)"File %s is not valid: ignored.", file_name);
      error((char *)"This file may have been generated by an old version of fcron.");
      error((char *)"In that case, you should try to use the converter given in the source package, or install it again using fcrontab.");
      goto err;
    } else {
      tmp___3 = fileno(ff);
      tmp___4 = read(tmp___3, (void *)(& bufi), (unsigned int )size);
      if (tmp___4 < (int )size) {
        error((char *)"File %s is not valid: ignored.", file_name);
        error((char *)"This file may have been generated by an old version of fcron.");
        error((char *)"In that case, you should try to use the converter given in the source package, or install it again using fcrontab.");
        goto err;
      } else {
        if (bufi != 100L) {
          error((char *)"File %s is not valid: ignored.", file_name);
          error((char *)"This file may have been generated by an old version of fcron.");
          error((char *)"In that case, you should try to use the converter given in the source package, or install it again using fcrontab.");
          goto err;
        }
      }
    }
  }
  tmp___5 = fileno(ff);
  tmp___6 = read_type(tmp___5, & type, & size);
  if (tmp___6 != 0) {
    error((char *)"Invalid binary fcrontab (no USER field)");
    goto err;
  } else {
    if ((int )type != 2) {
      error((char *)"Invalid binary fcrontab (no USER field)");
      goto err;
    }
  }
  free((void *)cf->cf_user);
  tmp___7 = fileno(ff);
  tmp___8 = read_strn(tmp___7, & cf->cf_user, size);
  if (tmp___8 != 0) {
    error((char *)"Cannot read user\'s name : file ignored");
    goto err;
  }
  if (runas != 0U) {
    free((void *)cf->cf_user);
    cf->cf_user = runas_str;
  }
  tmp___9 = fileno(ff);
  tmp___10 = read_type(tmp___9, & type, & size);
  if (tmp___10 != 0) {
    error((char *)"could not get time and date of saving");
    goto err;
  } else {
    if ((int )type != 3) {
      error((char *)"could not get time and date of saving");
      goto err;
    } else {
      tmp___11 = fileno(ff);
      tmp___12 = read(tmp___11, (void *)(& t_save), (unsigned int )size);
      if (tmp___12 < (int )size) {
        error((char *)"could not get time and date of saving");
        goto err;
      }
    }
  }
  tmp___58 = calloc(1U, sizeof(cl_t ));
  cl = (cl_t *)tmp___58;
  if ((unsigned int )cl == (unsigned int )((void *)0)) {
    die_e((char *)"Could not calloc.");
  }
  while (1) {
    tmp___55 = fileno(ff);
    tmp___56 = read_type(tmp___55, & type, & size);
    if (! (tmp___56 == 0)) {
      break;
    }
    switch ((int )type) {
    case 1000: 
    tmp___59 = calloc(1U, sizeof(env_t ));
    env = (env_t *)tmp___59;
    if ((unsigned int )env == (unsigned int )((void *)0)) {
      die_e((char *)"Could not calloc.");
    }
    tmp___13 = fileno(ff);
    tmp___14 = read_strn(tmp___13, & env->e_val, size);
    if (tmp___14 != 0) {
      error_e((char *)"Error while reading env var");
      goto err;
    }
    if (debug_opt) {
      Debug((char *)"  Env: \"%s\"", env->e_val);
    }
    env->e_next = cf->cf_env_base;
    cf->cf_env_base = env;
    break;
    case 4: 
    tmp___15 = fileno(ff);
    tmp___16 = read(tmp___15, (void *)(& bufi), (unsigned int )size);
    if (tmp___16 < (int )size) {
      error_e((char *)"Error while reading tzdiff field");
      goto err;
    }
    cf->cf_tzdiff = (signed char )bufi;
    break;
    case 2001: 
    tmp___17 = fileno(ff);
    tmp___18 = read_strn(tmp___17, & cl->cl_shell, size);
    if (tmp___18 != 0) {
      error_e((char *)"Error while reading shell field");
      goto err;
    }
    break;
    case 2006: 
    tmp___19 = fileno(ff);
    tmp___20 = read_strn(tmp___19, & cl->cl_runas, size);
    if (tmp___20 != 0) {
      error_e((char *)"Error while reading runas field");
      goto err;
    }
    break;
    case 2007: 
    tmp___21 = fileno(ff);
    tmp___22 = read_strn(tmp___21, & cl->cl_mailto, size);
    if (tmp___22 != 0) {
      error_e((char *)"Error while reading mailto field");
      goto err;
    }
    break;
    case 2008: 
    tmp___23 = fileno(ff);
    tmp___24 = read(tmp___23, (void *)(& bufi), (unsigned int )size);
    if (tmp___24 < (int )size) {
      error_e((char *)"Error while reading nextexe field");
      goto err;
    }
    cl->cl_nextexe = bufi;
    break;
    case 2018: 
    tmp___25 = fileno(ff);
    tmp___26 = read(tmp___25, (void *)(& bufi), (unsigned int )size);
    if (tmp___26 < (int )size) {
      error_e((char *)"Error while reading first field");
      goto err;
    }
    cl->cl_first = bufi;
    break;
    case 2017: 
    tmp___27 = fileno(ff);
    tmp___28 = read(tmp___27, (void *)(& cl->cl_option), (unsigned int )size);
    if (tmp___28 < (int )size) {
      error_e((char *)"Error while reading option field");
      goto err;
    }
    break;
    case 2002: 
    tmp___29 = fileno(ff);
    tmp___30 = read(tmp___29, (void *)(& cl->cl_numexe), (unsigned int )size);
    if (tmp___30 < (int )size) {
      error_e((char *)"Error while reading numexe field");
      goto err;
    }
    break;
    case 2003: 
    tmp___31 = fileno(ff);
    tmp___32 = read(tmp___31, (void *)(& cl->cl_lavg), (unsigned int )size);
    if (tmp___32 < (int )size) {
      error_e((char *)"Error while reading lavg field");
      goto err;
    }
    break;
    case 2004: 
    tmp___33 = fileno(ff);
    tmp___34 = read(tmp___33, (void *)(& bufi), (unsigned int )size);
    if (tmp___34 < (int )size) {
      error_e((char *)"Error while reading until field");
      goto err;
    }
    cl->cl_until = bufi;
    break;
    case 2005: 
    tmp___35 = fileno(ff);
    tmp___36 = read(tmp___35, (void *)(& cl->cl_nice), (unsigned int )size);
    if (tmp___36 < (int )size) {
      error_e((char *)"Error while reading nice field");
      goto err;
    }
    break;
    case 2011: 
    tmp___37 = fileno(ff);
    tmp___38 = read(tmp___37, (void *)(& bufi), (unsigned int )size);
    if (tmp___38 < (int )size) {
      error_e((char *)"Error while reading runfreq field");
      goto err;
    }
    cl->cl_runfreq = (unsigned short )bufi;
    break;
    case 2009: 
    tmp___39 = fileno(ff);
    tmp___40 = read(tmp___39, (void *)(& bufi), (unsigned int )size);
    if (tmp___40 < (int )size) {
      error_e((char *)"Error while reading remain field");
      goto err;
    }
    cl->cl_remain = (unsigned short )bufi;
    break;
    case 2010: 
    tmp___41 = fileno(ff);
    tmp___42 = read(tmp___41, (void *)(& bufi), (unsigned int )size);
    if (tmp___42 < (int )size) {
      error_e((char *)"Error while reading timefreq field");
      goto err;
    }
    cl->cl_timefreq = bufi;
    break;
    case 2012: 
    tmp___43 = fileno(ff);
    tmp___44 = read(tmp___43, (void *)(& cl->cl_mins), (unsigned int )size);
    if (tmp___44 < (int )size) {
      error_e((char *)"Error while reading mins field");
      goto err;
    }
    break;
    case 2013: 
    tmp___45 = fileno(ff);
    tmp___46 = read(tmp___45, (void *)(& cl->cl_hrs), (unsigned int )size);
    if (tmp___46 < (int )size) {
      error_e((char *)"Error while reading hrs field");
      goto err;
    }
    break;
    case 2014: 
    tmp___47 = fileno(ff);
    tmp___48 = read(tmp___47, (void *)(& cl->cl_days), (unsigned int )size);
    if (tmp___48 < (int )size) {
      error_e((char *)"Error while reading days field");
      goto err;
    }
    break;
    case 2015: 
    tmp___49 = fileno(ff);
    tmp___50 = read(tmp___49, (void *)(& cl->cl_mons), (unsigned int )size);
    if (tmp___50 < (int )size) {
      error_e((char *)"Error while reading mons field");
      goto err;
    }
    break;
    case 2016: 
    tmp___51 = fileno(ff);
    tmp___52 = read(tmp___51, (void *)(& cl->cl_dow), (unsigned int )size);
    if (tmp___52 < (int )size) {
      error_e((char *)"Error while reading dow field");
      goto err;
    }
    break;
    case 2000: 
    tmp___53 = add_line_to_file(cl, cf, runas, runas_str, t_save);
    if (tmp___53 == 0) {
      tmp___60 = calloc(1U, sizeof(cl_t ));
      cl = (cl_t *)tmp___60;
      if ((unsigned int )cl == (unsigned int )((void *)0)) {
        die_e((char *)"Could not calloc.");
      }
    }
    break;
    default: 
    error((char *)"Error while loading %s : unknown field type %d (ignored)", file_name, type);
    i = 0;
    while (i < (int )size) {
      tmp___54 = _IO_getc(ff);
      if (tmp___54 == -1) {
        goto err;
      }
      i = i + 1;
    }
    }
  }
  free((void *)cl);
  tmp___57 = ferror(ff);
  if (tmp___57 != 0) {
    error((char *)"file %s is truncated : you should reinstall it with fcrontab", file_name);
  }
  if (ff->BLAST_FLAG == 1) {
    ff->BLAST_FLAG = 0;
  } else {
    BLAST_ERROR();
  }
  fclose(ff);
  return (0);
  err: 
  if ((unsigned int )ff != (unsigned int )((void *)0)) {
    if (ff->BLAST_FLAG == 1) {
      ff->BLAST_FLAG = 0;
    } else {
      BLAST_ERROR();
    }
    fclose(ff);
  }
  if ((unsigned int )cl != (unsigned int )((void *)0)) {
    if ((unsigned int )cl->cl_next == (unsigned int )((void *)0)) {
      if (cl->cl_shell) {
        free((void *)cl->cl_shell);
      }
      if (cl->cl_runas) {
        free((void *)cl->cl_runas);
      }
      if (cl->cl_mailto) {
        free((void *)cl->cl_mailto);
      }
      free((void *)cl);
    }
  }
  if ((unsigned int )cl != (unsigned int )((void *)0)) {
    cf->cf_next = file_base;
    file_base = cf;
    delete_file(cf->cf_user);
  } else {
    if ((unsigned int )cf->cf_user != (unsigned int )((void *)0)) {
      free((void *)cf->cf_user);
    }
  }
  return (-1);
}
}
int add_line_to_file(cl_t *cl , cf_t *cf , uid_t runas , char *runas_str , time_t t_save ) 
{ time_t slept ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  struct tm *since2 ;
  struct tm *tmp___2 ;
  struct tm since ;
  struct tm *ftime ;
  unsigned long tmp___3 ;

  {
  slept = now - t_save;
  if ((unsigned int )cl->cl_shell == (unsigned int )((void *)0)) {
    goto _L;
  } else {
    if ((unsigned int )cl->cl_runas == (unsigned int )((void *)0)) {
      goto _L;
    } else {
      if ((unsigned int )cl->cl_mailto == (unsigned int )((void *)0)) {
        _L: 
        error((char *)"Line is not valid (empty shell, runas or mailto field) : ignored");
        bzero((void *)cl, sizeof(cl));
        if (cl->cl_shell) {
          free((void *)cl->cl_shell);
        }
        if (cl->cl_runas) {
          free((void *)cl->cl_runas);
        }
        if (cl->cl_mailto) {
          free((void *)cl->cl_mailto);
        }
        return (1);
      }
    }
  }
  if (runas != 0U) {
    tmp = strcmp(cl->cl_runas, runas_str);
    if (tmp != 0) {
      warn((char *)"warning: runas(%s) is not owner (%s): overridden.", cl->cl_runas, runas_str);
    }
    free((void *)cl->cl_runas);
    cl->cl_runas = strdup2(runas_str);
  }
  cl->cl_file = cf;
  if (cl->cl_mailto) {
    if ((int )*(cl->cl_mailto) == 45) {
      error((char *)"mailto field \'%s\' is not valid : set to owner %s.", cl->cl_mailto, (cl->cl_file)->cf_user);
      free((void *)cl->cl_mailto);
      cl->cl_mailto = strdup2((cl->cl_file)->cf_user);
    } else {
      tmp___0 = strcspn(cl->cl_mailto, (char *)" \t\n");
      tmp___1 = strlen(cl->cl_mailto);
      if (tmp___0 != tmp___1) {
        error((char *)"mailto field \'%s\' is not valid : set to owner %s.", cl->cl_mailto, (cl->cl_file)->cf_user);
        free((void *)cl->cl_mailto);
        cl->cl_mailto = strdup2((cl->cl_file)->cf_user);
      }
    }
  }
  if ((int )cl->cl_numexe > 0) {
    cl->cl_numexe = (unsigned char)0;
    if ((int )cl->cl_option[0] & 2) {
      if ((int )cl->cl_option[2] & 16) {
        add_lavg_job(cl, -1);
      }
    } else {
      if ((int )cl->cl_option[0] & 32) {
        add_serial_job(cl, -1);
      } else {
        if ((int )cl->cl_option[0] & 64) {
          add_serial_job(cl, -1);
        } else {
          warn((char *)"job %s did not finish : running it again.", cl->cl_shell);
          cl->cl_option[0] = (unsigned char )((int )cl->cl_option[0] | 64);
          add_serial_job(cl, -1);
        }
      }
    }
  }
  if ((int )cl->cl_option[0] & 1) {
    if ((int )cl->cl_option[3] & 1) {
      cl->cl_nextexe = now + cl->cl_first;
    } else {
      cl->cl_nextexe = cl->cl_nextexe + slept;
    }
    if (cl->cl_timefreq < 10L) {
      error((char *)"Invalid timefreq for %s: set to 1 day", cl->cl_shell);
      cl->cl_timefreq = 86400L;
    }
    insert_nextexe(cl);
  } else {
    if (cl->cl_nextexe <= now) {
      if (cl->cl_nextexe == 0L) {
        set_next_exe(cl, (char)1, -1);
      } else {
        if ((int )cl->cl_runfreq == 1) {
          if ((int )cl->cl_option[2] & 32) {
            set_next_exe_notrun(cl, (char)2);
          } else {
            goto _L___3;
          }
        } else {
          _L___3: 
          if ((int )cl->cl_option[0] & 16) {
            if (t_save != 0L) {
              if ((int )cl->cl_runfreq != 1) {
                if ((int )cl->cl_remain > 0) {
                  cl->cl_remain = (unsigned short )((int )cl->cl_remain - 1);
                  if ((int )cl->cl_remain > 0) {
                    if (debug_opt) {
                      Debug((char *)"    cl_remain: %d", cl->cl_remain);
                    }
                  } else {
                    goto _L___0;
                  }
                } else {
                  _L___0: 
                  cl->cl_remain = cl->cl_runfreq;
                  if (debug_opt) {
                    Debug((char *)"   boot-run %s", cl->cl_shell);
                  }
                  if ((int )cl->cl_option[0] & 2) {
                    add_lavg_job(cl, -1);
                  } else {
                    cl->cl_option[0] = (unsigned char )((int )cl->cl_option[0] | 64);
                    add_serial_job(cl, -1);
                  }
                }
                set_next_exe(cl, (char)0, -1);
              } else {
                goto _L___2;
              }
            } else {
              goto _L___2;
            }
          } else {
            _L___2: 
            if ((int )cl->cl_option[2] & 32) {
              tmp___2 = localtime(& cl->cl_nextexe);
              since2 = tmp___2;
              memcpy((void *)(& since), (void *)since2, sizeof(since));
              set_next_exe(cl, (char)1, -1);
              mail_notrun(cl, (char)2, & since);
            } else {
              set_next_exe(cl, (char)1, -1);
            }
          }
        }
      }
    } else {
      insert_nextexe(cl);
    }
  }
  if (debug_opt) {
    ftime = localtime(& cl->cl_nextexe);
    if (debug_opt) {
      Debug((char *)"  cmd %s next exec %d/%d/%d wday:%d %02d:%02d:%02d", cl->cl_shell, ftime->tm_mon + 1, ftime->tm_mday, ftime->tm_year + 1900, ftime->tm_wday, ftime->tm_hour, ftime->tm_min, ftime->tm_sec);
    }
  }
  tmp___3 = next_id;
  next_id = next_id + 1UL;
  cl->cl_id = (long )tmp___3;
  if ((unsigned long )cl->cl_id >= 4294967294UL) {
    next_id = 0UL;
  }
  cl->cl_next = cf->cf_line_base;
  cf->cf_line_base = cl;
  return (0);
}
}
void delete_file(char *user_name ) 
{ cf_t *file ;
  cf_t *prev_file ;
  cl_t *line ;
  cl_t *cur_line ;
  env_t *env ;
  env_t *cur_env ;
  struct job_t *j ;
  struct job_t *prev_j ;
  int i ;
  int k ;
  struct cl_t **s_a ;
  int tmp ;
  void *tmp___0 ;

  {
  prev_file = (cf_t *)((void *)0);
  env = (env_t *)((void *)0);
  cur_env = (env_t *)((void *)0);
  j = (struct job_t *)((void *)0);
  s_a = (struct cl_t **)((void *)0);
  file = file_base;
  while ((unsigned int )file != (unsigned int )((void *)0)) {
    tmp = strcmp(user_name, file->cf_user);
    if (tmp != 0) {
      prev_file = file;
      file = file->cf_next;
      continue;
    }
    i = 0;
    while (i < (int )exe_num) {
      if ((unsigned int )(exe_array + i)->e_line != (unsigned int )((void *)0)) {
        if ((unsigned int )((exe_array + i)->e_line)->cl_file == (unsigned int )file) {
          if ((int )((exe_array + i)->e_line)->cl_option[0] & 32) {
            goto _L___0;
          } else {
            if ((int )((exe_array + i)->e_line)->cl_option[0] & 64) {
              _L___0: 
              if ((int )((exe_array + i)->e_line)->cl_option[0] & 2) {
                goto _L;
              } else {
                serial_running = (short )((int )serial_running - 1);
              }
            } else {
              _L: 
              if ((int )((exe_array + i)->e_line)->cl_option[0] & 32) {
                if ((int )((exe_array + i)->e_line)->cl_option[0] & 2) {
                  lavg_serial_running = (short )((int )lavg_serial_running - 1);
                }
              }
            }
          }
          (exe_array + i)->e_line = (struct cl_t *)((void *)0);
        }
      }
      i = i + 1;
    }
    i = 0;
    while (i < (int )lavg_num) {
      if ((unsigned int )((lavg_array + i)->l_line)->cl_file == (unsigned int )file) {
        if (debug_opt) {
          Debug((char *)"removing %s from lavg queue", ((lavg_array + i)->l_line)->cl_shell);
        }
        ((lavg_array + i)->l_line)->cl_numexe = (unsigned char )((int )((lavg_array + i)->l_line)->cl_numexe - 1);
        lavg_num = (short )((int )lavg_num - 1);
        if (i < (int )lavg_num) {
          *(lavg_array + i) = *(lavg_array + (int )lavg_num);
          (lavg_array + (int )lavg_num)->l_line = (struct cl_t *)((void *)0);
        } else {
          (lavg_array + i)->l_line = (struct cl_t *)((void *)0);
        }
      } else {
        i = i + 1;
      }
    }
    i = 0;
    while (i < (int )serial_array_size) {
      if ((unsigned int )*(serial_array + i) != (unsigned int )((void *)0)) {
        if ((unsigned int )(*(serial_array + i))->cl_file == (unsigned int )file) {
          if (! s_a) {
            tmp___0 = calloc((unsigned int )serial_array_size, sizeof(cl_t *));
            s_a = (struct cl_t **)tmp___0;
          }
          if (debug_opt) {
            Debug((char *)"removing %s from serial queue", (*(serial_array + i))->cl_shell);
          }
          serial_num = (short )((int )serial_num - 1);
          (*(serial_array + i))->cl_numexe = (unsigned char )((int )(*(serial_array + i))->cl_numexe - 1);
          *(serial_array + i) = (struct cl_t *)((void *)0);
        }
      }
      i = i + 1;
    }
    if (! s_a) {
      goto end_of_serial_recomputing;
    }
    k = (int )serial_array_index + (int )serial_num;
    if (k >= (int )serial_array_size) {
      k = k - (int )serial_array_size;
    }
    k = 0;
    i = k;
    while (i < (int )serial_array_size) {
      if ((int )serial_array_index + i < (int )serial_array_size) {
        *(s_a + k) = *(serial_array + ((int )serial_array_index + i));
        if ((unsigned int )*(s_a + k) != (unsigned int )((void *)0)) {
          k = k + 1;
        }
      } else {
        *(s_a + k) = *(serial_array + (((int )serial_array_index + i) - (int )serial_array_size));
        if ((unsigned int )*(s_a + k) != (unsigned int )((void *)0)) {
          k = k + 1;
        }
      }
      i = i + 1;
    }
    free((void *)serial_array);
    serial_array = s_a;
    serial_array_index = (short)0;
    end_of_serial_recomputing: 
    cur_line = file->cf_line_base;
    while (1) {
      line = cur_line;
      if (! ((unsigned int )line != (unsigned int )((void *)0))) {
        break;
      }
      cur_line = line->cl_next;
      prev_j = (struct job_t *)((void *)0);
      j = queue_base;
      while ((unsigned int )j != (unsigned int )((void *)0)) {
        if ((unsigned int )j->j_line == (unsigned int )line) {
          if ((unsigned int )prev_j != (unsigned int )((void *)0)) {
            prev_j->j_next = j->j_next;
          } else {
            queue_base = j->j_next;
          }
          free((void *)j);
          break;
        } else {
          prev_j = j;
        }
        j = j->j_next;
      }
      free((void *)line->cl_shell);
      free((void *)line->cl_runas);
      free((void *)line->cl_mailto);
      free((void *)line);
    }
    break;
  }
  if ((unsigned int )file == (unsigned int )((void *)0)) {
    return;
  }
  if ((unsigned int )prev_file == (unsigned int )((void *)0)) {
    file_base = file->cf_next;
  } else {
    prev_file->cf_next = file->cf_next;
  }
  cur_env = file->cf_env_base;
  while (1) {
    env = cur_env;
    if (! ((unsigned int )env != (unsigned int )((void *)0))) {
      break;
    }
    cur_env = env->e_next;
    free((void *)env->e_val);
    free((void *)env);
  }
  free((void *)file->cf_user);
  free((void *)file);
  return;
}
}
void save_file(struct cf_t *arg_file ) 
{ cf_t *file ;
  cf_t *start_file ;

  {
  file = (cf_t *)((void *)0);
  start_file = (cf_t *)((void *)0);
  if ((unsigned int )arg_file != (unsigned int )((void *)0)) {
    start_file = arg_file;
  } else {
    start_file = file_base;
  }
  file = start_file;
  while (file) {
    if (debug_opt) {
      Debug((char *)"Saving %s...", file->cf_user);
    }
    save_file_safe(file, file->cf_user, (char *)"fcron", 0U, 0U, now);
    if ((unsigned int )arg_file != (unsigned int )((void *)0)) {
      break;
    }
    file = file->cf_next;
  }
  return;
}
}
void remove_connection(struct fcrondyn_cl **client , struct fcrondyn_cl *prev_client ) ;
void exe_cmd(struct fcrondyn_cl *client ) ;
void auth_client(struct fcrondyn_cl *client ) ;
void cmd_ls(struct fcrondyn_cl *client , long *cmd , int fd , int is_root ) ;
void print_fields(int fd , unsigned char *details ) ;
void print_line(int fd , struct cl_t *line , unsigned char *details , pid_t pid , int index___0 , time_t until ) ;
void cmd_on_exeq(struct fcrondyn_cl *client , long *cmd , int fd , int is_root ) ;
void cmd_renice(struct fcrondyn_cl *client , long *cmd , int fd , int exe_index , int is_root ) ;
void cmd_send_signal(struct fcrondyn_cl *client , long *cmd , int fd , int exe_index ) ;
void cmd_run(struct fcrondyn_cl *client , long *cmd , int fd , int is_root ) ;
fcrondyn_cl *fcrondyn_cl_base  ;
int fcrondyn_cl_num  ;
fd_set master_set  ;
int listen_fd  ;
int auth_fail  ;
long auth_nofail_since  ;
char err_no_err_str[33]  ;
char err_unknown_str[57]  ;
char err_cmd_unknown_str[18]  ;
char err_job_nfound_str[29]  ;
char err_rjob_nfound_str[86]  ;
char err_invalid_user_str[47]  ;
char err_invalid_args_str[20]  ;
char err_job_nallowed_str[46]  ;
char err_all_nallowed_str[39]  ;
char err_others_nallowed_str[48]  ;
void auth_client(struct fcrondyn_cl *client ) 
{ char *pass_cry ;
  char *pass_sys ;
  char *pass_str ;
  struct spwd *pass_sp ;
  size_t tmp ;
  register char *x__xx__ ;
  char *tmp___0 ;
  int tmp___1 ;
  register char *x__xx_____0 ;
  char *tmp___2 ;
  struct spwd *tmp___3 ;

  {
  pass_cry = (char *)((void *)0);
  pass_sys = (char *)((void *)0);
  pass_str = (char *)((void *)0);
  pass_sp = (struct spwd *)((void *)0);
  tmp___3 = getspnam((char *)client->fcl_cmd);
  pass_sp = tmp___3;
  if ((unsigned int )pass_sp == (unsigned int )((void *)0)) {
    error_e((char *)"could not getspnam %s", (char *)client->fcl_cmd);
    send(client->fcl_sock_fd, (void *)"0", sizeof("0"), 0);
    return;
  }
  pass_sys = pass_sp->sp_pwdp;
  if (debug_opt) {
    Debug((char *)"auth_client() : socket : %d", client->fcl_sock_fd);
  }
  if (auth_fail > 0) {
    if (auth_nofail_since + 60L <= now) {
      auth_fail = 0;
    }
  }
  if (auth_fail >= 10) {
    error((char *)"Too many authentication failures : try to connect later.");
    send(client->fcl_sock_fd, (void *)"0", sizeof("0"), 0);
    auth_nofail_since = 0L;
    auth_fail = (int )auth_nofail_since;
    return;
  }
  tmp = strlen((char *)client->fcl_cmd);
  pass_str = (char *)client->fcl_cmd + (tmp + 1U);
  pass_cry = crypt(pass_str, pass_sys);
  if ((unsigned int )pass_cry == (unsigned int )((void *)0)) {
    error_e((char *)"could not crypt()");
    send(client->fcl_sock_fd, (void *)"0", sizeof("0"), 0);
    while (1) {
      x__xx__ = pass_str;
      if (x__xx__) {
        while (*x__xx__) {
          tmp___0 = x__xx__;
          x__xx__ = x__xx__ + 1;
          *tmp___0 = (char )'\000';
        }
      }
      break;
    }
    return;
  }
  tmp___1 = strcmp(pass_cry, pass_sys);
  if (tmp___1 == 0) {
    client->fcl_user = strdup2((char *)client->fcl_cmd);
    send(client->fcl_sock_fd, (void *)"1", sizeof("1"), 0);
  } else {
    auth_fail = auth_fail + 1;
    auth_nofail_since = now;
    error((char *)"Invalid passwd for %s from socket %d", (char *)client->fcl_cmd, client->fcl_sock_fd);
    send(client->fcl_sock_fd, (void *)"0", sizeof("0"), 0);
  }
  while (1) {
    x__xx_____0 = pass_str;
    if (x__xx_____0) {
      while (*x__xx_____0) {
        tmp___2 = x__xx_____0;
        x__xx_____0 = x__xx_____0 + 1;
        *tmp___2 = (char )'\000';
      }
    }
    break;
  }
  return;
}
}
void print_fields(int fd , unsigned char *details ) 
{ char fields[196] ;
  char field_user[8] ;
  char field_id[6] ;
  char field_rq[6] ;
  char field_options[11] ;
  char field_schedule[18] ;
  char field_until[32] ;
  char field_pid[9] ;
  char field_index[7] ;
  char field_cmd[5] ;
  char field_endline[2] ;
  int len ;
  unsigned int tmp ;
  ssize_t tmp___0 ;

  {
  field_user[0] = (char )' ';
  field_user[1] = (char )'U';
  field_user[2] = (char )'S';
  field_user[3] = (char )'E';
  field_user[4] = (char )'R';
  field_user[5] = (char )' ';
  field_user[6] = (char )' ';
  field_user[7] = (char )'\000';
  field_id[0] = (char )'I';
  field_id[1] = (char )'D';
  field_id[2] = (char )' ';
  field_id[3] = (char )' ';
  field_id[4] = (char )' ';
  field_id[5] = (char )'\000';
  field_rq[0] = (char )' ';
  field_rq[1] = (char )'R';
  field_rq[2] = (char )'&';
  field_rq[3] = (char )'Q';
  field_rq[4] = (char )' ';
  field_rq[5] = (char )'\000';
  field_options[0] = (char )' ';
  field_options[1] = (char )'O';
  field_options[2] = (char )'P';
  field_options[3] = (char )'T';
  field_options[4] = (char )'I';
  field_options[5] = (char )'O';
  field_options[6] = (char )'N';
  field_options[7] = (char )'S';
  field_options[8] = (char )' ';
  field_options[9] = (char )' ';
  field_options[10] = (char )'\000';
  field_schedule[0] = (char )' ';
  field_schedule[1] = (char )'S';
  field_schedule[2] = (char )'C';
  field_schedule[3] = (char )'H';
  field_schedule[4] = (char )'E';
  field_schedule[5] = (char )'D';
  field_schedule[6] = (char )'U';
  field_schedule[7] = (char )'L';
  field_schedule[8] = (char )'E';
  field_schedule[9] = (char )' ';
  field_schedule[10] = (char )' ';
  field_schedule[11] = (char )' ';
  field_schedule[12] = (char )' ';
  field_schedule[13] = (char )' ';
  field_schedule[14] = (char )' ';
  field_schedule[15] = (char )' ';
  field_schedule[16] = (char )' ';
  field_schedule[17] = (char )'\000';
  field_until[0] = (char )' ';
  field_until[1] = (char )'L';
  field_until[2] = (char )'A';
  field_until[3] = (char )'V';
  field_until[4] = (char )'G';
  field_until[5] = (char )' ';
  field_until[6] = (char )'1';
  field_until[7] = (char )',';
  field_until[8] = (char )'5';
  field_until[9] = (char )',';
  field_until[10] = (char )'1';
  field_until[11] = (char )'5';
  field_until[12] = (char )' ';
  field_until[13] = (char )'U';
  field_until[14] = (char )'N';
  field_until[15] = (char )'T';
  field_until[16] = (char )'I';
  field_until[17] = (char )'L';
  field_until[18] = (char )' ';
  field_until[19] = (char )' ';
  field_until[20] = (char )' ';
  field_until[21] = (char )' ';
  field_until[22] = (char )' ';
  field_until[23] = (char )' ';
  field_until[24] = (char )' ';
  field_until[25] = (char )'S';
  field_until[26] = (char )'T';
  field_until[27] = (char )'R';
  field_until[28] = (char )'I';
  field_until[29] = (char )'C';
  field_until[30] = (char )'T';
  field_until[31] = (char )'\000';
  field_pid[0] = (char )' ';
  field_pid[1] = (char )'P';
  field_pid[2] = (char )'I';
  field_pid[3] = (char )'D';
  field_pid[4] = (char )' ';
  field_pid[5] = (char )' ';
  field_pid[6] = (char )' ';
  field_pid[7] = (char )' ';
  field_pid[8] = (char )'\000';
  field_index[0] = (char )' ';
  field_index[1] = (char )'I';
  field_index[2] = (char )'N';
  field_index[3] = (char )'D';
  field_index[4] = (char )'E';
  field_index[5] = (char )'X';
  field_index[6] = (char )'\000';
  field_cmd[0] = (char )' ';
  field_cmd[1] = (char )'C';
  field_cmd[2] = (char )'M';
  field_cmd[3] = (char )'D';
  field_cmd[4] = (char )'\000';
  field_endline[0] = (char )'\n';
  field_endline[1] = (char )'\000';
  len = 0;
  fields[0] = (char )'\000';
  strncat(fields, field_id, sizeof(fields) - (unsigned int )len);
  len = (int )((unsigned int )len + (sizeof(field_id) - 1U));
  if ((int )*(details + 0) & 1) {
    strncat(fields, field_user, (sizeof(fields) - 1U) - (unsigned int )len);
    len = (int )((unsigned int )len + (sizeof(field_user) - 1U));
  }
  if ((int )*(details + 0) & 4) {
    strncat(fields, field_pid, (sizeof(fields) - 1U) - (unsigned int )len);
    len = (int )((unsigned int )len + (sizeof(field_pid) - 1U));
  }
  if ((int )*(details + 0) & 32) {
    strncat(fields, field_index, (sizeof(fields) - 1U) - (unsigned int )len);
    len = (int )((unsigned int )len + (sizeof(field_index) - 1U));
  }
  if ((int )*(details + 0) & 2) {
    strncat(fields, field_rq, (sizeof(fields) - 1U) - (unsigned int )len);
    len = (int )((unsigned int )len + (sizeof(field_rq) - 1U));
  }
  if ((int )*(details + 0) & 64) {
    strncat(fields, field_options, (sizeof(fields) - 1U) - (unsigned int )len);
    len = (int )((unsigned int )len + (sizeof(field_options) - 1U));
  }
  if ((int )*(details + 0) & 16) {
    strncat(fields, field_until, (sizeof(fields) - 1U) - (unsigned int )len);
    len = (int )((unsigned int )len + (sizeof(field_until) - 1U));
  }
  if ((int )*(details + 0) & 8) {
    strncat(fields, field_schedule, (sizeof(fields) - 1U) - (unsigned int )len);
    len = (int )((unsigned int )len + (sizeof(field_schedule) - 1U));
  }
  strncat(fields, field_cmd, sizeof(fields) - (unsigned int )len);
  len = (int )((unsigned int )len + (sizeof(field_cmd) - 1U));
  strncat(fields, field_endline, sizeof(fields) - (unsigned int )len);
  len = (int )((unsigned int )len + (sizeof(field_endline) - 1U));
  fields[195] = (char )'\000';
  if ((unsigned int )len < sizeof(fields)) {
    tmp = (unsigned int )len;
  } else {
    tmp = sizeof(fields);
  }
  tmp___0 = send(fd, (void *)(fields), tmp, 0);
  if (tmp___0 < 0) {
    error_e((char *)"error in send()");
  }
  return;
}
}
void print_line(int fd , struct cl_t *line , unsigned char *details , pid_t pid , int index___0 , time_t until ) 
{ char buf[196] ;
  int len ;
  struct tm *ftime ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char opt___0[9] ;
  int i ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned int tmp___15 ;
  ssize_t tmp___16 ;

  {
  len = 0;
  len = snprintf(buf, sizeof(buf), (char *)"%-5ld", line->cl_id);
  if ((int )*(details + 0) & 1) {
    tmp = snprintf(buf + len, sizeof(buf) - (unsigned int )len, (char *)" %-6s", (line->cl_file)->cf_user);
    len = len + tmp;
  }
  if ((int )*(details + 0) & 4) {
    tmp___0 = snprintf(buf + len, sizeof(buf) - (unsigned int )len, (char *)" %-7d", pid);
    len = len + tmp___0;
  }
  if ((int )*(details + 0) & 32) {
    tmp___1 = snprintf(buf + len, sizeof(buf) - (unsigned int )len, (char *)" %-5d", index___0);
    len = len + tmp___1;
  }
  if ((int )*(details + 0) & 2) {
    tmp___2 = snprintf(buf + len, sizeof(buf) - (unsigned int )len, (char *)" %-4d", line->cl_numexe);
    len = len + tmp___2;
  }
  if ((int )*(details + 0) & 64) {
    i = 0;
    opt___0[0] = (char )'\000';
    if ((int )line->cl_option[0] & 2) {
      if ((int )line->cl_option[1] & 16) {
        tmp___3 = 0;
      } else {
        tmp___3 = 1;
      }
      tmp___4 = snprintf(opt___0 + i, sizeof(opt___0) - (unsigned int )i, (char *)"L%.*s", tmp___3, "O");
      i = i + tmp___4;
    }
    if ((int )line->cl_option[0] & 32) {
      if ((int )line->cl_option[1] & 8) {
        tmp___5 = 1;
      } else {
        tmp___5 = 0;
      }
      tmp___6 = snprintf(opt___0 + i, sizeof(opt___0) - (unsigned int )i, (char *)"%.*sS%.*s", i, ",", tmp___5, "O");
      i = i + tmp___6;
    }
    if ((int )line->cl_option[1] & 4) {
      tmp___7 = snprintf(opt___0 + i, sizeof(opt___0) - (unsigned int )i, (char *)"%.*sES", i, ",");
      i = i + tmp___7;
    }
    tmp___8 = snprintf(buf + len, sizeof(buf) - (unsigned int )len, (char *)" %-9s", opt___0);
    len = len + tmp___8;
  }
  if ((int )*(details + 0) & 16) {
    tmp___9 = snprintf(buf + len, sizeof(buf) - (unsigned int )len, (char *)" %.1f,%.1f,%.1f", (double )line->cl_lavg[0] / (double )10, (double )line->cl_lavg[1] / (double )10, (double )line->cl_lavg[2] / (double )10);
    len = len + tmp___9;
    if (until > 0L) {
      ftime = localtime(& until);
      if ((int )line->cl_option[2] & 16) {
        tmp___10 = (char *)"N";
      } else {
        tmp___10 = (char *)"Y";
      }
      tmp___11 = snprintf(buf + len, sizeof(buf) - (unsigned int )len, (char *)" %02d/%02d/%d %02d:%02d %s", ftime->tm_mon + 1, ftime->tm_mday, ftime->tm_year + 1900, ftime->tm_hour, ftime->tm_min, tmp___10);
      len = len + tmp___11;
    } else {
      tmp___12 = snprintf(buf + len, sizeof(buf) - (unsigned int )len, (char *)" %18s", " (no until set) ");
      len = len + tmp___12;
    }
  }
  if ((int )*(details + 0) & 8) {
    ftime = localtime(& line->cl_nextexe);
    tmp___13 = snprintf(buf + len, sizeof(buf) - (unsigned int )len, (char *)" %02d/%02d/%d %02d:%02d", ftime->tm_mon + 1, ftime->tm_mday, ftime->tm_year + 1900, ftime->tm_hour, ftime->tm_min);
    len = len + tmp___13;
  }
  tmp___14 = snprintf(buf + len, sizeof(buf) - (unsigned int )len, (char *)" %s\n", line->cl_shell);
  len = len + tmp___14;
  if ((unsigned int )len < sizeof(buf)) {
    tmp___15 = (unsigned int )len;
  } else {
    tmp___15 = sizeof(buf);
  }
  tmp___16 = send(fd, (void *)(buf), tmp___15, 0);
  if (tmp___16 < 0) {
    error_e((char *)"error in send()");
  }
  return;
}
}
void cmd_ls(struct fcrondyn_cl *client , long *cmd , int fd , int is_root ) 
{ int found ;
  int all ;
  int tmp ;
  char *user ;
  struct job_t *j ;
  int i ;
  unsigned char fields[1] ;
  int tmp___0 ;
  double lavg[3] ;
  char lavg_str[196] ;
  struct passwd *pass ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int j___0 ;
  int tmp___5 ;

  {
  found = 0;
  if (*(cmd + 1) == -1L) {
    tmp = 1;
  } else {
    tmp = 0;
  }
  all = tmp;
  user = (char *)((void *)0);
  i = 0;
  while (i < 1) {
    fields[i] = (unsigned char)0;
    i = i + 1;
  }
  switch ((int )*(cmd + 0)) {
  case 105: 
  fields[0] = (unsigned char )((int )fields[0] | 8);
  fields[0] = (unsigned char )((int )fields[0] | 2);
  fields[0] = (unsigned char )((int )fields[0] | 1);
  fields[0] = (unsigned char )((int )fields[0] | 64);
  print_fields(fd, fields);
  j = queue_base;
  while ((unsigned int )j != (unsigned int )((void *)0)) {
    if (*(cmd + 1) == (j->j_line)->cl_id) {
      tmp___0 = strcmp(client->fcl_user, ((j->j_line)->cl_file)->cf_user);
      if (tmp___0 == 0) {
        print_line(fd, j->j_line, fields, 0, 0, 0L);
      } else {
        if (is_root) {
          print_line(fd, j->j_line, fields, 0, 0, 0L);
        } else {
          send(fd, (void *)(err_job_nfound_str), sizeof(err_job_nfound_str), 0);
        }
      }
      found = 1;
      break;
    }
    j = j->j_next;
  }
  break;
  case 101: 
  case 102: 
  case 103: 
  case 104: 
  if (*(cmd + 0) == 102L) {
    lavg[0] = (double )0;
    lavg[1] = (double )0;
    lavg[2] = (double )0;
    getloadavg(lavg, 3);
    i = snprintf(lavg_str, sizeof(lavg_str), (char *)"Current load average : %.1f, %.1f, %.1f\n", lavg[0], lavg[1], lavg[2]);
    send(fd, (void *)(lavg_str), (unsigned int )i, 0);
    fields[0] = (unsigned char )((int )fields[0] | 16);
  } else {
    fields[0] = (unsigned char )((int )fields[0] | 8);
  }
  if (*(cmd + 0) == 103L) {
    fields[0] = (unsigned char )((int )fields[0] | 32);
  }
  if (*(cmd + 0) == 104L) {
    fields[0] = (unsigned char )((int )fields[0] | 4);
  }
  if (all) {
    if (! is_root) {
      warn((char *)"User %s tried to list *all* jobs.", client->fcl_user);
      send(fd, (void *)(err_all_nallowed_str), sizeof(err_all_nallowed_str), 0);
      send(fd, (void *)"\000\000", sizeof("\000\000"), 0);
      return;
    }
  }
  if (all) {
    fields[0] = (unsigned char )((int )fields[0] | 1);
  }
  print_fields(fd, fields);
  if (! all) {
    if (*(cmd + 1) == -100L) {
      user = (char *)"systab";
    } else {
      pass = getpwuid((unsigned int )*(cmd + 1));
      if ((unsigned int )pass == (unsigned int )((void *)0)) {
        warn_e((char *)"Unable to find passwd entry for %ld", *(cmd + 1));
        send(fd, (void *)(err_invalid_user_str), sizeof(err_invalid_user_str), 0);
        send(fd, (void *)"\000\000", sizeof("\000\000"), 0);
        return;
      }
      if (! is_root) {
        tmp___1 = strcmp(pass->pw_name, client->fcl_user);
        if (tmp___1 != 0) {
          warn_e((char *)"%s is not allowed to see %s\'s jobs. %ld", client->fcl_user, pass->pw_name);
          send(fd, (void *)(err_others_nallowed_str), sizeof(err_others_nallowed_str), 0);
          send(fd, (void *)"\000\000", sizeof("\000\000"), 0);
          return;
        }
      }
      user = pass->pw_name;
    }
  }
  switch ((int )*(cmd + 0)) {
  case 101: 
  j = queue_base;
  while ((unsigned int )j != (unsigned int )((void *)0)) {
    if (all) {
      print_line(fd, j->j_line, fields, 0, 0, 0L);
      found = 1;
    } else {
      tmp___2 = strcmp(user, ((j->j_line)->cl_file)->cf_user);
      if (tmp___2 == 0) {
        print_line(fd, j->j_line, fields, 0, 0, 0L);
        found = 1;
      }
    }
    j = j->j_next;
  }
  break;
  case 104: 
  i = 0;
  while (i < (int )exe_num) {
    if ((unsigned int )(exe_array + i)->e_line == (unsigned int )((void *)0)) {
      if (is_root) {
        send_msg_fd(fd, (char *)"job no more in an fcrontab: pid %d", (exe_array + i)->e_job_pid);
        found = 1;
      }
    } else {
      if (all) {
        print_line(fd, (exe_array + i)->e_line, fields, (exe_array + i)->e_job_pid, 0, 0L);
        found = 1;
      } else {
        tmp___3 = strcmp(user, (((exe_array + i)->e_line)->cl_file)->cf_user);
        if (tmp___3 == 0) {
          print_line(fd, (exe_array + i)->e_line, fields, (exe_array + i)->e_job_pid, 0, 0L);
          found = 1;
        }
      }
    }
    i = i + 1;
  }
  break;
  case 102: 
  i = 0;
  while (i < (int )lavg_num) {
    if (all) {
      print_line(fd, (lavg_array + i)->l_line, fields, 0, 0, (lavg_array + i)->l_until);
      found = 1;
    } else {
      tmp___4 = strcmp(user, (((lavg_array + i)->l_line)->cl_file)->cf_user);
      if (tmp___4 == 0) {
        print_line(fd, (lavg_array + i)->l_line, fields, 0, 0, (lavg_array + i)->l_until);
        found = 1;
      }
    }
    i = i + 1;
  }
  break;
  case 103: 
  i = (int )serial_array_index;
  j___0 = 0;
  while (j___0 < (int )serial_num) {
    if (all) {
      print_line(fd, *(serial_array + i), fields, 0, j___0, 0L);
      found = 1;
    } else {
      tmp___5 = strcmp(user, ((*(serial_array + i))->cl_file)->cf_user);
      if (tmp___5 == 0) {
        print_line(fd, *(serial_array + i), fields, 0, j___0, 0L);
        found = 1;
      }
    }
    i = i + 1;
    if (i >= (int )serial_array_size) {
      i = i - (int )serial_array_size;
    }
    j___0 = j___0 + 1;
  }
  break;
  }
  break;
  }
  if (! found) {
    send(fd, (void *)(err_job_nfound_str), sizeof(err_job_nfound_str), 0);
  }
  send(fd, (void *)"\000\000", sizeof("\000\000"), 0);
  return;
}
}
void cmd_on_exeq(struct fcrondyn_cl *client , long *cmd , int fd , int is_root ) 
{ int exe_index ;
  int found ;
  char *err_str ;
  int tmp ;

  {
  found = 0;
  err_str = (char *)((void *)0);
  exe_index = 0;
  while (exe_index < (int )exe_num) {
    if ((unsigned int )(exe_array + exe_index)->e_line != (unsigned int )((void *)0)) {
      if (*(cmd + 2) == ((exe_array + exe_index)->e_line)->cl_id) {
        found = 1;
        if (is_root) {
          _L: 
          if (*(cmd + 0) == 401L) {
            cmd_send_signal(client, cmd, fd, exe_index);
          } else {
            if (*(cmd + 0) == 402L) {
              cmd_renice(client, cmd, fd, exe_index, is_root);
            } else {
              send(fd, (void *)(err_cmd_unknown_str), sizeof(err_cmd_unknown_str), 0);
              send(fd, (void *)"\000\000", sizeof("\000\000"), 0);
              return;
            }
          }
        } else {
          tmp = strcmp(client->fcl_user, (((exe_array + exe_index)->e_line)->cl_file)->cf_user);
          if (tmp != 0) {
            if (*(cmd + 0) == 402L) {
              err_str = (char *)"%s tried to renice to %ld job id %ld for %s : not allowed.";
            } else {
              if (*(cmd + 0) == 401L) {
                err_str = (char *)"%s tried to send signal %ld to id %ld for %s : not allowed.";
              } else {
                err_str = (char *)"cannot run unknown cmd with arg %ld on job id %ld for %s : not allowed.";
              }
            }
            warn(err_str, client->fcl_user, *(cmd + 1), *(cmd + 2), client->fcl_user);
            send(fd, (void *)(err_job_nfound_str), sizeof(err_job_nfound_str), 0);
            send(fd, (void *)"\000\000", sizeof("\000\000"), 0);
          } else {
            goto _L;
          }
        }
      }
    }
    exe_index = exe_index + 1;
  }
  if (found) {
    send(fd, (void *)"\000\000", sizeof("\000\000"), 0);
  } else {
    if (*(cmd + 0) == 402L) {
      err_str = (char *)"cannot renice job id %ld for %s : no corresponding running job.";
    } else {
      if (*(cmd + 0) == 401L) {
        err_str = (char *)"cannot send signal to job id %ld for %s : no corresponding running job.";
      } else {
        err_str = (char *)"cannot run unknown cmd on job id %ld for %s : no corresponding running job.";
      }
    }
    warn(err_str, *(cmd + 2), client->fcl_user);
    send(fd, (void *)(err_rjob_nfound_str), sizeof(err_rjob_nfound_str), 0);
    send(fd, (void *)"\000\000", sizeof("\000\000"), 0);
  }
  return;
}
}
void cmd_renice(struct fcrondyn_cl *client , long *cmd , int fd , int exe_index , int is_root ) 
{ int tmp ;

  {
  if ((exe_array + exe_index)->e_job_pid <= 0) {
    warn((char *)"renice: invalid args : pid: %d nice_value: %d user: %s.", (exe_array + exe_index)->e_job_pid, (int )*(cmd + 1), client->fcl_user);
    send(fd, (void *)(err_invalid_args_str), sizeof(err_invalid_args_str), 0);
    send(fd, (void *)"\000\000", sizeof("\000\000"), 0);
    return;
  } else {
    if ((int )*(cmd + 1) < 0) {
      if (is_root) {
        goto _L;
      } else {
        warn((char *)"renice: invalid args : pid: %d nice_value: %d user: %s.", (exe_array + exe_index)->e_job_pid, (int )*(cmd + 1), client->fcl_user);
        send(fd, (void *)(err_invalid_args_str), sizeof(err_invalid_args_str), 0);
        send(fd, (void *)"\000\000", sizeof("\000\000"), 0);
        return;
      }
    } else {
      _L: 
      if ((int )*(cmd + 1) > 20) {
        warn((char *)"renice: invalid args : pid: %d nice_value: %d user: %s.", (exe_array + exe_index)->e_job_pid, (int )*(cmd + 1), client->fcl_user);
        send(fd, (void *)(err_invalid_args_str), sizeof(err_invalid_args_str), 0);
        send(fd, (void *)"\000\000", sizeof("\000\000"), 0);
        return;
      } else {
        if ((int )*(cmd + 1) < -20) {
          warn((char *)"renice: invalid args : pid: %d nice_value: %d user: %s.", (exe_array + exe_index)->e_job_pid, (int )*(cmd + 1), client->fcl_user);
          send(fd, (void *)(err_invalid_args_str), sizeof(err_invalid_args_str), 0);
          send(fd, (void *)"\000\000", sizeof("\000\000"), 0);
          return;
        }
      }
    }
  }
  tmp = setpriority(0, (unsigned int )(exe_array + exe_index)->e_job_pid, (int )*(cmd + 1));
  if (tmp != 0) {
    error_e((char *)"could not setpriority(PRIO_PROCESS, %d, %d)", (exe_array + exe_index)->e_job_pid, (int )*(cmd + 1));
    send(fd, (void *)(err_unknown_str), sizeof(err_unknown_str), 0);
    send(fd, (void *)"\000\000", sizeof("\000\000"), 0);
    return;
  } else {
    send_msg_fd(fd, (char *)"Command successfully completed on process %d.", (exe_array + exe_index)->e_job_pid);
    return;
  }
}
}
void cmd_send_signal(struct fcrondyn_cl *client , long *cmd , int fd , int exe_index ) 
{ int tmp ;

  {
  if ((exe_array + exe_index)->e_job_pid <= 0) {
    warn((char *)"send_signal: invalid args : pid: %d signal: %d user: %s", (exe_array + exe_index)->e_job_pid, (int )*(cmd + 1), client->fcl_user);
    send(fd, (void *)(err_invalid_args_str), sizeof(err_invalid_args_str), 0);
    send(fd, (void *)"\000\000", sizeof("\000\000"), 0);
    return;
  } else {
    if ((int )*(cmd + 1) <= 0) {
      warn((char *)"send_signal: invalid args : pid: %d signal: %d user: %s", (exe_array + exe_index)->e_job_pid, (int )*(cmd + 1), client->fcl_user);
      send(fd, (void *)(err_invalid_args_str), sizeof(err_invalid_args_str), 0);
      send(fd, (void *)"\000\000", sizeof("\000\000"), 0);
      return;
    }
  }
  tmp = kill((exe_array + exe_index)->e_job_pid, (int )*(cmd + 1));
  if (tmp != 0) {
    error_e((char *)"could not kill(%d, %d)", (exe_array + exe_index)->e_job_pid, (int )*(cmd + 1));
    send(fd, (void *)(err_unknown_str), sizeof(err_unknown_str), 0);
    send(fd, (void *)"\000\000", sizeof("\000\000"), 0);
    return;
  } else {
    send_msg_fd(fd, (char *)"Command successfully completed on process %d.", (exe_array + exe_index)->e_job_pid);
    return;
  }
}
}
void cmd_run(struct fcrondyn_cl *client , long *cmd , int fd , int is_root ) 
{ struct job_t *j ;
  int tmp ;

  {
  j = (struct job_t *)((void *)0);
  j = queue_base;
  while ((unsigned int )j != (unsigned int )((void *)0)) {
    if (*(cmd + 1) == (j->j_line)->cl_id) {
      tmp = strcmp(client->fcl_user, ((j->j_line)->cl_file)->cf_user);
      if (tmp == 0) {
        goto _L;
      } else {
        if (is_root) {
          _L: 
          if ((int )(j->j_line)->cl_option[0] & 2) {
            add_lavg_job(j->j_line, fd);
          } else {
            if ((int )(j->j_line)->cl_option[0] & 32) {
              add_serial_job(j->j_line, fd);
            } else {
              run_normal_job(j->j_line, fd);
            }
          }
          if (*(cmd + 0) == 301L) {
            set_next_exe(j->j_line, (char)4, fd);
          }
          send(fd, (void *)"\000\000", sizeof("\000\000"), 0);
          return;
        }
      }
    }
    j = j->j_next;
  }
  send(fd, (void *)(err_job_nfound_str), sizeof(err_job_nfound_str), 0);
  send(fd, (void *)"\000\000", sizeof("\000\000"), 0);
  return;
}
}
void exe_cmd(struct fcrondyn_cl *client ) 
{ long *cmd ;
  int fd ;
  int is_root ;
  int tmp___0 ;

  {
  is_root = 0;
  tmp___0 = strcmp(client->fcl_user, (char *)"root");
  if (tmp___0 == 0) {
    is_root = 1;
  } else {
    is_root = 0;
  }
  cmd = client->fcl_cmd;
  fd = client->fcl_sock_fd;
  if (debug_opt) {
    Debug((char *)"exe_cmd [0,1,2] : %d %d %d", *(cmd + 0), *(cmd + 1), *(cmd + 2));
  }
  switch ((int )*(cmd + 0)) {
  case 401: 
  case 402: 
  cmd_on_exeq(client, cmd, fd, is_root);
  break;
  case 105: 
  case 101: 
  case 102: 
  case 103: 
  case 104: 
  cmd_ls(client, cmd, fd, is_root);
  break;
  case 302: 
  case 301: 
  cmd_run(client, cmd, fd, is_root);
  break;
  default: 
  send(fd, (void *)(err_cmd_unknown_str), sizeof(err_cmd_unknown_str), 0);
  send(fd, (void *)"\000\000", sizeof("\000\000"), 0);
  }
  return;
}
}
void remove_connection(struct fcrondyn_cl **client , struct fcrondyn_cl *prev_client ) 
{ 

  {
  shutdown((*client)->fcl_sock_fd, 2);
  close((*client)->fcl_sock_fd);
  if ((unsigned int )prev_client == (unsigned int )((void *)0)) {
    fcrondyn_cl_base = (*client)->fcl_next;
    free((void *)(*client)->fcl_user);
    (*client)->fcl_user = (char *)((void *)0);
    free((void *)*client);
    *client = (struct fcrondyn_cl *)((void *)0);
    *client = fcrondyn_cl_base;
  } else {
    prev_client->fcl_next = (*client)->fcl_next;
    free((void *)(*client)->fcl_user);
    (*client)->fcl_user = (char *)((void *)0);
    free((void *)*client);
    *client = (struct fcrondyn_cl *)((void *)0);
    *client = prev_client->fcl_next;
  }
  fcrondyn_cl_num = fcrondyn_cl_num - 1;
  return;
}
}
void check_socket(int num ) 
{ int fd ;
  int avoid_fd ;
  int addr_len ;
  struct sockaddr_un client_addr ;
  long buf_int[20] ;
  int read_len ;
  struct fcrondyn_cl *client ;
  struct fcrondyn_cl *prev_client ;
  int tmp ;
  int tmp___0 ;
  int UNK1 ;
  int UNK2 ;
  void *tmp___1 ;

  {
  fd = -1;
  avoid_fd = -1;
  addr_len = (int )sizeof(struct sockaddr_un );
  read_len = 0;
  client = (struct fcrondyn_cl *)((void *)0);
  prev_client = (struct fcrondyn_cl *)((void *)0);
  if (num <= 0) {
    goto final_settings;
  }
  if (UNK1) {
    fd = accept(listen_fd, (void *)((struct sockaddr *)(& client_addr)), (socklen_t *)(& addr_len));
    if (! (fd == -1)) {
      fcntl(fd, 2, 1);
      tmp = fcntl(fd, 3);
      tmp___0 = fcntl(fd, 4, tmp | 2048);
      if (tmp___0 == -1) {
        error_e((char *)"Could not set fd attribute O_NONBLOCK : connection rejected.");
        shutdown(fd, 2);
        close(fd);
      } else {
        tmp___1 = calloc(1U, sizeof(fcrondyn_cl ));
        client = (struct fcrondyn_cl *)tmp___1;
        if ((unsigned int )client == (unsigned int )((void *)0)) {
          die_e((char *)"Could not calloc.");
        }
        client->fcl_sock_fd = fd;
        client->fcl_user = (char *)((void *)0);
        client->fcl_cmd = (long *)((void *)0);
        client->fcl_next = fcrondyn_cl_base;
        fcrondyn_cl_base = client;
        client->fcl_idle_since = now;
        avoid_fd = fd;
        if (fd > set_max_fd) {
          set_max_fd = fd;
        }
        fcrondyn_cl_num = fcrondyn_cl_num + 1;
      }
    }
  }
  client = fcrondyn_cl_base;
  while ((unsigned int )client != (unsigned int )((void *)0)) {
    if (UNK2) {
      if (client->fcl_sock_fd == avoid_fd) {
        _L___0: 
        if ((unsigned int )client->fcl_user == (unsigned int )((void *)0)) {
          if (now - client->fcl_idle_since > 60L) {
            warn((char *)"Connection with no auth for more than %ds : closing it.", 60);
            remove_connection(& client, prev_client);
          } else {
            goto _L;
          }
        } else {
          _L: 
          if (now - client->fcl_idle_since > 600L) {
            warn((char *)"Connection of %s is idle for more than %ds : closing it.", client->fcl_user, 600);
            remove_connection(& client, prev_client);
          } else {
            prev_client = client;
            client = client->fcl_next;
          }
        }
        continue;
      }
    } else {
      goto _L___0;
    }
    read_len = recv(client->fcl_sock_fd, (void *)(buf_int), sizeof(buf_int), 0);
    if (read_len <= 0) {
      if (read_len == 0) {
        remove_connection(& client, prev_client);
      } else {
        error_e((char *)"error recv() from sock fd %d", client->fcl_sock_fd);
        prev_client = client;
        client = client->fcl_next;
      }
    } else {
      client->fcl_cmd_len = read_len;
      client->fcl_cmd = buf_int;
      if ((unsigned int )client->fcl_user == (unsigned int )((void *)0)) {
        auth_client(client);
      } else {
        client->fcl_idle_since = now;
        exe_cmd(client);
      }
      prev_client = client;
      client = client->fcl_next;
    }
  }
  final_settings: 
  read_set = master_set;
  return;
}
}
void close_socket(void) 
{ struct fcrondyn_cl *client ;
  struct fcrondyn_cl *client_buf ;

  {
  client_buf = (struct fcrondyn_cl *)((void *)0);
  if (listen_fd) {
    shutdown(listen_fd, 2);
    close(listen_fd);
    unlink(fifofile);
    client = fcrondyn_cl_base;
    while ((unsigned int )client != (unsigned int )((void *)0)) {
      shutdown(client->fcl_sock_fd, 2);
      close(client->fcl_sock_fd);
      client_buf = client->fcl_next;
      free((void *)client);
      client = (struct fcrondyn_cl *)((void *)0);
      fcrondyn_cl_num = fcrondyn_cl_num - 1;
      client = client_buf;
    }
  }
  return;
}
}
void __initialize__(void) 
{ 

  {
  saved_str = (char *)((void *)0);
  debug_opt = (char)0;
  foreground = (char)0;
  first_sleep = 20L;
  save_time = 1800L;
  once = (char)0;
  dosyslog = (char)1;
  tmp_path = (char *)"";
  prog_name = (char *)((void *)0);
  sig_conf = (char)0;
  sig_chld = (char)0;
  sig_debug = (char)0;
  serial_max_running = (short)1;
  serial_queue_max = (short)30;
  lavg_queue_max = (short)30;
  pamh = (pam_handle_t *)((void *)0);
  fcronconf = (char *)((void *)0);
  fcrontabs = (char *)((void *)0);
  pidfile = (char *)((void *)0);
  fifofile = (char *)((void *)0);
  fcronallow = (char *)((void *)0);
  fcrondeny = (char *)((void *)0);
  shell = (char *)((void *)0);
  sendmail = (char *)((void *)0);
  editor = (char *)((void *)0);
  log_open = 0;
  fcrondyn_cl_num = 0;
  set_max_fd = 0;
  listen_fd = -1;
  auth_fail = 0;
  auth_nofail_since = 0L;
  return;
}
}

/* Generated by CIL v. 1.3.1 */
/* print_CIL_Input is false */

#line 452 "/users/rupak/ccured/include/ccured.h"
struct printf_arguments {
   int i ;
   double d ;
   char * __attribute__((__rostring__)) s ;
   long long ll ;
};
#line 201 "/usr/lib/gcc-lib/i386-redhat-linux/3.2/include/stddef.h"
typedef unsigned int size_t;
#line 131 "/usr/include/bits/types.h"
typedef unsigned long long __dev_t;
#line 132 "/usr/include/bits/types.h"
typedef unsigned int __uid_t;
#line 133 "/usr/include/bits/types.h"
typedef unsigned int __gid_t;
#line 134 "/usr/include/bits/types.h"
typedef unsigned long __ino_t;
#line 136 "/usr/include/bits/types.h"
typedef unsigned int __mode_t;
#line 137 "/usr/include/bits/types.h"
typedef unsigned int __nlink_t;
#line 138 "/usr/include/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/bits/types.h"
typedef long long __off64_t;
#line 140 "/usr/include/bits/types.h"
typedef int __pid_t;
#line 145 "/usr/include/bits/types.h"
typedef unsigned int __id_t;
#line 146 "/usr/include/bits/types.h"
typedef long __time_t;
#line 148 "/usr/include/bits/types.h"
typedef long __suseconds_t;
#line 161 "/usr/include/bits/types.h"
typedef long __blksize_t;
#line 166 "/usr/include/bits/types.h"
typedef long __blkcnt_t;
#line 180 "/usr/include/bits/types.h"
typedef int __ssize_t;
#line 189 "/usr/include/bits/types.h"
typedef unsigned int __socklen_t;
#line 67 "/usr/include/sys/types.h"
typedef __gid_t gid_t;
#line 72 "/usr/include/sys/types.h"
typedef __mode_t mode_t;
#line 82 "/usr/include/sys/types.h"
typedef __uid_t uid_t;
#line 100 "/usr/include/sys/types.h"
typedef __pid_t pid_t;
#line 105 "/usr/include/sys/types.h"
typedef __id_t id_t;
#line 110 "/usr/include/sys/types.h"
typedef __ssize_t ssize_t;
#line 76 "/users/rupak/ccured/include/gcc_3.2/time.h"
typedef __time_t time_t;
#line 28 "/usr/include/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[(int )(1024U / (8U * sizeof(unsigned long )))] ;
};
#line 28 "/usr/include/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 118 "/users/rupak/ccured/include/gcc_3.2/time.h"
struct timespec {
   __time_t tv_sec ;
   long tv_nsec ;
};
#line 69 "/usr/include/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/sys/select.h"
typedef long __fd_mask;
#line 67 "/usr/include/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[(int )(1024U / (8U * sizeof(__fd_mask )))] ;
};
#line 67 "/usr/include/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 136 "/usr/include/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 300 "/users/rupak/ccured/include/ccured_GNUCC.patch"
struct open_arguments {
   int a ;
};
#line 306 "/users/rupak/ccured/include/ccured_GNUCC.patch"
struct fcntl_arguments {
   long l ;
   struct flock *f ;
   int *p ;
};
#line 243
struct __ccured_va_list;
#line 243 "/users/rupak/ccured/include/ccured_GNUCC.patch"
typedef struct __ccured_va_list *__gnuc_va_list;
#line 263 "/users/rupak/ccured/include/ccured_GNUCC.patch"
struct __ccured_va_list {
   int next ;
};
#line 263 "/users/rupak/ccured/include/ccured_GNUCC.patch"
typedef struct __ccured_va_list *__ccured_va_list;
#line 300 "/users/rupak/ccured/include/ccured_GNUCC.patch"
struct open_arguments___0 {
   int a ;
};
#line 306 "/users/rupak/ccured/include/ccured_GNUCC.patch"
struct fcntl_arguments___0 {
   long l ;
   struct flock *f ;
   int *p ;
};
#line 94 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 50 "/users/rupak/ccured/include/gcc_3.2/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 46 "/users/rupak/ccured/include/gcc_3.2/stdio.h"
struct _IO_FILE;
#line 46 "/users/rupak/ccured/include/gcc_3.2/stdio.h"
typedef struct _IO_FILE FILE;
#line 73 "/users/rupak/ccured/include/gcc_3.2/signal.h"
typedef void (*__sighandler_t)(int  );
#line 25 "/users/rupak/ccured/include/gcc_3.2/bits/sigaction.h"
struct sigaction {
   void (*sa_handler)(int  ) ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 41 "/users/rupak/ccured/include/signal_wrappers.h"
typedef void (*__ccured_sig_func_ptr)(int  );
#line 172 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 178 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 263 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[(int )(15U * sizeof(int ) - 2U * sizeof(void *))] ;
};
#line 327 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 105 "/users/rupak/ccured/include/stdio_wrappers.h"
struct scanf_format {
   int *p_int ;
   double *p_double ;
   long *p_long ;
   unsigned int *p_uint ;
   unsigned long *p_ulong ;
   char *p_char ;
   short *p_short ;
};
#line 36 "/usr/include/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   unsigned short __pad1 ;
   __ino_t st_ino ;
   __mode_t st_mode ;
   __nlink_t st_nlink ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   __dev_t st_rdev ;
   unsigned short __pad2 ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   unsigned long __unused4 ;
   unsigned long __unused5 ;
};
#line 153 "/usr/include/bits/resource.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   long ru_maxrss ;
   long ru_ixrss ;
   long ru_idrss ;
   long ru_isrss ;
   long ru_minflt ;
   long ru_majflt ;
   long ru_nswap ;
   long ru_inblock ;
   long ru_oublock ;
   long ru_msgsnd ;
   long ru_msgrcv ;
   long ru_nsignals ;
   long ru_nvcsw ;
   long ru_nivcsw ;
};
#line 45 "/usr/include/sys/resource.h"
typedef int __priority_which_t;
#line 62 "/usr/include/sys/wait.h"
union wait;
#line 65 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_terminated_39 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 65 "/usr/include/bits/waitstatus.h"
struct __anonstruct___wait_stopped_40 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 65 "/usr/include/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_39 __wait_terminated ;
   struct __anonstruct___wait_stopped_40 __wait_stopped ;
};
#line 131 "/users/rupak/ccured/include/gcc_3.2/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 247 "/users/rupak/ccured/include/gcc_3.2/unistd.h"
typedef __socklen_t socklen_t;
#line 105 "/users/rupak/ccured/include/unistd_wrappers.h"
struct __ccured_execl_arguments {
   char * __attribute__((__safe__)) arg ;
};
#line 300 "/users/rupak/ccured/include/ccured_GNUCC.patch"
struct open_arguments___1 {
   int a ;
};
#line 306 "/users/rupak/ccured/include/ccured_GNUCC.patch"
struct fcntl_arguments___1 {
   long l ;
   struct flock *f ;
   int *p ;
};
#line 33 "/usr/include/security/_pam_types.h"
struct pam_handle;
#line 33 "/usr/include/security/_pam_types.h"
typedef struct pam_handle pam_handle_t;
#line 237 "/usr/include/security/_pam_types.h"
struct pam_message {
   int msg_style ;
   char const   *msg ;
};
#line 262 "/usr/include/security/_pam_types.h"
struct pam_response {
   char *resp ;
   int resp_retcode ;
};
#line 269 "/usr/include/security/_pam_types.h"
struct pam_conv {
   int (*conv)(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
               void *appdata_ptr ) ;
   void *appdata_ptr ;
};
#line 23 "bitstring.h"
typedef unsigned char bitstr_t;
#line 300 "/users/rupak/ccured/include/ccured_GNUCC.patch"
struct open_arguments___2 {
   int a ;
};
#line 306 "/users/rupak/ccured/include/ccured_GNUCC.patch"
struct fcntl_arguments___2 {
   long l ;
   struct flock *f ;
   int *p ;
};
#line 157 "global.h"
struct env_t {
   char *e_val ;
   struct env_t *e_next ;
};
#line 157 "global.h"
typedef struct env_t env_t;
#line 162
struct cl_t;
#line 162 "global.h"
struct cf_t {
   struct cf_t *cf_next ;
   struct cl_t *cf_line_base ;
   char *cf_user ;
   struct env_t *cf_env_base ;
   int cf_running ;
   signed char cf_tzdiff ;
};
#line 162 "global.h"
typedef struct cf_t cf_t;
#line 182 "global.h"
struct cl_t {
   struct cl_t *cl_next ;
   struct cf_t *cl_file ;
   char *cl_shell ;
   char *cl_runas ;
   char *cl_mailto ;
   long cl_id ;
   time_t cl_until ;
   time_t cl_first ;
   time_t cl_nextexe ;
   long cl_timefreq ;
   unsigned short cl_remain ;
   unsigned short cl_runfreq ;
   unsigned char cl_option[4] ;
   unsigned char cl_lavg[3] ;
   unsigned char cl_numexe ;
   char cl_nice ;
   bitstr_t cl_mins[8] ;
   bitstr_t cl_hrs[3] ;
   bitstr_t cl_days[4] ;
   bitstr_t cl_mons[2] ;
   bitstr_t cl_dow[1] ;
};
#line 182 "global.h"
typedef struct cl_t cl_t;
#line 207 "global.h"
struct job_t {
   struct cl_t *j_line ;
   struct job_t *j_next ;
};
#line 207 "global.h"
typedef struct job_t job_t;
#line 212 "global.h"
struct lavg_t {
   struct cl_t *l_line ;
   time_t l_until ;
};
#line 212 "global.h"
typedef struct lavg_t lavg_t;
#line 217 "global.h"
struct exe_t {
   struct cl_t *e_line ;
   pid_t e_ctrl_pid ;
   pid_t e_job_pid ;
};
#line 23 "/usr/include/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 128 "/usr/include/dirent.h"
struct __dirstream;
#line 128 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 300 "/users/rupak/ccured/include/ccured_GNUCC.patch"
struct open_arguments___3 {
   int a ;
};
#line 306 "/users/rupak/ccured/include/ccured_GNUCC.patch"
struct fcntl_arguments___3 {
   long l ;
   struct flock *f ;
   int *p ;
};
#line 43 "/users/rupak/ccured/include/gcc_3.2/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 40 "/users/rupak/ccured/include/gcc_3.2/shadow.h"
struct spwd {
   char * __attribute__((__mdsize__(nullterm))) sp_namp ;
   char * __attribute__((__mdsize__(nullterm))) sp_pwdp ;
   long sp_lstchg ;
   long sp_min ;
   long sp_max ;
   long sp_warn ;
   long sp_inact ;
   long sp_expire ;
   unsigned long sp_flag ;
};
#line 28 "/usr/include/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 37 "/usr/include/bits/ioctl-types.h"
struct termio {
   unsigned short c_iflag ;
   unsigned short c_oflag ;
   unsigned short c_cflag ;
   unsigned short c_lflag ;
   unsigned char c_line ;
   unsigned char c_cc[8] ;
};
#line 434 "/users/rupak/ccured/include/ccured_GNUCC.patch"
struct ioctl_format {
   int anInt ;
   int *anIntPtr ;
   char *aCharPtr ;
   unsigned long *aLongPtr ;
   struct termio *aTermio ;
   struct winsize *aWinsize ;
   void *voidPtr ;
};
#line 57 "/usr/include/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 63 "/usr/include/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 42 "/usr/include/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 50 "/users/rupak/ccured/include/uio_wrappers.h"
struct iovec_SAFE {
   void * __attribute__((__safe__)) iov_base ;
   size_t iov_len ;
};
#line 29 "/usr/include/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 145 "/usr/include/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 215 "/usr/include/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 30 "/usr/include/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 49 "socket.h"
struct fcrondyn_cl {
   struct fcrondyn_cl *fcl_next ;
   int fcl_sock_fd ;
   char *fcl_user ;
   time_t fcl_idle_since ;
   int fcl_cmd_len ;
   long *fcl_cmd ;
};
#line 49 "socket.h"
typedef struct fcrondyn_cl fcrondyn_cl;
#line 467 "job.c"
union __anonunion___u_47 {
   int __in ;
   int __i ;
};
#line 467 "job.c"
union __anonunion___u_48 {
   int __in ;
   int __i ;
};
#line 481 "job.c"
union __anonunion___u_49 {
   int __in ;
   int __i ;
};
#line 486 "job.c"
union __anonunion___u_50 {
   int __in ;
   int __i ;
};
#line 490 "job.c"
union __anonunion___u_51 {
   int __in ;
   int __i ;
};
#line 493 "job.c"
union __anonunion___u_52 {
   int __in ;
   int __i ;
};
#line 488 "job.c"
union __anonunion___u_53 {
   int __in ;
   int __i ;
};
#line 479 "job.c"
union __anonunion___u_54 {
   int __in ;
   int __i ;
};
#line 475 "job.c"
union __anonunion___u_55 {
   int __in ;
   int __i ;
};
#line 475 "job.c"
union __anonunion___u_56 {
   int __in ;
   int __i ;
};
#line 41 "conf.c"
struct list_t {
   char *str ;
   struct list_t *next ;
};
#line 41 "conf.c"
typedef struct list_t list_t;
#line 1 "fcron.o"
/* #pragma merger(0,"./fcron.i","-O2 -Wall") */
#line 121 "/users/rupak/ccured/include/ccuredannot.h"
extern void __ccuredInit(void) ;
#line 123
/* #pragma cilnoremove("__ccuredInit") */
#line 127
extern void ccured_fail_str(char *str , char *file , int line , char *func ) ;
#line 139
extern void ccured_fail(int msgId , char *file , int line , char *func ) ;
#line 19 "/users/rupak/ccured/include/ccured.h"
extern void *wrapperAlloc(unsigned int  ) ;
#line 20
/* #pragma cilnoremove("wrapperAlloc") */
#line 21
/* #pragma ccuredalloc("wrapperAlloc",sizein(1),nozero) */
#line 23
extern void wrapperFree(void * ) ;
#line 24
/* #pragma cilnoremove("wrapperFree") */
#line 25
/* #pragma ccuredpoly("wrapperFree") */
#line 28
extern char *wrapperStrdup(char * ) ;
#line 29
/* #pragma cilnoremove("wrapperStrdup") */
#line 30
/* #pragma ccuredpoly("wrapperStrdup") */
#line 33
extern unsigned int __ccured_mult_u32(unsigned int x , unsigned int y ) ;
#line 50
/* #pragma ccuredpoly("__ptrof_nocheck") */
#line 51
/* #pragma cilnoremove("__ptrof_nocheck") */
#line 52
extern void * __attribute__((__safe__)) __ptrof_nocheck(void *ptr ) ;
#line 57
/* #pragma ccuredpoly("__startof") */
#line 63
/* #pragma ccuredpoly("__endof") */
#line 64
extern void * __attribute__((__safe__)) __endof(void *ptr ) ;
#line 78
/* #pragma ccuredpoly("__ptrof") */
#line 79
extern void * __attribute__((__safe__)) __ptrof(void *ptr ) ;
#line 84
/* #pragma ccuredpoly("__ptrof_size") */
#line 85
/* #pragma cilnoremove("__ptrof_size") */
#line 86
extern void * __attribute__((__safe__)) __ptrof_size(void *ptr , unsigned int size ) ;
#line 92
/* #pragma ccuredpoly("__verify_nul") */
#line 93
extern void __verify_nul(char const   *ptr ) ;
#line 101
/* #pragma ccuredpoly("__strlen") */
#line 102
extern int __strlen(char *ptr ) ;
#line 111
/* #pragma ccuredpoly("__strlen_n") */
#line 112
extern int __strlen_n(char *ptr , int n ) ;
#line 125
/* #pragma ccuredpoly("__stringof") */
#line 126
extern char *__stringof(char const   *ptr ) ;
#line 127
/* #pragma cilnoremove("__stringof") */
#line 136
/* #pragma ccuredpoly("__stringof_ornull") */
#line 137
extern char *__stringof_ornull(char const   *ptr ) ;
#line 138
/* #pragma cilnoremove("__stringof_ornull") */
#line 147
/* #pragma ccuredpoly("__write_at_least") */
#line 148
extern void __write_at_least(void *ptr , unsigned int n ) ;
#line 155
/* #pragma ccuredpoly("__read_at_least") */
#line 156
extern void __read_at_least(void *ptr , unsigned int n ) ;
#line 162
/* #pragma ccuredpoly("__copytags") */
#line 163
extern void __copytags(void *dest , void *src , unsigned int n ) ;
#line 180
/* #pragma ccuredpoly("__mkptr") */
#line 181
/* #pragma cilnoremove("__mkptr") */
#line 182
extern void *__mkptr(void * __attribute__((__safe__)) p , void *phome ) ;
#line 188
/* #pragma ccuredpoly("__mkptr_int") */
#line 196
/* #pragma ccuredpoly("__mkptr_size") */
#line 197
/* #pragma cilnoremove("__mkptr_size") */
#line 198
extern void *__mkptr_size(void * __attribute__((__safe__)) p , unsigned int len ) ;
#line 206
/* #pragma ccuredpoly("__mkptr_string") */
#line 207
/* #pragma cilnoremove("__mkptr_string") */
#line 208
extern char *__mkptr_string(char * __attribute__((__safe__)) p ) ;
#line 215
/* #pragma ccuredpoly("__align_seq") */
#line 216
/* #pragma cilnoremove("__align_seq") */
#line 217
extern void *__align_seq(void *p , unsigned int size ) ;
#line 227
/* #pragma ccuredpoly("__trusted_cast") */
#line 228
/* #pragma cilnoremove("__trusted_cast") */
#line 229
extern void *__trusted_cast(void *p ) ;
#line 237
/* #pragma ccuredpoly("__trusted_deepcast") */
#line 238
/* #pragma cilnoremove("__trusted_deepcast") */
#line 239
extern void * __attribute__((__safe__)) __trusted_deepcast(void * __attribute__((__safe__)) p ) ;
#line 250
/* #pragma ccuredpoly("ccured_hasuniontag") */
#line 259
/* #pragma ccuredpoly("__ccured_kind_of") */
#line 306
extern char *__ccured_mangling_of(unsigned int  ) ;
#line 307
/* #pragma ccuredpoly("__ccured_mangling_of") */
#line 308
/* #pragma cilnoremove("__ccured_mangling_of") */
#line 311
extern int __ccured_has_empty_mangling(unsigned int  ) ;
#line 312
/* #pragma ccuredpoly("__ccured_has_empty_mangling") */
#line 313
/* #pragma cilnoremove("__ccured_has_empty_mangling") */
#line 327
/* #pragma cilnoremove("abort_deepcopy") */
#line 328
extern  __attribute__((__noreturn__)) void abort_deepcopy(char *errmsg ) ;
#line 451
/* #pragma cilnoremove("struct printf_arguments") */
#line 45 "/users/rupak/ccured/include/time_wrappers.h"
/* #pragma ccuredwrapper("time_wrapper",of("time")) */
#line 48
extern time_t time(time_t *__timer ) ;
#line 46 "/users/rupak/ccured/include/time_wrappers.h"
__inline static time_t time_wrapper(time_t *timer ) 
{ time_t *tmp ;
  time_t tmp___0 ;

  {
#line 49
  if ((unsigned int )timer != (unsigned int )((time_t *)0)) {
#line 50
    __write_at_least((void *)timer, sizeof(time_t ));
  }
#line 52
  tmp = (time_t *)__ptrof((void *)timer);
#line 52
  tmp___0 = time(tmp);
#line 52
  return (tmp___0);
}
}
#line 59
/* #pragma ccuredwrapper("ctime_wrapper",of("ctime")) */
#line 63
extern char *ctime(time_t const   *__timer ) ;
#line 60 "/users/rupak/ccured/include/time_wrappers.h"
__inline static char *ctime_wrapper(time_t const   *timer ) 
{ time_t *thinTimer ;
  time_t *tmp ;
  char *thinRet ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 64
  tmp = (time_t *)__ptrof((void *)((time_t *)timer));
#line 64
  thinTimer = tmp;
#line 65
  tmp___0 = ctime((time_t const   *)thinTimer);
#line 65
  thinRet = tmp___0;
#line 66
  tmp___1 = __mkptr_string((char */* __attribute__((__safe__)) */)thinRet);
#line 66
  return (tmp___1);
}
}
#line 106 "/usr/include/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 60 "/users/rupak/ccured/include/gcc_3.2/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 66
extern int open(char const   *file , int flag  , ...) ;
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments )) */
#line 264
extern void __ccured_va_start(__ccured_va_list  , unsigned long  ) ;
#line 265
extern void *__ccured_va_arg(__ccured_va_list  , unsigned int  , int  ) ;
#line 266
/* #pragma ccuredpoly("__ccured_va_arg") */
#line 267
extern void __ccured_va_end(__ccured_va_list  ) ;
#line 303
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___0 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___0 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___0 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___0 )) */
#line 69 "/users/rupak/ccured/include/io_wrappers.h"
/* #pragma ccuredwrapper("unlink_wrapper",of("unlink")) */
#line 74
extern int unlink(char const   *__name ) ;
#line 70 "/users/rupak/ccured/include/io_wrappers.h"
__inline static int unlink_wrapper(char *path ) 
{ void * __attribute__((__safe__)) tmp ;
  int tmp___0 ;

  {
#line 73
  __verify_nul((char const   *)path);
#line 74
  tmp = __ptrof((void *)path);
#line 74
  tmp___0 = unlink(tmp);
#line 74
  return (tmp___0);
}
}
#line 79
/* #pragma ccuredwrapper("open_wrapper",of("open")) */
#line 80
/* #pragma ccuredvararg("open_wrapper",sizeof(int )) */
#line 81 "/users/rupak/ccured/include/io_wrappers.h"
__inline static int open_wrapper(char *file , int oflag  , ...) 
{ __ccured_va_list argptr ;
  int mode ;
  unsigned long tmp ;
  void *tmp___0 ;
  char const   *tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;

  {
#line 83
  __verify_nul((char const   *)file);
#line 87
  if (oflag & 64) {
#line 91
    tmp = GCC_STDARG_START();
#line 91
    __ccured_va_start(argptr, tmp);
#line 92
    tmp___0 = __ccured_va_arg(argptr, sizeof(int ), -1);
#line 92
    mode = (*((int *)tmp___0));
#line 93
    __ccured_va_end(argptr);
#line 95
    tmp___1 = (char const   *)__ptrof((void *)file);
#line 95
    tmp___2 = open(tmp___1, oflag, mode);
#line 95
    return (tmp___2);
  } else {
#line 97
    tmp___3 = (char const   *)__ptrof((void *)file);
#line 97
    tmp___4 = open(tmp___3, oflag);
#line 97
    return (tmp___4);
  }
}
}
#line 123
/* #pragma ccuredwrapper("rename_wrapper",of("rename")) */
#line 128
extern int rename(char const   *__old , char const   *__new ) ;
#line 124 "/users/rupak/ccured/include/io_wrappers.h"
__inline static int rename_wrapper(char const   *__old , char const   *__new ) 
{ void * __attribute__((__safe__)) tmp ;
  void * __attribute__((__safe__)) tmp___0 ;
  int tmp___1 ;

  {
#line 126
  __verify_nul(__old);
#line 127
  __verify_nul(__new);
#line 128
  tmp = __ptrof((void *)__new);
#line 128
  tmp___0 = __ptrof((void *)__old);
#line 128
  tmp___1 = rename(tmp___0, tmp);
#line 128
  return (tmp___1);
}
}
#line 72 "/users/rupak/ccured/include/ccured_GNUCC.patch"
extern int _get__ctype_b(int  ) ;
#line 38 "/usr/include/bits/errno.h"
extern int *__errno_location(void)  __attribute__((__const__)) ;
#line 47 "/usr/include/getopt.h"
extern char *optarg ;
#line 61
extern int optind ;
#line 145
extern int getopt(int ___argc , char * const  *___argv , char const   *__shortopts ) ;
#line 151
extern int getopt_long(int ___argc , char * const  *___argv , char const   *__shortopts ,
                       struct option  const  *__longopts , int *__longind ) ;
#line 76 "/users/rupak/ccured/include/gcc_3.2/pwd.h"
extern struct passwd *getpwent(void) ;
#line 89
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 92
extern struct passwd *getpwnam(char const   *__name ) ;
#line 38 "/users/rupak/ccured/include/gcc_3.2/string.h"
extern void *memcpy(void * __restrict  __dest , void const   * __restrict  __src ,
                    size_t __n ) ;
#line 42
extern void *memmove(void *__dest , void const   *__src , size_t __n ) ;
#line 58
extern void *memset(void *__s , int __c , size_t __n ) ;
#line 61
extern int memcmp(void const   *__s1 , void const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
#line 65
extern void *memchr(void const   *__s , int __c , size_t __n )  __attribute__((__pure__)) ;
#line 82
extern char *strcpy(char * __restrict  __dest , char const   * __restrict  __src ) ;
#line 85
extern char *strncpy(char * __restrict  __dest , char const   * __restrict  __src ,
                     size_t __n ) ;
#line 89
extern char *strcat(char * __restrict  __dest , char const   * __restrict  __src ) ;
#line 92
extern char *strncat(char * __restrict  __dest , char const   * __restrict  __src ,
                     size_t __n ) ;
#line 96
extern int strcmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__)) ;
#line 99
extern int strncmp(char const   *__s1 , char const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
#line 162
extern char *strchr(char const   *__s , int __c )  __attribute__((__pure__)) ;
#line 164
extern char *strrchr(char const   *__s , int __c )  __attribute__((__pure__)) ;
#line 176
extern size_t strcspn(char const   *__s , char const   *__reject )  __attribute__((__pure__)) ;
#line 183
extern char *strpbrk(char const   *__s , char const   *__accept )  __attribute__((__pure__)) ;
#line 336 "/users/rupak/ccured/include/ccured_GNUCC.patch"
extern char * __attribute__((__rostring__, __nullterm__)) strstr(char const   * __attribute__((__rostring__,
                                                                 __nullterm__)) __haystack ,
                                                                 char const   * __attribute__((__rostring__,
                                                                 __nullterm__)) __needle ) ;
#line 191 "/usr/include/string.h"
extern char *strtok(char * __restrict  __s , char const   * __restrict  __delim ) ;
#line 201
extern char *strtok_r(char * __restrict  __s , char const   * __restrict  __delim ,
                      char ** __restrict  __save_ptr ) ;
#line 230
extern size_t strlen(char const   *__s )  __attribute__((__pure__)) ;
#line 243
extern char *strerror(int __errnum ) ;
#line 260
extern void bzero(void *__s , size_t __n ) ;
#line 287
extern int strcasecmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__)) ;
#line 291
extern int strncasecmp(char const   *__s1 , char const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
#line 309
extern char *strsep(char ** __restrict  __stringp , char const   * __restrict  __delim ) ;
#line 110 "/users/rupak/ccured/include/gcc_3.2/malloc.h"
extern void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 113
extern void *calloc(size_t __nmemb , size_t __size )  __attribute__((__malloc__)) ;
#line 539 "/users/rupak/ccured/include/ccured_GNUCC.patch"
extern void *realloc(void *__ptr , size_t __size ) ;
#line 123 "/usr/include/malloc.h"
extern void free(void *__ptr ) ;
#line 6 "/users/rupak/ccured/include/malloc_wrappers.h"
/* #pragma ccuredalloc("malloc",nozero,sizein(1)) */
#line 8
/* #pragma ccuredpoly("realloc") */
#line 9
/* #pragma ccuredwrapper("realloc_wrapper",of("realloc")) */
#line 10 "/users/rupak/ccured/include/malloc_wrappers.h"
void *realloc_wrapper(void *b , int sz ) 
{ void *res ;
  void *tmp ;
  void *tmp___0 ;
  void *result ;

  {
#line 12
  tmp = __ptrof(b);
#line 12
  tmp___0 = realloc(tmp, (unsigned int )sz);
#line 12
  res = tmp___0;
#line 15
  result = b;
#line 17
  result = __mkptr_size((void */* __attribute__((__safe__)) */)res, (unsigned int )sz);
#line 18
  return (result);
}
}
#line 22
/* #pragma ccuredwrapper("free_wrapper",of("free")) */
#line 23 "/users/rupak/ccured/include/malloc_wrappers.h"
void free_wrapper(void *x ) 
{ void *tmp ;

  {
#line 24
  tmp = __ptrof(x);
#line 24
  free(tmp);
#line 25
  return;
}
}
#line 27
/* #pragma ccuredalloc("alloca",nozero,sizein(1)) */
#line 28
/* #pragma ccuredalloc("calloc",zero,sizemul(1,2)) */
#line 46 "/users/rupak/ccured/include/string_wrappers.h"
/* #pragma ccuredwrapper("strlen_wrapper",of("strlen")) */
#line 47 "/users/rupak/ccured/include/string_wrappers.h"
__inline static unsigned int strlen_wrapper(char const   *s ) 
{ unsigned int tmp ;

  {
#line 49
  tmp = (unsigned int )__strlen((char *)s);
#line 49
  return (tmp);
}
}
#line 52
/* #pragma ccuredwrapper("bzero_wrapper",of("bzero")) */
#line 53 "/users/rupak/ccured/include/string_wrappers.h"
__inline static void bzero_wrapper(char *buff , unsigned int size ) 
{ char *tmp ;

  {
#line 55
  if (size > 0U) {
#line 56
    __write_at_least((void *)buff, size);
#line 57
    tmp = (char *)__ptrof((void *)buff);
#line 57
    bzero((void *)tmp, size);
  }
#line 59
  return;
}
}
#line 61
/* #pragma ccuredwrapper("strcpy_wrapper",of("strcpy")) */
#line 62 "/users/rupak/ccured/include/string_wrappers.h"
__inline static char *strcpy_wrapper(char *dest , char const   *src ) 
{ char *result ;
  int len ;
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 66
  tmp = __strlen((char *)src);
#line 66
  len = tmp;
#line 67
  __copytags((void *)dest, (void *)src, (unsigned int )len);
#line 77
  tmp___0 = (char *)__ptrof((void *)src);
#line 77
  tmp___1 = (char *)__ptrof((void *)dest);
#line 77
  result = strcpy((char */* __restrict  */)tmp___1, (char const   */* __restrict  */)tmp___0);
#line 78
  tmp___2 = (char *)__mkptr((void */* __attribute__((__safe__)) */)result, (void *)dest);
#line 78
  return (tmp___2);
}
}
#line 81
/* #pragma ccuredwrapper("strncpy_wrapper",of("strncpy")) */
#line 82 "/users/rupak/ccured/include/string_wrappers.h"
__inline static char *strncpy_wrapper(char *dest , char const   *src , int n ) 
{ char *result ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 86
  __strlen_n((char *)src, n);
#line 89
  __write_at_least((void *)dest, (unsigned int )n);
#line 91
  tmp = (char *)__ptrof((void *)src);
#line 91
  tmp___0 = (char *)__ptrof((void *)dest);
#line 91
  result = strncpy((char */* __restrict  */)tmp___0, (char const   */* __restrict  */)tmp,
                   (unsigned int )n);
#line 92
  tmp___1 = (char *)__mkptr((void */* __attribute__((__safe__)) */)result, (void *)dest);
#line 92
  return (tmp___1);
}
}
#line 95
/* #pragma ccuredwrapper("strcat_wrapper",of("strcat")) */
#line 96 "/users/rupak/ccured/include/string_wrappers.h"
__inline static char *strcat_wrapper(char *dest , char const   *src ) 
{ char *result ;
  int len ;
  int tmp ;
  char *deststart ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 100
  tmp = __strlen((char *)src);
#line 100
  len = tmp;
#line 103
  tmp___0 = __strlen(dest);
#line 103
  deststart = dest + tmp___0;
#line 105
  __copytags((void *)deststart, (void *)src, (unsigned int )len);
#line 107
  tmp___1 = (char *)__ptrof((void *)src);
#line 107
  tmp___2 = (char *)__ptrof((void *)deststart);
#line 107
  result = strcpy((char */* __restrict  */)tmp___2, (char const   */* __restrict  */)tmp___1);
#line 108
  tmp___3 = (char *)__mkptr((void */* __attribute__((__safe__)) */)result, (void *)dest);
#line 108
  return (tmp___3);
}
}
#line 111
/* #pragma ccuredwrapper("strncat_wrapper",of("strncat")) */
#line 112 "/users/rupak/ccured/include/string_wrappers.h"
__inline static char *strncat_wrapper(char *dest , char const   *src , int n ) 
{ char *result ;
  int len ;
  int tmp ;
  char *deststart ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 116
  tmp = __strlen_n((char *)src, n);
#line 116
  len = tmp;
#line 119
  tmp___0 = __strlen(dest);
#line 119
  deststart = dest + tmp___0;
#line 121
  __copytags((void *)deststart, (void *)src, (unsigned int )len);
#line 123
  tmp___1 = (char *)__ptrof((void *)src);
#line 123
  tmp___2 = (char *)__ptrof((void *)dest);
#line 123
  result = strncat((char */* __restrict  */)tmp___2, (char const   */* __restrict  */)tmp___1,
                   (unsigned int )n);
#line 124
  tmp___3 = (char *)__mkptr((void */* __attribute__((__safe__)) */)result, (void *)dest);
#line 124
  return (tmp___3);
}
}
#line 128
/* #pragma ccuredwrapper("strchr_wrapper",of("strchr")) */
#line 129 "/users/rupak/ccured/include/string_wrappers.h"
__inline static char *strchr_wrapper(char const   *s , int chr ) 
{ char *result ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 133
  tmp = __stringof(s);
#line 133
  result = strchr((char const   *)tmp, chr);
#line 134
  tmp___0 = (char *)__mkptr((void */* __attribute__((__safe__)) */)result, (void *)s);
#line 134
  return (tmp___0);
}
}
#line 137
/* #pragma ccuredwrapper("strrchr_wrapper",of("strrchr")) */
#line 138 "/users/rupak/ccured/include/string_wrappers.h"
char *strrchr_wrapper(char const   *s , int chr ) 
{ char *result ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 141
  tmp = __stringof(s);
#line 141
  result = strrchr((char const   *)tmp, chr);
#line 142
  tmp___0 = (char *)__mkptr((void */* __attribute__((__safe__)) */)result, (void *)s);
#line 142
  return (tmp___0);
}
}
#line 146
/* #pragma ccuredwrapper("strdup_wrapper",of("strdup")) */
#line 147 "/users/rupak/ccured/include/string_wrappers.h"
__inline static char *strdup_wrapper(char const   *s ) 
{ int len ;
  int tmp ;
  char *result ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 150
  tmp = __strlen((char *)s);
#line 150
  len = tmp;
#line 151
  tmp___0 = (char *)malloc((unsigned int )(len + 1));
#line 151
  result = tmp___0;
#line 152
  if ((unsigned int )result == (unsigned int )((char *)0)) {
#line 153
    return ((char *)0);
  }
#line 155
  tmp___1 = (char *)__ptrof((void *)s);
#line 155
  tmp___2 = (char *)__ptrof_nocheck((void *)result);
#line 155
  strcpy((char */* __restrict  */)tmp___2, (char const   */* __restrict  */)tmp___1);
#line 156
  __copytags((void *)result, (void *)s, (unsigned int )len);
#line 157
  return (result);
}
}
#line 167
/* #pragma ccuredwrapper("strcasecmp_wrapper",of("strcasecmp")) */
#line 168 "/users/rupak/ccured/include/string_wrappers.h"
int strcasecmp_wrapper(char const   *s1 , char const   *s2 ) 
{ char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 170
  tmp = __stringof(s2);
#line 170
  tmp___0 = __stringof(s1);
#line 170
  tmp___1 = strcasecmp((char const   *)tmp___0, (char const   *)tmp);
#line 170
  return (tmp___1);
}
}
#line 173
/* #pragma ccuredwrapper("strcmp_wrapper",of("strcmp")) */
#line 174 "/users/rupak/ccured/include/string_wrappers.h"
__inline static int strcmp_wrapper(char const   *s1 , char const   *s2 ) 
{ char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 177
  tmp = __stringof(s2);
#line 177
  tmp___0 = __stringof(s1);
#line 177
  tmp___1 = strcmp((char const   *)tmp___0, (char const   *)tmp);
#line 177
  return (tmp___1);
}
}
#line 180
/* #pragma ccuredwrapper("strncasecmp_wrapper",of("strncasecmp")) */
#line 181 "/users/rupak/ccured/include/string_wrappers.h"
int strncasecmp_wrapper(char const   *s1 , char const   *s2 , unsigned int n ) 
{ void * __attribute__((__safe__)) tmp ;
  void * __attribute__((__safe__)) tmp___0 ;
  void * __attribute__((__safe__)) tmp___1 ;
  void * __attribute__((__safe__)) tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 183
  tmp = __endof((void *)s1);
#line 183
  tmp___0 = __ptrof_nocheck((void *)s1);
#line 183
  if ((unsigned int )tmp - (unsigned int )tmp___0 < n) {
#line 185
    __verify_nul(s1);
  }
#line 187
  tmp___1 = __endof((void *)s2);
#line 187
  tmp___2 = __ptrof_nocheck((void *)s2);
#line 187
  if ((unsigned int )tmp___1 - (unsigned int )tmp___2 < n) {
#line 188
    __verify_nul(s2);
  }
#line 190
  tmp___3 = (char *)__ptrof((void *)s2);
#line 190
  tmp___4 = (char *)__ptrof((void *)s1);
#line 190
  tmp___5 = strncasecmp((char const   *)tmp___4, (char const   *)tmp___3, n);
#line 190
  return (tmp___5);
}
}
#line 194
/* #pragma ccuredwrapper("strncmp_wrapper",of("strncmp")) */
#line 195 "/users/rupak/ccured/include/string_wrappers.h"
__inline static int strncmp_wrapper(char const   *s1 , char const   *s2 , unsigned int n ) 
{ void * __attribute__((__safe__)) tmp ;
  void * __attribute__((__safe__)) tmp___0 ;
  void * __attribute__((__safe__)) tmp___1 ;
  void * __attribute__((__safe__)) tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;

  {
#line 198
  tmp = __endof((void *)s1);
#line 198
  tmp___0 = __ptrof_nocheck((void *)s1);
#line 198
  if ((unsigned int )tmp - (unsigned int )tmp___0 < n) {
#line 200
    __verify_nul(s1);
  }
#line 202
  tmp___1 = __endof((void *)s2);
#line 202
  tmp___2 = __ptrof_nocheck((void *)s2);
#line 202
  if ((unsigned int )tmp___1 - (unsigned int )tmp___2 < n) {
#line 203
    __verify_nul(s2);
  }
#line 205
  tmp___3 = (char *)__ptrof((void *)s2);
#line 205
  tmp___4 = (char *)__ptrof((void *)s1);
#line 205
  tmp___5 = strncmp((char const   *)tmp___4, (char const   *)tmp___3, n);
#line 205
  return (tmp___5);
}
}
#line 208
/* #pragma ccuredwrapper("strpbrk_wrapper",of("strpbrk")) */
#line 209 "/users/rupak/ccured/include/string_wrappers.h"
__inline static char *strpbrk_wrapper(char const   *str , char const   *accept_arg ) 
{ char *res ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 213
  tmp = __stringof(accept_arg);
#line 213
  tmp___0 = __stringof(str);
#line 213
  res = strpbrk((char const   *)tmp___0, (char const   *)tmp);
#line 214
  tmp___1 = (char *)__mkptr((void */* __attribute__((__safe__)) */)res, (void *)str);
#line 214
  return (tmp___1);
}
}
#line 217
/* #pragma ccuredwrapper("strsep_wrapper",of("strsep")) */
#line 218 "/users/rupak/ccured/include/string_wrappers.h"
__inline static char *strsep_wrapper(char **stringp , char const   *delim ) 
{ char *res ;
  char * __attribute__((__safe__)) tmp ;
  char * __attribute__((__safe__)) tmp___0 ;
  char const   * __restrict  tmp___1 ;
  void * __attribute__((__safe__)) tmp___2 ;

  {
#line 222
  if ((unsigned int )stringp == (unsigned int )((void *)0)) {
#line 223
    return ((char *)0);
  } else {
#line 222
    if ((unsigned int )(*stringp) == (unsigned int )((void *)0)) {
#line 223
      return ((char *)0);
    } else {
#line 226
      tmp___0 = __stringof((char const   *)(*stringp));
#line 226
      tmp = tmp___0;
#line 227
      tmp___1 = __stringof(delim);
#line 227
      tmp___2 = (void */* __attribute__((__safe__)) */)strsep((char **/* __restrict  */)(& tmp),
                                                              tmp___1);
#line 227
      res = (char *)__mkptr(tmp___2, (void *)(*stringp));
#line 229
      (*stringp) = (char *)__mkptr((void */* __attribute__((__safe__)) */)tmp, (void *)(*stringp));
#line 230
      return (res);
    }
  }
}
}
#line 234
/* #pragma ccuredwrapper("strtoul_wrapper",of("strtoul")) */
#line 142 "/users/rupak/ccured/include/gcc_3.2/stdlib.h"
extern double atof(char const   *__nptr )  __attribute__((__pure__)) ;
#line 144
extern int atoi(char const   *__nptr )  __attribute__((__pure__)) ;
#line 146
extern long atol(char const   *__nptr )  __attribute__((__pure__)) ;
#line 176
extern long strtol(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                   int __base ) ;
#line 179
extern unsigned long strtoul(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                             int __base ) ;
#line 473 "/usr/include/stdlib.h"
extern int rand(void) ;
#line 475
extern void srand(unsigned int __seed ) ;
#line 612
extern  __attribute__((__noreturn__)) void exit(int __status ) ;
__attribute__((__noreturn__)) void exit(int __status ) {
__L : goto __L;
}
#line 626
extern char *getenv(char const   *__name ) ;
#line 637
extern int putenv(char *__string ) ;
#line 643
extern int setenv(char const   *__name , char const   *__value , int __replace ) ;
#line 671
extern int mkstemp(char *__template ) ;
#line 732
extern void *bsearch(void const   *__key , void const   *__base , size_t __nmemb ,
                     size_t __size , int (*__compar)(void const   * , void const   * ) ) ;
#line 737
extern void qsort(void *__base , size_t __nmemb , size_t __size , int (*__compar)(void const   * __attribute__((__safe__)) left ,
                                                                                  void const   * __attribute__((__safe__)) right ) ) ;
#line 910
extern int getloadavg(double *result , int n ) ;
#line 47 "/users/rupak/ccured/include/stdlib_wrappers.h"
/* #pragma ccuredwrapper("atof_wrapper",of("atof")) */
#line 48 "/users/rupak/ccured/include/stdlib_wrappers.h"
__inline static double atof_wrapper(char *str ) 
{ char *tmp ;
  double tmp___0 ;

  {
#line 51
  __verify_nul((char const   *)str);
#line 52
  tmp = (char *)__ptrof((void *)str);
#line 52
  tmp___0 = atof((char const   *)tmp);
#line 52
  return (tmp___0);
}
}
#line 55
/* #pragma ccuredwrapper("atoi_wrapper",of("atoi")) */
#line 56 "/users/rupak/ccured/include/stdlib_wrappers.h"
__inline static int atoi_wrapper(char *str ) 
{ char *tmp ;
  int tmp___0 ;

  {
#line 59
  __verify_nul((char const   *)str);
#line 60
  tmp = (char *)__ptrof((void *)str);
#line 60
  tmp___0 = atoi((char const   *)tmp);
#line 60
  return (tmp___0);
}
}
#line 63
/* #pragma ccuredwrapper("atol_wrapper",of("atol")) */
#line 64 "/users/rupak/ccured/include/stdlib_wrappers.h"
__inline static long atol_wrapper(char *str ) 
{ char *tmp ;
  long tmp___0 ;

  {
#line 67
  __verify_nul((char const   *)str);
#line 68
  tmp = (char *)__ptrof((void *)str);
#line 68
  tmp___0 = atol((char const   *)tmp);
#line 68
  return (tmp___0);
}
}
#line 92
extern void qsort_zero_tags(void *base , size_t nelts , size_t size ) ;
#line 93
/* #pragma ccuredpoly("qsort_zero_tags") */
#line 152 "/users/rupak/ccured/include/stdlib_wrappers.h"
static void *__qsort_base     ;
#line 156 "/users/rupak/ccured/include/stdlib_wrappers.h"
static int (*__qsort_compare)(void * , void * )  ;
#line 158 "/users/rupak/ccured/include/stdlib_wrappers.h"
__inline static int __qsort_thunk(void * __attribute__((__safe__)) left , void * __attribute__((__safe__)) right ) 
{ void *fatleft ;
  void * __attribute__((__safe__)) tmp ;
  void *tmp___0 ;
  void *fatright ;
  void * __attribute__((__safe__)) tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 163
  tmp = __ptrof((void *)left);
#line 163
  tmp___0 = __mkptr(tmp, __qsort_base);
#line 163
  fatleft = tmp___0;
#line 164
  tmp___1 = __ptrof((void *)right);
#line 164
  tmp___2 = __mkptr(tmp___1, __qsort_base);
#line 164
  fatright = tmp___2;
#line 168
  tmp___3 = ((*__qsort_compare))(fatleft, fatright);
#line 168
  return (tmp___3);
}
}
#line 172
/* #pragma ccuredwrapper("qsort_wrapper",of("qsort")) */
#line 173 "/users/rupak/ccured/include/stdlib_wrappers.h"
__inline static void qsort_wrapper(void *base , size_t nmemb , size_t size , int (*compare)(void *left ,
                                                                                            void *right ) ) 
{ void * __attribute__((__safe__)) tmp ;
  void * __attribute__((__safe__)) tmp___0 ;
  unsigned int tmp___1 ;
  int (*tmp___2)(void * , void * ) ;
  void *tmp___3 ;

  {
#line 178
  tmp = __endof(base);
#line 178
  tmp___0 = __ptrof_nocheck(base);
#line 178
  tmp___1 = __ccured_mult_u32(nmemb, size);
#line 178
  if ((unsigned int )tmp - (unsigned int )tmp___0 < tmp___1) {
#line 179
    ccured_fail(3, (char *)"/users/rupak/ccured/include/stdlib_wrappers.h", 179, (char *)"qsort_wrapper");
  }
#line 180
  qsort_zero_tags(base, nmemb, size);
#line 183
  __qsort_base = base;
#line 184
  __qsort_compare = compare;
#line 186
  tmp___2 = (int (*)(void * , void * ))__ptrof((void *)(& __qsort_thunk));
#line 186
  tmp___3 = __ptrof(base);
#line 186
  qsort(tmp___3, nmemb, size, (int (*)(void const   * __attribute__((__safe__)) left ,
                                       void const   * __attribute__((__safe__)) right ))tmp___2);
#line 190
  __qsort_base = (void *)0;
#line 191
  return;
}
}
#line 195 "/users/rupak/ccured/include/stdlib_wrappers.h"
static void *__bsearch_base     ;
#line 196 "/users/rupak/ccured/include/stdlib_wrappers.h"
static void *__bsearch_key     ;
#line 200 "/users/rupak/ccured/include/stdlib_wrappers.h"
static int (*__bsearch_compare)(void * , void * )  ;
#line 202 "/users/rupak/ccured/include/stdlib_wrappers.h"
__inline static int __bsearch_thunk(void * __attribute__((__safe__)) key , void * __attribute__((__safe__)) element ) 
{ void *fatkey ;
  void * __attribute__((__safe__)) tmp ;
  void *tmp___0 ;
  void *fatelement ;
  void * __attribute__((__safe__)) tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 207
  tmp = __ptrof((void *)key);
#line 207
  tmp___0 = __mkptr(tmp, __bsearch_key);
#line 207
  fatkey = tmp___0;
#line 208
  tmp___1 = __ptrof((void *)element);
#line 208
  tmp___2 = __mkptr(tmp___1, __bsearch_base);
#line 208
  fatelement = tmp___2;
#line 212
  tmp___3 = ((*__bsearch_compare))(fatkey, fatelement);
#line 212
  return (tmp___3);
}
}
#line 216
/* #pragma ccuredwrapper("bsearch_wrapper",of("bsearch")) */
#line 217 "/users/rupak/ccured/include/stdlib_wrappers.h"
__inline static void *bsearch_wrapper(void *key , void *base , size_t nmemb , size_t size ,
                                      int (*compare)(void *left , void *right ) ) 
{ void * __attribute__((__safe__)) result ;
  void * __attribute__((__safe__)) tmp ;
  void * __attribute__((__safe__)) tmp___0 ;
  unsigned int tmp___1 ;
  int (*tmp___2)(void * , void * ) ;
  void const   *tmp___3 ;
  void const   *tmp___4 ;
  void *tmp___5 ;

  {
#line 226
  tmp = __endof(base);
#line 226
  tmp___0 = __ptrof_nocheck(base);
#line 226
  tmp___1 = __ccured_mult_u32(nmemb, size);
#line 226
  if ((unsigned int )tmp - (unsigned int )tmp___0 < tmp___1) {
#line 227
    ccured_fail(3, (char *)"/users/rupak/ccured/include/stdlib_wrappers.h", 227, (char *)"bsearch_wrapper");
  }
#line 230
  __bsearch_key = key;
#line 231
  __bsearch_base = base;
#line 232
  __bsearch_compare = compare;
#line 234
  tmp___2 = (int (*)(void * , void * ))__ptrof((void *)(& __bsearch_thunk));
#line 234
  tmp___3 = __ptrof(base);
#line 234
  tmp___4 = __ptrof(key);
#line 234
  result = bsearch(tmp___4, tmp___3, nmemb, size, (int (*)(void const   * , void const   * ))tmp___2);
#line 241
  __bsearch_base = (void *)0;
#line 242
  tmp___5 = __mkptr(result, base);
#line 242
  return (tmp___5);
}
}
#line 254
/* #pragma ccuredwrapper("strtol_wrapper",of("strtol")) */
#line 255 "/users/rupak/ccured/include/stdlib_wrappers.h"
__inline static long strtol_wrapper(char const   *str , char **endptr , int base ) 
{ char * __attribute__((__safe__)) ep  __attribute__((__safe__)) ;
  long result ;
  char * __attribute__((__safe__)) *tmp ;
  char const   * __restrict  tmp___0 ;
  long tmp___1 ;

  {
#line 259
  if ((unsigned int )endptr == (unsigned int )((void *)0)) {
#line 259
    tmp = (char * __attribute__((__safe__)) *)((void *)0);
  } else {
#line 259
    tmp = & ep;
  }
#line 259
  tmp___0 = (char const   */* __restrict  */)__ptrof((void *)str);
#line 259
  tmp___1 = strtol(tmp___0, (char **/* __restrict  */)tmp, base);
#line 259
  result = tmp___1;
#line 262
  if ((unsigned int )endptr != (unsigned int )((void *)0)) {
#line 265
    (*endptr) = (char *)__mkptr((void */* __attribute__((__safe__)) */)ep, (void *)str);
  }
#line 267
  return (result);
}
}
#line 270
/* #pragma ccuredwrapper("getenv_wrapper",of("getenv")) */
#line 271 "/users/rupak/ccured/include/stdlib_wrappers.h"
__inline static char *getenv_wrapper(char *str ) 
{ char const   *tmp ;
  char * __attribute__((__safe__)) tmp___0 ;
  char *tmp___1 ;

  {
#line 274
  __verify_nul((char const   *)str);
#line 275
  tmp = (char const   *)__ptrof((void *)str);
#line 275
  tmp___0 = getenv(tmp);
#line 275
  tmp___1 = __mkptr_string(tmp___0);
#line 275
  return (tmp___1);
}
}
#line 236 "/users/rupak/ccured/include/string_wrappers.h"
__inline static unsigned long strtoul_wrapper(char * __restrict  nptr , char ** __restrict  endptr ,
                                              int __base ) 
{ char * __attribute__((__safe__)) tmp ;
  char * __attribute__((__safe__)) tmp___0 ;
  unsigned long val ;
  char const   * __restrict  tmp___1 ;
  unsigned long tmp___2 ;
  char const   * __restrict  tmp___3 ;
  unsigned long tmp___4 ;

  {
#line 240
  if ((unsigned int )endptr != (unsigned int )((void *)0)) {
#line 241
    tmp___0 = (char */* __attribute__((__safe__)) */)__ptrof((void *)(*endptr));
#line 241
    tmp = tmp___0;
#line 244
    tmp___1 = __stringof((char const   *)nptr);
#line 244
    tmp___2 = strtoul(tmp___1, (char **/* __restrict  */)(& tmp), __base);
#line 244
    val = tmp___2;
#line 245
    (*endptr) = (char *)__mkptr((void */* __attribute__((__safe__)) */)tmp, (void *)(*endptr));
#line 246
    return (val);
  } else {
#line 248
    tmp___3 = __stringof((char const   *)nptr);
#line 248
    tmp___4 = strtoul(tmp___3, (char **/* __restrict  */)0, __base);
#line 248
    return (tmp___4);
  }
}
}
#line 254 "/users/rupak/ccured/include/string_wrappers.h"
static char const   *saved_str     =    (char const   *)((void *)0);
#line 256
/* #pragma ccuredwrapper("strtok_wrapper",of("strtok")) */
#line 257 "/users/rupak/ccured/include/string_wrappers.h"
__inline static char *strtok_wrapper(char *str , char const   *delim ) 
{ char *res ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 261
  if ((unsigned int )str != (unsigned int )((void *)0)) {
#line 262
    __verify_nul((char const   *)((void *)str));
#line 263
    saved_str = (char const   *)str;
  }
#line 265
  tmp = __stringof((char const   *)((void *)delim));
#line 265
  tmp___0 = (char *)__ptrof((void *)str);
#line 265
  res = strtok((char */* __restrict  */)tmp___0, (char const   */* __restrict  */)tmp);
#line 266
  tmp___1 = (char *)__mkptr((void */* __attribute__((__safe__)) */)res, (void *)saved_str);
#line 266
  return (tmp___1);
}
}
#line 269
/* #pragma ccuredwrapper("strtok_r_wrapper",of("strtok_r")) */
#line 270 "/users/rupak/ccured/include/string_wrappers.h"
__inline static char *strtok_r_wrapper(char *str , char const   *delim , char **ptrptr ) 
{ char * __attribute__((__safe__)) thin_ptrptr ;
  char * __attribute__((__safe__)) tmp ;
  char *res ;
  char const   * __restrict  tmp___0 ;
  char * __restrict  tmp___1 ;
  char *tmp___2 ;
  char *base ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 273
  if ((unsigned int )str != (unsigned int )((void *)0)) {
#line 274
    __verify_nul((char const   *)str);
  }
#line 278
  tmp = (char */* __attribute__((__safe__)) */)__ptrof((void *)(*ptrptr));
#line 278
  thin_ptrptr = tmp;
#line 280
  tmp___0 = __stringof(delim);
#line 280
  tmp___1 = (char */* __restrict  */)__ptrof((void *)str);
#line 280
  tmp___2 = strtok_r(tmp___1, tmp___0, (char **/* __restrict  */)(& thin_ptrptr));
#line 280
  res = tmp___2;
#line 281
  if ((unsigned int )str == (unsigned int )((void *)0)) {
#line 281
    tmp___3 = (*ptrptr);
  } else {
#line 281
    tmp___3 = str;
  }
#line 281
  base = tmp___3;
#line 284
  (*ptrptr) = (char *)__mkptr((void */* __attribute__((__safe__)) */)thin_ptrptr,
                              (void *)base);
#line 286
  tmp___4 = (char *)__mkptr((void */* __attribute__((__safe__)) */)res, (void *)base);
#line 286
  return (tmp___4);
}
}
#line 319
/* #pragma ccuredwrapper("memcmp_wrapper",of("memcmp")) */
#line 320 "/users/rupak/ccured/include/string_wrappers.h"
__inline static int memcmp_wrapper(void const   *s1 , void const   *s2 , size_t n ) 
{ void * __attribute__((__safe__)) tmp ;
  void * __attribute__((__safe__)) tmp___0 ;
  void * __attribute__((__safe__)) tmp___1 ;
  void * __attribute__((__safe__)) tmp___2 ;
  void const   *tmp___3 ;
  void const   *tmp___4 ;
  int tmp___5 ;

  {
#line 323
  tmp = __endof((void *)s1);
#line 323
  tmp___0 = __ptrof_nocheck((void *)s1);
#line 323
  if ((unsigned int )tmp - (unsigned int )tmp___0 < n) {
#line 324
    ccured_fail(3, (char *)"/users/rupak/ccured/include/string_wrappers.h", 324, (char *)"memcmp_wrapper");
  }
#line 326
  tmp___1 = __endof((void *)s2);
#line 326
  tmp___2 = __ptrof_nocheck((void *)s2);
#line 326
  if ((unsigned int )tmp___1 - (unsigned int )tmp___2 < n) {
#line 327
    ccured_fail(3, (char *)"/users/rupak/ccured/include/string_wrappers.h", 327, (char *)"memcmp_wrapper");
  }
#line 329
  tmp___3 = __ptrof((void *)s2);
#line 329
  tmp___4 = __ptrof((void *)s1);
#line 329
  tmp___5 = memcmp(tmp___4, tmp___3, n);
#line 329
  return (tmp___5);
}
}
#line 332
/* #pragma ccuredwrapper("memset_wrapper",of("memset")) */
#line 333 "/users/rupak/ccured/include/string_wrappers.h"
__inline static void *memset_wrapper(void *buffer , int c , size_t size ) 
{ void *tmp ;

  {
#line 336
  __write_at_least(buffer, size);
#line 337
  tmp = __ptrof(buffer);
#line 337
  memset(tmp, c, size);
#line 338
  return (buffer);
}
}
#line 341
/* #pragma ccuredwrapper("memmove_wrapper",of("memmove")) */
#line 342 "/users/rupak/ccured/include/string_wrappers.h"
__inline static void *memmove_wrapper(void *dest , void const   *src , size_t size ) 
{ void *tmp ;
  void *tmp___0 ;

  {
#line 345
  if (size) {
#line 346
    __copytags(dest, (void *)src, size);
#line 347
    tmp = __ptrof((void *)src);
#line 347
    tmp___0 = __ptrof(dest);
#line 347
    memmove(tmp___0, (void const   *)tmp, size);
  }
#line 350
  return (dest);
}
}
#line 353
/* #pragma ccuredwrapper("memcpy_wrapper",of("memcpy")) */
#line 354 "/users/rupak/ccured/include/string_wrappers.h"
__inline static void *memcpy_wrapper(void *dest , void const   *src , size_t size ) 
{ void const   *tmp ;
  void * __restrict  tmp___0 ;

  {
#line 357
  if (size) {
#line 358
    __copytags(dest, (void *)src, size);
#line 359
    tmp = __ptrof((void *)src);
#line 359
    tmp___0 = __ptrof(dest);
#line 359
    memcpy(tmp___0, (void const   */* __restrict  */)tmp, size);
  }
#line 362
  return (dest);
}
}
#line 366
/* #pragma ccuredwrapper("strerror_wrapper",of("strerror")) */
#line 367 "/users/rupak/ccured/include/string_wrappers.h"
__inline static char *strerror_wrapper(int errnum ) 
{ char *ret ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 370
  tmp = strerror(errnum);
#line 370
  ret = tmp;
#line 371
  tmp___0 = __mkptr_string((char */* __attribute__((__safe__)) */)ret);
#line 371
  return (tmp___0);
}
}
#line 374
/* #pragma ccuredwrapper("strstr_wrapper",of("strstr")) */
#line 375 "/users/rupak/ccured/include/string_wrappers.h"
__inline static char *strstr_wrapper(char const   *__haystack , char const   *__needle ) 
{ char *res ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 379
  tmp = __stringof(__needle);
#line 379
  tmp___0 = __stringof(__haystack);
#line 379
  res = strstr((char const   */* __attribute__((__rostring__, __nullterm__)) */)tmp___0,
               (char const   */* __attribute__((__rostring__, __nullterm__)) */)tmp);
#line 380
  tmp___1 = (char *)__mkptr((void */* __attribute__((__safe__)) */)res, (void *)__haystack);
#line 380
  return (tmp___1);
}
}
#line 383
/* #pragma ccuredwrapper("memchr_wrapper",of("memchr")) */
#line 384 "/users/rupak/ccured/include/string_wrappers.h"
__inline static void *memchr_wrapper(void const   *s , int c , size_t n ) 
{ void *result ;
  void const   *tmp ;
  void *tmp___0 ;

  {
#line 388
  __read_at_least((void *)s, n);
#line 389
  tmp = __ptrof((void *)s);
#line 389
  result = memchr(tmp, c, n);
#line 390
  tmp___0 = __mkptr((void */* __attribute__((__safe__)) */)result, (void *)s);
#line 390
  return (tmp___0);
}
}
#line 38 "/users/rupak/ccured/include/pwd_wrappers.h"
extern void __deepcopy_passwd_from_compat(struct passwd *fat , struct passwd  __attribute__((__compat__)) *compat ) 
{ 

  {
#line 40
  fat->pw_name = __mkptr_string((char */* __attribute__((__safe__)) */)compat->pw_name);
#line 41
  fat->pw_passwd = __mkptr_string((char */* __attribute__((__safe__)) */)compat->pw_passwd);
#line 42
  fat->pw_gecos = __mkptr_string((char */* __attribute__((__safe__)) */)compat->pw_gecos);
#line 43
  fat->pw_dir = __mkptr_string((char */* __attribute__((__safe__)) */)compat->pw_dir);
#line 44
  fat->pw_shell = __mkptr_string((char */* __attribute__((__safe__)) */)compat->pw_shell);
#line 45
  return;
}
}
#line 48 "/users/rupak/ccured/include/pwd_wrappers.h"
static struct passwd my_passwd_result  ;
#line 50
/* #pragma ccuredwrapper("getpwnam_wrapper",of("getpwnam")) */
#line 51 "/users/rupak/ccured/include/pwd_wrappers.h"
__inline static struct passwd *getpwnam_wrapper(char const   *name ) 
{ struct passwd  __attribute__((__compat__)) *libc_result ;
  char const   *tmp ;

  {
#line 57
  __verify_nul(name);
#line 58
  tmp = (char const   *)__ptrof((void *)name);
#line 58
  libc_result = getpwnam(tmp);
#line 60
  if ((unsigned int )libc_result == (unsigned int )((void *)0)) {
#line 61
    return ((struct passwd *)((void *)0));
  }
#line 63
  if ((unsigned int )libc_result != (unsigned int )(& my_passwd_result)) {
#line 63
    __deepcopy_passwd_from_compat(& my_passwd_result, libc_result);
  }
#line 64
  return (& my_passwd_result);
}
}
#line 68
/* #pragma ccuredwrapper("getpwuid_wrapper",of("getpwuid")) */
#line 69 "/users/rupak/ccured/include/pwd_wrappers.h"
__inline static struct passwd *getpwuid_wrapper(__uid_t uid ) 
{ struct passwd  __attribute__((__compat__)) *libc_result ;
  struct passwd  __attribute__((__compat__)) *tmp ;

  {
#line 73
  tmp = getpwuid(uid);
#line 73
  libc_result = tmp;
#line 74
  if ((unsigned int )libc_result == (unsigned int )((void *)0)) {
#line 75
    return ((struct passwd *)((void *)0));
  }
#line 77
  if ((unsigned int )libc_result != (unsigned int )(& my_passwd_result)) {
#line 77
    __deepcopy_passwd_from_compat(& my_passwd_result, libc_result);
  }
#line 78
  return (& my_passwd_result);
}
}
#line 81
/* #pragma ccuredwrapper("getpwent_wrapper",of("getpwent")) */
#line 82 "/users/rupak/ccured/include/pwd_wrappers.h"
__inline static struct passwd *getpwent_wrapper(void) 
{ struct passwd  __attribute__((__compat__)) *libc_result ;
  struct passwd  __attribute__((__compat__)) *tmp ;

  {
#line 85
  tmp = getpwent();
#line 85
  libc_result = tmp;
#line 86
  if ((unsigned int )libc_result == (unsigned int )((void *)0)) {
#line 87
    return ((struct passwd *)((void *)0));
  }
#line 89
  if ((unsigned int )libc_result != (unsigned int )(& my_passwd_result)) {
#line 89
    __deepcopy_passwd_from_compat(& my_passwd_result, libc_result);
  }
#line 90
  return (& my_passwd_result);
}
}
#line 90 "/users/rupak/ccured/include/gcc_3.2/signal.h"
extern __sighandler_t signal(int __sig , void (*__handler)(int  ) ) ;
#line 114
extern int kill(__pid_t __pid , int __sig ) ;
#line 249
extern int sigaction(int __sig , struct sigaction  const  * __restrict  __act , struct sigaction * __restrict  __oact ) ;
#line 326
extern int siginterrupt(int __sig , int __interrupt ) ;
#line 43 "/users/rupak/ccured/include/signal_wrappers.h"
__inline static __ccured_sig_func_ptr __attribute__((__safe__))  __ptrof_signal(void (*fn)(int  ) ) 
{ void (*safe_fn)(int  ) ;
  void (*tmp)(int  ) ;

  {
#line 46
  tmp = (void (*)(int  ))__ptrof_nocheck((void *)fn);
#line 46
  safe_fn = tmp;
#line 47
  if ((int )safe_fn != -1) {
#line 47
    if ((unsigned int )safe_fn != (unsigned int )((void (*)(int  ))0)) {
#line 47
      if ((int )safe_fn != 1) {
#line 51
        __ptrof((void *)fn);
      }
    }
  }
#line 53
  return (safe_fn);
}
}
#line 56
/* #pragma ccuredpoly("__mkfat_sighandler") */
#line 57 "/users/rupak/ccured/include/signal_wrappers.h"
__inline static void *__mkfat_sighandler(void *in ) 
{ void *tmp ;
  void *tmp___0 ;

  {
#line 58
  if ((int )in == 1) {
#line 59
    tmp = __mkptr((void */* __attribute__((__safe__)) */)in, (void *)0);
#line 59
    return (tmp);
  } else {
#line 61
    tmp___0 = __mkptr_size((void */* __attribute__((__safe__)) */)in, 1U);
#line 61
    return (tmp___0);
  }
}
}
#line 66
/* #pragma ccuredwrapper("signal_wrapper",of("signal")) */
#line 67 "/users/rupak/ccured/include/signal_wrappers.h"
__inline static __ccured_sig_func_ptr signal_wrapper(int signum , void (*fn)(int  ) ) 
{ void (*null)(int  ) ;
  void (*ret)(int  ) ;
  void (*tmp)(int  ) ;
  __ccured_sig_func_ptr tmp___0 ;

  {
#line 71
  null = (void (*)(int  ))0;
#line 73
  tmp = __ptrof_signal(fn);
#line 73
  ret = signal(signum, tmp);
#line 74
  tmp___0 = (__ccured_sig_func_ptr )__mkptr((void */* __attribute__((__safe__)) */)ret,
                                            (void *)null);
#line 74
  return (tmp___0);
}
}
#line 80 "/users/rupak/ccured/include/signal_wrappers.h"
extern void __deepcopy_sigaction_from_compat(struct sigaction *fat , struct sigaction  __attribute__((__compat__)) *compat ) 
{ 

  {
#line 81
  fat->sa_handler = (void (*)(int  ))__mkfat_sighandler((void *)compat->sa_handler);
#line 82
  fat->sa_restorer = (void (*)(void))__mkfat_sighandler((void *)compat->sa_restorer);
#line 84
  return;
}
}
#line 88
/* #pragma ccuredwrapper("sigaction_wrapper",of("sigaction")) */
#line 93
extern void __deepcopy_sigaction_to_compat(struct sigaction  __attribute__((__compat__)) *compat ,
                                           struct sigaction *fat ) ;
#line 89 "/users/rupak/ccured/include/signal_wrappers.h"
__inline static int sigaction_wrapper(int __sig , struct sigaction *__act , struct sigaction *__oact ) 
{ struct sigaction  __attribute__((__compat__)) p_act_compat__area ;
  struct sigaction *p_act_compat__ptrof ;
  struct sigaction *tmp ;
  struct sigaction  __attribute__((__compat__)) *p_act_compat ;
  struct sigaction  __attribute__((__compat__)) *tmp___2 ;
  int tmp___4 ;
  struct sigaction  __attribute__((__compat__)) p_oact_compat__area ;
  struct sigaction *p_oact_compat__ptrof ;
  struct sigaction *tmp___5 ;
  struct sigaction  __attribute__((__compat__)) *p_oact_compat ;
  struct sigaction  __attribute__((__compat__)) *tmp___8 ;
  int tmp___10 ;
  int res ;
  int tmp___11 ;

  {
#line 93
  tmp = (struct sigaction *)__ptrof_nocheck((void *)__act);
#line 93
  p_act_compat__ptrof = tmp;
#line 93
  if (p_act_compat__ptrof) {
#line 93
    tmp___4 = __ccured_has_empty_mangling(sizeof(struct sigaction ));
#line 93
    if (tmp___4) {
#line 93
      tmp___2 = (struct sigaction  __attribute__((__compat__)) *)__trusted_cast((void *)p_act_compat__ptrof);
    } else {
#line 93
      __deepcopy_sigaction_to_compat(& p_act_compat__area, p_act_compat__ptrof);
#line 93
      tmp___2 = & p_act_compat__area;
    }
  } else {
#line 93
    tmp___2 = (struct sigaction  __attribute__((__compat__)) *)__trusted_cast((void *)p_act_compat__ptrof);
  }
#line 93
  p_act_compat = tmp___2;
#line 94
  tmp___5 = (struct sigaction *)__ptrof_nocheck((void *)__oact);
#line 94
  p_oact_compat__ptrof = tmp___5;
#line 94
  if (p_oact_compat__ptrof) {
#line 94
    tmp___10 = __ccured_has_empty_mangling(sizeof(struct sigaction ));
#line 94
    if (tmp___10) {
#line 94
      tmp___8 = (struct sigaction  __attribute__((__compat__)) *)__trusted_cast((void *)p_oact_compat__ptrof);
    } else {
#line 94
      tmp___8 = & p_oact_compat__area;
    }
  } else {
#line 94
    tmp___8 = (struct sigaction  __attribute__((__compat__)) *)__trusted_cast((void *)p_oact_compat__ptrof);
  }
#line 94
  p_oact_compat = tmp___8;
#line 96
  tmp___11 = sigaction(__sig, (struct sigaction  const  */* __restrict  */)p_act_compat,
                       (struct sigaction */* __restrict  */)p_oact_compat);
#line 96
  res = tmp___11;
#line 97
  if ((unsigned int )p_oact_compat != (unsigned int )__oact) {
#line 97
    __deepcopy_sigaction_from_compat(__oact, p_oact_compat);
  }
#line 98
  return (res);
}
}
#line 432 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 433
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 167 "/users/rupak/ccured/include/ccured_GNUCC.patch"
extern FILE *get_stdin(void) ;
#line 168
/* #pragma ccuredpoly("get_stdin") */
#line 169
extern FILE *get_stdout(void) ;
#line 170
/* #pragma ccuredpoly("get_stdout") */
#line 171
extern FILE *get_stderr(void) ;
#line 172
/* #pragma ccuredpoly("get_stderr") */
#line 154 "/usr/include/stdio.h"
extern int remove(char const   *__filename ) ;
#line 202
extern int fclose(FILE *__stream ) ;
#line 204
extern int fflush(FILE *__stream ) ;
#line 221
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 224
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 252
extern FILE *fdopen(int __fd , char const   *__modes ) ;
#line 291
extern void setlinebuf(FILE *__stream ) ;
#line 297
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 319
extern int ( /* format attribute */  snprintf)(char * __restrict  __s , size_t __maxlen ,
                                               char const   * __restrict  __format 
                                               , ...) ;
#line 323
extern int ( /* format attribute */  vsnprintf)(char * __restrict  __s , size_t __maxlen ,
                                                char const   * __restrict  __format ,
                                                __gnuc_va_list __arg ) ;
#line 353
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 383
extern int fgetc(FILE *__stream ) ;
#line 408
extern int fputc(int __c , FILE *__stream ) ;
#line 442
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 479
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 483
extern int puts(char const   *__s ) ;
#line 491
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 494
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 515
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 517
extern long ftell(FILE *__stream ) ;
#line 519
extern void rewind(FILE *__stream ) ;
#line 577
extern void clearerr(FILE *__stream ) ;
#line 581
extern int ferror(FILE *__stream ) ;
#line 594
extern void perror(char const   *__s ) ;
#line 606
extern int fileno(FILE *__stream ) ;
#line 58 "/users/rupak/ccured/include/stdio_wrappers.h"
extern FILE *__mkptr_file(FILE * __attribute__((__safe__)) f ) ;
#line 59
/* #pragma ccuredpoly("__mkptr_file") */
#line 64
extern FILE * __attribute__((__safe__)) __ptrof_file(FILE *f ) ;
#line 65
/* #pragma ccuredpoly("__ptrof_file") */
#line 68
/* #pragma ccuredvararg("printf",printf(1)) */
#line 69
/* #pragma ccuredvararg("fprintf",printf(2)) */
#line 70
/* #pragma ccuredvararg("snprintf",printf(3)) */
#line 71
/* #pragma ccuredvararg("syslog",printf(2)) */
#line 72
/* #pragma ccuredvararg("sprintf",printf(2)) */
#line 73
/* #pragma ccuredvararg("vsprintf",printf(2)) */
#line 74
/* #pragma ccuredvararg("vfprintf",printf(2)) */
#line 75
/* #pragma ccuredvararg("vprintf",printf(1)) */
#line 76
/* #pragma ccuredvararg("vsyslog",printf(2)) */
#line 78
/* #pragma ccuredpoly("__endof") */
#line 87
extern void ccured_fscanf_string_len(FILE * , char *format , char *buffer , long bufflen ) ;
#line 89
/* #pragma ccuredpoly("ccured_fscanf_string") */
#line 92
/* #pragma ccuredwrapper("ccured_fscanf_string_wrapper",of("ccured_fscanf_string")) */
#line 93 "/users/rupak/ccured/include/stdio_wrappers.h"
__inline static void ccured_fscanf_string_wrapper(FILE *f , char *format , char *buffer ) 
{ long bufflen ;
  void * __attribute__((__safe__)) tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  FILE *tmp___2 ;

  {
#line 95
  tmp = __endof((void *)buffer);
#line 95
  bufflen = (long )tmp - (long )buffer;
#line 96
  __verify_nul((char const   *)format);
#line 97
  tmp___0 = (char *)__ptrof((void *)buffer);
#line 97
  tmp___1 = (char *)__ptrof((void *)format);
#line 97
  tmp___2 = (FILE *)__ptrof((void *)f);
#line 97
  ccured_fscanf_string_len(tmp___2, tmp___1, tmp___0, bufflen);
#line 99
  return;
}
}
#line 117
/* #pragma ccuredvararg("sscanf",sizeof(struct scanf_format )) */
#line 118
/* #pragma ccuredvararg("fscanf",sizeof(struct scanf_format )) */
#line 123
/* #pragma ccuredwrapper("fgets_wrapper",of("fgets")) */
#line 124 "/users/rupak/ccured/include/stdio_wrappers.h"
__inline static char *fgets_wrapper(char *buf , int size , FILE *fp ) 
{ char *res ;
  FILE *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 127
  __write_at_least((void *)buf, (unsigned int )size);
#line 128
  tmp = __ptrof_file(fp);
#line 128
  tmp___0 = (char *)__ptrof((void *)buf);
#line 128
  res = fgets((char */* __restrict  */)tmp___0, size, (FILE */* __restrict  */)tmp);
#line 129
  tmp___1 = (char *)__mkptr((void */* __attribute__((__safe__)) */)res, (void *)buf);
#line 129
  return (tmp___1);
}
}
#line 132
/* #pragma ccuredwrapper("fopen_wrapper",of("fopen")) */
#line 133 "/users/rupak/ccured/include/stdio_wrappers.h"
__inline static FILE *fopen_wrapper(char const   *fname , char const   *mode ) 
{ char const   * __restrict  tmp ;
  char const   * __restrict  tmp___0 ;
  FILE * __attribute__((__safe__)) tmp___1 ;
  FILE *tmp___2 ;

  {
#line 136
  tmp = __stringof(mode);
#line 136
  tmp___0 = __stringof(fname);
#line 136
  tmp___1 = fopen(tmp___0, tmp);
#line 136
  tmp___2 = __mkptr_file(tmp___1);
#line 136
  return (tmp___2);
}
}
#line 139
/* #pragma ccuredwrapper("fdopen_wrapper",of("fdopen")) */
#line 140 "/users/rupak/ccured/include/stdio_wrappers.h"
__inline static FILE *fdopen_wrapper(int filedes , char const   *mode ) 
{ char const   *tmp ;
  FILE * __attribute__((__safe__)) tmp___0 ;
  FILE *tmp___1 ;

  {
#line 143
  tmp = __stringof(mode);
#line 143
  tmp___0 = fdopen(filedes, tmp);
#line 143
  tmp___1 = __mkptr_file(tmp___0);
#line 143
  return (tmp___1);
}
}
#line 146
/* #pragma ccuredwrapper("fflush_wrapper",of("fflush")) */
#line 147 "/users/rupak/ccured/include/stdio_wrappers.h"
__inline static int fflush_wrapper(FILE *f ) 
{ FILE *tmp ;
  int tmp___0 ;

  {
#line 150
  tmp = __ptrof_file(f);
#line 150
  tmp___0 = fflush(tmp);
#line 150
  return (tmp___0);
}
}
#line 152
/* #pragma ccuredwrapper("fclose_wrapper",of("fclose")) */
#line 153 "/users/rupak/ccured/include/stdio_wrappers.h"
__inline static int fclose_wrapper(FILE *f ) 
{ FILE *tmp ;
  int tmp___0 ;

  {
#line 156
  tmp = __ptrof_file(f);
#line 156
  tmp___0 = fclose(tmp);
#line 156
  return (tmp___0);
}
}
#line 179
/* #pragma ccuredwrapper("_IO_putc_wrapper",of("_IO_putc")) */
#line 180 "/users/rupak/ccured/include/stdio_wrappers.h"
__inline static int _IO_putc_wrapper(int c , FILE *fl ) 
{ FILE *tmp ;
  int tmp___0 ;

  {
#line 182
  tmp = __ptrof_file(fl);
#line 182
  tmp___0 = _IO_putc(c, tmp);
#line 182
  return (tmp___0);
}
}
#line 185
/* #pragma ccuredwrapper("_IO_getc_wrapper",of("_IO_getc")) */
#line 186 "/users/rupak/ccured/include/stdio_wrappers.h"
__inline static int _IO_getc_wrapper(FILE *fl ) 
{ FILE *tmp ;
  int tmp___0 ;

  {
#line 188
  tmp = __ptrof_file(fl);
#line 188
  tmp___0 = _IO_getc(tmp);
#line 188
  return (tmp___0);
}
}
#line 210
/* #pragma ccuredwrapper("fputc_wrapper",of("fputc")) */
#line 211 "/users/rupak/ccured/include/stdio_wrappers.h"
__inline static int fputc_wrapper(int c , FILE *fl ) 
{ FILE *tmp ;
  int tmp___0 ;

  {
#line 213
  tmp = __ptrof_file(fl);
#line 213
  tmp___0 = fputc(c, tmp);
#line 213
  return (tmp___0);
}
}
#line 216
/* #pragma ccuredwrapper("fputs_wrapper",of("fputs")) */
#line 217 "/users/rupak/ccured/include/stdio_wrappers.h"
__inline static int fputs_wrapper(char const   *s , FILE *fl ) 
{ FILE *tmp ;
  char const   * __restrict  tmp___0 ;
  int tmp___1 ;

  {
#line 219
  tmp = __ptrof_file(fl);
#line 219
  tmp___0 = __stringof(s);
#line 219
  tmp___1 = fputs(tmp___0, (FILE */* __restrict  */)tmp);
#line 219
  return (tmp___1);
}
}
#line 222
/* #pragma ccuredwrapper("fgetc_wrapper",of("fgetc")) */
#line 223 "/users/rupak/ccured/include/stdio_wrappers.h"
__inline static int fgetc_wrapper(FILE *fl ) 
{ FILE *tmp ;
  int tmp___0 ;

  {
#line 225
  tmp = __ptrof_file(fl);
#line 225
  tmp___0 = fgetc(tmp);
#line 225
  return (tmp___0);
}
}
#line 228
/* #pragma ccuredwrapper("puts_wrapper",of("puts")) */
#line 229 "/users/rupak/ccured/include/stdio_wrappers.h"
__inline static int puts_wrapper(char *s ) 
{ char *tmp ;
  int tmp___0 ;

  {
#line 231
  tmp = (char *)__ptrof((void *)s);
#line 231
  tmp___0 = puts((char const   *)tmp);
#line 231
  return (tmp___0);
}
}
#line 234
/* #pragma ccuredwrapper("fileno_wrapper",of("fileno")) */
#line 235 "/users/rupak/ccured/include/stdio_wrappers.h"
__inline static int fileno_wrapper(FILE *f ) 
{ FILE *tmp ;
  int tmp___0 ;

  {
#line 237
  tmp = (FILE *)__ptrof((void *)f);
#line 237
  tmp___0 = fileno(tmp);
#line 237
  return (tmp___0);
}
}
#line 240
/* #pragma ccuredwrapper("ferror_wrapper",of("ferror")) */
#line 241 "/users/rupak/ccured/include/stdio_wrappers.h"
__inline static int ferror_wrapper(FILE *f ) 
{ FILE *tmp ;
  int tmp___0 ;

  {
#line 243
  tmp = (FILE *)__ptrof((void *)f);
#line 243
  tmp___0 = ferror(tmp);
#line 243
  return (tmp___0);
}
}
#line 246
/* #pragma ccuredwrapper("fseek_wrapper",of("fseek")) */
#line 247 "/users/rupak/ccured/include/stdio_wrappers.h"
__inline static int fseek_wrapper(FILE *fp , long offset , int whence ) 
{ FILE *tmp ;
  int tmp___0 ;

  {
#line 250
  tmp = __ptrof_file(fp);
#line 250
  tmp___0 = fseek(tmp, offset, whence);
#line 250
  return (tmp___0);
}
}
#line 253
/* #pragma ccuredwrapper("clearerr_wrapper",of("clearerr")) */
#line 254 "/users/rupak/ccured/include/stdio_wrappers.h"
__inline static void clearerr_wrapper(FILE *fp ) 
{ FILE *tmp ;

  {
#line 257
  tmp = __ptrof_file(fp);
#line 257
  clearerr(tmp);
#line 258
  return;
}
}
#line 264
/* #pragma ccuredwrapper("fread_wrapper",of("fread")) */
#line 265 "/users/rupak/ccured/include/stdio_wrappers.h"
__inline static size_t fread_wrapper(char *buff , size_t size , size_t count , FILE *fl ) 
{ size_t requested ;
  size_t tmp ;
  size_t res ;
  FILE *tmp___0 ;
  void * __restrict  tmp___1 ;

  {
#line 268
  tmp = __ccured_mult_u32(size, count);
#line 268
  requested = tmp;
#line 270
  __write_at_least((void *)buff, requested);
#line 271
  tmp___0 = __ptrof_file(fl);
#line 271
  tmp___1 = __ptrof((void *)buff);
#line 271
  res = fread(tmp___1, size, count, (FILE */* __restrict  */)tmp___0);
#line 272
  return (res);
}
}
#line 275
/* #pragma ccuredwrapper("fwrite_wrapper",of("fwrite")) */
#line 276 "/users/rupak/ccured/include/stdio_wrappers.h"
__inline static size_t fwrite_wrapper(char *buff , size_t size , size_t count , FILE *fl ) 
{ size_t requested ;
  size_t tmp ;
  size_t res ;
  FILE *tmp___0 ;
  void const   * __restrict  tmp___1 ;

  {
#line 279
  tmp = __ccured_mult_u32(size, count);
#line 279
  requested = tmp;
#line 281
  __write_at_least((void *)buff, requested);
#line 282
  tmp___0 = __ptrof_file(fl);
#line 282
  tmp___1 = __ptrof((void *)buff);
#line 282
  res = fwrite(tmp___1, size, count, (FILE */* __restrict  */)tmp___0);
#line 283
  return (res);
}
}
#line 288
/* #pragma ccuredwrapper("gets_wrapper",of("gets")) */
#line 289 "/users/rupak/ccured/include/stdio_wrappers.h"
__inline static char *gets_wrapper(char *buffer ) 
{ char *res ;
  FILE *tmp ;
  void * __attribute__((__safe__)) tmp___0 ;
  void * __attribute__((__safe__)) tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 292
  tmp = get_stdin();
#line 292
  tmp___0 = __endof((void *)buffer);
#line 292
  tmp___1 = __ptrof_nocheck((void *)buffer);
#line 292
  tmp___2 = fgets_wrapper(buffer, (int )((unsigned int )tmp___0 - (unsigned int )tmp___1),
                          tmp);
#line 292
  res = tmp___2;
#line 294
  if ((unsigned int )res != (unsigned int )((void *)0)) {
#line 295
    tmp___3 = res;
#line 296
    while (1) {
#line 296
      if ((int )(*tmp___3) != 10) {
#line 296
        if (! ((int )(*tmp___3) != 0)) {
#line 296
          break;
        }
      } else {
#line 296
        break;
      }
#line 298
      tmp___3 ++;
    }
#line 300
    (*tmp___3) = (char )'\000';
  }
#line 302
  return (res);
}
}
#line 309
extern int __ccured_vsnprintf(char * __attribute__((__safe__)) buffer , int size ,
                              char const   * __attribute__((__safe__)) format , __ccured_va_list args ) ;
#line 314
/* #pragma ccuredvararg("vsnprintf_wrapper",printf(3)) */
#line 315
/* #pragma ccuredwrapper("vsnprintf_wrapper",of("vsnprintf")) */
#line 316 "/users/rupak/ccured/include/stdio_wrappers.h"
__inline static int vsnprintf_wrapper(char *buf , size_t n , char const   *format ,
                                      __ccured_va_list ap ) 
{ char const   * __attribute__((__safe__)) tmp ;
  char * __attribute__((__safe__)) tmp___0 ;
  int tmp___1 ;

  {
#line 318
  __write_at_least((void *)buf, n);
#line 319
  tmp = __stringof(format);
#line 319
  tmp___0 = (char */* __attribute__((__safe__)) */)__ptrof((void *)buf);
#line 319
  tmp___1 = __ccured_vsnprintf(tmp___0, (int )n, tmp, ap);
#line 319
  return (tmp___1);
}
}
#line 322
/* #pragma ccuredvararg("vsprintf_wrapper",printf(2)) */
#line 323
/* #pragma ccuredwrapper("vsprintf_wrapper",of("vsprintf")) */
#line 324 "/users/rupak/ccured/include/stdio_wrappers.h"
__inline static int vsprintf_wrapper(char *buf , char const   *format , __ccured_va_list ap ) 
{ int n ;
  void * __attribute__((__safe__)) tmp ;
  int tmp___0 ;

  {
#line 326
  tmp = __endof((void *)buf);
#line 326
  n = (char *)tmp - buf;
#line 327
  tmp___0 = vsnprintf_wrapper(buf, (unsigned int )n, format, ap);
#line 327
  return (tmp___0);
}
}
#line 330
/* #pragma ccuredvararg("snprintf_wrapper",printf(3)) */
#line 331
/* #pragma ccuredwrapper("snprintf_wrapper",of("snprintf")) */
#line 332 "/users/rupak/ccured/include/stdio_wrappers.h"
__inline static int snprintf_wrapper(char *buf , size_t n , char const   *format 
                                     , ...) 
{ __ccured_va_list ap ;
  int res ;
  unsigned long tmp ;
  char const   * __attribute__((__safe__)) tmp___0 ;
  char * __attribute__((__safe__)) tmp___1 ;

  {
#line 336
  __write_at_least((void *)buf, n);
#line 337
  tmp = GCC_STDARG_START();
#line 337
  __ccured_va_start(ap, tmp);
#line 338
  tmp___0 = __stringof(format);
#line 338
  tmp___1 = (char */* __attribute__((__safe__)) */)__ptrof((void *)buf);
#line 338
  res = __ccured_vsnprintf(tmp___1, (int )n, tmp___0, ap);
#line 339
  __ccured_va_end(ap);
#line 340
  return (res);
}
}
#line 343
/* #pragma ccuredvararg("sprintf_wrapper",printf(2)) */
#line 344
/* #pragma ccuredwrapper("sprintf_wrapper",of("sprintf")) */
#line 345 "/users/rupak/ccured/include/stdio_wrappers.h"
__inline static int sprintf_wrapper(char *buf , char const   *format  , ...) 
{ __ccured_va_list ap ;
  int res ;
  int size ;
  void * __attribute__((__safe__)) tmp ;
  void * __attribute__((__safe__)) tmp___0 ;
  unsigned long tmp___1 ;
  char const   * __attribute__((__safe__)) tmp___2 ;
  char * __attribute__((__safe__)) tmp___3 ;

  {
#line 349
  tmp = __endof((void *)buf);
#line 349
  tmp___0 = __ptrof_nocheck((void *)buf);
#line 349
  size = (int )((unsigned int )tmp - (unsigned int )tmp___0);
#line 350
  __write_at_least((void *)buf, (unsigned int )size);
#line 351
  tmp___1 = GCC_STDARG_START();
#line 351
  __ccured_va_start(ap, tmp___1);
#line 352
  tmp___2 = __stringof(format);
#line 352
  tmp___3 = (char */* __attribute__((__safe__)) */)__ptrof((void *)buf);
#line 352
  res = __ccured_vsnprintf(tmp___3, size, tmp___2, ap);
#line 353
  __ccured_va_end(ap);
#line 354
  if (res < 0) {
#line 358
    ccured_fail(3, (char *)"/users/rupak/ccured/include/stdio_wrappers.h", 358, (char *)"sprintf_wrapper");
  } else {
#line 354
    if (res >= size) {
#line 358
      ccured_fail(3, (char *)"/users/rupak/ccured/include/stdio_wrappers.h", 358,
                  (char *)"sprintf_wrapper");
    }
  }
#line 360
  return (res);
}
}
#line 366
/* #pragma ccuredpoly("ccured_fscanf_double") */
#line 382
/* #pragma ccuredpoly("ccured_fscanf_int") */
#line 398
/* #pragma ccuredpoly("ccured_fscanf_nothing") */
#line 467
/* #pragma ccuredwrapper("perror_wrapper",of("perror")) */
#line 468 "/users/rupak/ccured/include/stdio_wrappers.h"
void perror_wrapper(char const   *s ) 
{ char const   *tmp ;

  {
#line 469
  tmp = __stringof(s);
#line 469
  perror(tmp);
#line 470
  return;
}
}
#line 51 "/usr/include/sys/file.h"
extern int flock(int __fd , int __operation ) ;
#line 255 "/users/rupak/ccured/include/gcc_3.2/sys/stat.h"
extern int chmod(char const   *__file , __mode_t __mode ) ;
#line 266
extern int fchmod(int __fd , __mode_t __mode ) ;
#line 272
extern __mode_t umask(__mode_t __mask ) ;
#line 281
extern int mkdir(char const   *__path , __mode_t __mode ) ;
#line 319
extern int __fxstat(int __ver , int __fildes , struct stat *__stat_buf ) ;
#line 320
extern int __xstat(int __ver , char const   *__filename , struct stat *__stat_buf ) ;
#line 356 "/users/rupak/ccured/include/gcc_3.2/sys/stat.h"
__inline static int stat__extinline(char const   *__path , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 359
  tmp = __xstat(3, __path, __statbuf);
#line 359
  return (tmp);
}
}
#line 370 "/users/rupak/ccured/include/gcc_3.2/sys/stat.h"
__inline static int fstat__extinline(int __fd , struct stat *__statbuf ) 
{ int tmp ;

  {
#line 372
  tmp = __fxstat(3, __fd, __statbuf);
#line 372
  return (tmp);
}
}
#line 49 "/users/rupak/ccured/include/stat_wrappers.h"
/* #pragma ccuredwrapper("fstat_wrapper",of("fstat")) */
#line 50 "/users/rupak/ccured/include/stat_wrappers.h"
__inline static int fstat_wrapper(int fid , struct stat *buff ) 
{ struct stat *tmp ;
  int tmp___0 ;

  {
#line 53
  __write_at_least((void *)buff, sizeof(struct stat ));
#line 54
  tmp = (struct stat *)__ptrof((void *)buff);
#line 54
  tmp___0 = fstat__extinline(fid, tmp);
#line 54
  return (tmp___0);
}
}
#line 57
/* #pragma ccuredwrapper("stat_wrapper",of("stat")) */
#line 58 "/users/rupak/ccured/include/stat_wrappers.h"
__inline static int stat_wrapper(char *path , struct stat *buff ) 
{ struct stat *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 61
  __write_at_least((void *)buff, sizeof(struct stat ));
#line 62
  __verify_nul((char const   *)path);
#line 63
  tmp = (struct stat *)__ptrof((void *)buff);
#line 63
  tmp___0 = (char const   *)__ptrof((void *)path);
#line 63
  tmp___1 = stat__extinline(tmp___0, tmp);
#line 63
  return (tmp___1);
}
}
#line 68
/* #pragma ccuredwrapper("__xstat_wrapper",of("__xstat")) */
#line 69 "/users/rupak/ccured/include/stat_wrappers.h"
__inline static int __xstat_wrapper(int __ver , char const   *__filename , struct stat *__stat_buf ) 
{ struct stat *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
#line 73
  __write_at_least((void *)__stat_buf, sizeof((*__stat_buf)));
#line 74
  tmp = (struct stat *)__ptrof((void *)__stat_buf);
#line 74
  tmp___0 = __stringof(__filename);
#line 74
  tmp___1 = __xstat(__ver, tmp___0, tmp);
#line 74
  return (tmp___1);
}
}
#line 99 "/usr/include/sys/resource.h"
extern int setpriority(__priority_which_t __which , id_t __who , int __prio ) ;
#line 156 "/usr/include/sys/wait.h"
extern __pid_t wait3(union wait *__stat_loc , int __options , struct rusage *__usage ) ;
#line 172 "/usr/include/sys/syslog.h"
extern void closelog(void) ;
#line 175
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 182
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 191 "/users/rupak/ccured/include/gcc_3.2/time.h"
extern time_t mktime(struct tm *__tp ) ;
#line 197
extern size_t strftime(char * __restrict  __s , size_t __maxsize , char const   * __restrict  __format ,
                       struct tm  const  * __restrict  __tp ) ;
#line 233
extern struct tm *localtime(time_t const   *__timer ) ;
#line 251
extern char *asctime(struct tm  const  *timep ) ;
#line 79 "/users/rupak/ccured/include/time_wrappers.h"
/* #pragma ccuredwrapper("asctime_wrapper",of("asctime")) */
#line 80 "/users/rupak/ccured/include/time_wrappers.h"
__inline static char *asctime_wrapper(struct tm  const  *timep ) 
{ struct tm *thinTimep ;
  struct tm *tmp ;
  char *thinRet ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 83
  tmp = (struct tm *)__ptrof((void *)timep);
#line 83
  thinTimep = tmp;
#line 84
  tmp___0 = asctime((struct tm  const  *)thinTimep);
#line 84
  thinRet = tmp___0;
#line 85
  tmp___1 = __mkptr_string((char */* __attribute__((__safe__)) */)thinRet);
#line 85
  return (tmp___1);
}
}
#line 260 "/users/rupak/ccured/include/gcc_3.2/unistd.h"
extern int access(char const   *__name , int __type ) ;
#line 306
extern int close(int __fd ) ;
#line 310
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 313
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 353
extern int pipe(int *__pipedes ) ;
#line 398
extern int fchown(int __fd , __uid_t __owner , __gid_t __group ) ;
#line 409
extern int chdir(char const   *__path ) ;
#line 444
extern int dup2(int __fd , int __fd2 ) ;
#line 455
extern int execve(char const   *__path , char * const  *__argv , char * const  *__envp ) ;
#line 467
extern int execv(char const   *__path , char * const  *__argv ) ;
#line 475
extern int execl(char const   *__path , char const   *__arg  , ...) ;
#line 479
extern int execvp(char const   *__file , char * const  *__argv ) ;
#line 484
extern int execlp(char const   *__file , char const   *__arg  , ...) ;
#line 489
extern int nice(int __inc ) ;
#line 518
extern __pid_t getpid(void) ;
#line 580
extern __pid_t setsid(void) ;
#line 588
extern __uid_t getuid(void) ;
#line 613
extern int setuid(__uid_t __uid ) ;
#line 630
extern int setgid(__gid_t __gid ) ;
#line 665
extern __pid_t fork(void) ;
#line 678
extern char *ttyname(int __fd ) ;
#line 725
extern char *getlogin(void) ;
#line 752
extern int gethostname(char *__name , size_t __len ) ;
#line 798
extern char *getusershell(void) ;
#line 859
extern int ftruncate(int __fd , __off_t __length ) ;
#line 13 "/users/rupak/ccured/include/functions/deepcopy_stringarray.h"
/* #pragma cilnoremove("__deepcopy_stringarray_from_compat") */
#line 14
/* #pragma ccuredpoly("__deepcopy_stringarray_from_compat") */
#line 15 "/users/rupak/ccured/include/functions/deepcopy_stringarray.h"
__inline static char **__deepcopy_stringarray_from_compat(char * __attribute__((__safe__)) * __attribute__((__safe__)) array_in ) 
{ int num_strings ;
  int i ;
  char *   *new_array ;
  char * __attribute__((__safe__)) * __attribute__((__safe__)) p ;
  void * __attribute__((__safe__)) tmp ;
  char **tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;

  {
#line 17
  num_strings = 0;
#line 24
  if ((unsigned int )array_in == (unsigned int )((char * __attribute__((__safe__)) */* __attribute__((__safe__)) */)0)) {
#line 25
    return ((char **)0);
  }
#line 28
  p = array_in;
#line 29
  while ((unsigned int )(*p) != (unsigned int )((char */* __attribute__((__safe__)) */)0)) {
#line 31
    p = (char * __attribute__((__safe__)) */* __attribute__((__safe__)) */)__trusted_cast((void *)((unsigned long )p +
                                                                                                   (unsigned long )(1U *
                                                                                                                    sizeof((*p)))));
#line 32
    num_strings ++;
  }
#line 34
  num_strings ++;
#line 36
  tmp___2 = __ccured_has_empty_mangling(sizeof((*new_array)));
#line 36
  if (tmp___2) {
#line 38
    tmp = __trusted_deepcast((void */* __attribute__((__safe__)) */)array_in);
#line 38
    tmp___0 = (char **)__mkptr_size(tmp, (unsigned int )num_strings * sizeof((*(new_array +
                                                                                0))));
#line 38
    return (tmp___0);
  } else {
#line 42
    tmp___1 = wrapperAlloc((unsigned int )num_strings * sizeof((*(new_array + 0))));
#line 42
    new_array = (char *   *)((char **)tmp___1);
#line 43
    i = 0;
#line 43
    while (i < num_strings) {
#line 46
      p = (char * __attribute__((__safe__)) */* __attribute__((__safe__)) */)__trusted_cast((void *)((unsigned long )array_in +
                                                                                                     (unsigned long )((unsigned int )i *
                                                                                                                      sizeof((*array_in)))));
#line 47
      (*(new_array + i)) = __mkptr_string((*p));
#line 43
      i ++;
    }
  }
#line 50
  return ((char **)new_array);
}
}
#line 53
/* #pragma ccuredpoly("__deepcopy_stringarray_to_compat") */
#line 54 "/users/rupak/ccured/include/functions/deepcopy_stringarray.h"
__inline static char * __attribute__((__safe__)) * __attribute__((__safe__)) __deepcopy_stringarray_to_compat(char **array_in ) 
{ int num_strings ;
  void * __attribute__((__safe__)) tmp ;
  void * __attribute__((__safe__)) tmp___0 ;
  int i ;
  char *  __attribute__((__safe__)) * __attribute__((__safe__)) new_array ;
  void * __attribute__((__safe__)) tmp___1 ;
  char * __attribute__((__safe__)) * __attribute__((__safe__)) tmp___2 ;
  void *tmp___3 ;
  char *  __attribute__((__safe__)) * __attribute__((__safe__)) p_new_array ;
  char *  __attribute__((__safe__)) * __attribute__((__safe__)) tmp___4 ;
  int tmp___5 ;

  {
#line 56
  tmp = __endof((void *)array_in);
#line 56
  tmp___0 = __ptrof_nocheck((void *)array_in);
#line 56
  num_strings = (int )(((unsigned int )tmp - (unsigned int )tmp___0) / sizeof((*array_in)));
#line 60
  if ((unsigned int )array_in == (unsigned int )((char **)0)) {
#line 61
    return ((char * __attribute__((__safe__)) */* __attribute__((__safe__)) */)0);
  }
#line 64
  tmp___5 = __ccured_has_empty_mangling(sizeof((*array_in)));
#line 64
  if (tmp___5) {
#line 66
    tmp___1 = __ptrof((void *)array_in);
#line 66
    tmp___2 = (char * __attribute__((__safe__)) */* __attribute__((__safe__)) */)__trusted_deepcast(tmp___1);
#line 66
    return (tmp___2);
  } else {
#line 69
    tmp___3 = wrapperAlloc((unsigned int )num_strings * sizeof((*new_array)));
#line 69
    new_array = (char *  __attribute__((__safe__)) */* __attribute__((__safe__)) */)((char **)tmp___3);
#line 70
    i = 0;
#line 70
    while (i < num_strings) {
#line 71
      tmp___4 = (char *  __attribute__((__safe__)) */* __attribute__((__safe__)) */)__trusted_cast((void *)((unsigned long )new_array +
                                                                                                            (unsigned long )((unsigned int )i *
                                                                                                                             sizeof((*new_array)))));
#line 71
      p_new_array = tmp___4;
#line 73
      if ((unsigned int )(*(array_in + i)) != (unsigned int )((void *)0)) {
#line 74
        (*p_new_array) = __stringof((char const   *)(*(array_in + i)));
      } else {
#line 76
        (*p_new_array) = (char */*  __attribute__((__safe__)) */)((char *)0);
      }
#line 70
      i ++;
    }
  }
#line 81
  return ((char * __attribute__((__safe__)) */* __attribute__((__safe__)) */)new_array);
}
}
#line 44 "/users/rupak/ccured/include/unistd_wrappers.h"
/* #pragma ccuredwrapper("execv_wrapper",of("execv")) */
#line 45 "/users/rupak/ccured/include/unistd_wrappers.h"
__inline static int execv_wrapper(char *path , char **argv ) 
{ int ret ;
  char * __attribute__((__safe__)) *thinArgv ;
  void *e ;
  void *tmp ;
  char * const  *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 50
  tmp = __endof((void *)argv);
#line 50
  e = tmp;
#line 52
  __verify_nul((char const   *)path);
#line 53
  thinArgv = __deepcopy_stringarray_to_compat(argv);
#line 55
  tmp___0 = (char * const  *)__ptrof((void *)thinArgv);
#line 55
  tmp___1 = (char const   *)__ptrof((void *)path);
#line 55
  ret = execv(tmp___1, tmp___0);
#line 59
  free_wrapper((void *)thinArgv);
#line 61
  return (ret);
}
}
#line 66
/* #pragma ccuredwrapper("execvp_wrapper",of("execvp")) */
#line 67 "/users/rupak/ccured/include/unistd_wrappers.h"
__inline static int execvp_wrapper(char *path , char **argv ) 
{ int ret ;
  char * __attribute__((__safe__)) *thinArgv ;
  void *e ;
  void *tmp ;
  char * const  *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 72
  tmp = __endof((void *)argv);
#line 72
  e = tmp;
#line 74
  __verify_nul((char const   *)path);
#line 75
  thinArgv = __deepcopy_stringarray_to_compat(argv);
#line 77
  tmp___0 = (char * const  *)__ptrof((void *)thinArgv);
#line 77
  tmp___1 = (char const   *)__ptrof((void *)path);
#line 77
  ret = execvp(tmp___1, tmp___0);
#line 81
  free_wrapper((void *)thinArgv);
#line 83
  return (ret);
}
}
#line 86
/* #pragma ccuredwrapper("execve_wrapper",of("execve")) */
#line 87 "/users/rupak/ccured/include/unistd_wrappers.h"
__inline static int execve_wrapper(char *path , char **argv , char **envp ) 
{ int ret ;
  char * __attribute__((__safe__)) *thinArgv ;
  char * __attribute__((__safe__)) *thinEnvp ;
  char * const  *tmp ;
  char * const  *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 94
  __verify_nul((char const   *)path);
#line 95
  thinArgv = __deepcopy_stringarray_to_compat(argv);
#line 96
  thinEnvp = __deepcopy_stringarray_to_compat(envp);
#line 98
  tmp = (char * const  *)__ptrof((void *)thinEnvp);
#line 98
  tmp___0 = (char * const  *)__ptrof((void *)thinArgv);
#line 98
  tmp___1 = (char const   *)__ptrof((void *)path);
#line 98
  ret = execve(tmp___1, tmp___0, tmp);
#line 100
  free_wrapper((void *)thinArgv);
#line 101
  free_wrapper((void *)thinEnvp);
#line 102
  return (ret);
}
}
#line 106
/* #pragma ccuredvararg("execl",sizeof(struct __ccured_execl_arguments )) */
#line 107
/* #pragma ccuredvararg("execlp",sizeof(struct __ccured_execl_arguments )) */
#line 108
/* #pragma ccuredvararg("execle",sizeof(struct __ccured_execl_arguments )) */
#line 110
/* #pragma ccuredwrapper("getlogin_wrapper",of("getlogin")) */
#line 111 "/users/rupak/ccured/include/unistd_wrappers.h"
__inline static char *getlogin_wrapper(void) 
{ char * __attribute__((__safe__)) tmp ;
  char *tmp___0 ;

  {
#line 114
  tmp = getlogin();
#line 114
  tmp___0 = __mkptr_string(tmp);
#line 114
  return (tmp___0);
}
}
#line 117
/* #pragma ccuredwrapper("ttyname_wrapper",of("ttyname")) */
#line 118 "/users/rupak/ccured/include/unistd_wrappers.h"
__inline static char *ttyname_wrapper(int filedes ) 
{ char * __attribute__((__safe__)) tmp ;
  char *tmp___0 ;

  {
#line 121
  tmp = ttyname(filedes);
#line 121
  tmp___0 = __mkptr_string(tmp);
#line 121
  return (tmp___0);
}
}
#line 129
/* #pragma ccuredwrapper("getopt_wrapper",of("getopt")) */
#line 130
extern char *ccured_get_optarg(void) ;
#line 132 "/users/rupak/ccured/include/unistd_wrappers.h"
__inline static int getopt_wrapper(int argc , char **argv , char const   *optstring ) 
{ char * __attribute__((__safe__)) *thinArgv ;
  int ret ;
  char const   *tmp ;
  char * __attribute__((__safe__)) tmp___0 ;

  {
#line 139
  __read_at_least((void *)argv, (unsigned int )argc * sizeof((*argv)));
#line 146
  if (optind > argc) {
#line 147
    ccured_fail_str((char *)"you have to reset \'optind\' between sets of calls to getopt()",
                    (char *)"/users/rupak/ccured/include/unistd_wrappers.h", 148,
                    (char *)"getopt_wrapper");
  }
#line 155
  thinArgv = __deepcopy_stringarray_to_compat(argv);
#line 156
  __verify_nul(optstring);
#line 157
  tmp = (char const   *)__ptrof((void *)optstring);
#line 157
  ret = getopt(argc, (char * const  *)thinArgv, tmp);
#line 158
  free_wrapper((void *)thinArgv);
#line 163
  tmp___0 = ccured_get_optarg();
#line 163
  optarg = __mkptr_string(tmp___0);
#line 164
  return (ret);
}
}
#line 174
/* #pragma ccuredwrapper("read_wrapper",of("read")) */
#line 175 "/users/rupak/ccured/include/unistd_wrappers.h"
__inline static int read_wrapper(int fid , char *buff , unsigned int size ) 
{ void *tmp ;
  int tmp___0 ;

  {
#line 178
  __write_at_least((void *)buff, size);
#line 179
  tmp = __ptrof((void *)buff);
#line 179
  tmp___0 = read(fid, tmp, size);
#line 179
  return (tmp___0);
}
}
#line 182
/* #pragma ccuredwrapper("write_wrapper",of("write")) */
#line 183 "/users/rupak/ccured/include/unistd_wrappers.h"
__inline static int write_wrapper(int fid , char *buff , unsigned int size ) 
{ void * __attribute__((__safe__)) tmp ;
  void * __attribute__((__safe__)) tmp___0 ;
  void const   *tmp___1 ;
  int tmp___2 ;

  {
#line 186
  tmp = __endof((void *)buff);
#line 186
  tmp___0 = __ptrof_nocheck((void *)buff);
#line 186
  if ((unsigned int )tmp - (unsigned int )tmp___0 < size) {
#line 186
    ccured_fail(3, (char *)"/users/rupak/ccured/include/unistd_wrappers.h", 186, (char *)"write_wrapper");
  }
#line 187
  tmp___1 = __ptrof((void *)buff);
#line 187
  tmp___2 = write(fid, tmp___1, size);
#line 187
  return (tmp___2);
}
}
#line 195
/* #pragma ccuredwrapper("getusershell_wrapper",of("getusershell")) */
#line 196 "/users/rupak/ccured/include/unistd_wrappers.h"
__inline static char *getusershell_wrapper(void) 
{ char * __attribute__((__safe__)) tmp ;
  char *tmp___0 ;

  {
#line 199
  tmp = getusershell();
#line 199
  tmp___0 = __mkptr_string(tmp);
#line 199
  return (tmp___0);
}
}
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___1 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___1 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___1 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___1 )) */
#line 156 "/usr/include/security/_pam_types.h"
extern char const   *pam_strerror(pam_handle_t *pamh , int errnum ) ;
#line 160
extern char **pam_getenvlist(pam_handle_t *pamh ) ;
#line 27 "/usr/include/security/pam_appl.h"
extern int pam_start(char const   *service_name , char const   *user , struct pam_conv  const  *pam_conversation ,
                     pam_handle_t **pamh ) ;
#line 30
extern int pam_end(pam_handle_t *pamh , int pam_status ) ;
#line 34
extern int pam_authenticate(pam_handle_t *pamh , int flags ) ;
#line 35
extern int pam_setcred(pam_handle_t *pamh , int flags ) ;
#line 39
extern int pam_acct_mgmt(pam_handle_t *pamh , int flags ) ;
#line 43
extern int pam_open_session(pam_handle_t *pamh , int flags ) ;
#line 44
extern int pam_close_session(pam_handle_t *pamh , int flags ) ;
#line 36 "pam.h"
pam_handle_t *pamh ;
#line 37
struct pam_conv  const  apamconv ;
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___2 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___2 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___2 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___2 )) */
#line 30 "save.h"
int write_file_to_disk(int fd , struct cf_t *file , time_t time_date ) ;
#line 31
int save_file_safe(cf_t *file , char *final_path , char *prog_name___0 , uid_t own_uid ,
                   gid_t own_gid , time_t save_date ) ;
#line 30 "log.h"
void xcloselog(void) ;
#line 31
void explain(char *fmt  , ...) ;
#line 32
void explain_fd(int fd , char *fmt  , ...) ;
#line 33
void explain_e(char *fmt  , ...) ;
#line 34
void warn(char *fmt  , ...) ;
#line 35
void warn_fd(int fd , char *fmt  , ...) ;
#line 36
void warn_e(char *fmt  , ...) ;
#line 37
void error(char *fmt  , ...) ;
#line 38
void error_fd(int fd , char *fmt  , ...) ;
#line 39
void error_e(char *fmt  , ...) ;
#line 40
void die(char *fmt  , ...) ;
#line 41
void die_e(char *fmt  , ...) ;
#line 43
void error_pame(pam_handle_t *pamh___0 , int pamerrno , char *fmt  , ...) ;
#line 44
void die_pame(pam_handle_t *pamh___0 , int pamerrno , char *fmt  , ...) ;
#line 46
void Debug(char *fmt  , ...) ;
#line 47
void send_msg_fd_debug(int fd , char *fmt  , ...) ;
#line 48
void send_msg_fd(int fd , char *fmt  , ...) ;
#line 33 "subs.h"
char *fcronconf ;
#line 34
char *fcronallow ;
#line 35
char *fcrondeny ;
#line 36
char *fcrontabs ;
#line 37
char *pidfile ;
#line 38
char *fifofile ;
#line 39
char *editor ;
#line 40
char *shell ;
#line 41
char *sendmail ;
#line 45
int remove_blanks(char *str ) ;
#line 46
char *strdup2(char const   *str ) ;
#line 47
int get_word(char **str ) ;
#line 48
int temp_file(char **name ) ;
#line 49
void read_conf(void) ;
#line 50
void free_conf(void) ;
#line 33 "/users/rupak/ccured/include/gcc_3.2/crypt.h"
extern char *crypt(char const   *__key , char const   *__salt ) ;
#line 43 "/users/rupak/ccured/include/crypt_wrappers.h"
/* #pragma ccuredwrapper("crypt_wrapper",of("crypt")) */
#line 44 "/users/rupak/ccured/include/crypt_wrappers.h"
__inline static char *crypt_wrapper(char const   *key , char const   *salt ) 
{ char const   *tmp ;
  char const   *tmp___0 ;
  char * __attribute__((__safe__)) tmp___1 ;
  char *tmp___2 ;

  {
#line 47
  __verify_nul(key);
#line 48
  __read_at_least((void *)salt, 2U);
#line 49
  tmp = (char const   *)__ptrof((void *)salt);
#line 49
  tmp___0 = (char const   *)__ptrof((void *)key);
#line 49
  tmp___1 = crypt(tmp___0, tmp);
#line 49
  tmp___2 = __mkptr_string(tmp___1);
#line 49
  return (tmp___2);
}
}
#line 132 "/usr/include/dirent.h"
extern DIR *opendir(char const   *__name ) ;
#line 136
extern int closedir(DIR *__dirp ) ;
#line 146
extern struct dirent *readdir(DIR *__dirp ) ;
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___3 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___3 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___3 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___3 )) */
#line 66 "/users/rupak/ccured/include/gcc_3.2/grp.h"
extern struct group *getgrent(void) ;
#line 81
extern struct group *getgrgid(__gid_t __gid ) ;
#line 84
extern struct group *getgrnam(char const   *__name ) ;
#line 148
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 13 "/users/rupak/ccured/include/grp_wrappers.h"
extern void __deepcopy_group_from_compat(struct group *fat , struct group  __attribute__((__compat__)) *compat ) 
{ 

  {
#line 15
  fat->gr_name = __mkptr_string((char */* __attribute__((__safe__)) */)compat->gr_name);
#line 16
  fat->gr_passwd = __mkptr_string((char */* __attribute__((__safe__)) */)compat->gr_passwd);
#line 18
  fat->gr_mem = __deepcopy_stringarray_from_compat((char * __attribute__((__safe__)) */* __attribute__((__safe__)) */)compat->gr_mem);
#line 19
  return;
}
}
#line 21 "/users/rupak/ccured/include/grp_wrappers.h"
static struct group my_group_result  ;
#line 23
/* #pragma ccuredwrapper("getgrnam_wrapper",of("getgrnam")) */
#line 24 "/users/rupak/ccured/include/grp_wrappers.h"
__inline static struct group *getgrnam_wrapper(char const   *name ) 
{ struct group  __attribute__((__compat__)) *libc_result ;
  char const   *tmp ;

  {
#line 30
  __verify_nul(name);
#line 31
  tmp = (char const   *)__ptrof((void *)name);
#line 31
  libc_result = getgrnam(tmp);
#line 32
  if ((unsigned int )libc_result != (unsigned int )(& my_group_result)) {
#line 32
    __deepcopy_group_from_compat(& my_group_result, libc_result);
  }
#line 33
  if ((unsigned int )libc_result == (unsigned int )((void *)0)) {
#line 34
    return ((struct group *)((void *)0));
  }
#line 36
  return (& my_group_result);
}
}
#line 45
/* #pragma ccuredwrapper("getgrgid_wrapper",of("getgrgid")) */
#line 46 "/users/rupak/ccured/include/grp_wrappers.h"
__inline static struct group *getgrgid_wrapper(__gid_t gid ) 
{ struct group  __attribute__((__compat__)) *libc_result ;
  struct group  __attribute__((__compat__)) *tmp ;

  {
#line 50
  tmp = getgrgid(gid);
#line 50
  libc_result = tmp;
#line 51
  if ((unsigned int )libc_result == (unsigned int )((void *)0)) {
#line 52
    return ((struct group *)((void *)0));
  }
#line 54
  if ((unsigned int )libc_result != (unsigned int )(& my_group_result)) {
#line 54
    __deepcopy_group_from_compat(& my_group_result, libc_result);
  }
#line 55
  return (& my_group_result);
}
}
#line 59
/* #pragma ccuredwrapper("getgrent_wrapper",of("getgrent")) */
#line 60 "/users/rupak/ccured/include/grp_wrappers.h"
__inline static struct group *getgrent_wrapper(void) 
{ struct group  __attribute__((__compat__)) *libc_result ;
  struct group  __attribute__((__compat__)) *tmp ;

  {
#line 64
  tmp = getgrent();
#line 64
  libc_result = tmp;
#line 65
  if ((unsigned int )libc_result == (unsigned int )((void *)0)) {
#line 66
    return ((struct group *)((void *)0));
  }
#line 68
  if ((unsigned int )libc_result != (unsigned int )(& my_group_result)) {
#line 68
    __deepcopy_group_from_compat(& my_group_result, libc_result);
  }
#line 69
  return (& my_group_result);
}
}
#line 67 "/usr/include/shadow.h"
extern struct spwd * __attribute__((__split__)) getspnam(char const   * __attribute__((__split__)) __name )  __attribute__((__compat__)) ;
#line 42 "/users/rupak/ccured/include/gcc_3.2/sys/ioctl.h"
extern int ioctl(int __fd , unsigned long __request  , ...) ;
#line 443 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("ioctl",sizeof(struct ioctl_format )) */
#line 73 "/usr/include/sys/time.h"
extern int gettimeofday(struct timeval * __restrict  __tv , __timezone_ptr_t __tz ) ;
#line 62 "fcron.h"
time_t now  ;
#line 63
char debug_opt ;
#line 64
char foreground ;
#line 65
char dosyslog ;
#line 66
long first_sleep ;
#line 68 "fcron.h"
pid_t daemon_pid  ;
#line 69 "fcron.h"
mode_t saved_umask  ;
#line 70
char *prog_name ;
#line 72 "fcron.h"
struct cf_t *file_base  ;
#line 73 "fcron.h"
struct job_t *queue_base  ;
#line 74 "fcron.h"
unsigned long next_id  ;
#line 75 "fcron.h"
struct cl_t **serial_array  ;
#line 76 "fcron.h"
short serial_array_size  ;
#line 77 "fcron.h"
short serial_array_index  ;
#line 78 "fcron.h"
short serial_num  ;
#line 79 "fcron.h"
short serial_running  ;
#line 80
short serial_max_running ;
#line 81
short serial_queue_max ;
#line 82
short lavg_queue_max ;
#line 83 "fcron.h"
struct exe_t *exe_array  ;
#line 84 "fcron.h"
short exe_array_size  ;
#line 85 "fcron.h"
short exe_num  ;
#line 86 "fcron.h"
struct lavg_t *lavg_array  ;
#line 87 "fcron.h"
short lavg_array_size  ;
#line 88 "fcron.h"
short lavg_num  ;
#line 89 "fcron.h"
short lavg_serial_running  ;
#line 96
void xexit(int exit_value ) ;
#line 30 "database.h"
void test_jobs(void) ;
#line 31
void wait_chld(void) ;
#line 32
void wait_all(int *counter ) ;
#line 33
time_t time_to_sleep(time_t lim ) ;
#line 34
time_t check_lavg(time_t lim ) ;
#line 35
void set_next_exe(struct cl_t *line , char option , int info_fd ) ;
#line 39
void set_next_exe_notrun(struct cl_t *line , char context ) ;
#line 43
void mail_notrun(struct cl_t *line , char context , struct tm *since ) ;
#line 44
void insert_nextexe(struct cl_t *line ) ;
#line 45
void run_normal_job(cl_t *line , int info_fd ) ;
#line 46
void add_serial_job(struct cl_t *line , int info_fd ) ;
#line 47
void add_lavg_job(struct cl_t *line , int info_fd ) ;
#line 48
void run_serial_job(void) ;
#line 30 "conf.h"
void reload_all(char const   *dir_name ) ;
#line 31
void synchronize_dir(char const   *dir_name ) ;
#line 32
void delete_file(char const   *user_name ) ;
#line 33
void save_file(struct cf_t *arg_file ) ;
#line 30 "job.h"
int change_user(struct cl_t *cl ) ;
#line 31
void run_job(struct exe_t *exeent ) ;
#line 32
FILE *create_mail(struct cl_t *line , char *subject ) ;
#line 33
void launch_mailer(struct cl_t *line , FILE *mailf ) ;
#line 59 "/users/rupak/ccured/include/uio_wrappers.h"
extern int true_readv(int fd , struct iovec_SAFE  const  *vec , int count ) ;
#line 60
extern int true_writev(int filedes , struct iovec_SAFE  const  *vector , int count ) ;
#line 62
/* #pragma ccuredwrapper("readv_wrapper",of("readv")) */
#line 63 "/users/rupak/ccured/include/uio_wrappers.h"
__inline static int readv_wrapper(int fd , struct iovec  const  *vec , int count ) 
{ int i ;
  struct iovec_SAFE *safevec ;
  struct iovec_SAFE *tmp ;
  int tmp___0 ;

  {
#line 67
  tmp = (struct iovec_SAFE *)wrapperAlloc((unsigned int )count * sizeof((*safevec)));
#line 67
  safevec = tmp;
#line 68
  i = 0;
#line 68
  while (i < count) {
#line 70
    (safevec + i)->iov_base = __ptrof((vec + i)->iov_base);
#line 72
    (safevec + i)->iov_len = (vec + i)->iov_len;
#line 73
    __write_at_least((vec + i)->iov_base, (vec + i)->iov_len);
#line 68
    i ++;
  }
#line 75
  tmp___0 = true_readv(fd, (struct iovec_SAFE  const  *)safevec, count);
#line 75
  return (tmp___0);
}
}
#line 79
/* #pragma ccuredwrapper("writev_wrapper",of("writev")) */
#line 80 "/users/rupak/ccured/include/uio_wrappers.h"
__inline static int writev_wrapper(int fd , struct iovec  const  *vec , int count ) 
{ int i ;
  struct iovec_SAFE *safevec ;
  struct iovec_SAFE *tmp ;
  int tmp___0 ;

  {
#line 84
  tmp = (struct iovec_SAFE *)wrapperAlloc((unsigned int )count * sizeof((*safevec)));
#line 84
  safevec = tmp;
#line 85
  i = 0;
#line 85
  while (i < count) {
#line 87
    (safevec + i)->iov_base = __ptrof((vec + i)->iov_base);
#line 89
    (safevec + i)->iov_len = (vec + i)->iov_len;
#line 90
    __read_at_least((vec + i)->iov_base, (vec + i)->iov_len);
#line 85
    i ++;
  }
#line 92
  tmp___0 = true_writev(fd, (struct iovec_SAFE  const  *)safevec, count);
#line 92
  return (tmp___0);
}
}
#line 100 "/usr/include/sys/socket.h"
extern int socket(int __domain , int __type , int __protocol ) ;
#line 110
extern int bind(int __fd , void const   *__addr , socklen_t __len ) ;
#line 114
extern int getsockname(int __fd , void * __restrict  __addr , socklen_t * __restrict  __len ) ;
#line 121
extern int connect(int __fd , void const   *__addr , socklen_t __len ) ;
#line 126
extern int getpeername(int __fd , void * __restrict  __addr , socklen_t * __restrict  __len ) ;
#line 131
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 136
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 141
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      void const   *__addr , socklen_t __addr_len ) ;
#line 149
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        void * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 156
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 161
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 168
extern int getsockopt(int __fd , int __level , int __optname , void * __restrict  __optval ,
                      socklen_t * __restrict  __optlen ) ;
#line 175
extern int setsockopt(int __fd , int __level , int __optname , void const   *__optval ,
                      socklen_t __optlen ) ;
#line 182
extern int listen(int __fd , int __n ) ;
#line 189
extern int accept(int __fd , void * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 199
extern int shutdown(int __fd , int __how ) ;
#line 49 "/users/rupak/ccured/include/socket_wrappers.h"
/* #pragma ccuredwrapper("setsockopt_wrapper",of("setsockopt")) */
#line 50 "/users/rupak/ccured/include/socket_wrappers.h"
__inline static int setsockopt_wrapper(int s , int level , int optname , void const   *optval ,
                                       int optlen ) 
{ void const   *tmp ;
  int tmp___0 ;

  {
#line 53
  __read_at_least((void *)optval, (unsigned int )optlen);
#line 54
  tmp = __ptrof((void *)optval);
#line 54
  tmp___0 = setsockopt(s, level, optname, tmp, (unsigned int )optlen);
#line 54
  return (tmp___0);
}
}
#line 57
/* #pragma ccuredwrapper("getsockopt_wrapper",of("getsockopt")) */
#line 58 "/users/rupak/ccured/include/socket_wrappers.h"
__inline static int getsockopt_wrapper(int s , int level , int optname , void *optval ,
                                       int *optlen ) 
{ socklen_t * __restrict  tmp ;
  void * __restrict  tmp___0 ;
  int tmp___1 ;

  {
#line 61
  __write_at_least(optval, (unsigned int )(*optlen));
#line 62
  tmp = (socklen_t */* __restrict  */)__ptrof((void *)optlen);
#line 62
  tmp___0 = __ptrof(optval);
#line 62
  tmp___1 = getsockopt(s, level, optname, tmp___0, tmp);
#line 62
  return (tmp___1);
}
}
#line 66
/* #pragma ccuredwrapper("bind_wrapper",of("bind")) */
#line 67 "/users/rupak/ccured/include/socket_wrappers.h"
__inline static int bind_wrapper(int sockfd , void *my_addr , int addrlen ) 
{ void *tmp ;
  int tmp___0 ;

  {
#line 70
  __read_at_least(my_addr, (unsigned int )addrlen);
#line 71
  tmp = __ptrof(my_addr);
#line 71
  tmp___0 = bind(sockfd, (void const   *)tmp, (unsigned int )addrlen);
#line 71
  return (tmp___0);
}
}
#line 75
/* #pragma ccuredwrapper("connect_wrapper",of("connect")) */
#line 76 "/users/rupak/ccured/include/socket_wrappers.h"
__inline static int connect_wrapper(int sockfd , void *my_addr , int addrlen ) 
{ void *tmp ;
  int tmp___0 ;

  {
#line 79
  __read_at_least(my_addr, (unsigned int )addrlen);
#line 80
  tmp = __ptrof(my_addr);
#line 80
  tmp___0 = connect(sockfd, (void const   *)tmp, (unsigned int )addrlen);
#line 80
  return (tmp___0);
}
}
#line 84
/* #pragma ccuredwrapper("accept_wrapper",of("accept")) */
#line 85 "/users/rupak/ccured/include/socket_wrappers.h"
__inline static int accept_wrapper(int s , void *addr , int *addrlen ) 
{ int res ;
  socklen_t * __restrict  tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 88
  if ((unsigned int )addr != (unsigned int )((void *)0)) {
#line 91
    if ((unsigned int )addrlen == (unsigned int )((void *)0)) {
#line 92
      ccured_fail(15, (char *)"/users/rupak/ccured/include/socket_wrappers.h", 92,
                  (char *)"accept_wrapper");
    }
#line 94
    __read_at_least(addr, (unsigned int )(*addrlen));
#line 95
    tmp = (socklen_t */* __restrict  */)__ptrof((void *)addrlen);
#line 95
    tmp___0 = __ptrof(addr);
#line 95
    res = accept(s, (void */* __restrict  */)tmp___0, tmp);
#line 98
    __write_at_least(addr, (unsigned int )(*addrlen));
#line 99
    return (res);
  } else {
#line 103
    tmp___1 = accept(s, (void */* __restrict  */)((void *)0), (socklen_t */* __restrict  */)((int *)0));
#line 103
    return (tmp___1);
  }
}
}
#line 110
/* #pragma ccuredwrapper("getpeername_wrapper",of("getpeername")) */
#line 111 "/users/rupak/ccured/include/socket_wrappers.h"
__inline static int getpeername_wrapper(int s , void *name , int *namelen ) 
{ int res ;
  socklen_t * __restrict  tmp ;
  void *tmp___0 ;

  {
#line 116
  __read_at_least(name, (unsigned int )(*namelen));
#line 118
  tmp = (socklen_t */* __restrict  */)__ptrof((void *)namelen);
#line 118
  tmp___0 = __ptrof(name);
#line 118
  res = getpeername(s, (void */* __restrict  */)tmp___0, tmp);
#line 121
  __write_at_least(name, (unsigned int )(*namelen));
#line 122
  return (res);
}
}
#line 127
/* #pragma ccuredwrapper("getsockname_wrapper",of("getsockname")) */
#line 128 "/users/rupak/ccured/include/socket_wrappers.h"
__inline static int getsockname_wrapper(int s , void *name , int *namelen ) 
{ int res ;
  socklen_t * __restrict  tmp ;
  void *tmp___0 ;

  {
#line 133
  __read_at_least(name, (unsigned int )(*namelen));
#line 135
  tmp = (socklen_t */* __restrict  */)__ptrof((void *)namelen);
#line 135
  tmp___0 = __ptrof(name);
#line 135
  res = getsockname(s, (void */* __restrict  */)tmp___0, tmp);
#line 138
  __write_at_least(name, (unsigned int )(*namelen));
#line 139
  return (res);
}
}
#line 149
/* #pragma ccuredwrapper("sendto_wrapper",of("sendto")) */
#line 150 "/users/rupak/ccured/include/socket_wrappers.h"
__inline static int sendto_wrapper(int s , void const   *msg , size_t len , int flags ,
                                   void const   *to , socklen_t tolen ) 
{ void const   *tmp ;
  void const   *tmp___0 ;
  int tmp___1 ;

  {
#line 154
  __read_at_least((void *)msg, len);
#line 155
  __read_at_least((void *)to, tolen);
#line 156
  tmp = __ptrof((void *)to);
#line 156
  tmp___0 = __ptrof((void *)msg);
#line 156
  tmp___1 = sendto(s, tmp___0, len, flags, tmp, tolen);
#line 156
  return (tmp___1);
}
}
#line 161
/* #pragma ccuredwrapper("select_wrapper",of("select")) */
#line 162 "/users/rupak/ccured/include/socket_wrappers.h"
__inline static int select_wrapper(int n , fd_set *readfds , fd_set *writefds , fd_set *exceptfds ,
                                   struct timeval *timeout ) 
{ void * __attribute__((__safe__)) tmp ;
  struct timeval *tmp___0 ;
  fd_set * __restrict  tmp___1 ;
  fd_set * __restrict  tmp___2 ;
  fd_set * __restrict  tmp___3 ;
  int tmp___4 ;

  {
#line 166
  tmp = __ptrof((void *)timeout);
#line 166
  if (tmp) {
#line 167
    __write_at_least((void *)timeout, sizeof(struct timeval ));
  }
#line 169
  tmp___0 = (struct timeval *)__ptrof((void *)timeout);
#line 169
  tmp___1 = (fd_set */* __restrict  */)__ptrof((void *)exceptfds);
#line 169
  tmp___2 = (fd_set */* __restrict  */)__ptrof((void *)writefds);
#line 169
  tmp___3 = (fd_set */* __restrict  */)__ptrof((void *)readfds);
#line 169
  tmp___4 = select(n, tmp___3, tmp___2, tmp___1, (struct timeval */* __restrict  */)tmp___0);
#line 169
  return (tmp___4);
}
}
#line 176
/* #pragma ccuredwrapper("recvfrom_wrapper",of("recvfrom")) */
#line 177 "/users/rupak/ccured/include/socket_wrappers.h"
__inline static int recvfrom_wrapper(int s , void *buf , size_t len , int flags ,
                                     void *from , socklen_t *fromlen ) 
{ socklen_t * __restrict  tmp ;
  void * __restrict  tmp___0 ;
  void * __restrict  tmp___1 ;
  int tmp___2 ;

  {
#line 181
  __write_at_least(buf, len);
#line 182
  tmp = (socklen_t */* __restrict  */)__ptrof((void *)fromlen);
#line 182
  tmp___0 = __ptrof(from);
#line 182
  tmp___1 = __ptrof(buf);
#line 182
  tmp___2 = recvfrom(s, tmp___1, len, flags, tmp___0, tmp);
#line 182
  return (tmp___2);
}
}
#line 186
/* #pragma ccuredwrapper("recv_wrapper",of("recv")) */
#line 187 "/users/rupak/ccured/include/socket_wrappers.h"
__inline static int recv_wrapper(int s , void *buf , size_t len , int flags ) 
{ void *tmp ;
  int tmp___0 ;

  {
#line 190
  __write_at_least(buf, len);
#line 191
  tmp = __ptrof(buf);
#line 191
  tmp___0 = recv(s, tmp, len, flags);
#line 191
  return (tmp___0);
}
}
#line 195
/* #pragma ccuredwrapper("send_wrapper",of("send")) */
#line 196 "/users/rupak/ccured/include/socket_wrappers.h"
__inline static int send_wrapper(int s , void const   *msg , size_t len , int flags ) 
{ void const   *tmp ;
  int tmp___0 ;

  {
#line 199
  __read_at_least((void *)msg, len);
#line 200
  tmp = __ptrof((void *)msg);
#line 200
  tmp___0 = send(s, tmp, len, flags);
#line 200
  return (tmp___0);
}
}
#line 203 "/users/rupak/ccured/include/socket_wrappers.h"
__inline static void __deepcopy_iovec_to_compat(struct iovec  __attribute__((__compat__)) *compat ,
                                                struct iovec *fat ) 
{ 

  {
#line 205
  compat->iov_base = __ptrof_nocheck(fat->iov_base);
#line 206
  return;
}
}
#line 208 "/users/rupak/ccured/include/socket_wrappers.h"
__inline static void __deepcopy_msghdr_to_compat(struct msghdr  __attribute__((__compat__)) *compat ,
                                                 struct msghdr *fat ) 
{ int len ;
  int v ;
  struct iovec  __attribute__((__compat__)) *iptr ;
  struct iovec  __attribute__((__compat__)) *tmp ;
  int tmp___0 ;

  {
#line 212
  tmp___0 = __ccured_has_empty_mangling(sizeof((*(fat->msg_iov))));
#line 212
  if (tmp___0) {
#line 214
    compat->msg_iov = (struct iovec *)__ptrof((void *)fat->msg_iov);
  } else {
#line 216
    len = (int )fat->msg_iovlen;
#line 218
    compat->msg_iov = (struct iovec *)wrapperAlloc((unsigned int )len * sizeof((*(compat->msg_iov +
                                                                                  0))));
#line 219
    v = 0;
#line 219
    while (v < len) {
#line 220
      tmp = (struct iovec  __attribute__((__compat__)) *)__trusted_cast((void *)((unsigned long )compat->msg_iov +
                                                                                 (unsigned long )((unsigned int )v *
                                                                                                  sizeof((*(compat->msg_iov))))));
#line 220
      iptr = tmp;
#line 221
      __deepcopy_iovec_to_compat(iptr, fat->msg_iov + v);
#line 219
      v ++;
    }
  }
#line 224
  return;
}
}
#line 226 "/users/rupak/ccured/include/socket_wrappers.h"
__inline static void __deepcopy_iovec_from_compat(struct iovec *fat , struct iovec  __attribute__((__compat__)) *compat ) 
{ 

  {
#line 228
  fat->iov_base = __mkptr_size((void */* __attribute__((__safe__)) */)compat->iov_base,
                               compat->iov_len);
#line 229
  return;
}
}
#line 231 "/users/rupak/ccured/include/socket_wrappers.h"
__inline static void __deepcopy_msghdr_from_compat(struct msghdr *fat , struct msghdr  __attribute__((__compat__)) *compat ) 
{ int len ;
  int v ;
  struct iovec  __attribute__((__compat__)) *iptr ;
  struct iovec  __attribute__((__compat__)) *tmp ;
  int tmp___0 ;

  {
#line 233
  fat->msg_name = __mkptr_size((void */* __attribute__((__safe__)) */)compat->msg_name,
                               compat->msg_namelen);
#line 234
  fat->msg_control = __mkptr_size((void */* __attribute__((__safe__)) */)compat->msg_control,
                                  compat->msg_controllen);
#line 236
  tmp___0 = __ccured_has_empty_mangling(sizeof((*(fat->msg_iov))));
#line 236
  if (tmp___0) {
#line 238
    fat->msg_iov = (struct iovec *)__mkptr_size((void */* __attribute__((__safe__)) */)compat->msg_iov,
                                                compat->msg_iovlen * sizeof((*(fat->msg_iov +
                                                                               0))));
  } else {
#line 241
    len = (int )compat->msg_iovlen;
#line 243
    fat->msg_iov = (struct iovec *)wrapperAlloc((unsigned int )len * sizeof((*(fat->msg_iov +
                                                                               0))));
#line 244
    v = 0;
#line 244
    while (v < len) {
#line 245
      tmp = (struct iovec  __attribute__((__compat__)) *)__trusted_cast((void *)((unsigned long )compat->msg_iov +
                                                                                 (unsigned long )((unsigned int )v *
                                                                                                  sizeof((*(compat->msg_iov))))));
#line 245
      iptr = tmp;
#line 246
      __deepcopy_iovec_from_compat(fat->msg_iov + v, iptr);
#line 244
      v ++;
    }
  }
#line 249
  return;
}
}
#line 252
/* #pragma ccuredwrapper("sendmsg_wrapper",of("sendmsg")) */
#line 253 "/users/rupak/ccured/include/socket_wrappers.h"
__inline static int sendmsg_wrapper(int s , struct msghdr  const  *fat_msg , int flags ) 
{ struct msghdr  __attribute__((__compat__)) lean_msg__area ;
  struct msghdr *lean_msg__ptrof ;
  struct msghdr *tmp ;
  struct msghdr  __attribute__((__compat__)) *lean_msg ;
  struct msghdr  __attribute__((__compat__)) *tmp___2 ;
  int tmp___4 ;
  int result ;
  int tmp___5 ;

  {
#line 255
  tmp = (struct msghdr *)__ptrof_nocheck((void *)fat_msg);
#line 255
  lean_msg__ptrof = tmp;
#line 255
  if (lean_msg__ptrof) {
#line 255
    tmp___4 = __ccured_has_empty_mangling(sizeof(struct msghdr ));
#line 255
    if (tmp___4) {
#line 255
      tmp___2 = (struct msghdr  __attribute__((__compat__)) *)__trusted_cast((void *)lean_msg__ptrof);
    } else {
#line 255
      __deepcopy_msghdr_to_compat(& lean_msg__area, lean_msg__ptrof);
#line 255
      tmp___2 = & lean_msg__area;
    }
  } else {
#line 255
    tmp___2 = (struct msghdr  __attribute__((__compat__)) *)__trusted_cast((void *)lean_msg__ptrof);
  }
#line 255
  lean_msg = tmp___2;
#line 256
  tmp___5 = sendmsg(s, (struct msghdr  const  *)lean_msg, flags);
#line 256
  result = tmp___5;
#line 258
  if ((unsigned int )lean_msg->msg_iov != (unsigned int )fat_msg->msg_iov) {
#line 259
    wrapperFree((void *)lean_msg->msg_iov);
  }
#line 261
  return (result);
}
}
#line 264
/* #pragma ccuredwrapper("recvmsg_wrapper",of("recvmsg")) */
#line 265 "/users/rupak/ccured/include/socket_wrappers.h"
__inline static int recvmsg_wrapper(int s , struct msghdr *fat_msg , int flags ) 
{ struct msghdr  __attribute__((__compat__)) lean_msg__area ;
  struct msghdr *lean_msg__ptrof ;
  struct msghdr *tmp ;
  struct msghdr  __attribute__((__compat__)) *lean_msg ;
  struct msghdr  __attribute__((__compat__)) *tmp___2 ;
  int tmp___4 ;
  int result ;
  int tmp___5 ;

  {
#line 267
  tmp = (struct msghdr *)__ptrof_nocheck((void *)fat_msg);
#line 267
  lean_msg__ptrof = tmp;
#line 267
  if (lean_msg__ptrof) {
#line 267
    tmp___4 = __ccured_has_empty_mangling(sizeof(struct msghdr ));
#line 267
    if (tmp___4) {
#line 267
      tmp___2 = (struct msghdr  __attribute__((__compat__)) *)__trusted_cast((void *)lean_msg__ptrof);
    } else {
#line 267
      __deepcopy_msghdr_to_compat(& lean_msg__area, lean_msg__ptrof);
#line 267
      tmp___2 = & lean_msg__area;
    }
  } else {
#line 267
    tmp___2 = (struct msghdr  __attribute__((__compat__)) *)__trusted_cast((void *)lean_msg__ptrof);
  }
#line 267
  lean_msg = tmp___2;
#line 268
  tmp___5 = recvmsg(s, (struct msghdr *)lean_msg, flags);
#line 268
  result = tmp___5;
#line 269
  if ((unsigned int )lean_msg != (unsigned int )fat_msg) {
#line 269
    __deepcopy_msghdr_from_compat(fat_msg, lean_msg);
  }
#line 270
  if ((unsigned int )lean_msg->msg_iov != (unsigned int )fat_msg->msg_iov) {
#line 271
    wrapperFree((void *)lean_msg->msg_iov);
  }
#line 273
  return (result);
}
}
#line 38 "socket.h"
fd_set read_set ;
#line 39
int set_max_fd ;
#line 42
void init_socket(void) ;
#line 43
void check_socket(int num ) ;
#line 44
void close_socket(void) ;
#line 36 "fcron.c"
char rcs_info[56]  = 
#line 36
  {      (char )'$',      (char )'I',      (char )'d',      (char )':', 
        (char )' ',      (char )'f',      (char )'c',      (char )'r', 
        (char )'o',      (char )'n',      (char )'.',      (char )'c', 
        (char )',',      (char )'v',      (char )' ',      (char )'1', 
        (char )'.',      (char )'7',      (char )'1',      (char )' ', 
        (char )'2',      (char )'0',      (char )'0',      (char )'4', 
        (char )'/',      (char )'0',      (char )'4',      (char )'/', 
        (char )'2',      (char )'9',      (char )' ',      (char )'2', 
        (char )'0',      (char )':',      (char )'5',      (char )'0', 
        (char )':',      (char )'4',      (char )'7',      (char )' ', 
        (char )'t',      (char )'h',      (char )'i',      (char )'b', 
        (char )' ',      (char )'E',      (char )'x',      (char )'p', 
        (char )' ',      (char )'t',      (char )'h',      (char )'i', 
        (char )'b',      (char )' ',      (char )'$',      (char )'\000'};
#line 38
void main_loop(void) ;
#line 39
void check_signal(void) ;
#line 40
void info(void) ;
#line 41
void usage(void) ;
#line 42
void print_schedule(void) ;
#line 43
void sighup_handler(int x ) ;
#line 44
void sigterm_handler(int x ) ;
#line 45
void sigchild_handler(int x ) ;
#line 46
void sigusr1_handler(int x ) ;
#line 47
void sigusr2_handler(int x ) ;
#line 48
int parseopt(int argc , char **argv ) ;
#line 49
void get_lock(void) ;
#line 50
void create_spooldir(char *dir ) ;
#line 58 "fcron.c"
char debug_opt  =    0;
#line 64 "fcron.c"
char foreground  =    0;
#line 67 "fcron.c"
long first_sleep  =    (time_t )20;
#line 68 "fcron.c"
long save_time  =    (time_t )1800;
#line 69 "fcron.c"
char once  =    0;
#line 71 "fcron.c"
char dosyslog  =    1;
#line 74 "fcron.c"
char *tmp_path  =    (char *)"";
#line 79 "fcron.c"
char *prog_name  =    (char *)((void *)0);
#line 82 "fcron.c"
char sig_conf  =    0;
#line 83 "fcron.c"
char sig_chld  =    0;
#line 84 "fcron.c"
char sig_debug  =    0;
#line 98 "fcron.c"
short serial_max_running  =    1;
#line 99 "fcron.c"
short serial_queue_max  =    30;
#line 100 "fcron.c"
short lavg_queue_max  =    30;
#line 111 "fcron.c"
time_t begin_sleep  ;
#line 115 "fcron.c"
pam_handle_t *pamh  =    (pam_handle_t *)((void *)0);
#line 116 "fcron.c"
struct pam_conv  const  apamconv  =    {(int (*)(int num_msg , struct pam_message  const  **msg , struct pam_response **resp ,
             void *appdata_ptr ))((void *)0), (void *)0};
#line 119 "fcron.c"
void info(void) 
{ FILE * __restrict  tmp ;

  {
#line 124
  tmp = get_stderr();
#line 124
  fprintf(tmp, (char const   */* __restrict  */)"fcron 2.9.5 - periodic command scheduler\nCopyright 2000-2004 Thibault Godouet <fcron@free.fr>\nThis program is free software distributed WITHOUT ANY WARRANTY.\nSee the GNU General Public License for more details.\n");
#line 131
  exit(0);
}
}
#line 136 "fcron.c"
void usage(void) 
{ FILE * __restrict  tmp ;

  {
#line 140
  tmp = get_stderr();
#line 140
  fprintf(tmp, (char const   */* __restrict  */)"\nfcron 2.9.5\n\nfcron [-d] [-f] [-b]\nfcron -h\n  -s t   --savetime t     Save fcrontabs on disk every t sec.\n  -l t   --firstsleep t   Sets the initial delay before any job is executed,\n                          default to %d seconds.\n  -m n   --maxserial n    Set to n the max number of running serial jobs.\n  -c f   --configfile f   Make fcron use config file f.\n  -n d   --newspooldir d  Create d as a new spool directory.\n  -f     --foreground     Stay in foreground.\n  -b     --background     Go to background.\n  -y     --nosyslog       Don\'t log to syslog at all.\n  -o     --once           Execute all jobs that need to be run, wait for them,\n                          then return. Sets firstsleep to 0.\n                          Especially useful with -f and -y.\n  -d     --debug          Set Debug mode.\n  -h     --help           Show this help message.\n  -V     --version        Display version & infos about fcron.\n",
          20);
#line 161
  exit(1);
}
}
#line 165 "fcron.c"
void print_schedule(void) 
{ cf_t *cf ;
  cl_t *cl ;
  struct tm *ftime ;

  {
#line 173
  explain((char *)"Printing schedule ...");
#line 174
  cf = file_base;
#line 174
  while (cf) {
#line 175
    explain((char *)" File %s", cf->cf_user);
#line 176
    cl = cf->cf_line_base;
#line 176
    while (cl) {
#line 177
      ftime = localtime((time_t const   *)(& cl->cl_nextexe));
#line 178
      explain((char *)"  cmd %s next exec %d/%d/%d wday:%d %02d:%02d", cl->cl_shell,
              ftime->tm_mon + 1, ftime->tm_mday, ftime->tm_year + 1900, ftime->tm_wday,
              ftime->tm_hour, ftime->tm_min);
#line 176
      cl = cl->cl_next;
    }
#line 174
    cf = cf->cf_next;
  }
#line 185
  explain((char *)"... end of printing schedule.");
#line 186
  return;
}
}
#line 189 "fcron.c"
void xexit(int exit_value ) 
{ cf_t *f ;

  {
#line 193
  f = (cf_t *)((void *)0);
#line 195
  now = time((time_t *)((void *)0));
#line 200
  save_file((struct cf_t *)((void *)0));
#line 203
  close_socket();
#line 206
  f = file_base;
#line 207
  while ((unsigned int )f != (unsigned int )((void *)0)) {
#line 208
    if (f->cf_running > 0) {
#line 210
      if (debug_opt) {
#line 210
        Debug((char *)"waiting jobs for %s ...", f->cf_user);
      }
#line 212
      wait_all(& f->cf_running);
#line 213
      save_file(f);
    }
#line 215
    delete_file((char const   *)f->cf_user);
#line 219
    f = file_base;
  }
#line 222
  remove((char const   *)pidfile);
#line 224
  free_conf();
#line 226
  explain((char *)"Exiting with code %d", exit_value);
#line 227
  exit(exit_value);
}
}
#line 231 "fcron.c"
void get_lock(void) 
{ int otherpid ;
  FILE *daemon_lockfp ;
  int fd ;
  int tmp ;
  __off_t tmp___0 ;
  int tmp___1 ;

  {
#line 237
  otherpid = 0;
#line 238
  daemon_lockfp = (FILE *)((void *)0);
#line 241
  fd = open((char const   *)pidfile, 66, 420);
#line 241
  if (fd == -1) {
#line 243
    die_e((char *)"can\'t open or create %s", pidfile);
  } else {
#line 241
    daemon_lockfp = fdopen(fd, "r+");
#line 241
    if ((unsigned int )daemon_lockfp == (unsigned int )((void *)0)) {
#line 243
      die_e((char *)"can\'t open or create %s", pidfile);
    }
  }
#line 246
  tmp = flock(fd, 6);
#line 246
  if (tmp != 0) {
#line 251
    fscanf((FILE */* __restrict  */)daemon_lockfp, (char const   */* __restrict  */)"%d",
           & otherpid);
#line 252
    die_e((char *)"can\'t lock %s, running daemon\'s pid may be %d", pidfile, otherpid);
  }
#line 256
  fcntl(fd, 2, 1);
#line 258
  rewind(daemon_lockfp);
#line 259
  fprintf((FILE */* __restrict  */)daemon_lockfp, (char const   */* __restrict  */)"%d\n",
          daemon_pid);
#line 260
  fflush(daemon_lockfp);
#line 261
  tmp___0 = ftell(daemon_lockfp);
#line 261
  tmp___1 = fileno(daemon_lockfp);
#line 261
  ftruncate(tmp___1, tmp___0);
#line 267
  return;
}
}
#line 279 "fcron.c"
static struct option opt[14]  = 
#line 279
  {      {"debug", 0, (int *)((void *)0), 'd'}, 
        {"foreground", 0, (int *)((void *)0), 'f'}, 
        {"background", 0, (int *)((void *)0), 'b'}, 
        {"nosyslog", 0, (int *)((void *)0), 'y'}, 
        {"help", 0, (int *)((void *)0), 'h'}, 
        {"version", 0, (int *)((void *)0), 'V'}, 
        {"once", 0, (int *)((void *)0), 'o'}, 
        {"savetime", 1, (int *)((void *)0), 's'}, 
        {"firstsleep", 1, (int *)((void *)0), 'l'}, 
        {"maxserial", 1, (int *)((void *)0), 'm'}, 
        {"configfile", 1, (int *)((void *)0), 'c'}, 
        {"newspooldir", 1, (int *)((void *)0), 'n'}, 
        {"queuelen", 1, (int *)((void *)0), 'q'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 270 "fcron.c"
int parseopt(int argc , char **argv ) 
{ int c ;
  int i ;

  {
#line 303
  while (1) {
#line 305
    c = getopt_long(argc, (char * const  *)argv, "dfbyhVos:l:m:c:n:q:", (struct option  const  *)(opt),
                    (int *)((void *)0));
#line 309
    if (c == -1) {
#line 309
      break;
    }
#line 310
    switch ((int )((char )c)) {
    case 86: 
#line 313
    info();
#line 313
    break;
    case 104: 
#line 316
    usage();
#line 316
    break;
    case 100: 
#line 319
    debug_opt = 1;
#line 319
    break;
    case 102: 
#line 322
    foreground = 1;
#line 322
    break;
    case 98: 
#line 325
    foreground = 0;
#line 325
    break;
    case 121: 
#line 328
    dosyslog = 0;
#line 328
    break;
    case 111: 
#line 331
    once = 1;
#line 331
    first_sleep = 0L;
#line 331
    break;
    case 115: 
#line 334
    save_time = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                       10);
#line 334
    if (save_time < 60L) {
#line 335
      die((char *)"Save time can only be set between 60 and %d.", 2147483647L);
    } else {
#line 334
      if (save_time >= 2147483647L) {
#line 335
        die((char *)"Save time can only be set between 60 and %d.", 2147483647L);
      }
    }
#line 336
    break;
    case 108: 
#line 339
    first_sleep = strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                         10);
#line 339
    if (first_sleep < 0L) {
#line 340
      die((char *)"First sleep can only be set between 0 and %d.", 2147483647L);
    } else {
#line 339
      if (first_sleep >= 2147483647L) {
#line 340
        die((char *)"First sleep can only be set between 0 and %d.", 2147483647L);
      }
    }
#line 341
    break;
    case 109: 
#line 344
    serial_max_running = (short )strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                                        10);
#line 344
    if ((int )serial_max_running <= 0) {
#line 346
      die((char *)"Max running can only be set between 1 and %d.", 32767);
    } else {
#line 344
      if ((int )serial_max_running >= 32767) {
#line 346
        die((char *)"Max running can only be set between 1 and %d.", 32767);
      }
    }
#line 347
    break;
    case 99: 
#line 350
    free((void *)fcronconf);
#line 350
    fcronconf = strdup2((char const   *)optarg);
#line 351
    break;
    case 110: 
#line 354
    create_spooldir(optarg);
#line 355
    break;
    case 113: 
#line 358
    serial_queue_max = (short )strtol((char const   */* __restrict  */)optarg, (char **/* __restrict  */)((void *)0),
                                      10);
#line 358
    lavg_queue_max = serial_queue_max;
#line 358
    if ((int )lavg_queue_max < 5) {
#line 360
      die((char *)"Queue length can only be set between 5 and %d.", 32767);
    } else {
#line 358
      if ((int )serial_queue_max >= 32767) {
#line 360
        die((char *)"Queue length can only be set between 5 and %d.", 32767);
      }
    }
#line 361
    break;
    case 58: 
#line 364
    error((char *)"(parseopt) Missing parameter");
#line 365
    usage();
    case 63: 
#line 368
    usage();
    default: 
#line 371
    warn((char *)"(parseopt) Warning: getopt returned %c", c);
    }
  }
#line 375
  if (optind < argc) {
#line 376
    i = optind;
#line 376
    while (i <= argc) {
#line 377
      error((char *)"Unknown argument \"%s\"", (*(argv + i)));
#line 376
      i ++;
    }
#line 378
    usage();
  }
#line 381
  return (0);
}
}
#line 385 "fcron.c"
void create_spooldir(char *dir ) 
{ int dir_fd ;
  struct passwd *pass ;
  struct group *grp ;
  struct stat st ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 389
  dir_fd = -1;
#line 390
  pass = (struct passwd *)((void *)0);
#line 391
  grp = (struct group *)((void *)0);
#line 394
  tmp = mkdir((char const   *)dir, 0U);
#line 394
  if (tmp != 0) {
#line 394
    tmp___0 = __errno_location();
#line 394
    if ((*tmp___0) != 17) {
#line 395
      die_e((char *)"Cannot create dir %s", dir);
    }
  }
#line 397
  dir_fd = open((char const   *)dir, 0);
#line 397
  if (dir_fd < 0) {
#line 398
    die_e((char *)"Cannot open dir %s", dir);
  }
#line 400
  tmp___1 = fstat__extinline(dir_fd, & st);
#line 400
  if (tmp___1 != 0) {
#line 401
    close(dir_fd);
#line 402
    die_e((char *)"Cannot fstat %s", dir);
  }
#line 405
  if (! ((st.st_mode & 61440U) == 16384U)) {
#line 406
    close(dir_fd);
#line 407
    die((char *)"%s exists and is not a directory", dir);
  }
#line 410
  pass = getpwnam("fcron");
#line 410
  if ((unsigned int )pass == (unsigned int )((void *)0)) {
#line 411
    die_e((char *)"Cannot getpwnam(%s)", "fcron");
  }
#line 413
  grp = getgrnam("fcron");
#line 413
  if ((unsigned int )grp == (unsigned int )((void *)0)) {
#line 414
    die_e((char *)"Cannot getgrnam(%s)", "fcron");
  }
#line 416
  tmp___2 = fchown(dir_fd, pass->pw_uid, grp->gr_gid);
#line 416
  if (tmp___2 != 0) {
#line 417
    close(dir_fd);
#line 418
    die_e((char *)"Cannot fchown dir %s to %s:%s", dir, "fcron", "fcron");
  }
#line 421
  tmp___3 = fchmod(dir_fd, 504U);
#line 421
  if (tmp___3 != 0) {
#line 422
    close(dir_fd);
#line 423
    die_e((char *)"Cannot change dir %s\'s mode to 770", dir);
  }
#line 426
  close(dir_fd);
#line 428
  exit(0);
}
}
#line 433 "fcron.c"
void sigterm_handler(int x ) 
{ 

  {
#line 437
  if (debug_opt) {
#line 437
    Debug((char *)"");
  }
#line 438
  explain((char *)"SIGTERM signal received");
#line 439
  xexit(0);
#line 440
  return;
}
}
#line 442 "fcron.c"
void sighup_handler(int x ) 
{ 

  {
#line 450
  sig_conf = 1;
#line 451
  return;
}
}
#line 453 "fcron.c"
void sigchild_handler(int x ) 
{ 

  {
#line 458
  sig_chld = 1;
#line 460
  return;
}
}
#line 463 "fcron.c"
void sigusr1_handler(int x ) 
{ 

  {
#line 471
  sig_conf = 2;
#line 472
  return;
}
}
#line 475 "fcron.c"
void sigusr2_handler(int x ) 
{ 

  {
#line 479
  sig_debug = 1;
#line 480
  return;
}
}
#line 483 "fcron.c"
int main(int argc , char **argv ) 
{ char *tmp ;
  char *tmp___0 ;
  uid_t daemon_uid ;
  int tmp___1 ;
  FILE * __restrict  tmp___2 ;
  int fd ;
  pid_t pid ;
  FILE * __restrict  tmp___3 ;
  FILE * __restrict  tmp___4 ;
  __pid_t tmp___5 ;
  unsigned int tmp___6 ;

  {
#line 489
  saved_umask = umask(18U);
#line 493
  tmp___0 = strrchr((char const   *)(*(argv + 0)), '/');
#line 493
  if ((unsigned int )tmp___0 == (unsigned int )((void *)0)) {
#line 493
    prog_name = (*(argv + 0));
  } else {
#line 494
    tmp = strrchr((char const   *)(*(argv + 0)), '/');
#line 494
    prog_name = tmp + 1;
  }
#line 498
  daemon_uid = getuid();
#line 498
  if (daemon_uid != 0U) {
#line 499
    die((char *)"Fcron must be executed as root");
  }
#line 504
  daemon_pid = getpid();
#line 506
  parseopt(argc, argv);
#line 509
  read_conf();
#line 513
  tmp___1 = chdir((char const   *)fcrontabs);
#line 513
  if (tmp___1 != 0) {
#line 514
    die_e((char *)"Could not change dir to %s", fcrontabs);
  }
#line 517
  tmp___2 = get_stdin();
#line 517
  freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"r",
          tmp___2);
#line 519
  if ((int )foreground == 0) {
#line 528
    pid = fork();
#line 528
    switch (pid) {
    case -1: 
#line 530
    die_e((char *)"fork");
#line 531
    break;
    case 0: ;
#line 534
    break;
    default: 
#line 539
    exit(0);
    }
#line 542
    daemon_pid = getpid();
#line 544
    fd = open("/dev/tty", 2);
#line 544
    if (fd >= 0) {
#line 545
      ioctl(fd, 21538UL, 0);
#line 546
      close(fd);
    }
#line 549
    tmp___3 = get_stdout();
#line 549
    freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
            tmp___3);
#line 550
    tmp___4 = get_stderr();
#line 550
    freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
            tmp___4);
#line 553
    xcloselog();
#line 554
    fd = 3;
#line 554
    while (fd < 250) {
#line 554
      close(fd);
#line 554
      fd ++;
    }
#line 557
    tmp___5 = setsid();
#line 557
    if (tmp___5 == -1) {
#line 558
      error((char *)"Could not setsid()");
    }
  }
#line 563
  get_lock();
#line 568
  umask(54U);
#line 570
  explain((char *)"%s[%d] 2.9.5 started", prog_name, daemon_pid);
#line 572
  signal(15, & sigterm_handler);
#line 573
  signal(1, & sighup_handler);
#line 574
  siginterrupt(1, 0);
#line 575
  signal(17, & sigchild_handler);
#line 576
  siginterrupt(17, 0);
#line 577
  signal(10, & sigusr1_handler);
#line 578
  siginterrupt(10, 0);
#line 579
  signal(12, & sigusr2_handler);
#line 580
  siginterrupt(12, 0);
#line 582
  signal(13, (void (*)(int  ))1);
#line 585
  next_id = 0UL;
#line 588
  exe_num = 0;
#line 589
  exe_array_size = 6;
#line 590
  exe_array = (struct exe_t *)calloc((unsigned int )exe_array_size, sizeof(struct exe_t ));
#line 590
  if ((unsigned int )exe_array == (unsigned int )((void *)0)) {
#line 591
    die_e((char *)"could not calloc exe_array");
  }
#line 594
  serial_running = 0;
#line 595
  serial_array_index = 0;
#line 596
  serial_num = 0;
#line 597
  serial_array_size = 10;
#line 598
  serial_array = (struct cl_t **)calloc((unsigned int )serial_array_size, sizeof(cl_t *));
#line 598
  if ((unsigned int )serial_array == (unsigned int )((void *)0)) {
#line 599
    die_e((char *)"could not calloc serial_array");
  }
#line 602
  lavg_num = 0;
#line 603
  lavg_serial_running = 0;
#line 604
  lavg_array_size = 10;
#line 605
  lavg_array = (struct lavg_t *)calloc((unsigned int )lavg_array_size, sizeof(lavg_t ));
#line 605
  if ((unsigned int )lavg_array == (unsigned int )((void *)0)) {
#line 606
    die_e((char *)"could not calloc lavg_array");
  }
#line 610
  init_socket();
#line 615
  tmp___6 = (unsigned int )time((time_t *)((void *)0));
#line 615
  srand(tmp___6);
#line 617
  main_loop();
#line 620
  return (0);
}
}
#line 624 "fcron.c"
void check_signal(void) 
{ 

  {
#line 632
  if ((int )sig_chld > 0) {
#line 633
    wait_chld();
#line 634
    sig_chld = 0;
#line 635
    signal(17, & sigchild_handler);
#line 636
    siginterrupt(17, 0);
  }
#line 638
  if ((int )sig_conf > 0) {
#line 640
    if ((int )sig_conf == 1) {
#line 642
      synchronize_dir(".");
#line 643
      sig_conf = 0;
#line 644
      signal(1, & sighup_handler);
#line 645
      siginterrupt(1, 0);
    } else {
#line 649
      reload_all(".");
#line 650
      sig_conf = 0;
#line 651
      signal(10, & sigusr1_handler);
#line 652
      siginterrupt(10, 0);
    }
  }
#line 656
  if ((int )sig_debug > 0) {
#line 657
    print_schedule();
#line 658
    if ((int )debug_opt > 0) {
#line 658
      debug_opt = 0;
    } else {
#line 658
      debug_opt = 1;
    }
#line 659
    explain((char *)"debug_opt = %d", debug_opt);
#line 660
    sig_debug = 0;
#line 661
    signal(12, & sigusr2_handler);
#line 662
    siginterrupt(12, 0);
  }
#line 665
  return;
}
}
#line 667 "fcron.c"
void main_loop(void) 
{ time_t save ;
  time_t stime___0 ;
  struct timeval tv ;
  int retcode ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 679
  retcode = 0;
#line 682
  if (debug_opt) {
#line 682
    Debug((char *)"Entering main loop");
  }
#line 684
  now = time((time_t *)((void *)0));
#line 686
  synchronize_dir(".");
#line 689
  save = now + save_time;
#line 691
  if ((int )serial_num > 0) {
#line 692
    stime___0 = first_sleep;
  } else {
#line 691
    if (once) {
#line 692
      stime___0 = first_sleep;
    } else {
#line 693
      stime___0 = time_to_sleep(save);
#line 693
      if (stime___0 < first_sleep) {
#line 696
        stime___0 = first_sleep;
      }
    }
  }
#line 698
  while (1) {
#line 702
    gettimeofday((struct timeval */* __restrict  */)(& tv), (struct timezone */* __restrict  */)((void *)0));
#line 703
    if (stime___0 > 1L) {
#line 703
      tv.tv_sec = stime___0 - 1L;
    } else {
#line 703
      tv.tv_sec = 0L;
    }
#line 704
    tv.tv_usec = 1000000L - tv.tv_usec;
#line 705
    retcode = select(set_max_fd + 1, (fd_set */* __restrict  */)(& read_set), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
#line 705
    if (retcode < 0) {
#line 705
      tmp___0 = __errno_location();
#line 705
      if ((*tmp___0) != 4) {
#line 706
        tmp = __errno_location();
#line 706
        die_e((char *)"select return %d", (*tmp));
      }
    }
#line 717
    now = time((time_t *)((void *)0));
#line 719
    check_signal();
#line 721
    if (debug_opt) {
#line 721
      Debug((char *)"\n");
    }
#line 722
    test_jobs();
#line 724
    while (1) {
#line 724
      if ((int )serial_num > 0) {
#line 724
        if (! ((int )serial_running < (int )serial_max_running)) {
#line 724
          break;
        }
      } else {
#line 724
        break;
      }
#line 725
      run_serial_job();
    }
#line 727
    if (once) {
#line 728
      explain((char *)"Running with option once : exiting ... ");
#line 729
      xexit(0);
    }
#line 732
    if (save <= now) {
#line 733
      save = now + save_time;
#line 735
      save_file((struct cf_t *)((void *)0));
    }
#line 741
    check_socket(retcode);
#line 744
    stime___0 = check_lavg(save);
#line 745
    if (debug_opt) {
#line 745
      Debug((char *)"next sleep time : %ld", stime___0);
    }
#line 747
    check_signal();
  }
#line 751
  return;
}
}
#line 1 "subs.o"
/* #pragma merger(0,"./subs.i","-O2 -Wall") */
#line 123 "/users/rupak/ccured/include/ccuredannot.h"
/* #pragma cilnoremove("__ccuredInit") */
#line 20 "/users/rupak/ccured/include/ccured.h"
/* #pragma cilnoremove("wrapperAlloc") */
#line 21
/* #pragma ccuredalloc("wrapperAlloc",sizein(1),nozero) */
#line 24
/* #pragma cilnoremove("wrapperFree") */
#line 25
/* #pragma ccuredpoly("wrapperFree") */
#line 29
/* #pragma cilnoremove("wrapperStrdup") */
#line 30
/* #pragma ccuredpoly("wrapperStrdup") */
#line 50
/* #pragma ccuredpoly("__ptrof_nocheck") */
#line 51
/* #pragma cilnoremove("__ptrof_nocheck") */
#line 57
/* #pragma ccuredpoly("__startof") */
#line 63
/* #pragma ccuredpoly("__endof") */
#line 78
/* #pragma ccuredpoly("__ptrof") */
#line 84
/* #pragma ccuredpoly("__ptrof_size") */
#line 85
/* #pragma cilnoremove("__ptrof_size") */
#line 92
/* #pragma ccuredpoly("__verify_nul") */
#line 101
/* #pragma ccuredpoly("__strlen") */
#line 111
/* #pragma ccuredpoly("__strlen_n") */
#line 125
/* #pragma ccuredpoly("__stringof") */
#line 127
/* #pragma cilnoremove("__stringof") */
#line 136
/* #pragma ccuredpoly("__stringof_ornull") */
#line 138
/* #pragma cilnoremove("__stringof_ornull") */
#line 147
/* #pragma ccuredpoly("__write_at_least") */
#line 155
/* #pragma ccuredpoly("__read_at_least") */
#line 162
/* #pragma ccuredpoly("__copytags") */
#line 180
/* #pragma ccuredpoly("__mkptr") */
#line 181
/* #pragma cilnoremove("__mkptr") */
#line 188
/* #pragma ccuredpoly("__mkptr_int") */
#line 196
/* #pragma ccuredpoly("__mkptr_size") */
#line 197
/* #pragma cilnoremove("__mkptr_size") */
#line 206
/* #pragma ccuredpoly("__mkptr_string") */
#line 207
/* #pragma cilnoremove("__mkptr_string") */
#line 215
/* #pragma ccuredpoly("__align_seq") */
#line 216
/* #pragma cilnoremove("__align_seq") */
#line 227
/* #pragma ccuredpoly("__trusted_cast") */
#line 228
/* #pragma cilnoremove("__trusted_cast") */
#line 237
/* #pragma ccuredpoly("__trusted_deepcast") */
#line 238
/* #pragma cilnoremove("__trusted_deepcast") */
#line 250
/* #pragma ccuredpoly("ccured_hasuniontag") */
#line 259
/* #pragma ccuredpoly("__ccured_kind_of") */
#line 307
/* #pragma ccuredpoly("__ccured_mangling_of") */
#line 308
/* #pragma cilnoremove("__ccured_mangling_of") */
#line 312
/* #pragma ccuredpoly("__ccured_has_empty_mangling") */
#line 313
/* #pragma cilnoremove("__ccured_has_empty_mangling") */
#line 327
/* #pragma cilnoremove("abort_deepcopy") */
#line 451
/* #pragma cilnoremove("struct printf_arguments") */
#line 45 "/users/rupak/ccured/include/time_wrappers.h"
/* #pragma ccuredwrapper("time_wrapper",of("time")) */
#line 59
/* #pragma ccuredwrapper("ctime_wrapper",of("ctime")) */
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments )) */
#line 266
/* #pragma ccuredpoly("__ccured_va_arg") */
#line 303
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___0 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___0 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___0 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___0 )) */
#line 69 "/users/rupak/ccured/include/io_wrappers.h"
/* #pragma ccuredwrapper("unlink_wrapper",of("unlink")) */
#line 79
/* #pragma ccuredwrapper("open_wrapper",of("open")) */
#line 80
/* #pragma ccuredvararg("open_wrapper",sizeof(int )) */
#line 123
/* #pragma ccuredwrapper("rename_wrapper",of("rename")) */
#line 6 "/users/rupak/ccured/include/malloc_wrappers.h"
/* #pragma ccuredalloc("malloc",nozero,sizein(1)) */
#line 8
/* #pragma ccuredpoly("realloc") */
#line 9
/* #pragma ccuredwrapper("realloc_wrapper",of("realloc")) */
#line 22
/* #pragma ccuredwrapper("free_wrapper",of("free")) */
#line 27
/* #pragma ccuredalloc("alloca",nozero,sizein(1)) */
#line 28
/* #pragma ccuredalloc("calloc",zero,sizemul(1,2)) */
#line 46 "/users/rupak/ccured/include/string_wrappers.h"
/* #pragma ccuredwrapper("strlen_wrapper",of("strlen")) */
#line 52
/* #pragma ccuredwrapper("bzero_wrapper",of("bzero")) */
#line 61
/* #pragma ccuredwrapper("strcpy_wrapper",of("strcpy")) */
#line 81
/* #pragma ccuredwrapper("strncpy_wrapper",of("strncpy")) */
#line 95
/* #pragma ccuredwrapper("strcat_wrapper",of("strcat")) */
#line 111
/* #pragma ccuredwrapper("strncat_wrapper",of("strncat")) */
#line 128
/* #pragma ccuredwrapper("strchr_wrapper",of("strchr")) */
#line 137
/* #pragma ccuredwrapper("strrchr_wrapper",of("strrchr")) */
#line 146
/* #pragma ccuredwrapper("strdup_wrapper",of("strdup")) */
#line 167
/* #pragma ccuredwrapper("strcasecmp_wrapper",of("strcasecmp")) */
#line 173
/* #pragma ccuredwrapper("strcmp_wrapper",of("strcmp")) */
#line 180
/* #pragma ccuredwrapper("strncasecmp_wrapper",of("strncasecmp")) */
#line 194
/* #pragma ccuredwrapper("strncmp_wrapper",of("strncmp")) */
#line 208
/* #pragma ccuredwrapper("strpbrk_wrapper",of("strpbrk")) */
#line 217
/* #pragma ccuredwrapper("strsep_wrapper",of("strsep")) */
#line 234
/* #pragma ccuredwrapper("strtoul_wrapper",of("strtoul")) */
#line 47 "/users/rupak/ccured/include/stdlib_wrappers.h"
/* #pragma ccuredwrapper("atof_wrapper",of("atof")) */
#line 55
/* #pragma ccuredwrapper("atoi_wrapper",of("atoi")) */
#line 63
/* #pragma ccuredwrapper("atol_wrapper",of("atol")) */
#line 93
/* #pragma ccuredpoly("qsort_zero_tags") */
#line 172
/* #pragma ccuredwrapper("qsort_wrapper",of("qsort")) */
#line 216
/* #pragma ccuredwrapper("bsearch_wrapper",of("bsearch")) */
#line 254
/* #pragma ccuredwrapper("strtol_wrapper",of("strtol")) */
#line 270
/* #pragma ccuredwrapper("getenv_wrapper",of("getenv")) */
#line 256 "/users/rupak/ccured/include/string_wrappers.h"
/* #pragma ccuredwrapper("strtok_wrapper",of("strtok")) */
#line 269
/* #pragma ccuredwrapper("strtok_r_wrapper",of("strtok_r")) */
#line 319
/* #pragma ccuredwrapper("memcmp_wrapper",of("memcmp")) */
#line 332
/* #pragma ccuredwrapper("memset_wrapper",of("memset")) */
#line 341
/* #pragma ccuredwrapper("memmove_wrapper",of("memmove")) */
#line 353
/* #pragma ccuredwrapper("memcpy_wrapper",of("memcpy")) */
#line 366
/* #pragma ccuredwrapper("strerror_wrapper",of("strerror")) */
#line 374
/* #pragma ccuredwrapper("strstr_wrapper",of("strstr")) */
#line 383
/* #pragma ccuredwrapper("memchr_wrapper",of("memchr")) */
#line 50 "/users/rupak/ccured/include/pwd_wrappers.h"
/* #pragma ccuredwrapper("getpwnam_wrapper",of("getpwnam")) */
#line 68
/* #pragma ccuredwrapper("getpwuid_wrapper",of("getpwuid")) */
#line 81
/* #pragma ccuredwrapper("getpwent_wrapper",of("getpwent")) */
#line 56 "/users/rupak/ccured/include/signal_wrappers.h"
/* #pragma ccuredpoly("__mkfat_sighandler") */
#line 66
/* #pragma ccuredwrapper("signal_wrapper",of("signal")) */
#line 88
/* #pragma ccuredwrapper("sigaction_wrapper",of("sigaction")) */
#line 168 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredpoly("get_stdin") */
#line 170
/* #pragma ccuredpoly("get_stdout") */
#line 172
/* #pragma ccuredpoly("get_stderr") */
#line 59 "/users/rupak/ccured/include/stdio_wrappers.h"
/* #pragma ccuredpoly("__mkptr_file") */
#line 65
/* #pragma ccuredpoly("__ptrof_file") */
#line 68
/* #pragma ccuredvararg("printf",printf(1)) */
#line 69
/* #pragma ccuredvararg("fprintf",printf(2)) */
#line 70
/* #pragma ccuredvararg("snprintf",printf(3)) */
#line 71
/* #pragma ccuredvararg("syslog",printf(2)) */
#line 72
/* #pragma ccuredvararg("sprintf",printf(2)) */
#line 73
/* #pragma ccuredvararg("vsprintf",printf(2)) */
#line 74
/* #pragma ccuredvararg("vfprintf",printf(2)) */
#line 75
/* #pragma ccuredvararg("vprintf",printf(1)) */
#line 76
/* #pragma ccuredvararg("vsyslog",printf(2)) */
#line 78
/* #pragma ccuredpoly("__endof") */
#line 89
/* #pragma ccuredpoly("ccured_fscanf_string") */
#line 92
/* #pragma ccuredwrapper("ccured_fscanf_string_wrapper",of("ccured_fscanf_string")) */
#line 117
/* #pragma ccuredvararg("sscanf",sizeof(struct scanf_format )) */
#line 118
/* #pragma ccuredvararg("fscanf",sizeof(struct scanf_format )) */
#line 123
/* #pragma ccuredwrapper("fgets_wrapper",of("fgets")) */
#line 132
/* #pragma ccuredwrapper("fopen_wrapper",of("fopen")) */
#line 139
/* #pragma ccuredwrapper("fdopen_wrapper",of("fdopen")) */
#line 146
/* #pragma ccuredwrapper("fflush_wrapper",of("fflush")) */
#line 152
/* #pragma ccuredwrapper("fclose_wrapper",of("fclose")) */
#line 179
/* #pragma ccuredwrapper("_IO_putc_wrapper",of("_IO_putc")) */
#line 185
/* #pragma ccuredwrapper("_IO_getc_wrapper",of("_IO_getc")) */
#line 210
/* #pragma ccuredwrapper("fputc_wrapper",of("fputc")) */
#line 216
/* #pragma ccuredwrapper("fputs_wrapper",of("fputs")) */
#line 222
/* #pragma ccuredwrapper("fgetc_wrapper",of("fgetc")) */
#line 228
/* #pragma ccuredwrapper("puts_wrapper",of("puts")) */
#line 234
/* #pragma ccuredwrapper("fileno_wrapper",of("fileno")) */
#line 240
/* #pragma ccuredwrapper("ferror_wrapper",of("ferror")) */
#line 246
/* #pragma ccuredwrapper("fseek_wrapper",of("fseek")) */
#line 253
/* #pragma ccuredwrapper("clearerr_wrapper",of("clearerr")) */
#line 264
/* #pragma ccuredwrapper("fread_wrapper",of("fread")) */
#line 275
/* #pragma ccuredwrapper("fwrite_wrapper",of("fwrite")) */
#line 288
/* #pragma ccuredwrapper("gets_wrapper",of("gets")) */
#line 314
/* #pragma ccuredvararg("vsnprintf_wrapper",printf(3)) */
#line 315
/* #pragma ccuredwrapper("vsnprintf_wrapper",of("vsnprintf")) */
#line 322
/* #pragma ccuredvararg("vsprintf_wrapper",printf(2)) */
#line 323
/* #pragma ccuredwrapper("vsprintf_wrapper",of("vsprintf")) */
#line 330
/* #pragma ccuredvararg("snprintf_wrapper",printf(3)) */
#line 331
/* #pragma ccuredwrapper("snprintf_wrapper",of("snprintf")) */
#line 343
/* #pragma ccuredvararg("sprintf_wrapper",printf(2)) */
#line 344
/* #pragma ccuredwrapper("sprintf_wrapper",of("sprintf")) */
#line 366
/* #pragma ccuredpoly("ccured_fscanf_double") */
#line 382
/* #pragma ccuredpoly("ccured_fscanf_int") */
#line 398
/* #pragma ccuredpoly("ccured_fscanf_nothing") */
#line 467
/* #pragma ccuredwrapper("perror_wrapper",of("perror")) */
#line 49 "/users/rupak/ccured/include/stat_wrappers.h"
/* #pragma ccuredwrapper("fstat_wrapper",of("fstat")) */
#line 57
/* #pragma ccuredwrapper("stat_wrapper",of("stat")) */
#line 68
/* #pragma ccuredwrapper("__xstat_wrapper",of("__xstat")) */
#line 79 "/users/rupak/ccured/include/time_wrappers.h"
/* #pragma ccuredwrapper("asctime_wrapper",of("asctime")) */
#line 13 "/users/rupak/ccured/include/functions/deepcopy_stringarray.h"
/* #pragma cilnoremove("__deepcopy_stringarray_from_compat") */
#line 14
/* #pragma ccuredpoly("__deepcopy_stringarray_from_compat") */
#line 53
/* #pragma ccuredpoly("__deepcopy_stringarray_to_compat") */
#line 44 "/users/rupak/ccured/include/unistd_wrappers.h"
/* #pragma ccuredwrapper("execv_wrapper",of("execv")) */
#line 66
/* #pragma ccuredwrapper("execvp_wrapper",of("execvp")) */
#line 86
/* #pragma ccuredwrapper("execve_wrapper",of("execve")) */
#line 106
/* #pragma ccuredvararg("execl",sizeof(struct __ccured_execl_arguments )) */
#line 107
/* #pragma ccuredvararg("execlp",sizeof(struct __ccured_execl_arguments )) */
#line 108
/* #pragma ccuredvararg("execle",sizeof(struct __ccured_execl_arguments )) */
#line 110
/* #pragma ccuredwrapper("getlogin_wrapper",of("getlogin")) */
#line 117
/* #pragma ccuredwrapper("ttyname_wrapper",of("ttyname")) */
#line 129
/* #pragma ccuredwrapper("getopt_wrapper",of("getopt")) */
#line 174
/* #pragma ccuredwrapper("read_wrapper",of("read")) */
#line 182
/* #pragma ccuredwrapper("write_wrapper",of("write")) */
#line 195
/* #pragma ccuredwrapper("getusershell_wrapper",of("getusershell")) */
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___1 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___1 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___1 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___1 )) */
#line 303
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___2 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___2 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___2 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___2 )) */
#line 30 "subs.c"
void init_conf(void) ;
#line 35 "subs.c"
char *fcronconf  =    (char *)((void *)0);
#line 36 "subs.c"
char *fcrontabs  =    (char *)((void *)0);
#line 37 "subs.c"
char *pidfile  =    (char *)((void *)0);
#line 38 "subs.c"
char *fifofile  =    (char *)((void *)0);
#line 39 "subs.c"
char *fcronallow  =    (char *)((void *)0);
#line 40 "subs.c"
char *fcrondeny  =    (char *)((void *)0);
#line 41 "subs.c"
char *shell  =    (char *)((void *)0);
#line 42 "subs.c"
char *sendmail  =    (char *)((void *)0);
#line 43 "subs.c"
char *editor  =    (char *)((void *)0);
#line 45 "subs.c"
int remove_blanks(char *str ) 
{ char *c ;
  int tmp ;

  {
#line 50
  c = str;
#line 53
  while ((*c)) {
#line 54
    c ++;
  }
#line 57
  while (1) {
#line 57
    c --;
#line 57
    if ((unsigned int )c >= (unsigned int )str) {
#line 57
      tmp = _get__ctype_b((int )(*c));
#line 57
      if (! (tmp & 8192)) {
#line 57
        break;
      }
    } else {
#line 57
      break;
    }
  }
#line 61
  if ((int )(*c) == 10) {
#line 62
    (*c) = (char )'\000';
  } else {
#line 66
    c ++;
#line 66
    (*c) = (char )'\000';
  }
#line 69
  return (c - str);
}
}
#line 74 "subs.c"
char *strdup2(char const   *str ) 
{ char *ptr ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 77
  tmp = strlen(str);
#line 77
  tmp___0 = (char *)malloc(tmp + 1U);
#line 77
  ptr = tmp___0;
#line 79
  if (! ptr) {
#line 80
    die_e((char *)"Could not calloc");
  }
#line 82
  strcpy((char */* __restrict  */)ptr, (char const   */* __restrict  */)str);
#line 83
  return (ptr);
}
}
#line 87 "subs.c"
int get_word(char **str ) 
{ char *ptr ;
  int tmp ;
  int tmp___0 ;

  {
#line 93
  while (1) {
#line 93
    if (! ((int )(*((*str))) == 32)) {
#line 93
      if (! ((int )(*((*str))) == 9)) {
#line 93
        break;
      }
    }
#line 93
    (*str) ++;
  }
#line 94
  ptr = (*str);
#line 96
  while (1) {
#line 96
    tmp = _get__ctype_b((int )(*ptr));
#line 96
    if (tmp & 8) {
      goto _L;
    } else {
#line 96
      if ((int )(*ptr) == 95) {
        goto _L;
      } else {
#line 96
        if ((int )(*ptr) == 45) {
          _L: /* CIL Label */ 
#line 96
          if ((int )(*ptr) != 61) {
#line 96
            tmp___0 = _get__ctype_b((int )(*ptr));
#line 96
            if (tmp___0 & 8192) {
#line 96
              break;
            }
          } else {
#line 96
            break;
          }
        } else {
#line 96
          break;
        }
      }
    }
#line 98
    ptr ++;
  }
#line 100
  return (ptr - (*str));
}
}
#line 103 "subs.c"
void init_conf(void) 
{ 

  {
#line 108
  if ((unsigned int )fcronconf == (unsigned int )((void *)0)) {
#line 109
    fcronconf = strdup2("/etc/fcron.conf");
  }
#line 110
  fcrontabs = strdup2("/var/spool/fcron");
#line 111
  pidfile = strdup2("/var/run/fcron.pid");
#line 112
  fifofile = strdup2("/var/run/fcron.fifo");
#line 113
  fcronallow = strdup2("/etc/fcron.allow");
#line 114
  fcrondeny = strdup2("/etc/fcron.deny");
#line 115
  shell = strdup2("/bin/sh");
#line 117
  sendmail = strdup2("/usr/lib/sendmail");
#line 119
  editor = strdup2("/bin/vi");
#line 120
  return;
}
}
#line 122 "subs.c"
void free_conf(void) 
{ 

  {
#line 126
  free((void *)fcronconf);
#line 127
  free((void *)fcrontabs);
#line 128
  free((void *)pidfile);
#line 129
  free((void *)fifofile);
#line 130
  free((void *)fcronallow);
#line 131
  free((void *)fcrondeny);
#line 132
  free((void *)shell);
#line 133
  free((void *)sendmail);
#line 134
  free((void *)editor);
#line 135
  return;
}
}
#line 139 "subs.c"
void read_conf(void) 
{ FILE *f ;
  struct stat st ;
  char buf[1024] ;
  char *ptr1 ;
  char *ptr2 ;
  short namesize ;
  char err_on_enoent ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 143
  f = (FILE *)((void *)0);
#line 146
  ptr1 = (char *)((void *)0);
#line 146
  ptr2 = (char *)((void *)0);
#line 147
  namesize = 0;
#line 148
  err_on_enoent = 0;
#line 150
  if ((unsigned int )fcronconf != (unsigned int )((void *)0)) {
#line 152
    err_on_enoent = 1;
  }
#line 154
  init_conf();
#line 156
  f = fopen((char const   */* __restrict  */)fcronconf, (char const   */* __restrict  */)"r");
#line 156
  if ((unsigned int )f == (unsigned int )((void *)0)) {
#line 157
    tmp = __errno_location();
#line 157
    if ((*tmp) == 2) {
#line 158
      if (err_on_enoent) {
#line 159
        die_e((char *)"Could not read %s", fcronconf);
      } else {
#line 162
        return;
      }
    } else {
#line 165
      error_e((char *)"Could not read %s : config file ignored", fcronconf);
#line 166
      return;
    }
  }
#line 171
  tmp___0 = fileno(f);
#line 171
  tmp___1 = fstat__extinline(tmp___0, & st);
#line 171
  if (tmp___1 != 0) {
#line 173
    error((char *)"Conf file (%s) must be owned by root and (no more than) 644 : ignored",
          fcronconf);
#line 175
    fclose(f);
#line 176
    return;
  } else {
#line 171
    if (st.st_uid != 0U) {
#line 173
      error((char *)"Conf file (%s) must be owned by root and (no more than) 644 : ignored",
            fcronconf);
#line 175
      fclose(f);
#line 176
      return;
    } else {
#line 171
      if (st.st_mode & 16U) {
#line 173
        error((char *)"Conf file (%s) must be owned by root and (no more than) 644 : ignored",
              fcronconf);
#line 175
        fclose(f);
#line 176
        return;
      } else {
#line 171
        if (st.st_mode & 2U) {
#line 173
          error((char *)"Conf file (%s) must be owned by root and (no more than) 644 : ignored",
                fcronconf);
#line 175
          fclose(f);
#line 176
          return;
        }
      }
    }
  }
#line 179
  while (1) {
#line 179
    ptr1 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)f);
#line 179
    if (! ((unsigned int )ptr1 != (unsigned int )((void *)0))) {
#line 179
      break;
    }
#line 181
    while (1) {
#line 181
      if (! ((int )(*ptr1) == 32)) {
#line 181
        if (! ((int )(*ptr1) == 9)) {
#line 181
          break;
        }
      }
#line 181
      ptr1 ++;
    }
#line 184
    if ((int )(*ptr1) == 35) {
#line 185
      continue;
    } else {
#line 184
      if ((int )(*ptr1) == 10) {
#line 185
        continue;
      } else {
#line 184
        if ((int )(*ptr1) == 0) {
#line 185
          continue;
        }
      }
    }
#line 187
    remove_blanks(ptr1);
#line 190
    namesize = (short )get_word(& ptr1);
#line 190
    if ((int )namesize == 0) {
#line 192
      error((char *)"Zero-length var name at line %s : line ignored", buf);
    }
#line 194
    ptr2 = ptr1 + (int )namesize;
#line 197
    while (1) {
#line 197
      tmp___2 = _get__ctype_b((int )(*ptr2));
#line 197
      if (! (tmp___2 & 8192)) {
#line 197
        break;
      }
#line 197
      ptr2 ++;
    }
#line 198
    if ((int )(*ptr2) == 61) {
#line 198
      ptr2 ++;
    }
#line 199
    while (1) {
#line 199
      tmp___3 = _get__ctype_b((int )(*ptr2));
#line 199
      if (! (tmp___3 & 8192)) {
#line 199
        break;
      }
#line 199
      ptr2 ++;
    }
#line 202
    tmp___11 = strncmp((char const   *)ptr1, "fcrontabs", (unsigned int )namesize);
#line 202
    if (tmp___11 == 0) {
#line 203
      fcrontabs = strdup2((char const   *)ptr2);
    } else {
#line 204
      tmp___10 = strncmp((char const   *)ptr1, "pidfile", (unsigned int )namesize);
#line 204
      if (tmp___10 == 0) {
#line 205
        pidfile = strdup2((char const   *)ptr2);
      } else {
#line 206
        tmp___9 = strncmp((char const   *)ptr1, "fifofile", (unsigned int )namesize);
#line 206
        if (tmp___9 == 0) {
#line 207
          fifofile = strdup2((char const   *)ptr2);
        } else {
#line 208
          tmp___8 = strncmp((char const   *)ptr1, "fcronallow", (unsigned int )namesize);
#line 208
          if (tmp___8 == 0) {
#line 209
            fcronallow = strdup2((char const   *)ptr2);
          } else {
#line 210
            tmp___7 = strncmp((char const   *)ptr1, "fcrondeny", (unsigned int )namesize);
#line 210
            if (tmp___7 == 0) {
#line 211
              fcrondeny = strdup2((char const   *)ptr2);
            } else {
#line 212
              tmp___6 = strncmp((char const   *)ptr1, "shell", (unsigned int )namesize);
#line 212
              if (tmp___6 == 0) {
#line 213
                shell = strdup2((char const   *)ptr2);
              } else {
#line 214
                tmp___5 = strncmp((char const   *)ptr1, "sendmail", (unsigned int )namesize);
#line 214
                if (tmp___5 == 0) {
#line 215
                  sendmail = strdup2((char const   *)ptr2);
                } else {
#line 216
                  tmp___4 = strncmp((char const   *)ptr1, "editor", (unsigned int )namesize);
#line 216
                  if (tmp___4 == 0) {
#line 217
                    editor = strdup2((char const   *)ptr2);
                  } else {
#line 219
                    error((char *)"Unknown var name at line %s : line ignored", buf);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 223
  if (debug_opt) {
#line 224
    if (debug_opt) {
#line 224
      Debug((char *)"  fcronconf=%s", fcronconf);
    }
  }
#line 235
  fclose(f);
#line 237
  return;
}
}
#line 1 "save.o"
/* #pragma merger(0,"./save.i","-O2 -Wall") */
#line 123 "/users/rupak/ccured/include/ccuredannot.h"
/* #pragma cilnoremove("__ccuredInit") */
#line 20 "/users/rupak/ccured/include/ccured.h"
/* #pragma cilnoremove("wrapperAlloc") */
#line 21
/* #pragma ccuredalloc("wrapperAlloc",sizein(1),nozero) */
#line 24
/* #pragma cilnoremove("wrapperFree") */
#line 25
/* #pragma ccuredpoly("wrapperFree") */
#line 29
/* #pragma cilnoremove("wrapperStrdup") */
#line 30
/* #pragma ccuredpoly("wrapperStrdup") */
#line 50
/* #pragma ccuredpoly("__ptrof_nocheck") */
#line 51
/* #pragma cilnoremove("__ptrof_nocheck") */
#line 57
/* #pragma ccuredpoly("__startof") */
#line 63
/* #pragma ccuredpoly("__endof") */
#line 78
/* #pragma ccuredpoly("__ptrof") */
#line 84
/* #pragma ccuredpoly("__ptrof_size") */
#line 85
/* #pragma cilnoremove("__ptrof_size") */
#line 92
/* #pragma ccuredpoly("__verify_nul") */
#line 101
/* #pragma ccuredpoly("__strlen") */
#line 111
/* #pragma ccuredpoly("__strlen_n") */
#line 125
/* #pragma ccuredpoly("__stringof") */
#line 127
/* #pragma cilnoremove("__stringof") */
#line 136
/* #pragma ccuredpoly("__stringof_ornull") */
#line 138
/* #pragma cilnoremove("__stringof_ornull") */
#line 147
/* #pragma ccuredpoly("__write_at_least") */
#line 155
/* #pragma ccuredpoly("__read_at_least") */
#line 162
/* #pragma ccuredpoly("__copytags") */
#line 180
/* #pragma ccuredpoly("__mkptr") */
#line 181
/* #pragma cilnoremove("__mkptr") */
#line 188
/* #pragma ccuredpoly("__mkptr_int") */
#line 196
/* #pragma ccuredpoly("__mkptr_size") */
#line 197
/* #pragma cilnoremove("__mkptr_size") */
#line 206
/* #pragma ccuredpoly("__mkptr_string") */
#line 207
/* #pragma cilnoremove("__mkptr_string") */
#line 215
/* #pragma ccuredpoly("__align_seq") */
#line 216
/* #pragma cilnoremove("__align_seq") */
#line 227
/* #pragma ccuredpoly("__trusted_cast") */
#line 228
/* #pragma cilnoremove("__trusted_cast") */
#line 237
/* #pragma ccuredpoly("__trusted_deepcast") */
#line 238
/* #pragma cilnoremove("__trusted_deepcast") */
#line 250
/* #pragma ccuredpoly("ccured_hasuniontag") */
#line 259
/* #pragma ccuredpoly("__ccured_kind_of") */
#line 307
/* #pragma ccuredpoly("__ccured_mangling_of") */
#line 308
/* #pragma cilnoremove("__ccured_mangling_of") */
#line 312
/* #pragma ccuredpoly("__ccured_has_empty_mangling") */
#line 313
/* #pragma cilnoremove("__ccured_has_empty_mangling") */
#line 327
/* #pragma cilnoremove("abort_deepcopy") */
#line 451
/* #pragma cilnoremove("struct printf_arguments") */
#line 45 "/users/rupak/ccured/include/time_wrappers.h"
/* #pragma ccuredwrapper("time_wrapper",of("time")) */
#line 59
/* #pragma ccuredwrapper("ctime_wrapper",of("ctime")) */
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments )) */
#line 266
/* #pragma ccuredpoly("__ccured_va_arg") */
#line 303
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___0 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___0 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___0 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___0 )) */
#line 69 "/users/rupak/ccured/include/io_wrappers.h"
/* #pragma ccuredwrapper("unlink_wrapper",of("unlink")) */
#line 79
/* #pragma ccuredwrapper("open_wrapper",of("open")) */
#line 80
/* #pragma ccuredvararg("open_wrapper",sizeof(int )) */
#line 123
/* #pragma ccuredwrapper("rename_wrapper",of("rename")) */
#line 6 "/users/rupak/ccured/include/malloc_wrappers.h"
/* #pragma ccuredalloc("malloc",nozero,sizein(1)) */
#line 8
/* #pragma ccuredpoly("realloc") */
#line 9
/* #pragma ccuredwrapper("realloc_wrapper",of("realloc")) */
#line 22
/* #pragma ccuredwrapper("free_wrapper",of("free")) */
#line 27
/* #pragma ccuredalloc("alloca",nozero,sizein(1)) */
#line 28
/* #pragma ccuredalloc("calloc",zero,sizemul(1,2)) */
#line 46 "/users/rupak/ccured/include/string_wrappers.h"
/* #pragma ccuredwrapper("strlen_wrapper",of("strlen")) */
#line 52
/* #pragma ccuredwrapper("bzero_wrapper",of("bzero")) */
#line 61
/* #pragma ccuredwrapper("strcpy_wrapper",of("strcpy")) */
#line 81
/* #pragma ccuredwrapper("strncpy_wrapper",of("strncpy")) */
#line 95
/* #pragma ccuredwrapper("strcat_wrapper",of("strcat")) */
#line 111
/* #pragma ccuredwrapper("strncat_wrapper",of("strncat")) */
#line 128
/* #pragma ccuredwrapper("strchr_wrapper",of("strchr")) */
#line 137
/* #pragma ccuredwrapper("strrchr_wrapper",of("strrchr")) */
#line 146
/* #pragma ccuredwrapper("strdup_wrapper",of("strdup")) */
#line 167
/* #pragma ccuredwrapper("strcasecmp_wrapper",of("strcasecmp")) */
#line 173
/* #pragma ccuredwrapper("strcmp_wrapper",of("strcmp")) */
#line 180
/* #pragma ccuredwrapper("strncasecmp_wrapper",of("strncasecmp")) */
#line 194
/* #pragma ccuredwrapper("strncmp_wrapper",of("strncmp")) */
#line 208
/* #pragma ccuredwrapper("strpbrk_wrapper",of("strpbrk")) */
#line 217
/* #pragma ccuredwrapper("strsep_wrapper",of("strsep")) */
#line 234
/* #pragma ccuredwrapper("strtoul_wrapper",of("strtoul")) */
#line 47 "/users/rupak/ccured/include/stdlib_wrappers.h"
/* #pragma ccuredwrapper("atof_wrapper",of("atof")) */
#line 55
/* #pragma ccuredwrapper("atoi_wrapper",of("atoi")) */
#line 63
/* #pragma ccuredwrapper("atol_wrapper",of("atol")) */
#line 93
/* #pragma ccuredpoly("qsort_zero_tags") */
#line 172
/* #pragma ccuredwrapper("qsort_wrapper",of("qsort")) */
#line 216
/* #pragma ccuredwrapper("bsearch_wrapper",of("bsearch")) */
#line 254
/* #pragma ccuredwrapper("strtol_wrapper",of("strtol")) */
#line 270
/* #pragma ccuredwrapper("getenv_wrapper",of("getenv")) */
#line 256 "/users/rupak/ccured/include/string_wrappers.h"
/* #pragma ccuredwrapper("strtok_wrapper",of("strtok")) */
#line 269
/* #pragma ccuredwrapper("strtok_r_wrapper",of("strtok_r")) */
#line 319
/* #pragma ccuredwrapper("memcmp_wrapper",of("memcmp")) */
#line 332
/* #pragma ccuredwrapper("memset_wrapper",of("memset")) */
#line 341
/* #pragma ccuredwrapper("memmove_wrapper",of("memmove")) */
#line 353
/* #pragma ccuredwrapper("memcpy_wrapper",of("memcpy")) */
#line 366
/* #pragma ccuredwrapper("strerror_wrapper",of("strerror")) */
#line 374
/* #pragma ccuredwrapper("strstr_wrapper",of("strstr")) */
#line 383
/* #pragma ccuredwrapper("memchr_wrapper",of("memchr")) */
#line 50 "/users/rupak/ccured/include/pwd_wrappers.h"
/* #pragma ccuredwrapper("getpwnam_wrapper",of("getpwnam")) */
#line 68
/* #pragma ccuredwrapper("getpwuid_wrapper",of("getpwuid")) */
#line 81
/* #pragma ccuredwrapper("getpwent_wrapper",of("getpwent")) */
#line 56 "/users/rupak/ccured/include/signal_wrappers.h"
/* #pragma ccuredpoly("__mkfat_sighandler") */
#line 66
/* #pragma ccuredwrapper("signal_wrapper",of("signal")) */
#line 88
/* #pragma ccuredwrapper("sigaction_wrapper",of("sigaction")) */
#line 168 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredpoly("get_stdin") */
#line 170
/* #pragma ccuredpoly("get_stdout") */
#line 172
/* #pragma ccuredpoly("get_stderr") */
#line 59 "/users/rupak/ccured/include/stdio_wrappers.h"
/* #pragma ccuredpoly("__mkptr_file") */
#line 65
/* #pragma ccuredpoly("__ptrof_file") */
#line 68
/* #pragma ccuredvararg("printf",printf(1)) */
#line 69
/* #pragma ccuredvararg("fprintf",printf(2)) */
#line 70
/* #pragma ccuredvararg("snprintf",printf(3)) */
#line 71
/* #pragma ccuredvararg("syslog",printf(2)) */
#line 72
/* #pragma ccuredvararg("sprintf",printf(2)) */
#line 73
/* #pragma ccuredvararg("vsprintf",printf(2)) */
#line 74
/* #pragma ccuredvararg("vfprintf",printf(2)) */
#line 75
/* #pragma ccuredvararg("vprintf",printf(1)) */
#line 76
/* #pragma ccuredvararg("vsyslog",printf(2)) */
#line 78
/* #pragma ccuredpoly("__endof") */
#line 89
/* #pragma ccuredpoly("ccured_fscanf_string") */
#line 92
/* #pragma ccuredwrapper("ccured_fscanf_string_wrapper",of("ccured_fscanf_string")) */
#line 117
/* #pragma ccuredvararg("sscanf",sizeof(struct scanf_format )) */
#line 118
/* #pragma ccuredvararg("fscanf",sizeof(struct scanf_format )) */
#line 123
/* #pragma ccuredwrapper("fgets_wrapper",of("fgets")) */
#line 132
/* #pragma ccuredwrapper("fopen_wrapper",of("fopen")) */
#line 139
/* #pragma ccuredwrapper("fdopen_wrapper",of("fdopen")) */
#line 146
/* #pragma ccuredwrapper("fflush_wrapper",of("fflush")) */
#line 152
/* #pragma ccuredwrapper("fclose_wrapper",of("fclose")) */
#line 179
/* #pragma ccuredwrapper("_IO_putc_wrapper",of("_IO_putc")) */
#line 185
/* #pragma ccuredwrapper("_IO_getc_wrapper",of("_IO_getc")) */
#line 210
/* #pragma ccuredwrapper("fputc_wrapper",of("fputc")) */
#line 216
/* #pragma ccuredwrapper("fputs_wrapper",of("fputs")) */
#line 222
/* #pragma ccuredwrapper("fgetc_wrapper",of("fgetc")) */
#line 228
/* #pragma ccuredwrapper("puts_wrapper",of("puts")) */
#line 234
/* #pragma ccuredwrapper("fileno_wrapper",of("fileno")) */
#line 240
/* #pragma ccuredwrapper("ferror_wrapper",of("ferror")) */
#line 246
/* #pragma ccuredwrapper("fseek_wrapper",of("fseek")) */
#line 253
/* #pragma ccuredwrapper("clearerr_wrapper",of("clearerr")) */
#line 264
/* #pragma ccuredwrapper("fread_wrapper",of("fread")) */
#line 275
/* #pragma ccuredwrapper("fwrite_wrapper",of("fwrite")) */
#line 288
/* #pragma ccuredwrapper("gets_wrapper",of("gets")) */
#line 314
/* #pragma ccuredvararg("vsnprintf_wrapper",printf(3)) */
#line 315
/* #pragma ccuredwrapper("vsnprintf_wrapper",of("vsnprintf")) */
#line 322
/* #pragma ccuredvararg("vsprintf_wrapper",printf(2)) */
#line 323
/* #pragma ccuredwrapper("vsprintf_wrapper",of("vsprintf")) */
#line 330
/* #pragma ccuredvararg("snprintf_wrapper",printf(3)) */
#line 331
/* #pragma ccuredwrapper("snprintf_wrapper",of("snprintf")) */
#line 343
/* #pragma ccuredvararg("sprintf_wrapper",printf(2)) */
#line 344
/* #pragma ccuredwrapper("sprintf_wrapper",of("sprintf")) */
#line 366
/* #pragma ccuredpoly("ccured_fscanf_double") */
#line 382
/* #pragma ccuredpoly("ccured_fscanf_int") */
#line 398
/* #pragma ccuredpoly("ccured_fscanf_nothing") */
#line 467
/* #pragma ccuredwrapper("perror_wrapper",of("perror")) */
#line 49 "/users/rupak/ccured/include/stat_wrappers.h"
/* #pragma ccuredwrapper("fstat_wrapper",of("fstat")) */
#line 57
/* #pragma ccuredwrapper("stat_wrapper",of("stat")) */
#line 68
/* #pragma ccuredwrapper("__xstat_wrapper",of("__xstat")) */
#line 79 "/users/rupak/ccured/include/time_wrappers.h"
/* #pragma ccuredwrapper("asctime_wrapper",of("asctime")) */
#line 13 "/users/rupak/ccured/include/functions/deepcopy_stringarray.h"
/* #pragma cilnoremove("__deepcopy_stringarray_from_compat") */
#line 14
/* #pragma ccuredpoly("__deepcopy_stringarray_from_compat") */
#line 53
/* #pragma ccuredpoly("__deepcopy_stringarray_to_compat") */
#line 44 "/users/rupak/ccured/include/unistd_wrappers.h"
/* #pragma ccuredwrapper("execv_wrapper",of("execv")) */
#line 66
/* #pragma ccuredwrapper("execvp_wrapper",of("execvp")) */
#line 86
/* #pragma ccuredwrapper("execve_wrapper",of("execve")) */
#line 106
/* #pragma ccuredvararg("execl",sizeof(struct __ccured_execl_arguments )) */
#line 107
/* #pragma ccuredvararg("execlp",sizeof(struct __ccured_execl_arguments )) */
#line 108
/* #pragma ccuredvararg("execle",sizeof(struct __ccured_execl_arguments )) */
#line 110
/* #pragma ccuredwrapper("getlogin_wrapper",of("getlogin")) */
#line 117
/* #pragma ccuredwrapper("ttyname_wrapper",of("ttyname")) */
#line 129
/* #pragma ccuredwrapper("getopt_wrapper",of("getopt")) */
#line 174
/* #pragma ccuredwrapper("read_wrapper",of("read")) */
#line 182
/* #pragma ccuredwrapper("write_wrapper",of("write")) */
#line 195
/* #pragma ccuredwrapper("getusershell_wrapper",of("getusershell")) */
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___1 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___1 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___1 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___1 )) */
#line 303
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___2 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___2 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___2 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___2 )) */
#line 32 "save.c"
int write_buf_to_disk(int fd , char *write_buf , int *buf_used ) ;
#line 33
int save_type(int fd , short type , char *write_buf , int *buf_used ) ;
#line 34
int save_str(int fd , short type , char *str , char *write_buf , int *buf_used ) ;
#line 35
int save_strn(int fd , short type , char *str , short size , char *write_buf , int *buf_used ) ;
#line 37
int save_lint(int fd , short type , long value , char *write_buf , int *buf_used ) ;
#line 38
int save_one_file(cf_t *file , char *filename , uid_t own_uid , gid_t own_gid , time_t save_date ) ;
#line 42 "save.c"
int save_type(int fd , short type , char *write_buf , int *buf_used ) 
{ short size ;
  int write_len ;
  int tmp ;

  {
#line 46
  size = 0;
#line 47
  write_len = (int )(sizeof(type) + sizeof(size));
#line 49
  if (write_len > 1024 - (*buf_used)) {
#line 50
    tmp = write_buf_to_disk(fd, write_buf, buf_used);
#line 50
    if (tmp == -1) {
#line 51
      return (-1);
    }
  }
#line 53
  memcpy((void */* __restrict  */)(write_buf + (*buf_used)), (void const   */* __restrict  */)(& type),
         sizeof(type));
#line 54
  (*buf_used) = (int )((unsigned int )(*buf_used) + sizeof(type));
#line 55
  memcpy((void */* __restrict  */)(write_buf + (*buf_used)), (void const   */* __restrict  */)(& size),
         sizeof(size));
#line 56
  (*buf_used) = (int )((unsigned int )(*buf_used) + sizeof(size));
#line 58
  return (0);
}
}
#line 62 "save.c"
int save_str(int fd , short type , char *str , char *write_buf , int *buf_used ) 
{ short size ;
  short tmp ;
  int write_len ;
  int tmp___0 ;

  {
#line 66
  tmp = (short )strlen((char const   *)str);
#line 66
  size = tmp;
#line 67
  write_len = (int )((sizeof(type) + sizeof(size)) + (unsigned int )size);
#line 69
  if (write_len > 1024 - (*buf_used)) {
#line 70
    tmp___0 = write_buf_to_disk(fd, write_buf, buf_used);
#line 70
    if (tmp___0 == -1) {
#line 71
      return (-1);
    }
  }
#line 73
  memcpy((void */* __restrict  */)(write_buf + (*buf_used)), (void const   */* __restrict  */)(& type),
         sizeof(type));
#line 74
  (*buf_used) = (int )((unsigned int )(*buf_used) + sizeof(type));
#line 75
  memcpy((void */* __restrict  */)(write_buf + (*buf_used)), (void const   */* __restrict  */)(& size),
         sizeof(size));
#line 76
  (*buf_used) = (int )((unsigned int )(*buf_used) + sizeof(size));
#line 77
  memcpy((void */* __restrict  */)(write_buf + (*buf_used)), (void const   */* __restrict  */)str,
         (unsigned int )size);
#line 78
  (*buf_used) += (int )size;
#line 80
  return (0);
}
}
#line 83 "save.c"
int save_strn(int fd , short type , char *str , short size , char *write_buf , int *buf_used ) 
{ int write_len ;
  int tmp ;

  {
#line 88
  write_len = (int )((sizeof(type) + sizeof(size)) + (unsigned int )size);
#line 90
  if (write_len > 1024 - (*buf_used)) {
#line 91
    tmp = write_buf_to_disk(fd, write_buf, buf_used);
#line 91
    if (tmp == -1) {
#line 92
      return (-1);
    }
  }
#line 94
  memcpy((void */* __restrict  */)(write_buf + (*buf_used)), (void const   */* __restrict  */)(& type),
         sizeof(type));
#line 95
  (*buf_used) = (int )((unsigned int )(*buf_used) + sizeof(type));
#line 96
  memcpy((void */* __restrict  */)(write_buf + (*buf_used)), (void const   */* __restrict  */)(& size),
         sizeof(size));
#line 97
  (*buf_used) = (int )((unsigned int )(*buf_used) + sizeof(size));
#line 98
  memcpy((void */* __restrict  */)(write_buf + (*buf_used)), (void const   */* __restrict  */)str,
         (unsigned int )size);
#line 99
  (*buf_used) += (int )size;
#line 101
  return (0);
}
}
#line 104 "save.c"
int save_lint(int fd , short type , long value , char *write_buf , int *buf_used ) 
{ short size ;
  int write_len ;
  int tmp ;

  {
#line 108
  size = (short )sizeof(value);
#line 109
  write_len = (int )((sizeof(type) + sizeof(size)) + (unsigned int )size);
#line 111
  if (write_len > 1024 - (*buf_used)) {
#line 112
    tmp = write_buf_to_disk(fd, write_buf, buf_used);
#line 112
    if (tmp == -1) {
#line 113
      return (-1);
    }
  }
#line 115
  memcpy((void */* __restrict  */)(write_buf + (*buf_used)), (void const   */* __restrict  */)(& type),
         sizeof(type));
#line 116
  (*buf_used) = (int )((unsigned int )(*buf_used) + sizeof(type));
#line 117
  memcpy((void */* __restrict  */)(write_buf + (*buf_used)), (void const   */* __restrict  */)(& size),
         sizeof(size));
#line 118
  (*buf_used) = (int )((unsigned int )(*buf_used) + sizeof(size));
#line 119
  memcpy((void */* __restrict  */)(write_buf + (*buf_used)), (void const   */* __restrict  */)(& value),
         (unsigned int )size);
#line 120
  (*buf_used) += (int )size;
#line 122
  return (0);
}
}
#line 126 "save.c"
int write_buf_to_disk(int fd , char *write_buf , int *buf_used ) 
{ ssize_t to_write ;
  ssize_t written ;
  ssize_t return_val ;
  int num_retries ;
  int tmp ;

  {
#line 130
  to_write = (*buf_used);
#line 131
  written = 0;
#line 133
  num_retries = 0;
#line 135
  while (written < to_write) {
#line 136
    tmp = num_retries;
#line 136
    num_retries ++;
#line 136
    if (tmp > to_write / 2) {
#line 137
      error((char *)"too many retries (%d) to write buf to disk : giving up.", num_retries);
#line 138
      return (-1);
    }
#line 140
    return_val = write(fd, (void const   *)(write_buf + written), (unsigned int )(to_write -
                                                                                  written));
#line 141
    if (return_val == -1) {
#line 142
      error_e((char *)"could not write() buf to disk");
#line 143
      return (-1);
    }
#line 145
    written += return_val;
  }
#line 149
  if (debug_opt) {
#line 149
    Debug((char *)"write_buf_to_disk() : written %d/%d, %d (re)try(ies)", written,
          to_write, num_retries);
  }
#line 153
  if (written == to_write) {
#line 154
    (*buf_used) = 0;
#line 155
    return (0);
  } else {
#line 158
    error((char *)"write_buf_to_disk() : written %d bytes for %d requested.", written,
          to_write);
#line 160
    return (-1);
  }
}
}
#line 202 "save.c"
int write_file_to_disk(int fd , struct cf_t *file , time_t time_date ) 
{ cl_t *line ;
  env_t *env ;
  char write_buf[1024] ;
  int write_buf_used ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;

  {
#line 206
  line = (cl_t *)((void *)0);
#line 207
  env = (env_t *)((void *)0);
#line 209
  write_buf_used = 0;
#line 216
  tmp = save_lint(fd, 1, 100L, write_buf, & write_buf_used);
#line 216
  if (tmp != 0) {
#line 216
    error_e((char *)"Could not write lint : file %s has not been saved.", file->cf_user);
#line 216
    return (-1);
  }
#line 220
  tmp___0 = save_str(fd, 2, file->cf_user, write_buf, & write_buf_used);
#line 220
  if (tmp___0 != 0) {
#line 220
    error_e((char *)"Could not write str : file %s has not been saved.", file->cf_user);
#line 220
    return (-1);
  }
#line 225
  tmp___1 = save_lint(fd, 3, time_date, write_buf, & write_buf_used);
#line 225
  if (tmp___1 != 0) {
#line 225
    error_e((char *)"Could not write lint : file %s has not been saved.", file->cf_user);
#line 225
    return (-1);
  }
#line 228
  if ((int )file->cf_tzdiff != 0) {
#line 229
    tmp___2 = save_lint(fd, 4, (long )file->cf_tzdiff, write_buf, & write_buf_used);
#line 229
    if (tmp___2 != 0) {
#line 229
      error_e((char *)"Could not write lint : file %s has not been saved.", file->cf_user);
#line 229
      return (-1);
    }
  }
#line 232
  env = file->cf_env_base;
#line 232
  while (env) {
#line 233
    tmp___3 = save_str(fd, 1000, env->e_val, write_buf, & write_buf_used);
#line 233
    if (tmp___3 != 0) {
#line 233
      error_e((char *)"Could not write str : file %s has not been saved.", file->cf_user);
#line 233
      return (-1);
    }
#line 232
    env = env->e_next;
  }
#line 236
  line = file->cf_line_base;
#line 236
  while (line) {
#line 239
    tmp___4 = save_str(fd, 2001, line->cl_shell, write_buf, & write_buf_used);
#line 239
    if (tmp___4 != 0) {
#line 239
      error_e((char *)"Could not write str : file %s has not been saved.", file->cf_user);
#line 239
      return (-1);
    }
#line 240
    tmp___5 = save_str(fd, 2006, line->cl_runas, write_buf, & write_buf_used);
#line 240
    if (tmp___5 != 0) {
#line 240
      error_e((char *)"Could not write str : file %s has not been saved.", file->cf_user);
#line 240
      return (-1);
    }
#line 241
    tmp___6 = save_str(fd, 2007, line->cl_mailto, write_buf, & write_buf_used);
#line 241
    if (tmp___6 != 0) {
#line 241
      error_e((char *)"Could not write str : file %s has not been saved.", file->cf_user);
#line 241
      return (-1);
    }
#line 242
    tmp___7 = save_strn(fd, 2017, (char *)(line->cl_option), 4, write_buf, & write_buf_used);
#line 242
    if (tmp___7 != 0) {
#line 242
      error_e((char *)"Could not write strn : file %s has not been saved.", file->cf_user);
#line 242
      return (-1);
    }
#line 246
    if ((int )line->cl_option[3] & 1) {
#line 246
      if ((int )line->cl_option[0] & 1) {
#line 247
        tmp___8 = save_lint(fd, 2018, line->cl_first, write_buf, & write_buf_used);
#line 247
        if (tmp___8 != 0) {
#line 247
          error_e((char *)"Could not write lint : file %s has not been saved.", file->cf_user);
#line 247
          return (-1);
        }
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 250
      tmp___9 = save_lint(fd, 2008, line->cl_nextexe, write_buf, & write_buf_used);
#line 250
      if (tmp___9 != 0) {
#line 250
        error_e((char *)"Could not write lint : file %s has not been saved.", file->cf_user);
#line 250
        return (-1);
      }
    }
#line 251
    if (line->cl_numexe) {
#line 252
      tmp___10 = save_strn(fd, 2002, (char *)(& line->cl_numexe), 1, write_buf, & write_buf_used);
#line 252
      if (tmp___10 != 0) {
#line 252
        error_e((char *)"Could not write strn : file %s has not been saved.", file->cf_user);
#line 252
        return (-1);
      }
    }
#line 253
    if ((int )line->cl_option[0] & 2) {
#line 254
      tmp___11 = save_strn(fd, 2003, (char *)(line->cl_lavg), 3, write_buf, & write_buf_used);
#line 254
      if (tmp___11 != 0) {
#line 254
        error_e((char *)"Could not write strn : file %s has not been saved.", file->cf_user);
#line 254
        return (-1);
      }
    }
#line 256
    if (line->cl_until > 0L) {
#line 257
      tmp___12 = save_lint(fd, 2004, line->cl_until, write_buf, & write_buf_used);
#line 257
      if (tmp___12 != 0) {
#line 257
        error_e((char *)"Could not write lint : file %s has not been saved.", file->cf_user);
#line 257
        return (-1);
      }
    }
#line 258
    if ((int )line->cl_nice != 0) {
#line 259
      tmp___13 = save_strn(fd, 2005, & line->cl_nice, 1, write_buf, & write_buf_used);
#line 259
      if (tmp___13 != 0) {
#line 259
        error_e((char *)"Could not write strn : file %s has not been saved.", file->cf_user);
#line 259
        return (-1);
      }
    }
#line 260
    if ((int )line->cl_runfreq > 0) {
#line 261
      tmp___14 = save_lint(fd, 2011, (long )line->cl_runfreq, write_buf, & write_buf_used);
#line 261
      if (tmp___14 != 0) {
#line 261
        error_e((char *)"Could not write lint : file %s has not been saved.", file->cf_user);
#line 261
        return (-1);
      }
#line 262
      tmp___15 = save_lint(fd, 2009, (long )line->cl_remain, write_buf, & write_buf_used);
#line 262
      if (tmp___15 != 0) {
#line 262
        error_e((char *)"Could not write lint : file %s has not been saved.", file->cf_user);
#line 262
        return (-1);
      }
    }
#line 265
    if ((int )line->cl_option[0] & 1) {
#line 267
      tmp___16 = save_lint(fd, 2010, line->cl_timefreq, write_buf, & write_buf_used);
#line 267
      if (tmp___16 != 0) {
#line 267
        error_e((char *)"Could not write lint : file %s has not been saved.", file->cf_user);
#line 267
        return (-1);
      }
    } else {
#line 271
      tmp___17 = save_strn(fd, 2012, (char *)(line->cl_mins), 8, write_buf, & write_buf_used);
#line 271
      if (tmp___17 != 0) {
#line 271
        error_e((char *)"Could not write strn : file %s has not been saved.", file->cf_user);
#line 271
        return (-1);
      }
#line 273
      tmp___18 = save_strn(fd, 2013, (char *)(line->cl_hrs), 3, write_buf, & write_buf_used);
#line 273
      if (tmp___18 != 0) {
#line 273
        error_e((char *)"Could not write strn : file %s has not been saved.", file->cf_user);
#line 273
        return (-1);
      }
#line 275
      tmp___19 = save_strn(fd, 2014, (char *)(line->cl_days), 4, write_buf, & write_buf_used);
#line 275
      if (tmp___19 != 0) {
#line 275
        error_e((char *)"Could not write strn : file %s has not been saved.", file->cf_user);
#line 275
        return (-1);
      }
#line 277
      tmp___20 = save_strn(fd, 2015, (char *)(line->cl_mons), 2, write_buf, & write_buf_used);
#line 277
      if (tmp___20 != 0) {
#line 277
        error_e((char *)"Could not write strn : file %s has not been saved.", file->cf_user);
#line 277
        return (-1);
      }
#line 279
      tmp___21 = save_strn(fd, 2016, (char *)(line->cl_dow), 1, write_buf, & write_buf_used);
#line 279
      if (tmp___21 != 0) {
#line 279
        error_e((char *)"Could not write strn : file %s has not been saved.", file->cf_user);
#line 279
        return (-1);
      }
    }
#line 284
    tmp___22 = save_type(fd, 2000, write_buf, & write_buf_used);
#line 284
    if (tmp___22 != 0) {
#line 284
      error_e((char *)"Could not write type : file %s has not been saved.", file->cf_user);
#line 284
      return (-1);
    }
#line 236
    line = line->cl_next;
  }
#line 287
  tmp___23 = write_buf_to_disk(fd, write_buf, & write_buf_used);
#line 287
  if (tmp___23 == -1) {
#line 288
    return (-1);
  }
#line 290
  return (0);
}
}
#line 294 "save.c"
int save_one_file(cf_t *file , char *filename , uid_t own_uid , gid_t own_gid , time_t save_date ) 
{ int fd ;
  int tmp ;
  int tmp___0 ;

  {
#line 308
  fd = open((char const   *)filename, 4673, 384);
#line 313
  if (fd == -1) {
#line 314
    error_e((char *)"Could not open %s", filename);
#line 315
    return (-1);
  }
#line 318
  tmp = fchown(fd, own_uid, own_gid);
#line 318
  if (tmp != 0) {
#line 319
    error_e((char *)"Could not fchown %s to uid:%d gid:%d", filename, own_uid, own_gid);
#line 320
    close(fd);
#line 321
    remove((char const   *)filename);
#line 322
    return (-1);
  }
#line 326
  tmp___0 = write_file_to_disk(fd, file, save_date);
#line 326
  if (tmp___0 == -1) {
#line 327
    close(fd);
#line 328
    remove((char const   *)filename);
#line 329
    return (-1);
  }
#line 332
  close(fd);
#line 334
  return (0);
}
}
#line 338 "save.c"
int save_file_safe(cf_t *file , char *final_path , char *prog_name___0 , uid_t own_uid ,
                   gid_t own_gid , time_t save_date ) 
{ char temp_path[516] ;
  int final_path_len ;
  int temp_path_index ;
  char *tmp_str ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 346
  tmp_str = (char *)".tmp";
#line 348
  final_path_len = (int )strlen((char const   *)final_path);
#line 349
  strncpy((char */* __restrict  */)(temp_path), (char const   */* __restrict  */)final_path,
          sizeof(temp_path) - sizeof(tmp_str));
#line 350
  if ((unsigned int )final_path_len > sizeof(temp_path) - sizeof(tmp_str)) {
#line 350
    temp_path_index = (int )(sizeof(temp_path) - sizeof(tmp_str));
  } else {
#line 350
    temp_path_index = final_path_len;
  }
#line 352
  strcpy((char */* __restrict  */)(& temp_path[temp_path_index]), (char const   */* __restrict  */)".tmp");
#line 354
  tmp___1 = save_one_file(file, temp_path, own_uid, own_gid, save_date);
#line 354
  if (tmp___1 == 0) {
#line 355
    tmp___0 = rename((char const   *)(temp_path), (char const   *)final_path);
#line 355
    if (tmp___0 != 0) {
#line 356
      error_e((char *)"Cannot rename %s to %s", temp_path, final_path);
#line 357
      error((char *)"%s will try to save the name to its definitive filename directly.",
            prog_name___0);
#line 359
      error((char *)"If there is an error, root may consider to replace %s (which is a valid copy) by %s manually.",
            final_path, temp_path);
#line 361
      tmp = save_one_file(file, final_path, own_uid, own_gid, save_date);
#line 361
      if (tmp == -1) {
#line 362
        return (-1);
      }
    }
  } else {
#line 366
    error((char *)"Since %s has not been able to save %s\'s file, it will keep the previous version (if any) of %s.",
          prog_name___0, final_path, final_path);
#line 368
    return (-1);
  }
#line 371
  return (0);
}
}
#line 1 "temp_file.o"
/* #pragma merger(0,"./temp_file.i","-O2 -Wall") */
#line 123 "/users/rupak/ccured/include/ccuredannot.h"
/* #pragma cilnoremove("__ccuredInit") */
#line 20 "/users/rupak/ccured/include/ccured.h"
/* #pragma cilnoremove("wrapperAlloc") */
#line 21
/* #pragma ccuredalloc("wrapperAlloc",sizein(1),nozero) */
#line 24
/* #pragma cilnoremove("wrapperFree") */
#line 25
/* #pragma ccuredpoly("wrapperFree") */
#line 29
/* #pragma cilnoremove("wrapperStrdup") */
#line 30
/* #pragma ccuredpoly("wrapperStrdup") */
#line 50
/* #pragma ccuredpoly("__ptrof_nocheck") */
#line 51
/* #pragma cilnoremove("__ptrof_nocheck") */
#line 57
/* #pragma ccuredpoly("__startof") */
#line 63
/* #pragma ccuredpoly("__endof") */
#line 78
/* #pragma ccuredpoly("__ptrof") */
#line 84
/* #pragma ccuredpoly("__ptrof_size") */
#line 85
/* #pragma cilnoremove("__ptrof_size") */
#line 92
/* #pragma ccuredpoly("__verify_nul") */
#line 101
/* #pragma ccuredpoly("__strlen") */
#line 111
/* #pragma ccuredpoly("__strlen_n") */
#line 125
/* #pragma ccuredpoly("__stringof") */
#line 127
/* #pragma cilnoremove("__stringof") */
#line 136
/* #pragma ccuredpoly("__stringof_ornull") */
#line 138
/* #pragma cilnoremove("__stringof_ornull") */
#line 147
/* #pragma ccuredpoly("__write_at_least") */
#line 155
/* #pragma ccuredpoly("__read_at_least") */
#line 162
/* #pragma ccuredpoly("__copytags") */
#line 180
/* #pragma ccuredpoly("__mkptr") */
#line 181
/* #pragma cilnoremove("__mkptr") */
#line 188
/* #pragma ccuredpoly("__mkptr_int") */
#line 196
/* #pragma ccuredpoly("__mkptr_size") */
#line 197
/* #pragma cilnoremove("__mkptr_size") */
#line 206
/* #pragma ccuredpoly("__mkptr_string") */
#line 207
/* #pragma cilnoremove("__mkptr_string") */
#line 215
/* #pragma ccuredpoly("__align_seq") */
#line 216
/* #pragma cilnoremove("__align_seq") */
#line 227
/* #pragma ccuredpoly("__trusted_cast") */
#line 228
/* #pragma cilnoremove("__trusted_cast") */
#line 237
/* #pragma ccuredpoly("__trusted_deepcast") */
#line 238
/* #pragma cilnoremove("__trusted_deepcast") */
#line 250
/* #pragma ccuredpoly("ccured_hasuniontag") */
#line 259
/* #pragma ccuredpoly("__ccured_kind_of") */
#line 307
/* #pragma ccuredpoly("__ccured_mangling_of") */
#line 308
/* #pragma cilnoremove("__ccured_mangling_of") */
#line 312
/* #pragma ccuredpoly("__ccured_has_empty_mangling") */
#line 313
/* #pragma cilnoremove("__ccured_has_empty_mangling") */
#line 327
/* #pragma cilnoremove("abort_deepcopy") */
#line 451
/* #pragma cilnoremove("struct printf_arguments") */
#line 45 "/users/rupak/ccured/include/time_wrappers.h"
/* #pragma ccuredwrapper("time_wrapper",of("time")) */
#line 59
/* #pragma ccuredwrapper("ctime_wrapper",of("ctime")) */
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments )) */
#line 266
/* #pragma ccuredpoly("__ccured_va_arg") */
#line 303
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___0 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___0 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___0 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___0 )) */
#line 69 "/users/rupak/ccured/include/io_wrappers.h"
/* #pragma ccuredwrapper("unlink_wrapper",of("unlink")) */
#line 79
/* #pragma ccuredwrapper("open_wrapper",of("open")) */
#line 80
/* #pragma ccuredvararg("open_wrapper",sizeof(int )) */
#line 123
/* #pragma ccuredwrapper("rename_wrapper",of("rename")) */
#line 6 "/users/rupak/ccured/include/malloc_wrappers.h"
/* #pragma ccuredalloc("malloc",nozero,sizein(1)) */
#line 8
/* #pragma ccuredpoly("realloc") */
#line 9
/* #pragma ccuredwrapper("realloc_wrapper",of("realloc")) */
#line 22
/* #pragma ccuredwrapper("free_wrapper",of("free")) */
#line 27
/* #pragma ccuredalloc("alloca",nozero,sizein(1)) */
#line 28
/* #pragma ccuredalloc("calloc",zero,sizemul(1,2)) */
#line 46 "/users/rupak/ccured/include/string_wrappers.h"
/* #pragma ccuredwrapper("strlen_wrapper",of("strlen")) */
#line 52
/* #pragma ccuredwrapper("bzero_wrapper",of("bzero")) */
#line 61
/* #pragma ccuredwrapper("strcpy_wrapper",of("strcpy")) */
#line 81
/* #pragma ccuredwrapper("strncpy_wrapper",of("strncpy")) */
#line 95
/* #pragma ccuredwrapper("strcat_wrapper",of("strcat")) */
#line 111
/* #pragma ccuredwrapper("strncat_wrapper",of("strncat")) */
#line 128
/* #pragma ccuredwrapper("strchr_wrapper",of("strchr")) */
#line 137
/* #pragma ccuredwrapper("strrchr_wrapper",of("strrchr")) */
#line 146
/* #pragma ccuredwrapper("strdup_wrapper",of("strdup")) */
#line 167
/* #pragma ccuredwrapper("strcasecmp_wrapper",of("strcasecmp")) */
#line 173
/* #pragma ccuredwrapper("strcmp_wrapper",of("strcmp")) */
#line 180
/* #pragma ccuredwrapper("strncasecmp_wrapper",of("strncasecmp")) */
#line 194
/* #pragma ccuredwrapper("strncmp_wrapper",of("strncmp")) */
#line 208
/* #pragma ccuredwrapper("strpbrk_wrapper",of("strpbrk")) */
#line 217
/* #pragma ccuredwrapper("strsep_wrapper",of("strsep")) */
#line 234
/* #pragma ccuredwrapper("strtoul_wrapper",of("strtoul")) */
#line 47 "/users/rupak/ccured/include/stdlib_wrappers.h"
/* #pragma ccuredwrapper("atof_wrapper",of("atof")) */
#line 55
/* #pragma ccuredwrapper("atoi_wrapper",of("atoi")) */
#line 63
/* #pragma ccuredwrapper("atol_wrapper",of("atol")) */
#line 93
/* #pragma ccuredpoly("qsort_zero_tags") */
#line 172
/* #pragma ccuredwrapper("qsort_wrapper",of("qsort")) */
#line 216
/* #pragma ccuredwrapper("bsearch_wrapper",of("bsearch")) */
#line 254
/* #pragma ccuredwrapper("strtol_wrapper",of("strtol")) */
#line 270
/* #pragma ccuredwrapper("getenv_wrapper",of("getenv")) */
#line 256 "/users/rupak/ccured/include/string_wrappers.h"
/* #pragma ccuredwrapper("strtok_wrapper",of("strtok")) */
#line 269
/* #pragma ccuredwrapper("strtok_r_wrapper",of("strtok_r")) */
#line 319
/* #pragma ccuredwrapper("memcmp_wrapper",of("memcmp")) */
#line 332
/* #pragma ccuredwrapper("memset_wrapper",of("memset")) */
#line 341
/* #pragma ccuredwrapper("memmove_wrapper",of("memmove")) */
#line 353
/* #pragma ccuredwrapper("memcpy_wrapper",of("memcpy")) */
#line 366
/* #pragma ccuredwrapper("strerror_wrapper",of("strerror")) */
#line 374
/* #pragma ccuredwrapper("strstr_wrapper",of("strstr")) */
#line 383
/* #pragma ccuredwrapper("memchr_wrapper",of("memchr")) */
#line 50 "/users/rupak/ccured/include/pwd_wrappers.h"
/* #pragma ccuredwrapper("getpwnam_wrapper",of("getpwnam")) */
#line 68
/* #pragma ccuredwrapper("getpwuid_wrapper",of("getpwuid")) */
#line 81
/* #pragma ccuredwrapper("getpwent_wrapper",of("getpwent")) */
#line 56 "/users/rupak/ccured/include/signal_wrappers.h"
/* #pragma ccuredpoly("__mkfat_sighandler") */
#line 66
/* #pragma ccuredwrapper("signal_wrapper",of("signal")) */
#line 88
/* #pragma ccuredwrapper("sigaction_wrapper",of("sigaction")) */
#line 168 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredpoly("get_stdin") */
#line 170
/* #pragma ccuredpoly("get_stdout") */
#line 172
/* #pragma ccuredpoly("get_stderr") */
#line 59 "/users/rupak/ccured/include/stdio_wrappers.h"
/* #pragma ccuredpoly("__mkptr_file") */
#line 65
/* #pragma ccuredpoly("__ptrof_file") */
#line 68
/* #pragma ccuredvararg("printf",printf(1)) */
#line 69
/* #pragma ccuredvararg("fprintf",printf(2)) */
#line 70
/* #pragma ccuredvararg("snprintf",printf(3)) */
#line 71
/* #pragma ccuredvararg("syslog",printf(2)) */
#line 72
/* #pragma ccuredvararg("sprintf",printf(2)) */
#line 73
/* #pragma ccuredvararg("vsprintf",printf(2)) */
#line 74
/* #pragma ccuredvararg("vfprintf",printf(2)) */
#line 75
/* #pragma ccuredvararg("vprintf",printf(1)) */
#line 76
/* #pragma ccuredvararg("vsyslog",printf(2)) */
#line 78
/* #pragma ccuredpoly("__endof") */
#line 89
/* #pragma ccuredpoly("ccured_fscanf_string") */
#line 92
/* #pragma ccuredwrapper("ccured_fscanf_string_wrapper",of("ccured_fscanf_string")) */
#line 117
/* #pragma ccuredvararg("sscanf",sizeof(struct scanf_format )) */
#line 118
/* #pragma ccuredvararg("fscanf",sizeof(struct scanf_format )) */
#line 123
/* #pragma ccuredwrapper("fgets_wrapper",of("fgets")) */
#line 132
/* #pragma ccuredwrapper("fopen_wrapper",of("fopen")) */
#line 139
/* #pragma ccuredwrapper("fdopen_wrapper",of("fdopen")) */
#line 146
/* #pragma ccuredwrapper("fflush_wrapper",of("fflush")) */
#line 152
/* #pragma ccuredwrapper("fclose_wrapper",of("fclose")) */
#line 179
/* #pragma ccuredwrapper("_IO_putc_wrapper",of("_IO_putc")) */
#line 185
/* #pragma ccuredwrapper("_IO_getc_wrapper",of("_IO_getc")) */
#line 210
/* #pragma ccuredwrapper("fputc_wrapper",of("fputc")) */
#line 216
/* #pragma ccuredwrapper("fputs_wrapper",of("fputs")) */
#line 222
/* #pragma ccuredwrapper("fgetc_wrapper",of("fgetc")) */
#line 228
/* #pragma ccuredwrapper("puts_wrapper",of("puts")) */
#line 234
/* #pragma ccuredwrapper("fileno_wrapper",of("fileno")) */
#line 240
/* #pragma ccuredwrapper("ferror_wrapper",of("ferror")) */
#line 246
/* #pragma ccuredwrapper("fseek_wrapper",of("fseek")) */
#line 253
/* #pragma ccuredwrapper("clearerr_wrapper",of("clearerr")) */
#line 264
/* #pragma ccuredwrapper("fread_wrapper",of("fread")) */
#line 275
/* #pragma ccuredwrapper("fwrite_wrapper",of("fwrite")) */
#line 288
/* #pragma ccuredwrapper("gets_wrapper",of("gets")) */
#line 314
/* #pragma ccuredvararg("vsnprintf_wrapper",printf(3)) */
#line 315
/* #pragma ccuredwrapper("vsnprintf_wrapper",of("vsnprintf")) */
#line 322
/* #pragma ccuredvararg("vsprintf_wrapper",printf(2)) */
#line 323
/* #pragma ccuredwrapper("vsprintf_wrapper",of("vsprintf")) */
#line 330
/* #pragma ccuredvararg("snprintf_wrapper",printf(3)) */
#line 331
/* #pragma ccuredwrapper("snprintf_wrapper",of("snprintf")) */
#line 343
/* #pragma ccuredvararg("sprintf_wrapper",printf(2)) */
#line 344
/* #pragma ccuredwrapper("sprintf_wrapper",of("sprintf")) */
#line 366
/* #pragma ccuredpoly("ccured_fscanf_double") */
#line 382
/* #pragma ccuredpoly("ccured_fscanf_int") */
#line 398
/* #pragma ccuredpoly("ccured_fscanf_nothing") */
#line 467
/* #pragma ccuredwrapper("perror_wrapper",of("perror")) */
#line 49 "/users/rupak/ccured/include/stat_wrappers.h"
/* #pragma ccuredwrapper("fstat_wrapper",of("fstat")) */
#line 57
/* #pragma ccuredwrapper("stat_wrapper",of("stat")) */
#line 68
/* #pragma ccuredwrapper("__xstat_wrapper",of("__xstat")) */
#line 79 "/users/rupak/ccured/include/time_wrappers.h"
/* #pragma ccuredwrapper("asctime_wrapper",of("asctime")) */
#line 13 "/users/rupak/ccured/include/functions/deepcopy_stringarray.h"
/* #pragma cilnoremove("__deepcopy_stringarray_from_compat") */
#line 14
/* #pragma ccuredpoly("__deepcopy_stringarray_from_compat") */
#line 53
/* #pragma ccuredpoly("__deepcopy_stringarray_to_compat") */
#line 44 "/users/rupak/ccured/include/unistd_wrappers.h"
/* #pragma ccuredwrapper("execv_wrapper",of("execv")) */
#line 66
/* #pragma ccuredwrapper("execvp_wrapper",of("execvp")) */
#line 86
/* #pragma ccuredwrapper("execve_wrapper",of("execve")) */
#line 106
/* #pragma ccuredvararg("execl",sizeof(struct __ccured_execl_arguments )) */
#line 107
/* #pragma ccuredvararg("execlp",sizeof(struct __ccured_execl_arguments )) */
#line 108
/* #pragma ccuredvararg("execle",sizeof(struct __ccured_execl_arguments )) */
#line 110
/* #pragma ccuredwrapper("getlogin_wrapper",of("getlogin")) */
#line 117
/* #pragma ccuredwrapper("ttyname_wrapper",of("ttyname")) */
#line 129
/* #pragma ccuredwrapper("getopt_wrapper",of("getopt")) */
#line 174
/* #pragma ccuredwrapper("read_wrapper",of("read")) */
#line 182
/* #pragma ccuredwrapper("write_wrapper",of("write")) */
#line 195
/* #pragma ccuredwrapper("getusershell_wrapper",of("getusershell")) */
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___1 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___1 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___1 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___1 )) */
#line 303
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___2 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___2 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___2 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___2 )) */
#line 34 "temp_file.c"
int temp_file(char **name ) 
{ int fd ;
  char name_local[512] ;
  int tmp ;
  int tmp___0 ;

  {
#line 40
  name_local[0] = (char )'\000';
#line 41
  strncpy((char */* __restrict  */)(name_local), (char const   */* __restrict  */)tmp_path,
          sizeof(name_local) - 1U);
#line 42
  name_local[sizeof(name_local) - 1U] = (char )'\000';
#line 43
  strcat((char */* __restrict  */)(name_local), (char const   */* __restrict  */)"fcr-XXXXXX");
#line 44
  fd = mkstemp(name_local);
#line 44
  if (fd == -1) {
#line 45
    die_e((char *)"Can\'t find a unique temporary filename");
  }
#line 48
  tmp = fchmod(fd, 384U);
#line 48
  if (tmp != 0) {
#line 49
    die_e((char *)"Can\'t fchmod temp file");
  }
#line 67
  if ((unsigned int )name == (unsigned int )((void *)0)) {
#line 67
    tmp___0 = unlink((char const   *)(name_local));
#line 67
    if (tmp___0 != 0) {
#line 68
      die_e((char *)"Can\'t unlink temporary file %s", name_local);
    }
  }
#line 70
  fcntl(fd, 2, 1);
#line 73
  if ((unsigned int )name != (unsigned int )((void *)0)) {
#line 74
    (*name) = strdup2((char const   *)(name_local));
  }
#line 79
  return (fd);
}
}
#line 1 "log.o"
/* #pragma merger(0,"./log.i","-O2 -Wall") */
#line 123 "/users/rupak/ccured/include/ccuredannot.h"
/* #pragma cilnoremove("__ccuredInit") */
#line 20 "/users/rupak/ccured/include/ccured.h"
/* #pragma cilnoremove("wrapperAlloc") */
#line 21
/* #pragma ccuredalloc("wrapperAlloc",sizein(1),nozero) */
#line 24
/* #pragma cilnoremove("wrapperFree") */
#line 25
/* #pragma ccuredpoly("wrapperFree") */
#line 29
/* #pragma cilnoremove("wrapperStrdup") */
#line 30
/* #pragma ccuredpoly("wrapperStrdup") */
#line 50
/* #pragma ccuredpoly("__ptrof_nocheck") */
#line 51
/* #pragma cilnoremove("__ptrof_nocheck") */
#line 57
/* #pragma ccuredpoly("__startof") */
#line 63
/* #pragma ccuredpoly("__endof") */
#line 78
/* #pragma ccuredpoly("__ptrof") */
#line 84
/* #pragma ccuredpoly("__ptrof_size") */
#line 85
/* #pragma cilnoremove("__ptrof_size") */
#line 92
/* #pragma ccuredpoly("__verify_nul") */
#line 101
/* #pragma ccuredpoly("__strlen") */
#line 111
/* #pragma ccuredpoly("__strlen_n") */
#line 125
/* #pragma ccuredpoly("__stringof") */
#line 127
/* #pragma cilnoremove("__stringof") */
#line 136
/* #pragma ccuredpoly("__stringof_ornull") */
#line 138
/* #pragma cilnoremove("__stringof_ornull") */
#line 147
/* #pragma ccuredpoly("__write_at_least") */
#line 155
/* #pragma ccuredpoly("__read_at_least") */
#line 162
/* #pragma ccuredpoly("__copytags") */
#line 180
/* #pragma ccuredpoly("__mkptr") */
#line 181
/* #pragma cilnoremove("__mkptr") */
#line 188
/* #pragma ccuredpoly("__mkptr_int") */
#line 196
/* #pragma ccuredpoly("__mkptr_size") */
#line 197
/* #pragma cilnoremove("__mkptr_size") */
#line 206
/* #pragma ccuredpoly("__mkptr_string") */
#line 207
/* #pragma cilnoremove("__mkptr_string") */
#line 215
/* #pragma ccuredpoly("__align_seq") */
#line 216
/* #pragma cilnoremove("__align_seq") */
#line 227
/* #pragma ccuredpoly("__trusted_cast") */
#line 228
/* #pragma cilnoremove("__trusted_cast") */
#line 237
/* #pragma ccuredpoly("__trusted_deepcast") */
#line 238
/* #pragma cilnoremove("__trusted_deepcast") */
#line 250
/* #pragma ccuredpoly("ccured_hasuniontag") */
#line 259
/* #pragma ccuredpoly("__ccured_kind_of") */
#line 307
/* #pragma ccuredpoly("__ccured_mangling_of") */
#line 308
/* #pragma cilnoremove("__ccured_mangling_of") */
#line 312
/* #pragma ccuredpoly("__ccured_has_empty_mangling") */
#line 313
/* #pragma cilnoremove("__ccured_has_empty_mangling") */
#line 327
/* #pragma cilnoremove("abort_deepcopy") */
#line 451
/* #pragma cilnoremove("struct printf_arguments") */
#line 45 "/users/rupak/ccured/include/time_wrappers.h"
/* #pragma ccuredwrapper("time_wrapper",of("time")) */
#line 59
/* #pragma ccuredwrapper("ctime_wrapper",of("ctime")) */
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments )) */
#line 266
/* #pragma ccuredpoly("__ccured_va_arg") */
#line 303
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___0 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___0 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___0 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___0 )) */
#line 69 "/users/rupak/ccured/include/io_wrappers.h"
/* #pragma ccuredwrapper("unlink_wrapper",of("unlink")) */
#line 79
/* #pragma ccuredwrapper("open_wrapper",of("open")) */
#line 80
/* #pragma ccuredvararg("open_wrapper",sizeof(int )) */
#line 123
/* #pragma ccuredwrapper("rename_wrapper",of("rename")) */
#line 6 "/users/rupak/ccured/include/malloc_wrappers.h"
/* #pragma ccuredalloc("malloc",nozero,sizein(1)) */
#line 8
/* #pragma ccuredpoly("realloc") */
#line 9
/* #pragma ccuredwrapper("realloc_wrapper",of("realloc")) */
#line 22
/* #pragma ccuredwrapper("free_wrapper",of("free")) */
#line 27
/* #pragma ccuredalloc("alloca",nozero,sizein(1)) */
#line 28
/* #pragma ccuredalloc("calloc",zero,sizemul(1,2)) */
#line 46 "/users/rupak/ccured/include/string_wrappers.h"
/* #pragma ccuredwrapper("strlen_wrapper",of("strlen")) */
#line 52
/* #pragma ccuredwrapper("bzero_wrapper",of("bzero")) */
#line 61
/* #pragma ccuredwrapper("strcpy_wrapper",of("strcpy")) */
#line 81
/* #pragma ccuredwrapper("strncpy_wrapper",of("strncpy")) */
#line 95
/* #pragma ccuredwrapper("strcat_wrapper",of("strcat")) */
#line 111
/* #pragma ccuredwrapper("strncat_wrapper",of("strncat")) */
#line 128
/* #pragma ccuredwrapper("strchr_wrapper",of("strchr")) */
#line 137
/* #pragma ccuredwrapper("strrchr_wrapper",of("strrchr")) */
#line 146
/* #pragma ccuredwrapper("strdup_wrapper",of("strdup")) */
#line 167
/* #pragma ccuredwrapper("strcasecmp_wrapper",of("strcasecmp")) */
#line 173
/* #pragma ccuredwrapper("strcmp_wrapper",of("strcmp")) */
#line 180
/* #pragma ccuredwrapper("strncasecmp_wrapper",of("strncasecmp")) */
#line 194
/* #pragma ccuredwrapper("strncmp_wrapper",of("strncmp")) */
#line 208
/* #pragma ccuredwrapper("strpbrk_wrapper",of("strpbrk")) */
#line 217
/* #pragma ccuredwrapper("strsep_wrapper",of("strsep")) */
#line 234
/* #pragma ccuredwrapper("strtoul_wrapper",of("strtoul")) */
#line 47 "/users/rupak/ccured/include/stdlib_wrappers.h"
/* #pragma ccuredwrapper("atof_wrapper",of("atof")) */
#line 55
/* #pragma ccuredwrapper("atoi_wrapper",of("atoi")) */
#line 63
/* #pragma ccuredwrapper("atol_wrapper",of("atol")) */
#line 93
/* #pragma ccuredpoly("qsort_zero_tags") */
#line 172
/* #pragma ccuredwrapper("qsort_wrapper",of("qsort")) */
#line 216
/* #pragma ccuredwrapper("bsearch_wrapper",of("bsearch")) */
#line 254
/* #pragma ccuredwrapper("strtol_wrapper",of("strtol")) */
#line 270
/* #pragma ccuredwrapper("getenv_wrapper",of("getenv")) */
#line 256 "/users/rupak/ccured/include/string_wrappers.h"
/* #pragma ccuredwrapper("strtok_wrapper",of("strtok")) */
#line 269
/* #pragma ccuredwrapper("strtok_r_wrapper",of("strtok_r")) */
#line 319
/* #pragma ccuredwrapper("memcmp_wrapper",of("memcmp")) */
#line 332
/* #pragma ccuredwrapper("memset_wrapper",of("memset")) */
#line 341
/* #pragma ccuredwrapper("memmove_wrapper",of("memmove")) */
#line 353
/* #pragma ccuredwrapper("memcpy_wrapper",of("memcpy")) */
#line 366
/* #pragma ccuredwrapper("strerror_wrapper",of("strerror")) */
#line 374
/* #pragma ccuredwrapper("strstr_wrapper",of("strstr")) */
#line 383
/* #pragma ccuredwrapper("memchr_wrapper",of("memchr")) */
#line 50 "/users/rupak/ccured/include/pwd_wrappers.h"
/* #pragma ccuredwrapper("getpwnam_wrapper",of("getpwnam")) */
#line 68
/* #pragma ccuredwrapper("getpwuid_wrapper",of("getpwuid")) */
#line 81
/* #pragma ccuredwrapper("getpwent_wrapper",of("getpwent")) */
#line 56 "/users/rupak/ccured/include/signal_wrappers.h"
/* #pragma ccuredpoly("__mkfat_sighandler") */
#line 66
/* #pragma ccuredwrapper("signal_wrapper",of("signal")) */
#line 88
/* #pragma ccuredwrapper("sigaction_wrapper",of("sigaction")) */
#line 168 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredpoly("get_stdin") */
#line 170
/* #pragma ccuredpoly("get_stdout") */
#line 172
/* #pragma ccuredpoly("get_stderr") */
#line 59 "/users/rupak/ccured/include/stdio_wrappers.h"
/* #pragma ccuredpoly("__mkptr_file") */
#line 65
/* #pragma ccuredpoly("__ptrof_file") */
#line 68
/* #pragma ccuredvararg("printf",printf(1)) */
#line 69
/* #pragma ccuredvararg("fprintf",printf(2)) */
#line 70
/* #pragma ccuredvararg("snprintf",printf(3)) */
#line 71
/* #pragma ccuredvararg("syslog",printf(2)) */
#line 72
/* #pragma ccuredvararg("sprintf",printf(2)) */
#line 73
/* #pragma ccuredvararg("vsprintf",printf(2)) */
#line 74
/* #pragma ccuredvararg("vfprintf",printf(2)) */
#line 75
/* #pragma ccuredvararg("vprintf",printf(1)) */
#line 76
/* #pragma ccuredvararg("vsyslog",printf(2)) */
#line 78
/* #pragma ccuredpoly("__endof") */
#line 89
/* #pragma ccuredpoly("ccured_fscanf_string") */
#line 92
/* #pragma ccuredwrapper("ccured_fscanf_string_wrapper",of("ccured_fscanf_string")) */
#line 117
/* #pragma ccuredvararg("sscanf",sizeof(struct scanf_format )) */
#line 118
/* #pragma ccuredvararg("fscanf",sizeof(struct scanf_format )) */
#line 123
/* #pragma ccuredwrapper("fgets_wrapper",of("fgets")) */
#line 132
/* #pragma ccuredwrapper("fopen_wrapper",of("fopen")) */
#line 139
/* #pragma ccuredwrapper("fdopen_wrapper",of("fdopen")) */
#line 146
/* #pragma ccuredwrapper("fflush_wrapper",of("fflush")) */
#line 152
/* #pragma ccuredwrapper("fclose_wrapper",of("fclose")) */
#line 179
/* #pragma ccuredwrapper("_IO_putc_wrapper",of("_IO_putc")) */
#line 185
/* #pragma ccuredwrapper("_IO_getc_wrapper",of("_IO_getc")) */
#line 210
/* #pragma ccuredwrapper("fputc_wrapper",of("fputc")) */
#line 216
/* #pragma ccuredwrapper("fputs_wrapper",of("fputs")) */
#line 222
/* #pragma ccuredwrapper("fgetc_wrapper",of("fgetc")) */
#line 228
/* #pragma ccuredwrapper("puts_wrapper",of("puts")) */
#line 234
/* #pragma ccuredwrapper("fileno_wrapper",of("fileno")) */
#line 240
/* #pragma ccuredwrapper("ferror_wrapper",of("ferror")) */
#line 246
/* #pragma ccuredwrapper("fseek_wrapper",of("fseek")) */
#line 253
/* #pragma ccuredwrapper("clearerr_wrapper",of("clearerr")) */
#line 264
/* #pragma ccuredwrapper("fread_wrapper",of("fread")) */
#line 275
/* #pragma ccuredwrapper("fwrite_wrapper",of("fwrite")) */
#line 288
/* #pragma ccuredwrapper("gets_wrapper",of("gets")) */
#line 314
/* #pragma ccuredvararg("vsnprintf_wrapper",printf(3)) */
#line 315
/* #pragma ccuredwrapper("vsnprintf_wrapper",of("vsnprintf")) */
#line 322
/* #pragma ccuredvararg("vsprintf_wrapper",printf(2)) */
#line 323
/* #pragma ccuredwrapper("vsprintf_wrapper",of("vsprintf")) */
#line 330
/* #pragma ccuredvararg("snprintf_wrapper",printf(3)) */
#line 331
/* #pragma ccuredwrapper("snprintf_wrapper",of("snprintf")) */
#line 343
/* #pragma ccuredvararg("sprintf_wrapper",printf(2)) */
#line 344
/* #pragma ccuredwrapper("sprintf_wrapper",of("sprintf")) */
#line 366
/* #pragma ccuredpoly("ccured_fscanf_double") */
#line 382
/* #pragma ccuredpoly("ccured_fscanf_int") */
#line 398
/* #pragma ccuredpoly("ccured_fscanf_nothing") */
#line 467
/* #pragma ccuredwrapper("perror_wrapper",of("perror")) */
#line 49 "/users/rupak/ccured/include/stat_wrappers.h"
/* #pragma ccuredwrapper("fstat_wrapper",of("fstat")) */
#line 57
/* #pragma ccuredwrapper("stat_wrapper",of("stat")) */
#line 68
/* #pragma ccuredwrapper("__xstat_wrapper",of("__xstat")) */
#line 79 "/users/rupak/ccured/include/time_wrappers.h"
/* #pragma ccuredwrapper("asctime_wrapper",of("asctime")) */
#line 13 "/users/rupak/ccured/include/functions/deepcopy_stringarray.h"
/* #pragma cilnoremove("__deepcopy_stringarray_from_compat") */
#line 14
/* #pragma ccuredpoly("__deepcopy_stringarray_from_compat") */
#line 53
/* #pragma ccuredpoly("__deepcopy_stringarray_to_compat") */
#line 44 "/users/rupak/ccured/include/unistd_wrappers.h"
/* #pragma ccuredwrapper("execv_wrapper",of("execv")) */
#line 66
/* #pragma ccuredwrapper("execvp_wrapper",of("execvp")) */
#line 86
/* #pragma ccuredwrapper("execve_wrapper",of("execve")) */
#line 106
/* #pragma ccuredvararg("execl",sizeof(struct __ccured_execl_arguments )) */
#line 107
/* #pragma ccuredvararg("execlp",sizeof(struct __ccured_execl_arguments )) */
#line 108
/* #pragma ccuredvararg("execle",sizeof(struct __ccured_execl_arguments )) */
#line 110
/* #pragma ccuredwrapper("getlogin_wrapper",of("getlogin")) */
#line 117
/* #pragma ccuredwrapper("ttyname_wrapper",of("ttyname")) */
#line 129
/* #pragma ccuredwrapper("getopt_wrapper",of("getopt")) */
#line 174
/* #pragma ccuredwrapper("read_wrapper",of("read")) */
#line 182
/* #pragma ccuredwrapper("write_wrapper",of("write")) */
#line 195
/* #pragma ccuredwrapper("getusershell_wrapper",of("getusershell")) */
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___1 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___1 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___1 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___1 )) */
#line 303
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___2 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___2 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___2 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___2 )) */
#line 43 "/users/rupak/ccured/include/crypt_wrappers.h"
/* #pragma ccuredwrapper("crypt_wrapper",of("crypt")) */
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___3 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___3 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___3 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___3 )) */
#line 23 "/users/rupak/ccured/include/grp_wrappers.h"
/* #pragma ccuredwrapper("getgrnam_wrapper",of("getgrnam")) */
#line 45
/* #pragma ccuredwrapper("getgrgid_wrapper",of("getgrgid")) */
#line 59
/* #pragma ccuredwrapper("getgrent_wrapper",of("getgrent")) */
#line 443 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("ioctl",sizeof(struct ioctl_format )) */
#line 62 "/users/rupak/ccured/include/uio_wrappers.h"
/* #pragma ccuredwrapper("readv_wrapper",of("readv")) */
#line 79
/* #pragma ccuredwrapper("writev_wrapper",of("writev")) */
#line 49 "/users/rupak/ccured/include/socket_wrappers.h"
/* #pragma ccuredwrapper("setsockopt_wrapper",of("setsockopt")) */
#line 57
/* #pragma ccuredwrapper("getsockopt_wrapper",of("getsockopt")) */
#line 66
/* #pragma ccuredwrapper("bind_wrapper",of("bind")) */
#line 75
/* #pragma ccuredwrapper("connect_wrapper",of("connect")) */
#line 84
/* #pragma ccuredwrapper("accept_wrapper",of("accept")) */
#line 110
/* #pragma ccuredwrapper("getpeername_wrapper",of("getpeername")) */
#line 127
/* #pragma ccuredwrapper("getsockname_wrapper",of("getsockname")) */
#line 149
/* #pragma ccuredwrapper("sendto_wrapper",of("sendto")) */
#line 161
/* #pragma ccuredwrapper("select_wrapper",of("select")) */
#line 176
/* #pragma ccuredwrapper("recvfrom_wrapper",of("recvfrom")) */
#line 186
/* #pragma ccuredwrapper("recv_wrapper",of("recv")) */
#line 195
/* #pragma ccuredwrapper("send_wrapper",of("send")) */
#line 252
/* #pragma ccuredwrapper("sendmsg_wrapper",of("sendmsg")) */
#line 264
/* #pragma ccuredwrapper("recvmsg_wrapper",of("recvmsg")) */
#line 38 "log.c"
static void xopenlog(void) ;
#line 39
char *make_msg(char const   *append , char *fmt , __ccured_va_list args ) ;
#line 40
void log_syslog_str(int priority , char *msg ) ;
#line 41
void log_console_str(char *msg ) ;
#line 42
void log_fd_str(int fd , char *msg ) ;
#line 43
static void log_syslog(int priority , int fd , char *fmt , __ccured_va_list args ) ;
#line 44
static void log_e(int priority , char *fmt , __ccured_va_list args ) ;
#line 46
static void log_pame(int priority , pam_handle_t *pamh___0 , int pamerrno , char *fmt ,
                     __ccured_va_list args ) ;
#line 50 "log.c"
static char truncated[13]  = 
#line 50
  {      (char )' ',      (char )'(',      (char )'t',      (char )'r', 
        (char )'u',      (char )'n',      (char )'c',      (char )'a', 
        (char )'t',      (char )'e',      (char )'d',      (char )')', 
        (char )'\000'};
#line 51 "log.c"
static int log_open  =    0;
#line 54 "log.c"
static void xopenlog(void) 
{ 

  {
#line 57
  if (! log_open) {
#line 58
    openlog((char const   *)prog_name, 1, 72);
#line 59
    log_open = 1;
  }
#line 61
  return;
}
}
#line 64 "log.c"
void xcloselog(void) 
{ 

  {
#line 67
  if (log_open) {
#line 67
    closelog();
  }
#line 68
  log_open = 0;
#line 69
  return;
}
}
#line 73 "log.c"
char *make_msg(char const   *append , char *fmt , __ccured_va_list args ) 
{ int len ;
  char *msg ;
  size_t tmp ;

  {
#line 77
  msg = (char *)((void *)0);
#line 79
  msg = (char *)calloc(1U, 176U);
#line 79
  if ((unsigned int )msg == (unsigned int )((void *)0)) {
#line 80
    return ((char *)((void *)0));
  }
#line 83
  len = vsnprintf((char */* __restrict  */)msg, 176U, (char const   */* __restrict  */)fmt,
                  args);
#line 84
  if ((unsigned int )append != (unsigned int )((void *)0)) {
#line 85
    strncat((char */* __restrict  */)msg, (char const   */* __restrict  */)": ", (unsigned int )(175 -
                                                                                                 len));
#line 86
    strncat((char */* __restrict  */)msg, (char const   */* __restrict  */)append,
            (unsigned int )(175 - len));
#line 87
    tmp = strlen(append);
#line 87
    len = (int )((size_t )len + (2U + tmp));
  }
#line 89
  if (len >= 175) {
#line 90
    strcpy((char */* __restrict  */)((msg + 174) - sizeof(truncated)), (char const   */* __restrict  */)(truncated));
  }
#line 92
  return (msg);
}
}
#line 97 "log.c"
void log_syslog_str(int priority , char *msg ) 
{ 

  {
#line 100
  if (dosyslog) {
#line 101
    xopenlog();
#line 102
    syslog(priority, "%s", msg);
  }
#line 105
  return;
}
}
#line 108 "log.c"
void log_console_str(char *msg ) 
{ time_t t ;
  time_t tmp ;
  struct tm *ft ;
  char date[30] ;
  FILE * __restrict  tmp___0 ;

  {
#line 111
  if ((int )foreground == 1) {
#line 112
    tmp = time((time_t *)((void *)0));
#line 112
    t = tmp;
#line 116
    ft = localtime((time_t const   *)(& t));
#line 117
    date[0] = (char )'\000';
#line 118
    strftime((char */* __restrict  */)(date), sizeof(date), (char const   */* __restrict  */)"%H:%M:%S",
             (struct tm  const  */* __restrict  */)ft);
#line 119
    tmp___0 = get_stderr();
#line 119
    fprintf(tmp___0, (char const   */* __restrict  */)"%s %s\n", date, msg);
  }
#line 122
  return;
}
}
#line 125 "log.c"
void log_fd_str(int fd , char *msg ) 
{ size_t tmp ;
  size_t tmp___0 ;

  {
#line 128
  if (fd >= 0) {
#line 129
    tmp = strlen((char const   *)msg);
#line 129
    send(fd, (void const   *)msg, tmp, 0);
#line 130
    tmp___0 = strlen("\n");
#line 130
    send(fd, (void const   *)"\n", tmp___0, 0);
  }
#line 132
  return;
}
}
#line 137 "log.c"
static void log_syslog(int priority , int fd , char *fmt , __ccured_va_list args ) 
{ char *msg ;

  {
#line 142
  msg = make_msg((char const   *)((void *)0), fmt, args);
#line 142
  if ((unsigned int )msg == (unsigned int )((void *)0)) {
#line 143
    return;
  }
#line 145
  log_syslog_str(priority, msg);
#line 146
  log_console_str(msg);
#line 147
  log_fd_str(fd, msg);
#line 149
  free((void *)msg);
#line 150
  return;
}
}
#line 154 "log.c"
static void log_e(int priority , char *fmt , __ccured_va_list args ) 
{ int saved_errno ;
  char *msg ;
  int *tmp ;
  char const   *tmp___0 ;

  {
#line 160
  tmp = __errno_location();
#line 160
  saved_errno = (*tmp);
#line 162
  tmp___0 = strerror(saved_errno);
#line 162
  msg = make_msg(tmp___0, fmt, args);
#line 162
  if ((unsigned int )msg == (unsigned int )((void *)0)) {
#line 163
    return;
  }
#line 165
  log_syslog_str(priority, msg);
#line 166
  log_console_str(msg);
#line 168
  free((void *)msg);
#line 169
  return;
}
}
#line 175 "log.c"
static void log_pame(int priority , pam_handle_t *pamh___0 , int pamerrno , char *fmt ,
                     __ccured_va_list args ) 
{ char *msg ;
  char const   *tmp ;

  {
#line 180
  tmp = pam_strerror(pamh___0, pamerrno);
#line 180
  msg = make_msg(tmp, fmt, args);
#line 180
  if ((unsigned int )msg == (unsigned int )((void *)0)) {
#line 181
    return;
  }
#line 183
  log_syslog_str(priority, msg);
#line 184
  log_console_str(msg);
#line 186
  xcloselog();
#line 188
  free((void *)msg);
#line 189
  return;
}
}
#line 194 "log.c"
void explain(char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;

  {
#line 199
  tmp = GCC_STDARG_START();
#line 199
  __ccured_va_start(args, tmp);
#line 200
  log_syslog(5, -1, fmt, args);
#line 201
  __ccured_va_end(args);
#line 202
  return;
}
}
#line 205 "log.c"
void explain_fd(int fd , char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;

  {
#line 210
  tmp = GCC_STDARG_START();
#line 210
  __ccured_va_start(args, tmp);
#line 211
  log_syslog(5, fd, fmt, args);
#line 212
  __ccured_va_end(args);
#line 213
  return;
}
}
#line 217 "log.c"
void explain_e(char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;

  {
#line 222
  tmp = GCC_STDARG_START();
#line 222
  __ccured_va_start(args, tmp);
#line 223
  log_e(5, fmt, args);
#line 224
  __ccured_va_end(args);
#line 225
  return;
}
}
#line 229 "log.c"
void warn(char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;

  {
#line 234
  tmp = GCC_STDARG_START();
#line 234
  __ccured_va_start(args, tmp);
#line 235
  log_syslog(4, -1, fmt, args);
#line 236
  __ccured_va_end(args);
#line 237
  return;
}
}
#line 240 "log.c"
void warn_fd(int fd , char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;

  {
#line 245
  tmp = GCC_STDARG_START();
#line 245
  __ccured_va_start(args, tmp);
#line 246
  log_syslog(4, fd, fmt, args);
#line 247
  __ccured_va_end(args);
#line 248
  return;
}
}
#line 252 "log.c"
void warn_e(char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;

  {
#line 257
  tmp = GCC_STDARG_START();
#line 257
  __ccured_va_start(args, tmp);
#line 258
  log_e(4, fmt, args);
#line 259
  __ccured_va_end(args);
#line 260
  return;
}
}
#line 264 "log.c"
void error(char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;

  {
#line 269
  tmp = GCC_STDARG_START();
#line 269
  __ccured_va_start(args, tmp);
#line 270
  log_syslog(3, -1, fmt, args);
#line 271
  __ccured_va_end(args);
#line 272
  return;
}
}
#line 275 "log.c"
void error_fd(int fd , char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;

  {
#line 280
  tmp = GCC_STDARG_START();
#line 280
  __ccured_va_start(args, tmp);
#line 281
  log_syslog(3, fd, fmt, args);
#line 282
  __ccured_va_end(args);
#line 283
  return;
}
}
#line 287 "log.c"
void error_e(char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;

  {
#line 292
  tmp = GCC_STDARG_START();
#line 292
  __ccured_va_start(args, tmp);
#line 293
  log_e(3, fmt, args);
#line 294
  __ccured_va_end(args);
#line 295
  return;
}
}
#line 300 "log.c"
void error_pame(pam_handle_t *pamh___0 , int pamerrno , char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;

  {
#line 305
  xcloselog();
#line 307
  tmp = GCC_STDARG_START();
#line 307
  __ccured_va_start(args, tmp);
#line 308
  log_pame(3, pamh___0, pamerrno, fmt, args);
#line 309
  __ccured_va_end(args);
#line 310
  return;
}
}
#line 314 "log.c"
void die(char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;
  __pid_t tmp___0 ;

  {
#line 319
  tmp = GCC_STDARG_START();
#line 319
  __ccured_va_start(args, tmp);
#line 320
  log_syslog(3, -1, fmt, args);
#line 321
  __ccured_va_end(args);
#line 322
  tmp___0 = getpid();
#line 322
  if (tmp___0 == daemon_pid) {
#line 322
    error((char *)"Aborted");
  }
#line 324
  exit(1);
}
}
#line 330 "log.c"
void die_e(char *fmt  , ...) 
{ __ccured_va_list args ;
  int err_no ;
  int *tmp ;
  unsigned long tmp___0 ;
  __pid_t tmp___1 ;

  {
#line 334
  err_no = 0;
#line 336
  tmp = __errno_location();
#line 336
  err_no = (*tmp);
#line 338
  tmp___0 = GCC_STDARG_START();
#line 338
  __ccured_va_start(args, tmp___0);
#line 339
  log_e(3, fmt, args);
#line 340
  __ccured_va_end(args);
#line 341
  tmp___1 = getpid();
#line 341
  if (tmp___1 == daemon_pid) {
#line 341
    error((char *)"Aborted");
  }
#line 343
  exit(err_no);
}
}
#line 349 "log.c"
void die_pame(pam_handle_t *pamh___0 , int pamerrno , char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;
  __pid_t tmp___0 ;

  {
#line 354
  xcloselog();
#line 356
  tmp = GCC_STDARG_START();
#line 356
  __ccured_va_start(args, tmp);
#line 357
  log_pame(3, pamh___0, pamerrno, fmt, args);
#line 358
  __ccured_va_end(args);
#line 359
  pam_end(pamh___0, pamerrno);
#line 360
  tmp___0 = getpid();
#line 360
  if (tmp___0 == daemon_pid) {
#line 360
    error((char *)"Aborted");
  }
#line 362
  exit(1);
}
}
#line 368 "log.c"
void Debug(char *fmt  , ...) 
{ __ccured_va_list args ;
  unsigned long tmp ;

  {
#line 373
  tmp = GCC_STDARG_START();
#line 373
  __ccured_va_start(args, tmp);
#line 374
  log_syslog(7, -1, fmt, args);
#line 375
  __ccured_va_end(args);
#line 376
  return;
}
}
#line 379 "log.c"
void send_msg_fd_debug(int fd , char *fmt  , ...) 
{ char *msg ;
  __ccured_va_list args ;
  unsigned long tmp ;

  {
#line 386
  tmp = GCC_STDARG_START();
#line 386
  __ccured_va_start(args, tmp);
#line 388
  msg = make_msg((char const   *)((void *)0), fmt, args);
#line 388
  if ((unsigned int )msg == (unsigned int )((void *)0)) {
#line 389
    return;
  }
#line 391
  if (debug_opt) {
#line 392
    log_syslog_str(7, msg);
  }
#line 394
  log_fd_str(fd, msg);
#line 396
  free((void *)msg);
#line 398
  __ccured_va_end(args);
#line 399
  return;
}
}
#line 402 "log.c"
void send_msg_fd(int fd , char *fmt  , ...) 
{ char *msg ;
  __ccured_va_list args ;
  unsigned long tmp ;

  {
#line 409
  tmp = GCC_STDARG_START();
#line 409
  __ccured_va_start(args, tmp);
#line 411
  msg = make_msg((char const   *)((void *)0), fmt, args);
#line 411
  if ((unsigned int )msg == (unsigned int )((void *)0)) {
#line 412
    return;
  }
#line 414
  log_fd_str(fd, msg);
#line 416
  free((void *)msg);
#line 418
  __ccured_va_end(args);
#line 419
  return;
}
}
#line 1 "database.o"
/* #pragma merger(0,"./database.i","-O2 -Wall") */
#line 123 "/users/rupak/ccured/include/ccuredannot.h"
/* #pragma cilnoremove("__ccuredInit") */
#line 20 "/users/rupak/ccured/include/ccured.h"
/* #pragma cilnoremove("wrapperAlloc") */
#line 21
/* #pragma ccuredalloc("wrapperAlloc",sizein(1),nozero) */
#line 24
/* #pragma cilnoremove("wrapperFree") */
#line 25
/* #pragma ccuredpoly("wrapperFree") */
#line 29
/* #pragma cilnoremove("wrapperStrdup") */
#line 30
/* #pragma ccuredpoly("wrapperStrdup") */
#line 50
/* #pragma ccuredpoly("__ptrof_nocheck") */
#line 51
/* #pragma cilnoremove("__ptrof_nocheck") */
#line 57
/* #pragma ccuredpoly("__startof") */
#line 63
/* #pragma ccuredpoly("__endof") */
#line 78
/* #pragma ccuredpoly("__ptrof") */
#line 84
/* #pragma ccuredpoly("__ptrof_size") */
#line 85
/* #pragma cilnoremove("__ptrof_size") */
#line 92
/* #pragma ccuredpoly("__verify_nul") */
#line 101
/* #pragma ccuredpoly("__strlen") */
#line 111
/* #pragma ccuredpoly("__strlen_n") */
#line 125
/* #pragma ccuredpoly("__stringof") */
#line 127
/* #pragma cilnoremove("__stringof") */
#line 136
/* #pragma ccuredpoly("__stringof_ornull") */
#line 138
/* #pragma cilnoremove("__stringof_ornull") */
#line 147
/* #pragma ccuredpoly("__write_at_least") */
#line 155
/* #pragma ccuredpoly("__read_at_least") */
#line 162
/* #pragma ccuredpoly("__copytags") */
#line 180
/* #pragma ccuredpoly("__mkptr") */
#line 181
/* #pragma cilnoremove("__mkptr") */
#line 188
/* #pragma ccuredpoly("__mkptr_int") */
#line 196
/* #pragma ccuredpoly("__mkptr_size") */
#line 197
/* #pragma cilnoremove("__mkptr_size") */
#line 206
/* #pragma ccuredpoly("__mkptr_string") */
#line 207
/* #pragma cilnoremove("__mkptr_string") */
#line 215
/* #pragma ccuredpoly("__align_seq") */
#line 216
/* #pragma cilnoremove("__align_seq") */
#line 227
/* #pragma ccuredpoly("__trusted_cast") */
#line 228
/* #pragma cilnoremove("__trusted_cast") */
#line 237
/* #pragma ccuredpoly("__trusted_deepcast") */
#line 238
/* #pragma cilnoremove("__trusted_deepcast") */
#line 250
/* #pragma ccuredpoly("ccured_hasuniontag") */
#line 259
/* #pragma ccuredpoly("__ccured_kind_of") */
#line 307
/* #pragma ccuredpoly("__ccured_mangling_of") */
#line 308
/* #pragma cilnoremove("__ccured_mangling_of") */
#line 312
/* #pragma ccuredpoly("__ccured_has_empty_mangling") */
#line 313
/* #pragma cilnoremove("__ccured_has_empty_mangling") */
#line 327
/* #pragma cilnoremove("abort_deepcopy") */
#line 451
/* #pragma cilnoremove("struct printf_arguments") */
#line 45 "/users/rupak/ccured/include/time_wrappers.h"
/* #pragma ccuredwrapper("time_wrapper",of("time")) */
#line 59
/* #pragma ccuredwrapper("ctime_wrapper",of("ctime")) */
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments )) */
#line 266
/* #pragma ccuredpoly("__ccured_va_arg") */
#line 303
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___0 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___0 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___0 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___0 )) */
#line 69 "/users/rupak/ccured/include/io_wrappers.h"
/* #pragma ccuredwrapper("unlink_wrapper",of("unlink")) */
#line 79
/* #pragma ccuredwrapper("open_wrapper",of("open")) */
#line 80
/* #pragma ccuredvararg("open_wrapper",sizeof(int )) */
#line 123
/* #pragma ccuredwrapper("rename_wrapper",of("rename")) */
#line 6 "/users/rupak/ccured/include/malloc_wrappers.h"
/* #pragma ccuredalloc("malloc",nozero,sizein(1)) */
#line 8
/* #pragma ccuredpoly("realloc") */
#line 9
/* #pragma ccuredwrapper("realloc_wrapper",of("realloc")) */
#line 22
/* #pragma ccuredwrapper("free_wrapper",of("free")) */
#line 27
/* #pragma ccuredalloc("alloca",nozero,sizein(1)) */
#line 28
/* #pragma ccuredalloc("calloc",zero,sizemul(1,2)) */
#line 46 "/users/rupak/ccured/include/string_wrappers.h"
/* #pragma ccuredwrapper("strlen_wrapper",of("strlen")) */
#line 52
/* #pragma ccuredwrapper("bzero_wrapper",of("bzero")) */
#line 61
/* #pragma ccuredwrapper("strcpy_wrapper",of("strcpy")) */
#line 81
/* #pragma ccuredwrapper("strncpy_wrapper",of("strncpy")) */
#line 95
/* #pragma ccuredwrapper("strcat_wrapper",of("strcat")) */
#line 111
/* #pragma ccuredwrapper("strncat_wrapper",of("strncat")) */
#line 128
/* #pragma ccuredwrapper("strchr_wrapper",of("strchr")) */
#line 137
/* #pragma ccuredwrapper("strrchr_wrapper",of("strrchr")) */
#line 146
/* #pragma ccuredwrapper("strdup_wrapper",of("strdup")) */
#line 167
/* #pragma ccuredwrapper("strcasecmp_wrapper",of("strcasecmp")) */
#line 173
/* #pragma ccuredwrapper("strcmp_wrapper",of("strcmp")) */
#line 180
/* #pragma ccuredwrapper("strncasecmp_wrapper",of("strncasecmp")) */
#line 194
/* #pragma ccuredwrapper("strncmp_wrapper",of("strncmp")) */
#line 208
/* #pragma ccuredwrapper("strpbrk_wrapper",of("strpbrk")) */
#line 217
/* #pragma ccuredwrapper("strsep_wrapper",of("strsep")) */
#line 234
/* #pragma ccuredwrapper("strtoul_wrapper",of("strtoul")) */
#line 47 "/users/rupak/ccured/include/stdlib_wrappers.h"
/* #pragma ccuredwrapper("atof_wrapper",of("atof")) */
#line 55
/* #pragma ccuredwrapper("atoi_wrapper",of("atoi")) */
#line 63
/* #pragma ccuredwrapper("atol_wrapper",of("atol")) */
#line 93
/* #pragma ccuredpoly("qsort_zero_tags") */
#line 172
/* #pragma ccuredwrapper("qsort_wrapper",of("qsort")) */
#line 216
/* #pragma ccuredwrapper("bsearch_wrapper",of("bsearch")) */
#line 254
/* #pragma ccuredwrapper("strtol_wrapper",of("strtol")) */
#line 270
/* #pragma ccuredwrapper("getenv_wrapper",of("getenv")) */
#line 256 "/users/rupak/ccured/include/string_wrappers.h"
/* #pragma ccuredwrapper("strtok_wrapper",of("strtok")) */
#line 269
/* #pragma ccuredwrapper("strtok_r_wrapper",of("strtok_r")) */
#line 319
/* #pragma ccuredwrapper("memcmp_wrapper",of("memcmp")) */
#line 332
/* #pragma ccuredwrapper("memset_wrapper",of("memset")) */
#line 341
/* #pragma ccuredwrapper("memmove_wrapper",of("memmove")) */
#line 353
/* #pragma ccuredwrapper("memcpy_wrapper",of("memcpy")) */
#line 366
/* #pragma ccuredwrapper("strerror_wrapper",of("strerror")) */
#line 374
/* #pragma ccuredwrapper("strstr_wrapper",of("strstr")) */
#line 383
/* #pragma ccuredwrapper("memchr_wrapper",of("memchr")) */
#line 50 "/users/rupak/ccured/include/pwd_wrappers.h"
/* #pragma ccuredwrapper("getpwnam_wrapper",of("getpwnam")) */
#line 68
/* #pragma ccuredwrapper("getpwuid_wrapper",of("getpwuid")) */
#line 81
/* #pragma ccuredwrapper("getpwent_wrapper",of("getpwent")) */
#line 56 "/users/rupak/ccured/include/signal_wrappers.h"
/* #pragma ccuredpoly("__mkfat_sighandler") */
#line 66
/* #pragma ccuredwrapper("signal_wrapper",of("signal")) */
#line 88
/* #pragma ccuredwrapper("sigaction_wrapper",of("sigaction")) */
#line 168 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredpoly("get_stdin") */
#line 170
/* #pragma ccuredpoly("get_stdout") */
#line 172
/* #pragma ccuredpoly("get_stderr") */
#line 59 "/users/rupak/ccured/include/stdio_wrappers.h"
/* #pragma ccuredpoly("__mkptr_file") */
#line 65
/* #pragma ccuredpoly("__ptrof_file") */
#line 68
/* #pragma ccuredvararg("printf",printf(1)) */
#line 69
/* #pragma ccuredvararg("fprintf",printf(2)) */
#line 70
/* #pragma ccuredvararg("snprintf",printf(3)) */
#line 71
/* #pragma ccuredvararg("syslog",printf(2)) */
#line 72
/* #pragma ccuredvararg("sprintf",printf(2)) */
#line 73
/* #pragma ccuredvararg("vsprintf",printf(2)) */
#line 74
/* #pragma ccuredvararg("vfprintf",printf(2)) */
#line 75
/* #pragma ccuredvararg("vprintf",printf(1)) */
#line 76
/* #pragma ccuredvararg("vsyslog",printf(2)) */
#line 78
/* #pragma ccuredpoly("__endof") */
#line 89
/* #pragma ccuredpoly("ccured_fscanf_string") */
#line 92
/* #pragma ccuredwrapper("ccured_fscanf_string_wrapper",of("ccured_fscanf_string")) */
#line 117
/* #pragma ccuredvararg("sscanf",sizeof(struct scanf_format )) */
#line 118
/* #pragma ccuredvararg("fscanf",sizeof(struct scanf_format )) */
#line 123
/* #pragma ccuredwrapper("fgets_wrapper",of("fgets")) */
#line 132
/* #pragma ccuredwrapper("fopen_wrapper",of("fopen")) */
#line 139
/* #pragma ccuredwrapper("fdopen_wrapper",of("fdopen")) */
#line 146
/* #pragma ccuredwrapper("fflush_wrapper",of("fflush")) */
#line 152
/* #pragma ccuredwrapper("fclose_wrapper",of("fclose")) */
#line 179
/* #pragma ccuredwrapper("_IO_putc_wrapper",of("_IO_putc")) */
#line 185
/* #pragma ccuredwrapper("_IO_getc_wrapper",of("_IO_getc")) */
#line 210
/* #pragma ccuredwrapper("fputc_wrapper",of("fputc")) */
#line 216
/* #pragma ccuredwrapper("fputs_wrapper",of("fputs")) */
#line 222
/* #pragma ccuredwrapper("fgetc_wrapper",of("fgetc")) */
#line 228
/* #pragma ccuredwrapper("puts_wrapper",of("puts")) */
#line 234
/* #pragma ccuredwrapper("fileno_wrapper",of("fileno")) */
#line 240
/* #pragma ccuredwrapper("ferror_wrapper",of("ferror")) */
#line 246
/* #pragma ccuredwrapper("fseek_wrapper",of("fseek")) */
#line 253
/* #pragma ccuredwrapper("clearerr_wrapper",of("clearerr")) */
#line 264
/* #pragma ccuredwrapper("fread_wrapper",of("fread")) */
#line 275
/* #pragma ccuredwrapper("fwrite_wrapper",of("fwrite")) */
#line 288
/* #pragma ccuredwrapper("gets_wrapper",of("gets")) */
#line 314
/* #pragma ccuredvararg("vsnprintf_wrapper",printf(3)) */
#line 315
/* #pragma ccuredwrapper("vsnprintf_wrapper",of("vsnprintf")) */
#line 322
/* #pragma ccuredvararg("vsprintf_wrapper",printf(2)) */
#line 323
/* #pragma ccuredwrapper("vsprintf_wrapper",of("vsprintf")) */
#line 330
/* #pragma ccuredvararg("snprintf_wrapper",printf(3)) */
#line 331
/* #pragma ccuredwrapper("snprintf_wrapper",of("snprintf")) */
#line 343
/* #pragma ccuredvararg("sprintf_wrapper",printf(2)) */
#line 344
/* #pragma ccuredwrapper("sprintf_wrapper",of("sprintf")) */
#line 366
/* #pragma ccuredpoly("ccured_fscanf_double") */
#line 382
/* #pragma ccuredpoly("ccured_fscanf_int") */
#line 398
/* #pragma ccuredpoly("ccured_fscanf_nothing") */
#line 467
/* #pragma ccuredwrapper("perror_wrapper",of("perror")) */
#line 49 "/users/rupak/ccured/include/stat_wrappers.h"
/* #pragma ccuredwrapper("fstat_wrapper",of("fstat")) */
#line 57
/* #pragma ccuredwrapper("stat_wrapper",of("stat")) */
#line 68
/* #pragma ccuredwrapper("__xstat_wrapper",of("__xstat")) */
#line 79 "/users/rupak/ccured/include/time_wrappers.h"
/* #pragma ccuredwrapper("asctime_wrapper",of("asctime")) */
#line 13 "/users/rupak/ccured/include/functions/deepcopy_stringarray.h"
/* #pragma cilnoremove("__deepcopy_stringarray_from_compat") */
#line 14
/* #pragma ccuredpoly("__deepcopy_stringarray_from_compat") */
#line 53
/* #pragma ccuredpoly("__deepcopy_stringarray_to_compat") */
#line 44 "/users/rupak/ccured/include/unistd_wrappers.h"
/* #pragma ccuredwrapper("execv_wrapper",of("execv")) */
#line 66
/* #pragma ccuredwrapper("execvp_wrapper",of("execvp")) */
#line 86
/* #pragma ccuredwrapper("execve_wrapper",of("execve")) */
#line 106
/* #pragma ccuredvararg("execl",sizeof(struct __ccured_execl_arguments )) */
#line 107
/* #pragma ccuredvararg("execlp",sizeof(struct __ccured_execl_arguments )) */
#line 108
/* #pragma ccuredvararg("execle",sizeof(struct __ccured_execl_arguments )) */
#line 110
/* #pragma ccuredwrapper("getlogin_wrapper",of("getlogin")) */
#line 117
/* #pragma ccuredwrapper("ttyname_wrapper",of("ttyname")) */
#line 129
/* #pragma ccuredwrapper("getopt_wrapper",of("getopt")) */
#line 174
/* #pragma ccuredwrapper("read_wrapper",of("read")) */
#line 182
/* #pragma ccuredwrapper("write_wrapper",of("write")) */
#line 195
/* #pragma ccuredwrapper("getusershell_wrapper",of("getusershell")) */
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___1 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___1 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___1 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___1 )) */
#line 303
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___2 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___2 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___2 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___2 )) */
#line 43 "/users/rupak/ccured/include/crypt_wrappers.h"
/* #pragma ccuredwrapper("crypt_wrapper",of("crypt")) */
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___3 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___3 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___3 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___3 )) */
#line 23 "/users/rupak/ccured/include/grp_wrappers.h"
/* #pragma ccuredwrapper("getgrnam_wrapper",of("getgrnam")) */
#line 45
/* #pragma ccuredwrapper("getgrgid_wrapper",of("getgrgid")) */
#line 59
/* #pragma ccuredwrapper("getgrent_wrapper",of("getgrent")) */
#line 443 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("ioctl",sizeof(struct ioctl_format )) */
#line 32 "database.c"
int is_leap_year(int year ) ;
#line 33
int get_nb_mdays(int year , int mon ) ;
#line 34
void set_wday(struct tm *date ) ;
#line 35
void goto_non_matching(cl_t *line , struct tm *ftime , char option ) ;
#line 38
void run_lavg_job(int i ) ;
#line 39
void run_queue_job(cl_t *line ) ;
#line 40
void resize_exe_array(void) ;
#line 42 "database.c"
void test_jobs(void) 
{ struct job_t *j ;

  {
#line 49
  if (debug_opt) {
#line 49
    Debug((char *)"Looking for jobs to execute ...");
  }
#line 52
  while (1) {
#line 52
    j = queue_base;
#line 52
    if (j) {
#line 52
      if (! ((j->j_line)->cl_nextexe <= now)) {
#line 52
        break;
      }
    } else {
#line 52
      break;
    }
#line 53
    if ((int )(j->j_line)->cl_remain > 0) {
#line 53
      (j->j_line)->cl_remain = (unsigned short )((int )(j->j_line)->cl_remain - 1);
#line 53
      if ((j->j_line)->cl_remain > 0) {
#line 54
        set_next_exe(j->j_line, 0, -1);
#line 55
        if (debug_opt) {
#line 55
          Debug((char *)"    cl_remain: %d", (j->j_line)->cl_remain);
        }
#line 56
        continue;
      }
    }
#line 59
    (j->j_line)->cl_remain = (j->j_line)->cl_runfreq;
#line 61
    if ((int )(j->j_line)->cl_option[0] & 2) {
#line 62
      add_lavg_job(j->j_line, -1);
    } else {
#line 63
      if ((int )(j->j_line)->cl_option[0] & 32) {
#line 64
        add_serial_job(j->j_line, -1);
      } else {
#line 66
        run_normal_job(j->j_line, -1);
      }
    }
#line 68
    set_next_exe(j->j_line, 0, -1);
  }
#line 71
  return;
}
}
#line 74 "database.c"
void run_normal_job(cl_t *line , int info_fd ) 
{ 

  {
#line 79
  if ((int )line->cl_numexe <= 0) {
#line 81
    line->cl_numexe = (unsigned char )((int )line->cl_numexe + 1);
#line 82
    run_queue_job(line);
#line 83
    send_msg_fd(info_fd, (char *)"Job %s started.", line->cl_shell);
  } else {
#line 79
    if ((int )line->cl_option[1] & 4) {
#line 79
      if ((int )line->cl_numexe < 255) {
#line 81
        line->cl_numexe = (unsigned char )((int )line->cl_numexe + 1);
#line 82
        run_queue_job(line);
#line 83
        send_msg_fd(info_fd, (char *)"Job %s started.", line->cl_shell);
      } else {
#line 86
        warn_fd(info_fd, (char *)"    process already running: %s\'s %s", (line->cl_file)->cf_user,
                line->cl_shell);
      }
    } else {
#line 86
      warn_fd(info_fd, (char *)"    process already running: %s\'s %s", (line->cl_file)->cf_user,
              line->cl_shell);
    }
  }
#line 90
  return;
}
}
#line 92 "database.c"
void run_lavg_job(int i ) 
{ 

  {
#line 96
  run_queue_job((lavg_array + i)->l_line);
#line 98
  if ((int )((lavg_array + i)->l_line)->cl_option[0] & 32) {
#line 99
    lavg_serial_running = (short )((int )lavg_serial_running + 1);
  }
#line 101
  lavg_num = (short )((int )lavg_num - 1);
#line 101
  if (i < lavg_num) {
#line 102
    (*(lavg_array + i)) = (*(lavg_array + lavg_num));
#line 103
    (lavg_array + lavg_num)->l_line = (struct cl_t *)((void *)0);
  } else {
#line 106
    (lavg_array + i)->l_line = (struct cl_t *)((void *)0);
  }
#line 108
  return;
}
}
#line 111 "database.c"
void run_serial_job(void) 
{ 

  {
#line 119
  if (debug_opt) {
#line 119
    Debug((char *)"num: %d running:%d  index:%d", serial_num, serial_running, serial_array_index);
  }
#line 121
  if ((int )serial_num != 0) {
#line 122
    run_queue_job((*(serial_array + serial_array_index)));
#line 123
    (*(serial_array + serial_array_index)) = (struct cl_t *)((void *)0);
#line 125
    serial_running = (short )((int )serial_running + 1);
#line 126
    serial_array_index = (short )((int )serial_array_index + 1);
#line 126
    if (serial_array_index >= (int )serial_array_size) {
#line 127
      serial_array_index = (short )((int )serial_array_index - (int )serial_array_size);
    }
#line 128
    serial_num = (short )((int )serial_num - 1);
  }
#line 131
  return;
}
}
#line 134 "database.c"
void resize_exe_array(void) 
{ struct exe_t *ptr ;
  short old_size ;

  {
#line 138
  ptr = (struct exe_t *)((void *)0);
#line 139
  old_size = exe_array_size;
#line 141
  if (debug_opt) {
#line 141
    Debug((char *)"Resizing exe_array");
  }
#line 142
  exe_array_size = (short )((int )exe_array_size + 5);
#line 144
  ptr = (struct exe_t *)calloc((unsigned int )exe_array_size, sizeof(struct exe_t ));
#line 144
  if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 145
    die_e((char *)"could not calloc exe_array");
  }
#line 147
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)exe_array,
         sizeof(struct exe_t ) * (unsigned int )old_size);
#line 148
  free((void *)exe_array);
#line 149
  exe_array = ptr;
#line 150
  return;
}
}
#line 153 "database.c"
void run_queue_job(cl_t *line ) 
{ short tmp ;

  {
#line 163
  if ((int )exe_num >= (int )exe_array_size) {
#line 164
    resize_exe_array();
  }
#line 166
  (exe_array + exe_num)->e_line = line;
#line 168
  tmp = exe_num;
#line 168
  exe_num = (short )((int )exe_num + 1);
#line 168
  run_job(exe_array + tmp);
#line 170
  return;
}
}
#line 174 "database.c"
void insert_nextexe(struct cl_t *line ) 
{ struct job_t *newjob ;
  struct job_t *j ;
  struct job_t *jprev ;
  struct job_t *old_entry ;

  {
#line 180
  if ((unsigned int )queue_base != (unsigned int )((void *)0)) {
#line 182
    jprev = (struct job_t *)((void *)0);
#line 183
    old_entry = (struct job_t *)((void *)0);
#line 186
    j = queue_base;
#line 186
    while ((unsigned int )j != (unsigned int )((void *)0)) {
#line 187
      if ((unsigned int )j->j_line == (unsigned int )line) {
#line 188
        old_entry = j;
#line 190
        if ((unsigned int )jprev != (unsigned int )((void *)0)) {
#line 191
          jprev->j_next = j->j_next;
#line 192
          j = jprev;
        } else {
#line 196
          queue_base = j->j_next;
#line 196
          j = queue_base;
        }
#line 198
        break;
      } else {
#line 201
        jprev = j;
      }
#line 186
      j = j->j_next;
    }
#line 203
    jprev = (struct job_t *)((void *)0);
#line 204
    if ((unsigned int )j == (unsigned int )((void *)0)) {
#line 205
      j = queue_base;
    } else {
#line 204
      if (line->cl_nextexe < (j->j_line)->cl_nextexe) {
#line 205
        j = queue_base;
      }
    }
#line 206
    while (1) {
#line 206
      if ((unsigned int )j != (unsigned int )((void *)0)) {
#line 206
        if (! (line->cl_nextexe >= (j->j_line)->cl_nextexe)) {
#line 206
          break;
        }
      } else {
#line 206
        break;
      }
#line 207
      jprev = j;
#line 208
      j = j->j_next;
    }
#line 211
    if ((unsigned int )old_entry == (unsigned int )((void *)0)) {
#line 213
      newjob = (struct job_t *)calloc(1U, sizeof(job_t ));
#line 213
      if ((unsigned int )newjob == (unsigned int )((void *)0)) {
#line 213
        die_e((char *)"Could not calloc.");
      }
#line 214
      newjob->j_line = line;
    } else {
#line 218
      newjob = old_entry;
    }
#line 220
    newjob->j_next = j;
#line 222
    if ((unsigned int )jprev == (unsigned int )((void *)0)) {
#line 223
      queue_base = newjob;
    } else {
#line 225
      jprev->j_next = newjob;
    }
  } else {
#line 230
    newjob = (struct job_t *)calloc(1U, sizeof(job_t ));
#line 230
    if ((unsigned int )newjob == (unsigned int )((void *)0)) {
#line 230
      die_e((char *)"Could not calloc.");
    }
#line 231
    newjob->j_line = line;
#line 232
    queue_base = newjob;
  }
#line 235
  return;
}
}
#line 237 "database.c"
void add_serial_job(struct cl_t *line , int info_fd ) 
{ short i ;
  cl_t **ptr ;
  short old_size ;

  {
#line 245
  if (! ((int )line->cl_option[1] & 8)) {
#line 245
    if ((int )line->cl_numexe >= 255) {
#line 247
      send_msg_fd_debug(info_fd, (char *)"already in serial queue %s", line->cl_shell);
#line 248
      return;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 245
    if (! (! ((int )line->cl_option[1] & 8))) {
#line 245
      if ((int )line->cl_numexe > 0) {
#line 247
        send_msg_fd_debug(info_fd, (char *)"already in serial queue %s", line->cl_shell);
#line 248
        return;
      }
    }
  }
#line 251
  send_msg_fd_debug(info_fd, (char *)"inserting in serial queue %s", line->cl_shell);
#line 253
  if ((int )serial_num >= (int )serial_array_size) {
#line 254
    if ((int )serial_num >= (int )serial_queue_max) {
#line 255
      error_fd(info_fd, (char *)"Could not add job : serial queue is full (%d jobs). Consider using option serialonce, fcron\'s option -m and/or -q : %s",
               serial_queue_max, line->cl_shell);
#line 258
      if ((int )line->cl_option[2] & 32) {
#line 259
        mail_notrun(line, 3, (struct tm *)((void *)0));
      }
#line 260
      return;
    } else {
#line 263
      ptr = (cl_t **)((void *)0);
#line 264
      old_size = serial_array_size;
#line 266
      if (debug_opt) {
#line 266
        Debug((char *)"Resizing serial_array");
      }
#line 267
      serial_array_size = (short )((int )serial_array_size + 10);
#line 269
      ptr = (cl_t **)calloc((unsigned int )serial_array_size, sizeof(cl_t *));
#line 269
      if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 270
        die_e((char *)"could not calloc serial_array");
      }
#line 273
      memcpy((void */* __restrict  */)(ptr + (int )serial_array_index), (void const   */* __restrict  */)serial_array,
             sizeof(cl_t *) * (unsigned int )((int )old_size - (int )serial_array_index));
#line 275
      memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)(serial_array +
                                                                             ((int )old_size -
                                                                              (int )serial_array_index)),
             sizeof(cl_t *) * (unsigned int )serial_array_index);
#line 277
      serial_array_index = 0;
#line 278
      free((void *)serial_array);
#line 279
      serial_array = ptr;
    }
  }
#line 283
  i = (short )((int )serial_array_index + (int )serial_num);
#line 283
  if ((int )i >= (int )serial_array_size) {
#line 284
    i = (short )((int )i - (int )serial_array_size);
  }
#line 286
  (*(serial_array + i)) = line;
#line 288
  serial_num = (short )((int )serial_num + 1);
#line 289
  line->cl_numexe = (unsigned char )((int )line->cl_numexe + 1);
#line 291
  send_msg_fd_debug(info_fd, (char *)"serial num: %d size:%d index:%d curline:%d running:%d (%s)",
                    serial_num, serial_array_size, serial_array_index, i, serial_running,
                    line->cl_shell);
#line 296
  return;
}
}
#line 299 "database.c"
void add_lavg_job(struct cl_t *line , int info_fd ) 
{ struct lavg_t *ptr ;
  short old_size ;
  struct tm *ft ;
  struct tm ftime ;
  time_t begin_of_cur_int ;
  time_t end_of_cur_int ;
  time_t tmp ;

  {
#line 308
  if ((int )line->cl_option[1] & 16) {
#line 308
    if ((int )line->cl_numexe >= 255) {
#line 310
      send_msg_fd_debug(info_fd, (char *)"already in lavg queue %s", line->cl_shell);
#line 311
      return;
    } else {
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 308
    if (! ((int )line->cl_option[1] & 16)) {
#line 308
      if ((int )line->cl_numexe > 0) {
#line 310
        send_msg_fd_debug(info_fd, (char *)"already in lavg queue %s", line->cl_shell);
#line 311
        return;
      }
    }
  }
#line 314
  send_msg_fd_debug(info_fd, (char *)"inserting in lavg queue %s", line->cl_shell);
#line 318
  if ((int )lavg_num >= (int )lavg_array_size) {
#line 319
    if ((int )lavg_num >= (int )lavg_queue_max) {
#line 320
      error_fd(info_fd, (char *)"Could not add job : lavg queue is full (%d jobs). Consider using options lavgonce, until, strict and/or fcron\'s option -q.",
               lavg_queue_max, line->cl_shell);
#line 323
      if ((int )line->cl_option[2] & 32) {
#line 324
        mail_notrun(line, 3, (struct tm *)((void *)0));
      }
#line 325
      return;
    } else {
#line 328
      ptr = (struct lavg_t *)((void *)0);
#line 329
      old_size = lavg_array_size;
#line 331
      if (debug_opt) {
#line 331
        Debug((char *)"Resizing lavg_array");
      }
#line 332
      lavg_array_size = (short )((int )lavg_array_size + 10);
#line 334
      ptr = (struct lavg_t *)calloc((unsigned int )lavg_array_size, sizeof(lavg_t ));
#line 334
      if ((unsigned int )ptr == (unsigned int )((void *)0)) {
#line 335
        die_e((char *)"could not calloc lavg_array");
      }
#line 337
      memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)lavg_array,
             sizeof(lavg_t ) * (unsigned int )old_size);
#line 338
      free((void *)lavg_array);
#line 339
      lavg_array = ptr;
    }
  }
#line 343
  (lavg_array + lavg_num)->l_line = line;
#line 344
  line->cl_numexe = (unsigned char )((int )line->cl_numexe + 1);
#line 345
  line->cl_option[1] = (unsigned char )((int )line->cl_option[1] | 2);
#line 346
  if (! ((int )line->cl_option[2] & 16)) {
#line 346
    if ((int )line->cl_runfreq == 1) {
#line 349
      end_of_cur_int = (time_t )0;
#line 352
      begin_of_cur_int = line->cl_nextexe - (time_t )((int )(line->cl_file)->cf_tzdiff *
                                                      3600);
#line 354
      ft = localtime((time_t const   *)(& begin_of_cur_int));
#line 359
      memcpy((void */* __restrict  */)(& ftime), (void const   */* __restrict  */)ft,
             sizeof(struct tm ));
#line 361
      goto_non_matching(line, & ftime, 1);
#line 363
      tmp = mktime(& ftime);
#line 363
      end_of_cur_int = tmp + (time_t )((int )(line->cl_file)->cf_tzdiff * 3600);
#line 365
      if (line->cl_until > 0L) {
#line 365
        if (line->cl_until + now < end_of_cur_int) {
#line 366
          (lavg_array + lavg_num)->l_until = line->cl_until + now;
        } else {
#line 368
          (lavg_array + lavg_num)->l_until = end_of_cur_int;
#line 369
          line->cl_option[1] = (unsigned char )((int )line->cl_option[1] & -3);
        }
      } else {
#line 368
        (lavg_array + lavg_num)->l_until = end_of_cur_int;
#line 369
        line->cl_option[1] = (unsigned char )((int )line->cl_option[1] & -3);
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 373
    if (line->cl_until > 0L) {
#line 373
      (lavg_array + lavg_num)->l_until = now + line->cl_until;
    } else {
#line 373
      (lavg_array + lavg_num)->l_until = 0L;
    }
  }
#line 376
  lavg_num = (short )((int )lavg_num + 1);
#line 377
  return;
}
}
#line 380 "database.c"
void wait_chld(void) 
{ short i ;
  int pid ;
  cl_t *line ;

  {
#line 384
  i = 0;
#line 386
  line = (cl_t *)((void *)0);
#line 393
  while (1) {
#line 393
    pid = wait3((union wait *)((void *)0), 1, (struct rusage *)((void *)0));
#line 393
    if (! (pid > 0)) {
#line 393
      break;
    }
#line 394
    i = 0;
#line 395
    while ((int )i < (int )exe_num) {
#line 396
      if (pid == (exe_array + i)->e_ctrl_pid) {
#line 397
        if ((unsigned int )(exe_array + i)->e_line == (unsigned int )((void *)0)) {
#line 399
          if (debug_opt) {
#line 399
            Debug((char *)"job finished: pid %d", pid);
          }
        } else {
#line 403
          line = (exe_array + i)->e_line;
#line 405
          line->cl_numexe = (unsigned char )((int )line->cl_numexe - 1);
#line 406
          (line->cl_file)->cf_running = (line->cl_file)->cf_running - 1;
#line 408
          if ((int )line->cl_option[0] & 64) {
#line 409
            line->cl_option[0] = (unsigned char )((int )line->cl_option[0] & -65);
#line 410
            serial_running = (short )((int )serial_running - 1);
#line 410
            if (serial_running < (int )serial_max_running) {
#line 411
              run_serial_job();
            }
          } else {
#line 413
            if ((int )line->cl_option[0] & 32) {
#line 413
              if (! ((int )line->cl_option[0] & 2)) {
#line 415
                serial_running = (short )((int )serial_running - 1);
#line 415
                if (serial_running < (int )serial_max_running) {
#line 416
                  run_serial_job();
                }
              } else {
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
#line 418
              if ((int )line->cl_option[0] & 2) {
#line 418
                if ((int )line->cl_option[0] & 32) {
#line 420
                  lavg_serial_running = (short )((int )lavg_serial_running - 1);
                }
              }
            }
          }
        }
#line 422
        exe_num = (short )((int )exe_num - 1);
#line 422
        if ((int )i < exe_num) {
#line 423
          (*(exe_array + i)) = (*(exe_array + exe_num));
#line 424
          (exe_array + exe_num)->e_line = (struct cl_t *)((void *)0);
        } else {
#line 427
          (exe_array + i)->e_line = (struct cl_t *)((void *)0);
        }
#line 429
        break;
      }
#line 431
      i = (short )((int )i + 1);
    }
  }
#line 435
  return;
}
}
#line 438 "database.c"
void wait_all(int *counter ) 
{ short i ;
  int pid ;

  {
#line 442
  i = 0;
#line 445
  if (debug_opt) {
#line 445
    Debug((char *)"Waiting for all jobs");
  }
#line 447
  while (1) {
#line 447
    if ((*counter) > 0) {
#line 447
      pid = wait3((union wait *)((void *)0), 0, (struct rusage *)((void *)0));
#line 447
      if (! (pid > 0)) {
#line 447
        break;
      }
    } else {
#line 447
      break;
    }
#line 448
    i = 0;
#line 449
    while ((int )i < (int )exe_num) {
#line 450
      if (pid == (exe_array + i)->e_ctrl_pid) {
#line 451
        if ((unsigned int )(exe_array + i)->e_line == (unsigned int )((void *)0)) {
#line 453
          if (debug_opt) {
#line 453
            Debug((char *)"job finished: pid %d", pid);
          }
        } else {
#line 457
          if (debug_opt) {
#line 457
            Debug((char *)"job finished: %s", ((exe_array + i)->e_line)->cl_shell);
          }
#line 458
          ((exe_array + i)->e_line)->cl_numexe = (unsigned char )((int )((exe_array +
                                                                          i)->e_line)->cl_numexe -
                                                                  1);
#line 459
          (((exe_array + i)->e_line)->cl_file)->cf_running = (((exe_array + i)->e_line)->cl_file)->cf_running -
                                                             1;
#line 461
          if ((int )((exe_array + i)->e_line)->cl_option[0] & 64) {
#line 462
            ((exe_array + i)->e_line)->cl_option[0] = (unsigned char )((int )((exe_array +
                                                                               i)->e_line)->cl_option[0] &
                                                                       -65);
          }
        }
#line 465
        exe_num = (short )((int )exe_num - 1);
#line 465
        if ((int )i < exe_num) {
#line 466
          (*(exe_array + i)) = (*(exe_array + exe_num));
#line 467
          (exe_array + exe_num)->e_line = (struct cl_t *)((void *)0);
        } else {
#line 470
          (exe_array + i)->e_line = (struct cl_t *)((void *)0);
        }
#line 472
        break;
      }
#line 474
      i = (short )((int )i + 1);
    }
  }
#line 478
  return;
}
}
#line 481 "database.c"
int is_leap_year(int year ) 
{ int tmp ;

  {
#line 485
  if (year % 4 == 0) {
#line 485
    if (year % 100 != 0) {
#line 485
      tmp = 1;
    } else {
#line 485
      if (year % 400 == 0) {
#line 485
        tmp = 1;
      } else {
#line 485
        tmp = 0;
      }
    }
  } else {
#line 485
    tmp = 0;
  }
#line 485
  return (tmp);
}
}
#line 491 "database.c"
int get_nb_mdays(int year , int mon ) 
{ int tmp ;

  {
#line 495
  if (mon == 1) {
#line 496
    tmp = is_leap_year(year);
#line 496
    if (tmp) {
#line 497
      return (29);
    } else {
#line 499
      return (28);
    }
  } else {
#line 501
    if (mon <= 6) {
#line 502
      if (mon % 2 == 0) {
#line 503
        return (31);
      } else {
#line 505
        return (30);
      }
    } else {
#line 506
      if (mon % 2 == 0) {
#line 507
        return (30);
      } else {
#line 509
        return (31);
      }
    }
  }
}
}
#line 514 "database.c"
void set_wday(struct tm *date ) 
{ long nod ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 520
  nod = 0L;
#line 524
  i = date->tm_year - 1;
#line 524
  while (i >= 100) {
#line 525
    tmp___1 = is_leap_year(i + 1900);
#line 525
    if (tmp___1) {
#line 525
      tmp___0 = 366;
    } else {
#line 525
      tmp___0 = 365;
    }
#line 525
    nod += (long )tmp___0;
#line 524
    i --;
  }
#line 528
  i = date->tm_mon - 1;
#line 528
  while (i >= 0) {
#line 529
    tmp___2 = get_nb_mdays(date->tm_year + 1900, i);
#line 529
    nod += (long )tmp___2;
#line 528
    i --;
  }
#line 532
  nod += (long )(date->tm_mday - 1);
#line 534
  date->tm_wday = (int )(nod % 7L + 6L);
#line 536
  if (date->tm_wday >= 7) {
#line 537
    date->tm_wday = date->tm_wday - 7;
  }
#line 539
  if (debug_opt) {
#line 539
    Debug((char *)"   dow of %d-%d-%d : %d", date->tm_mon + 1, date->tm_mday, date->tm_year +
                                                                              1900,
          date->tm_wday);
  }
#line 542
  return;
}
}
#line 547 "database.c"
void goto_non_matching(cl_t *line , struct tm *ftime , char option ) 
{ struct tm next_period ;
  int max ;
  int tmp ;
  struct tm ftime_initial ;
  int to_add ;
  int tmp___0 ;
  int to_add___0 ;
  int tmp___1 ;
  short year_limit ;
  char ignore_mins ;
  int tmp___2 ;
  char ignore_hrs ;
  int tmp___3 ;
  char ignore_days ;
  int tmp___4 ;
  char ignore_mons ;
  int tmp___5 ;
  char ignore_dow ;
  int tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;

  {
#line 554
  if ((int )line->cl_option[2] & 4) {
#line 555
    tmp = get_nb_mdays(ftime->tm_year, ftime->tm_mon);
#line 555
    max = tmp;
#line 558
    if ((int )option == 1) {
#line 559
      memcpy((void */* __restrict  */)(& ftime_initial), (void const   */* __restrict  */)ftime,
             sizeof(ftime_initial));
    }
#line 561
    if ((int )line->cl_option[2] & 8) {
#line 562
      if ((int )line->cl_option[1] & 32) {
#line 564
        return;
      } else {
#line 565
        if ((int )line->cl_option[1] & 64) {
#line 566
          if (ftime->tm_min >= 30) {
#line 567
            ftime->tm_hour = ftime->tm_hour + 1;
          }
#line 568
          ftime->tm_min = 30;
        } else {
#line 570
          ftime->tm_min = 0;
#line 571
          if ((int )line->cl_option[1] & 128) {
#line 572
            if (ftime->tm_hour >= 12) {
#line 573
              ftime->tm_mday = ftime->tm_mday + 1;
            }
#line 574
            ftime->tm_hour = 12;
          } else {
#line 576
            ftime->tm_hour = 0;
#line 577
            if ((int )line->cl_option[2] & 2) {
#line 578
              if (ftime->tm_wday >= 4) {
#line 578
                tmp___0 = 11 - ftime->tm_wday;
              } else {
#line 578
                tmp___0 = 4 - ftime->tm_wday;
              }
#line 578
              to_add = tmp___0;
#line 580
              if (ftime->tm_mday + to_add > max) {
#line 581
                ftime->tm_mon = ftime->tm_mon + 1;
#line 582
                ftime->tm_mday = (ftime->tm_mday + to_add) - max;
              } else {
#line 584
                ftime->tm_mday = ftime->tm_mday + to_add;
              }
            } else {
#line 586
              if ((int )line->cl_option[2] & 1) {
#line 587
                if (ftime->tm_mday >= 15) {
#line 588
                  ftime->tm_mon = ftime->tm_mon + 1;
                }
#line 589
                ftime->tm_mday = 15;
              }
            }
          }
        }
      }
    } else {
#line 601
      if ((int )line->cl_option[1] & 32) {
#line 603
        return;
      } else {
#line 605
        ftime->tm_min = 0;
#line 606
        if ((int )line->cl_option[1] & 64) {
#line 607
          ftime->tm_hour = ftime->tm_hour + 1;
        } else {
#line 609
          ftime->tm_hour = 0;
#line 610
          if ((int )line->cl_option[1] & 128) {
#line 611
            ftime->tm_mday = ftime->tm_mday + 1;
          } else {
#line 613
            if ((int )line->cl_option[2] & 2) {
#line 614
              if (ftime->tm_wday == 0) {
#line 614
                tmp___1 = 1;
              } else {
#line 614
                tmp___1 = 8 - ftime->tm_wday;
              }
#line 614
              to_add___0 = tmp___1;
#line 615
              if (ftime->tm_mday + to_add___0 > max) {
#line 616
                ftime->tm_mday = (ftime->tm_mday + to_add___0) - max;
#line 617
                ftime->tm_mon = ftime->tm_mon + 1;
              } else {
#line 619
                ftime->tm_mday = ftime->tm_mday + to_add___0;
              }
            } else {
#line 621
              ftime->tm_mday = 1;
#line 622
              if ((int )line->cl_option[2] & 1) {
#line 623
                ftime->tm_mon = ftime->tm_mon + 1;
              }
            }
          }
        }
      }
    }
#line 630
    if (ftime->tm_min >= 60) {
#line 631
      ftime->tm_min = 0;
#line 632
      ftime->tm_hour = ftime->tm_hour + 1;
    }
#line 634
    if (ftime->tm_hour >= 24) {
#line 635
      ftime->tm_hour = 0;
#line 636
      ftime->tm_mday = ftime->tm_mday + 1;
    }
#line 639
    max = get_nb_mdays(ftime->tm_year + 1900, ftime->tm_mon);
#line 640
    if (ftime->tm_mday > max) {
#line 641
      ftime->tm_mday = 1;
#line 642
      ftime->tm_mon = ftime->tm_mon + 1;
    }
#line 644
    if (ftime->tm_mon >= 12) {
#line 645
      ftime->tm_mon = 0;
#line 646
      ftime->tm_year = ftime->tm_year + 1;
    }
#line 649
    if ((int )option != 1) {
#line 650
      if (debug_opt) {
#line 651
        set_wday(ftime);
      }
#line 652
      if (debug_opt) {
#line 652
        Debug((char *)"   %s beginning of next period %d/%d/%d wday:%d %02d:%02d (tzdiff=%d)",
              line->cl_shell, ftime->tm_mon + 1, ftime->tm_mday, ftime->tm_year +
                                                                 1900, ftime->tm_wday,
              ftime->tm_hour, ftime->tm_min, (line->cl_file)->cf_tzdiff);
      }
#line 657
      return;
    } else {
#line 660
      memcpy((void */* __restrict  */)(& next_period), (void const   */* __restrict  */)ftime,
             sizeof(next_period));
#line 662
      memcpy((void */* __restrict  */)ftime, (void const   */* __restrict  */)(& ftime_initial),
             sizeof(ftime_initial));
    }
  }
#line 673
  year_limit = 10;
#line 675
  if ((int )line->cl_option[1] & 32) {
#line 675
    tmp___2 = 1;
  } else {
#line 675
    tmp___2 = 0;
  }
#line 675
  ignore_mins = (char )tmp___2;
#line 676
  if ((int )line->cl_option[1] & 64) {
#line 676
    tmp___3 = 1;
  } else {
#line 676
    tmp___3 = 0;
  }
#line 676
  ignore_hrs = (char )tmp___3;
#line 677
  if ((int )line->cl_option[1] & 128) {
#line 677
    tmp___4 = 1;
  } else {
#line 677
    tmp___4 = 0;
  }
#line 677
  ignore_days = (char )tmp___4;
#line 678
  if ((int )line->cl_option[2] & 1) {
#line 678
    tmp___5 = 1;
  } else {
#line 678
    tmp___5 = 0;
  }
#line 678
  ignore_mons = (char )tmp___5;
#line 679
  if ((int )line->cl_option[2] & 2) {
#line 679
    tmp___6 = 1;
  } else {
#line 679
    tmp___6 = 0;
  }
#line 679
  ignore_dow = (char )tmp___6;
#line 681
  if ((int )option == 1) {
#line 683
    ignore_dow = 0;
#line 683
    ignore_mons = ignore_dow;
#line 683
    ignore_days = ignore_mons;
#line 683
    ignore_hrs = ignore_days;
#line 683
    ignore_mins = ignore_hrs;
  }
#line 686
  if (debug_opt) {
#line 686
    Debug((char *)"   ignore: %d %d %d %d %d", ignore_mins, ignore_hrs, ignore_days,
          ignore_mons, ignore_dow);
  }
#line 691
  while (1) {
#line 691
    if ((int )ignore_mins == 1) {
      goto _L___5;
    } else {
#line 691
      if ((int )line->cl_mins[ftime->tm_min >> 3] & (1 << (ftime->tm_min & 7))) {
        _L___5: /* CIL Label */ 
#line 691
        if ((int )ignore_hrs == 1) {
          goto _L___4;
        } else {
#line 691
          if ((int )line->cl_hrs[ftime->tm_hour >> 3] & (1 << (ftime->tm_hour & 7))) {
            _L___4: /* CIL Label */ 
#line 691
            if (! ((int )line->cl_option[0] & 8)) {
#line 691
              if ((int )ignore_days == 1) {
                goto _L___3;
              } else {
#line 691
                if ((int )line->cl_days[ftime->tm_mday >> 3] & (1 << (ftime->tm_mday &
                                                                      7))) {
                  _L___3: /* CIL Label */ 
#line 691
                  if ((int )ignore_dow == 1) {
                    goto _L___0;
                  } else {
#line 691
                    if ((int )line->cl_dow[ftime->tm_wday >> 3] & (1 << (ftime->tm_wday &
                                                                         7))) {
                      goto _L___0;
                    } else {
                      goto _L___2;
                    }
                  }
                } else {
                  goto _L___2;
                }
              }
            } else {
              _L___2: /* CIL Label */ 
#line 691
              if ((int )line->cl_option[0] & 8) {
#line 691
                if ((int )ignore_days == 1) {
                  goto _L___0;
                } else {
#line 691
                  if ((int )line->cl_days[ftime->tm_mday >> 3] & (1 << (ftime->tm_mday &
                                                                        7))) {
                    goto _L___0;
                  } else {
#line 691
                    if ((int )ignore_dow == 1) {
                      goto _L___0;
                    } else {
#line 691
                      if ((int )line->cl_dow[ftime->tm_wday >> 3] & (1 << (ftime->tm_wday &
                                                                           7))) {
                        _L___0: /* CIL Label */ 
#line 691
                        if (! ((int )ignore_mons == 1)) {
#line 691
                          if (! ((int )line->cl_mons[ftime->tm_mon >> 3] & (1 << (ftime->tm_mon &
                                                                                  7)))) {
#line 691
                            break;
                          }
                        }
                      } else {
#line 691
                        break;
                      }
                    }
                  }
                }
              } else {
#line 691
                break;
              }
            }
          } else {
#line 691
            break;
          }
        }
      } else {
#line 691
        break;
      }
    }
#line 705
    if (ignore_mins) {
#line 705
      ftime->tm_min = 60;
    } else {
#line 707
      while (1) {
#line 707
        ftime->tm_min = ftime->tm_min + 1;
#line 707
        if ((int )line->cl_mins[ftime->tm_min >> 3] & (1 << (ftime->tm_min & 7))) {
#line 707
          if (! (ftime->tm_min < 60)) {
#line 707
            break;
          }
        } else {
#line 707
          break;
        }
      }
    }
#line 711
    if (ftime->tm_min >= 60) {
#line 712
      ftime->tm_min = 0;
#line 713
      if (ignore_hrs) {
#line 713
        if (ignore_mins) {
#line 713
          ftime->tm_hour = 24;
        } else {
#line 714
          ftime->tm_hour = ftime->tm_hour + 1;
        }
      } else {
#line 714
        ftime->tm_hour = ftime->tm_hour + 1;
      }
#line 715
      if (ftime->tm_hour >= 24) {
#line 716
        ftime->tm_hour = 0;
#line 717
        if (ignore_days) {
#line 717
          if (ignore_hrs) {
#line 717
            if (ignore_mins) {
#line 717
              if (ignore_dow) {
#line 718
                ftime->tm_mday = 32;
              } else {
#line 719
                ftime->tm_mday = ftime->tm_mday + 1;
              }
            } else {
#line 719
              ftime->tm_mday = ftime->tm_mday + 1;
            }
          } else {
#line 719
            ftime->tm_mday = ftime->tm_mday + 1;
          }
        } else {
#line 719
          ftime->tm_mday = ftime->tm_mday + 1;
        }
#line 720
        tmp___7 = get_nb_mdays(ftime->tm_year + 1900, ftime->tm_mon);
#line 720
        if (ftime->tm_mday > tmp___7) {
#line 722
          ftime->tm_mday = 1;
#line 723
          if (ignore_mons) {
#line 723
            if (ignore_days) {
#line 723
              if (ignore_dow) {
#line 723
                if (ignore_hrs) {
#line 723
                  if (ignore_mins) {
#line 725
                    ftime->tm_mon = 12;
                  } else {
#line 726
                    ftime->tm_mon = ftime->tm_mon + 1;
                  }
                } else {
#line 726
                  ftime->tm_mon = ftime->tm_mon + 1;
                }
              } else {
#line 726
                ftime->tm_mon = ftime->tm_mon + 1;
              }
            } else {
#line 726
              ftime->tm_mon = ftime->tm_mon + 1;
            }
          } else {
#line 726
            ftime->tm_mon = ftime->tm_mon + 1;
          }
#line 727
          if (ftime->tm_mon >= 12) {
#line 728
            ftime->tm_mon = 0;
#line 729
            ftime->tm_year = ftime->tm_year + 1;
#line 730
            year_limit = (short )((int )year_limit - 1);
#line 730
            if (year_limit <= 0) {
#line 731
              error((char *)"Can\'t found a non matching date for %s in the next %d years. Maybe this line is corrupted : consider reinstalling the fcrontab",
                    line->cl_shell, 10);
#line 736
              return;
            }
          }
        }
#line 740
        set_wday(ftime);
      }
    }
#line 744
    if ((int )option == 1) {
#line 744
      if ((int )line->cl_option[2] & 4) {
#line 744
        if (ftime->tm_year <= next_period.tm_year) {
#line 744
          if (ftime->tm_mon <= next_period.tm_mon) {
#line 744
            if (ftime->tm_mday <= next_period.tm_mday) {
#line 744
              if (ftime->tm_hour <= next_period.tm_hour) {
#line 744
                if (ftime->tm_min <= next_period.tm_min) {
#line 752
                  memcpy((void */* __restrict  */)ftime, (void const   */* __restrict  */)(& next_period),
                         sizeof(next_period));
#line 753
                  break;
                }
              }
            }
          }
        }
      }
    }
  }
#line 757
  if ((int )option == 1) {
#line 760
    ftime->tm_min = ftime->tm_min - 1;
#line 760
    if (ftime->tm_min < 0) {
#line 761
      ftime->tm_min = 59;
#line 762
      ftime->tm_hour = ftime->tm_hour - 1;
#line 762
      if (ftime->tm_hour < 0) {
#line 763
        ftime->tm_hour = 23;
#line 764
        ftime->tm_mday = ftime->tm_mday - 1;
#line 764
        if (ftime->tm_mday < 1) {
#line 765
          ftime->tm_mon = ftime->tm_mon - 1;
#line 765
          if (ftime->tm_mon < 0) {
#line 766
            ftime->tm_mon = 11;
#line 767
            ftime->tm_year = ftime->tm_year - 1;
          }
#line 769
          ftime->tm_mday = get_nb_mdays(ftime->tm_year + 1900, ftime->tm_mon);
        }
      }
    }
  }
#line 776
  if (debug_opt) {
#line 776
    if ((int )option == 0) {
#line 776
      tmp___8 = "first non matching";
    } else {
#line 776
      tmp___8 = "end of interval";
    }
#line 776
    Debug((char *)"   %s %s %d/%d/%d wday:%d %02d:%02d (tzdiff=%d)", line->cl_shell,
          tmp___8, ftime->tm_mon + 1, ftime->tm_mday, ftime->tm_year + 1900, ftime->tm_wday,
          ftime->tm_hour, ftime->tm_min, (line->cl_file)->cf_tzdiff);
  }
#line 781
  return;
}
}
#line 786 "database.c"
void set_next_exe(struct cl_t *line , char option , int info_fd ) 
{ time_t basetime ;
  struct tm *ft ;
  struct tm ftime ;
  time_t nextexe ;
  int i ;
  int max ;
  char has_changed ;
  short year_limit ;
  time_t basetime_tz ;
  int j ;
  struct tm intend ;
  time_t intend_int ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 795
  if ((int )option & 4) {
#line 795
    basetime = line->cl_nextexe;
  } else {
#line 795
    basetime = now;
  }
#line 797
  if (! ((int )line->cl_option[0] & 1)) {
#line 799
    nextexe = (time_t )0;
#line 802
    has_changed = 0;
#line 804
    year_limit = 10;
#line 806
    basetime_tz = basetime - (time_t )((int )(line->cl_file)->cf_tzdiff * 3600);
#line 808
    ft = localtime((time_t const   *)(& basetime_tz));
#line 813
    memcpy((void */* __restrict  */)(& ftime), (void const   */* __restrict  */)ft,
           sizeof(struct tm ));
#line 820
    if (first_sleep > 0L) {
#line 821
      ftime.tm_min = ftime.tm_min + 1;
#line 822
      ftime.tm_sec = 0;
    } else {
#line 820
      if ((int )option == 0) {
#line 821
        ftime.tm_min = ftime.tm_min + 1;
#line 822
        ftime.tm_sec = 0;
      } else {
#line 820
        if ((int )line->cl_runfreq != 1) {
#line 821
          ftime.tm_min = ftime.tm_min + 1;
#line 822
          ftime.tm_sec = 0;
        }
      }
    }
#line 825
    if ((int )line->cl_runfreq == 1) {
#line 825
      if ((int )option != 1) {
#line 825
        if ((int )option != 2) {
#line 826
          goto_non_matching(line, & ftime, 0);
        }
      }
    }
    setMonth: 
#line 829
    i = ftime.tm_mon;
#line 829
    while (1) {
#line 829
      if (((int )line->cl_mons[i >> 3] & (1 << (i & 7))) == 0) {
#line 829
        if (! (i < 12)) {
#line 829
          break;
        }
      } else {
#line 829
        break;
      }
#line 829
      i ++;
    }
#line 830
    if (i >= 12) {
#line 831
      ftime.tm_year = ftime.tm_year + 1;
#line 832
      year_limit = (short )((int )year_limit - 1);
#line 832
      if (year_limit <= 0) {
#line 833
        error((char *)"Can\'t found a matching date for %s in the next %d years. Maybe this line is corrupted : consider reinstalling the fcrontab.",
              line->cl_shell, 10);
        goto set_cl_nextexe;
      }
#line 839
      if ((int )has_changed < 3) {
#line 840
        has_changed = 3;
#line 841
        ftime.tm_mon = 0;
#line 842
        ftime.tm_mday = 1;
#line 843
        ftime.tm_hour = 0;
#line 844
        ftime.tm_min = 0;
      } else {
#line 846
        ftime.tm_mon = 0;
      }
      goto setMonth;
    }
#line 849
    if (ftime.tm_mon != i) {
#line 850
      ftime.tm_mon = i;
#line 851
      if ((int )has_changed < 2) {
#line 852
        has_changed = 2;
#line 853
        ftime.tm_mday = 1;
#line 854
        ftime.tm_hour = 0;
#line 855
        ftime.tm_min = 0;
      }
    }
#line 860
    max = get_nb_mdays(ftime.tm_year + 1900, ftime.tm_mon);
    setDay: 
#line 863
    if (! ((int )line->cl_option[0] & 8)) {
#line 864
      i = ftime.tm_mday;
#line 864
      while (1) {
#line 864
        if (((int )line->cl_days[i >> 3] & (1 << (i & 7))) == 0) {
#line 864
          if (! (i <= max)) {
#line 864
            break;
          }
        } else {
#line 864
          break;
        }
#line 864
        i ++;
      }
#line 866
      if (i > max) {
#line 867
        ftime.tm_mon = ftime.tm_mon + 1;
#line 868
        if ((int )has_changed < 2) {
#line 869
          has_changed = 2;
#line 870
          ftime.tm_mday = 1;
#line 871
          ftime.tm_hour = 0;
#line 872
          ftime.tm_min = 0;
        } else {
#line 874
          ftime.tm_mday = 1;
        }
        goto setMonth;
      }
#line 877
      if (ftime.tm_mday != i) {
#line 878
        ftime.tm_mday = i;
#line 879
        if ((int )has_changed < 1) {
#line 880
          has_changed = 1;
#line 881
          ftime.tm_hour = 0;
#line 882
          ftime.tm_min = 0;
        }
      }
#line 886
      set_wday(& ftime);
#line 889
      if (((int )line->cl_dow[ftime.tm_wday >> 3] & (1 << (ftime.tm_wday & 7))) ==
          0) {
#line 890
        ftime.tm_mday = ftime.tm_mday + 1;
#line 891
        ftime.tm_hour = 0;
#line 892
        ftime.tm_min = 0;
        goto setDay;
      }
    } else {
#line 898
      set_wday(& ftime);
#line 900
      j = ftime.tm_wday;
#line 901
      i = ftime.tm_mday;
#line 902
      while (1) {
#line 902
        if (((int )line->cl_days[i >> 3] & (1 << (i & 7))) == 0) {
#line 902
          if (! (((int )line->cl_dow[j >> 3] & (1 << (j & 7))) == 0)) {
#line 902
            break;
          }
        } else {
#line 902
          break;
        }
#line 904
        if (i > max) {
#line 905
          ftime.tm_mon = ftime.tm_mon + 1;
#line 906
          if ((int )has_changed < 2) {
#line 907
            has_changed = 2;
#line 908
            ftime.tm_mday = 1;
#line 909
            ftime.tm_hour = 0;
#line 910
            ftime.tm_min = 0;
          } else {
#line 912
            ftime.tm_mday = 1;
          }
          goto setMonth;
        }
#line 915
        if (j >= 7) {
#line 916
          j -= 7;
        }
#line 917
        i ++;
#line 918
        j ++;
      }
#line 920
      if (ftime.tm_mday != i) {
#line 921
        ftime.tm_mday = i;
#line 922
        if ((int )has_changed < 1) {
#line 923
          has_changed = 1;
#line 924
          ftime.tm_hour = 0;
#line 925
          ftime.tm_min = 0;
        }
      }
    }
    setHour: 
#line 931
    i = ftime.tm_hour;
#line 931
    while (1) {
#line 931
      if (((int )line->cl_hrs[i >> 3] & (1 << (i & 7))) == 0) {
#line 931
        if (! (i < 24)) {
#line 931
          break;
        }
      } else {
#line 931
        break;
      }
#line 931
      i ++;
    }
#line 932
    if (i >= 24) {
#line 933
      ftime.tm_mday = ftime.tm_mday + 1;
#line 934
      if ((int )has_changed < 1) {
#line 935
        has_changed = 1;
#line 936
        ftime.tm_hour = 0;
#line 937
        ftime.tm_min = 0;
      } else {
#line 939
        ftime.tm_hour = 0;
      }
      goto setDay;
    }
#line 942
    if (ftime.tm_hour != i) {
#line 943
      ftime.tm_hour = i;
#line 944
      ftime.tm_min = 0;
    }
#line 948
    i = ftime.tm_min;
#line 948
    while (1) {
#line 948
      if (((int )line->cl_mins[i >> 3] & (1 << (i & 7))) == 0) {
#line 948
        if (! (i < 60)) {
#line 948
          break;
        }
      } else {
#line 948
        break;
      }
#line 948
      i ++;
    }
#line 949
    if (i >= 60) {
#line 950
      ftime.tm_hour = ftime.tm_hour + 1;
#line 951
      ftime.tm_min = 0;
      goto setHour;
    }
#line 954
    ftime.tm_min = i;
    set_cl_nextexe: 
#line 958
    nextexe = mktime(& ftime);
#line 960
    if ((int )line->cl_option[2] & 128) {
#line 965
      if (debug_opt) {
#line 965
        Debug((char *)"   cmd: %s begin int exec %d/%d/%d wday:%d %02d:%02d (tzdiff=%d)",
              line->cl_shell, ftime.tm_mon + 1, ftime.tm_mday, ftime.tm_year + 1900,
              ftime.tm_wday, ftime.tm_hour, ftime.tm_min, (line->cl_file)->cf_tzdiff);
      }
#line 970
      memcpy((void */* __restrict  */)(& intend), (void const   */* __restrict  */)(& ftime),
             sizeof(intend));
#line 971
      goto_non_matching(line, & intend, 1);
#line 972
      intend_int = mktime(& intend);
#line 975
      i = (int )(intend_int - nextexe);
#line 975
      if (i > 0) {
#line 975
        tmp___1 = rand();
#line 975
        tmp___0 = (long )(((float )i * (float )tmp___1) / (float )2147483647);
      } else {
#line 975
        tmp___0 = 0L;
      }
#line 975
      nextexe += tmp___0;
    }
#line 979
    line->cl_nextexe = nextexe + (time_t )((int )(line->cl_file)->cf_tzdiff * 3600);
#line 981
    if ((int )option != 1) {
#line 982
      if ((int )line->cl_option[2] & 128) {
#line 983
        ft = localtime((time_t const   *)(& nextexe));
#line 984
        memcpy((void */* __restrict  */)(& ftime), (void const   */* __restrict  */)ft,
               sizeof(ftime));
      }
#line 986
      send_msg_fd_debug(info_fd, (char *)"   cmd: %s next exec %d/%d/%d wday:%d %02d:%02d (tzdiff=%d w/ sys time)",
                        line->cl_shell, ftime.tm_mon + 1, ftime.tm_mday, ftime.tm_year +
                                                                         1900, ftime.tm_wday,
                        ftime.tm_hour, ftime.tm_min, (line->cl_file)->cf_tzdiff);
    }
#line 1004
    if (line->cl_nextexe <= now) {
#line 1005
      error((char *)"BUG ??? Fcron thinks the next exe time of %s is %ld, hence before now (%ld). To avoid infinite loop, nextexe will be set at now+5s.");
#line 1008
      line->cl_nextexe = now + 5L;
    }
  } else {
#line 1015
    line->cl_nextexe = basetime + line->cl_timefreq;
#line 1017
    ft = localtime((time_t const   *)(& line->cl_nextexe));
#line 1022
    memcpy((void */* __restrict  */)(& ftime), (void const   */* __restrict  */)ft,
           sizeof(struct tm ));
#line 1024
    send_msg_fd_debug(info_fd, (char *)"   cmd: %s next exec %d/%d/%d wday:%d %02d:%02d (system time)",
                      line->cl_shell, ftime.tm_mon + 1, ftime.tm_mday, ftime.tm_year +
                                                                       1900, ftime.tm_wday,
                      ftime.tm_hour, ftime.tm_min);
  }
#line 1030
  insert_nextexe(line);
#line 1032
  return;
}
}
#line 1035 "database.c"
void set_next_exe_notrun(struct cl_t *line , char context ) 
{ time_t previous_period ;
  time_t next_period ;
  struct tm *ft ;
  struct tm ftime ;
  struct tm last_nextexe ;
  char set_next_exe_opt ;
  time_t tmp ;

  {
#line 1040
  previous_period = (time_t )0;
#line 1040
  next_period = (time_t )0;
#line 1041
  ft = (struct tm *)((void *)0);
#line 1043
  set_next_exe_opt = 0;
#line 1046
  if (debug_opt) {
#line 1046
    Debug((char *)"  set_next_exe_notrun : %s %d", line->cl_shell, context);
  }
#line 1049
  if ((int )context == 2) {
#line 1051
    previous_period = line->cl_nextexe - (time_t )((int )(line->cl_file)->cf_tzdiff *
                                                   3600);
#line 1052
    set_next_exe_opt = 1;
  } else {
#line 1055
    previous_period = now - (time_t )((int )(line->cl_file)->cf_tzdiff * 3600);
#line 1056
    set_next_exe_opt = 2;
  }
#line 1058
  ft = localtime((time_t const   *)(& previous_period));
#line 1063
  memcpy((void */* __restrict  */)(& ftime), (void const   */* __restrict  */)ft,
         sizeof(ftime));
#line 1065
  memcpy((void */* __restrict  */)(& last_nextexe), (void const   */* __restrict  */)ft,
         sizeof(last_nextexe));
#line 1067
  ftime.tm_sec = 0;
#line 1068
  goto_non_matching(line, & ftime, 0);
#line 1069
  tmp = mktime(& ftime);
#line 1069
  next_period = tmp + (time_t )((int )(line->cl_file)->cf_tzdiff * 3600);
#line 1071
  set_next_exe(line, set_next_exe_opt, -1);
#line 1072
  if (line->cl_nextexe >= next_period) {
#line 1074
    mail_notrun(line, context, & last_nextexe);
  }
#line 1077
  return;
}
}
#line 1079 "database.c"
void mail_notrun(struct cl_t *line , char context , struct tm *since ) 
{ int pid ;
  FILE *mailf ;
  struct tm *time2 ;
  struct tm time___0 ;
  int tmp ;

  {
#line 1083
  pid = 0;
#line 1084
  mailf = (FILE *)0;
#line 1085
  time2 = (struct tm *)((void *)0);
#line 1087
  pid = fork();
#line 1087
  switch (pid) {
  case -1: 
#line 1089
  error_e((char *)"Fork error : could not mail for not run %s", line->cl_shell);
#line 1090
  return;
  case 0: ;
#line 1093
  break;
  default: ;
#line 1098
  if (debug_opt) {
#line 1098
    Debug((char *)"Reporting by mail non execution of %s (pid %d)", line->cl_shell,
          pid);
  }
#line 1103
  if ((int )exe_num >= (int )exe_array_size) {
#line 1104
    resize_exe_array();
  }
#line 1106
  (exe_array + exe_num)->e_line = (struct cl_t *)((void *)0);
#line 1107
  (exe_array + exe_num)->e_ctrl_pid = pid;
#line 1108
  exe_num = (short )((int )exe_num + 1);
#line 1109
  return;
  }
#line 1112
  if ((int )context == 3) {
#line 1113
    time2 = localtime((time_t const   *)(& now));
  } else {
#line 1115
    time2 = localtime((time_t const   *)(& line->cl_nextexe));
  }
#line 1116
  memcpy((void */* __restrict  */)(& time___0), (void const   */* __restrict  */)time2,
         sizeof(time___0));
#line 1119
  mailf = create_mail(line, (char *)"Non-execution of fcron job");
#line 1121
  switch ((int )context) {
  case 2: 
#line 1123
  fprintf((FILE */* __restrict  */)mailf, (char const   */* __restrict  */)"Line %s has not run since and including %d/%d/%d wday:%d %02d:%02d\ndue to system\'s down state.\n",
          line->cl_shell, since->tm_mon + 1, since->tm_mday, since->tm_year + 1900,
          since->tm_wday, since->tm_hour, since->tm_min);
#line 1128
  fprintf((FILE */* __restrict  */)mailf, (char const   */* __restrict  */)"It will be next executed at %d/%d/%d wday:%d %02d:%02d\n",
          time___0.tm_mon + 1, time___0.tm_mday, time___0.tm_year + 1900, time___0.tm_wday,
          time___0.tm_hour, time___0.tm_min);
#line 1131
  break;
  case 1: 
#line 1133
  fprintf((FILE */* __restrict  */)mailf, (char const   */* __restrict  */)"Line %s has not run since and including %d/%d/%d wday:%d %02d:%02d\n",
          line->cl_shell, since->tm_mon + 1, since->tm_mday, since->tm_year + 1900,
          since->tm_wday, since->tm_hour, since->tm_min);
#line 1137
  fprintf((FILE */* __restrict  */)mailf, (char const   */* __restrict  */)"due to a too high system load average or too many lavg-serial jobs.\n");
#line 1139
  fprintf((FILE */* __restrict  */)mailf, (char const   */* __restrict  */)"It will be next executed at %d/%d/%d wday:%d %02d:%02d\n",
          time___0.tm_mon + 1, time___0.tm_mday, time___0.tm_year + 1900, time___0.tm_wday,
          time___0.tm_hour, time___0.tm_min);
#line 1142
  break;
  case 3: 
#line 1144
  fprintf((FILE */* __restrict  */)mailf, (char const   */* __restrict  */)"Line %s couldn\'t be added to lavg or serial queue which is full ( %d/%d/%d wday:%d %02d:%02d ).\n",
          line->cl_shell, time___0.tm_mon + 1, time___0.tm_mday, time___0.tm_year +
                                                                 1900, time___0.tm_wday,
          time___0.tm_hour, time___0.tm_min);
#line 1148
  fprintf((FILE */* __restrict  */)mailf, (char const   */* __restrict  */)"Consider using options lavgonce, until, strict, serialonce and/or fcron\'s option -m.\n");
#line 1150
  fprintf((FILE */* __restrict  */)mailf, (char const   */* __restrict  */)"Note that job %s has not run.\n",
          line->cl_shell);
#line 1151
  break;
  }
#line 1155
  tmp = change_user(line);
#line 1155
  if (tmp < 0) {
#line 1156
    return;
  }
#line 1159
  launch_mailer(line, mailf);
#line 1162
  error((char *)"mail_notrun : launch_mailer failed");
}
}
#line 1166 "database.c"
time_t check_lavg(time_t lim ) 
{ time_t tts ;
  int i ;
  double l_avg[3] ;
  char const   *tmp ;
  time_t tmp___0 ;

  {
#line 1171
  tts = (time_t )0;
#line 1181
  i = 0;
#line 1182
  l_avg[0] = (double )0;
#line 1182
  l_avg[1] = (double )0;
#line 1182
  l_avg[2] = (double )0;
#line 1185
  while (i < (int )lavg_num) {
#line 1186
    if (((lavg_array + i)->l_line)->cl_until > 0L) {
      goto _L;
    } else {
#line 1186
      if ((int )((lavg_array + i)->l_line)->cl_runfreq == 1) {
        _L: /* CIL Label */ 
#line 1186
        if ((lavg_array + i)->l_until < now) {
#line 1189
          if (! ((int )((lavg_array + i)->l_line)->cl_option[1] & 2)) {
#line 1190
            if (! ((int )((lavg_array + i)->l_line)->cl_option[2] & 64)) {
#line 1191
              explain((char *)"Interval of execution exceeded : %s (not run)", ((lavg_array +
                                                                                 i)->l_line)->cl_shell);
            }
#line 1195
            if (! ((int )((lavg_array + i)->l_line)->cl_option[0] & 1)) {
#line 1195
              if ((int )((lavg_array + i)->l_line)->cl_option[2] & 32) {
#line 1197
                set_next_exe_notrun((lavg_array + i)->l_line, 1);
              } else {
#line 1199
                set_next_exe((lavg_array + i)->l_line, 2, -1);
              }
            } else {
#line 1199
              set_next_exe((lavg_array + i)->l_line, 2, -1);
            }
#line 1202
            ((lavg_array + i)->l_line)->cl_numexe = (unsigned char )((int )((lavg_array +
                                                                             i)->l_line)->cl_numexe -
                                                                     1);
#line 1203
            lavg_num = (short )((int )lavg_num - 1);
#line 1203
            if (i < lavg_num) {
#line 1204
              (*(lavg_array + i)) = (*(lavg_array + lavg_num));
#line 1205
              (lavg_array + lavg_num)->l_line = (struct cl_t *)((void *)0);
            } else {
#line 1208
              (lavg_array + i)->l_line = (struct cl_t *)((void *)0);
            }
          } else {
#line 1212
            if (debug_opt) {
#line 1212
              Debug((char *)"until %s %d", ((lavg_array + i)->l_line)->cl_shell, (lavg_array +
                                                                                  i)->l_until);
            }
#line 1214
            run_lavg_job(i);
          }
        } else {
#line 1217
          i ++;
        }
      } else {
#line 1217
        i ++;
      }
    }
  }
#line 1220
  tts = time_to_sleep(lim);
#line 1222
  if ((int )lavg_num == 0) {
#line 1223
    return (tts);
  }
#line 1225
  i = getloadavg(l_avg, 3);
#line 1225
  if (i != 3) {
#line 1226
    if (debug_opt) {
#line 1226
      Debug((char *)"got only %d lavg values", i);
    }
  }
#line 1227
  if (debug_opt) {
#line 1227
    Debug((char *)"get_lavg: %lf, %lf, %lf", l_avg[0], l_avg[1], l_avg[2]);
  }
#line 1229
  l_avg[0] *= (double )10;
#line 1230
  l_avg[1] *= (double )10;
#line 1231
  l_avg[2] *= (double )10;
#line 1232
  i = 0;
#line 1233
  while (i < (int )lavg_num) {
#line 1235
    if ((int )lavg_serial_running >= (int )serial_max_running) {
#line 1235
      if ((int )((lavg_array + i)->l_line)->cl_option[0] & 32) {
#line 1237
        i ++;
#line 1238
        continue;
      }
    }
#line 1240
    if (! ((int )((lavg_array + i)->l_line)->cl_option[0] & 4)) {
#line 1240
      if (l_avg[0] < (double )((lavg_array + i)->l_line)->cl_lavg[0]) {
        goto _L___6;
      } else {
#line 1240
        if ((int )((lavg_array + i)->l_line)->cl_lavg[0] == 0) {
          _L___6: /* CIL Label */ 
#line 1240
          if (l_avg[1] < (double )((lavg_array + i)->l_line)->cl_lavg[1]) {
            goto _L___4;
          } else {
#line 1240
            if ((int )((lavg_array + i)->l_line)->cl_lavg[1] == 0) {
              _L___4: /* CIL Label */ 
#line 1240
              if (l_avg[2] < (double )((lavg_array + i)->l_line)->cl_lavg[2]) {
                goto _L___1;
              } else {
#line 1240
                if ((int )((lavg_array + i)->l_line)->cl_lavg[2] == 0) {
                  goto _L___1;
                } else {
                  goto _L___5;
                }
              }
            } else {
              goto _L___5;
            }
          }
        } else {
          goto _L___5;
        }
      }
    } else {
      _L___5: /* CIL Label */ 
#line 1240
      if ((int )((lavg_array + i)->l_line)->cl_option[0] & 4) {
#line 1240
        if (l_avg[0] < (double )((lavg_array + i)->l_line)->cl_lavg[0]) {
          goto _L___1;
        } else {
#line 1240
          if (l_avg[1] < (double )((lavg_array + i)->l_line)->cl_lavg[1]) {
            goto _L___1;
          } else {
#line 1240
            if (l_avg[2] < (double )((lavg_array + i)->l_line)->cl_lavg[2]) {
              _L___1: /* CIL Label */ 
#line 1255
              if (debug_opt) {
#line 1255
                if ((int )((lavg_array + i)->l_line)->cl_option[0] & 4) {
#line 1255
                  tmp = "or";
                } else {
#line 1255
                  tmp = "and";
                }
#line 1255
                Debug((char *)"lavg %s %s %.0f:%d %.0f:%d %.0f:%d", ((lavg_array +
                                                                      i)->l_line)->cl_shell,
                      tmp, l_avg[0], ((lavg_array + i)->l_line)->cl_lavg[0], l_avg[1],
                      ((lavg_array + i)->l_line)->cl_lavg[1], l_avg[2], ((lavg_array +
                                                                          i)->l_line)->cl_lavg[2]);
              }
#line 1261
              run_lavg_job(i);
            } else {
#line 1264
              i ++;
            }
          }
        }
      } else {
#line 1264
        i ++;
      }
    }
  }
#line 1268
  if ((int )lavg_num == 0) {
#line 1269
    return (tts);
  } else {
#line 1271
    if (30L < tts) {
#line 1271
      tmp___0 = 30L;
    } else {
#line 1271
      tmp___0 = tts;
    }
#line 1271
    return (tmp___0);
  }
}
}
#line 1277 "database.c"
time_t time_to_sleep(time_t lim ) 
{ time_t tts ;
  time_t ti ;
  time_t tmp ;

  {
#line 1283
  tts = lim;
#line 1284
  tmp = time((time_t *)((void *)0));
#line 1284
  ti = tmp;
#line 1287
  if ((unsigned int )queue_base != (unsigned int )((void *)0)) {
#line 1288
    if ((queue_base->j_line)->cl_nextexe < lim) {
#line 1289
      tts = (queue_base->j_line)->cl_nextexe;
    }
  }
#line 1292
  tts = tts - ti;
#line 1293
  if (tts < 0L) {
#line 1294
    tts = 0L;
  }
#line 1298
  return (tts);
}
}
#line 1 "job.o"
/* #pragma merger(0,"./job.i","-O2 -Wall") */
#line 123 "/users/rupak/ccured/include/ccuredannot.h"
/* #pragma cilnoremove("__ccuredInit") */
#line 20 "/users/rupak/ccured/include/ccured.h"
/* #pragma cilnoremove("wrapperAlloc") */
#line 21
/* #pragma ccuredalloc("wrapperAlloc",sizein(1),nozero) */
#line 24
/* #pragma cilnoremove("wrapperFree") */
#line 25
/* #pragma ccuredpoly("wrapperFree") */
#line 29
/* #pragma cilnoremove("wrapperStrdup") */
#line 30
/* #pragma ccuredpoly("wrapperStrdup") */
#line 50
/* #pragma ccuredpoly("__ptrof_nocheck") */
#line 51
/* #pragma cilnoremove("__ptrof_nocheck") */
#line 57
/* #pragma ccuredpoly("__startof") */
#line 63
/* #pragma ccuredpoly("__endof") */
#line 78
/* #pragma ccuredpoly("__ptrof") */
#line 84
/* #pragma ccuredpoly("__ptrof_size") */
#line 85
/* #pragma cilnoremove("__ptrof_size") */
#line 92
/* #pragma ccuredpoly("__verify_nul") */
#line 101
/* #pragma ccuredpoly("__strlen") */
#line 111
/* #pragma ccuredpoly("__strlen_n") */
#line 125
/* #pragma ccuredpoly("__stringof") */
#line 127
/* #pragma cilnoremove("__stringof") */
#line 136
/* #pragma ccuredpoly("__stringof_ornull") */
#line 138
/* #pragma cilnoremove("__stringof_ornull") */
#line 147
/* #pragma ccuredpoly("__write_at_least") */
#line 155
/* #pragma ccuredpoly("__read_at_least") */
#line 162
/* #pragma ccuredpoly("__copytags") */
#line 180
/* #pragma ccuredpoly("__mkptr") */
#line 181
/* #pragma cilnoremove("__mkptr") */
#line 188
/* #pragma ccuredpoly("__mkptr_int") */
#line 196
/* #pragma ccuredpoly("__mkptr_size") */
#line 197
/* #pragma cilnoremove("__mkptr_size") */
#line 206
/* #pragma ccuredpoly("__mkptr_string") */
#line 207
/* #pragma cilnoremove("__mkptr_string") */
#line 215
/* #pragma ccuredpoly("__align_seq") */
#line 216
/* #pragma cilnoremove("__align_seq") */
#line 227
/* #pragma ccuredpoly("__trusted_cast") */
#line 228
/* #pragma cilnoremove("__trusted_cast") */
#line 237
/* #pragma ccuredpoly("__trusted_deepcast") */
#line 238
/* #pragma cilnoremove("__trusted_deepcast") */
#line 250
/* #pragma ccuredpoly("ccured_hasuniontag") */
#line 259
/* #pragma ccuredpoly("__ccured_kind_of") */
#line 307
/* #pragma ccuredpoly("__ccured_mangling_of") */
#line 308
/* #pragma cilnoremove("__ccured_mangling_of") */
#line 312
/* #pragma ccuredpoly("__ccured_has_empty_mangling") */
#line 313
/* #pragma cilnoremove("__ccured_has_empty_mangling") */
#line 327
/* #pragma cilnoremove("abort_deepcopy") */
#line 451
/* #pragma cilnoremove("struct printf_arguments") */
#line 45 "/users/rupak/ccured/include/time_wrappers.h"
/* #pragma ccuredwrapper("time_wrapper",of("time")) */
#line 59
/* #pragma ccuredwrapper("ctime_wrapper",of("ctime")) */
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments )) */
#line 266
/* #pragma ccuredpoly("__ccured_va_arg") */
#line 303
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___0 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___0 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___0 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___0 )) */
#line 69 "/users/rupak/ccured/include/io_wrappers.h"
/* #pragma ccuredwrapper("unlink_wrapper",of("unlink")) */
#line 79
/* #pragma ccuredwrapper("open_wrapper",of("open")) */
#line 80
/* #pragma ccuredvararg("open_wrapper",sizeof(int )) */
#line 123
/* #pragma ccuredwrapper("rename_wrapper",of("rename")) */
#line 6 "/users/rupak/ccured/include/malloc_wrappers.h"
/* #pragma ccuredalloc("malloc",nozero,sizein(1)) */
#line 8
/* #pragma ccuredpoly("realloc") */
#line 9
/* #pragma ccuredwrapper("realloc_wrapper",of("realloc")) */
#line 22
/* #pragma ccuredwrapper("free_wrapper",of("free")) */
#line 27
/* #pragma ccuredalloc("alloca",nozero,sizein(1)) */
#line 28
/* #pragma ccuredalloc("calloc",zero,sizemul(1,2)) */
#line 46 "/users/rupak/ccured/include/string_wrappers.h"
/* #pragma ccuredwrapper("strlen_wrapper",of("strlen")) */
#line 52
/* #pragma ccuredwrapper("bzero_wrapper",of("bzero")) */
#line 61
/* #pragma ccuredwrapper("strcpy_wrapper",of("strcpy")) */
#line 81
/* #pragma ccuredwrapper("strncpy_wrapper",of("strncpy")) */
#line 95
/* #pragma ccuredwrapper("strcat_wrapper",of("strcat")) */
#line 111
/* #pragma ccuredwrapper("strncat_wrapper",of("strncat")) */
#line 128
/* #pragma ccuredwrapper("strchr_wrapper",of("strchr")) */
#line 137
/* #pragma ccuredwrapper("strrchr_wrapper",of("strrchr")) */
#line 146
/* #pragma ccuredwrapper("strdup_wrapper",of("strdup")) */
#line 167
/* #pragma ccuredwrapper("strcasecmp_wrapper",of("strcasecmp")) */
#line 173
/* #pragma ccuredwrapper("strcmp_wrapper",of("strcmp")) */
#line 180
/* #pragma ccuredwrapper("strncasecmp_wrapper",of("strncasecmp")) */
#line 194
/* #pragma ccuredwrapper("strncmp_wrapper",of("strncmp")) */
#line 208
/* #pragma ccuredwrapper("strpbrk_wrapper",of("strpbrk")) */
#line 217
/* #pragma ccuredwrapper("strsep_wrapper",of("strsep")) */
#line 234
/* #pragma ccuredwrapper("strtoul_wrapper",of("strtoul")) */
#line 47 "/users/rupak/ccured/include/stdlib_wrappers.h"
/* #pragma ccuredwrapper("atof_wrapper",of("atof")) */
#line 55
/* #pragma ccuredwrapper("atoi_wrapper",of("atoi")) */
#line 63
/* #pragma ccuredwrapper("atol_wrapper",of("atol")) */
#line 93
/* #pragma ccuredpoly("qsort_zero_tags") */
#line 172
/* #pragma ccuredwrapper("qsort_wrapper",of("qsort")) */
#line 216
/* #pragma ccuredwrapper("bsearch_wrapper",of("bsearch")) */
#line 254
/* #pragma ccuredwrapper("strtol_wrapper",of("strtol")) */
#line 270
/* #pragma ccuredwrapper("getenv_wrapper",of("getenv")) */
#line 256 "/users/rupak/ccured/include/string_wrappers.h"
/* #pragma ccuredwrapper("strtok_wrapper",of("strtok")) */
#line 269
/* #pragma ccuredwrapper("strtok_r_wrapper",of("strtok_r")) */
#line 319
/* #pragma ccuredwrapper("memcmp_wrapper",of("memcmp")) */
#line 332
/* #pragma ccuredwrapper("memset_wrapper",of("memset")) */
#line 341
/* #pragma ccuredwrapper("memmove_wrapper",of("memmove")) */
#line 353
/* #pragma ccuredwrapper("memcpy_wrapper",of("memcpy")) */
#line 366
/* #pragma ccuredwrapper("strerror_wrapper",of("strerror")) */
#line 374
/* #pragma ccuredwrapper("strstr_wrapper",of("strstr")) */
#line 383
/* #pragma ccuredwrapper("memchr_wrapper",of("memchr")) */
#line 50 "/users/rupak/ccured/include/pwd_wrappers.h"
/* #pragma ccuredwrapper("getpwnam_wrapper",of("getpwnam")) */
#line 68
/* #pragma ccuredwrapper("getpwuid_wrapper",of("getpwuid")) */
#line 81
/* #pragma ccuredwrapper("getpwent_wrapper",of("getpwent")) */
#line 56 "/users/rupak/ccured/include/signal_wrappers.h"
/* #pragma ccuredpoly("__mkfat_sighandler") */
#line 66
/* #pragma ccuredwrapper("signal_wrapper",of("signal")) */
#line 88
/* #pragma ccuredwrapper("sigaction_wrapper",of("sigaction")) */
#line 168 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredpoly("get_stdin") */
#line 170
/* #pragma ccuredpoly("get_stdout") */
#line 172
/* #pragma ccuredpoly("get_stderr") */
#line 59 "/users/rupak/ccured/include/stdio_wrappers.h"
/* #pragma ccuredpoly("__mkptr_file") */
#line 65
/* #pragma ccuredpoly("__ptrof_file") */
#line 68
/* #pragma ccuredvararg("printf",printf(1)) */
#line 69
/* #pragma ccuredvararg("fprintf",printf(2)) */
#line 70
/* #pragma ccuredvararg("snprintf",printf(3)) */
#line 71
/* #pragma ccuredvararg("syslog",printf(2)) */
#line 72
/* #pragma ccuredvararg("sprintf",printf(2)) */
#line 73
/* #pragma ccuredvararg("vsprintf",printf(2)) */
#line 74
/* #pragma ccuredvararg("vfprintf",printf(2)) */
#line 75
/* #pragma ccuredvararg("vprintf",printf(1)) */
#line 76
/* #pragma ccuredvararg("vsyslog",printf(2)) */
#line 78
/* #pragma ccuredpoly("__endof") */
#line 89
/* #pragma ccuredpoly("ccured_fscanf_string") */
#line 92
/* #pragma ccuredwrapper("ccured_fscanf_string_wrapper",of("ccured_fscanf_string")) */
#line 117
/* #pragma ccuredvararg("sscanf",sizeof(struct scanf_format )) */
#line 118
/* #pragma ccuredvararg("fscanf",sizeof(struct scanf_format )) */
#line 123
/* #pragma ccuredwrapper("fgets_wrapper",of("fgets")) */
#line 132
/* #pragma ccuredwrapper("fopen_wrapper",of("fopen")) */
#line 139
/* #pragma ccuredwrapper("fdopen_wrapper",of("fdopen")) */
#line 146
/* #pragma ccuredwrapper("fflush_wrapper",of("fflush")) */
#line 152
/* #pragma ccuredwrapper("fclose_wrapper",of("fclose")) */
#line 179
/* #pragma ccuredwrapper("_IO_putc_wrapper",of("_IO_putc")) */
#line 185
/* #pragma ccuredwrapper("_IO_getc_wrapper",of("_IO_getc")) */
#line 210
/* #pragma ccuredwrapper("fputc_wrapper",of("fputc")) */
#line 216
/* #pragma ccuredwrapper("fputs_wrapper",of("fputs")) */
#line 222
/* #pragma ccuredwrapper("fgetc_wrapper",of("fgetc")) */
#line 228
/* #pragma ccuredwrapper("puts_wrapper",of("puts")) */
#line 234
/* #pragma ccuredwrapper("fileno_wrapper",of("fileno")) */
#line 240
/* #pragma ccuredwrapper("ferror_wrapper",of("ferror")) */
#line 246
/* #pragma ccuredwrapper("fseek_wrapper",of("fseek")) */
#line 253
/* #pragma ccuredwrapper("clearerr_wrapper",of("clearerr")) */
#line 264
/* #pragma ccuredwrapper("fread_wrapper",of("fread")) */
#line 275
/* #pragma ccuredwrapper("fwrite_wrapper",of("fwrite")) */
#line 288
/* #pragma ccuredwrapper("gets_wrapper",of("gets")) */
#line 314
/* #pragma ccuredvararg("vsnprintf_wrapper",printf(3)) */
#line 315
/* #pragma ccuredwrapper("vsnprintf_wrapper",of("vsnprintf")) */
#line 322
/* #pragma ccuredvararg("vsprintf_wrapper",printf(2)) */
#line 323
/* #pragma ccuredwrapper("vsprintf_wrapper",of("vsprintf")) */
#line 330
/* #pragma ccuredvararg("snprintf_wrapper",printf(3)) */
#line 331
/* #pragma ccuredwrapper("snprintf_wrapper",of("snprintf")) */
#line 343
/* #pragma ccuredvararg("sprintf_wrapper",printf(2)) */
#line 344
/* #pragma ccuredwrapper("sprintf_wrapper",of("sprintf")) */
#line 366
/* #pragma ccuredpoly("ccured_fscanf_double") */
#line 382
/* #pragma ccuredpoly("ccured_fscanf_int") */
#line 398
/* #pragma ccuredpoly("ccured_fscanf_nothing") */
#line 467
/* #pragma ccuredwrapper("perror_wrapper",of("perror")) */
#line 49 "/users/rupak/ccured/include/stat_wrappers.h"
/* #pragma ccuredwrapper("fstat_wrapper",of("fstat")) */
#line 57
/* #pragma ccuredwrapper("stat_wrapper",of("stat")) */
#line 68
/* #pragma ccuredwrapper("__xstat_wrapper",of("__xstat")) */
#line 79 "/users/rupak/ccured/include/time_wrappers.h"
/* #pragma ccuredwrapper("asctime_wrapper",of("asctime")) */
#line 13 "/users/rupak/ccured/include/functions/deepcopy_stringarray.h"
/* #pragma cilnoremove("__deepcopy_stringarray_from_compat") */
#line 14
/* #pragma ccuredpoly("__deepcopy_stringarray_from_compat") */
#line 53
/* #pragma ccuredpoly("__deepcopy_stringarray_to_compat") */
#line 44 "/users/rupak/ccured/include/unistd_wrappers.h"
/* #pragma ccuredwrapper("execv_wrapper",of("execv")) */
#line 66
/* #pragma ccuredwrapper("execvp_wrapper",of("execvp")) */
#line 86
/* #pragma ccuredwrapper("execve_wrapper",of("execve")) */
#line 106
/* #pragma ccuredvararg("execl",sizeof(struct __ccured_execl_arguments )) */
#line 107
/* #pragma ccuredvararg("execlp",sizeof(struct __ccured_execl_arguments )) */
#line 108
/* #pragma ccuredvararg("execle",sizeof(struct __ccured_execl_arguments )) */
#line 110
/* #pragma ccuredwrapper("getlogin_wrapper",of("getlogin")) */
#line 117
/* #pragma ccuredwrapper("ttyname_wrapper",of("ttyname")) */
#line 129
/* #pragma ccuredwrapper("getopt_wrapper",of("getopt")) */
#line 174
/* #pragma ccuredwrapper("read_wrapper",of("read")) */
#line 182
/* #pragma ccuredwrapper("write_wrapper",of("write")) */
#line 195
/* #pragma ccuredwrapper("getusershell_wrapper",of("getusershell")) */
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___1 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___1 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___1 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___1 )) */
#line 303
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___2 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___2 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___2 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___2 )) */
#line 43 "/users/rupak/ccured/include/crypt_wrappers.h"
/* #pragma ccuredwrapper("crypt_wrapper",of("crypt")) */
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___3 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___3 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___3 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___3 )) */
#line 23 "/users/rupak/ccured/include/grp_wrappers.h"
/* #pragma ccuredwrapper("getgrnam_wrapper",of("getgrnam")) */
#line 45
/* #pragma ccuredwrapper("getgrgid_wrapper",of("getgrgid")) */
#line 59
/* #pragma ccuredwrapper("getgrent_wrapper",of("getgrent")) */
#line 443 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("ioctl",sizeof(struct ioctl_format )) */
#line 31 "job.c"
void sig_dfl(void) ;
#line 32
void end_job(cl_t *line , int status , FILE *mailf , short mailpos ) ;
#line 35
void die_mail_pame(cl_t *cl , int pamerrno , struct passwd *pas , char *str ) ;
#line 49 "job.c"
void die_mail_pame(cl_t *cl , int pamerrno , struct passwd *pas , char *str ) 
{ char buf[175] ;
  size_t tmp ;
  FILE *mailf ;
  FILE *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 55
  strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)str, sizeof(buf) -
                                                                                1U);
#line 56
  tmp = strlen((char const   *)(buf));
#line 56
  strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)" for \'%s\'",
          (sizeof(buf) - tmp) - 1U);
#line 57
  buf[sizeof(buf) - 1U] = (char )'\000';
#line 59
  if (! ((int )cl->cl_option[0] & 128)) {
#line 60
    tmp___0 = create_mail(cl, (char *)"Could not run fcron job");
#line 60
    mailf = tmp___0;
#line 63
    tmp___1 = fileno(mailf);
#line 63
    tmp___2 = dup2(tmp___1, 1);
#line 63
    if (tmp___2 != 1) {
#line 64
      die_e((char *)"dup2() error");
    } else {
#line 63
      tmp___3 = dup2(1, 2);
#line 63
      if (tmp___3 != 2) {
#line 64
        die_e((char *)"dup2() error");
      }
    }
#line 66
    foreground = 1;
#line 67
    error_pame(pamh, pamerrno, buf, cl->cl_shell);
#line 68
    error((char *)"Job \'%s\' has *not* run.", cl->cl_shell);
#line 69
    foreground = 0;
#line 71
    pam_end(pamh, pamerrno);
#line 75
    tmp___4 = initgroups((char const   *)pas->pw_name, pas->pw_gid);
#line 75
    if (tmp___4 < 0) {
#line 76
      die_e((char *)"initgroups failed: %s", pas->pw_name);
    }
#line 77
    tmp___5 = setgid(pas->pw_gid);
#line 77
    if (tmp___5 < 0) {
#line 78
      die((char *)"setgid failed: %s %d", pas->pw_name, pas->pw_gid);
    }
#line 79
    tmp___6 = setuid(pas->pw_uid);
#line 79
    if (tmp___6 < 0) {
#line 80
      die((char *)"setuid failed: %s %d", pas->pw_name, pas->pw_uid);
    }
#line 82
    launch_mailer(cl, mailf);
  } else {
#line 86
    die_pame(pamh, pamerrno, buf, cl->cl_shell);
  }
#line 87
  return;
}
}
#line 90 "job.c"
int change_user(struct cl_t *cl ) 
{ struct passwd *pas ;
  int retcode ;
  char const   * const  *env ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 95
  retcode = 0;
#line 100
  umask(saved_umask);
#line 104
  pas = getpwnam((char const   *)cl->cl_runas);
#line 104
  if ((unsigned int )pas == (unsigned int )((void *)0)) {
#line 105
    die((char *)"failed to get passwd fields for user \"%s\"", cl->cl_runas);
  }
#line 108
  setenv("USER", (char const   *)pas->pw_name, 1);
#line 109
  setenv("HOME", (char const   *)pas->pw_dir, 1);
#line 110
  setenv("SHELL", (char const   *)pas->pw_shell, 1);
#line 134
  retcode = pam_start("fcron", (char const   *)pas->pw_name, & apamconv, & pamh);
#line 135
  if (retcode != 0) {
#line 135
    die_pame(pamh, retcode, (char *)"Could not start PAM for %s", cl->cl_shell);
  }
#line 140
  retcode = pam_authenticate(pamh, 32768);
#line 141
  if (retcode != 0) {
#line 141
    die_mail_pame(cl, retcode, pas, (char *)"Could not authenticate PAM user");
  }
#line 143
  retcode = pam_acct_mgmt(pamh, 32768);
#line 144
  if (retcode != 0) {
#line 144
    die_mail_pame(cl, retcode, pas, (char *)"Could not init PAM account management");
  }
#line 146
  retcode = pam_setcred(pamh, 32770);
#line 147
  if (retcode != 0) {
#line 147
    die_mail_pame(cl, retcode, pas, (char *)"Could not set PAM credentials");
  }
#line 149
  retcode = pam_open_session(pamh, 32768);
#line 150
  if (retcode != 0) {
#line 150
    die_mail_pame(cl, retcode, pas, (char *)"Could not open PAM session");
  }
#line 153
  env = pam_getenvlist(pamh);
#line 154
  while (1) {
#line 154
    if (env) {
#line 154
      if (! (*env)) {
#line 154
        break;
      }
    } else {
#line 154
      break;
    }
#line 155
    tmp___0 = putenv((char *)(*env));
#line 155
    if (tmp___0) {
#line 155
      die_e((char *)"Could not copy PAM environment");
    }
#line 156
    env ++;
  }
#line 161
  xcloselog();
#line 165
  tmp___1 = initgroups((char const   *)pas->pw_name, pas->pw_gid);
#line 165
  if (tmp___1 < 0) {
#line 166
    die_e((char *)"initgroups failed: %s", pas->pw_name);
  }
#line 168
  tmp___2 = setgid(pas->pw_gid);
#line 168
  if (tmp___2 < 0) {
#line 169
    die((char *)"setgid failed: %s %d", pas->pw_name, pas->pw_gid);
  }
#line 171
  tmp___3 = setuid(pas->pw_uid);
#line 171
  if (tmp___3 < 0) {
#line 172
    die((char *)"setuid failed: %s %d", pas->pw_name, pas->pw_uid);
  }
#line 174
  return ((int )pas->pw_uid);
}
}
#line 178 "job.c"
void sig_dfl(void) 
{ 

  {
#line 182
  signal(15, (void (*)(int  ))0);
#line 183
  signal(17, (void (*)(int  ))0);
#line 184
  signal(1, (void (*)(int  ))0);
#line 185
  signal(10, (void (*)(int  ))0);
#line 186
  signal(12, (void (*)(int  ))0);
#line 187
  signal(13, (void (*)(int  ))0);
#line 188
  return;
}
}
#line 191 "job.c"
FILE *create_mail(struct cl_t *line , char *subject ) 
{ int mailfd ;
  int tmp ;
  FILE *mailf ;
  FILE *tmp___0 ;
  char hostname[128] ;
  char complete_adr ;
  int i ;
  int tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;

  {
#line 196
  tmp = temp_file((char **)((void *)0));
#line 196
  mailfd = tmp;
#line 197
  tmp___0 = fdopen(mailfd, "r+");
#line 197
  mailf = tmp___0;
#line 200
  complete_adr = 0;
#line 203
  if ((unsigned int )mailf == (unsigned int )((void *)0)) {
#line 204
    die_e((char *)"Could not fdopen() mailfd");
  }
#line 207
  fprintf((FILE */* __restrict  */)mailf, (char const   */* __restrict  */)"To: %s",
          line->cl_mailto);
#line 210
  tmp___1 = gethostname(hostname, sizeof(hostname));
#line 210
  if (tmp___1 != 0) {
#line 211
    error_e((char *)"Could not get hostname");
#line 212
    hostname[0] = (char )'\000';
  } else {
#line 216
    hostname[127] = (char )'\000';
#line 219
    i = 0;
#line 219
    while ((int )(*(line->cl_mailto + i)) != 0) {
#line 220
      if ((int )(*(line->cl_mailto + i)) == 64) {
#line 221
        complete_adr = 1;
#line 222
        break;
      }
#line 219
      i ++;
    }
#line 225
    if (! complete_adr) {
#line 226
      fprintf((FILE */* __restrict  */)mailf, (char const   */* __restrict  */)"@%s",
              hostname);
    }
  }
#line 232
  if (subject) {
#line 233
    if ((int )hostname[0] != 0) {
#line 233
      tmp___2 = (char const   *)(hostname);
    } else {
#line 233
      tmp___2 = "?";
    }
#line 233
    fprintf((FILE */* __restrict  */)mailf, (char const   */* __restrict  */)"\nSubject: fcron <%s@%s> %s: %s\n\n",
            (line->cl_file)->cf_user, tmp___2, subject, line->cl_shell);
  } else {
#line 236
    if ((int )hostname[0] != 0) {
#line 236
      tmp___3 = (char const   *)(hostname);
    } else {
#line 236
      tmp___3 = "?";
    }
#line 236
    fprintf((FILE */* __restrict  */)mailf, (char const   */* __restrict  */)"\nSubject: fcron <%s@%s> %s\n\n",
            (line->cl_file)->cf_user, tmp___3, line->cl_shell);
  }
#line 240
  return (mailf);
}
}
#line 243 "job.c"
void run_job(struct exe_t *exeent ) 
{ pid_t pid ;
  cl_t *line ;
  int pipe_pid_fd[2] ;
  int i ;
  int j ;
  int tmp ;
  char *curshell ;
  char *home ;
  env_t *env ;
  FILE *mailf ;
  int status ;
  int to_stdout ;
  int tmp___0 ;
  int pipe_fd[2] ;
  short mailpos ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  FILE *tmp___8 ;
  FILE *tmp___9 ;
  FILE * __restrict  tmp___10 ;
  FILE * __restrict  tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  int tmp___19 ;
  ssize_t tmp___20 ;
  char mailbuf[196] ;
  FILE *pipef ;
  FILE *tmp___21 ;
  int tmp___22 ;
  char *tmp___23 ;
  int *tmp___24 ;

  {
#line 249
  line = exeent->e_line;
#line 251
  i = 0;
#line 254
  tmp = pipe(pipe_pid_fd);
#line 254
  if (tmp != 0) {
#line 255
    error_e((char *)"pipe(pipe_pid_fd) : setting job_pid to -1");
#line 256
    exeent->e_job_pid = -1;
  }
#line 259
  pid = fork();
#line 259
  switch (pid) {
  case -1: 
#line 261
  error_e((char *)"Fork error : could not exec \"%s\"", line->cl_shell);
#line 262
  break;
  case 0: 
#line 270
  mailf = (FILE *)((void *)0);
#line 271
  status = 0;
#line 272
  if (foreground) {
#line 272
    if ((int )line->cl_option[3] & 2) {
#line 272
      tmp___0 = 1;
    } else {
#line 272
      tmp___0 = 0;
    }
  } else {
#line 272
    tmp___0 = 0;
  }
#line 272
  to_stdout = tmp___0;
#line 274
  mailpos = 0;
#line 280
  if (debug_opt) {
#line 280
    if ((int )line->cl_option[3] & 2) {
#line 280
      tmp___1 = "stdout";
    } else {
#line 280
      tmp___1 = "normal";
    }
#line 280
    if (foreground) {
#line 280
      tmp___2 = "running in foreground";
    } else {
#line 280
      tmp___2 = "running in background";
    }
#line 280
    if (to_stdout) {
#line 280
      tmp___3 = "stdout";
    } else {
#line 280
      tmp___3 = "file";
    }
#line 280
    Debug((char *)"sent output to %s, %s, %s\n", tmp___3, tmp___2, tmp___1);
  }
#line 285
  if (! to_stdout) {
#line 285
    if (! ((int )line->cl_option[0] & 128)) {
#line 290
      mailf = create_mail(line, (char *)((void *)0));
#line 291
      mailpos = (short )ftell(mailf);
#line 292
      tmp___4 = pipe(pipe_fd);
#line 292
      if (tmp___4 != 0) {
#line 293
        die_e((char *)"could not pipe()");
      }
    }
  }
#line 297
  tmp___5 = change_user(line);
#line 297
  if (tmp___5 < 0) {
#line 298
    return;
  }
#line 301
  sig_dfl();
#line 304
  pid = fork();
#line 304
  switch (pid) {
  case -1: 
#line 306
  error_e((char *)"Fork error : could not exec \"%s\"", line->cl_shell);
#line 307
  break;
  case 0: ;
#line 311
  if (! to_stdout) {
#line 312
    if (! ((int )line->cl_option[0] & 128)) {
#line 315
      tmp___6 = dup2(pipe_fd[1], 1);
#line 315
      if (tmp___6 != 1) {
#line 316
        die_e((char *)"dup2() error");
      } else {
#line 315
        tmp___7 = dup2(1, 2);
#line 315
        if (tmp___7 != 2) {
#line 316
          die_e((char *)"dup2() error");
        }
      }
#line 319
      close(pipe_fd[0]);
#line 320
      close(pipe_fd[1]);
#line 324
      tmp___8 = get_stdout();
#line 324
      setlinebuf(tmp___8);
#line 325
      tmp___9 = get_stderr();
#line 325
      setlinebuf(tmp___9);
    } else {
#line 331
      if (foreground) {
#line 332
        tmp___10 = get_stdout();
#line 332
        freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
                tmp___10);
#line 333
        tmp___11 = get_stderr();
#line 333
        freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
                tmp___11);
      }
    }
  }
#line 337
  foreground = 1;
#line 340
  if ((int )line->cl_nice != 0) {
#line 341
    tmp___12 = __errno_location();
#line 341
    (*tmp___12) = 0;
#line 342
    tmp___13 = nice((int )line->cl_nice);
#line 342
    if (tmp___13 == -1) {
#line 342
      tmp___14 = __errno_location();
#line 342
      if ((*tmp___14) != 0) {
#line 343
        error_e((char *)"could not set nice value");
      }
    }
  }
#line 346
  xcloselog();
#line 349
  env = (line->cl_file)->cf_env_base;
#line 349
  while (env) {
#line 350
    tmp___15 = putenv(env->e_val);
#line 350
    if (tmp___15 != 0) {
#line 351
      error((char *)"could not putenv()");
    }
#line 349
    env = env->e_next;
  }
#line 353
  home = getenv("HOME");
#line 353
  if ((unsigned int )home != (unsigned int )((void *)0)) {
#line 354
    tmp___17 = chdir((char const   *)home);
#line 354
    if (tmp___17 != 0) {
#line 355
      error_e((char *)"Could not chdir to HOME dir \"%s\"", home);
#line 356
      tmp___16 = chdir("/");
#line 356
      if (tmp___16 < 0) {
#line 357
        die_e((char *)"Could not chdir to HOME dir /");
      }
    }
  }
#line 360
  curshell = getenv("SHELL");
#line 360
  if ((unsigned int )curshell == (unsigned int )((void *)0)) {
#line 361
    curshell = shell;
  } else {
#line 362
    tmp___19 = access((char const   *)curshell, 1);
#line 362
    if (tmp___19 != 0) {
#line 363
      tmp___18 = __errno_location();
#line 363
      if ((*tmp___18) == 2) {
#line 364
        error((char *)"shell \"%s\" : no file or directory. SHELL set to %s", curshell,
              shell);
      } else {
#line 367
        error_e((char *)"shell \"%s\" not valid : SHELL set to %s", curshell, shell);
      }
#line 369
      curshell = shell;
    }
  }
#line 383
  execl((char const   *)curshell, (char const   *)curshell, "-c", line->cl_shell,
        (void *)0);
#line 385
  error_e((char *)"Can\'t find \"%s\". Trying a execlp(\"sh\",...)", curshell);
#line 386
  execlp("sh", "sh", "-c", line->cl_shell, (void *)0);
#line 387
  die_e((char *)"execl() \"%s -c %s\" error", curshell, line->cl_shell);
  default: 
#line 395
  close(pipe_fd[1]);
#line 396
  close(pipe_pid_fd[0]);
#line 399
  tmp___20 = write(pipe_pid_fd[1], (void const   *)(& pid), sizeof(pid));
#line 399
  if (tmp___20 < 0) {
#line 400
    error_e((char *)"could not write child pid to pipe_pid_fd[1]");
  }
#line 401
  close(pipe_pid_fd[1]);
#line 403
  if (! ((int )line->cl_option[2] & 64)) {
#line 404
    explain((char *)"Job %s started for user %s (pid %d)", line->cl_shell, (line->cl_file)->cf_user,
            pid);
  }
#line 407
  if (! to_stdout) {
#line 407
    if (! ((int )line->cl_option[0] & 128)) {
#line 410
      tmp___21 = fdopen(pipe_fd[0], "r");
#line 410
      pipef = tmp___21;
#line 412
      if ((unsigned int )pipef == (unsigned int )((void *)0)) {
#line 413
        die_e((char *)"Could not fdopen() pipe_fd[0]");
      }
#line 415
      mailbuf[sizeof(mailbuf) - 1U] = (char )'\000';
#line 416
      while (1) {
#line 416
        tmp___23 = fgets((char */* __restrict  */)(mailbuf), (int )sizeof(mailbuf),
                         (FILE */* __restrict  */)pipef);
#line 416
        if (! ((unsigned int )tmp___23 != (unsigned int )((void *)0))) {
#line 416
          break;
        }
#line 417
        tmp___22 = fputs((char const   */* __restrict  */)(mailbuf), (FILE */* __restrict  */)mailf);
#line 417
        if (tmp___22 < 0) {
#line 418
          warn((char *)"fputs() failed to write to mail file for job %s (pid %d)",
               line->cl_shell, pid);
        }
      }
#line 420
      fclose(pipef);
    }
  }
#line 424
  while (1) {
#line 424
    pid = wait3((union wait *)(& status), 0, (struct rusage *)((void *)0));
#line 424
    if (! (pid > 0)) {
#line 424
      break;
    }
#line 425
    end_job(line, status, mailf, mailpos);
  }
  }
  default: 
#line 435
  close(pipe_pid_fd[1]);
#line 437
  exeent->e_ctrl_pid = pid;
#line 438
  (line->cl_file)->cf_running = (line->cl_file)->cf_running + 1;
#line 441
  while ((unsigned int )i < sizeof(pid_t )) {
#line 442
    j = read(pipe_pid_fd[0], (void *)((char *)(& exeent->e_job_pid) + i), sizeof(pid_t ));
#line 443
    if (j <= 0) {
#line 443
      tmp___24 = __errno_location();
#line 443
      if ((*tmp___24) != 4) {
#line 444
        error_e((char *)"Could not read job pid : setting it to -1");
#line 445
        exeent->e_job_pid = -1;
#line 446
        break;
      }
    }
#line 448
    i += j;
  }
#line 450
  close(pipe_pid_fd[0]);
  }
#line 453
  return;
}
}
#line 455 "job.c"
void end_job(cl_t *line , int status , FILE *mailf , short mailpos ) 
{ char mail_output ;
  char *m ;
  int tmp ;
  long tmp___0 ;
  union __anonunion___u_47 __u ;
  union __anonunion___u_48 __u___0 ;
  union __anonunion___u_49 __u___1 ;
  union __anonunion___u_50 __u___2 ;
  union __anonunion___u_51 __u___3 ;
  union __anonunion___u_52 __u___4 ;
  int __status ;
  union __anonunion___u_53 __u___5 ;
  int tmp___1 ;
  union __anonunion___u_54 __u___6 ;
  union __anonunion___u_55 __u___7 ;
  union __anonunion___u_56 __u___8 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 467
  if ((unsigned int )mailf != (unsigned int )((void *)0)) {
#line 467
    if ((int )line->cl_option[1] & 1) {
#line 469
      mail_output = 1;
    } else {
#line 467
      if (! ((int )line->cl_option[0] & 128)) {
#line 463
        tmp = fseek(mailf, 0L, 2);
#line 467
        if (tmp == 0) {
#line 463
          tmp___0 = ftell(mailf);
#line 467
          if (tmp___0 > (long )mailpos) {
#line 469
            mail_output = 1;
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 467
          __u.__in = status;
#line 467
          if ((__u.__i & 127) == 0) {
#line 467
            __u___0.__in = status;
#line 467
            if ((__u___0.__i & 65280) >> 8 == 0) {
#line 472
              mail_output = 0;
            } else {
#line 469
              mail_output = 1;
            }
          } else {
#line 469
            mail_output = 1;
          }
        }
      } else {
#line 472
        mail_output = 0;
      }
    }
  } else {
#line 472
    mail_output = 0;
  }
#line 474
  if ((int )mail_output == 1) {
#line 474
    m = (char *)" (mailing output)";
  } else {
#line 474
    m = (char *)"";
  }
#line 475
  __u___7.__in = status;
#line 475
  if ((__u___7.__i & 127) == 0) {
#line 475
    __u___8.__in = status;
#line 475
    if ((__u___8.__i & 65280) >> 8 == 0) {
#line 476
      if (! ((int )line->cl_option[2] & 64)) {
#line 477
        explain((char *)"Job %s completed%s", line->cl_shell, m);
      }
    } else {
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 479
    __u___6.__in = status;
#line 479
    if ((__u___6.__i & 127) == 0) {
#line 481
      __u___1.__in = status;
#line 481
      warn((char *)"Job %s terminated (exit status: %d)%s", line->cl_shell, (__u___1.__i &
                                                                             65280) >>
                                                                            8, m);
#line 484
      if ((unsigned int )mailf != (unsigned int )((void *)0)) {
#line 486
        __u___2.__in = status;
#line 486
        fprintf((FILE */* __restrict  */)mailf, (char const   */* __restrict  */)"Job %s terminated (exit status: %d)%s",
                line->cl_shell, (__u___2.__i & 65280) >> 8, m);
      }
    } else {
#line 488
      __u___5.__in = status;
#line 488
      __status = __u___5.__i;
#line 488
      if (! ((__status & 255) == 127)) {
#line 488
        if (! ((__status & 127) == 0)) {
#line 488
          tmp___1 = 1;
        } else {
#line 488
          tmp___1 = 0;
        }
      } else {
#line 488
        tmp___1 = 0;
      }
#line 488
      if (tmp___1) {
#line 490
        __u___3.__in = status;
#line 490
        error((char *)"Job %s terminated due to signal %d%s", line->cl_shell, __u___3.__i &
                                                                              127,
              m);
#line 491
        if ((unsigned int )mailf != (unsigned int )((void *)0)) {
#line 493
          __u___4.__in = status;
#line 493
          fprintf((FILE */* __restrict  */)mailf, (char const   */* __restrict  */)"Job %s terminated due to signal %d%s",
                  line->cl_shell, __u___4.__i & 127, m);
        }
      } else {
#line 496
        error((char *)"Job %s terminated abnormally %s", line->cl_shell, m);
#line 497
        if ((unsigned int )mailf != (unsigned int )((void *)0)) {
#line 498
          fprintf((FILE */* __restrict  */)mailf, (char const   */* __restrict  */)"Job %s terminated abnormally %s",
                  line->cl_shell, m);
        }
      }
    }
  }
#line 512
  pam_setcred(pamh, 32772);
#line 513
  tmp___2 = pam_close_session(pamh, 32768);
#line 513
  pam_end(pamh, tmp___2);
#line 516
  if ((int )mail_output == 1) {
#line 517
    launch_mailer(line, mailf);
#line 519
    die_e((char *)"Internal error: launch_mailer returned");
  }
#line 523
  if ((unsigned int )mailf != (unsigned int )((void *)0)) {
#line 523
    tmp___3 = fclose(mailf);
#line 523
    if (tmp___3 != 0) {
#line 524
      die_e((char *)"Can\'t close file mailf");
    }
  }
#line 526
  exit(0);
}
}
#line 530 "job.c"
void launch_mailer(struct cl_t *line , FILE *mailf ) 
{ int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 535
  foreground = 0;
#line 538
  tmp = fseek(mailf, 0L, 0);
#line 538
  if (tmp != 0) {
#line 538
    die_e((char *)"Can\'t fseek()");
  }
#line 539
  tmp___0 = fileno(mailf);
#line 539
  tmp___1 = dup2(tmp___0, 0);
#line 539
  if (tmp___1 != 0) {
#line 539
    die_e((char *)"Can\'t dup2(fileno(mailf))");
  }
#line 541
  xcloselog();
#line 543
  tmp___2 = chdir("/");
#line 543
  if (tmp___2 < 0) {
#line 544
    die_e((char *)"Could not chdir to /");
  }
#line 547
  execl((char const   *)sendmail, (char const   *)sendmail, "-Ffcron", "-odi", line->cl_mailto,
        (void *)0);
#line 548
  error_e((char *)"Can\'t find \"%s\". Trying a execlp(\"sendmail\")", sendmail);
#line 549
  execlp("sendmail", "sendmail", "-Ffcron", "-odi", line->cl_mailto, (void *)0);
#line 550
  die_e((char *)"Can\'t exec /usr/lib/sendmail");
#line 554
  return;
}
}
#line 1 "conf.o"
/* #pragma merger(0,"./conf.i","-O2 -Wall") */
#line 123 "/users/rupak/ccured/include/ccuredannot.h"
/* #pragma cilnoremove("__ccuredInit") */
#line 20 "/users/rupak/ccured/include/ccured.h"
/* #pragma cilnoremove("wrapperAlloc") */
#line 21
/* #pragma ccuredalloc("wrapperAlloc",sizein(1),nozero) */
#line 24
/* #pragma cilnoremove("wrapperFree") */
#line 25
/* #pragma ccuredpoly("wrapperFree") */
#line 29
/* #pragma cilnoremove("wrapperStrdup") */
#line 30
/* #pragma ccuredpoly("wrapperStrdup") */
#line 50
/* #pragma ccuredpoly("__ptrof_nocheck") */
#line 51
/* #pragma cilnoremove("__ptrof_nocheck") */
#line 57
/* #pragma ccuredpoly("__startof") */
#line 63
/* #pragma ccuredpoly("__endof") */
#line 78
/* #pragma ccuredpoly("__ptrof") */
#line 84
/* #pragma ccuredpoly("__ptrof_size") */
#line 85
/* #pragma cilnoremove("__ptrof_size") */
#line 92
/* #pragma ccuredpoly("__verify_nul") */
#line 101
/* #pragma ccuredpoly("__strlen") */
#line 111
/* #pragma ccuredpoly("__strlen_n") */
#line 125
/* #pragma ccuredpoly("__stringof") */
#line 127
/* #pragma cilnoremove("__stringof") */
#line 136
/* #pragma ccuredpoly("__stringof_ornull") */
#line 138
/* #pragma cilnoremove("__stringof_ornull") */
#line 147
/* #pragma ccuredpoly("__write_at_least") */
#line 155
/* #pragma ccuredpoly("__read_at_least") */
#line 162
/* #pragma ccuredpoly("__copytags") */
#line 180
/* #pragma ccuredpoly("__mkptr") */
#line 181
/* #pragma cilnoremove("__mkptr") */
#line 188
/* #pragma ccuredpoly("__mkptr_int") */
#line 196
/* #pragma ccuredpoly("__mkptr_size") */
#line 197
/* #pragma cilnoremove("__mkptr_size") */
#line 206
/* #pragma ccuredpoly("__mkptr_string") */
#line 207
/* #pragma cilnoremove("__mkptr_string") */
#line 215
/* #pragma ccuredpoly("__align_seq") */
#line 216
/* #pragma cilnoremove("__align_seq") */
#line 227
/* #pragma ccuredpoly("__trusted_cast") */
#line 228
/* #pragma cilnoremove("__trusted_cast") */
#line 237
/* #pragma ccuredpoly("__trusted_deepcast") */
#line 238
/* #pragma cilnoremove("__trusted_deepcast") */
#line 250
/* #pragma ccuredpoly("ccured_hasuniontag") */
#line 259
/* #pragma ccuredpoly("__ccured_kind_of") */
#line 307
/* #pragma ccuredpoly("__ccured_mangling_of") */
#line 308
/* #pragma cilnoremove("__ccured_mangling_of") */
#line 312
/* #pragma ccuredpoly("__ccured_has_empty_mangling") */
#line 313
/* #pragma cilnoremove("__ccured_has_empty_mangling") */
#line 327
/* #pragma cilnoremove("abort_deepcopy") */
#line 451
/* #pragma cilnoremove("struct printf_arguments") */
#line 45 "/users/rupak/ccured/include/time_wrappers.h"
/* #pragma ccuredwrapper("time_wrapper",of("time")) */
#line 59
/* #pragma ccuredwrapper("ctime_wrapper",of("ctime")) */
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments )) */
#line 266
/* #pragma ccuredpoly("__ccured_va_arg") */
#line 303
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___0 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___0 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___0 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___0 )) */
#line 69 "/users/rupak/ccured/include/io_wrappers.h"
/* #pragma ccuredwrapper("unlink_wrapper",of("unlink")) */
#line 79
/* #pragma ccuredwrapper("open_wrapper",of("open")) */
#line 80
/* #pragma ccuredvararg("open_wrapper",sizeof(int )) */
#line 123
/* #pragma ccuredwrapper("rename_wrapper",of("rename")) */
#line 6 "/users/rupak/ccured/include/malloc_wrappers.h"
/* #pragma ccuredalloc("malloc",nozero,sizein(1)) */
#line 8
/* #pragma ccuredpoly("realloc") */
#line 9
/* #pragma ccuredwrapper("realloc_wrapper",of("realloc")) */
#line 22
/* #pragma ccuredwrapper("free_wrapper",of("free")) */
#line 27
/* #pragma ccuredalloc("alloca",nozero,sizein(1)) */
#line 28
/* #pragma ccuredalloc("calloc",zero,sizemul(1,2)) */
#line 46 "/users/rupak/ccured/include/string_wrappers.h"
/* #pragma ccuredwrapper("strlen_wrapper",of("strlen")) */
#line 52
/* #pragma ccuredwrapper("bzero_wrapper",of("bzero")) */
#line 61
/* #pragma ccuredwrapper("strcpy_wrapper",of("strcpy")) */
#line 81
/* #pragma ccuredwrapper("strncpy_wrapper",of("strncpy")) */
#line 95
/* #pragma ccuredwrapper("strcat_wrapper",of("strcat")) */
#line 111
/* #pragma ccuredwrapper("strncat_wrapper",of("strncat")) */
#line 128
/* #pragma ccuredwrapper("strchr_wrapper",of("strchr")) */
#line 137
/* #pragma ccuredwrapper("strrchr_wrapper",of("strrchr")) */
#line 146
/* #pragma ccuredwrapper("strdup_wrapper",of("strdup")) */
#line 167
/* #pragma ccuredwrapper("strcasecmp_wrapper",of("strcasecmp")) */
#line 173
/* #pragma ccuredwrapper("strcmp_wrapper",of("strcmp")) */
#line 180
/* #pragma ccuredwrapper("strncasecmp_wrapper",of("strncasecmp")) */
#line 194
/* #pragma ccuredwrapper("strncmp_wrapper",of("strncmp")) */
#line 208
/* #pragma ccuredwrapper("strpbrk_wrapper",of("strpbrk")) */
#line 217
/* #pragma ccuredwrapper("strsep_wrapper",of("strsep")) */
#line 234
/* #pragma ccuredwrapper("strtoul_wrapper",of("strtoul")) */
#line 47 "/users/rupak/ccured/include/stdlib_wrappers.h"
/* #pragma ccuredwrapper("atof_wrapper",of("atof")) */
#line 55
/* #pragma ccuredwrapper("atoi_wrapper",of("atoi")) */
#line 63
/* #pragma ccuredwrapper("atol_wrapper",of("atol")) */
#line 93
/* #pragma ccuredpoly("qsort_zero_tags") */
#line 172
/* #pragma ccuredwrapper("qsort_wrapper",of("qsort")) */
#line 216
/* #pragma ccuredwrapper("bsearch_wrapper",of("bsearch")) */
#line 254
/* #pragma ccuredwrapper("strtol_wrapper",of("strtol")) */
#line 270
/* #pragma ccuredwrapper("getenv_wrapper",of("getenv")) */
#line 256 "/users/rupak/ccured/include/string_wrappers.h"
/* #pragma ccuredwrapper("strtok_wrapper",of("strtok")) */
#line 269
/* #pragma ccuredwrapper("strtok_r_wrapper",of("strtok_r")) */
#line 319
/* #pragma ccuredwrapper("memcmp_wrapper",of("memcmp")) */
#line 332
/* #pragma ccuredwrapper("memset_wrapper",of("memset")) */
#line 341
/* #pragma ccuredwrapper("memmove_wrapper",of("memmove")) */
#line 353
/* #pragma ccuredwrapper("memcpy_wrapper",of("memcpy")) */
#line 366
/* #pragma ccuredwrapper("strerror_wrapper",of("strerror")) */
#line 374
/* #pragma ccuredwrapper("strstr_wrapper",of("strstr")) */
#line 383
/* #pragma ccuredwrapper("memchr_wrapper",of("memchr")) */
#line 50 "/users/rupak/ccured/include/pwd_wrappers.h"
/* #pragma ccuredwrapper("getpwnam_wrapper",of("getpwnam")) */
#line 68
/* #pragma ccuredwrapper("getpwuid_wrapper",of("getpwuid")) */
#line 81
/* #pragma ccuredwrapper("getpwent_wrapper",of("getpwent")) */
#line 56 "/users/rupak/ccured/include/signal_wrappers.h"
/* #pragma ccuredpoly("__mkfat_sighandler") */
#line 66
/* #pragma ccuredwrapper("signal_wrapper",of("signal")) */
#line 88
/* #pragma ccuredwrapper("sigaction_wrapper",of("sigaction")) */
#line 168 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredpoly("get_stdin") */
#line 170
/* #pragma ccuredpoly("get_stdout") */
#line 172
/* #pragma ccuredpoly("get_stderr") */
#line 59 "/users/rupak/ccured/include/stdio_wrappers.h"
/* #pragma ccuredpoly("__mkptr_file") */
#line 65
/* #pragma ccuredpoly("__ptrof_file") */
#line 68
/* #pragma ccuredvararg("printf",printf(1)) */
#line 69
/* #pragma ccuredvararg("fprintf",printf(2)) */
#line 70
/* #pragma ccuredvararg("snprintf",printf(3)) */
#line 71
/* #pragma ccuredvararg("syslog",printf(2)) */
#line 72
/* #pragma ccuredvararg("sprintf",printf(2)) */
#line 73
/* #pragma ccuredvararg("vsprintf",printf(2)) */
#line 74
/* #pragma ccuredvararg("vfprintf",printf(2)) */
#line 75
/* #pragma ccuredvararg("vprintf",printf(1)) */
#line 76
/* #pragma ccuredvararg("vsyslog",printf(2)) */
#line 78
/* #pragma ccuredpoly("__endof") */
#line 89
/* #pragma ccuredpoly("ccured_fscanf_string") */
#line 92
/* #pragma ccuredwrapper("ccured_fscanf_string_wrapper",of("ccured_fscanf_string")) */
#line 117
/* #pragma ccuredvararg("sscanf",sizeof(struct scanf_format )) */
#line 118
/* #pragma ccuredvararg("fscanf",sizeof(struct scanf_format )) */
#line 123
/* #pragma ccuredwrapper("fgets_wrapper",of("fgets")) */
#line 132
/* #pragma ccuredwrapper("fopen_wrapper",of("fopen")) */
#line 139
/* #pragma ccuredwrapper("fdopen_wrapper",of("fdopen")) */
#line 146
/* #pragma ccuredwrapper("fflush_wrapper",of("fflush")) */
#line 152
/* #pragma ccuredwrapper("fclose_wrapper",of("fclose")) */
#line 179
/* #pragma ccuredwrapper("_IO_putc_wrapper",of("_IO_putc")) */
#line 185
/* #pragma ccuredwrapper("_IO_getc_wrapper",of("_IO_getc")) */
#line 210
/* #pragma ccuredwrapper("fputc_wrapper",of("fputc")) */
#line 216
/* #pragma ccuredwrapper("fputs_wrapper",of("fputs")) */
#line 222
/* #pragma ccuredwrapper("fgetc_wrapper",of("fgetc")) */
#line 228
/* #pragma ccuredwrapper("puts_wrapper",of("puts")) */
#line 234
/* #pragma ccuredwrapper("fileno_wrapper",of("fileno")) */
#line 240
/* #pragma ccuredwrapper("ferror_wrapper",of("ferror")) */
#line 246
/* #pragma ccuredwrapper("fseek_wrapper",of("fseek")) */
#line 253
/* #pragma ccuredwrapper("clearerr_wrapper",of("clearerr")) */
#line 264
/* #pragma ccuredwrapper("fread_wrapper",of("fread")) */
#line 275
/* #pragma ccuredwrapper("fwrite_wrapper",of("fwrite")) */
#line 288
/* #pragma ccuredwrapper("gets_wrapper",of("gets")) */
#line 314
/* #pragma ccuredvararg("vsnprintf_wrapper",printf(3)) */
#line 315
/* #pragma ccuredwrapper("vsnprintf_wrapper",of("vsnprintf")) */
#line 322
/* #pragma ccuredvararg("vsprintf_wrapper",printf(2)) */
#line 323
/* #pragma ccuredwrapper("vsprintf_wrapper",of("vsprintf")) */
#line 330
/* #pragma ccuredvararg("snprintf_wrapper",printf(3)) */
#line 331
/* #pragma ccuredwrapper("snprintf_wrapper",of("snprintf")) */
#line 343
/* #pragma ccuredvararg("sprintf_wrapper",printf(2)) */
#line 344
/* #pragma ccuredwrapper("sprintf_wrapper",of("sprintf")) */
#line 366
/* #pragma ccuredpoly("ccured_fscanf_double") */
#line 382
/* #pragma ccuredpoly("ccured_fscanf_int") */
#line 398
/* #pragma ccuredpoly("ccured_fscanf_nothing") */
#line 467
/* #pragma ccuredwrapper("perror_wrapper",of("perror")) */
#line 49 "/users/rupak/ccured/include/stat_wrappers.h"
/* #pragma ccuredwrapper("fstat_wrapper",of("fstat")) */
#line 57
/* #pragma ccuredwrapper("stat_wrapper",of("stat")) */
#line 68
/* #pragma ccuredwrapper("__xstat_wrapper",of("__xstat")) */
#line 79 "/users/rupak/ccured/include/time_wrappers.h"
/* #pragma ccuredwrapper("asctime_wrapper",of("asctime")) */
#line 13 "/users/rupak/ccured/include/functions/deepcopy_stringarray.h"
/* #pragma cilnoremove("__deepcopy_stringarray_from_compat") */
#line 14
/* #pragma ccuredpoly("__deepcopy_stringarray_from_compat") */
#line 53
/* #pragma ccuredpoly("__deepcopy_stringarray_to_compat") */
#line 44 "/users/rupak/ccured/include/unistd_wrappers.h"
/* #pragma ccuredwrapper("execv_wrapper",of("execv")) */
#line 66
/* #pragma ccuredwrapper("execvp_wrapper",of("execvp")) */
#line 86
/* #pragma ccuredwrapper("execve_wrapper",of("execve")) */
#line 106
/* #pragma ccuredvararg("execl",sizeof(struct __ccured_execl_arguments )) */
#line 107
/* #pragma ccuredvararg("execlp",sizeof(struct __ccured_execl_arguments )) */
#line 108
/* #pragma ccuredvararg("execle",sizeof(struct __ccured_execl_arguments )) */
#line 110
/* #pragma ccuredwrapper("getlogin_wrapper",of("getlogin")) */
#line 117
/* #pragma ccuredwrapper("ttyname_wrapper",of("ttyname")) */
#line 129
/* #pragma ccuredwrapper("getopt_wrapper",of("getopt")) */
#line 174
/* #pragma ccuredwrapper("read_wrapper",of("read")) */
#line 182
/* #pragma ccuredwrapper("write_wrapper",of("write")) */
#line 195
/* #pragma ccuredwrapper("getusershell_wrapper",of("getusershell")) */
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___1 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___1 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___1 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___1 )) */
#line 303
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___2 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___2 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___2 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___2 )) */
#line 43 "/users/rupak/ccured/include/crypt_wrappers.h"
/* #pragma ccuredwrapper("crypt_wrapper",of("crypt")) */
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___3 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___3 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___3 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___3 )) */
#line 23 "/users/rupak/ccured/include/grp_wrappers.h"
/* #pragma ccuredwrapper("getgrnam_wrapper",of("getgrnam")) */
#line 45
/* #pragma ccuredwrapper("getgrgid_wrapper",of("getgrgid")) */
#line 59
/* #pragma ccuredwrapper("getgrent_wrapper",of("getgrent")) */
#line 443 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("ioctl",sizeof(struct ioctl_format )) */
#line 32 "conf.c"
int read_file(char const   *file_name , cf_t *cf ) ;
#line 33
int add_line_to_file(cl_t *cl , cf_t *cf , uid_t runas , char *runas_str , time_t t_save ) ;
#line 35
int read_strn(int fd , char **str , short size ) ;
#line 36
int read_type(int fd , short *type , short *size ) ;
#line 37
void synchronize_file(char *file_name ) ;
#line 47 "conf.c"
void reload_all(char const   *dir_name ) 
{ cf_t *f ;

  {
#line 52
  f = (cf_t *)((void *)0);
#line 54
  explain((char *)"Removing current configuration from memory");
#line 56
  f = file_base;
#line 57
  while ((unsigned int )f != (unsigned int )((void *)0)) {
#line 58
    if (f->cf_running > 0) {
#line 59
      wait_all(& f->cf_running);
    }
#line 60
    save_file(f);
#line 61
    delete_file((char const   *)f->cf_user);
#line 65
    f = file_base;
  }
#line 68
  synchronize_dir(dir_name);
#line 70
  return;
}
}
#line 73 "conf.c"
void synchronize_dir(char const   *dir_name ) 
{ list_t *rm_list ;
  list_t *new_list ;
  list_t *file_list ;
  list_t *list_cur ;
  DIR *dir ;
  struct dirent *den ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  struct passwd *tmp___7 ;
  int tmp___8 ;
  struct passwd *tmp___9 ;
  int tmp___10 ;
  list_t *l ;
  list_t *next ;

  {
#line 81
  rm_list = (list_t *)((void *)0);
#line 82
  new_list = (list_t *)((void *)0);
#line 83
  file_list = (list_t *)((void *)0);
#line 84
  list_cur = (list_t *)((void *)0);
#line 88
  tmp = strcmp(dir_name, ".");
#line 88
  if (tmp == 0) {
#line 89
    explain((char *)"updating configuration from %s", fcrontabs);
  } else {
#line 91
    explain((char *)"updating configuration from %s", dir_name);
  }
#line 93
  dir = opendir(".");
#line 93
  if (dir) {
#line 94
    while (1) {
#line 94
      den = readdir(dir);
#line 94
      if (! den) {
#line 94
        break;
      }
#line 96
      tmp___2 = strncmp((char const   *)(den->d_name), "rm.", 3U);
#line 96
      if (tmp___2 == 0) {
#line 98
        list_cur = (list_t *)calloc(1U, sizeof(list_t ));
#line 98
        if ((unsigned int )list_cur == (unsigned int )((void *)0)) {
#line 98
          die_e((char *)"Could not calloc.");
        }
#line 99
        list_cur->str = strdup2((char const   *)(den->d_name));
#line 100
        list_cur->next = rm_list;
#line 101
        rm_list = list_cur;
      } else {
#line 104
        tmp___1 = strncmp((char const   *)(den->d_name), "new.", 4U);
#line 104
        if (tmp___1 == 0) {
#line 106
          list_cur = (list_t *)calloc(1U, sizeof(list_t ));
#line 106
          if ((unsigned int )list_cur == (unsigned int )((void *)0)) {
#line 106
            die_e((char *)"Could not calloc.");
          }
#line 107
          list_cur->str = strdup2((char const   *)(den->d_name));
#line 108
          list_cur->next = new_list;
#line 109
          new_list = list_cur;
        } else {
#line 112
          tmp___0 = strchr((char const   *)(den->d_name), '.');
#line 112
          if ((unsigned int )tmp___0 != (unsigned int )((void *)0)) {
#line 113
            continue;
          } else {
#line 118
            if ((unsigned int )file_base == (unsigned int )((void *)0)) {
#line 119
              list_cur = (list_t *)calloc(1U, sizeof(list_t ));
#line 119
              if ((unsigned int )list_cur == (unsigned int )((void *)0)) {
#line 119
                die_e((char *)"Could not calloc.");
              }
#line 120
              list_cur->str = strdup2((char const   *)(den->d_name));
#line 121
              list_cur->next = file_list;
#line 122
              file_list = list_cur;
            }
          }
        }
      }
    }
#line 126
    closedir(dir);
  } else {
#line 128
    die((char *)"Unable to open current dir!");
  }
#line 134
  list_cur = rm_list;
#line 134
  while (list_cur) {
#line 135
    explain((char *)"removing file %s", list_cur->str + 3);
#line 136
    delete_file((char const   *)(list_cur->str + 3));
#line 137
    tmp___3 = remove((char const   *)(list_cur->str + 3));
#line 137
    if (tmp___3 != 0) {
#line 137
      tmp___4 = __errno_location();
#line 137
      if ((*tmp___4) != 2) {
#line 138
        error_e((char *)"Could not remove %s", list_cur->str + 3);
      }
    }
#line 139
    tmp___5 = remove((char const   *)list_cur->str);
#line 139
    if (tmp___5 != 0) {
#line 139
      tmp___6 = __errno_location();
#line 139
      if ((*tmp___6) != 2) {
#line 140
        error_e((char *)"Could not remove %s", list_cur->str);
      }
    }
#line 134
    list_cur = list_cur->next;
  }
#line 144
  list_cur = file_list;
#line 144
  while (list_cur) {
#line 145
    tmp___7 = getpwnam((char const   *)list_cur->str);
#line 145
    if (tmp___7) {
#line 150
      explain((char *)"adding file %s", list_cur->str);
#line 151
      synchronize_file(list_cur->str);
    } else {
#line 145
      tmp___8 = strcmp((char const   *)list_cur->str, "systab");
#line 145
      if (tmp___8 == 0) {
#line 150
        explain((char *)"adding file %s", list_cur->str);
#line 151
        synchronize_file(list_cur->str);
      } else {
#line 154
        error((char *)"ignoring file \"%s\" : not in passwd file.", list_cur->str);
      }
    }
#line 144
    list_cur = list_cur->next;
  }
#line 158
  list_cur = new_list;
#line 158
  while (list_cur) {
#line 160
    tmp___9 = getpwnam((char const   *)(list_cur->str + 4));
#line 160
    if (tmp___9) {
#line 165
      explain((char *)"adding new file %s", list_cur->str + 4);
#line 166
      synchronize_file(list_cur->str);
    } else {
#line 160
      tmp___10 = strcmp((char const   *)(list_cur->str + 4), "systab");
#line 160
      if (tmp___10 == 0) {
#line 165
        explain((char *)"adding new file %s", list_cur->str + 4);
#line 166
        synchronize_file(list_cur->str);
      } else {
#line 169
        error((char *)"ignoring file %s : not in passwd file.", list_cur->str + 4);
      }
    }
#line 158
    list_cur = list_cur->next;
  }
#line 175
  l = (list_t *)((void *)0);
#line 176
  next = (list_t *)((void *)0);
#line 178
  next = rm_list;
#line 179
  while (1) {
#line 179
    l = next;
#line 179
    if (! ((unsigned int )l != (unsigned int )((void *)0))) {
#line 179
      break;
    }
#line 180
    next = l->next;
#line 181
    free((void *)l->str);
#line 182
    free((void *)l);
  }
#line 185
  next = new_list;
#line 186
  while (1) {
#line 186
    l = next;
#line 186
    if (! ((unsigned int )l != (unsigned int )((void *)0))) {
#line 186
      break;
    }
#line 187
    next = l->next;
#line 188
    free((void *)l->str);
#line 189
    free((void *)l);
  }
#line 192
  next = file_list;
#line 193
  while (1) {
#line 193
    l = next;
#line 193
    if (! ((unsigned int )l != (unsigned int )((void *)0))) {
#line 193
      break;
    }
#line 194
    next = l->next;
#line 195
    free((void *)l->str);
#line 196
    free((void *)l);
  }
#line 201
  return;
}
}
#line 204 "conf.c"
void synchronize_file(char *file_name ) 
{ cf_t *cur_f ;
  char *user ;
  cf_t *prev ;
  int tmp ;
  cf_t *old ;
  cl_t *old_l ;
  cl_t *new_l ;
  size_t size ;
  int tmp___0 ;
  struct tm *ftime ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;

  {
#line 208
  cur_f = (cf_t *)((void *)0);
#line 209
  user = (char *)((void *)0);
#line 211
  tmp___7 = strchr((char const   *)file_name, '.');
#line 211
  if ((unsigned int )tmp___7 != (unsigned int )((void *)0)) {
#line 216
    prev = (cf_t *)((void *)0);
#line 221
    user = file_name + 4;
#line 223
    cur_f = file_base;
#line 223
    while (cur_f) {
#line 224
      tmp = strcmp((char const   *)user, (char const   *)cur_f->cf_user);
#line 224
      if (tmp == 0) {
#line 225
        break;
      }
#line 226
      prev = cur_f;
#line 223
      cur_f = cur_f->cf_next;
    }
#line 229
    if ((unsigned int )cur_f != (unsigned int )((void *)0)) {
#line 232
      old = (cf_t *)((void *)0);
#line 233
      old_l = (cl_t *)((void *)0);
#line 234
      new_l = (cl_t *)((void *)0);
#line 237
      size = (size_t )18;
#line 241
      old = cur_f;
#line 244
      cur_f = (cf_t *)calloc(1U, sizeof(cf_t ));
#line 244
      if ((unsigned int )cur_f == (unsigned int )((void *)0)) {
#line 244
        die_e((char *)"Could not calloc.");
      }
#line 245
      tmp___0 = read_file((char const   *)file_name, cur_f);
#line 245
      if (tmp___0 != 0) {
#line 247
        return;
      }
#line 253
      if ((unsigned int )prev != (unsigned int )((void *)0)) {
#line 254
        prev->cf_next = old->cf_next;
#line 255
        old->cf_next = file_base;
#line 256
        file_base = old;
      }
#line 264
      new_l = cur_f->cf_line_base;
#line 264
      while (new_l) {
#line 265
        old_l = old->cf_line_base;
#line 265
        while (old_l) {
#line 269
          tmp___1 = strcmp((char const   *)new_l->cl_shell, (char const   *)old_l->cl_shell);
#line 269
          if (tmp___1 == 0) {
#line 269
            if ((int )new_l->cl_option[0] & 1) {
#line 269
              if (new_l->cl_timefreq == old_l->cl_timefreq) {
                goto _L;
              } else {
                goto _L___0;
              }
            } else {
              _L___0: /* CIL Label */ 
#line 269
              if (! ((int )new_l->cl_option[0] & 1)) {
#line 269
                tmp___2 = memcmp((void const   *)(& new_l->cl_mins), (void const   *)(& old_l->cl_mins),
                                 size);
#line 269
                if (tmp___2 == 0) {
#line 269
                  if (((int )new_l->cl_option[0] & 8) == ((int )old_l->cl_option[0] &
                                                          8)) {
                    _L: /* CIL Label */ 
#line 279
                    if ((int )new_l->cl_runfreq == (int )old_l->cl_runfreq) {
#line 280
                      new_l->cl_remain = old_l->cl_remain;
                    }
#line 282
                    if ((int )(new_l->cl_file)->cf_tzdiff != (int )(old_l->cl_file)->cf_tzdiff) {
#line 282
                      if ((old_l->cl_nextexe - (time_t )(old_l->cl_file)->cf_tzdiff) +
                          (time_t )(new_l->cl_file)->cf_tzdiff > now) {
#line 286
                        new_l->cl_nextexe = (old_l->cl_nextexe - (time_t )(old_l->cl_file)->cf_tzdiff) +
                                            (time_t )(new_l->cl_file)->cf_tzdiff;
                      } else {
#line 290
                        new_l->cl_nextexe = old_l->cl_nextexe;
                      }
                    } else {
#line 290
                      new_l->cl_nextexe = old_l->cl_nextexe;
                    }
#line 291
                    insert_nextexe(new_l);
#line 293
                    if (debug_opt) {
#line 295
                      ftime = localtime((time_t const   *)(& new_l->cl_nextexe));
#line 296
                      if (debug_opt) {
#line 296
                        Debug((char *)"  from last conf: %s next exec %d/%d/%d wday:%d %02d:%02d",
                              new_l->cl_shell, ftime->tm_mon + 1, ftime->tm_mday,
                              ftime->tm_year + 1900, ftime->tm_wday, ftime->tm_hour,
                              ftime->tm_min);
                      }
                    }
#line 303
                    break;
                  }
                }
              }
            }
          }
#line 265
          old_l = old_l->cl_next;
        }
#line 264
        new_l = new_l->cl_next;
      }
#line 309
      delete_file((char const   *)user);
#line 312
      cur_f->cf_next = file_base;
#line 313
      file_base = cur_f;
#line 316
      save_file(cur_f);
#line 319
      tmp___3 = remove((char const   *)file_name);
#line 319
      if (tmp___3 != 0) {
#line 320
        error_e((char *)"could not remove %s", file_name);
      }
    } else {
#line 328
      cur_f = (cf_t *)calloc(1U, sizeof(cf_t ));
#line 328
      if ((unsigned int )cur_f == (unsigned int )((void *)0)) {
#line 328
        die_e((char *)"Could not calloc.");
      }
#line 330
      tmp___4 = read_file((char const   *)file_name, cur_f);
#line 330
      if (tmp___4 != 0) {
#line 332
        return;
      }
#line 336
      cur_f->cf_next = file_base;
#line 337
      file_base = cur_f;
#line 340
      save_file(cur_f);
#line 343
      tmp___5 = remove((char const   *)file_name);
#line 343
      if (tmp___5 != 0) {
#line 344
        error_e((char *)"could not remove %s", file_name);
      }
    }
  } else {
#line 352
    cur_f = (cf_t *)calloc(1U, sizeof(cf_t ));
#line 352
    if ((unsigned int )cur_f == (unsigned int )((void *)0)) {
#line 352
      die_e((char *)"Could not calloc.");
    }
#line 354
    tmp___6 = read_file((char const   *)file_name, cur_f);
#line 354
    if (tmp___6 != 0) {
#line 356
      return;
    }
#line 360
    cur_f->cf_next = file_base;
#line 361
    file_base = cur_f;
  }
#line 365
  return;
}
}
#line 368 "conf.c"
int read_strn(int fd , char **str , short size ) 
{ ssize_t tmp ;

  {
#line 372
  (*str) = (char *)calloc((unsigned int )((int )size + 1), sizeof(char ));
#line 372
  if ((unsigned int )(*str) == (unsigned int )((void *)0)) {
    goto err;
  }
#line 375
  tmp = read(fd, (void *)(*str), (unsigned int )size);
#line 375
  if (tmp < (ssize_t )size) {
    goto err;
  }
#line 377
  (*((*str) + size)) = (char )'\000';
#line 378
  return (0);
  err: 
#line 381
  if ((*str)) {
#line 382
    free((void *)(*str));
  }
#line 383
  (*str) = (char *)((void *)0);
#line 384
  return (-1);
}
}
#line 388 "conf.c"
int read_type(int fd , short *type , short *size ) 
{ ssize_t tmp ;
  ssize_t tmp___0 ;

  {
#line 392
  tmp = read(fd, (void *)type, sizeof(short ));
#line 392
  if ((unsigned int )tmp < sizeof(short )) {
    goto err;
  }
#line 394
  tmp___0 = read(fd, (void *)size, sizeof(short ));
#line 394
  if ((unsigned int )tmp___0 < sizeof(short )) {
    goto err;
  }
#line 397
  return (0);
  err: 
#line 400
  return (-1);
}
}
#line 423 "conf.c"
int read_file(char const   *file_name , cf_t *cf ) 
{ FILE *ff ;
  cl_t *cl ;
  env_t *env ;
  char buf[1024] ;
  long bufi ;
  time_t t_save ;
  uid_t runas ;
  char *runas_str ;
  struct stat file_stat ;
  struct passwd *pass ;
  short type ;
  short size ;
  int rc ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  ssize_t tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  ssize_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  ssize_t tmp___24 ;
  int tmp___25 ;
  ssize_t tmp___26 ;
  int tmp___27 ;
  ssize_t tmp___28 ;
  int tmp___29 ;
  ssize_t tmp___30 ;
  int tmp___31 ;
  ssize_t tmp___32 ;
  int tmp___33 ;
  ssize_t tmp___34 ;
  int tmp___35 ;
  ssize_t tmp___36 ;
  int tmp___37 ;
  ssize_t tmp___38 ;
  int tmp___39 ;
  ssize_t tmp___40 ;
  int tmp___41 ;
  ssize_t tmp___42 ;
  int tmp___43 ;
  ssize_t tmp___44 ;
  int tmp___45 ;
  ssize_t tmp___46 ;
  int tmp___47 ;
  ssize_t tmp___48 ;
  int tmp___49 ;
  ssize_t tmp___50 ;
  int tmp___51 ;
  ssize_t tmp___52 ;
  int tmp___53 ;
  int i ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;

  {
#line 428
  ff = (FILE *)((void *)0);
#line 429
  cl = (cl_t *)((void *)0);
#line 430
  env = (env_t *)((void *)0);
#line 432
  bufi = 0L;
#line 433
  t_save = (time_t )0;
#line 434
  runas = (uid_t )0;
#line 435
  runas_str = (char *)((void *)0);
#line 437
  pass = (struct passwd *)((void *)0);
#line 438
  type = 0;
#line 438
  size = 0;
#line 448
  ff = fopen((char const   */* __restrict  */)file_name, (char const   */* __restrict  */)"r");
#line 448
  if ((unsigned int )ff == (unsigned int )((void *)0)) {
#line 449
    warn_e((char *)"Could not read %s (may have just been removed)", file_name);
    goto err;
  }
#line 455
  tmp = fileno(ff);
#line 455
  rc = fstat__extinline(tmp, & file_stat);
#line 456
  if (rc != 0) {
#line 457
    error_e((char *)"Could not stat %s", file_name);
    goto err;
  }
#line 468
  tmp___0 = strncmp(file_name, "new.", 4U);
#line 468
  if (tmp___0 == 0) {
#line 469
    if (file_stat.st_uid == 0U) {
#line 471
      runas = 0U;
    } else {
#line 476
      runas = file_stat.st_uid;
#line 477
      pass = getpwuid(file_stat.st_uid);
#line 477
      if ((unsigned int )pass == (unsigned int )((void *)0)) {
#line 478
        error_e((char *)"Could not getpwuid(%d)", file_stat.st_uid);
        goto err;
      }
#line 481
      runas_str = strdup2((char const   *)pass->pw_name);
    }
#line 483
    cf->cf_user = strdup2(file_name + 4);
  } else {
#line 486
    if (! cf->cf_user) {
#line 487
      cf->cf_user = strdup2(file_name);
    }
#line 488
    if (file_stat.st_uid == 0U) {
#line 491
      runas = 0U;
    } else {
#line 494
      error((char *)"Non-new file %s owned by someone else than root", file_name);
      goto err;
    }
  }
#line 528
  if (debug_opt) {
#line 528
    Debug((char *)"User %s Entry", file_name);
  }
#line 529
  bzero((void *)(buf), sizeof(buf));
#line 535
  tmp___1 = fileno(ff);
#line 535
  tmp___2 = read_type(tmp___1, & type, & size);
#line 535
  if (tmp___2 != 0) {
#line 537
    error((char *)"File %s is not valid: ignored.", file_name);
#line 538
    error((char *)"This file may have been generated by an old version of fcron.");
#line 539
    error((char *)"In that case, you should try to use the converter given in the source package, or install it again using fcrontab.");
    goto err;
  } else {
#line 535
    if ((int )type != 1) {
#line 537
      error((char *)"File %s is not valid: ignored.", file_name);
#line 538
      error((char *)"This file may have been generated by an old version of fcron.");
#line 539
      error((char *)"In that case, you should try to use the converter given in the source package, or install it again using fcrontab.");
      goto err;
    } else {
#line 535
      tmp___3 = fileno(ff);
#line 535
      tmp___4 = read(tmp___3, (void *)(& bufi), (unsigned int )size);
#line 535
      if (tmp___4 < (ssize_t )size) {
#line 537
        error((char *)"File %s is not valid: ignored.", file_name);
#line 538
        error((char *)"This file may have been generated by an old version of fcron.");
#line 539
        error((char *)"In that case, you should try to use the converter given in the source package, or install it again using fcrontab.");
        goto err;
      } else {
#line 535
        if (bufi != 100L) {
#line 537
          error((char *)"File %s is not valid: ignored.", file_name);
#line 538
          error((char *)"This file may have been generated by an old version of fcron.");
#line 539
          error((char *)"In that case, you should try to use the converter given in the source package, or install it again using fcrontab.");
          goto err;
        }
      }
    }
  }
#line 544
  tmp___5 = fileno(ff);
#line 544
  tmp___6 = read_type(tmp___5, & type, & size);
#line 544
  if (tmp___6 != 0) {
#line 545
    error((char *)"Invalid binary fcrontab (no USER field)");
    goto err;
  } else {
#line 544
    if ((int )type != 2) {
#line 545
      error((char *)"Invalid binary fcrontab (no USER field)");
      goto err;
    }
  }
#line 550
  free((void *)cf->cf_user);
#line 551
  tmp___7 = fileno(ff);
#line 551
  tmp___8 = read_strn(tmp___7, & cf->cf_user, size);
#line 551
  if (tmp___8 != 0) {
#line 552
    error((char *)"Cannot read user\'s name : file ignored");
    goto err;
  }
#line 555
  if (runas != 0U) {
#line 559
    free((void *)cf->cf_user);
#line 560
    cf->cf_user = runas_str;
  }
#line 565
  tmp___9 = fileno(ff);
#line 565
  tmp___10 = read_type(tmp___9, & type, & size);
#line 565
  if (tmp___10 != 0) {
#line 567
    error((char *)"could not get time and date of saving");
    goto err;
  } else {
#line 565
    if ((int )type != 3) {
#line 567
      error((char *)"could not get time and date of saving");
      goto err;
    } else {
#line 565
      tmp___11 = fileno(ff);
#line 565
      tmp___12 = read(tmp___11, (void *)(& t_save), (unsigned int )size);
#line 565
      if (tmp___12 < (ssize_t )size) {
#line 567
        error((char *)"could not get time and date of saving");
        goto err;
      }
    }
  }
#line 571
  cl = (cl_t *)calloc(1U, sizeof(cl_t ));
#line 571
  if ((unsigned int )cl == (unsigned int )((void *)0)) {
#line 571
    die_e((char *)"Could not calloc.");
  }
#line 573
  while (1) {
#line 573
    tmp___55 = fileno(ff);
#line 573
    tmp___56 = read_type(tmp___55, & type, & size);
#line 573
    if (! (tmp___56 == 0)) {
#line 573
      break;
    }
#line 575
    switch ((int )type) {
    case 1000: 
#line 579
    env = (env_t *)calloc(1U, sizeof(env_t ));
#line 579
    if ((unsigned int )env == (unsigned int )((void *)0)) {
#line 579
      die_e((char *)"Could not calloc.");
    }
#line 580
    tmp___13 = fileno(ff);
#line 580
    tmp___14 = read_strn(tmp___13, & env->e_val, size);
#line 580
    if (tmp___14 != 0) {
#line 580
      error_e((char *)"Error while reading env var");
      goto err;
    }
#line 582
    if (debug_opt) {
#line 582
      Debug((char *)"  Env: \"%s\"", env->e_val);
    }
#line 583
    env->e_next = cf->cf_env_base;
#line 584
    cf->cf_env_base = env;
#line 585
    break;
    case 4: 
#line 589
    tmp___15 = fileno(ff);
#line 589
    tmp___16 = read(tmp___15, (void *)(& bufi), (unsigned int )size);
#line 589
    if (tmp___16 < (ssize_t )size) {
#line 589
      error_e((char *)"Error while reading tzdiff field");
      goto err;
    }
#line 590
    cf->cf_tzdiff = (signed char )bufi;
#line 591
    break;
    case 2001: 
#line 594
    tmp___17 = fileno(ff);
#line 594
    tmp___18 = read_strn(tmp___17, & cl->cl_shell, size);
#line 594
    if (tmp___18 != 0) {
#line 594
      error_e((char *)"Error while reading shell field");
      goto err;
    }
#line 595
    break;
    case 2006: 
#line 598
    tmp___19 = fileno(ff);
#line 598
    tmp___20 = read_strn(tmp___19, & cl->cl_runas, size);
#line 598
    if (tmp___20 != 0) {
#line 598
      error_e((char *)"Error while reading runas field");
      goto err;
    }
#line 599
    break;
    case 2007: 
#line 602
    tmp___21 = fileno(ff);
#line 602
    tmp___22 = read_strn(tmp___21, & cl->cl_mailto, size);
#line 602
    if (tmp___22 != 0) {
#line 602
      error_e((char *)"Error while reading mailto field");
      goto err;
    }
#line 603
    break;
    case 2008: 
#line 606
    tmp___23 = fileno(ff);
#line 606
    tmp___24 = read(tmp___23, (void *)(& bufi), (unsigned int )size);
#line 606
    if (tmp___24 < (ssize_t )size) {
#line 606
      error_e((char *)"Error while reading nextexe field");
      goto err;
    }
#line 607
    cl->cl_nextexe = bufi;
#line 608
    break;
    case 2018: 
#line 611
    tmp___25 = fileno(ff);
#line 611
    tmp___26 = read(tmp___25, (void *)(& bufi), (unsigned int )size);
#line 611
    if (tmp___26 < (ssize_t )size) {
#line 611
      error_e((char *)"Error while reading first field");
      goto err;
    }
#line 612
    cl->cl_first = bufi;
#line 613
    break;
    case 2017: ;
#line 616
    if ((int )size < 4) {

    }
#line 619
    tmp___27 = fileno(ff);
#line 619
    tmp___28 = read(tmp___27, (void *)(& cl->cl_option), (unsigned int )size);
#line 619
    if (tmp___28 < (ssize_t )size) {
#line 619
      error_e((char *)"Error while reading option field");
      goto err;
    }
#line 620
    break;
    case 2002: 
#line 623
    tmp___29 = fileno(ff);
#line 623
    tmp___30 = read(tmp___29, (void *)(& cl->cl_numexe), (unsigned int )size);
#line 623
    if (tmp___30 < (ssize_t )size) {
#line 623
      error_e((char *)"Error while reading numexe field");
      goto err;
    }
#line 624
    break;
    case 2003: 
#line 627
    tmp___31 = fileno(ff);
#line 627
    tmp___32 = read(tmp___31, (void *)(& cl->cl_lavg), (unsigned int )size);
#line 627
    if (tmp___32 < (ssize_t )size) {
#line 627
      error_e((char *)"Error while reading lavg field");
      goto err;
    }
#line 628
    break;
    case 2004: 
#line 631
    tmp___33 = fileno(ff);
#line 631
    tmp___34 = read(tmp___33, (void *)(& bufi), (unsigned int )size);
#line 631
    if (tmp___34 < (ssize_t )size) {
#line 631
      error_e((char *)"Error while reading until field");
      goto err;
    }
#line 632
    cl->cl_until = bufi;
#line 633
    break;
    case 2005: 
#line 636
    tmp___35 = fileno(ff);
#line 636
    tmp___36 = read(tmp___35, (void *)(& cl->cl_nice), (unsigned int )size);
#line 636
    if (tmp___36 < (ssize_t )size) {
#line 636
      error_e((char *)"Error while reading nice field");
      goto err;
    }
#line 637
    break;
    case 2011: 
#line 640
    tmp___37 = fileno(ff);
#line 640
    tmp___38 = read(tmp___37, (void *)(& bufi), (unsigned int )size);
#line 640
    if (tmp___38 < (ssize_t )size) {
#line 640
      error_e((char *)"Error while reading runfreq field");
      goto err;
    }
#line 641
    cl->cl_runfreq = (unsigned short )bufi;
#line 642
    break;
    case 2009: 
#line 645
    tmp___39 = fileno(ff);
#line 645
    tmp___40 = read(tmp___39, (void *)(& bufi), (unsigned int )size);
#line 645
    if (tmp___40 < (ssize_t )size) {
#line 645
      error_e((char *)"Error while reading remain field");
      goto err;
    }
#line 646
    cl->cl_remain = (unsigned short )bufi;
#line 647
    break;
    case 2010: 
#line 650
    tmp___41 = fileno(ff);
#line 650
    tmp___42 = read(tmp___41, (void *)(& bufi), (unsigned int )size);
#line 650
    if (tmp___42 < (ssize_t )size) {
#line 650
      error_e((char *)"Error while reading timefreq field");
      goto err;
    }
#line 651
    cl->cl_timefreq = bufi;
#line 652
    break;
    case 2012: 
#line 655
    tmp___43 = fileno(ff);
#line 655
    tmp___44 = read(tmp___43, (void *)(& cl->cl_mins), (unsigned int )size);
#line 655
    if (tmp___44 < (ssize_t )size) {
#line 655
      error_e((char *)"Error while reading mins field");
      goto err;
    }
#line 656
    break;
    case 2013: 
#line 659
    tmp___45 = fileno(ff);
#line 659
    tmp___46 = read(tmp___45, (void *)(& cl->cl_hrs), (unsigned int )size);
#line 659
    if (tmp___46 < (ssize_t )size) {
#line 659
      error_e((char *)"Error while reading hrs field");
      goto err;
    }
#line 660
    break;
    case 2014: 
#line 663
    tmp___47 = fileno(ff);
#line 663
    tmp___48 = read(tmp___47, (void *)(& cl->cl_days), (unsigned int )size);
#line 663
    if (tmp___48 < (ssize_t )size) {
#line 663
      error_e((char *)"Error while reading days field");
      goto err;
    }
#line 664
    break;
    case 2015: 
#line 667
    tmp___49 = fileno(ff);
#line 667
    tmp___50 = read(tmp___49, (void *)(& cl->cl_mons), (unsigned int )size);
#line 667
    if (tmp___50 < (ssize_t )size) {
#line 667
      error_e((char *)"Error while reading mons field");
      goto err;
    }
#line 668
    break;
    case 2016: 
#line 671
    tmp___51 = fileno(ff);
#line 671
    tmp___52 = read(tmp___51, (void *)(& cl->cl_dow), (unsigned int )size);
#line 671
    if (tmp___52 < (ssize_t )size) {
#line 671
      error_e((char *)"Error while reading dow field");
      goto err;
    }
#line 672
    break;
    case 2000: 
#line 675
    tmp___53 = add_line_to_file(cl, cf, runas, runas_str, t_save);
#line 675
    if (tmp___53 == 0) {
#line 676
      cl = (cl_t *)calloc(1U, sizeof(cl_t ));
#line 676
      if ((unsigned int )cl == (unsigned int )((void *)0)) {
#line 676
        die_e((char *)"Could not calloc.");
      }
    }
#line 677
    break;
    default: 
#line 681
    error((char *)"Error while loading %s : unknown field type %d (ignored)", file_name,
          type);
#line 688
    i = 0;
#line 688
    while (i < (int )size) {
#line 689
      tmp___54 = _IO_getc(ff);
#line 689
      if (tmp___54 == -1) {
        goto err;
      }
#line 688
      i ++;
    }
    }
  }
#line 696
  free((void *)cl);
#line 699
  tmp___57 = ferror(ff);
#line 699
  if (tmp___57 != 0) {
#line 700
    error((char *)"file %s is truncated : you should reinstall it with fcrontab",
          file_name);
  }
#line 703
  fclose(ff);
#line 705
  return (0);
  err: 
#line 708
  if ((unsigned int )ff != (unsigned int )((void *)0)) {
#line 709
    fclose(ff);
  }
#line 711
  if ((unsigned int )cl != (unsigned int )((void *)0)) {
#line 711
    if ((unsigned int )cl->cl_next == (unsigned int )((void *)0)) {
#line 713
      if (cl->cl_shell) {
#line 713
        free((void *)cl->cl_shell);
      }
#line 714
      if (cl->cl_runas) {
#line 714
        free((void *)cl->cl_runas);
      }
#line 715
      if (cl->cl_mailto) {
#line 715
        free((void *)cl->cl_mailto);
      }
#line 716
      free((void *)cl);
    }
  }
#line 720
  if ((unsigned int )cl != (unsigned int )((void *)0)) {
#line 724
    cf->cf_next = file_base;
#line 725
    file_base = cf;
#line 727
    delete_file((char const   *)cf->cf_user);
  } else {
#line 730
    if ((unsigned int )cf->cf_user != (unsigned int )((void *)0)) {
#line 731
      free((void *)cf->cf_user);
    }
  }
#line 733
  return (-1);
}
}
#line 738 "conf.c"
int add_line_to_file(cl_t *cl , cf_t *cf , uid_t runas , char *runas_str , time_t t_save ) 
{ time_t slept ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  struct tm *since2 ;
  struct tm *tmp___2 ;
  struct tm since ;
  struct tm *ftime ;
  unsigned long tmp___3 ;

  {
#line 742
  slept = now - t_save;
#line 744
  if ((unsigned int )cl->cl_shell == (unsigned int )((void *)0)) {
    goto _L;
  } else {
#line 744
    if ((unsigned int )cl->cl_runas == (unsigned int )((void *)0)) {
      goto _L;
    } else {
#line 744
      if ((unsigned int )cl->cl_mailto == (unsigned int )((void *)0)) {
        _L: /* CIL Label */ 
#line 746
        error((char *)"Line is not valid (empty shell, runas or mailto field) : ignored");
#line 748
        bzero((void *)cl, sizeof(cl));
#line 749
        if (cl->cl_shell) {
#line 749
          free((void *)cl->cl_shell);
        }
#line 750
        if (cl->cl_runas) {
#line 750
          free((void *)cl->cl_runas);
        }
#line 751
        if (cl->cl_mailto) {
#line 751
          free((void *)cl->cl_mailto);
        }
#line 752
        return (1);
      }
    }
  }
#line 756
  if (runas != 0U) {
#line 757
    tmp = strcmp((char const   *)cl->cl_runas, (char const   *)runas_str);
#line 757
    if (tmp != 0) {
#line 758
      warn((char *)"warning: runas(%s) is not owner (%s): overridden.", cl->cl_runas,
           runas_str);
    }
#line 760
    free((void *)cl->cl_runas);
#line 760
    cl->cl_runas = strdup2((char const   *)runas_str);
  }
#line 765
  cl->cl_file = cf;
#line 768
  if (cl->cl_mailto) {
#line 768
    if ((int )(*(cl->cl_mailto)) == 45) {
#line 770
      error((char *)"mailto field \'%s\' is not valid : set to owner %s.", cl->cl_mailto,
            (cl->cl_file)->cf_user);
#line 772
      free((void *)cl->cl_mailto);
#line 773
      cl->cl_mailto = strdup2((char const   *)(cl->cl_file)->cf_user);
    } else {
#line 768
      tmp___0 = strcspn((char const   *)cl->cl_mailto, " \t\n");
#line 768
      tmp___1 = strlen((char const   *)cl->cl_mailto);
#line 768
      if (tmp___0 != tmp___1) {
#line 770
        error((char *)"mailto field \'%s\' is not valid : set to owner %s.", cl->cl_mailto,
              (cl->cl_file)->cf_user);
#line 772
        free((void *)cl->cl_mailto);
#line 773
        cl->cl_mailto = strdup2((char const   *)(cl->cl_file)->cf_user);
      }
    }
  }
#line 778
  if ((int )cl->cl_numexe > 0) {
#line 779
    cl->cl_numexe = 0;
#line 780
    if ((int )cl->cl_option[0] & 2) {
#line 781
      if (! (! ((int )cl->cl_option[2] & 16))) {
#line 782
        add_lavg_job(cl, -1);
      }
    } else {
#line 784
      if ((int )cl->cl_option[0] & 32) {
#line 786
        add_serial_job(cl, -1);
      } else {
#line 784
        if ((int )cl->cl_option[0] & 64) {
#line 786
          add_serial_job(cl, -1);
        } else {
#line 790
          warn((char *)"job %s did not finish : running it again.", cl->cl_shell);
#line 792
          cl->cl_option[0] = (unsigned char )((int )cl->cl_option[0] | 64);
#line 793
          add_serial_job(cl, -1);
        }
      }
    }
  }
#line 797
  if (! ((int )cl->cl_option[0] & 1)) {
#line 800
    if (cl->cl_nextexe <= now) {
#line 801
      if (cl->cl_nextexe == 0L) {
#line 803
        set_next_exe(cl, 1, -1);
      } else {
#line 804
        if ((int )cl->cl_runfreq == 1) {
#line 804
          if ((int )cl->cl_option[2] & 32) {
#line 806
            set_next_exe_notrun(cl, 2);
          } else {
            goto _L___3;
          }
        } else {
          _L___3: /* CIL Label */ 
#line 807
          if ((int )cl->cl_option[0] & 16) {
#line 807
            if (t_save != 0L) {
#line 807
              if ((int )cl->cl_runfreq != 1) {
#line 809
                if ((int )cl->cl_remain > 0) {
#line 809
                  cl->cl_remain = (unsigned short )((int )cl->cl_remain - 1);
#line 809
                  if (cl->cl_remain > 0) {
#line 810
                    if (debug_opt) {
#line 810
                      Debug((char *)"    cl_remain: %d", cl->cl_remain);
                    }
                  } else {
                    goto _L___0;
                  }
                } else {
                  _L___0: /* CIL Label */ 
#line 814
                  cl->cl_remain = cl->cl_runfreq;
#line 815
                  if (debug_opt) {
#line 815
                    Debug((char *)"   boot-run %s", cl->cl_shell);
                  }
#line 816
                  if (! ((int )cl->cl_option[0] & 2)) {
#line 817
                    cl->cl_option[0] = (unsigned char )((int )cl->cl_option[0] | 64);
#line 818
                    add_serial_job(cl, -1);
                  } else {
#line 821
                    add_lavg_job(cl, -1);
                  }
                }
#line 823
                set_next_exe(cl, 0, -1);
              } else {
                goto _L___2;
              }
            } else {
              goto _L___2;
            }
          } else {
            _L___2: /* CIL Label */ 
#line 826
            if ((int )cl->cl_option[2] & 32) {
#line 828
              tmp___2 = localtime((time_t const   *)(& cl->cl_nextexe));
#line 828
              since2 = tmp___2;
#line 830
              memcpy((void */* __restrict  */)(& since), (void const   */* __restrict  */)since2,
                     sizeof(since));
#line 831
              set_next_exe(cl, 1, -1);
#line 832
              mail_notrun(cl, 2, & since);
            } else {
#line 835
              set_next_exe(cl, 1, -1);
            }
          }
        }
      }
    } else {
#line 840
      insert_nextexe(cl);
    }
  } else {
#line 843
    if ((int )cl->cl_option[3] & 1) {
#line 845
      cl->cl_nextexe = now + cl->cl_first;
    } else {
#line 847
      cl->cl_nextexe = cl->cl_nextexe + slept;
    }
#line 849
    if (cl->cl_timefreq < 10L) {
#line 850
      error((char *)"Invalid timefreq for %s: set to 1 day", cl->cl_shell);
#line 852
      cl->cl_timefreq = 86400L;
    }
#line 854
    insert_nextexe(cl);
  }
#line 857
  if (debug_opt) {
#line 859
    ftime = localtime((time_t const   *)(& cl->cl_nextexe));
#line 860
    if (debug_opt) {
#line 860
      Debug((char *)"  cmd %s next exec %d/%d/%d wday:%d %02d:%02d:%02d", cl->cl_shell,
            ftime->tm_mon + 1, ftime->tm_mday, ftime->tm_year + 1900, ftime->tm_wday,
            ftime->tm_hour, ftime->tm_min, ftime->tm_sec);
    }
  }
#line 867
  tmp___3 = next_id;
#line 867
  next_id = next_id + 1UL;
#line 867
  cl->cl_id = (long )tmp___3;
#line 867
  if ((unsigned long )cl->cl_id >= 4294967294UL) {
#line 868
    next_id = 0UL;
  }
#line 869
  cl->cl_next = cf->cf_line_base;
#line 870
  cf->cf_line_base = cl;
#line 871
  return (0);
}
}
#line 874 "conf.c"
void delete_file(char const   *user_name ) 
{ cf_t *file ;
  cf_t *prev_file ;
  cl_t *line ;
  cl_t *cur_line ;
  env_t *env ;
  env_t *cur_env ;
  struct job_t *j ;
  struct job_t *prev_j ;
  int i ;
  int k ;
  struct cl_t **s_a ;
  int tmp ;

  {
#line 880
  prev_file = (cf_t *)((void *)0);
#line 883
  env = (env_t *)((void *)0);
#line 884
  cur_env = (env_t *)((void *)0);
#line 885
  j = (struct job_t *)((void *)0);
#line 888
  s_a = (struct cl_t **)((void *)0);
#line 890
  file = file_base;
#line 891
  while ((unsigned int )file != (unsigned int )((void *)0)) {
#line 892
    tmp = strcmp(user_name, (char const   *)file->cf_user);
#line 892
    if (tmp != 0) {
#line 893
      prev_file = file;
#line 894
      file = file->cf_next;
#line 895
      continue;
    }
#line 898
    i = 0;
#line 898
    while (i < (int )exe_num) {
#line 899
      if ((unsigned int )(exe_array + i)->e_line != (unsigned int )((void *)0)) {
#line 899
        if ((unsigned int )((exe_array + i)->e_line)->cl_file == (unsigned int )file) {
#line 905
          if ((int )((exe_array + i)->e_line)->cl_option[0] & 32) {
            goto _L___0;
          } else {
#line 905
            if ((int )((exe_array + i)->e_line)->cl_option[0] & 64) {
              _L___0: /* CIL Label */ 
#line 905
              if (! ((int )((exe_array + i)->e_line)->cl_option[0] & 2)) {
#line 908
                serial_running = (short )((int )serial_running - 1);
              } else {
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
#line 909
              if ((int )((exe_array + i)->e_line)->cl_option[0] & 32) {
#line 909
                if ((int )((exe_array + i)->e_line)->cl_option[0] & 2) {
#line 911
                  lavg_serial_running = (short )((int )lavg_serial_running - 1);
                }
              }
            }
          }
#line 912
          (exe_array + i)->e_line = (struct cl_t *)((void *)0);
        }
      }
#line 898
      i ++;
    }
#line 916
    i = 0;
#line 917
    while (i < (int )lavg_num) {
#line 918
      if ((unsigned int )((lavg_array + i)->l_line)->cl_file == (unsigned int )file) {
#line 919
        if (debug_opt) {
#line 919
          Debug((char *)"removing %s from lavg queue", ((lavg_array + i)->l_line)->cl_shell);
        }
#line 921
        ((lavg_array + i)->l_line)->cl_numexe = (unsigned char )((int )((lavg_array +
                                                                         i)->l_line)->cl_numexe -
                                                                 1);
#line 922
        lavg_num = (short )((int )lavg_num - 1);
#line 922
        if (i < lavg_num) {
#line 923
          (*(lavg_array + i)) = (*(lavg_array + lavg_num));
#line 924
          (lavg_array + lavg_num)->l_line = (struct cl_t *)((void *)0);
        } else {
#line 927
          (lavg_array + i)->l_line = (struct cl_t *)((void *)0);
        }
      } else {
#line 930
        i ++;
      }
    }
#line 933
    i = 0;
#line 933
    while (i < (int )serial_array_size) {
#line 934
      if ((unsigned int )(*(serial_array + i)) != (unsigned int )((void *)0)) {
#line 934
        if ((unsigned int )((*(serial_array + i)))->cl_file == (unsigned int )file) {
#line 935
          if (! s_a) {
#line 936
            s_a = (struct cl_t **)calloc((unsigned int )serial_array_size, sizeof(cl_t *));
          }
#line 937
          if (debug_opt) {
#line 937
            Debug((char *)"removing %s from serial queue", ((*(serial_array + i)))->cl_shell);
          }
#line 939
          serial_num = (short )((int )serial_num - 1);
#line 940
          ((*(serial_array + i)))->cl_numexe = (unsigned char )((int )((*(serial_array +
                                                                          i)))->cl_numexe -
                                                                1);
#line 941
          (*(serial_array + i)) = (struct cl_t *)((void *)0);
        }
      }
#line 933
      i ++;
    }
#line 945
    if (! s_a) {
      goto end_of_serial_recomputing;
    }
#line 948
    k = (int )serial_array_index + (int )serial_num;
#line 948
    if (k >= (int )serial_array_size) {
#line 949
      k -= (int )serial_array_size;
    }
#line 950
    k = 0;
#line 950
    i = k;
#line 950
    while (i < (int )serial_array_size) {
#line 951
      if ((int )serial_array_index + i < (int )serial_array_size) {
#line 952
        (*(s_a + k)) = (*(serial_array + ((int )serial_array_index + i)));
#line 952
        if ((unsigned int )(*(s_a + k)) != (unsigned int )((void *)0)) {
#line 953
          k ++;
        }
      } else {
#line 956
        (*(s_a + k)) = (*(serial_array + (((int )serial_array_index + i) - (int )serial_array_size)));
#line 956
        if ((unsigned int )(*(s_a + k)) != (unsigned int )((void *)0)) {
#line 959
          k ++;
        }
      }
#line 950
      i ++;
    }
#line 961
    free((void *)serial_array);
#line 962
    serial_array = s_a;
#line 963
    serial_array_index = 0;
    end_of_serial_recomputing: 
#line 968
    cur_line = file->cf_line_base;
#line 969
    while (1) {
#line 969
      line = cur_line;
#line 969
      if (! ((unsigned int )line != (unsigned int )((void *)0))) {
#line 969
        break;
      }
#line 970
      cur_line = line->cl_next;
#line 973
      prev_j = (struct job_t *)((void *)0);
#line 974
      j = queue_base;
#line 974
      while ((unsigned int )j != (unsigned int )((void *)0)) {
#line 975
        if ((unsigned int )j->j_line == (unsigned int )line) {
#line 976
          if ((unsigned int )prev_j != (unsigned int )((void *)0)) {
#line 977
            prev_j->j_next = j->j_next;
          } else {
#line 979
            queue_base = j->j_next;
          }
#line 980
          free((void *)j);
#line 981
          break;
        } else {
#line 984
          prev_j = j;
        }
#line 974
        j = j->j_next;
      }
#line 987
      free((void *)line->cl_shell);
#line 988
      free((void *)line->cl_runas);
#line 989
      free((void *)line->cl_mailto);
#line 990
      free((void *)line);
    }
#line 994
    break;
  }
#line 997
  if ((unsigned int )file == (unsigned int )((void *)0)) {
#line 999
    return;
  }
#line 1002
  if ((unsigned int )prev_file == (unsigned int )((void *)0)) {
#line 1003
    file_base = file->cf_next;
  } else {
#line 1005
    prev_file->cf_next = file->cf_next;
  }
#line 1008
  cur_env = file->cf_env_base;
#line 1009
  while (1) {
#line 1009
    env = cur_env;
#line 1009
    if (! ((unsigned int )env != (unsigned int )((void *)0))) {
#line 1009
      break;
    }
#line 1010
    cur_env = env->e_next;
#line 1011
    free((void *)env->e_val);
#line 1012
    free((void *)env);
  }
#line 1016
  free((void *)file->cf_user);
#line 1017
  free((void *)file);
#line 1019
  return;
}
}
#line 1022 "conf.c"
void save_file(struct cf_t *arg_file ) 
{ cf_t *file ;
  cf_t *start_file ;

  {
#line 1027
  file = (cf_t *)((void *)0);
#line 1028
  start_file = (cf_t *)((void *)0);
#line 1030
  if ((unsigned int )arg_file != (unsigned int )((void *)0)) {
#line 1031
    start_file = arg_file;
  } else {
#line 1033
    start_file = file_base;
  }
#line 1036
  file = start_file;
#line 1036
  while (file) {
#line 1038
    if (debug_opt) {
#line 1038
      Debug((char *)"Saving %s...", file->cf_user);
    }
#line 1043
    save_file_safe(file, file->cf_user, (char *)"fcron", 0U, 0U, now);
#line 1045
    if ((unsigned int )arg_file != (unsigned int )((void *)0)) {
#line 1047
      break;
    }
#line 1036
    file = file->cf_next;
  }
#line 1049
  return;
}
}
#line 1 "socket.o"
/* #pragma merger(0,"./socket.i","-O2 -Wall") */
#line 123 "/users/rupak/ccured/include/ccuredannot.h"
/* #pragma cilnoremove("__ccuredInit") */
#line 20 "/users/rupak/ccured/include/ccured.h"
/* #pragma cilnoremove("wrapperAlloc") */
#line 21
/* #pragma ccuredalloc("wrapperAlloc",sizein(1),nozero) */
#line 24
/* #pragma cilnoremove("wrapperFree") */
#line 25
/* #pragma ccuredpoly("wrapperFree") */
#line 29
/* #pragma cilnoremove("wrapperStrdup") */
#line 30
/* #pragma ccuredpoly("wrapperStrdup") */
#line 50
/* #pragma ccuredpoly("__ptrof_nocheck") */
#line 51
/* #pragma cilnoremove("__ptrof_nocheck") */
#line 57
/* #pragma ccuredpoly("__startof") */
#line 63
/* #pragma ccuredpoly("__endof") */
#line 78
/* #pragma ccuredpoly("__ptrof") */
#line 84
/* #pragma ccuredpoly("__ptrof_size") */
#line 85
/* #pragma cilnoremove("__ptrof_size") */
#line 92
/* #pragma ccuredpoly("__verify_nul") */
#line 101
/* #pragma ccuredpoly("__strlen") */
#line 111
/* #pragma ccuredpoly("__strlen_n") */
#line 125
/* #pragma ccuredpoly("__stringof") */
#line 127
/* #pragma cilnoremove("__stringof") */
#line 136
/* #pragma ccuredpoly("__stringof_ornull") */
#line 138
/* #pragma cilnoremove("__stringof_ornull") */
#line 147
/* #pragma ccuredpoly("__write_at_least") */
#line 155
/* #pragma ccuredpoly("__read_at_least") */
#line 162
/* #pragma ccuredpoly("__copytags") */
#line 180
/* #pragma ccuredpoly("__mkptr") */
#line 181
/* #pragma cilnoremove("__mkptr") */
#line 188
/* #pragma ccuredpoly("__mkptr_int") */
#line 196
/* #pragma ccuredpoly("__mkptr_size") */
#line 197
/* #pragma cilnoremove("__mkptr_size") */
#line 206
/* #pragma ccuredpoly("__mkptr_string") */
#line 207
/* #pragma cilnoremove("__mkptr_string") */
#line 215
/* #pragma ccuredpoly("__align_seq") */
#line 216
/* #pragma cilnoremove("__align_seq") */
#line 227
/* #pragma ccuredpoly("__trusted_cast") */
#line 228
/* #pragma cilnoremove("__trusted_cast") */
#line 237
/* #pragma ccuredpoly("__trusted_deepcast") */
#line 238
/* #pragma cilnoremove("__trusted_deepcast") */
#line 250
/* #pragma ccuredpoly("ccured_hasuniontag") */
#line 259
/* #pragma ccuredpoly("__ccured_kind_of") */
#line 307
/* #pragma ccuredpoly("__ccured_mangling_of") */
#line 308
/* #pragma cilnoremove("__ccured_mangling_of") */
#line 312
/* #pragma ccuredpoly("__ccured_has_empty_mangling") */
#line 313
/* #pragma cilnoremove("__ccured_has_empty_mangling") */
#line 327
/* #pragma cilnoremove("abort_deepcopy") */
#line 451
/* #pragma cilnoremove("struct printf_arguments") */
#line 45 "/users/rupak/ccured/include/time_wrappers.h"
/* #pragma ccuredwrapper("time_wrapper",of("time")) */
#line 59
/* #pragma ccuredwrapper("ctime_wrapper",of("ctime")) */
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments )) */
#line 266
/* #pragma ccuredpoly("__ccured_va_arg") */
#line 303
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___0 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___0 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___0 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___0 )) */
#line 69 "/users/rupak/ccured/include/io_wrappers.h"
/* #pragma ccuredwrapper("unlink_wrapper",of("unlink")) */
#line 79
/* #pragma ccuredwrapper("open_wrapper",of("open")) */
#line 80
/* #pragma ccuredvararg("open_wrapper",sizeof(int )) */
#line 123
/* #pragma ccuredwrapper("rename_wrapper",of("rename")) */
#line 6 "/users/rupak/ccured/include/malloc_wrappers.h"
/* #pragma ccuredalloc("malloc",nozero,sizein(1)) */
#line 8
/* #pragma ccuredpoly("realloc") */
#line 9
/* #pragma ccuredwrapper("realloc_wrapper",of("realloc")) */
#line 22
/* #pragma ccuredwrapper("free_wrapper",of("free")) */
#line 27
/* #pragma ccuredalloc("alloca",nozero,sizein(1)) */
#line 28
/* #pragma ccuredalloc("calloc",zero,sizemul(1,2)) */
#line 46 "/users/rupak/ccured/include/string_wrappers.h"
/* #pragma ccuredwrapper("strlen_wrapper",of("strlen")) */
#line 52
/* #pragma ccuredwrapper("bzero_wrapper",of("bzero")) */
#line 61
/* #pragma ccuredwrapper("strcpy_wrapper",of("strcpy")) */
#line 81
/* #pragma ccuredwrapper("strncpy_wrapper",of("strncpy")) */
#line 95
/* #pragma ccuredwrapper("strcat_wrapper",of("strcat")) */
#line 111
/* #pragma ccuredwrapper("strncat_wrapper",of("strncat")) */
#line 128
/* #pragma ccuredwrapper("strchr_wrapper",of("strchr")) */
#line 137
/* #pragma ccuredwrapper("strrchr_wrapper",of("strrchr")) */
#line 146
/* #pragma ccuredwrapper("strdup_wrapper",of("strdup")) */
#line 167
/* #pragma ccuredwrapper("strcasecmp_wrapper",of("strcasecmp")) */
#line 173
/* #pragma ccuredwrapper("strcmp_wrapper",of("strcmp")) */
#line 180
/* #pragma ccuredwrapper("strncasecmp_wrapper",of("strncasecmp")) */
#line 194
/* #pragma ccuredwrapper("strncmp_wrapper",of("strncmp")) */
#line 208
/* #pragma ccuredwrapper("strpbrk_wrapper",of("strpbrk")) */
#line 217
/* #pragma ccuredwrapper("strsep_wrapper",of("strsep")) */
#line 234
/* #pragma ccuredwrapper("strtoul_wrapper",of("strtoul")) */
#line 47 "/users/rupak/ccured/include/stdlib_wrappers.h"
/* #pragma ccuredwrapper("atof_wrapper",of("atof")) */
#line 55
/* #pragma ccuredwrapper("atoi_wrapper",of("atoi")) */
#line 63
/* #pragma ccuredwrapper("atol_wrapper",of("atol")) */
#line 93
/* #pragma ccuredpoly("qsort_zero_tags") */
#line 172
/* #pragma ccuredwrapper("qsort_wrapper",of("qsort")) */
#line 216
/* #pragma ccuredwrapper("bsearch_wrapper",of("bsearch")) */
#line 254
/* #pragma ccuredwrapper("strtol_wrapper",of("strtol")) */
#line 270
/* #pragma ccuredwrapper("getenv_wrapper",of("getenv")) */
#line 256 "/users/rupak/ccured/include/string_wrappers.h"
/* #pragma ccuredwrapper("strtok_wrapper",of("strtok")) */
#line 269
/* #pragma ccuredwrapper("strtok_r_wrapper",of("strtok_r")) */
#line 319
/* #pragma ccuredwrapper("memcmp_wrapper",of("memcmp")) */
#line 332
/* #pragma ccuredwrapper("memset_wrapper",of("memset")) */
#line 341
/* #pragma ccuredwrapper("memmove_wrapper",of("memmove")) */
#line 353
/* #pragma ccuredwrapper("memcpy_wrapper",of("memcpy")) */
#line 366
/* #pragma ccuredwrapper("strerror_wrapper",of("strerror")) */
#line 374
/* #pragma ccuredwrapper("strstr_wrapper",of("strstr")) */
#line 383
/* #pragma ccuredwrapper("memchr_wrapper",of("memchr")) */
#line 50 "/users/rupak/ccured/include/pwd_wrappers.h"
/* #pragma ccuredwrapper("getpwnam_wrapper",of("getpwnam")) */
#line 68
/* #pragma ccuredwrapper("getpwuid_wrapper",of("getpwuid")) */
#line 81
/* #pragma ccuredwrapper("getpwent_wrapper",of("getpwent")) */
#line 56 "/users/rupak/ccured/include/signal_wrappers.h"
/* #pragma ccuredpoly("__mkfat_sighandler") */
#line 66
/* #pragma ccuredwrapper("signal_wrapper",of("signal")) */
#line 88
/* #pragma ccuredwrapper("sigaction_wrapper",of("sigaction")) */
#line 168 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredpoly("get_stdin") */
#line 170
/* #pragma ccuredpoly("get_stdout") */
#line 172
/* #pragma ccuredpoly("get_stderr") */
#line 59 "/users/rupak/ccured/include/stdio_wrappers.h"
/* #pragma ccuredpoly("__mkptr_file") */
#line 65
/* #pragma ccuredpoly("__ptrof_file") */
#line 68
/* #pragma ccuredvararg("printf",printf(1)) */
#line 69
/* #pragma ccuredvararg("fprintf",printf(2)) */
#line 70
/* #pragma ccuredvararg("snprintf",printf(3)) */
#line 71
/* #pragma ccuredvararg("syslog",printf(2)) */
#line 72
/* #pragma ccuredvararg("sprintf",printf(2)) */
#line 73
/* #pragma ccuredvararg("vsprintf",printf(2)) */
#line 74
/* #pragma ccuredvararg("vfprintf",printf(2)) */
#line 75
/* #pragma ccuredvararg("vprintf",printf(1)) */
#line 76
/* #pragma ccuredvararg("vsyslog",printf(2)) */
#line 78
/* #pragma ccuredpoly("__endof") */
#line 89
/* #pragma ccuredpoly("ccured_fscanf_string") */
#line 92
/* #pragma ccuredwrapper("ccured_fscanf_string_wrapper",of("ccured_fscanf_string")) */
#line 117
/* #pragma ccuredvararg("sscanf",sizeof(struct scanf_format )) */
#line 118
/* #pragma ccuredvararg("fscanf",sizeof(struct scanf_format )) */
#line 123
/* #pragma ccuredwrapper("fgets_wrapper",of("fgets")) */
#line 132
/* #pragma ccuredwrapper("fopen_wrapper",of("fopen")) */
#line 139
/* #pragma ccuredwrapper("fdopen_wrapper",of("fdopen")) */
#line 146
/* #pragma ccuredwrapper("fflush_wrapper",of("fflush")) */
#line 152
/* #pragma ccuredwrapper("fclose_wrapper",of("fclose")) */
#line 179
/* #pragma ccuredwrapper("_IO_putc_wrapper",of("_IO_putc")) */
#line 185
/* #pragma ccuredwrapper("_IO_getc_wrapper",of("_IO_getc")) */
#line 210
/* #pragma ccuredwrapper("fputc_wrapper",of("fputc")) */
#line 216
/* #pragma ccuredwrapper("fputs_wrapper",of("fputs")) */
#line 222
/* #pragma ccuredwrapper("fgetc_wrapper",of("fgetc")) */
#line 228
/* #pragma ccuredwrapper("puts_wrapper",of("puts")) */
#line 234
/* #pragma ccuredwrapper("fileno_wrapper",of("fileno")) */
#line 240
/* #pragma ccuredwrapper("ferror_wrapper",of("ferror")) */
#line 246
/* #pragma ccuredwrapper("fseek_wrapper",of("fseek")) */
#line 253
/* #pragma ccuredwrapper("clearerr_wrapper",of("clearerr")) */
#line 264
/* #pragma ccuredwrapper("fread_wrapper",of("fread")) */
#line 275
/* #pragma ccuredwrapper("fwrite_wrapper",of("fwrite")) */
#line 288
/* #pragma ccuredwrapper("gets_wrapper",of("gets")) */
#line 314
/* #pragma ccuredvararg("vsnprintf_wrapper",printf(3)) */
#line 315
/* #pragma ccuredwrapper("vsnprintf_wrapper",of("vsnprintf")) */
#line 322
/* #pragma ccuredvararg("vsprintf_wrapper",printf(2)) */
#line 323
/* #pragma ccuredwrapper("vsprintf_wrapper",of("vsprintf")) */
#line 330
/* #pragma ccuredvararg("snprintf_wrapper",printf(3)) */
#line 331
/* #pragma ccuredwrapper("snprintf_wrapper",of("snprintf")) */
#line 343
/* #pragma ccuredvararg("sprintf_wrapper",printf(2)) */
#line 344
/* #pragma ccuredwrapper("sprintf_wrapper",of("sprintf")) */
#line 366
/* #pragma ccuredpoly("ccured_fscanf_double") */
#line 382
/* #pragma ccuredpoly("ccured_fscanf_int") */
#line 398
/* #pragma ccuredpoly("ccured_fscanf_nothing") */
#line 467
/* #pragma ccuredwrapper("perror_wrapper",of("perror")) */
#line 49 "/users/rupak/ccured/include/stat_wrappers.h"
/* #pragma ccuredwrapper("fstat_wrapper",of("fstat")) */
#line 57
/* #pragma ccuredwrapper("stat_wrapper",of("stat")) */
#line 68
/* #pragma ccuredwrapper("__xstat_wrapper",of("__xstat")) */
#line 79 "/users/rupak/ccured/include/time_wrappers.h"
/* #pragma ccuredwrapper("asctime_wrapper",of("asctime")) */
#line 13 "/users/rupak/ccured/include/functions/deepcopy_stringarray.h"
/* #pragma cilnoremove("__deepcopy_stringarray_from_compat") */
#line 14
/* #pragma ccuredpoly("__deepcopy_stringarray_from_compat") */
#line 53
/* #pragma ccuredpoly("__deepcopy_stringarray_to_compat") */
#line 44 "/users/rupak/ccured/include/unistd_wrappers.h"
/* #pragma ccuredwrapper("execv_wrapper",of("execv")) */
#line 66
/* #pragma ccuredwrapper("execvp_wrapper",of("execvp")) */
#line 86
/* #pragma ccuredwrapper("execve_wrapper",of("execve")) */
#line 106
/* #pragma ccuredvararg("execl",sizeof(struct __ccured_execl_arguments )) */
#line 107
/* #pragma ccuredvararg("execlp",sizeof(struct __ccured_execl_arguments )) */
#line 108
/* #pragma ccuredvararg("execle",sizeof(struct __ccured_execl_arguments )) */
#line 110
/* #pragma ccuredwrapper("getlogin_wrapper",of("getlogin")) */
#line 117
/* #pragma ccuredwrapper("ttyname_wrapper",of("ttyname")) */
#line 129
/* #pragma ccuredwrapper("getopt_wrapper",of("getopt")) */
#line 174
/* #pragma ccuredwrapper("read_wrapper",of("read")) */
#line 182
/* #pragma ccuredwrapper("write_wrapper",of("write")) */
#line 195
/* #pragma ccuredwrapper("getusershell_wrapper",of("getusershell")) */
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___1 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___1 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___1 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___1 )) */
#line 303
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___2 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___2 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___2 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___2 )) */
#line 43 "/users/rupak/ccured/include/crypt_wrappers.h"
/* #pragma ccuredwrapper("crypt_wrapper",of("crypt")) */
#line 303 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("__open",sizeof(struct open_arguments___3 )) */
#line 304
/* #pragma ccuredvararg("open",sizeof(struct open_arguments___3 )) */
#line 311
/* #pragma ccuredvararg("__fcntl",sizeof(struct fcntl_arguments___3 )) */
#line 312
/* #pragma ccuredvararg("fcntl",sizeof(struct fcntl_arguments___3 )) */
#line 23 "/users/rupak/ccured/include/grp_wrappers.h"
/* #pragma ccuredwrapper("getgrnam_wrapper",of("getgrnam")) */
#line 45
/* #pragma ccuredwrapper("getgrgid_wrapper",of("getgrgid")) */
#line 59
/* #pragma ccuredwrapper("getgrent_wrapper",of("getgrent")) */
#line 443 "/users/rupak/ccured/include/ccured_GNUCC.patch"
/* #pragma ccuredvararg("ioctl",sizeof(struct ioctl_format )) */
#line 62 "/users/rupak/ccured/include/uio_wrappers.h"
/* #pragma ccuredwrapper("readv_wrapper",of("readv")) */
#line 79
/* #pragma ccuredwrapper("writev_wrapper",of("writev")) */
#line 49 "/users/rupak/ccured/include/socket_wrappers.h"
/* #pragma ccuredwrapper("setsockopt_wrapper",of("setsockopt")) */
#line 57
/* #pragma ccuredwrapper("getsockopt_wrapper",of("getsockopt")) */
#line 66
/* #pragma ccuredwrapper("bind_wrapper",of("bind")) */
#line 75
/* #pragma ccuredwrapper("connect_wrapper",of("connect")) */
#line 84
/* #pragma ccuredwrapper("accept_wrapper",of("accept")) */
#line 110
/* #pragma ccuredwrapper("getpeername_wrapper",of("getpeername")) */
#line 127
/* #pragma ccuredwrapper("getsockname_wrapper",of("getsockname")) */
#line 149
/* #pragma ccuredwrapper("sendto_wrapper",of("sendto")) */
#line 161
/* #pragma ccuredwrapper("select_wrapper",of("select")) */
#line 176
/* #pragma ccuredwrapper("recvfrom_wrapper",of("recvfrom")) */
#line 186
/* #pragma ccuredwrapper("recv_wrapper",of("recv")) */
#line 195
/* #pragma ccuredwrapper("send_wrapper",of("send")) */
#line 252
/* #pragma ccuredwrapper("sendmsg_wrapper",of("sendmsg")) */
#line 264
/* #pragma ccuredwrapper("recvmsg_wrapper",of("recvmsg")) */
#line 38 "socket.h"
fd_set read_set  ;
#line 35 "socket.c"
void remove_connection(struct fcrondyn_cl **client , struct fcrondyn_cl *prev_client ) ;
#line 36
void exe_cmd(struct fcrondyn_cl *client ) ;
#line 37
void auth_client(struct fcrondyn_cl *client ) ;
#line 38
void cmd_ls(struct fcrondyn_cl *client , long *cmd , int fd , int is_root ) ;
#line 39
void print_fields(int fd , unsigned char *details ) ;
#line 40
void print_line(int fd , struct cl_t *line , unsigned char *details , pid_t pid ,
                int index___0 , time_t until ) ;
#line 42
void cmd_on_exeq(struct fcrondyn_cl *client , long *cmd , int fd , int is_root ) ;
#line 43
void cmd_renice(struct fcrondyn_cl *client , long *cmd , int fd , int exe_index ,
                int is_root ) ;
#line 45
void cmd_send_signal(struct fcrondyn_cl *client , long *cmd , int fd , int exe_index ) ;
#line 46
void cmd_run(struct fcrondyn_cl *client , long *cmd , int fd , int is_root ) ;
#line 48 "socket.c"
fcrondyn_cl *fcrondyn_cl_base  ;
#line 49 "socket.c"
int fcrondyn_cl_num  =    0;
#line 51 "socket.c"
fd_set master_set  ;
#line 52 "socket.c"
int set_max_fd  =    0;
#line 53 "socket.c"
int listen_fd  =    -1;
#line 54 "socket.c"
int auth_fail  =    0;
#line 55 "socket.c"
long auth_nofail_since  =    (time_t )0;
#line 58 "socket.c"
char err_no_err_str[33]  = 
#line 58
  {      (char )'C',      (char )'o',      (char )'m',      (char )'m', 
        (char )'a',      (char )'n',      (char )'d',      (char )' ', 
        (char )'s',      (char )'u',      (char )'c',      (char )'c', 
        (char )'e',      (char )'s',      (char )'s',      (char )'f', 
        (char )'u',      (char )'l',      (char )'l',      (char )'y', 
        (char )' ',      (char )'c',      (char )'o',      (char )'m', 
        (char )'p',      (char )'l',      (char )'e',      (char )'t', 
        (char )'e',      (char )'d',      (char )'.',      (char )'\n', 
        (char )'\000'};
#line 59 "socket.c"
char err_unknown_str[57]  = 
#line 59
  {      (char )'F',      (char )'c',      (char )'r',      (char )'o', 
        (char )'n',      (char )' ',      (char )'h',      (char )'a', 
        (char )'s',      (char )' ',      (char )'e',      (char )'n', 
        (char )'c',      (char )'o',      (char )'u',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'e', 
        (char )'d',      (char )' ',      (char )'a',      (char )'n', 
        (char )' ',      (char )'e',      (char )'r',      (char )'r', 
        (char )'o',      (char )'r',      (char )' ',      (char )':', 
        (char )' ',      (char )'c',      (char )'o',      (char )'m', 
        (char )'m',      (char )'a',      (char )'n',      (char )'d', 
        (char )' ',      (char )'n',      (char )'o',      (char )'t', 
        (char )' ',      (char )'c',      (char )'o',      (char )'m', 
        (char )'p',      (char )'l',      (char )'e',      (char )'t', 
        (char )'e',      (char )'d',      (char )'.',      (char )'\n', 
        (char )'\000'};
#line 60 "socket.c"
char err_cmd_unknown_str[18]  = 
#line 60
  {      (char )'U',      (char )'n',      (char )'k',      (char )'n', 
        (char )'o',      (char )'w',      (char )'n',      (char )' ', 
        (char )'c',      (char )'o',      (char )'m',      (char )'m', 
        (char )'a',      (char )'n',      (char )'d',      (char )'.', 
        (char )'\n',      (char )'\000'};
#line 61 "socket.c"
char err_job_nfound_str[29]  = 
#line 61
  {      (char )'N',      (char )'o',      (char )' ',      (char )'c', 
        (char )'o',      (char )'r',      (char )'r',      (char )'e', 
        (char )'s',      (char )'p',      (char )'o',      (char )'n', 
        (char )'d',      (char )'i',      (char )'n',      (char )'g', 
        (char )' ',      (char )'j',      (char )'o',      (char )'b', 
        (char )' ',      (char )'f',      (char )'o',      (char )'u', 
        (char )'n',      (char )'d',      (char )'.',      (char )'\n', 
        (char )'\000'};
#line 62 "socket.c"
char err_rjob_nfound_str[86]  = 
#line 62
  {      (char )'N',      (char )'o',      (char )' ',      (char )'c', 
        (char )'o',      (char )'r',      (char )'r',      (char )'e', 
        (char )'s',      (char )'p',      (char )'o',      (char )'n', 
        (char )'d',      (char )'i',      (char )'n',      (char )'g', 
        (char )' ',      (char )'r',      (char )'u',      (char )'n', 
        (char )'n',      (char )'i',      (char )'n',      (char )'g', 
        (char )' ',      (char )'j',      (char )'o',      (char )'b', 
        (char )' ',      (char )'f',      (char )'o',      (char )'u', 
        (char )'n',      (char )'d',      (char )'.',      (char )'\n', 
        (char )' ',      (char )'(',      (char )'T',      (char )'h', 
        (char )'e',      (char )' ',      (char )'j',      (char )'o', 
        (char )'b',      (char )' ',      (char )'m',      (char )'a', 
        (char )'y',      (char )' ',      (char )'h',      (char )'a', 
        (char )'v',      (char )'e',      (char )' ',      (char )'j', 
        (char )'u',      (char )'s',      (char )'t',      (char )' ', 
        (char )'f',      (char )'i',      (char )'n',      (char )'i', 
        (char )'s',      (char )'h',      (char )'e',      (char )'d', 
        (char )' ',      (char )'i',      (char )'t',      (char )'s', 
        (char )' ',      (char )'e',      (char )'x',      (char )'e', 
        (char )'c',      (char )'u',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )'.',      (char )')', 
        (char )'\n',      (char )'\000'};
#line 64 "socket.c"
char err_invalid_user_str[47]  = 
#line 64
  {      (char )'I',      (char )'n',      (char )'v',      (char )'a', 
        (char )'l',      (char )'i',      (char )'d',      (char )' ', 
        (char )'u',      (char )'s',      (char )'e',      (char )'r', 
        (char )' ',      (char )':',      (char )' ',      (char )'u', 
        (char )'n',      (char )'a',      (char )'b',      (char )'l', 
        (char )'e',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'f',      (char )'i',      (char )'n', 
        (char )'d',      (char )' ',      (char )'a',      (char )' ', 
        (char )'p',      (char )'a',      (char )'s',      (char )'s', 
        (char )'w',      (char )'d',      (char )' ',      (char )'e', 
        (char )'n',      (char )'t',      (char )'r',      (char )'y', 
        (char )'.',      (char )'\n',      (char )'\000'};
#line 65 "socket.c"
char err_invalid_args_str[20]  = 
#line 65
  {      (char )'I',      (char )'n',      (char )'v',      (char )'a', 
        (char )'l',      (char )'i',      (char )'d',      (char )' ', 
        (char )'a',      (char )'r',      (char )'g',      (char )'u', 
        (char )'m',      (char )'e',      (char )'n',      (char )'t', 
        (char )'s',      (char )'.',      (char )'\n',      (char )'\000'};
#line 66 "socket.c"
char err_job_nallowed_str[46]  = 
#line 66
  {      (char )'Y',      (char )'o',      (char )'u',      (char )' ', 
        (char )'a',      (char )'r',      (char )'e',      (char )' ', 
        (char )'n',      (char )'o',      (char )'t',      (char )' ', 
        (char )'a',      (char )'l',      (char )'l',      (char )'o', 
        (char )'w',      (char )'e',      (char )'d',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'s', 
        (char )'e',      (char )'e',      (char )'/',      (char )'c', 
        (char )'h',      (char )'a',      (char )'n',      (char )'g', 
        (char )'e',      (char )' ',      (char )'t',      (char )'h', 
        (char )'i',      (char )'s',      (char )' ',      (char )'l', 
        (char )'i',      (char )'n',      (char )'e',      (char )'.', 
        (char )'\n',      (char )'\000'};
#line 67 "socket.c"
char err_all_nallowed_str[39]  = 
#line 67
  {      (char )'Y',      (char )'o',      (char )'u',      (char )' ', 
        (char )'a',      (char )'r',      (char )'e',      (char )' ', 
        (char )'n',      (char )'o',      (char )'t',      (char )' ', 
        (char )'a',      (char )'l',      (char )'l',      (char )'o', 
        (char )'w',      (char )'e',      (char )'d',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'l', 
        (char )'i',      (char )'s',      (char )'t',      (char )' ', 
        (char )'a',      (char )'l',      (char )'l',      (char )' ', 
        (char )'j',      (char )'o',      (char )'b',      (char )'s', 
        (char )'.',      (char )'\n',      (char )'\000'};
#line 68 "socket.c"
char err_others_nallowed_str[48]  = 
#line 68
  {      (char )'Y',      (char )'o',      (char )'u',      (char )' ', 
        (char )'a',      (char )'r',      (char )'e',      (char )' ', 
        (char )'n',      (char )'o',      (char )'t',      (char )' ', 
        (char )'a',      (char )'l',      (char )'l',      (char )'o', 
        (char )'w',      (char )'e',      (char )'d',      (char )' ', 
        (char )'t',      (char )'o',      (char )' ',      (char )'l', 
        (char )'i',      (char )'s',      (char )'t',      (char )' ', 
        (char )'o',      (char )'t',      (char )'h',      (char )'e', 
        (char )'r',      (char )' ',      (char )'u',      (char )'s', 
        (char )'e',      (char )'r',      (char )'s',      (char )'\'', 
        (char )' ',      (char )'j',      (char )'o',      (char )'b', 
        (char )'s',      (char )'.',      (char )'\n',      (char )'\000'};
#line 97 "socket.c"
void init_socket(void) 
{ struct sockaddr_un addr ;
  int len ;
  unsigned int __i ;
  fd_set *__arr ;
  unsigned int __i___0 ;
  fd_set *__arr___0 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 102
  len = 0;
#line 105
  while (1) {
#line 105
    __arr = & read_set;
#line 105
    __i = 0U;
#line 105
    while (__i < sizeof(fd_set ) / sizeof(__fd_mask )) {
#line 105
      __arr->__fds_bits[__i] = 0L;
#line 105
      __i ++;
    }
#line 105
    break;
  }
#line 106
  while (1) {
#line 106
    __arr___0 = & master_set;
#line 106
    __i___0 = 0U;
#line 106
    while (__i___0 < sizeof(fd_set ) / sizeof(__fd_mask )) {
#line 106
      __arr___0->__fds_bits[__i___0] = 0L;
#line 106
      __i___0 ++;
    }
#line 106
    break;
  }
#line 108
  listen_fd = socket(1, 1, 0);
#line 108
  if (listen_fd == -1) {
#line 109
    error_e((char *)"Could not create socket : fcrondyn won\'t work");
#line 110
    return;
  }
#line 113
  addr.sun_family = 1;
#line 114
  len = (int )strlen((char const   *)fifofile);
#line 114
  if ((unsigned int )len > sizeof(addr.sun_path)) {
#line 115
    error((char *)"Error : fifo file path too long (max is %d)", sizeof(addr.sun_path));
    goto err;
  }
#line 118
  strncpy((char */* __restrict  */)(addr.sun_path), (char const   */* __restrict  */)fifofile,
          sizeof(addr.sun_path) - 1U);
#line 119
  addr.sun_path[sizeof(addr.sun_path) - 1U] = (char )'\000';
#line 121
  unlink((char const   *)fifofile);
#line 122
  tmp = bind(listen_fd, (void const   *)((struct sockaddr *)(& addr)), sizeof(addr.sun_family) +
                                                                       (unsigned int )len);
#line 122
  if (tmp != 0) {
#line 123
    error_e((char *)"Cannot bind socket to \'%s\'", fifofile);
    goto err;
  }
#line 127
  tmp___0 = listen(listen_fd, 25);
#line 127
  if (tmp___0 != 0) {
#line 128
    error_e((char *)"Cannot set socket in listen mode");
    goto err;
  }
#line 133
  tmp___1 = chmod((char const   *)fifofile, 438U);
#line 133
  if (tmp___1 != 0) {
#line 134
    error_e((char *)"Cannot chmod() socket file");
  }
#line 137
  fcntl(listen_fd, 2, 1);
#line 139
  tmp___2 = fcntl(listen_fd, 3);
#line 139
  tmp___3 = fcntl(listen_fd, 4, tmp___2 | 2048);
#line 139
  if (tmp___3 == -1) {
#line 140
    error_e((char *)"Could not set listen_fd attribute O_NONBLOCK : no fcrondyn support");
    goto err;
  }
#line 145
  master_set.__fds_bits[(unsigned int )listen_fd / (8U * sizeof(__fd_mask ))] = master_set.__fds_bits[(unsigned int )listen_fd /
                                                                                                      (8U *
                                                                                                       sizeof(__fd_mask ))] |
                                                                                (1L <<
                                                                                 (unsigned int )listen_fd %
                                                                                 (8U *
                                                                                  sizeof(__fd_mask )));
#line 146
  if (listen_fd > set_max_fd) {
#line 147
    set_max_fd = listen_fd;
  }
#line 150
  read_set = master_set;
#line 151
  if (debug_opt) {
#line 151
    Debug((char *)"Socket initialized : listen_fd : %d set_max_fd : %d ", listen_fd,
          set_max_fd);
  }
#line 152
  return;
  err: 
#line 155
  close_socket();
#line 157
  return;
}
}
#line 159 "socket.c"
void auth_client(struct fcrondyn_cl *client ) 
{ char *pass_cry ;
  char *pass_sys ;
  char *pass_str ;
  struct spwd *pass_sp ;
  size_t tmp ;
  register char *__xx__ ;
  char *tmp___0 ;
  int tmp___1 ;
  register char *__xx_____0 ;
  char *tmp___2 ;

  {
#line 163
  pass_cry = (char *)((void *)0);
#line 164
  pass_sys = (char *)((void *)0);
#line 165
  pass_str = (char *)((void *)0);
#line 168
  pass_sp = (struct spwd *)((void *)0);
#line 169
  pass_sp = getspnam((char const   */* __attribute__((__split__)) */)((char *)client->fcl_cmd));
#line 169
  if ((unsigned int )pass_sp == (unsigned int )((void *)0)) {
#line 170
    error_e((char *)"could not getspnam %s", (char *)client->fcl_cmd);
#line 171
    send(client->fcl_sock_fd, (void const   *)"0", sizeof("0"), 0);
#line 172
    return;
  }
#line 174
  pass_sys = (char *)pass_sp->sp_pwdp;
#line 186
  if (debug_opt) {
#line 186
    Debug((char *)"auth_client() : socket : %d", client->fcl_sock_fd);
  }
#line 191
  if (auth_fail > 0) {
#line 191
    if (auth_nofail_since + 60L <= now) {
#line 193
      auth_fail = 0;
    }
  }
#line 194
  if (auth_fail >= 10) {
#line 195
    error((char *)"Too many authentication failures : try to connect later.");
#line 196
    send(client->fcl_sock_fd, (void const   *)"0", sizeof("0"), 0);
#line 197
    auth_nofail_since = 0L;
#line 197
    auth_fail = (int )auth_nofail_since;
#line 198
    return;
  }
#line 202
  tmp = strlen((char const   *)((char *)client->fcl_cmd));
#line 202
  pass_str = (char *)client->fcl_cmd + (tmp + 1U);
#line 203
  pass_cry = crypt((char const   *)pass_str, (char const   *)pass_sys);
#line 203
  if ((unsigned int )pass_cry == (unsigned int )((void *)0)) {
#line 204
    error_e((char *)"could not crypt()");
#line 205
    send(client->fcl_sock_fd, (void const   *)"0", sizeof("0"), 0);
#line 206
    while (1) {
#line 206
      __xx__ = pass_str;
#line 206
      if (__xx__) {
#line 206
        while ((*__xx__)) {
#line 206
          tmp___0 = __xx__;
#line 206
          __xx__ ++;
#line 206
          (*tmp___0) = (char )'\000';
        }
      }
#line 206
      break;
    }
#line 207
    return;
  }
#line 212
  tmp___1 = strcmp((char const   *)pass_cry, (char const   *)pass_sys);
#line 212
  if (tmp___1 == 0) {
#line 213
    client->fcl_user = strdup2((char const   *)((char *)client->fcl_cmd));
#line 214
    send(client->fcl_sock_fd, (void const   *)"1", sizeof("1"), 0);
  } else {
#line 217
    auth_fail ++;
#line 218
    auth_nofail_since = now;
#line 219
    error((char *)"Invalid passwd for %s from socket %d", (char *)client->fcl_cmd,
          client->fcl_sock_fd);
#line 221
    send(client->fcl_sock_fd, (void const   *)"0", sizeof("0"), 0);
  }
#line 224
  while (1) {
#line 224
    __xx_____0 = pass_str;
#line 224
    if (__xx_____0) {
#line 224
      while ((*__xx_____0)) {
#line 224
        tmp___2 = __xx_____0;
#line 224
        __xx_____0 ++;
#line 224
        (*tmp___2) = (char )'\000';
      }
    }
#line 224
    break;
  }
#line 225
  return;
}
}
#line 237 "socket.c"
void print_fields(int fd , unsigned char *details ) 
{ char fields[196] ;
  char field_user[8] ;
  char field_id[6] ;
  char field_rq[6] ;
  char field_options[11] ;
  char field_schedule[18] ;
  char field_until[32] ;
  char field_pid[9] ;
  char field_index[7] ;
  char field_cmd[5] ;
  char field_endline[2] ;
  int len ;
  unsigned int tmp ;
  ssize_t tmp___0 ;

  {
#line 242
  field_user[0] = (char )' ';
#line 242
  field_user[1] = (char )'U';
#line 242
  field_user[2] = (char )'S';
#line 242
  field_user[3] = (char )'E';
#line 242
  field_user[4] = (char )'R';
#line 242
  field_user[5] = (char )' ';
#line 242
  field_user[6] = (char )' ';
#line 242
  field_user[7] = (char )'\000';
#line 243
  field_id[0] = (char )'I';
#line 243
  field_id[1] = (char )'D';
#line 243
  field_id[2] = (char )' ';
#line 243
  field_id[3] = (char )' ';
#line 243
  field_id[4] = (char )' ';
#line 243
  field_id[5] = (char )'\000';
#line 244
  field_rq[0] = (char )' ';
#line 244
  field_rq[1] = (char )'R';
#line 244
  field_rq[2] = (char )'&';
#line 244
  field_rq[3] = (char )'Q';
#line 244
  field_rq[4] = (char )' ';
#line 244
  field_rq[5] = (char )'\000';
#line 245
  field_options[0] = (char )' ';
#line 245
  field_options[1] = (char )'O';
#line 245
  field_options[2] = (char )'P';
#line 245
  field_options[3] = (char )'T';
#line 245
  field_options[4] = (char )'I';
#line 245
  field_options[5] = (char )'O';
#line 245
  field_options[6] = (char )'N';
#line 245
  field_options[7] = (char )'S';
#line 245
  field_options[8] = (char )' ';
#line 245
  field_options[9] = (char )' ';
#line 245
  field_options[10] = (char )'\000';
#line 246
  field_schedule[0] = (char )' ';
#line 246
  field_schedule[1] = (char )'S';
#line 246
  field_schedule[2] = (char )'C';
#line 246
  field_schedule[3] = (char )'H';
#line 246
  field_schedule[4] = (char )'E';
#line 246
  field_schedule[5] = (char )'D';
#line 246
  field_schedule[6] = (char )'U';
#line 246
  field_schedule[7] = (char )'L';
#line 246
  field_schedule[8] = (char )'E';
#line 246
  field_schedule[9] = (char )' ';
#line 246
  field_schedule[10] = (char )' ';
#line 246
  field_schedule[11] = (char )' ';
#line 246
  field_schedule[12] = (char )' ';
#line 246
  field_schedule[13] = (char )' ';
#line 246
  field_schedule[14] = (char )' ';
#line 246
  field_schedule[15] = (char )' ';
#line 246
  field_schedule[16] = (char )' ';
#line 246
  field_schedule[17] = (char )'\000';
#line 247
  field_until[0] = (char )' ';
#line 247
  field_until[1] = (char )'L';
#line 247
  field_until[2] = (char )'A';
#line 247
  field_until[3] = (char )'V';
#line 247
  field_until[4] = (char )'G';
#line 247
  field_until[5] = (char )' ';
#line 247
  field_until[6] = (char )'1';
#line 247
  field_until[7] = (char )',';
#line 247
  field_until[8] = (char )'5';
#line 247
  field_until[9] = (char )',';
#line 247
  field_until[10] = (char )'1';
#line 247
  field_until[11] = (char )'5';
#line 247
  field_until[12] = (char )' ';
#line 247
  field_until[13] = (char )'U';
#line 247
  field_until[14] = (char )'N';
#line 247
  field_until[15] = (char )'T';
#line 247
  field_until[16] = (char )'I';
#line 247
  field_until[17] = (char )'L';
#line 247
  field_until[18] = (char )' ';
#line 247
  field_until[19] = (char )' ';
#line 247
  field_until[20] = (char )' ';
#line 247
  field_until[21] = (char )' ';
#line 247
  field_until[22] = (char )' ';
#line 247
  field_until[23] = (char )' ';
#line 247
  field_until[24] = (char )' ';
#line 247
  field_until[25] = (char )'S';
#line 247
  field_until[26] = (char )'T';
#line 247
  field_until[27] = (char )'R';
#line 247
  field_until[28] = (char )'I';
#line 247
  field_until[29] = (char )'C';
#line 247
  field_until[30] = (char )'T';
#line 247
  field_until[31] = (char )'\000';
#line 248
  field_pid[0] = (char )' ';
#line 248
  field_pid[1] = (char )'P';
#line 248
  field_pid[2] = (char )'I';
#line 248
  field_pid[3] = (char )'D';
#line 248
  field_pid[4] = (char )' ';
#line 248
  field_pid[5] = (char )' ';
#line 248
  field_pid[6] = (char )' ';
#line 248
  field_pid[7] = (char )' ';
#line 248
  field_pid[8] = (char )'\000';
#line 249
  field_index[0] = (char )' ';
#line 249
  field_index[1] = (char )'I';
#line 249
  field_index[2] = (char )'N';
#line 249
  field_index[3] = (char )'D';
#line 249
  field_index[4] = (char )'E';
#line 249
  field_index[5] = (char )'X';
#line 249
  field_index[6] = (char )'\000';
#line 250
  field_cmd[0] = (char )' ';
#line 250
  field_cmd[1] = (char )'C';
#line 250
  field_cmd[2] = (char )'M';
#line 250
  field_cmd[3] = (char )'D';
#line 250
  field_cmd[4] = (char )'\000';
#line 251
  field_endline[0] = (char )'\n';
#line 251
  field_endline[1] = (char )'\000';
#line 252
  len = 0;
#line 254
  fields[0] = (char )'\000';
#line 256
  strncat((char */* __restrict  */)(fields), (char const   */* __restrict  */)(field_id),
          sizeof(fields) - (unsigned int )len);
#line 256
  len = (int )((unsigned int )len + (sizeof(field_id) - 1U));
#line 257
  if ((int )(*(details + 0)) & 1) {
#line 257
    strncat((char */* __restrict  */)(fields), (char const   */* __restrict  */)(field_user),
            (sizeof(fields) - 1U) - (unsigned int )len);
#line 257
    len = (int )((unsigned int )len + (sizeof(field_user) - 1U));
  }
#line 258
  if ((int )(*(details + 0)) & 4) {
#line 258
    strncat((char */* __restrict  */)(fields), (char const   */* __restrict  */)(field_pid),
            (sizeof(fields) - 1U) - (unsigned int )len);
#line 258
    len = (int )((unsigned int )len + (sizeof(field_pid) - 1U));
  }
#line 259
  if ((int )(*(details + 0)) & 32) {
#line 259
    strncat((char */* __restrict  */)(fields), (char const   */* __restrict  */)(field_index),
            (sizeof(fields) - 1U) - (unsigned int )len);
#line 259
    len = (int )((unsigned int )len + (sizeof(field_index) - 1U));
  }
#line 260
  if ((int )(*(details + 0)) & 2) {
#line 260
    strncat((char */* __restrict  */)(fields), (char const   */* __restrict  */)(field_rq),
            (sizeof(fields) - 1U) - (unsigned int )len);
#line 260
    len = (int )((unsigned int )len + (sizeof(field_rq) - 1U));
  }
#line 261
  if ((int )(*(details + 0)) & 64) {
#line 261
    strncat((char */* __restrict  */)(fields), (char const   */* __restrict  */)(field_options),
            (sizeof(fields) - 1U) - (unsigned int )len);
#line 261
    len = (int )((unsigned int )len + (sizeof(field_options) - 1U));
  }
#line 262
  if ((int )(*(details + 0)) & 16) {
#line 262
    strncat((char */* __restrict  */)(fields), (char const   */* __restrict  */)(field_until),
            (sizeof(fields) - 1U) - (unsigned int )len);
#line 262
    len = (int )((unsigned int )len + (sizeof(field_until) - 1U));
  }
#line 263
  if ((int )(*(details + 0)) & 8) {
#line 263
    strncat((char */* __restrict  */)(fields), (char const   */* __restrict  */)(field_schedule),
            (sizeof(fields) - 1U) - (unsigned int )len);
#line 263
    len = (int )((unsigned int )len + (sizeof(field_schedule) - 1U));
  }
#line 264
  strncat((char */* __restrict  */)(fields), (char const   */* __restrict  */)(field_cmd),
          sizeof(fields) - (unsigned int )len);
#line 264
  len = (int )((unsigned int )len + (sizeof(field_cmd) - 1U));
#line 265
  strncat((char */* __restrict  */)(fields), (char const   */* __restrict  */)(field_endline),
          sizeof(fields) - (unsigned int )len);
#line 265
  len = (int )((unsigned int )len + (sizeof(field_endline) - 1U));
#line 267
  fields[195] = (char )'\000';
#line 269
  if ((unsigned int )len < sizeof(fields)) {
#line 269
    tmp = (unsigned int )len;
  } else {
#line 269
    tmp = sizeof(fields);
  }
#line 269
  tmp___0 = send(fd, (void const   *)(fields), tmp, 0);
#line 269
  if (tmp___0 < 0) {
#line 270
    error_e((char *)"error in send()");
  }
#line 272
  return;
}
}
#line 275 "socket.c"
void print_line(int fd , struct cl_t *line , unsigned char *details , pid_t pid ,
                int index___0 , time_t until ) 
{ char buf[196] ;
  int len ;
  struct tm *ftime ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char opt___0[9] ;
  int i ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char const   *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  unsigned int tmp___15 ;
  ssize_t tmp___16 ;

  {
#line 281
  len = 0;
#line 285
  len = snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%-5ld",
                 line->cl_id);
#line 286
  if ((int )(*(details + 0)) & 1) {
#line 287
    tmp = snprintf((char */* __restrict  */)(buf + len), sizeof(buf) - (unsigned int )len,
                   (char const   */* __restrict  */)" %-6s", (line->cl_file)->cf_user);
#line 287
    len += tmp;
  }
#line 288
  if ((int )(*(details + 0)) & 4) {
#line 289
    tmp___0 = snprintf((char */* __restrict  */)(buf + len), sizeof(buf) - (unsigned int )len,
                       (char const   */* __restrict  */)" %-7d", pid);
#line 289
    len += tmp___0;
  }
#line 290
  if ((int )(*(details + 0)) & 32) {
#line 291
    tmp___1 = snprintf((char */* __restrict  */)(buf + len), sizeof(buf) - (unsigned int )len,
                       (char const   */* __restrict  */)" %-5d", index___0);
#line 291
    len += tmp___1;
  }
#line 292
  if ((int )(*(details + 0)) & 2) {
#line 293
    tmp___2 = snprintf((char */* __restrict  */)(buf + len), sizeof(buf) - (unsigned int )len,
                       (char const   */* __restrict  */)" %-4d", line->cl_numexe);
#line 293
    len += tmp___2;
  }
#line 294
  if ((int )(*(details + 0)) & 64) {
#line 296
    i = 0;
#line 297
    opt___0[0] = (char )'\000';
#line 298
    if ((int )line->cl_option[0] & 2) {
#line 299
      if ((int )line->cl_option[1] & 16) {
#line 299
        tmp___3 = 0;
      } else {
#line 299
        tmp___3 = 1;
      }
#line 299
      tmp___4 = snprintf((char */* __restrict  */)(opt___0 + i), sizeof(opt___0) -
                                                                 (unsigned int )i,
                         (char const   */* __restrict  */)"L%.*s", tmp___3, "O");
#line 299
      i += tmp___4;
    }
#line 301
    if ((int )line->cl_option[0] & 32) {
#line 302
      if (! ((int )line->cl_option[1] & 8)) {
#line 302
        tmp___5 = 0;
      } else {
#line 302
        tmp___5 = 1;
      }
#line 302
      tmp___6 = snprintf((char */* __restrict  */)(opt___0 + i), sizeof(opt___0) -
                                                                 (unsigned int )i,
                         (char const   */* __restrict  */)"%.*sS%.*s", i, ",", tmp___5,
                         "O");
#line 302
      i += tmp___6;
    }
#line 304
    if ((int )line->cl_option[1] & 4) {
#line 305
      tmp___7 = snprintf((char */* __restrict  */)(opt___0 + i), sizeof(opt___0) -
                                                                 (unsigned int )i,
                         (char const   */* __restrict  */)"%.*sES", i, ",");
#line 305
      i += tmp___7;
    }
#line 307
    tmp___8 = snprintf((char */* __restrict  */)(buf + len), sizeof(buf) - (unsigned int )len,
                       (char const   */* __restrict  */)" %-9s", opt___0);
#line 307
    len += tmp___8;
  }
#line 309
  if ((int )(*(details + 0)) & 16) {
#line 310
    tmp___9 = snprintf((char */* __restrict  */)(buf + len), sizeof(buf) - (unsigned int )len,
                       (char const   */* __restrict  */)" %.1f,%.1f,%.1f", (double )line->cl_lavg[0] /
                                                                           (double )10,
                       (double )line->cl_lavg[1] / (double )10, (double )line->cl_lavg[2] /
                                                                (double )10);
#line 310
    len += tmp___9;
#line 314
    if (until > 0L) {
#line 315
      ftime = localtime((time_t const   *)(& until));
#line 316
      if (! ((int )line->cl_option[2] & 16)) {
#line 316
        tmp___10 = "Y";
      } else {
#line 316
        tmp___10 = "N";
      }
#line 316
      tmp___11 = snprintf((char */* __restrict  */)(buf + len), sizeof(buf) - (unsigned int )len,
                          (char const   */* __restrict  */)" %02d/%02d/%d %02d:%02d %s",
                          ftime->tm_mon + 1, ftime->tm_mday, ftime->tm_year + 1900,
                          ftime->tm_hour, ftime->tm_min, tmp___10);
#line 316
      len += tmp___11;
    } else {
#line 322
      tmp___12 = snprintf((char */* __restrict  */)(buf + len), sizeof(buf) - (unsigned int )len,
                          (char const   */* __restrict  */)" %18s", " (no until set) ");
#line 322
      len += tmp___12;
    }
  }
#line 324
  if ((int )(*(details + 0)) & 8) {
#line 325
    ftime = localtime((time_t const   *)(& line->cl_nextexe));
#line 326
    tmp___13 = snprintf((char */* __restrict  */)(buf + len), sizeof(buf) - (unsigned int )len,
                        (char const   */* __restrict  */)" %02d/%02d/%d %02d:%02d",
                        ftime->tm_mon + 1, ftime->tm_mday, ftime->tm_year + 1900,
                        ftime->tm_hour, ftime->tm_min);
#line 326
    len += tmp___13;
  }
#line 330
  tmp___14 = snprintf((char */* __restrict  */)(buf + len), sizeof(buf) - (unsigned int )len,
                      (char const   */* __restrict  */)" %s\n", line->cl_shell);
#line 330
  len += tmp___14;
#line 332
  if ((unsigned int )len < sizeof(buf)) {
#line 332
    tmp___15 = (unsigned int )len;
  } else {
#line 332
    tmp___15 = sizeof(buf);
  }
#line 332
  tmp___16 = send(fd, (void const   *)(buf), tmp___15, 0);
#line 332
  if (tmp___16 < 0) {
#line 333
    error_e((char *)"error in send()");
  }
#line 335
  return;
}
}
#line 345 "socket.c"
void cmd_ls(struct fcrondyn_cl *client , long *cmd , int fd , int is_root ) 
{ int found ;
  int all ;
  int tmp ;
  char *user ;
  struct job_t *j ;
  int i ;
  unsigned char fields[1] ;
  int tmp___0 ;
  double lavg[3] ;
  char lavg_str[196] ;
  struct passwd *pass ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int j___0 ;
  int tmp___5 ;

  {
#line 349
  found = 0;
#line 350
  if ((*(cmd + 1)) == -1L) {
#line 350
    tmp = 1;
  } else {
#line 350
    tmp = 0;
  }
#line 350
  all = tmp;
#line 351
  user = (char *)((void *)0);
#line 356
  i = 0;
#line 356
  while (i < 1) {
#line 357
    fields[i] = 0;
#line 356
    i ++;
  }
#line 359
  switch ((int )(*(cmd + 0))) {
  case 105: 
#line 361
  fields[0] = (unsigned char )((int )fields[0] | 8);
#line 362
  fields[0] = (unsigned char )((int )fields[0] | 2);
#line 363
  fields[0] = (unsigned char )((int )fields[0] | 1);
#line 364
  fields[0] = (unsigned char )((int )fields[0] | 64);
#line 365
  print_fields(fd, fields);
#line 366
  j = queue_base;
#line 366
  while ((unsigned int )j != (unsigned int )((void *)0)) {
#line 367
    if ((*(cmd + 1)) == (j->j_line)->cl_id) {
#line 368
      tmp___0 = strcmp((char const   *)client->fcl_user, (char const   *)((j->j_line)->cl_file)->cf_user);
#line 368
      if (tmp___0 == 0) {
#line 370
        print_line(fd, j->j_line, fields, 0, 0, 0L);
      } else {
#line 368
        if (is_root) {
#line 370
          print_line(fd, j->j_line, fields, 0, 0, 0L);
        } else {
#line 372
          send(fd, (void const   *)(err_job_nfound_str), sizeof(err_job_nfound_str),
               0);
        }
      }
#line 373
      found = 1;
#line 374
      break;
    }
#line 366
    j = j->j_next;
  }
#line 377
  break;
  case 101: ;
  case 102: ;
  case 103: ;
  case 104: ;
#line 383
  if ((*(cmd + 0)) == 102L) {
#line 384
    lavg[0] = (double )0;
#line 384
    lavg[1] = (double )0;
#line 384
    lavg[2] = (double )0;
#line 386
    getloadavg(lavg, 3);
#line 387
    i = snprintf((char */* __restrict  */)(lavg_str), sizeof(lavg_str), (char const   */* __restrict  */)"Current load average : %.1f, %.1f, %.1f\n",
                 lavg[0], lavg[1], lavg[2]);
#line 389
    send(fd, (void const   *)(lavg_str), (unsigned int )i, 0);
#line 391
    fields[0] = (unsigned char )((int )fields[0] | 16);
  } else {
#line 394
    fields[0] = (unsigned char )((int )fields[0] | 8);
  }
#line 396
  if ((*(cmd + 0)) == 103L) {
#line 397
    fields[0] = (unsigned char )((int )fields[0] | 32);
  }
#line 399
  if ((*(cmd + 0)) == 104L) {
#line 400
    fields[0] = (unsigned char )((int )fields[0] | 4);
  }
#line 402
  if (all) {
#line 402
    if (! is_root) {
#line 403
      warn((char *)"User %s tried to list *all* jobs.", client->fcl_user);
#line 404
      send(fd, (void const   *)(err_all_nallowed_str), sizeof(err_all_nallowed_str),
           0);
#line 404
      send(fd, (void const   *)"\000\000", sizeof("\000\000"), 0);
#line 405
      return;
    }
  }
#line 407
  if (all) {
#line 408
    fields[0] = (unsigned char )((int )fields[0] | 1);
  }
#line 409
  print_fields(fd, fields);
#line 411
  if (! all) {
#line 415
    if ((*(cmd + 1)) == -100L) {
#line 416
      user = (char *)"systab";
    } else {
#line 419
      pass = getpwuid((unsigned int )(*(cmd + 1)));
#line 419
      if ((unsigned int )pass == (unsigned int )((void *)0)) {
#line 420
        warn_e((char *)"Unable to find passwd entry for %ld", (*(cmd + 1)));
#line 421
        send(fd, (void const   *)(err_invalid_user_str), sizeof(err_invalid_user_str),
             0);
#line 421
        send(fd, (void const   *)"\000\000", sizeof("\000\000"), 0);
#line 422
        return;
      }
#line 424
      if (! is_root) {
#line 424
        tmp___1 = strcmp((char const   *)pass->pw_name, (char const   *)client->fcl_user);
#line 424
        if (tmp___1 != 0) {
#line 425
          warn_e((char *)"%s is not allowed to see %s\'s jobs. %ld", client->fcl_user,
                 pass->pw_name);
#line 427
          send(fd, (void const   *)(err_others_nallowed_str), sizeof(err_others_nallowed_str),
               0);
#line 427
          send(fd, (void const   *)"\000\000", sizeof("\000\000"), 0);
#line 428
          return;
        }
      }
#line 430
      user = pass->pw_name;
    }
  }
#line 437
  switch ((int )(*(cmd + 0))) {
  case 101: 
#line 439
  j = queue_base;
#line 439
  while ((unsigned int )j != (unsigned int )((void *)0)) {
#line 440
    if (all) {
#line 440
      print_line(fd, j->j_line, fields, 0, 0, 0L);
#line 440
      found = 1;
    } else {
#line 440
      tmp___2 = strcmp((char const   *)user, (char const   *)((j->j_line)->cl_file)->cf_user);
#line 440
      if (tmp___2 == 0) {
#line 440
        print_line(fd, j->j_line, fields, 0, 0, 0L);
#line 440
        found = 1;
      }
    }
#line 439
    j = j->j_next;
  }
#line 441
  break;
  case 104: 
#line 444
  i = 0;
#line 444
  while (i < (int )exe_num) {
#line 445
    if ((unsigned int )(exe_array + i)->e_line == (unsigned int )((void *)0)) {
#line 446
      if (is_root) {
#line 447
        send_msg_fd(fd, (char *)"job no more in an fcrontab: pid %d", (exe_array +
                                                                       i)->e_job_pid);
#line 449
        found = 1;
      }
    } else {
#line 453
      if (all) {
#line 453
        print_line(fd, (exe_array + i)->e_line, fields, (exe_array + i)->e_job_pid,
                   0, 0L);
#line 453
        found = 1;
      } else {
#line 453
        tmp___3 = strcmp((char const   *)user, (char const   *)(((exe_array + i)->e_line)->cl_file)->cf_user);
#line 453
        if (tmp___3 == 0) {
#line 453
          print_line(fd, (exe_array + i)->e_line, fields, (exe_array + i)->e_job_pid,
                     0, 0L);
#line 453
          found = 1;
        }
      }
    }
#line 444
    i ++;
  }
#line 456
  break;
  case 102: 
#line 459
  i = 0;
#line 459
  while (i < (int )lavg_num) {
#line 460
    if (all) {
#line 460
      print_line(fd, (lavg_array + i)->l_line, fields, 0, 0, (lavg_array + i)->l_until);
#line 460
      found = 1;
    } else {
#line 460
      tmp___4 = strcmp((char const   *)user, (char const   *)(((lavg_array + i)->l_line)->cl_file)->cf_user);
#line 460
      if (tmp___4 == 0) {
#line 460
        print_line(fd, (lavg_array + i)->l_line, fields, 0, 0, (lavg_array + i)->l_until);
#line 460
        found = 1;
      }
    }
#line 459
    i ++;
  }
#line 461
  break;
  case 103: 
#line 466
  i = (int )serial_array_index;
#line 467
  j___0 = 0;
#line 467
  while (j___0 < (int )serial_num) {
#line 468
    if (all) {
#line 468
      print_line(fd, (*(serial_array + i)), fields, 0, j___0, 0L);
#line 468
      found = 1;
    } else {
#line 468
      tmp___5 = strcmp((char const   *)user, (char const   *)(((*(serial_array + i)))->cl_file)->cf_user);
#line 468
      if (tmp___5 == 0) {
#line 468
        print_line(fd, (*(serial_array + i)), fields, 0, j___0, 0L);
#line 468
        found = 1;
      }
    }
#line 469
    i ++;
#line 469
    if (i >= (int )serial_array_size) {
#line 470
      i -= (int )serial_array_size;
    }
#line 467
    j___0 ++;
  }
#line 472
  break;
  }
#line 477
  break;
  }
#line 480
  if (! found) {
#line 481
    send(fd, (void const   *)(err_job_nfound_str), sizeof(err_job_nfound_str), 0);
  }
#line 483
  send(fd, (void const   *)"\000\000", sizeof("\000\000"), 0);
#line 485
  return;
}
}
#line 488 "socket.c"
void cmd_on_exeq(struct fcrondyn_cl *client , long *cmd , int fd , int is_root ) 
{ int exe_index ;
  int found ;
  char *err_str ;
  int tmp ;

  {
#line 493
  found = 0;
#line 494
  err_str = (char *)((void *)0);
#line 497
  exe_index = 0;
#line 497
  while (exe_index < (int )exe_num) {
#line 498
    if ((unsigned int )(exe_array + exe_index)->e_line != (unsigned int )((void *)0)) {
#line 498
      if ((*(cmd + 2)) == ((exe_array + exe_index)->e_line)->cl_id) {
#line 501
        found = 1;
#line 504
        if (! is_root) {
#line 504
          tmp = strcmp((char const   *)client->fcl_user, (char const   *)(((exe_array +
                                                                            exe_index)->e_line)->cl_file)->cf_user);
#line 504
          if (tmp != 0) {
#line 508
            if ((*(cmd + 0)) == 402L) {
#line 509
              err_str = (char *)"%s tried to renice to %ld job id %ld for %s : not allowed.";
            } else {
#line 511
              if ((*(cmd + 0)) == 401L) {
#line 512
                err_str = (char *)"%s tried to send signal %ld to id %ld for %s : not allowed.";
              } else {
#line 515
                err_str = (char *)"cannot run unknown cmd with arg %ld on job id %ld for %s : not allowed.";
              }
            }
#line 518
            warn(err_str, client->fcl_user, (*(cmd + 1)), (*(cmd + 2)), client->fcl_user);
#line 520
            send(fd, (void const   *)(err_job_nfound_str), sizeof(err_job_nfound_str),
                 0);
#line 520
            send(fd, (void const   *)"\000\000", sizeof("\000\000"), 0);
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 525
          if ((*(cmd + 0)) == 401L) {
#line 526
            cmd_send_signal(client, cmd, fd, exe_index);
          } else {
#line 527
            if ((*(cmd + 0)) == 402L) {
#line 528
              cmd_renice(client, cmd, fd, exe_index, is_root);
            } else {
#line 530
              send(fd, (void const   *)(err_cmd_unknown_str), sizeof(err_cmd_unknown_str),
                   0);
#line 530
              send(fd, (void const   *)"\000\000", sizeof("\000\000"), 0);
#line 531
              return;
            }
          }
        }
      }
    }
#line 497
    exe_index ++;
  }
#line 537
  if (! found) {
#line 539
    if ((*(cmd + 0)) == 402L) {
#line 540
      err_str = (char *)"cannot renice job id %ld for %s : no corresponding running job.";
    } else {
#line 542
      if ((*(cmd + 0)) == 401L) {
#line 543
        err_str = (char *)"cannot send signal to job id %ld for %s : no corresponding running job.";
      } else {
#line 546
        err_str = (char *)"cannot run unknown cmd on job id %ld for %s : no corresponding running job.";
      }
    }
#line 549
    warn(err_str, (*(cmd + 2)), client->fcl_user);
#line 550
    send(fd, (void const   *)(err_rjob_nfound_str), sizeof(err_rjob_nfound_str), 0);
#line 550
    send(fd, (void const   *)"\000\000", sizeof("\000\000"), 0);
  } else {
#line 553
    send(fd, (void const   *)"\000\000", sizeof("\000\000"), 0);
  }
#line 556
  return;
}
}
#line 559 "socket.c"
void cmd_renice(struct fcrondyn_cl *client , long *cmd , int fd , int exe_index ,
                int is_root ) 
{ int tmp ;

  {
#line 566
  if ((exe_array + exe_index)->e_job_pid <= 0) {
#line 568
    warn((char *)"renice: invalid args : pid: %d nice_value: %d user: %s.", (exe_array +
                                                                             exe_index)->e_job_pid,
         (int )(*(cmd + 1)), client->fcl_user);
#line 570
    send(fd, (void const   *)(err_invalid_args_str), sizeof(err_invalid_args_str),
         0);
#line 570
    send(fd, (void const   *)"\000\000", sizeof("\000\000"), 0);
#line 571
    return;
  } else {
#line 566
    if ((int )(*(cmd + 1)) < 0) {
#line 566
      if (! is_root) {
#line 568
        warn((char *)"renice: invalid args : pid: %d nice_value: %d user: %s.", (exe_array +
                                                                                 exe_index)->e_job_pid,
             (int )(*(cmd + 1)), client->fcl_user);
#line 570
        send(fd, (void const   *)(err_invalid_args_str), sizeof(err_invalid_args_str),
             0);
#line 570
        send(fd, (void const   *)"\000\000", sizeof("\000\000"), 0);
#line 571
        return;
      } else {
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 566
      if ((int )(*(cmd + 1)) > 20) {
#line 568
        warn((char *)"renice: invalid args : pid: %d nice_value: %d user: %s.", (exe_array +
                                                                                 exe_index)->e_job_pid,
             (int )(*(cmd + 1)), client->fcl_user);
#line 570
        send(fd, (void const   *)(err_invalid_args_str), sizeof(err_invalid_args_str),
             0);
#line 570
        send(fd, (void const   *)"\000\000", sizeof("\000\000"), 0);
#line 571
        return;
      } else {
#line 566
        if ((int )(*(cmd + 1)) < -20) {
#line 568
          warn((char *)"renice: invalid args : pid: %d nice_value: %d user: %s.",
               (exe_array + exe_index)->e_job_pid, (int )(*(cmd + 1)), client->fcl_user);
#line 570
          send(fd, (void const   *)(err_invalid_args_str), sizeof(err_invalid_args_str),
               0);
#line 570
          send(fd, (void const   *)"\000\000", sizeof("\000\000"), 0);
#line 571
          return;
        }
      }
    }
  }
#line 575
  tmp = setpriority(0, (unsigned int )(exe_array + exe_index)->e_job_pid, (int )(*(cmd +
                                                                                   1)));
#line 575
  if (tmp != 0) {
#line 576
    error_e((char *)"could not setpriority(PRIO_PROCESS, %d, %d)", (exe_array + exe_index)->e_job_pid,
            (int )(*(cmd + 1)));
#line 578
    send(fd, (void const   *)(err_unknown_str), sizeof(err_unknown_str), 0);
#line 578
    send(fd, (void const   *)"\000\000", sizeof("\000\000"), 0);
#line 579
    return;
  } else {
#line 582
    send_msg_fd(fd, (char *)"Command successfully completed on process %d.", (exe_array +
                                                                              exe_index)->e_job_pid);
#line 584
    return;
  }
}
}
#line 596 "socket.c"
void cmd_send_signal(struct fcrondyn_cl *client , long *cmd , int fd , int exe_index ) 
{ int tmp ;

  {
#line 600
  if ((exe_array + exe_index)->e_job_pid <= 0) {
#line 601
    warn((char *)"send_signal: invalid args : pid: %d signal: %d user: %s", (exe_array +
                                                                             exe_index)->e_job_pid,
         (int )(*(cmd + 1)), client->fcl_user);
#line 603
    send(fd, (void const   *)(err_invalid_args_str), sizeof(err_invalid_args_str),
         0);
#line 603
    send(fd, (void const   *)"\000\000", sizeof("\000\000"), 0);
#line 604
    return;
  } else {
#line 600
    if ((int )(*(cmd + 1)) <= 0) {
#line 601
      warn((char *)"send_signal: invalid args : pid: %d signal: %d user: %s", (exe_array +
                                                                               exe_index)->e_job_pid,
           (int )(*(cmd + 1)), client->fcl_user);
#line 603
      send(fd, (void const   *)(err_invalid_args_str), sizeof(err_invalid_args_str),
           0);
#line 603
      send(fd, (void const   *)"\000\000", sizeof("\000\000"), 0);
#line 604
      return;
    }
  }
#line 608
  tmp = kill((exe_array + exe_index)->e_job_pid, (int )(*(cmd + 1)));
#line 608
  if (tmp != 0) {
#line 609
    error_e((char *)"could not kill(%d, %d)", (exe_array + exe_index)->e_job_pid,
            (int )(*(cmd + 1)));
#line 610
    send(fd, (void const   *)(err_unknown_str), sizeof(err_unknown_str), 0);
#line 610
    send(fd, (void const   *)"\000\000", sizeof("\000\000"), 0);
#line 611
    return;
  } else {
#line 614
    send_msg_fd(fd, (char *)"Command successfully completed on process %d.", (exe_array +
                                                                              exe_index)->e_job_pid);
#line 616
    return;
  }
}
}
#line 621 "socket.c"
void cmd_run(struct fcrondyn_cl *client , long *cmd , int fd , int is_root ) 
{ struct job_t *j ;
  int tmp ;

  {
#line 626
  j = (struct job_t *)((void *)0);
#line 628
  j = queue_base;
#line 628
  while ((unsigned int )j != (unsigned int )((void *)0)) {
#line 629
    if ((*(cmd + 1)) == (j->j_line)->cl_id) {
#line 630
      tmp = strcmp((char const   *)client->fcl_user, (char const   *)((j->j_line)->cl_file)->cf_user);
#line 630
      if (tmp == 0) {
        goto _L;
      } else {
#line 630
        if (is_root) {
          _L: /* CIL Label */ 
#line 633
          if ((int )(j->j_line)->cl_option[0] & 2) {
#line 634
            add_lavg_job(j->j_line, fd);
          } else {
#line 635
            if ((int )(j->j_line)->cl_option[0] & 32) {
#line 636
              add_serial_job(j->j_line, fd);
            } else {
#line 638
              run_normal_job(j->j_line, fd);
            }
          }
#line 640
          if ((*(cmd + 0)) == 301L) {
#line 641
            set_next_exe(j->j_line, 4, fd);
          }
#line 643
          send(fd, (void const   *)"\000\000", sizeof("\000\000"), 0);
#line 645
          return;
        }
      }
    }
#line 628
    j = j->j_next;
  }
#line 652
  send(fd, (void const   *)(err_job_nfound_str), sizeof(err_job_nfound_str), 0);
#line 652
  send(fd, (void const   *)"\000\000", sizeof("\000\000"), 0);
#line 654
  return;
}
}
#line 656 "socket.c"
void exe_cmd(struct fcrondyn_cl *client ) 
{ long *cmd ;
  int fd ;
  int is_root ;
  int tmp___0 ;

  {
#line 662
  is_root = 0;
#line 664
  tmp___0 = strcmp((char const   *)client->fcl_user, "root");
#line 664
  if (tmp___0 == 0) {
#line 664
    is_root = 1;
  } else {
#line 664
    is_root = 0;
  }
#line 667
  cmd = client->fcl_cmd;
#line 668
  fd = client->fcl_sock_fd;
#line 671
  if (debug_opt) {
#line 671
    Debug((char *)"exe_cmd [0,1,2] : %d %d %d", (*(cmd + 0)), (*(cmd + 1)), (*(cmd +
                                                                               2)));
  }
#line 674
  switch ((int )(*(cmd + 0))) {
  case 401: ;
  case 402: 
#line 678
  cmd_on_exeq(client, cmd, fd, is_root);
#line 679
  break;
  case 105: ;
  case 101: ;
  case 102: ;
  case 103: ;
  case 104: 
#line 686
  cmd_ls(client, cmd, fd, is_root);
#line 687
  break;
  case 302: ;
  case 301: 
#line 691
  cmd_run(client, cmd, fd, is_root);
#line 692
  break;
  default: 
#line 695
  send(fd, (void const   *)(err_cmd_unknown_str), sizeof(err_cmd_unknown_str), 0);
#line 695
  send(fd, (void const   *)"\000\000", sizeof("\000\000"), 0);
  }
#line 697
  return;
}
}
#line 699 "socket.c"
void remove_connection(struct fcrondyn_cl **client , struct fcrondyn_cl *prev_client ) 
{ 

  {
#line 704
  shutdown(((*client))->fcl_sock_fd, 2);
#line 705
  close(((*client))->fcl_sock_fd);
#line 706
  master_set.__fds_bits[(unsigned int )((*client))->fcl_sock_fd / (8U * sizeof(__fd_mask ))] = master_set.__fds_bits[(unsigned int )((*client))->fcl_sock_fd /
                                                                                                                     (8U *
                                                                                                                      sizeof(__fd_mask ))] &
                                                                                               ~ (1L <<
                                                                                                  (unsigned int )((*client))->fcl_sock_fd %
                                                                                                  (8U *
                                                                                                   sizeof(__fd_mask )));
#line 707
  if (debug_opt) {
#line 707
    Debug((char *)"connection closed : fd : %d", ((*client))->fcl_sock_fd);
  }
#line 708
  if ((unsigned int )prev_client == (unsigned int )((void *)0)) {
#line 709
    fcrondyn_cl_base = ((*client))->fcl_next;
#line 710
    free((void *)((*client))->fcl_user);
#line 710
    ((*client))->fcl_user = (char *)((void *)0);
#line 711
    free((void *)(*client));
#line 711
    (*client) = (struct fcrondyn_cl *)((void *)0);
#line 712
    (*client) = fcrondyn_cl_base;
  } else {
#line 715
    prev_client->fcl_next = ((*client))->fcl_next;
#line 716
    free((void *)((*client))->fcl_user);
#line 716
    ((*client))->fcl_user = (char *)((void *)0);
#line 717
    free((void *)(*client));
#line 717
    (*client) = (struct fcrondyn_cl *)((void *)0);
#line 718
    (*client) = prev_client->fcl_next;
  }
#line 720
  fcrondyn_cl_num --;
#line 721
  return;
}
}
#line 723 "socket.c"
void check_socket(int num ) 
{ int fd ;
  int avoid_fd ;
  int addr_len ;
  struct sockaddr_un client_addr ;
  long buf_int[20] ;
  int read_len ;
  struct fcrondyn_cl *client ;
  struct fcrondyn_cl *prev_client ;
  int tmp ;
  int tmp___0 ;

  {
#line 727
  fd = -1;
#line 727
  avoid_fd = -1;
#line 727
  addr_len = (int )sizeof(struct sockaddr_un );
#line 730
  read_len = 0;
#line 731
  client = (struct fcrondyn_cl *)((void *)0);
#line 731
  prev_client = (struct fcrondyn_cl *)((void *)0);
#line 733
  if (num <= 0) {
    goto final_settings;
  }
#line 737
  if (debug_opt) {
#line 737
    Debug((char *)"Checking socket ...");
  }
#line 739
  if (read_set.__fds_bits[(unsigned int )listen_fd / (8U * sizeof(__fd_mask ))] &
      (1L << (unsigned int )listen_fd % (8U * sizeof(__fd_mask )))) {
#line 740
    if (debug_opt) {
#line 740
      Debug((char *)"got new connection ...");
    }
#line 741
    fd = accept(listen_fd, (void */* __restrict  */)((struct sockaddr *)(& client_addr)),
                (socklen_t */* __restrict  */)(& addr_len));
#line 741
    if (fd == -1) {
#line 742
      error_e((char *)"could not accept new connection : isset(listen_fd = %d) = %d",
              listen_fd, read_set.__fds_bits[(unsigned int )listen_fd / (8U * sizeof(__fd_mask ))] &
                         (1L << (unsigned int )listen_fd % (8U * sizeof(__fd_mask ))));
    } else {
#line 746
      fcntl(fd, 2, 1);
#line 748
      tmp = fcntl(fd, 3);
#line 748
      tmp___0 = fcntl(fd, 4, tmp | 2048);
#line 748
      if (tmp___0 == -1) {
#line 749
        error_e((char *)"Could not set fd attribute O_NONBLOCK : connection rejected.");
#line 750
        shutdown(fd, 2);
#line 751
        close(fd);
      } else {
#line 754
        client = (struct fcrondyn_cl *)calloc(1U, sizeof(fcrondyn_cl ));
#line 754
        if ((unsigned int )client == (unsigned int )((void *)0)) {
#line 754
          die_e((char *)"Could not calloc.");
        }
#line 755
        client->fcl_sock_fd = fd;
#line 757
        client->fcl_user = (char *)((void *)0);
#line 758
        client->fcl_cmd = (long *)((void *)0);
#line 761
        client->fcl_next = fcrondyn_cl_base;
#line 762
        fcrondyn_cl_base = client;
#line 763
        client->fcl_idle_since = now;
#line 765
        avoid_fd = fd;
#line 767
        master_set.__fds_bits[(unsigned int )fd / (8U * sizeof(__fd_mask ))] = master_set.__fds_bits[(unsigned int )fd /
                                                                                                     (8U *
                                                                                                      sizeof(__fd_mask ))] |
                                                                               (1L <<
                                                                                (unsigned int )fd %
                                                                                (8U *
                                                                                 sizeof(__fd_mask )));
#line 768
        if (fd > set_max_fd) {
#line 769
          set_max_fd = fd;
        }
#line 770
        fcrondyn_cl_num ++;
#line 772
        if (debug_opt) {
#line 772
          Debug((char *)"Added connection fd : %d - %d connections", fd, fcrondyn_cl_num);
        }
      }
    }
  }
#line 777
  client = fcrondyn_cl_base;
#line 778
  while ((unsigned int )client != (unsigned int )((void *)0)) {
#line 779
    if (! (read_set.__fds_bits[(unsigned int )client->fcl_sock_fd / (8U * sizeof(__fd_mask ))] &
           (1L << (unsigned int )client->fcl_sock_fd % (8U * sizeof(__fd_mask ))))) {
      goto _L___0;
    } else {
#line 779
      if (client->fcl_sock_fd == avoid_fd) {
        _L___0: /* CIL Label */ 
#line 781
        if ((unsigned int )client->fcl_user == (unsigned int )((void *)0)) {
#line 781
          if (now - client->fcl_idle_since > 60L) {
#line 782
            warn((char *)"Connection with no auth for more than %ds : closing it.",
                 60);
#line 784
            remove_connection(& client, prev_client);
          } else {
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 786
          if (now - client->fcl_idle_since > 600L) {
#line 787
            warn((char *)"Connection of %s is idle for more than %ds : closing it.",
                 client->fcl_user, 600);
#line 789
            remove_connection(& client, prev_client);
          } else {
#line 793
            prev_client = client;
#line 794
            client = client->fcl_next;
          }
        }
#line 796
        continue;
      }
    }
#line 799
    read_len = recv(client->fcl_sock_fd, (void *)(buf_int), sizeof(buf_int), 0);
#line 799
    if (read_len <= 0) {
#line 800
      if (read_len == 0) {
#line 802
        remove_connection(& client, prev_client);
      } else {
#line 805
        error_e((char *)"error recv() from sock fd %d", client->fcl_sock_fd);
#line 806
        prev_client = client;
#line 807
        client = client->fcl_next;
      }
    } else {
#line 811
      client->fcl_cmd_len = read_len;
#line 812
      client->fcl_cmd = buf_int;
#line 813
      if ((unsigned int )client->fcl_user == (unsigned int )((void *)0)) {
#line 815
        auth_client(client);
      } else {
#line 818
        client->fcl_idle_since = now;
#line 819
        exe_cmd(client);
      }
#line 821
      prev_client = client;
#line 822
      client = client->fcl_next;
    }
  }
  final_settings: 
#line 828
  read_set = master_set;
#line 829
  return;
}
}
#line 832 "socket.c"
void close_socket(void) 
{ struct fcrondyn_cl *client ;
  struct fcrondyn_cl *client_buf ;

  {
#line 836
  client_buf = (struct fcrondyn_cl *)((void *)0);
#line 838
  if (listen_fd) {
#line 839
    shutdown(listen_fd, 2);
#line 840
    close(listen_fd);
#line 841
    unlink((char const   *)fifofile);
#line 843
    client = fcrondyn_cl_base;
#line 844
    while ((unsigned int )client != (unsigned int )((void *)0)) {
#line 845
      shutdown(client->fcl_sock_fd, 2);
#line 846
      close(client->fcl_sock_fd);
#line 848
      client_buf = client->fcl_next;
#line 849
      free((void *)client);
#line 849
      client = (struct fcrondyn_cl *)((void *)0);
#line 850
      fcrondyn_cl_num --;
#line 851
      client = client_buf;
    }
  }
#line 854
  return;
}
}

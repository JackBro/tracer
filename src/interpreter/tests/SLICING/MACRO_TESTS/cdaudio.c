// SAFE

/* Generated by Frontc */

char SLAM_alloc_dummy ;

char *  malloc(int i )
{
  return & SLAM_alloc_dummy;
}

// #line 16 "C:/Program Files/Microsoft Visual Studio/VC98/include/excpt.h"

typedef enum _EXCEPTION_DISPOSITION {
	ExceptionContinueExecution,
	ExceptionContinueSearch,
	ExceptionNestedException,
	ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION ;

// #line 89
struct _EXCEPTION_RECORD ;

// #line 90
struct _CONTEXT ;
// #line 25 "C:/NTDDK/inc/ntdef.h"
// #line 15 "C:/Program Files/Microsoft Visual Studio/VC98/include/ctype.h"
typedef unsigned short wchar_t ;
typedef wchar_t wint_t ;
typedef wchar_t wctype_t ;
typedef unsigned long POINTER_64_INT ;

// #line 25 "C:/NTDDK/inc/basetsd.h"
typedef int LONG32 , *  PLONG32 ;
typedef int INT32 , *  PINT32 ;
typedef unsigned int ULONG32 , *  PULONG32 ;
typedef unsigned int DWORD32 , *  PDWORD32 ;
typedef unsigned int UINT32 , *  PUINT32 ;
typedef int INT_PTR , *  PINT_PTR ;
typedef unsigned int UINT_PTR , *  PUINT_PTR ;
typedef long LONG_PTR , *  PLONG_PTR ;
typedef unsigned long ULONG_PTR , *  PULONG_PTR ;
typedef unsigned short UHALF_PTR , *  PUHALF_PTR ;
typedef short HALF_PTR , *  PHALF_PTR ;
typedef unsigned long HANDLE_PTR ;
typedef ULONG_PTR SIZE_T , *  PSIZE_T ;
typedef LONG_PTR SSIZE_T , *  PSSIZE_T ;
typedef ULONG_PTR DWORD_PTR , *  PDWORD_PTR ;
typedef long /* __int64 */ LONG64 , *  PLONG64 ;
typedef long /* __int64 */ INT64 , *  PINT64 ;
typedef unsigned long /*__int64*/ ULONG64 , *  PULONG64 ;
typedef unsigned long /*__int64*/ DWORD64 , *  PDWORD64 ;
typedef unsigned long /*__int64*/ UINT64 , *  PUINT64 ;
// #line 217 "C:/NTDDK/inc/ntdef.h"
typedef void *  PVOID ;
typedef void *  PVOID64 ;
typedef char CHAR ;
typedef short SHORT ;
typedef long LONG ;
typedef wchar_t WCHAR ;
typedef WCHAR *  PWCHAR ;
typedef WCHAR *  LPWCH , *  PWCH ;
typedef WCHAR *  LPCWCH , *  PCWCH ;
typedef WCHAR *  NWPSTR ;
typedef WCHAR *  LPWSTR , *  PWSTR ;
typedef   WCHAR *  LPCWSTR , *  PCWSTR ;
typedef CHAR *  PCHAR ;
typedef CHAR *  LPCH , *  PCH ;
typedef   CHAR *  LPCCH , *  PCCH ;
typedef CHAR *  NPSTR ;
typedef CHAR *  LPSTR , *  PSTR ;
typedef   CHAR *  LPCSTR , *  PCSTR ;
typedef char TCHAR , *  PTCHAR ;
typedef unsigned char TUCHAR , *  PTUCHAR ;
typedef LPSTR LPTCH , PTCH ;
typedef LPSTR PTSTR , LPTSTR ;
typedef LPCSTR PCTSTR , LPCTSTR ;
typedef double DOUBLE ;

// #line 349
typedef SHORT *  PSHORT ;

// #line 350
typedef LONG *  PLONG ;

// #line 351
// #line 360
typedef unsigned char UCHAR ;

// #line 361
typedef unsigned short USHORT ;

// #line 362
typedef unsigned long ULONG ;

// #line 363
// #line 369
typedef UCHAR *  PUCHAR ;

// #line 370
typedef USHORT *  PUSHORT ;

// #line 371
typedef ULONG *  PULONG ;

// #line 372
// #line 378
typedef signed char SCHAR ;

// #line 379
typedef SCHAR *  PSCHAR ;

// #line 394
typedef void *  HANDLE ;

// #line 400
typedef HANDLE *  PHANDLE ;

// #line 406
typedef UCHAR FCHAR ;

// #line 407
typedef USHORT FSHORT ;

// #line 408
typedef ULONG FLONG ;

// #line 414
typedef LONG HRESULT ;

// #line 478
typedef char CCHAR ;

// #line 479
typedef short CSHORT ;

// #line 480
typedef ULONG CLONG ;

typedef CCHAR *  PCCHAR ;

// #line 483
typedef CSHORT *  PCSHORT ;

// #line 484
typedef CLONG *  PCLONG ;

// #line 492
typedef ULONG LCID ;

// #line 493
typedef PULONG PLCID ;

// #line 494
typedef USHORT LANGID ;

// #line 500
typedef ULONG LOGICAL ;

// #line 501
typedef ULONG *  PLOGICAL ;

// #line 508
typedef LONG NTSTATUS ;

typedef NTSTATUS *  PNTSTATUS ;

// #line 602
typedef struct _FLOAT128 {
	long /*__int64*/ LowPart ;
	long /*__int64*/ HighPart ;
} FLOAT128 ;

typedef FLOAT128 *  PFLOAT128 ;

// #line 621
typedef long /*__int64*/ LONGLONG ;

// #line 622
typedef unsigned long /*__int64*/ ULONGLONG ;

// #line 639
typedef LONGLONG *  PLONGLONG ;

// #line 640
typedef ULONGLONG *  PULONGLONG ;

// #line 644
typedef LONGLONG USN ;

// #line 649
typedef union _LARGE_INTEGER {
	struct  {
		ULONG LowPart ;
		LONG HighPart ;
	}  ;
	struct  {
		ULONG LowPart ;
		LONG HighPart ;
	} u ;
	LONGLONG QuadPart ;
} LARGE_INTEGER ;

// #line 662
typedef LARGE_INTEGER *  PLARGE_INTEGER ;

// #line 668
typedef union _ULARGE_INTEGER {
	struct  {
		ULONG LowPart ;
		ULONG HighPart ;
	}  ;
	struct  {
		ULONG LowPart ;
		ULONG HighPart ;
	} u ;
	ULONGLONG QuadPart ;
} ULARGE_INTEGER ;

// #line 681
typedef ULARGE_INTEGER *  PULARGE_INTEGER ;

// #line 690
typedef struct _LUID {
	ULONG LowPart ;
	LONG HighPart ;
} LUID , *  PLUID ;

// #line 696
typedef ULONGLONG DWORDLONG ;

// #line 697
typedef DWORDLONG *  PDWORDLONG ;

// #line 707
typedef LARGE_INTEGER PHYSICAL_ADDRESS , *  PPHYSICAL_ADDRESS ;

// #line 809
// #line 816
// #line 823

// #line 831

// #pragma warning(push)

// #pragma warning(disable:4035)
// #pragma warning(pop)
// #line 956
typedef enum _EVENT_TYPE {
	NotificationEvent,
	SynchronizationEvent
} EVENT_TYPE ;

// #line 965
typedef enum _TIMER_TYPE {
	NotificationTimer,
	SynchronizationTimer
} TIMER_TYPE ;

// #line 974
typedef enum _WAIT_TYPE {
	WaitAll,
	WaitAny
} WAIT_TYPE ;

// #line 983
typedef CHAR *  PSZ ;

// #line 984
typedef   char *  PCSZ ;

// #line 991
typedef struct _STRING {
	USHORT Length ;
	USHORT MaximumLength ;
	PCHAR Buffer ;
} STRING ;

// #line 999
typedef STRING *  PSTRING ;

typedef STRING ANSI_STRING ;

// #line 1002
typedef PSTRING PANSI_STRING ;

typedef STRING OEM_STRING ;

// #line 1005
typedef PSTRING POEM_STRING ;

// #line 1011
typedef struct _CSTRING {
	USHORT Length ;
	USHORT MaximumLength ;
	  char *  Buffer ;
} CSTRING ;

// #line 1016
typedef CSTRING *  PCSTRING ;

// #line 1019
typedef STRING CANSI_STRING ;

// #line 1020
typedef PSTRING PCANSI_STRING ;

// #line 1027
typedef struct _UNICODE_STRING {
	USHORT Length ;
	USHORT MaximumLength ;
	PWSTR Buffer ;
} UNICODE_STRING ;

// #line 1036
typedef UNICODE_STRING *  PUNICODE_STRING ;

// #line 1037
typedef   UNICODE_STRING *  PCUNICODE_STRING ;

// #line 1046
typedef UCHAR BOOLEAN ;

// #line 1047
typedef BOOLEAN *  PBOOLEAN ;

// #line 1057
typedef struct _LIST_ENTRY {
	struct _LIST_ENTRY *  Flink ;
	struct _LIST_ENTRY *  Blink ;
} LIST_ENTRY , *  PLIST_ENTRY , *  PRLIST_ENTRY ;

// #line 1067
typedef struct _SINGLE_LIST_ENTRY {
	struct _SINGLE_LIST_ENTRY *  Next ;
} SINGLE_LIST_ENTRY , *  PSINGLE_LIST_ENTRY ;

// #line 1078
typedef struct LIST_ENTRY32 {
	ULONG Flink ;
	ULONG Blink ;
} LIST_ENTRY32 ;

// #line 1082
typedef LIST_ENTRY32 *  PLIST_ENTRY32 ;

typedef struct LIST_ENTRY64 {
	ULONGLONG Flink ;
	ULONGLONG Blink ;
} LIST_ENTRY64 ;

// #line 1088
typedef LIST_ENTRY64 *  PLIST_ENTRY64 ;

// #line 1094
// #line 1127
typedef struct _STRING32 {
	USHORT Length ;
	USHORT MaximumLength ;
	ULONG Buffer ;
} STRING32 ;

// #line 1132
typedef STRING32 *  PSTRING32 ;

typedef STRING32 UNICODE_STRING32 ;

// #line 1135
typedef UNICODE_STRING32 *  PUNICODE_STRING32 ;

typedef STRING32 ANSI_STRING32 ;

// #line 1138
typedef ANSI_STRING32 *  PANSI_STRING32 ;

// #line 1141
typedef struct _STRING64 {
	USHORT Length ;
	USHORT MaximumLength ;
	ULONGLONG Buffer ;
} STRING64 ;

// #line 1146
typedef STRING64 *  PSTRING64 ;

typedef STRING64 UNICODE_STRING64 ;

// #line 1149
typedef UNICODE_STRING64 *  PUNICODE_STRING64 ;

typedef STRING64 ANSI_STRING64 ;

// #line 1152
typedef ANSI_STRING64 *  PANSI_STRING64 ;

// #line 1173
typedef struct _OBJECT_ATTRIBUTES {
	ULONG Length ;
	HANDLE RootDirectory ;
	PUNICODE_STRING ObjectName ;
	ULONG Attributes ;
	PVOID SecurityDescriptor ;
	PVOID SecurityQualityOfService ;
} OBJECT_ATTRIBUTES ;

// #line 1181
typedef OBJECT_ATTRIBUTES *  POBJECT_ATTRIBUTES ;

// #line 17 "C:/NTDDK/inc/guiddef.h"
typedef struct _GUID {
	unsigned long Data1 ;
	unsigned short Data2 ;
	unsigned short Data3 ;
	unsigned char Data4[8] ;
} GUID ;

// #line 70
typedef GUID *  LPGUID ;

// #line 75
typedef   GUID *  LPCGUID ;

// #line 81
typedef GUID IID ;

// #line 82
typedef IID *  LPIID ;

// #line 85
typedef GUID CLSID ;

// #line 86
typedef CLSID *  LPCLSID ;

// #line 89
typedef GUID FMTID ;

// #line 90
typedef FMTID *  LPFMTID ;

// #line 16 "C:/NTDDK/inc/string.h"

// #pragma once
// #line 54
typedef unsigned int size_t ;

void * memcpy(void * a ,   void * b , size_t c){
  int x;
  return (void *) x;
}

int memcmp(  void *  a,   void * b , size_t c){
  int x;
  return x;
}

void * memset(void *  a, int b , size_t c){
  int x;
  return (void *) x;
}
 
// #line 1233 "C:/NTDDK/inc/ntdef.h"
typedef struct _OBJECTID {
	GUID Lineage ;
	ULONG Uniquifier ;
} OBJECTID ;

// #line 1288
struct _CONTEXT ;

// #line 1289
struct _EXCEPTION_RECORD ;

typedef EXCEPTION_DISPOSITION ( *  PEXCEPTION_ROUTINE
	)(struct _EXCEPTION_RECORD *  ExceptionRecord , PVOID EstablisherFrame ,
	struct _CONTEXT *  ContextRecord , PVOID DispatcherContext ) ;

// #line 1306
typedef UCHAR KIRQL ;

typedef KIRQL *  PKIRQL ;

// #line 1316
typedef enum _NT_PRODUCT_TYPE {
	NtProductWinNt /* = 1 */,
	NtProductLanManNt,
	NtProductServer
} NT_PRODUCT_TYPE , *  PNT_PRODUCT_TYPE ;

// #line 1329
typedef enum _SUITE_TYPE {
	SmallBusiness,
	Enterprise,
	BackOffice,
	CommunicationServer,
	TerminalServer,
	SmallBusinessRestricted,
	EmbeddedNT,
	DataCenter,
	SingleUserTS,
	MaxSuiteType
} SUITE_TYPE ;

// #line 75 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _KTHREAD *  PKTHREAD ;

// #line 76
typedef struct _ETHREAD *  PETHREAD ;

// #line 77
typedef struct _EPROCESS *  PEPROCESS ;

// #line 78
typedef struct _PEB *  PPEB ;

// #line 79
typedef struct _KINTERRUPT *  PKINTERRUPT ;

// #line 80
typedef struct _IO_TIMER *  PIO_TIMER ;

// #line 81
typedef struct _OBJECT_TYPE *  POBJECT_TYPE ;

// #line 82
typedef struct _CALLBACK_OBJECT *  PCALLBACK_OBJECT___0 ;

// #line 83
typedef struct _DEVICE_HANDLER_OBJECT *  PDEVICE_HANDLER_OBJECT ;

// #line 84
typedef struct _BUS_HANDLER *  PBUS_HANDLER ;

// #line 101
PKTHREAD   KeGetCurrentThread() ;
// #line 124
extern PCCHAR KeNumberProcessors ;

// #line 143
typedef union _SLIST_HEADER {
	ULONGLONG Alignment ;
	struct  {
		SINGLE_LIST_ENTRY Next ;
		USHORT Depth ;
		USHORT Sequence ;
	}  ;
} SLIST_HEADER , *  PSLIST_HEADER ;

// #line 204
typedef CCHAR KPROCESSOR_MODE ;

typedef enum _MODE {
	KernelMode,
	UserMode,
	MaximumMode
} MODE ;

// #line 222
struct _KAPC ;

typedef void ( *  PKNORMAL_ROUTINE )(PVOID NormalContext , PVOID SystemArgument1
	, PVOID SystemArgument2 ) ;

// #line 232
typedef void ( *  PKKERNEL_ROUTINE )(struct _KAPC *  Apc , PKNORMAL_ROUTINE * 
	NormalRoutine , PVOID *  NormalContext , PVOID *  SystemArgument1 ,
	PVOID *  SystemArgument2 ) ;

// #line 242
typedef void ( *  PKRUNDOWN_ROUTINE )(struct _KAPC *  Apc ) ;

// #line 248
typedef BOOLEAN ( *  PKSYNCHRONIZE_ROUTINE )(PVOID SynchronizeContext ) ;

// #line 254
typedef BOOLEAN ( *  PKTRANSFER_ROUTINE )(void  ) ;

// #line 265
typedef struct _KAPC {
	CSHORT Type ;
	CSHORT Size ;
	ULONG Spare0 ;
	struct _KTHREAD *  Thread ;
	LIST_ENTRY ApcListEntry ;
	PKKERNEL_ROUTINE KernelRoutine ;
	PKRUNDOWN_ROUTINE RundownRoutine ;
	PKNORMAL_ROUTINE NormalRoutine ;
	PVOID NormalContext ;
	PVOID SystemArgument1 ;
	PVOID SystemArgument2 ;
	CCHAR ApcStateIndex ;
	KPROCESSOR_MODE ApcMode ;
	BOOLEAN Inserted ;
} KAPC , *  PKAPC , *  PRKAPC ;

// #line 292
struct _KDPC ;

typedef void ( *  PKDEFERRED_ROUTINE )(struct _KDPC *  Dpc , PVOID
	DeferredContext , PVOID SystemArgument1 , PVOID SystemArgument2 ) ;

// #line 351
typedef enum _KDPC_IMPORTANCE {
	LowImportance,
	MediumImportance,
	HighImportance
} KDPC_IMPORTANCE ;

// #line 361
typedef struct _KDPC {
	CSHORT Type ;
	UCHAR Number ;
	UCHAR Importance ;
	LIST_ENTRY DpcListEntry ;
	PKDEFERRED_ROUTINE DeferredRoutine ;
	PVOID DeferredContext ;
	PVOID SystemArgument1 ;
	PVOID SystemArgument2 ;
	PULONG_PTR Lock ;
} KDPC , *  PKDPC , *  PRKDPC ;

// #line 377
typedef PVOID PKIPI_CONTEXT ;

typedef void ( *  PKIPI_WORKER )(PKIPI_CONTEXT PacketContext , PVOID Parameter1
	, PVOID Parameter2 , PVOID Parameter3 ) ;

// #line 392
typedef struct _KIPI_COUNTS {
	ULONG Freeze ;
	ULONG Packet ;
	ULONG DPC ;
	ULONG APC ;
	ULONG FlushSingleTb ;
	ULONG FlushMultipleTb ;
	ULONG FlushEntireTb ;
	ULONG GenericCall ;
	ULONG ChangeColor ;
	ULONG SweepDcache ;
	ULONG SweepIcache ;
	ULONG SweepIcacheRange ;
	ULONG FlushIoBuffers ;
	ULONG GratuitousDPC ;
} KIPI_COUNTS , *  PKIPI_COUNTS ;

// #line 443
typedef struct _MDL {
	struct _MDL *  Next ;
	CSHORT Size ;
	CSHORT MdlFlags ;
	struct _EPROCESS *  Process ;
	PVOID MappedSystemVa ;
	PVOID StartVa ;
	ULONG ByteCount ;
	ULONG ByteOffset ;
} MDL , *  PMDL ;

// #line 532
typedef PVOID PACCESS_TOKEN ;

// #line 538
typedef PVOID PSECURITY_DESCRIPTOR ;

// #line 544
typedef PVOID PSID ;

typedef ULONG ACCESS_MASK ;

// #line 547
typedef ACCESS_MASK *  PACCESS_MASK ;

// #line 597
typedef struct _GENERIC_MAPPING {
	ACCESS_MASK GenericRead ;
	ACCESS_MASK GenericWrite ;
	ACCESS_MASK GenericExecute ;
	ACCESS_MASK GenericAll ;
} GENERIC_MAPPING ;

// #line 603
typedef GENERIC_MAPPING *  PGENERIC_MAPPING ;

// #line 24 "C:/NTDDK/inc/pshpack4.h"

// #pragma warning(disable:4103)

// #pragma pack(push, 4)
// #line 618 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _LUID_AND_ATTRIBUTES {
	LUID Luid ;
	ULONG Attributes ;
} LUID_AND_ATTRIBUTES , *  PLUID_AND_ATTRIBUTES ;

// #line 622
typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[1] ;

// #line 623
typedef LUID_AND_ATTRIBUTES_ARRAY *  PLUID_AND_ATTRIBUTES_ARRAY ;

// #line 27 "C:/NTDDK/inc/poppack.h"

// #pragma warning(disable:4103)

// #pragma pack(pop)
// #line 642 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _ACL {
	UCHAR AclRevision ;
	UCHAR Sbz1 ;
	USHORT AclSize ;
	USHORT AceCount ;
	USHORT Sbz2 ;
} ACL ;

// #line 649
typedef ACL *  PACL ;

// #line 681
typedef struct _PRIVILEGE_SET {
	ULONG PrivilegeCount ;
	ULONG Control ;
	LUID_AND_ATTRIBUTES Privilege[1] ;
} PRIVILEGE_SET , *  PPRIVILEGE_SET ;

// #line 735
typedef enum _SECURITY_IMPERSONATION_LEVEL {
	SecurityAnonymous,
	SecurityIdentification,
	SecurityImpersonation,
	SecurityDelegation
} SECURITY_IMPERSONATION_LEVEL , *  PSECURITY_IMPERSONATION_LEVEL ;

// #line 753
typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE , * 
	PSECURITY_CONTEXT_TRACKING_MODE ;

// #line 762
typedef struct _SECURITY_QUALITY_OF_SERVICE {
	ULONG Length ;
	SECURITY_IMPERSONATION_LEVEL ImpersonationLevel ;
	SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode ;
	BOOLEAN EffectiveOnly ;
} SECURITY_QUALITY_OF_SERVICE , *  PSECURITY_QUALITY_OF_SERVICE ;

// #line 774
typedef struct _SE_IMPERSONATION_STATE {
	PACCESS_TOKEN Token ;
	BOOLEAN CopyOnOpen ;
	BOOLEAN EffectiveOnly ;
	SECURITY_IMPERSONATION_LEVEL Level ;
} SE_IMPERSONATION_STATE , *  PSE_IMPERSONATION_STATE ;

// #line 782
typedef ULONG SECURITY_INFORMATION , *  PSECURITY_INFORMATION ;

// #line 809
typedef ULONG KAFFINITY ;

// #line 810
typedef KAFFINITY *  PKAFFINITY ;

// #line 816
typedef LONG KPRIORITY ;

// #line 824
typedef ULONG_PTR KSPIN_LOCK ;

// #line 825
typedef KSPIN_LOCK *  PKSPIN_LOCK ;

// #line 833
typedef void ( *  PKINTERRUPT_ROUTINE )(void  ) ;

// #line 842
typedef enum _KPROFILE_SOURCE {
	ProfileTime,
	ProfileAlignmentFixup,
	ProfileTotalIssues,
	ProfilePipelineDry,
	ProfileLoadInstructions,
	ProfilePipelineFrozen,
	ProfileBranchInstructions,
	ProfileTotalNonissues,
	ProfileDcacheMisses,
	ProfileIcacheMisses,
	ProfileCacheMisses,
	ProfileBranchMispredictions,
	ProfileStoreInstructions,
	ProfileFpInstructions,
	ProfileIntegerInstructions,
	Profile2Issue,
	Profile3Issue,
	Profile4Issue,
	ProfileSpecialInstructions,
	ProfileTotalCycles,
	ProfileIcacheIssues,
	ProfileDcacheAccesses,
	ProfileMemoryBarrierCycles,
	ProfileLoadLinkedIssues,
	ProfileMaximum
} KPROFILE_SOURCE ;

// #line 1058
// #line 1067
// #line 1079
typedef NTSTATUS (  *  PRTL_QUERY_REGISTRY_ROUTINE )(PWSTR ValueName ,
	ULONG ValueType , PVOID ValueData , ULONG ValueLength , PVOID Context ,
	PVOID EntryContext ) ;

// #line 1088
typedef struct _RTL_QUERY_REGISTRY_TABLE {
	PRTL_QUERY_REGISTRY_ROUTINE QueryRoutine ;
	ULONG Flags ;
	PWSTR Name ;
	PVOID EntryContext ;
	ULONG DefaultType ;
	PVOID DefaultData ;
	ULONG DefaultLength ;
} RTL_QUERY_REGISTRY_TABLE , *  PRTL_QUERY_REGISTRY_TABLE ;

NTSTATUS   RtlQueryRegistryValues(ULONG RelativeTo,
				  PCWSTR Path , PRTL_QUERY_REGISTRY_TABLE QueryTable , PVOID Context ,
				  PVOID Environment ) ;
NTSTATUS   RtlWriteRegistryValue(ULONG RelativeTo,
				 PCWSTR Path , PCWSTR ValueName , ULONG ValueType , PVOID ValueData ,
				 ULONG ValueLength ) ;
NTSTATUS   RtlDeleteRegistryValue(ULONG RelativeTo,
				  PCWSTR Path , PCWSTR ValueName ) ;
SIZE_T     RtlCompareMemory(  void *  Source1 , void *  Source2 , SIZE_T Length );
NTSTATUS   RtlWriteRegistryValue(ULONG RelativeTo,
				 PCWSTR Path , PCWSTR ValueName , ULONG ValueType , PVOID ValueData ,
				 ULONG ValueLength ) ;

NTSTATUS RtlAnsiStringToUnicodeString(PUNICODE_STRING DestinationString ,	
				      PANSI_STRING SourceString , BOOLEAN AllocateDestinationString ) ;
// #pragma warning(push)

// #pragma warning(disable:4035)
// #line 1960
// #pragma warning(pop)
// #line 2214
typedef struct _TIME_FIELDS {
	CSHORT Year ;
	CSHORT Month ;
	CSHORT Day ;
	CSHORT Hour ;
	CSHORT Minute ;
	CSHORT Second ;
	CSHORT Milliseconds ;
	CSHORT Weekday ;
} TIME_FIELDS ;

// #line 2224
typedef TIME_FIELDS *  PTIME_FIELDS ;

// #line 2227
// #line 2239
// #line 2499
typedef struct _RTL_BITMAP {
	ULONG SizeOfBitMap ;
	PULONG Buffer ;
} RTL_BITMAP ;

// #line 2503
typedef RTL_BITMAP *  PRTL_BITMAP ;

// #line 2511
// #line 2525
// #line 2532
// #line 2549
// #line 2558
// #line 2578
// #line 2587
// #line 2601
// #line 2610

// #line 2627
typedef struct _RTL_BITMAP_RUN {
	ULONG StartingIndex ;
	ULONG NumberOfBits ;
} RTL_BITMAP_RUN ;

// #line 2633
typedef RTL_BITMAP_RUN *  PRTL_BITMAP_RUN ;

// #line 2886
typedef struct _RTL_RANGE {
	ULONGLONG Start ;
	ULONGLONG End ;
	PVOID UserData ;
	PVOID Owner ;
	UCHAR Attributes ;
	UCHAR Flags ;
} RTL_RANGE , *  PRTL_RANGE ;

// #line 2924
typedef struct _RTL_RANGE_LIST {
	LIST_ENTRY ListHead ;
	ULONG Flags ;
	ULONG Count ;
	ULONG Stamp ;
} RTL_RANGE_LIST , *  PRTL_RANGE_LIST ;

// #line 2950
typedef struct _RANGE_LIST_ITERATOR {
	PLIST_ENTRY RangeListHead ;
	PLIST_ENTRY MergedHead ;
	PVOID Current ;
	ULONG Stamp ;
} RTL_RANGE_LIST_ITERATOR , *  PRTL_RANGE_LIST_ITERATOR ;

// #line 2960
// #line 2967
// #line 2974
// #line 2985
// #line 2998
// #line 3008
// #line 3019
typedef BOOLEAN ( *  PRTL_CONFLICT_RANGE_CALLBACK )(PVOID Context , 
						    PRTL_RANGE Range ) ;
// #line 3155
typedef struct _OSVERSIONINFOA {
	ULONG dwOSVersionInfoSize ;
	ULONG dwMajorVersion ;
	ULONG dwMinorVersion ;
	ULONG dwBuildNumber ;
	ULONG dwPlatformId ;
	CHAR szCSDVersion[128] ;
} OSVERSIONINFOA , *  POSVERSIONINFOA , *  LPOSVERSIONINFOA ;

typedef struct _OSVERSIONINFOW {
	ULONG dwOSVersionInfoSize ;
	ULONG dwMajorVersion ;
	ULONG dwMinorVersion ;
	ULONG dwBuildNumber ;
	ULONG dwPlatformId ;
	WCHAR szCSDVersion[128] ;
} OSVERSIONINFOW , *  POSVERSIONINFOW , *  LPOSVERSIONINFOW , RTL_OSVERSIONINFOW
	, *  PRTL_OSVERSIONINFOW ;

// #line 3177
typedef OSVERSIONINFOA OSVERSIONINFO ;

// #line 3178
typedef POSVERSIONINFOA POSVERSIONINFO ;

// #line 3179
typedef LPOSVERSIONINFOA LPOSVERSIONINFO ;

// #line 3182
typedef struct _OSVERSIONINFOEXA {
	ULONG dwOSVersionInfoSize ;
	ULONG dwMajorVersion ;
	ULONG dwMinorVersion ;
	ULONG dwBuildNumber ;
	ULONG dwPlatformId ;
	CHAR szCSDVersion[128] ;
	USHORT wServicePackMajor ;
	USHORT wServicePackMinor ;
	USHORT wSuiteMask ;
	UCHAR wProductType ;
	UCHAR wReserved ;
} OSVERSIONINFOEXA , *  POSVERSIONINFOEXA , *  LPOSVERSIONINFOEXA ;

// #line 3195
typedef struct _OSVERSIONINFOEXW {
	ULONG dwOSVersionInfoSize ;
	ULONG dwMajorVersion ;
	ULONG dwMinorVersion ;
	ULONG dwBuildNumber ;
	ULONG dwPlatformId ;
	WCHAR szCSDVersion[128] ;
	USHORT wServicePackMajor ;
	USHORT wServicePackMinor ;
	USHORT wSuiteMask ;
	UCHAR wProductType ;
	UCHAR wReserved ;
} OSVERSIONINFOEXW , *  POSVERSIONINFOEXW , *  LPOSVERSIONINFOEXW ,
	RTL_OSVERSIONINFOEXW , *  PRTL_OSVERSIONINFOEXW ;

// #line 3213
typedef OSVERSIONINFOEXA OSVERSIONINFOEX ;

// #line 3214
typedef POSVERSIONINFOEXA POSVERSIONINFOEX ;

// #line 3215
typedef LPOSVERSIONINFOEXA LPOSVERSIONINFOEX ;

// #line 3275
// #line 3286
// #line 3292
// #line 3648
typedef struct _IO_STATUS_BLOCK {
	union  {
		NTSTATUS Status ;
		PVOID Pointer ;
	}  ;
	ULONG_PTR Information ;
} IO_STATUS_BLOCK , *  PIO_STATUS_BLOCK ;

// #line 3669
typedef void (  *  PIO_APC_ROUTINE )(PVOID ApcContext , PIO_STATUS_BLOCK
	IoStatusBlock , ULONG Reserved ) ;

// #line 3685
typedef enum _FILE_INFORMATION_CLASS {
	FileDirectoryInformation = 1,
	FileFullDirectoryInformation,
	FileBothDirectoryInformation,
	FileBasicInformation,
	FileStandardInformation,
	FileInternalInformation,
	FileEaInformation,
	FileAccessInformation,
	FileNameInformation,
	FileRenameInformation,
	FileLinkInformation,
	FileNamesInformation,
	FileDispositionInformation,
	FilePositionInformation,
	FileFullEaInformation,
	FileModeInformation,
	FileAlignmentInformation,
	FileAllInformation,
	FileAllocationInformation,
	FileEndOfFileInformation,
	FileAlternateNameInformation,
	FileStreamInformation,
	FilePipeInformation,
	FilePipeLocalInformation,
	FilePipeRemoteInformation,
	FileMailslotQueryInformation,
	FileMailslotSetInformation,
	FileCompressionInformation,
	FileObjectIdInformation,
	FileCompletionInformation,
	FileMoveClusterInformation,
	FileQuotaInformation,
	FileReparsePointInformation,
	FileNetworkOpenInformation,
	FileAttributeTagInformation,
	FileTrackingInformation,
	FileMaximumInformation
} FILE_INFORMATION_CLASS , *  PFILE_INFORMATION_CLASS ;

// #line 3731
typedef struct _FILE_BASIC_INFORMATION {
	LARGE_INTEGER CreationTime ;
	LARGE_INTEGER LastAccessTime ;
	LARGE_INTEGER LastWriteTime ;
	LARGE_INTEGER ChangeTime ;
	ULONG FileAttributes ;
} FILE_BASIC_INFORMATION , *  PFILE_BASIC_INFORMATION ;

typedef struct _FILE_STANDARD_INFORMATION {
	LARGE_INTEGER AllocationSize ;
	LARGE_INTEGER EndOfFile ;
	ULONG NumberOfLinks ;
	BOOLEAN DeletePending ;
	BOOLEAN Directory ;
} FILE_STANDARD_INFORMATION , *  PFILE_STANDARD_INFORMATION ;

typedef struct _FILE_POSITION_INFORMATION {
	LARGE_INTEGER CurrentByteOffset ;
} FILE_POSITION_INFORMATION , *  PFILE_POSITION_INFORMATION ;

typedef struct _FILE_ALIGNMENT_INFORMATION {
	ULONG AlignmentRequirement ;
} FILE_ALIGNMENT_INFORMATION , *  PFILE_ALIGNMENT_INFORMATION ;

typedef struct _FILE_NAME_INFORMATION {
	ULONG FileNameLength ;
	WCHAR FileName[1] ;
} FILE_NAME_INFORMATION , *  PFILE_NAME_INFORMATION ;

typedef struct _FILE_NETWORK_OPEN_INFORMATION {
	LARGE_INTEGER CreationTime ;
	LARGE_INTEGER LastAccessTime ;
	LARGE_INTEGER LastWriteTime ;
	LARGE_INTEGER ChangeTime ;
	LARGE_INTEGER AllocationSize ;
	LARGE_INTEGER EndOfFile ;
	ULONG FileAttributes ;
} FILE_NETWORK_OPEN_INFORMATION , *  PFILE_NETWORK_OPEN_INFORMATION ;

typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION {
	ULONG FileAttributes ;
	ULONG ReparseTag ;
} FILE_ATTRIBUTE_TAG_INFORMATION , *  PFILE_ATTRIBUTE_TAG_INFORMATION ;

typedef struct _FILE_DISPOSITION_INFORMATION {
	BOOLEAN DeleteFile ;
} FILE_DISPOSITION_INFORMATION , *  PFILE_DISPOSITION_INFORMATION ;

typedef struct _FILE_END_OF_FILE_INFORMATION {
	LARGE_INTEGER EndOfFile ;
} FILE_END_OF_FILE_INFORMATION , *  PFILE_END_OF_FILE_INFORMATION ;

// #line 3784
typedef struct _FILE_FULL_EA_INFORMATION {
	ULONG NextEntryOffset ;
	UCHAR Flags ;
	UCHAR EaNameLength ;
	USHORT EaValueLength ;
	CHAR EaName[1] ;
} FILE_FULL_EA_INFORMATION , *  PFILE_FULL_EA_INFORMATION ;

// #line 3798
typedef enum _FSINFOCLASS {
	FileFsVolumeInformation = 1,
	FileFsLabelInformation,
	FileFsSizeInformation,
	FileFsDeviceInformation,
	FileFsAttributeInformation,
	FileFsControlInformation,
	FileFsFullSizeInformation,
	FileFsObjectIdInformation,
	FileFsMaximumInformation
} FS_INFORMATION_CLASS , *  PFS_INFORMATION_CLASS ;

typedef struct _FILE_FS_DEVICE_INFORMATION {
	ULONG DeviceType ;
	ULONG Characteristics ;
} FILE_FS_DEVICE_INFORMATION , *  PFILE_FS_DEVICE_INFORMATION ;

// #line 3820
typedef union _FILE_SEGMENT_ELEMENT {
	PVOID64 Buffer ;
	ULONGLONG Alignment ;
} FILE_SEGMENT_ELEMENT , *  PFILE_SEGMENT_ELEMENT ;

// #line 3829
typedef enum _INTERFACE_TYPE {
	InterfaceTypeUndefined = - 1,
	Internal,
	Isa,
	Eisa,
	MicroChannel,
	TurboChannel,
	PCIBus,
	VMEBus,
	NuBus,
	PCMCIABus,
	CBus,
	MPIBus,
	MPSABus,
	ProcessorInternal,
	InternalPowerBus,
	PNPISABus,
	PNPBus,
	MaximumInterfaceType
} INTERFACE_TYPE , *  PINTERFACE_TYPE ;

// #line 3854
typedef enum _DMA_WIDTH {
	Width8Bits,
	Width16Bits,
	Width32Bits,
	MaximumDmaWidth
} DMA_WIDTH , *  PDMA_WIDTH ;

// #line 3865
typedef enum _DMA_SPEED {
	Compatible,
	TypeA,
	TypeB,
	TypeC,
	TypeF,
	MaximumDmaSpeed
} DMA_SPEED , *  PDMA_SPEED ;

// #line 3879
typedef void ( *  PINTERFACE_REFERENCE )(PVOID Context ) ;

// #line 3880
typedef void ( *  PINTERFACE_DEREFERENCE )(PVOID Context ) ;

// #line 3888
typedef enum _BUS_DATA_TYPE {
	ConfigurationSpaceUndefined = - 1,
	Cmos,
	EisaConfiguration,
	Pos,
	CbusConfiguration,
	PCIConfiguration,
	VMEConfiguration,
	NuBusConfiguration,
	PCMCIAConfiguration,
	MPIConfiguration,
	MPSAConfiguration,
	PNPISAConfiguration,
	SgiInternalConfiguration,
	MaximumBusDataType
} BUS_DATA_TYPE , *  PBUS_DATA_TYPE ;

// #line 3910
typedef struct _IO_ERROR_LOG_PACKET {
	UCHAR MajorFunctionCode ;
	UCHAR RetryCount ;
	USHORT DumpDataSize ;
	USHORT NumberOfStrings ;
	USHORT StringOffset ;
	USHORT EventCategory ;
	NTSTATUS ErrorCode ;
	ULONG UniqueErrorValue ;
	NTSTATUS FinalStatus ;
	ULONG SequenceNumber ;
	ULONG IoControlCode ;
	LARGE_INTEGER DeviceOffset ;
	ULONG DumpData[1] ;
} IO_ERROR_LOG_PACKET , *  PIO_ERROR_LOG_PACKET ;

// #line 3931
typedef struct _IO_ERROR_LOG_MESSAGE {
	USHORT Type ;
	USHORT Size ;
	USHORT DriverNameLength ;
	LARGE_INTEGER TimeStamp ;
	ULONG DriverNameOffset ;
	IO_ERROR_LOG_PACKET EntryData ;
} IO_ERROR_LOG_MESSAGE , *  PIO_ERROR_LOG_MESSAGE ;

// #line 4074
typedef struct _KEY_BASIC_INFORMATION {
	LARGE_INTEGER LastWriteTime ;
	ULONG TitleIndex ;
	ULONG NameLength ;
	WCHAR Name[1] ;
} KEY_BASIC_INFORMATION , *  PKEY_BASIC_INFORMATION ;

typedef struct _KEY_NODE_INFORMATION {
	LARGE_INTEGER LastWriteTime ;
	ULONG TitleIndex ;
	ULONG ClassOffset ;
	ULONG ClassLength ;
	ULONG NameLength ;
	WCHAR Name[1] ;
} KEY_NODE_INFORMATION , *  PKEY_NODE_INFORMATION ;

// #line 4091
typedef struct _KEY_FULL_INFORMATION {
	LARGE_INTEGER LastWriteTime ;
	ULONG TitleIndex ;
	ULONG ClassOffset ;
	ULONG ClassLength ;
	ULONG SubKeys ;
	ULONG MaxNameLen ;
	ULONG MaxClassLen ;
	ULONG Values ;
	ULONG MaxValueNameLen ;
	ULONG MaxValueDataLen ;
	WCHAR Class[1] ;
} KEY_FULL_INFORMATION , *  PKEY_FULL_INFORMATION ;

// #line 4106
typedef struct _KEY_NAME_INFORMATION {
	ULONG NameLength ;
	WCHAR Name[1] ;
} KEY_NAME_INFORMATION , *  PKEY_NAME_INFORMATION ;

// #line 4112
typedef enum _KEY_INFORMATION_CLASS {
	KeyBasicInformation,
	KeyNodeInformation,
	KeyFullInformation,
	KeyNameInformation
} KEY_INFORMATION_CLASS ;

// #line 4122
typedef struct _KEY_WRITE_TIME_INFORMATION {
	LARGE_INTEGER LastWriteTime ;
} KEY_WRITE_TIME_INFORMATION , *  PKEY_WRITE_TIME_INFORMATION ;

typedef enum _KEY_SET_INFORMATION_CLASS {
	KeyWriteTimeInformation
} KEY_SET_INFORMATION_CLASS ;

// #line 4134
typedef struct _KEY_VALUE_BASIC_INFORMATION {
	ULONG TitleIndex ;
	ULONG Type ;
	ULONG NameLength ;
	WCHAR Name[1] ;
} KEY_VALUE_BASIC_INFORMATION , *  PKEY_VALUE_BASIC_INFORMATION ;

typedef struct _KEY_VALUE_FULL_INFORMATION {
	ULONG TitleIndex ;
	ULONG Type ;
	ULONG DataOffset ;
	ULONG DataLength ;
	ULONG NameLength ;
	WCHAR Name[1] ;
} KEY_VALUE_FULL_INFORMATION , *  PKEY_VALUE_FULL_INFORMATION ;

// #line 4151
typedef struct _KEY_VALUE_PARTIAL_INFORMATION {
	ULONG TitleIndex ;
	ULONG Type ;
	ULONG DataLength ;
	UCHAR Data[1] ;
} KEY_VALUE_PARTIAL_INFORMATION , *  PKEY_VALUE_PARTIAL_INFORMATION ;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 {
	ULONG Type ;
	ULONG DataLength ;
	UCHAR Data[1] ;
} KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 , * 
	PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64 ;

// #line 4164
typedef struct _KEY_VALUE_ENTRY {
	PUNICODE_STRING ValueName ;
	ULONG DataLength ;
	ULONG DataOffset ;
	ULONG Type ;
} KEY_VALUE_ENTRY , *  PKEY_VALUE_ENTRY ;

typedef enum _KEY_VALUE_INFORMATION_CLASS {
	KeyValueBasicInformation,
	KeyValueFullInformation,
	KeyValuePartialInformation,
	KeyValueFullInformationAlign64,
	KeyValuePartialInformationAlign64
} KEY_VALUE_INFORMATION_CLASS ;

// #line 4210
typedef struct _OBJECT_NAME_INFORMATION {
	UNICODE_STRING Name ;
} OBJECT_NAME_INFORMATION , *  POBJECT_NAME_INFORMATION ;

// #line 4221
typedef enum _SECTION_INHERIT {
	ViewShare /* = 1 */,
	ViewUnmap /* = 2 */
} SECTION_INHERIT ;

// #line 4294
typedef struct _CLIENT_ID {
	HANDLE UniqueProcess ;
	HANDLE UniqueThread ;
} CLIENT_ID ;

// #line 4298
typedef CLIENT_ID *  PCLIENT_ID ;

// #line 4315
typedef struct _NT_TIB {
	struct _EXCEPTION_REGISTRATION_RECORD *  ExceptionList ;
	PVOID StackBase ;
	PVOID StackLimit ;
	PVOID SubSystemTib ;
	union  {
		PVOID FiberData ;
		ULONG Version ;
	}  ;
	PVOID ArbitraryUserPointer ;
	struct _NT_TIB *  Self ;
} NT_TIB ;

// #line 4327
typedef NT_TIB *  PNT_TIB ;

// #line 4332
typedef enum _PROCESSINFOCLASS {
	ProcessBasicInformation,
	ProcessQuotaLimits,
	ProcessIoCounters,
	ProcessVmCounters,
	ProcessTimes,
	ProcessBasePriority,
	ProcessRaisePriority,
	ProcessDebugPort,
	ProcessExceptionPort,
	ProcessAccessToken,
	ProcessLdtInformation,
	ProcessLdtSize,
	ProcessDefaultHardErrorMode,
	ProcessIoPortHandlers,
	ProcessPooledUsageAndLimits,
	ProcessWorkingSetWatch,
	ProcessUserModeIOPL,
	ProcessEnableAlignmentFaultFixup,
	ProcessPriorityClass,
	ProcessWx86Information,
	ProcessHandleCount,
	ProcessAffinityMask,
	ProcessPriorityBoost,
	ProcessDeviceMap,
	ProcessSessionInformation,
	ProcessForegroundInformation,
	ProcessWow64Information,
	MaxProcessInfoClass
} PROCESSINFOCLASS ;

// #line 4366
typedef enum _THREADINFOCLASS {
	ThreadBasicInformation,
	ThreadTimes,
	ThreadPriority,
	ThreadBasePriority,
	ThreadAffinityMask,
	ThreadImpersonationToken,
	ThreadDescriptorTableEntry,
	ThreadEnableAlignmentFaultFixup,
	ThreadEventPair_Reusable,
	ThreadQuerySetWin32StartAddress,
	ThreadZeroTlsCell,
	ThreadPerformanceCount,
	ThreadAmILastThread,
	ThreadIdealProcessor,
	ThreadPriorityBoost,
	ThreadSetTlsArrayAddress,
	ThreadIsIoPending,
	ThreadHideFromDebugger,
	MaxThreadInfoClass
} THREADINFOCLASS ;

// #line 4395
typedef struct _PROCESS_WS_WATCH_INFORMATION {
	PVOID FaultingPc ;
	PVOID FaultingVa ;
} PROCESS_WS_WATCH_INFORMATION , *  PPROCESS_WS_WATCH_INFORMATION ;

// #line 4405
typedef struct _PROCESS_BASIC_INFORMATION {
	NTSTATUS ExitStatus ;
	PPEB PebBaseAddress ;
	ULONG_PTR AffinityMask ;
	KPRIORITY BasePriority ;
	ULONG_PTR UniqueProcessId ;
	ULONG_PTR InheritedFromUniqueProcessId ;
} PROCESS_BASIC_INFORMATION ;

// #line 4413
typedef PROCESS_BASIC_INFORMATION *  PPROCESS_BASIC_INFORMATION ;

// #line 4422
typedef struct _PROCESS_DEVICEMAP_INFORMATION {
	union  {
		struct  {
			HANDLE DirectoryHandle ;
		} Set ;
		struct  {
			ULONG DriveMap ;
			UCHAR DriveType[32] ;
		} Query ;
	}  ;
} PROCESS_DEVICEMAP_INFORMATION , *  PPROCESS_DEVICEMAP_INFORMATION ;

// #line 4440
typedef struct _PROCESS_SESSION_INFORMATION {
	ULONG SessionId ;
} PROCESS_SESSION_INFORMATION , *  PPROCESS_SESSION_INFORMATION ;

// #line 4454
typedef struct _QUOTA_LIMITS {
	SIZE_T PagedPoolLimit ;
	SIZE_T NonPagedPoolLimit ;
	SIZE_T MinimumWorkingSetSize ;
	SIZE_T MaximumWorkingSetSize ;
	SIZE_T PagefileLimit ;
	LARGE_INTEGER TimeLimit ;
} QUOTA_LIMITS ;

// #line 4462
typedef QUOTA_LIMITS *  PQUOTA_LIMITS ;

// #line 4472
typedef struct _IO_COUNTERS {
	ULONGLONG ReadOperationCount ;
	ULONGLONG WriteOperationCount ;
	ULONGLONG OtherOperationCount ;
	ULONGLONG ReadTransferCount ;
	ULONGLONG WriteTransferCount ;
	ULONGLONG OtherTransferCount ;
} IO_COUNTERS ;

// #line 4480
typedef IO_COUNTERS *  PIO_COUNTERS ;

// #line 4488
typedef struct _VM_COUNTERS {
	SIZE_T PeakVirtualSize ;
	SIZE_T VirtualSize ;
	ULONG PageFaultCount ;
	SIZE_T PeakWorkingSetSize ;
	SIZE_T WorkingSetSize ;
	SIZE_T QuotaPeakPagedPoolUsage ;
	SIZE_T QuotaPagedPoolUsage ;
	SIZE_T QuotaPeakNonPagedPoolUsage ;
	SIZE_T QuotaNonPagedPoolUsage ;
	SIZE_T PagefileUsage ;
	SIZE_T PeakPagefileUsage ;
} VM_COUNTERS ;

// #line 4501
typedef VM_COUNTERS *  PVM_COUNTERS ;

// #line 4508
typedef struct _POOLED_USAGE_AND_LIMITS {
	SIZE_T PeakPagedPoolUsage ;
	SIZE_T PagedPoolUsage ;
	SIZE_T PagedPoolLimit ;
	SIZE_T PeakNonPagedPoolUsage ;
	SIZE_T NonPagedPoolUsage ;
	SIZE_T NonPagedPoolLimit ;
	SIZE_T PeakPagefileUsage ;
	SIZE_T PagefileUsage ;
	SIZE_T PagefileLimit ;
} POOLED_USAGE_AND_LIMITS ;

// #line 4519
typedef POOLED_USAGE_AND_LIMITS *  PPOOLED_USAGE_AND_LIMITS ;

// #line 4528
typedef struct _PROCESS_ACCESS_TOKEN {
	HANDLE Token ;
	HANDLE Thread ;
} PROCESS_ACCESS_TOKEN , *  PPROCESS_ACCESS_TOKEN ;

// #line 4555
typedef struct _KERNEL_USER_TIMES {
	LARGE_INTEGER CreateTime ;
	LARGE_INTEGER ExitTime ;
	LARGE_INTEGER KernelTime ;
	LARGE_INTEGER UserTime ;
} KERNEL_USER_TIMES ;

// #line 4561
typedef KERNEL_USER_TIMES *  PKERNEL_USER_TIMES ;

// #line 4562
// #line 4572
// #line 4587
typedef enum _SYSTEM_POWER_STATE {
	PowerSystemUnspecified /* = 0 */,
	PowerSystemWorking,
	PowerSystemSleeping1,
	PowerSystemSleeping2,
	PowerSystemSleeping3,
	PowerSystemHibernate,
	PowerSystemShutdown,
	PowerSystemMaximum
} SYSTEM_POWER_STATE , *  PSYSTEM_POWER_STATE ;

typedef enum  {
	PowerActionNone /* = 0 */,
	PowerActionReserved,
	PowerActionSleep,
	PowerActionHibernate,
	PowerActionShutdown,
	PowerActionShutdownReset,
	PowerActionShutdownOff,
	PowerActionWarmEject
} POWER_ACTION , *  PPOWER_ACTION ;

typedef enum _DEVICE_POWER_STATE {
	PowerDeviceUnspecified /* = 0 */,
	PowerDeviceD0,
	PowerDeviceD1,
	PowerDeviceD2,
	PowerDeviceD3,
	PowerDeviceMaximum
} DEVICE_POWER_STATE , *  PDEVICE_POWER_STATE ;

typedef union _POWER_STATE {
	SYSTEM_POWER_STATE SystemState ;
	DEVICE_POWER_STATE DeviceState ;
} POWER_STATE , *  PPOWER_STATE ;

typedef enum _POWER_STATE_TYPE {
	SystemPowerState /* = 0 */,
	DevicePowerState
} POWER_STATE_TYPE , *  PPOWER_STATE_TYPE ;

// #line 4654
typedef ULONG EXECUTION_STATE ;

typedef enum  {
	LT_DONT_CARE,
	LT_LOWEST_LATENCY
} LATENCY_TIME ;

// #line 4663
typedef enum  {
	SystemPowerPolicyAc,
	SystemPowerPolicyDc,
	VerifySystemPolicyAc,
	VerifySystemPolicyDc,
	SystemPowerCapabilities,
	SystemBatteryState,
	SystemPowerStateHandler,
	ProcessorStateHandler,
	SystemPowerPolicyCurrent,
	AdministratorPowerPolicy,
	SystemReserveHiberFile,
	ProcessorInformation,
	SystemPowerInformation
} POWER_INFORMATION_LEVEL ;

// #line 4690
typedef ULONG PFN_COUNT ;

typedef LONG SPFN_NUMBER , *  PSPFN_NUMBER ;

// #line 4693
typedef ULONG PFN_NUMBER , *  PPFN_NUMBER ;

// #line 4719
typedef union _MCI_STATS {
	struct  {
		USHORT McaCod ;
		USHORT MsCod ;
		ULONG OtherInfo /*  : 25 */;
		ULONG Damage /*  : 1 */;
		ULONG AddressValid /*  : 1 */;
		ULONG MiscValid /*  : 1 */;
		ULONG Enabled /*  : 1 */;
		ULONG UnCorrected /*  : 1 */;
		ULONG OverFlow /*  : 1 */;
		ULONG Valid  /* : 1 */;
	} MciStats ;
	ULONGLONG QuadPart ;
} MCI_STATS , *  PMCI_STATS ;

// #line 4768
// #line 4811
// #line 4978
typedef struct _KPCR {
	NT_TIB NtTib ;
	struct _KPCR *  SelfPcr ;
	struct _KPRCB *  Prcb ;
	KIRQL Irql ;
	ULONG IRR ;
	ULONG IrrActive ;
	ULONG IDR ;
	ULONG Reserved2 ;
	struct _KIDTENTRY *  IDT ;
	struct _KGDTENTRY *  GDT ;
	struct _KTSS *  TSS ;
	USHORT MajorVersion ;
	USHORT MinorVersion ;
	KAFFINITY SetMember ;
	ULONG StallScaleFactor ;
	UCHAR DebugActive ;
	UCHAR Number ;
} KPCR ;

// #line 5006
typedef KPCR *  PKPCR ;

// #line 5012
typedef struct _KFLOATING_SAVE {
	ULONG ControlWord ;
	ULONG StatusWord ;
	ULONG ErrorOffset ;
	ULONG ErrorSelector ;
	ULONG DataOffset ;
	ULONG DataSelector ;
	ULONG Cr0NpxState ;
	ULONG Spare1 ;
} KFLOATING_SAVE , *  PKFLOATING_SAVE ;

// #line 5069
extern PVOID *  MmHighestUserAddress ;
extern PVOID *  MmSystemRangeStart ;
extern ULONG *  MmUserProbeAddress ;

// #line 5153
typedef enum _INTERLOCKED_RESULT {
	ResultNegative /* = 0x8000 & ~ 0x4000 & (0x8000 | 0x4000) */,
	ResultZero /* = ~ 0x8000 & 0x4000 & (0x8000 | 0x4000) */,
	ResultPositive /* = ~ 0x8000 & ~ 0x4000 & (0x8000 | 0x4000) */
} INTERLOCKED_RESULT ;

// #line 5197
LONG InterlockedIncrement(PLONG Addend ) ;
// #line 5204
LONG InterlockedDecrement(PLONG Addend ) ;
// #line 5211
// #line 5229
// #line 5252
// #line 5262
KIRQL KeGetCurrentIrql() ;
// #line 5280
// #line 5287
// #line 6994
typedef struct _KSYSTEM_TIME {
	ULONG LowPart ;
	LONG High1Time ;
	LONG High2Time ;
} KSYSTEM_TIME , *  PKSYSTEM_TIME ;

// #line 7014

// #pragma warning(push)

// #pragma warning(disable:4164)
// #line 7019

// #pragma function(_enable)
// #line 7020

// #pragma function(_disable)
// #line 7024

// #pragma warning(pop)
// #line 7085
typedef struct _FLOATING_SAVE_AREA {
	ULONG ControlWord ;
	ULONG StatusWord ;
	ULONG TagWord ;
	ULONG ErrorOffset ;
	ULONG ErrorSelector ;
	ULONG DataOffset ;
	ULONG DataSelector ;
	UCHAR RegisterArea[80] ;
	ULONG Cr0NpxState ;
} FLOATING_SAVE_AREA ;

typedef FLOATING_SAVE_AREA *  PFLOATING_SAVE_AREA ;

// #line 7109
typedef struct _CONTEXT {
	ULONG ContextFlags ;
	ULONG Dr0 ;
	ULONG Dr1 ;
	ULONG Dr2 ;
	ULONG Dr3 ;
	ULONG Dr6 ;
	ULONG Dr7 ;
	FLOATING_SAVE_AREA FloatSave ;
	ULONG SegGs ;
	ULONG SegFs ;
	ULONG SegEs ;
	ULONG SegDs ;
	ULONG Edi ;
	ULONG Esi ;
	ULONG Ebx ;
	ULONG Edx ;
	ULONG Ecx ;
	ULONG Eax ;
	ULONG Ebp ;
	ULONG Eip ;
	ULONG SegCs ;
	ULONG EFlags ;
	ULONG Esp ;
	ULONG SegSs ;
	UCHAR ExtendedRegisters[512] ;
} CONTEXT ;

// #line 7197
typedef CONTEXT *  PCONTEXT ;

// #line 7826
typedef void ( *  PTIMER_APC_ROUTINE )(PVOID TimerContext , ULONG TimerLowValue
	, LONG TimerHighValue ) ;

// #line 7850
typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE {
	StandardDesign,
	NEC98x86,
	EndAlternatives
} ALTERNATIVE_ARCHITECTURE_TYPE ;

// #line 7899
typedef struct _KUSER_SHARED_DATA {
	volatile ULONG TickCountLow ;
	ULONG TickCountMultiplier ;
	volatile KSYSTEM_TIME InterruptTime ;
	volatile KSYSTEM_TIME SystemTime ;
	volatile KSYSTEM_TIME TimeZoneBias ;
	USHORT ImageNumberLow ;
	USHORT ImageNumberHigh ;
	WCHAR NtSystemRoot[260] ;
	ULONG MaxStackTraceDepth ;
	ULONG CryptoExponent ;
	ULONG TimeZoneId ;
	ULONG Reserved2[8] ;
	NT_PRODUCT_TYPE NtProductType ;
	BOOLEAN ProductTypeIsValid ;
	ULONG NtMajorVersion ;
	ULONG NtMinorVersion ;
	BOOLEAN ProcessorFeatures[64] ;
	ULONG Reserved1 ;
	ULONG Reserved3 ;
	volatile ULONG TimeSlip ;
	ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture ;
	LARGE_INTEGER SystemExpirationDate ;
	ULONG SuiteMask ;
	BOOLEAN KdDebuggerEnabled ;
} KUSER_SHARED_DATA , *  PKUSER_SHARED_DATA ;

// #line 8123
typedef enum _CM_SERVICE_NODE_TYPE {
	DriverType /* = 0x00000001 */,
	FileSystemType /* = 0x00000002 */,
	Win32ServiceOwnProcess /* = 0x00000010 */,
	Win32ServiceShareProcess /* = 0x00000020 */,
	AdapterType /* = 0x00000004 */,
	RecognizerType /* = 0x00000008 */
} SERVICE_NODE_TYPE ;

typedef enum _CM_SERVICE_LOAD_TYPE {
	BootLoad /* = 0x00000000 */,
	SystemLoad /* = 0x00000001 */,
	AutoLoad /* = 0x00000002 */,
	DemandLoad /* = 0x00000003 */,
	DisableLoad /* = 0x00000004 */
} SERVICE_LOAD_TYPE ;

typedef enum _CM_ERROR_CONTROL_TYPE {
	IgnoreError /* = 0x00000000 */,
	NormalError /* = 0x00000001 */,
	SevereError /* = 0x00000002 */,
	CriticalError/*  = 0x00000003 */
} SERVICE_ERROR_TYPE ;

// #line 8172
typedef int CM_RESOURCE_TYPE ;

// #line 8198
typedef enum _CM_SHARE_DISPOSITION {
	CmResourceShareUndetermined /* = 0 */,
	CmResourceShareDeviceExclusive,
	CmResourceShareDriverExclusive,
	CmResourceShareShared
} CM_SHARE_DISPOSITION ;

// #line 8211
typedef PVOID PASSIGNED_RESOURCE ;

// #line 24 "C:/NTDDK/inc/pshpack4.h"

// #pragma warning(disable:4103)

// #pragma pack(push, 4)
// #line 8309 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
	UCHAR Type ;
	UCHAR ShareDisposition ;
	USHORT Flags ;
	union  {
		struct  {
			PHYSICAL_ADDRESS Start ;
			ULONG Length ;
		} Generic ;
		struct  {
			PHYSICAL_ADDRESS Start ;
			ULONG Length ;
		} Port ;
		struct  {
			ULONG Level ;
			ULONG Vector ;
			ULONG Affinity ;
		} Interrupt ;
		struct  {
			PHYSICAL_ADDRESS Start ;
			ULONG Length ;
		} Memory ;
		struct  {
			ULONG Channel ;
			ULONG Port ;
			ULONG Reserved1 ;
		} Dma ;
		struct  {
			ULONG Data[3] ;
		} DevicePrivate ;
		struct  {
			ULONG Start ;
			ULONG Length ;
			ULONG Reserved ;
		} BusNumber ;
		struct  {
			ULONG DataSize ;
			ULONG Reserved1 ;
			ULONG Reserved2 ;
		} DeviceSpecificData ;
	} u ;
} CM_PARTIAL_RESOURCE_DESCRIPTOR , *  PCM_PARTIAL_RESOURCE_DESCRIPTOR ;

// #line 27 "C:/NTDDK/inc/poppack.h"

// #pragma warning(disable:4103)

// #pragma pack(pop)
// #line 8419 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_PARTIAL_RESOURCE_LIST {
	USHORT Version ;
	USHORT Revision ;
	ULONG Count ;
	CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1] ;
} CM_PARTIAL_RESOURCE_LIST , *  PCM_PARTIAL_RESOURCE_LIST ;

// #line 8443
typedef struct _CM_FULL_RESOURCE_DESCRIPTOR {
	INTERFACE_TYPE InterfaceType ;
	ULONG BusNumber ;
	CM_PARTIAL_RESOURCE_LIST PartialResourceList ;
} CM_FULL_RESOURCE_DESCRIPTOR , *  PCM_FULL_RESOURCE_DESCRIPTOR ;

// #line 8454
typedef struct _CM_RESOURCE_LIST {
	ULONG Count ;
	CM_FULL_RESOURCE_DESCRIPTOR List[1] ;
} CM_RESOURCE_LIST , *  PCM_RESOURCE_LIST ;

// #line 8471
typedef struct _DEVICE_FLAGS {
	ULONG Failed  /* :1*/;
	ULONG ReadOnly  /* :1*/;
	ULONG Removable  /* :1*/;
	ULONG ConsoleIn  /* :1*/;
	ULONG ConsoleOut  /* :1*/;
	ULONG Input  /* :1*/;
	ULONG Output  /* :1*/;
} DEVICE_FLAGS , *  PDEVICE_FLAGS ;

// #line 8485
typedef struct _CM_COMPONENT_INFORMATION {
	DEVICE_FLAGS Flags ;
	ULONG Version ;
	ULONG Key ;
	ULONG AffinityMask ;
} CM_COMPONENT_INFORMATION , *  PCM_COMPONENT_INFORMATION ;

// #line 8503
typedef struct _CM_ROM_BLOCK {
	ULONG Address ;
	ULONG Size ;
} CM_ROM_BLOCK , *  PCM_ROM_BLOCK ;

// #line 24 "C:/NTDDK/inc/pshpack1.h"

// #pragma warning(disable:4103)

// #pragma pack(push, 1)
// #line 8518 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_INT13_DRIVE_PARAMETER {
	USHORT DriveSelect ;
	ULONG MaxCylinders ;
	USHORT SectorsPerTrack ;
	USHORT MaxHeads ;
	USHORT NumberDrives ;
} CM_INT13_DRIVE_PARAMETER , *  PCM_INT13_DRIVE_PARAMETER ;

// #line 8532
typedef struct _CM_MCA_POS_DATA {
	USHORT AdapterId ;
	UCHAR PosData1 ;
	UCHAR PosData2 ;
	UCHAR PosData3 ;
	UCHAR PosData4 ;
} CM_MCA_POS_DATA , *  PCM_MCA_POS_DATA ;

// #line 8544
typedef struct _EISA_MEMORY_TYPE {
	UCHAR ReadWrite  /* :1*/;
	UCHAR Cached  /* :1*/;
	UCHAR Reserved0  /* :1*/;
	UCHAR Type  /*:2*/;
	UCHAR Shared  /* :1*/;
	UCHAR Reserved1  /* :1*/;
	UCHAR MoreEntries  /* :1*/;
} EISA_MEMORY_TYPE , *  PEISA_MEMORY_TYPE ;

typedef struct _EISA_MEMORY_CONFIGURATION {
	EISA_MEMORY_TYPE ConfigurationByte ;
	UCHAR DataSize ;
	USHORT AddressLowWord ;
	UCHAR AddressHighByte ;
	USHORT MemorySize ;
} EISA_MEMORY_CONFIGURATION , *  PEISA_MEMORY_CONFIGURATION ;

// #line 8567
typedef struct _EISA_IRQ_DESCRIPTOR {
	UCHAR Interrupt  /*:4*/;
	UCHAR Reserved  /* :1*/;
	UCHAR LevelTriggered  /* :1*/;
	UCHAR Shared  /* :1*/;
	UCHAR MoreEntries  /* :1*/;
} EISA_IRQ_DESCRIPTOR , *  PEISA_IRQ_DESCRIPTOR ;

typedef struct _EISA_IRQ_CONFIGURATION {
	EISA_IRQ_DESCRIPTOR ConfigurationByte ;
	UCHAR Reserved ;
} EISA_IRQ_CONFIGURATION , *  PEISA_IRQ_CONFIGURATION ;

// #line 8585
typedef struct _DMA_CONFIGURATION_BYTE0 {
	UCHAR Channel  /*:3*/;
	UCHAR Reserved  /*:3*/;
	UCHAR Shared  /* :1*/;
	UCHAR MoreEntries  /* :1*/;
} DMA_CONFIGURATION_BYTE0 ;

typedef struct _DMA_CONFIGURATION_BYTE1 {
	UCHAR Reserved0  /*:2*/;
	UCHAR TransferSize  /*:2*/;
	UCHAR Timing  /*:2*/;
	UCHAR Reserved1  /*:2*/;
} DMA_CONFIGURATION_BYTE1 ;

typedef struct _EISA_DMA_CONFIGURATION {
	DMA_CONFIGURATION_BYTE0 ConfigurationByte0 ;
	DMA_CONFIGURATION_BYTE1 ConfigurationByte1 ;
} EISA_DMA_CONFIGURATION , *  PEISA_DMA_CONFIGURATION ;

// #line 8609
typedef struct _EISA_PORT_DESCRIPTOR {
	UCHAR NumberPorts  /*:5*/;
	UCHAR Reserved  /* :1*/;
	UCHAR Shared  /* :1*/;
	UCHAR MoreEntries  /* :1*/;
} EISA_PORT_DESCRIPTOR , *  PEISA_PORT_DESCRIPTOR ;

typedef struct _EISA_PORT_CONFIGURATION {
	EISA_PORT_DESCRIPTOR Configuration ;
	USHORT PortAddress ;
} EISA_PORT_CONFIGURATION , *  PEISA_PORT_CONFIGURATION ;

// #line 8628
typedef struct _CM_EISA_SLOT_INFORMATION {
	UCHAR ReturnCode ;
	UCHAR ReturnFlags ;
	UCHAR MajorRevision ;
	UCHAR MinorRevision ;
	USHORT Checksum ;
	UCHAR NumberFunctions ;
	UCHAR FunctionInformation ;
	ULONG CompressedId ;
} CM_EISA_SLOT_INFORMATION , *  PCM_EISA_SLOT_INFORMATION ;

// #line 8644
typedef struct _CM_EISA_FUNCTION_INFORMATION {
	ULONG CompressedId ;
	UCHAR IdSlotFlags1 ;
	UCHAR IdSlotFlags2 ;
	UCHAR MinorRevision ;
	UCHAR MajorRevision ;
	UCHAR Selections[26] ;
	UCHAR FunctionFlags ;
	UCHAR TypeString[80] ;
	EISA_MEMORY_CONFIGURATION EisaMemory[9] ;
	EISA_IRQ_CONFIGURATION EisaIrq[7] ;
	EISA_DMA_CONFIGURATION EisaDma[4] ;
	EISA_PORT_CONFIGURATION EisaPort[20] ;
	UCHAR InitializationData[60] ;
} CM_EISA_FUNCTION_INFORMATION , *  PCM_EISA_FUNCTION_INFORMATION ;

// #line 8678
typedef struct _CM_PNP_BIOS_DEVICE_NODE {
	USHORT Size ;
	UCHAR Node ;
	ULONG ProductId ;
	UCHAR DeviceType[3] ;
	USHORT DeviceAttributes ;
} CM_PNP_BIOS_DEVICE_NODE , *  PCM_PNP_BIOS_DEVICE_NODE ;

// #line 8692
typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK {
	UCHAR Signature[4] ;
	UCHAR Revision ;
	UCHAR Length ;
	USHORT ControlField ;
	UCHAR Checksum ;
	ULONG EventFlagAddress ;
	USHORT RealModeEntryOffset ;
	USHORT RealModeEntrySegment ;
	USHORT ProtectedModeEntryOffset ;
	ULONG ProtectedModeCodeBaseAddress ;
	ULONG OemDeviceId ;
	USHORT RealModeDataBaseAddress ;
	ULONG ProtectedModeDataBaseAddress ;
} CM_PNP_BIOS_INSTALLATION_CHECK , *  PCM_PNP_BIOS_INSTALLATION_CHECK ;

// #line 27 "C:/NTDDK/inc/poppack.h"

// #pragma warning(disable:4103)

// #pragma pack(pop)
// #line 8761 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _CM_SCSI_DEVICE_DATA {
	USHORT Version ;
	USHORT Revision ;
	UCHAR HostIdentifier ;
} CM_SCSI_DEVICE_DATA , *  PCM_SCSI_DEVICE_DATA ;

// #line 8775
typedef struct _CM_VIDEO_DEVICE_DATA {
	USHORT Version ;
	USHORT Revision ;
	ULONG VideoClock ;
} CM_VIDEO_DEVICE_DATA , *  PCM_VIDEO_DEVICE_DATA ;

// #line 8785
typedef struct _CM_SONIC_DEVICE_DATA {
	USHORT Version ;
	USHORT Revision ;
	USHORT DataConfigurationRegister ;
	UCHAR EthernetAddress[8] ;
} CM_SONIC_DEVICE_DATA , *  PCM_SONIC_DEVICE_DATA ;

// #line 8796
typedef struct _CM_SERIAL_DEVICE_DATA {
	USHORT Version ;
	USHORT Revision ;
	ULONG BaudClock ;
} CM_SERIAL_DEVICE_DATA , *  PCM_SERIAL_DEVICE_DATA ;

// #line 8810
typedef struct _CM_MONITOR_DEVICE_DATA {
	USHORT Version ;
	USHORT Revision ;
	USHORT HorizontalScreenSize ;
	USHORT VerticalScreenSize ;
	USHORT HorizontalResolution ;
	USHORT VerticalResolution ;
	USHORT HorizontalDisplayTimeLow ;
	USHORT HorizontalDisplayTime ;
	USHORT HorizontalDisplayTimeHigh ;
	USHORT HorizontalBackPorchLow ;
	USHORT HorizontalBackPorch ;
	USHORT HorizontalBackPorchHigh ;
	USHORT HorizontalFrontPorchLow ;
	USHORT HorizontalFrontPorch ;
	USHORT HorizontalFrontPorchHigh ;
	USHORT HorizontalSyncLow ;
	USHORT HorizontalSync ;
	USHORT HorizontalSyncHigh ;
	USHORT VerticalBackPorchLow ;
	USHORT VerticalBackPorch ;
	USHORT VerticalBackPorchHigh ;
	USHORT VerticalFrontPorchLow ;
	USHORT VerticalFrontPorch ;
	USHORT VerticalFrontPorchHigh ;
	USHORT VerticalSyncLow ;
	USHORT VerticalSync ;
	USHORT VerticalSyncHigh ;
} CM_MONITOR_DEVICE_DATA , *  PCM_MONITOR_DEVICE_DATA ;

// #line 8844
typedef struct _CM_FLOPPY_DEVICE_DATA {
	USHORT Version ;
	USHORT Revision ;
	CHAR Size[8] ;
	ULONG MaxDensity ;
	ULONG MountDensity ;
	UCHAR StepRateHeadUnloadTime ;
	UCHAR HeadLoadTime ;
	UCHAR MotorOffTime ;
	UCHAR SectorLengthCode ;
	UCHAR SectorPerTrack ;
	UCHAR ReadWriteGapLength ;
	UCHAR DataTransferLength ;
	UCHAR FormatGapLength ;
	UCHAR FormatFillCharacter ;
	UCHAR HeadSettleTime ;
	UCHAR MotorSettleTime ;
	UCHAR MaximumTrackValue ;
	UCHAR DataTransferRate ;
} CM_FLOPPY_DEVICE_DATA , *  PCM_FLOPPY_DEVICE_DATA ;

// #line 8881
typedef struct _CM_KEYBOARD_DEVICE_DATA {
	USHORT Version ;
	USHORT Revision ;
	UCHAR Type ;
	UCHAR Subtype ;
	USHORT KeyboardFlags ;
} CM_KEYBOARD_DEVICE_DATA , *  PCM_KEYBOARD_DEVICE_DATA ;

// #line 8893
typedef struct _CM_DISK_GEOMETRY_DEVICE_DATA {
	ULONG BytesPerSector ;
	ULONG NumberOfCylinders ;
	ULONG SectorsPerTrack ;
	ULONG NumberOfHeads ;
} CM_DISK_GEOMETRY_DEVICE_DATA , *  PCM_DISK_GEOMETRY_DEVICE_DATA ;

// #line 8905
typedef struct _CM_PCCARD_DEVICE_DATA {
	UCHAR Flags ;
	UCHAR ErrorCode ;
	USHORT Reserved ;
	ULONG BusData ;
	ULONG DeviceId ;
	ULONG LegacyBaseAddress ;
	UCHAR IRQMap[16] ;
} CM_PCCARD_DEVICE_DATA , *  PCM_PCCARD_DEVICE_DATA ;

// #line 8944
typedef struct _IO_RESOURCE_DESCRIPTOR {
	UCHAR Option ;
	UCHAR Type ;
	UCHAR ShareDisposition ;
	UCHAR Spare1 ;
	USHORT Flags ;
	USHORT Spare2 ;
	union  {
		struct  {
			ULONG Length ;
			ULONG Alignment ;
			PHYSICAL_ADDRESS MinimumAddress ;
			PHYSICAL_ADDRESS MaximumAddress ;
		} Port ;
		struct  {
			ULONG Length ;
			ULONG Alignment ;
			PHYSICAL_ADDRESS MinimumAddress ;
			PHYSICAL_ADDRESS MaximumAddress ;
		} Memory ;
		struct  {
			ULONG MinimumVector ;
			ULONG MaximumVector ;
		} Interrupt ;
		struct  {
			ULONG MinimumChannel ;
			ULONG MaximumChannel ;
		} Dma ;
		struct  {
			ULONG Length ;
			ULONG Alignment ;
			PHYSICAL_ADDRESS MinimumAddress ;
			PHYSICAL_ADDRESS MaximumAddress ;
		} Generic ;
		struct  {
			ULONG Data[3] ;
		} DevicePrivate ;
		struct  {
			ULONG Length ;
			ULONG MinBusNumber ;
			ULONG MaxBusNumber ;
			ULONG Reserved ;
		} BusNumber ;
		struct  {
			PASSIGNED_RESOURCE AssignedResource ;
		} AssignedResource ;
		struct  {
			UCHAR Type ;
			UCHAR Reserved[3] ;
			PASSIGNED_RESOURCE AssignedResource ;
			PHYSICAL_ADDRESS Transformation ;
		} SubAllocateFrom ;
		struct  {
			ULONG Priority ;
			ULONG Reserved1 ;
			ULONG Reserved2 ;
		} ConfigData ;
	} u ;
} IO_RESOURCE_DESCRIPTOR , *  PIO_RESOURCE_DESCRIPTOR ;

// #line 9027
typedef struct _IO_RESOURCE_LIST {
	USHORT Version ;
	USHORT Revision ;
	ULONG Count ;
	IO_RESOURCE_DESCRIPTOR Descriptors[1] ;
} IO_RESOURCE_LIST , *  PIO_RESOURCE_LIST ;

// #line 9036
typedef struct _IO_RESOURCE_REQUIREMENTS_LIST {
	ULONG ListSize ;
	INTERFACE_TYPE InterfaceType ;
	ULONG BusNumber ;
	ULONG SlotNumber ;
	ULONG Reserved[3] ;
	ULONG AlternativeLists ;
	IO_RESOURCE_LIST List[1] ;
} IO_RESOURCE_REQUIREMENTS_LIST , *  PIO_RESOURCE_REQUIREMENTS_LIST ;

// #line 9065
typedef struct _EXCEPTION_RECORD {
	NTSTATUS ExceptionCode ;
	ULONG ExceptionFlags ;
	struct _EXCEPTION_RECORD *  ExceptionRecord ;
	PVOID ExceptionAddress ;
	ULONG NumberParameters ;
	ULONG_PTR ExceptionInformation[15] ;
} EXCEPTION_RECORD ;

typedef EXCEPTION_RECORD *  PEXCEPTION_RECORD ;

typedef struct _EXCEPTION_RECORD32 {
	NTSTATUS ExceptionCode ;
	ULONG ExceptionFlags ;
	ULONG ExceptionRecord ;
	ULONG ExceptionAddress ;
	ULONG NumberParameters ;
	ULONG ExceptionInformation[15] ;
} EXCEPTION_RECORD32 , *  PEXCEPTION_RECORD32 ;

typedef struct _EXCEPTION_RECORD64 {
	NTSTATUS ExceptionCode ;
	ULONG ExceptionFlags ;
	ULONG64 ExceptionRecord ;
	ULONG64 ExceptionAddress ;
	ULONG NumberParameters ;
	ULONG __unusedAlignment ;
	ULONG64 ExceptionInformation[15] ;
} EXCEPTION_RECORD64 , *  PEXCEPTION_RECORD64 ;

// #line 9099
typedef struct _EXCEPTION_POINTERS {
	PEXCEPTION_RECORD ExceptionRecord ;
	PCONTEXT ContextRecord ;
} EXCEPTION_POINTERS , *  PEXCEPTION_POINTERS ;

// #line 9111
typedef enum _CONFIGURATION_TYPE {
	ArcSystem,
	CentralProcessor,
	FloatingPointProcessor,
	PrimaryIcache,
	PrimaryDcache,
	SecondaryIcache,
	SecondaryDcache,
	SecondaryCache,
	EisaAdapter,
	TcAdapter,
	ScsiAdapter,
	DtiAdapter,
	MultiFunctionAdapter,
	DiskController,
	TapeController,
	CdromController,
	WormController,
	SerialController,
	NetworkController,
	DisplayController,
	ParallelController,
	PointerController,
	KeyboardController,
	AudioController,
	OtherController,
	DiskPeripheral,
	FloppyDiskPeripheral,
	TapePeripheral,
	ModemPeripheral,
	MonitorPeripheral,
	PrinterPeripheral,
	PointerPeripheral,
	KeyboardPeripheral,
	TerminalPeripheral,
	OtherPeripheral,
	LinePeripheral,
	NetworkPeripheral,
	SystemMemory,
	DockingInformation,
	RealModeIrqRoutingTable,
	MaximumType
} CONFIGURATION_TYPE , *  PCONFIGURATION_TYPE ;

// #line 9161
typedef enum _KINTERRUPT_MODE {
	LevelSensitive,
	Latched
} KINTERRUPT_MODE ;

// #line 9170
typedef enum _KWAIT_REASON {
	Executive,
	FreePage,
	PageIn,
	PoolAllocation,
	DelayExecution,
	Suspended,
	UserRequest,
	WrExecutive,
	WrFreePage,
	WrPageIn,
	WrPoolAllocation,
	WrDelayExecution,
	WrSuspended,
	WrUserRequest,
	WrEventPair,
	WrQueue,
	WrLpcReceive,
	WrLpcReply,
	WrVirtualMemory,
	WrPageOut,
	WrRendezvous,
	Spare2,
	Spare3,
	Spare4,
	Spare5,
	Spare6,
	WrKernel,
	MaximumWaitReason
} KWAIT_REASON ;

// #line 9207
typedef struct _DISPATCHER_HEADER {
	UCHAR Type ;
	UCHAR Absolute ;
	UCHAR Size ;
	UCHAR Inserted ;
	LONG SignalState ;
	LIST_ENTRY WaitListHead ;
} DISPATCHER_HEADER ;

// #line 9217
typedef struct _KWAIT_BLOCK {
	LIST_ENTRY WaitListEntry ;
	struct _KTHREAD *  Thread ;
	PVOID Object ;
	struct _KWAIT_BLOCK *  NextWaitBlock ;
	USHORT WaitKey ;
	USHORT WaitType ;
} KWAIT_BLOCK , *  PKWAIT_BLOCK , *  PRKWAIT_BLOCK ;

// #line 9230
typedef void ( *  PKSTART_ROUTINE )(PVOID StartContext ) ;

// #line 9244
typedef struct _KDEVICE_QUEUE {
	CSHORT Type ;
	CSHORT Size ;
	LIST_ENTRY DeviceListHead ;
	KSPIN_LOCK Lock ;
	BOOLEAN Busy ;
} KDEVICE_QUEUE , *  PKDEVICE_QUEUE , *  PRKDEVICE_QUEUE ;

typedef struct _KDEVICE_QUEUE_ENTRY {
	LIST_ENTRY DeviceListEntry ;
	ULONG SortKey ;
	BOOLEAN Inserted ;
} KDEVICE_QUEUE_ENTRY , *  PKDEVICE_QUEUE_ENTRY , *  PRKDEVICE_QUEUE_ENTRY ;

// #line 9263
typedef struct _KEVENT {
	DISPATCHER_HEADER Header ;
} KEVENT , *  PKEVENT , *  PRKEVENT ;

// #line 9271
typedef BOOLEAN ( *  PKSERVICE_ROUTINE )(struct _KINTERRUPT *  Interrupt , PVOID
	ServiceContext ) ;

// #line 9281
typedef struct _KMUTANT {
	DISPATCHER_HEADER Header ;
	LIST_ENTRY MutantListEntry ;
	struct _KTHREAD *  OwnerThread ;
	BOOLEAN Abandoned ;
	UCHAR ApcDisable ;
} KMUTANT , *  PKMUTANT , *  PRKMUTANT , KMUTEX , *  PKMUTEX , *  PRKMUTEX ;

// #line 9294
typedef struct _KSEMAPHORE {
	DISPATCHER_HEADER Header ;
	LONG Limit ;
} KSEMAPHORE , *  PKSEMAPHORE , *  PRKSEMAPHORE ;

// #line 9304
typedef struct _KTIMER {
	DISPATCHER_HEADER Header ;
	ULARGE_INTEGER DueTime ;
	LIST_ENTRY TimerListEntry ;
	struct _KDPC *  Dpc ;
	LONG Period ;
} KTIMER , *  PKTIMER , *  PRKTIMER ;

// #line 9316
// #line 9324
// #line 9332
// #line 9347
// #line 9365
// #line 9380
// #line 9386
// #line 9393
// #line 9400
// #line 9415
void KeInitializeEvent(PRKEVENT Event , EVENT_TYPE Type ,
		       BOOLEAN State ) ;
// #line 9423
// #line 9429
// #line 9437
// #line 9445
// #line 9451
// #line 9463
// #line 9472
// #line 9483
void KeInitializeSemaphore(PRKSEMAPHORE Semaphore , LONG Count , LONG Limit ) ;
// #line 9491
// #line 9497
// #line 9506
// #line 9514
// #line 9520
// #line 9527
// #line 9539
// #line 9636
// #line 9681
NTSTATUS KeWaitForSingleObject(PVOID Object , KWAIT_REASON WaitReason ,
			       KPROCESSOR_MODE WaitMode , BOOLEAN Alertable ,
			       PLARGE_INTEGER Timeout ) ;
// #line 9711
void   KeInitializeSpinLock(PKSPIN_LOCK SpinLock );	
// #line 9899
typedef enum _KBUGCHECK_BUFFER_DUMP_STATE {
	BufferEmpty,
	BufferInserted,
	BufferStarted,
	BufferFinished,
	BufferIncomplete
} KBUGCHECK_BUFFER_DUMP_STATE ;

typedef void ( *  PKBUGCHECK_CALLBACK_ROUTINE )(PVOID Buffer , ULONG Length ) ;

// #line 9914
typedef struct _KBUGCHECK_CALLBACK_RECORD {
	LIST_ENTRY Entry ;
	PKBUGCHECK_CALLBACK_ROUTINE CallbackRoutine ;
	PVOID Buffer ;
	ULONG Length ;
	PUCHAR Component ;
	ULONG_PTR Checksum ;
	UCHAR State ;
} KBUGCHECK_CALLBACK_RECORD , *  PKBUGCHECK_CALLBACK_RECORD ;

// #line 9934
// #line 9950
// #line 9956
// #line 9966
// #line 9973
// #line 9979
// #line 9985
// #line 9992

// #line 10002
typedef void (  *  PSWAP_CONTEXT_NOTIFY_ROUTINE )(HANDLE OldThreadId ,
	HANDLE NewThreadId ) ;

// #line 10009
// #line 10020
typedef LOGICAL (  *  PTHREAD_SELECT_NOTIFY_ROUTINE )(HANDLE ThreadId )
	;

// #line 10026
// #line 10037
typedef void (  *  PTIME_UPDATE_NOTIFY_ROUTINE )(HANDLE ThreadId ,
	KPROCESSOR_MODE Mode ) ;
// #line 10044
// #line 10051
extern volatile KSYSTEM_TIME KeTickCount ;

typedef enum _MEMORY_CACHING_TYPE_ORIG {
	MmFrameBufferCached /* = 2 */
} MEMORY_CACHING_TYPE_ORIG ;

typedef enum _MEMORY_CACHING_TYPE {
	MmNonCached /* = 0 */,
	MmCached /* = 1 */,
	MmWriteCombined /* = MmFrameBufferCached */,
	MmHardwareCoherentCached,
	MmNonCachedUnordered,
	MmUSWCCached,
	MmMaximumCacheType
} MEMORY_CACHING_TYPE ;

// #line 10074
extern PBOOLEAN KdDebuggerNotPresent ;
extern PBOOLEAN KdDebuggerEnabled ;

// #line 10087
typedef struct _DBGKD_DEBUG_DATA_HEADER64 *  PDBGKD_DEBUG_DATA_HEADER64 ;

// #line 10096
// #line 10101
// #line 10106
// #line 10115
typedef enum _POOL_TYPE {
	NonPagedPool,
	PagedPool,
	NonPagedPoolMustSucceed,
	DontUseThisType,
	NonPagedPoolCacheAligned,
	PagedPoolCacheAligned,
	NonPagedPoolCacheAlignedMustS,
	MaxPoolType,
	NonPagedPoolSession /* = 32 */,
	PagedPoolSession /* = NonPagedPoolSession + 1 */,
	NonPagedPoolMustSucceedSession /* = PagedPoolSession + 1 */,
	DontUseThisTypeSession /* = NonPagedPoolMustSucceedSession + 1 */,
	NonPagedPoolCacheAlignedSession /* = DontUseThisTypeSession + 1 */,
	PagedPoolCacheAlignedSession /* = NonPagedPoolCacheAlignedSession + 1 */,
	NonPagedPoolCacheAlignedMustSSession /* = PagedPoolCacheAlignedSession + 1 */
} POOL_TYPE ;

// #line 10145
PVOID ExAllocatePool(POOL_TYPE PoolType , SIZE_T NumberOfBytes ) ;
// #line 10152
PVOID ExAllocatePoolWithTag(POOL_TYPE PoolType , SIZE_T NumberOfBytes , ULONG Tag ) ;
typedef enum _EX_POOL_PRIORITY {
	LowPoolPriority,
	LowPoolPrioritySpecialPoolOverrun /* = 8 */,
	LowPoolPrioritySpecialPoolUnderrun /* = 9 */,
	NormalPoolPriority /* = 16 */,
	NormalPoolPrioritySpecialPoolOverrun /* = 24 */,
	NormalPoolPrioritySpecialPoolUnderrun /* = 25 */,
	HighPoolPriority /* = 32 */,
	HighPoolPrioritySpecialPoolOverrun /* = 40 */,
	HighPoolPrioritySpecialPoolUnderrun /* = 41 */
} EX_POOL_PRIORITY ;

// #line 10208
void   ExFreePool(PVOID P ) ;

// #line 10247
typedef struct _FAST_MUTEX {
	LONG Count ;
	PKTHREAD Owner ;
	ULONG Contention ;
	KEVENT Event ;
	ULONG OldIrql ;
} FAST_MUTEX , *  PFAST_MUTEX ;

// #line 10272
// #line 10574
typedef PVOID ( *  PALLOCATE_FUNCTION )(POOL_TYPE PoolType , SIZE_T NumberOfBytes , ULONG Tag ) ;
// #line 10582
typedef void ( *  PFREE_FUNCTION )(PVOID Buffer ) ;

// #line 10588
typedef struct _GENERAL_LOOKASIDE {
	SLIST_HEADER ListHead ;
	USHORT Depth ;
	USHORT MaximumDepth ;
	ULONG TotalAllocates ;
	union  {
		ULONG AllocateMisses ;
		ULONG AllocateHits ;
	}  ;
	ULONG TotalFrees ;
	union  {
		ULONG FreeMisses ;
		ULONG FreeHits ;
	}  ;
	POOL_TYPE Type ;
	ULONG Tag ;
	ULONG Size ;
	PALLOCATE_FUNCTION Allocate ;
	PFREE_FUNCTION Free ;
	LIST_ENTRY ListEntry ;
	ULONG LastTotalAllocates ;
	union  {
		ULONG LastAllocateMisses ;
		ULONG LastAllocateHits ;
	}  ;
	ULONG Future[2] ;
} GENERAL_LOOKASIDE , *  PGENERAL_LOOKASIDE ;

// #line 10619
typedef struct _NPAGED_LOOKASIDE_LIST {
	GENERAL_LOOKASIDE L ;
	KSPIN_LOCK Lock ;
} NPAGED_LOOKASIDE_LIST , *  PNPAGED_LOOKASIDE_LIST ;

// #line 10625
 
// #line 10637
// #line 10643
// #line 10729
typedef struct _PAGED_LOOKASIDE_LIST {
  GENERAL_LOOKASIDE L ;
  FAST_MUTEX Lock ;
} PAGED_LOOKASIDE_LIST , *  PPAGED_LOOKASIDE_LIST ;

// #line 10746
// #line 10754
// #line 10760
// #line 10856
// #line 10869
// #line 10882
typedef enum _WORK_QUEUE_TYPE {
	CriticalWorkQueue,
	DelayedWorkQueue,
	HyperCriticalWorkQueue,
	MaximumWorkQueue
} WORK_QUEUE_TYPE ;

typedef void ( *  PWORKER_THREAD_ROUTINE )(PVOID Parameter ) ;

// #line 10895
typedef struct _WORK_QUEUE_ITEM {
	LIST_ENTRY List ;
	PWORKER_THREAD_ROUTINE WorkerRoutine ;
	PVOID Parameter ;
} WORK_QUEUE_ITEM , *  PWORK_QUEUE_ITEM ;

// #line 10907
// #line 10916
// #line 10926
typedef struct _ZONE_SEGMENT_HEADER {
	SINGLE_LIST_ENTRY SegmentList ;
	PVOID Reserved ;
} ZONE_SEGMENT_HEADER , *  PZONE_SEGMENT_HEADER ;

typedef struct _ZONE_HEADER {
	SINGLE_LIST_ENTRY FreeList ;
	SINGLE_LIST_ENTRY SegmentList ;
	ULONG BlockSize ;
	ULONG TotalSegmentSize ;
} ZONE_HEADER , *  PZONE_HEADER ;

// #line 10939
// #line 10948
// #line 10956
// #line 11156
typedef ULONG_PTR ERESOURCE_THREAD ;

// #line 11157
typedef ERESOURCE_THREAD *  PERESOURCE_THREAD ;

typedef struct _OWNER_ENTRY {
	ERESOURCE_THREAD OwnerThread ;
	union  {
		LONG OwnerCount ;
		ULONG TableSize ;
	}  ;
} OWNER_ENTRY , *  POWNER_ENTRY ;

// #line 11168
typedef struct _ERESOURCE {
	LIST_ENTRY SystemResourcesList ;
	POWNER_ENTRY OwnerTable ;
	SHORT ActiveCount ;
	USHORT Flag ;
	PKSEMAPHORE SharedWaiters ;
	PKEVENT ExclusiveWaiters ;
	OWNER_ENTRY OwnerThreads[2] ;
	ULONG ContentionCount ;
	USHORT NumberOfSharedWaiters ;
	USHORT NumberOfExclusiveWaiters ;
	union  {
		PVOID Address ;
		ULONG_PTR CreatorBackTraceIndex ;
	}  ;
	KSPIN_LOCK SpinLock ;
} ERESOURCE , *  PERESOURCE ;

// #line 11197
typedef struct _RESOURCE_HASH_ENTRY {
	LIST_ENTRY ListEntry ;
	PVOID Address ;
	ULONG ContentionCount ;
	ULONG Number ;
} RESOURCE_HASH_ENTRY , *  PRESOURCE_HASH_ENTRY ;

typedef struct _RESOURCE_PERFORMANCE_DATA {
	ULONG ActiveResourceCount ;
	ULONG TotalResourceCount ;
	ULONG ExclusiveAcquire ;
	ULONG SharedFirstLevel ;
	ULONG SharedSecondLevel ;
	ULONG StarveFirstLevel ;
	ULONG StarveSecondLevel ;
	ULONG WaitForExclusive ;
	ULONG OwnerTableExpands ;
	ULONG MaximumTableExpand ;
	LIST_ENTRY HashTable[64] ;
} RESOURCE_PERFORMANCE_DATA , *  PRESOURCE_PERFORMANCE_DATA ;

// #line 11222
// #line 11234
// #line 11429
typedef void ( *  PCALLBACK_FUNCTION )(PVOID CallbackContext , PVOID Argument1 ,
	PVOID Argument2 ) ;

// #line 11474
typedef GUID UUID ;
// #line 11596
extern PBOOLEAN Mm64BitPhysicalAddress ;

// #line 11862
typedef enum _MM_SYSTEM_SIZE {
	MmSmallSystem,
	MmMediumSystem,
	MmLargeSystem
} MM_SYSTEMSIZE ;

// #line 11876

// #line 11884
typedef enum _LOCK_OPERATION {
	IoReadAccess,
	IoWriteAccess,
	IoModifyAccess
} LOCK_OPERATION ;

// #line 11891
// #line 11906
// #line 11915
PVOID MmLockPagableDataSection(PVOID AddressWithinSection);
void MmUnlockPages(PMDL MemoryDescriptorList ) ;
// #line 11921
// #line 11934
// #line 11970
typedef enum _MM_PAGE_PRIORITY {
	LowPagePriority,
	NormalPagePriority /* = 16 */,
	HighPagePriority /* = 32 */
} MM_PAGE_PRIORITY ;

// #line 11979
// #line 11990
// #line 11999
typedef struct _PHYSICAL_MEMORY_RANGE {
	PHYSICAL_ADDRESS BaseAddress ;
	LARGE_INTEGER NumberOfBytes ;
} PHYSICAL_MEMORY_RANGE , *  PPHYSICAL_MEMORY_RANGE ;

// #line 12011
// #line 12018
// #line 12385
typedef NTSTATUS ( *  PMM_DLL_INITIALIZE )(PUNICODE_STRING RegistryPath ) ;

// #line 12389
typedef NTSTATUS ( *  PMM_DLL_UNLOAD )(void  ) ;

// #line 12399
struct _DRIVER_OBJECT ;

// #line 12411
typedef enum _SECURITY_OPERATION_CODE {
	SetSecurityDescriptor,
	QuerySecurityDescriptor,
	DeleteSecurityDescriptor,
	AssignSecurityDescriptor
} SECURITY_OPERATION_CODE , *  PSECURITY_OPERATION_CODE ;

// #line 12426
typedef struct _SECURITY_SUBJECT_CONTEXT {
	PACCESS_TOKEN ClientToken ;
	SECURITY_IMPERSONATION_LEVEL ImpersonationLevel ;
	PACCESS_TOKEN PrimaryToken ;
	PVOID ProcessAuditId ;
} SECURITY_SUBJECT_CONTEXT , *  PSECURITY_SUBJECT_CONTEXT ;

// #line 12448
typedef struct _INITIAL_PRIVILEGE_SET {
	ULONG PrivilegeCount ;
	ULONG Control ;
	LUID_AND_ATTRIBUTES Privilege[3] ;
} INITIAL_PRIVILEGE_SET , *  PINITIAL_PRIVILEGE_SET ;

// #line 12462
typedef struct _ACCESS_STATE {
	LUID OperationID ;
	BOOLEAN SecurityEvaluated ;
	BOOLEAN GenerateAudit ;
	BOOLEAN GenerateOnClose ;
	BOOLEAN PrivilegesAllocated ;
	ULONG Flags ;
	ACCESS_MASK RemainingDesiredAccess ;
	ACCESS_MASK PreviouslyGrantedAccess ;
	ACCESS_MASK OriginalDesiredAccess ;
	SECURITY_SUBJECT_CONTEXT SubjectSecurityContext ;
	PSECURITY_DESCRIPTOR SecurityDescriptor ;
	PVOID AuxData ;
	union  {
		INITIAL_PRIVILEGE_SET InitialPrivilegeSet ;
		PRIVILEGE_SET PrivilegeSet ;
	} Privileges ;
	BOOLEAN AuditPrivileges ;
	UNICODE_STRING ObjectName ;
	UNICODE_STRING ObjectTypeName ;
} ACCESS_STATE , *  PACCESS_STATE ;

NTSTATUS PsCreateSystemThread(PHANDLE ThreadHandle , ULONG DesiredAccess ,
			      POBJECT_ATTRIBUTES ObjectAttributes , HANDLE ProcessHandle ,
			      PCLIENT_ID ClientId , PKSTART_ROUTINE StartRoutine ,
			      PVOID StartContext ) ;
NTSTATUS PsTerminateSystemThread(NTSTATUS ExitStatus ) ;

// #line 12571
typedef void ( *  PCREATE_PROCESS_NOTIFY_ROUTINE )(HANDLE ParentId , HANDLE
	ProcessId , BOOLEAN Create ) ;

// #line 12579
// #line 12585
typedef void ( *  PCREATE_THREAD_NOTIFY_ROUTINE )(HANDLE ProcessId , HANDLE
	ThreadId , BOOLEAN Create ) ;

// #line 12593
// #line 12602
typedef struct _IMAGE_INFO {
	union  {
		ULONG Properties ;
		struct  {
			ULONG ImageAddressingMode  : 8;
			ULONG SystemModeImage  /* :1*/;
			ULONG ImageMappedToAllPids  /* :1*/;
			ULONG Reserved  : 22;
		}  ;
	}  ;
	PVOID ImageBase ;
	ULONG ImageSelector ;
	SIZE_T ImageSize ;
	ULONG ImageSectionNumber ;
} IMAGE_INFO , *  PIMAGE_INFO ;

// #line 12620
typedef void ( *  PLOAD_IMAGE_NOTIFY_ROUTINE )(PUNICODE_STRING FullImageName ,
	HANDLE ProcessId , PIMAGE_INFO ImageInfo ) ;

// #line 12628
// #line 12633
// #line 12636
// #line 12639
// #line 12859
typedef NTSTATUS ( *  PIO_QUERY_DEVICE_ROUTINE )(PVOID Context , PUNICODE_STRING
	PathName , INTERFACE_TYPE BusType , ULONG BusNumber ,
	PKEY_VALUE_FULL_INFORMATION *  BusInformation , CONFIGURATION_TYPE
	ControllerType , ULONG ControllerNumber , PKEY_VALUE_FULL_INFORMATION * 
	ControllerInformation , CONFIGURATION_TYPE PeripheralType , ULONG
	PeripheralNumber , PKEY_VALUE_FULL_INFORMATION *  PeripheralInformation
	) ;

// #line 12878
typedef enum _IO_QUERY_DEVICE_DATA_FORMAT {
	IoQueryDeviceIdentifier /* = 0 */,
	IoQueryDeviceConfigurationData,
	IoQueryDeviceComponentInformation,
	IoQueryDeviceMaxData
} IO_QUERY_DEVICE_DATA_FORMAT , *  PIO_QUERY_DEVICE_DATA_FORMAT ;

// #line 12890
typedef enum _CREATE_FILE_TYPE {
	CreateFileTypeNone,
	CreateFileTypeNamedPipe,
	CreateFileTypeMailslot
} CREATE_FILE_TYPE ;

// #line 12905
struct _DEVICE_DESCRIPTION ;

// #line 12906
struct _DEVICE_OBJECT ;

// #line 12907
struct _DMA_ADAPTER ;

// #line 12908
struct _DRIVER_OBJECT ;

// #line 12909
struct _DRIVE_LAYOUT_INFORMATION ;

// #line 12910
struct _DISK_PARTITION ;

// #line 12911
struct _FILE_OBJECT ;

// #line 12912
struct _IRP ;

// #line 12913
struct _SCSI_REQUEST_BLOCK ;

// #line 12919
typedef void ( *  PIO_DPC_ROUTINE )(PKDPC Dpc , struct _DEVICE_OBJECT * 
	DeviceObject , struct _IRP *  Irp , PVOID Context ) ;

// #line 12932
typedef void ( *  PIO_TIMER_ROUTINE )(struct _DEVICE_OBJECT *  DeviceObject ,
	PVOID Context ) ;

// #line 12943
typedef NTSTATUS ( *  PDRIVER_INITIALIZE )(struct _DRIVER_OBJECT *  DriverObject
	, PUNICODE_STRING RegistryPath ) ;

// #line 12955
typedef void ( *  PDRIVER_REINITIALIZE )(struct _DRIVER_OBJECT *  DriverObject ,
	PVOID Context , ULONG Count ) ;

// #line 12968
typedef void ( *  PDRIVER_CANCEL )(struct _DEVICE_OBJECT *  DeviceObject ,
	struct _IRP *  Irp ) ;

// #line 12979
typedef NTSTATUS ( *  PDRIVER_DISPATCH )(struct _DEVICE_OBJECT *  DeviceObject ,
	struct _IRP *  Irp ) ;

// #line 12990
typedef void ( *  PDRIVER_STARTIO )(struct _DEVICE_OBJECT *  DeviceObject ,
	struct _IRP *  Irp ) ;

// #line 13001
typedef void ( *  PDRIVER_UNLOAD )(struct _DRIVER_OBJECT *  DriverObject ) ;

// #line 13011
typedef NTSTATUS ( *  PDRIVER_ADD_DEVICE )(struct _DRIVER_OBJECT *  DriverObject
	, struct _DEVICE_OBJECT *  PhysicalDeviceObject ) ;

// #line 13025
typedef BOOLEAN ( *  PFAST_IO_CHECK_IF_POSSIBLE )(struct _FILE_OBJECT * 
	FileObject , PLARGE_INTEGER FileOffset , ULONG Length , BOOLEAN Wait ,
	ULONG LockKey , BOOLEAN CheckForReadOperation , PIO_STATUS_BLOCK
	IoStatus , struct _DEVICE_OBJECT *  DeviceObject ) ;

// #line 13038
typedef BOOLEAN ( *  PFAST_IO_READ )(struct _FILE_OBJECT *  FileObject ,
	PLARGE_INTEGER FileOffset , ULONG Length , BOOLEAN Wait , ULONG LockKey
	, PVOID Buffer , PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT * 
	DeviceObject ) ;

// #line 13051
typedef BOOLEAN ( *  PFAST_IO_WRITE )(struct _FILE_OBJECT *  FileObject ,
	PLARGE_INTEGER FileOffset , ULONG Length , BOOLEAN Wait , ULONG LockKey
	, PVOID Buffer , PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT * 
	DeviceObject ) ;

// #line 13068
typedef BOOLEAN ( *  PFAST_IO_QUERY_BASIC_INFO )(struct _FILE_OBJECT * 
	FileObject , BOOLEAN Wait , PFILE_BASIC_INFORMATION Buffer ,
	PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *  DeviceObject ) ;

// #line 13078
typedef BOOLEAN ( *  PFAST_IO_QUERY_STANDARD_INFO )(struct _FILE_OBJECT * 
	FileObject , BOOLEAN Wait , PFILE_STANDARD_INFORMATION Buffer ,
	PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *  DeviceObject ) ;

// #line 13092
typedef BOOLEAN ( *  PFAST_IO_LOCK )(struct _FILE_OBJECT *  FileObject ,
	PLARGE_INTEGER FileOffset , PLARGE_INTEGER Length , PEPROCESS ProcessId
	, ULONG Key , BOOLEAN FailImmediately , BOOLEAN ExclusiveLock ,
	PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *  DeviceObject ) ;

// #line 13106
typedef BOOLEAN ( *  PFAST_IO_UNLOCK_SINGLE )(struct _FILE_OBJECT *  FileObject
	, PLARGE_INTEGER FileOffset , PLARGE_INTEGER Length , PEPROCESS
	ProcessId , ULONG Key , PIO_STATUS_BLOCK IoStatus ,
	struct _DEVICE_OBJECT *  DeviceObject ) ;

// #line 13118
typedef BOOLEAN ( *  PFAST_IO_UNLOCK_ALL )(struct _FILE_OBJECT *  FileObject ,
	PEPROCESS ProcessId , PIO_STATUS_BLOCK IoStatus ,
	struct _DEVICE_OBJECT *  DeviceObject ) ;

// #line 13127
typedef BOOLEAN ( *  PFAST_IO_UNLOCK_ALL_BY_KEY )(struct _FILE_OBJECT * 
	FileObject , PVOID ProcessId , ULONG Key , PIO_STATUS_BLOCK IoStatus ,
	struct _DEVICE_OBJECT *  DeviceObject ) ;

// #line 13141
typedef BOOLEAN ( *  PFAST_IO_DEVICE_CONTROL )(struct _FILE_OBJECT *  FileObject
	, BOOLEAN Wait , PVOID InputBuffer , ULONG InputBufferLength , PVOID
	OutputBuffer , ULONG OutputBufferLength , ULONG IoControlCode ,
	PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT *  DeviceObject ) ;

// #line 13161
typedef void ( *  PFAST_IO_ACQUIRE_FILE )(struct _FILE_OBJECT *  FileObject ) ;

// #line 13167
typedef void ( *  PFAST_IO_RELEASE_FILE )(struct _FILE_OBJECT *  FileObject ) ;

// #line 13179
typedef void ( *  PFAST_IO_DETACH_DEVICE )(struct _DEVICE_OBJECT *  SourceDevice
	, struct _DEVICE_OBJECT *  TargetDevice ) ;

// #line 13193
typedef BOOLEAN ( *  PFAST_IO_QUERY_NETWORK_OPEN_INFO )(struct _FILE_OBJECT * 
	FileObject , BOOLEAN Wait , struct _FILE_NETWORK_OPEN_INFORMATION * 
	Buffer , struct _IO_STATUS_BLOCK *  IoStatus , struct _DEVICE_OBJECT * 
	DeviceObject ) ;

// #line 13207
typedef BOOLEAN ( *  PFAST_IO_MDL_READ )(struct _FILE_OBJECT *  FileObject ,
	PLARGE_INTEGER FileOffset , ULONG Length , ULONG LockKey , PMDL * 
	MdlChain , PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT * 
	DeviceObject ) ;

// #line 13219
typedef BOOLEAN ( *  PFAST_IO_MDL_READ_COMPLETE )(struct _FILE_OBJECT * 
	FileObject , PMDL MdlChain , struct _DEVICE_OBJECT *  DeviceObject ) ;

// #line 13227
typedef BOOLEAN ( *  PFAST_IO_PREPARE_MDL_WRITE )(struct _FILE_OBJECT * 
	FileObject , PLARGE_INTEGER FileOffset , ULONG Length , ULONG LockKey ,
	PMDL *  MdlChain , PIO_STATUS_BLOCK IoStatus , struct _DEVICE_OBJECT * 
	DeviceObject ) ;

// #line 13239
typedef BOOLEAN ( *  PFAST_IO_MDL_WRITE_COMPLETE )(struct _FILE_OBJECT * 
	FileObject , PLARGE_INTEGER FileOffset , PMDL MdlChain ,
	struct _DEVICE_OBJECT *  DeviceObject ) ;

// #line 13253
typedef NTSTATUS ( *  PFAST_IO_ACQUIRE_FOR_MOD_WRITE )(struct _FILE_OBJECT * 
	FileObject , PLARGE_INTEGER EndingOffset , struct _ERESOURCE *  * 
	ResourceToRelease , struct _DEVICE_OBJECT *  DeviceObject ) ;

// #line 13262
typedef NTSTATUS ( *  PFAST_IO_RELEASE_FOR_MOD_WRITE )(struct _FILE_OBJECT * 
	FileObject , struct _ERESOURCE *  ResourceToRelease ,
	struct _DEVICE_OBJECT *  DeviceObject ) ;

// #line 13275
typedef NTSTATUS ( *  PFAST_IO_ACQUIRE_FOR_CCFLUSH )(struct _FILE_OBJECT * 
	FileObject , struct _DEVICE_OBJECT *  DeviceObject ) ;

// #line 13282
typedef NTSTATUS ( *  PFAST_IO_RELEASE_FOR_CCFLUSH )(struct _FILE_OBJECT * 
	FileObject , struct _DEVICE_OBJECT *  DeviceObject ) ;

// #line 13289
typedef BOOLEAN ( *  PFAST_IO_READ_COMPRESSED )(struct _FILE_OBJECT * 
	FileObject , PLARGE_INTEGER FileOffset , ULONG Length , ULONG LockKey ,
	PVOID Buffer , PMDL *  MdlChain , PIO_STATUS_BLOCK IoStatus ,
	struct _COMPRESSED_DATA_INFO *  CompressedDataInfo , ULONG
	CompressedDataInfoLength , struct _DEVICE_OBJECT *  DeviceObject ) ;

// #line 13304
typedef BOOLEAN ( *  PFAST_IO_WRITE_COMPRESSED )(struct _FILE_OBJECT * 
	FileObject , PLARGE_INTEGER FileOffset , ULONG Length , ULONG LockKey ,
	PVOID Buffer , PMDL *  MdlChain , PIO_STATUS_BLOCK IoStatus ,
	struct _COMPRESSED_DATA_INFO *  CompressedDataInfo , ULONG
	CompressedDataInfoLength , struct _DEVICE_OBJECT *  DeviceObject ) ;

// #line 13319
typedef BOOLEAN ( *  PFAST_IO_MDL_READ_COMPLETE_COMPRESSED
	)(struct _FILE_OBJECT *  FileObject , PMDL MdlChain ,
	struct _DEVICE_OBJECT *  DeviceObject ) ;

// #line 13327
typedef BOOLEAN ( *  PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED
	)(struct _FILE_OBJECT *  FileObject , PLARGE_INTEGER FileOffset , PMDL
	MdlChain , struct _DEVICE_OBJECT *  DeviceObject ) ;

// #line 13336
typedef BOOLEAN ( *  PFAST_IO_QUERY_OPEN )(struct _IRP *  Irp ,
	PFILE_NETWORK_OPEN_INFORMATION NetworkInformation ,
	struct _DEVICE_OBJECT *  DeviceObject ) ;

// #line 13350
typedef struct _FAST_IO_DISPATCH {
	ULONG SizeOfFastIoDispatch ;
	PFAST_IO_CHECK_IF_POSSIBLE FastIoCheckIfPossible ;
	PFAST_IO_READ FastIoRead ;
	PFAST_IO_WRITE FastIoWrite ;
	PFAST_IO_QUERY_BASIC_INFO FastIoQueryBasicInfo ;
	PFAST_IO_QUERY_STANDARD_INFO FastIoQueryStandardInfo ;
	PFAST_IO_LOCK FastIoLock ;
	PFAST_IO_UNLOCK_SINGLE FastIoUnlockSingle ;
	PFAST_IO_UNLOCK_ALL FastIoUnlockAll ;
	PFAST_IO_UNLOCK_ALL_BY_KEY FastIoUnlockAllByKey ;
	PFAST_IO_DEVICE_CONTROL FastIoDeviceControl ;
	PFAST_IO_ACQUIRE_FILE AcquireFileForNtCreateSection ;
	PFAST_IO_RELEASE_FILE ReleaseFileForNtCreateSection ;
	PFAST_IO_DETACH_DEVICE FastIoDetachDevice ;
	PFAST_IO_QUERY_NETWORK_OPEN_INFO FastIoQueryNetworkOpenInfo ;
	PFAST_IO_ACQUIRE_FOR_MOD_WRITE AcquireForModWrite ;
	PFAST_IO_MDL_READ MdlRead ;
	PFAST_IO_MDL_READ_COMPLETE MdlReadComplete ;
	PFAST_IO_PREPARE_MDL_WRITE PrepareMdlWrite ;
	PFAST_IO_MDL_WRITE_COMPLETE MdlWriteComplete ;
	PFAST_IO_READ_COMPRESSED FastIoReadCompressed ;
	PFAST_IO_WRITE_COMPRESSED FastIoWriteCompressed ;
	PFAST_IO_MDL_READ_COMPLETE_COMPRESSED MdlReadCompleteCompressed ;
	PFAST_IO_MDL_WRITE_COMPLETE_COMPRESSED MdlWriteCompleteCompressed ;
	PFAST_IO_QUERY_OPEN FastIoQueryOpen ;
	PFAST_IO_RELEASE_FOR_MOD_WRITE ReleaseForModWrite ;
	PFAST_IO_ACQUIRE_FOR_CCFLUSH AcquireForCcFlush ;
	PFAST_IO_RELEASE_FOR_CCFLUSH ReleaseForCcFlush ;
} FAST_IO_DISPATCH , *  PFAST_IO_DISPATCH ;

// #line 13386
typedef enum _IO_ALLOCATION_ACTION {
	KeepObject = 1,
	DeallocateObject,
	DeallocateObjectKeepRegisters
} IO_ALLOCATION_ACTION , *  PIO_ALLOCATION_ACTION ;

// #line 13396
typedef IO_ALLOCATION_ACTION ( *  PDRIVER_CONTROL )(struct _DEVICE_OBJECT * 
	DeviceObject , struct _IRP *  Irp , PVOID MapRegisterBase , PVOID
	Context ) ;

// #line 13410
typedef struct _IO_SECURITY_CONTEXT {
	PSECURITY_QUALITY_OF_SERVICE SecurityQos ;
	PACCESS_STATE AccessState ;
	ACCESS_MASK DesiredAccess ;
	ULONG FullCreateOptions ;
} IO_SECURITY_CONTEXT , *  PIO_SECURITY_CONTEXT ;

// #line 13434
typedef struct _VPB {
	CSHORT Type ;
	CSHORT Size ;
	USHORT Flags ;
	USHORT VolumeLabelLength ;
	struct _DEVICE_OBJECT *  DeviceObject ;
	struct _DEVICE_OBJECT *  RealDevice ;
	ULONG SerialNumber ;
	ULONG ReferenceCount ;
	WCHAR VolumeLabel[32 * sizeof(WCHAR ) / sizeof(WCHAR )] ;
} VPB , *  PVPB ;

// #line 13482
typedef struct _ADAPTER_OBJECT *  PADAPTER_OBJECT ;

// #line 13491
typedef struct _WAIT_CONTEXT_BLOCK {
	KDEVICE_QUEUE_ENTRY WaitQueueEntry ;
	PDRIVER_CONTROL DeviceRoutine ;
	PVOID DeviceContext ;
	ULONG NumberOfMapRegisters ;
	PVOID DeviceObject ;
	PVOID CurrentIrp ;
	PKDPC BufferChainingDpc ;
} WAIT_CONTEXT_BLOCK , *  PWAIT_CONTEXT_BLOCK ;

// #line 13503
typedef struct _CONTROLLER_OBJECT {
	CSHORT Type ;
	CSHORT Size ;
	PVOID ControllerExtension ;
	KDEVICE_QUEUE DeviceWaitQueue ;
	ULONG Spare1 ;
	LARGE_INTEGER Spare2 ;
} CONTROLLER_OBJECT , *  PCONTROLLER_OBJECT ;

// #line 13537
typedef struct _DEVICE_OBJECT {
	CSHORT Type ;
	USHORT Size ;
	LONG ReferenceCount ;
	struct _DRIVER_OBJECT *  DriverObject ;
	struct _DEVICE_OBJECT *  NextDevice ;
	struct _DEVICE_OBJECT *  AttachedDevice ;
	struct _IRP *  CurrentIrp ;
	PIO_TIMER Timer ;
	ULONG Flags ;
	ULONG Characteristics ;
	PVPB Vpb ;
	PVOID DeviceExtension ;
	ULONG DeviceType ;
	CCHAR StackSize ;
	union  {
		LIST_ENTRY ListEntry ;
		WAIT_CONTEXT_BLOCK Wcb ;
	} Queue ;
	ULONG AlignmentRequirement ;
	KDEVICE_QUEUE DeviceQueue ;
	KDPC Dpc ;
	ULONG ActiveThreadCount ;
	PSECURITY_DESCRIPTOR SecurityDescriptor ;
	KEVENT DeviceLock ;
	USHORT SectorSize ;
	USHORT Spare1 ;
	struct _DEVOBJ_EXTENSION *  DeviceObjectExtension ;
	PVOID Reserved ;
} DEVICE_OBJECT ;

// #line 13575
typedef struct _DEVICE_OBJECT *  PDEVICE_OBJECT ;

// #line 13578
struct _DEVICE_OBJECT_POWER_EXTENSION ;

typedef struct _DEVOBJ_EXTENSION {
	CSHORT Type ;
	USHORT Size ;
	PDEVICE_OBJECT DeviceObject ;
} DEVOBJ_EXTENSION , *  PDEVOBJ_EXTENSION ;

// #line 13608
typedef struct _DRIVER_EXTENSION {
	struct _DRIVER_OBJECT *  DriverObject ;
	PDRIVER_ADD_DEVICE AddDevice ;
	ULONG Count ;
	UNICODE_STRING ServiceKeyName ;
} DRIVER_EXTENSION , *  PDRIVER_EXTENSION ;

// #line 13645
typedef struct _DRIVER_OBJECT {
	CSHORT Type ;
	CSHORT Size ;
	PDEVICE_OBJECT DeviceObject ;
	ULONG Flags ;
	PVOID DriverStart ;
	ULONG DriverSize ;
	PVOID DriverSection ;
	PDRIVER_EXTENSION DriverExtension ;
	UNICODE_STRING DriverName ;
	PUNICODE_STRING HardwareDatabase ;
	PFAST_IO_DISPATCH FastIoDispatch ;
	PDRIVER_INITIALIZE DriverInit ;
	PDRIVER_STARTIO DriverStartIo ;
	PDRIVER_UNLOAD DriverUnload ;
	PDRIVER_DISPATCH MajorFunction[28] ;
} DRIVER_OBJECT ;

// #line 13706
typedef struct _DRIVER_OBJECT *  PDRIVER_OBJECT ;

// #line 13715
typedef struct _SECTION_OBJECT_POINTERS {
	PVOID DataSectionObject ;
	PVOID SharedCacheMap ;
	PVOID ImageSectionObject ;
} SECTION_OBJECT_POINTERS ;

// #line 13720
typedef SECTION_OBJECT_POINTERS *  PSECTION_OBJECT_POINTERS ;

// #line 13726
typedef struct _IO_COMPLETION_CONTEXT {
	PVOID Port ;
	PVOID Key ;
} IO_COMPLETION_CONTEXT , *  PIO_COMPLETION_CONTEXT ;

// #line 13759
typedef struct _FILE_OBJECT {
	CSHORT Type ;
	CSHORT Size ;
	PDEVICE_OBJECT DeviceObject ;
	PVPB Vpb ;
	PVOID FsContext ;
	PVOID FsContext2 ;
	PSECTION_OBJECT_POINTERS SectionObjectPointer ;
	PVOID PrivateCacheMap ;
	NTSTATUS FinalStatus ;
	struct _FILE_OBJECT *  RelatedFileObject ;
	BOOLEAN LockOperation ;
	BOOLEAN DeletePending ;
	BOOLEAN ReadAccess ;
	BOOLEAN WriteAccess ;
	BOOLEAN DeleteAccess ;
	BOOLEAN SharedRead ;
	BOOLEAN SharedWrite ;
	BOOLEAN SharedDelete ;
	ULONG Flags ;
	UNICODE_STRING FileName ;
	LARGE_INTEGER CurrentByteOffset ;
	ULONG Waiters ;
	ULONG Busy ;
	PVOID LastLock ;
	KEVENT Lock ;
	KEVENT Event ;
	PIO_COMPLETION_CONTEXT CompletionContext ;
} FILE_OBJECT ;

// #line 13788
typedef struct _FILE_OBJECT *  PFILE_OBJECT ;

// #line 13828
typedef struct _IRP {
	CSHORT Type ;
	USHORT Size ;
	PMDL MdlAddress ;
	ULONG Flags ;
	union  {
		struct _IRP *  MasterIrp ;
		LONG IrpCount ;
		PVOID SystemBuffer ;
	} AssociatedIrp ;
	LIST_ENTRY ThreadListEntry ;
	IO_STATUS_BLOCK IoStatus ;
	KPROCESSOR_MODE RequestorMode ;
	BOOLEAN PendingReturned ;
	CHAR StackCount ;
	CHAR CurrentLocation ;
	BOOLEAN Cancel ;
	KIRQL CancelIrql ;
	CCHAR ApcEnvironment ;
	UCHAR AllocationFlags ;
	PIO_STATUS_BLOCK UserIosb ;
	PKEVENT UserEvent ;
	union  {
		struct  {
			PIO_APC_ROUTINE UserApcRoutine ;
			PVOID UserApcContext ;
		} AsynchronousParameters ;
		LARGE_INTEGER AllocationSize ;
	} Overlay ;
	PDRIVER_CANCEL CancelRoutine ;
	PVOID UserBuffer ;
	union  {
		struct  {
			union  {
				KDEVICE_QUEUE_ENTRY DeviceQueueEntry ;
				struct  {
					PVOID DriverContext[4] ;
				}  ;
			}  ;
			PETHREAD Thread ;
			PCHAR AuxiliaryBuffer ;
			struct  {
				LIST_ENTRY ListEntry ;
				union  {
					struct _IO_STACK_LOCATION * 
						CurrentStackLocation ;
					ULONG PacketType ;
				}  ;
			}  ;
			PFILE_OBJECT OriginalFileObject ;
		} Overlay ;
		KAPC Apc ;
		PVOID CompletionKey ;
	} Tail ;
} IRP , *  PIRP ;

// #line 14078
typedef NTSTATUS ( *  PIO_COMPLETION_ROUTINE )(PDEVICE_OBJECT DeviceObject ,
	PIRP Irp , PVOID Context ) ;

// #line 14163
typedef enum _DEVICE_RELATION_TYPE {
	BusRelations,
	EjectionRelations,
	PowerRelations,
	RemovalRelations,
	TargetDeviceRelation
} DEVICE_RELATION_TYPE , *  PDEVICE_RELATION_TYPE ;

typedef struct _DEVICE_RELATIONS {
	ULONG Count ;
	PDEVICE_OBJECT Objects[1] ;
} DEVICE_RELATIONS , *  PDEVICE_RELATIONS ;

typedef enum _DEVICE_USAGE_NOTIFICATION_TYPE {
	DeviceUsageTypeUndefined,
	DeviceUsageTypePaging,
	DeviceUsageTypeHibernation,
	DeviceUsageTypeDumpFile
} DEVICE_USAGE_NOTIFICATION_TYPE ;

// #line 14185
typedef struct _INTERFACE {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
} INTERFACE , *  PINTERFACE ;

// #line 14196
typedef struct _DEVICE_CAPABILITIES {
	USHORT Size ;
	USHORT Version ;
	ULONG DeviceD1  /* :1*/;
	ULONG DeviceD2  /* :1*/;
	ULONG LockSupported  /* :1*/;
	ULONG EjectSupported  /* :1*/;
	ULONG Removable  /* :1*/;
	ULONG DockDevice  /* :1*/;
	ULONG UniqueID  /* :1*/;
	ULONG SilentInstall  /* :1*/;
	ULONG RawDeviceOK  /* :1*/;
	ULONG SurpriseRemovalOK  /* :1*/;
	ULONG WakeFromD0  /* :1*/;
	ULONG WakeFromD1  /* :1*/;
	ULONG WakeFromD2  /* :1*/;
	ULONG WakeFromD3  /* :1*/;
	ULONG HardwareDisabled  /* :1*/;
	ULONG NonDynamic  /* :1*/;
	ULONG WarmEjectSupported  /* :1*/;
	ULONG Reserved  /* : 15 */;
	ULONG Address ;
	ULONG UINumber ;
	DEVICE_POWER_STATE DeviceState[PowerSystemMaximum] ;
	SYSTEM_POWER_STATE SystemWake ;
	DEVICE_POWER_STATE DeviceWake ;
	ULONG D1Latency ;
	ULONG D2Latency ;
	ULONG D3Latency ;
} DEVICE_CAPABILITIES , *  PDEVICE_CAPABILITIES ;

// #line 14229
typedef struct _POWER_SEQUENCE {
	ULONG SequenceD1 ;
	ULONG SequenceD2 ;
	ULONG SequenceD3 ;
} POWER_SEQUENCE , *  PPOWER_SEQUENCE ;

typedef enum  {
	BusQueryDeviceID /* = 0 */,
	BusQueryHardwareIDs /* = 1 */,
	BusQueryCompatibleIDs /* = 2 */,
	BusQueryInstanceID /* = 3 */,
	BusQueryDeviceSerialNumber /* = 4 */
} BUS_QUERY_ID_TYPE , *  PBUS_QUERY_ID_TYPE ;

typedef ULONG PNP_DEVICE_STATE , *  PPNP_DEVICE_STATE ;

// #line 14252
typedef enum  {
	DeviceTextDescription /* = 0 */,
	DeviceTextLocationInformation /* = 1 */
} DEVICE_TEXT_TYPE , *  PDEVICE_TEXT_TYPE ;

// #line 24 "C:/NTDDK/inc/pshpack4.h"

// #pragma warning(disable:4103)

// #pragma pack(push, 4)
// #line 14271 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _IO_STACK_LOCATION {
	UCHAR MajorFunction ;
	UCHAR MinorFunction ;
	UCHAR Flags ;
	UCHAR Control ;
	union  {
		struct  {
			PIO_SECURITY_CONTEXT SecurityContext ;
			ULONG Options ;
			USHORT FileAttributes ;
			USHORT ShareAccess ;
			ULONG EaLength ;
		} Create ;
		struct  {
			ULONG Length ;
			ULONG Key ;
			LARGE_INTEGER ByteOffset ;
		} Read ;
		struct  {
			ULONG Length ;
			ULONG Key ;
			LARGE_INTEGER ByteOffset ;
		} Write ;
		struct  {
			ULONG Length ;
			FILE_INFORMATION_CLASS FileInformationClass ;
		} QueryFile ;
		struct  {
			ULONG Length ;
			FILE_INFORMATION_CLASS FileInformationClass ;
			PFILE_OBJECT FileObject ;
			union  {
				struct  {
					BOOLEAN ReplaceIfExists ;
					BOOLEAN AdvanceOnly ;
				}  ;
				ULONG ClusterCount ;
				HANDLE DeleteHandle ;
			}  ;
		} SetFile ;
		struct  {
			ULONG Length ;
			FS_INFORMATION_CLASS FsInformationClass ;
		} QueryVolume ;
		struct  {
			ULONG OutputBufferLength ;
			ULONG InputBufferLength ;
			ULONG IoControlCode ;
			PVOID Type3InputBuffer ;
		} DeviceIoControl ;
		struct  {
			SECURITY_INFORMATION SecurityInformation ;
			ULONG Length ;
		} QuerySecurity ;
		struct  {
			SECURITY_INFORMATION SecurityInformation ;
			PSECURITY_DESCRIPTOR SecurityDescriptor ;
		} SetSecurity ;
		struct  {
			PVPB Vpb ;
			PDEVICE_OBJECT DeviceObject ;
		} MountVolume ;
		struct  {
			PVPB Vpb ;
			PDEVICE_OBJECT DeviceObject ;
		} VerifyVolume ;
		struct  {
			struct _SCSI_REQUEST_BLOCK *  Srb ;
		} Scsi ;
		struct  {
			DEVICE_RELATION_TYPE Type ;
		} QueryDeviceRelations ;
		struct  {
			  GUID *  InterfaceType ;
			USHORT Size ;
			USHORT Version ;
			PINTERFACE Interface ;
			PVOID InterfaceSpecificData ;
		} QueryInterface ;
		struct  {
			PDEVICE_CAPABILITIES Capabilities ;
		} DeviceCapabilities ;
		struct  {
			PIO_RESOURCE_REQUIREMENTS_LIST IoResourceRequirementList
				;
		} FilterResourceRequirements ;
		struct  {
			ULONG WhichSpace ;
			PVOID Buffer ;
			ULONG Offset ;
			ULONG Length ;
		} ReadWriteConfig ;
		struct  {
			BOOLEAN Lock ;
		} SetLock ;
		struct  {
			BUS_QUERY_ID_TYPE IdType ;
		} QueryId ;
		struct  {
			DEVICE_TEXT_TYPE DeviceTextType ;
			LCID LocaleId ;
		} QueryDeviceText ;
		struct  {
			BOOLEAN InPath ;
			BOOLEAN Reserved[3] ;
			DEVICE_USAGE_NOTIFICATION_TYPE Type ;
		} UsageNotification ;
		struct  {
			SYSTEM_POWER_STATE PowerState ;
		} WaitWake ;
		struct  {
			PPOWER_SEQUENCE PowerSequence ;
		} PowerSequence ;
		struct  {
			ULONG SystemContext ;
			POWER_STATE_TYPE Type ;
			POWER_STATE State ;
			POWER_ACTION ShutdownType ;
		} Power ;
		struct  {
			PCM_RESOURCE_LIST AllocatedResources ;
			PCM_RESOURCE_LIST AllocatedResourcesTranslated ;
		} StartDevice ;
		struct  {
			ULONG_PTR ProviderId ;
			PVOID DataPath ;
			ULONG BufferSize ;
			PVOID Buffer ;
		} WMI ;
		struct  {
			PVOID Argument1 ;
			PVOID Argument2 ;
			PVOID Argument3 ;
			PVOID Argument4 ;
		} Others ;
	} Parameters ;
	PDEVICE_OBJECT DeviceObject ;
	PFILE_OBJECT FileObject ;
	PIO_COMPLETION_ROUTINE CompletionRoutine ;
	PVOID Context ;
} IO_STACK_LOCATION , *  PIO_STACK_LOCATION ;

// #line 27 "C:/NTDDK/inc/poppack.h"

// #pragma warning(disable:4103)

// #pragma pack(pop)
// #line 14615 "C:/NTDDK/inc/ddk/ntddk.h"
typedef struct _SHARE_ACCESS {
	ULONG OpenCount ;
	ULONG Readers ;
	ULONG Writers ;
	ULONG Deleters ;
	ULONG SharedRead ;
	ULONG SharedWrite ;
	ULONG SharedDelete ;
} SHARE_ACCESS , *  PSHARE_ACCESS ;

// #line 14635
typedef struct _CONFIGURATION_INFORMATION {
	ULONG DiskCount ;
	ULONG FloppyCount ;
	ULONG CdRomCount ;
	ULONG TapeCount ;
	ULONG ScsiPortCount ;
	ULONG SerialCount ;
	ULONG ParallelCount ;
	BOOLEAN AtDiskPrimaryAddressClaimed ;
	BOOLEAN AtDiskSecondaryAddressClaimed ;
	ULONG Version ;
	ULONG MediumChangerCount ;
} CONFIGURATION_INFORMATION , *  PCONFIGURATION_INFORMATION ;

// #line 14681
// #line 14688
// #line 14698
  PMDL IoAllocateMdl(PVOID VirtualAddress , ULONG Length ,
		     BOOLEAN SecondaryBuffer , BOOLEAN ChargeQuota , PIRP Irp ) ;
// #line 14776
// #line 14788
NTSTATUS IoAttachDevice(PDEVICE_OBJECT SourceDevice ,
			PUNICODE_STRING TargetDevice , PDEVICE_OBJECT *  AttachedDevice ) ;
// #line 14798
// #line 14807
PDEVICE_OBJECT IoAttachDeviceToDeviceStack(PDEVICE_OBJECT SourceDevice ,
					   PDEVICE_OBJECT TargetDevice ) ;
PIRP IoBuildAsynchronousFsdRequest(ULONG MajorFunction ,
				   PDEVICE_OBJECT DeviceObject , PVOID Buffer , ULONG Length ,
				   PLARGE_INTEGER StartingOffset , PIO_STATUS_BLOCK IoStatusBlock ) ;
PIRP IoBuildDeviceIoControlRequest(ULONG IoControlCode ,
				   PDEVICE_OBJECT DeviceObject , PVOID InputBuffer , 
				   ULONG InputBufferLength , PVOID OutputBuffer , 
				   ULONG OutputBufferLength ,				   
				   BOOLEAN InternalDeviceIoControl , PKEVENT Event , 
				   PIO_STATUS_BLOCK IoStatusBlock ) ;
				   
// #line 14839
// #line 14848
typedef struct _BOOTDISK_INFORMATION {
	LONGLONG BootPartitionOffset ;
	LONGLONG SystemPartitionOffset ;
	ULONG BootDeviceSignature ;
	ULONG SystemDeviceSignature ;
} BOOTDISK_INFORMATION , *  PBOOTDISK_INFORMATION ;

// #line 14863
// #line 14875
NTSTATUS IofCallDriver(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
// #line 14886
// #line 14893
// #line 14903
void IofCompleteRequest(PIRP Irp , CCHAR PriorityBoost ) ;
// #line 14934
// #line 14942
NTSTATUS IoCreateDevice(PDRIVER_OBJECT DriverObject ,
			ULONG DeviceExtensionSize , PUNICODE_STRING DeviceName , 
			ULONG DeviceType ,
			ULONG DeviceCharacteristics , BOOLEAN Exclusive ,
			PDEVICE_OBJECT *  DeviceObject ) ;
NTSTATUS IoCreateSymbolicLink(PUNICODE_STRING SymbolicLinkName , PUNICODE_STRING DeviceName ) ;
void IoDeleteDevice(PDEVICE_OBJECT DeviceObject ) ;
NTSTATUS IoDeleteSymbolicLink(PUNICODE_STRING SymbolicLinkName ) ;
void IoDetachDevice(PDEVICE_OBJECT TargetDevice ) ;
void IoFreeIrp(PIRP Irp ) ;
void IoFreeMdl(PMDL Mdl ) ;
PCONFIGURATION_INFORMATION  IoGetConfigurationInformation(void  ) ;
void IoReleaseCancelSpinLock(KIRQL Irql ) ;

typedef struct _IO_REMOVE_LOCK_TRACKING_BLOCK *  PIO_REMOVE_LOCK_TRACKING_BLOCK ;
	
// #line 15756
typedef struct _IO_REMOVE_LOCK_COMMON_BLOCK {
	BOOLEAN Removed ;
	BOOLEAN Reserved[3] ;
	LONG IoCount ;
	KEVENT RemoveEvent ;
} IO_REMOVE_LOCK_COMMON_BLOCK ;

// #line 15764
typedef struct _IO_REMOVE_LOCK_DBG_BLOCK {
	LONG Signature ;
	LONG HighWatermark ;
	LONGLONG MaxLockedTicks ;
	LONG AllocateTag ;
	LIST_ENTRY LockList ;
	KSPIN_LOCK Spin ;
	LONG LowMemoryCount ;
	ULONG Reserved1[4] ;
	PVOID Reserved2 ;
	PIO_REMOVE_LOCK_TRACKING_BLOCK Blocks ;
} IO_REMOVE_LOCK_DBG_BLOCK ;

typedef struct _IO_REMOVE_LOCK {
	IO_REMOVE_LOCK_COMMON_BLOCK Common ;
} IO_REMOVE_LOCK , *  PIO_REMOVE_LOCK ;

// #line 15787
// #line 15808
// #line 15857
// #line 15893
// #line 15949
// #line 16009
typedef struct _IO_WORKITEM *  PIO_WORKITEM ;

typedef void ( *  PIO_WORKITEM_ROUTINE )(PDEVICE_OBJECT DeviceObject , PVOID
	Context ) ;

// #line 16100
typedef enum  {
	DevicePropertyDeviceDescription,
	DevicePropertyHardwareID,
	DevicePropertyCompatibleIDs,
	DevicePropertyBootConfiguration,
	DevicePropertyBootConfigurationTranslated,
	DevicePropertyClassName,
	DevicePropertyClassGuid,
	DevicePropertyDriverKeyName,
	DevicePropertyManufacturer,
	DevicePropertyFriendlyName,
	DevicePropertyLocationInformation,
	DevicePropertyPhysicalDeviceObjectName,
	DevicePropertyBusTypeGuid,
	DevicePropertyLegacyBusType,
	DevicePropertyBusNumber,
	DevicePropertyEnumeratorName,
	DevicePropertyAddress,
	DevicePropertyUINumber
} DEVICE_REGISTRY_PROPERTY ;

typedef BOOLEAN ( *  PTRANSLATE_BUS_ADDRESS )(PVOID Context , PHYSICAL_ADDRESS
	BusAddress , ULONG Length , PULONG AddressSpace , PPHYSICAL_ADDRESS
	TranslatedAddress ) ;

// #line 16129
typedef struct _DMA_ADAPTER *  ( *  PGET_DMA_ADAPTER )(PVOID Context ,
	struct _DEVICE_DESCRIPTION *  DeviceDescriptor , PULONG
	NumberOfMapRegisters ) ;

// #line 16135
typedef ULONG ( *  PGET_SET_DEVICE_DATA )(PVOID Context , ULONG DataType , PVOID
	Buffer , ULONG Offset , ULONG Length ) ;

// #line 16148
typedef struct _PNP_BUS_INFORMATION {
	GUID BusTypeGuid ;
	INTERFACE_TYPE LegacyBusType ;
	ULONG BusNumber ;
} PNP_BUS_INFORMATION , *  PPNP_BUS_INFORMATION ;

// #line 16162
typedef struct _LEGACY_BUS_INFORMATION {
	GUID BusTypeGuid ;
	INTERFACE_TYPE LegacyBusType ;
	ULONG BusNumber ;
} LEGACY_BUS_INFORMATION , *  PLEGACY_BUS_INFORMATION ;

typedef struct _BUS_INTERFACE_STANDARD {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PTRANSLATE_BUS_ADDRESS TranslateBusAddress ;
	PGET_DMA_ADAPTER GetDmaAdapter ;
	PGET_SET_DEVICE_DATA SetBusData ;
	PGET_SET_DEVICE_DATA GetBusData ;
} BUS_INTERFACE_STANDARD , *  PBUS_INTERFACE_STANDARD ;

// #line 16190
typedef BOOLEAN ( *  PGPE_SERVICE_ROUTINE )(PVOID , PVOID ) ;

// #line 16194
typedef NTSTATUS ( *  PGPE_CONNECT_VECTOR )(PDEVICE_OBJECT , ULONG ,
	KINTERRUPT_MODE , BOOLEAN , PGPE_SERVICE_ROUTINE , PVOID , PVOID ) ;

// #line 16203
typedef NTSTATUS ( *  PGPE_DISCONNECT_VECTOR )(PVOID ) ;

// #line 16206
typedef NTSTATUS ( *  PGPE_ENABLE_EVENT )(PDEVICE_OBJECT , PVOID ) ;

// #line 16210
typedef NTSTATUS ( *  PGPE_DISABLE_EVENT )(PDEVICE_OBJECT , PVOID ) ;

// #line 16214
typedef NTSTATUS ( *  PGPE_CLEAR_STATUS )(PDEVICE_OBJECT , PVOID ) ;

// #line 16218
typedef void ( *  PDEVICE_NOTIFY_CALLBACK )(PVOID , ULONG ) ;

// #line 16222
typedef NTSTATUS ( *  PREGISTER_FOR_DEVICE_NOTIFICATIONS )(PDEVICE_OBJECT ,
	PDEVICE_NOTIFY_CALLBACK , PVOID ) ;

// #line 16227
typedef void ( *  PUNREGISTER_FOR_DEVICE_NOTIFICATIONS )(PDEVICE_OBJECT ,
	PDEVICE_NOTIFY_CALLBACK ) ;

// #line 16231
typedef struct _ACPI_INTERFACE_STANDARD {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PGPE_CONNECT_VECTOR GpeConnectVector ;
	PGPE_DISCONNECT_VECTOR GpeDisconnectVector ;
	PGPE_ENABLE_EVENT GpeEnableEvent ;
	PGPE_DISABLE_EVENT GpeDisableEvent ;
	PGPE_CLEAR_STATUS GpeClearStatus ;
	PREGISTER_FOR_DEVICE_NOTIFICATIONS RegisterForDeviceNotifications ;
	PUNREGISTER_FOR_DEVICE_NOTIFICATIONS UnregisterForDeviceNotifications ;
} ACPI_INTERFACE_STANDARD , *  PACPI_INTERFACE_STANDARD ;

// #line 16255
typedef enum _ACPI_REG_TYPE {
	PM1a_ENABLE,
	PM1b_ENABLE,
	PM1a_STATUS,
	PM1b_STATUS,
	PM1a_CONTROL,
	PM1b_CONTROL,
	GP_STATUS,
	GP_ENABLE,
	SMI_CMD,
	MaxRegType
} ACPI_REG_TYPE , *  PACPI_REG_TYPE ;

typedef USHORT ( *  PREAD_ACPI_REGISTER )(ACPI_REG_TYPE AcpiReg , ULONG Register
	) ;

// #line 16272
typedef void ( *  PWRITE_ACPI_REGISTER )(ACPI_REG_TYPE AcpiReg , ULONG Register
	, USHORT Value ) ;

// #line 16278
typedef struct ACPI_REGS_INTERFACE_STANDARD {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PREAD_ACPI_REGISTER ReadAcpiRegister ;
	PWRITE_ACPI_REGISTER WriteAcpiRegister ;
} ACPI_REGS_INTERFACE_STANDARD , *  PACPI_REGS_INTERFACE_STANDARD ;

// #line 16300
typedef struct  {
	PVOID LinkNode ;
	ULONG StaticVector ;
	UCHAR Flags ;
} ROUTING_TOKEN , *  PROUTING_TOKEN ;

// #line 16314
typedef NTSTATUS ( *  PGET_INTERRUPT_ROUTING )(PDEVICE_OBJECT Pdo , 
					       ULONG *  Bus, ULONG *  PciSlot , 
					       UCHAR *  InterruptLine , 
					       UCHAR *  InterruptPin ,
					       UCHAR *  ClassCode , UCHAR *  SubClassCode , 
					       PDEVICE_OBJECT *  ParentPdo, 
					       ROUTING_TOKEN *  RoutingToken , 
					       UCHAR *  Flags ) ;
// #line 16329
typedef NTSTATUS ( *  PSET_INTERRUPT_ROUTING_TOKEN )(PDEVICE_OBJECT Pdo ,
	PROUTING_TOKEN RoutingToken ) ;

// #line 16336
typedef void ( *  PUPDATE_INTERRUPT_LINE )(PDEVICE_OBJECT Pdo , UCHAR
	LineRegister ) ;

// #line 16343
typedef struct _INT_ROUTE_INTERFACE_STANDARD {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PGET_INTERRUPT_ROUTING GetInterruptRouting ;
	PSET_INTERRUPT_ROUTING_TOKEN SetInterruptRoutingToken ;
	PUPDATE_INTERRUPT_LINE UpdateInterruptLine ;
} INT_ROUTE_INTERFACE_STANDARD , *  PINT_ROUTE_INTERFACE_STANDARD ;

// #line 16366
typedef struct _IO_ASSIGNED_RESOURCES {
	ULONG Count ;
	PASSIGNED_RESOURCE AssignedResources[1] ;
} IO_ASSIGNED_RESOURCES , *  PIO_ASSIGNED_RESOURCES ;

// #line 16381
// #line 16396
// #line 16403
// #line 16409
// #line 16427

// #line 16490
typedef enum _IO_NOTIFICATION_EVENT_CATEGORY {
	EventCategoryReserved,
	EventCategoryHardwareProfileChange,
	EventCategoryDeviceInterfaceChange,
	EventCategoryTargetDeviceChange
} IO_NOTIFICATION_EVENT_CATEGORY ;

// #line 16504
typedef NTSTATUS ( *  PDRIVER_NOTIFICATION_CALLBACK_ROUTINE )(PVOID NotificationStructure , 
							      PVOID Context ) ;
							      

// #line 16512
// #line 16524
// #line 16530
// #line 16537
typedef void ( *  PDEVICE_CHANGE_COMPLETE_CALLBACK )(PVOID Context ) ;

// #line 16543
// #line 16559

// #line 16573
typedef enum _ARBITER_ACTION {
	ArbiterActionTestAllocation,
	ArbiterActionRetestAllocation,
	ArbiterActionCommitAllocation,
	ArbiterActionRollbackAllocation,
	ArbiterActionQueryAllocatedResources,
	ArbiterActionWriteReservedResources,
	ArbiterActionQueryConflict,
	ArbiterActionQueryArbitrate,
	ArbiterActionAddReserved,
	ArbiterActionBootAllocation
} ARBITER_ACTION , *  PARBITER_ACTION ;

typedef struct _ARBITER_CONFLICT_INFO {
	PDEVICE_OBJECT OwningObject ;
	ULONGLONG Start ;
	ULONGLONG End ;
} ARBITER_CONFLICT_INFO , *  PARBITER_CONFLICT_INFO ;

// #line 16608
typedef struct _ARBITER_PARAMETERS {
	union  {
		struct  {
			PLIST_ENTRY ArbitrationList ;
			ULONG AllocateFromCount ;
			PCM_PARTIAL_RESOURCE_DESCRIPTOR AllocateFrom ;
		} TestAllocation ;
		struct  {
			PLIST_ENTRY ArbitrationList ;
			ULONG AllocateFromCount ;
			PCM_PARTIAL_RESOURCE_DESCRIPTOR AllocateFrom ;
		} RetestAllocation ;
		struct  {
			PLIST_ENTRY ArbitrationList ;
		} BootAllocation ;
		struct  {
			PCM_PARTIAL_RESOURCE_LIST *  AllocatedResources ;
		} QueryAllocatedResources ;
		struct  {
			PDEVICE_OBJECT PhysicalDeviceObject ;
			PIO_RESOURCE_DESCRIPTOR ConflictingResource ;
			PULONG ConflictCount ;
			PARBITER_CONFLICT_INFO *  Conflicts ;
		} QueryConflict ;
		struct  {
			PLIST_ENTRY ArbitrationList ;
		} QueryArbitrate ;
		struct  {
			PDEVICE_OBJECT ReserveDevice ;
		} AddReserved ;
	} Parameters ;
} ARBITER_PARAMETERS , *  PARBITER_PARAMETERS ;

// #line 16719
typedef enum _ARBITER_REQUEST_SOURCE {
	ArbiterRequestUndefined /* = - 1 */,
	ArbiterRequestLegacyReported,
	ArbiterRequestHalReported,
	ArbiterRequestLegacyAssigned,
	ArbiterRequestPnpDetected,
	ArbiterRequestPnpEnumerated
} ARBITER_REQUEST_SOURCE ;

// #line 16731
typedef enum _ARBITER_RESULT {
	ArbiterResultUndefined /* = - 1 */,
	ArbiterResultSuccess,
	ArbiterResultExternalConflict,
	ArbiterResultNullRequest
} ARBITER_RESULT ;

// #line 16748

// #line 16761
typedef struct _ARBITER_LIST_ENTRY {
	LIST_ENTRY ListEntry ;
	ULONG AlternativeCount ;
	PIO_RESOURCE_DESCRIPTOR Alternatives ;
	PDEVICE_OBJECT PhysicalDeviceObject ;
	ARBITER_REQUEST_SOURCE RequestSource ;
	ULONG Flags ;
	LONG_PTR WorkSpace ;
	INTERFACE_TYPE InterfaceType ;
	ULONG SlotNumber ;
	ULONG BusNumber ;
	PCM_PARTIAL_RESOURCE_DESCRIPTOR Assignment ;
	PIO_RESOURCE_DESCRIPTOR SelectedAlternative ;
	ARBITER_RESULT Result ;
} ARBITER_LIST_ENTRY , *  PARBITER_LIST_ENTRY ;

// #line 16832
typedef NTSTATUS ( *  PARBITER_HANDLER )(PVOID Context , ARBITER_ACTION Action ,
	PARBITER_PARAMETERS Parameters ) ;

// #line 16853
typedef struct _ARBITER_INTERFACE {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PARBITER_HANDLER ArbiterHandler ;
	ULONG Flags ;
} ARBITER_INTERFACE , *  PARBITER_INTERFACE ;

// #line 16880
typedef enum _RESOURCE_TRANSLATION_DIRECTION {
	TranslateChildToParent,
	TranslateParentToChild
} RESOURCE_TRANSLATION_DIRECTION ;

// #line 16889
typedef NTSTATUS ( *  PTRANSLATE_RESOURCE_HANDLER )(PVOID Context ,
	PCM_PARTIAL_RESOURCE_DESCRIPTOR Source , RESOURCE_TRANSLATION_DIRECTION
	Direction , ULONG AlternativesCount , IO_RESOURCE_DESCRIPTOR
	Alternatives[] , PDEVICE_OBJECT PhysicalDeviceObject ,
	PCM_PARTIAL_RESOURCE_DESCRIPTOR Target ) ;

// #line 16901
typedef NTSTATUS ( *  PTRANSLATE_RESOURCE_REQUIREMENTS_HANDLER )(PVOID Context ,
	PIO_RESOURCE_DESCRIPTOR Source , PDEVICE_OBJECT PhysicalDeviceObject ,
	PULONG TargetCount , PIO_RESOURCE_DESCRIPTOR *  Target ) ;

// #line 16915
typedef struct _TRANSLATOR_INTERFACE {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PTRANSLATE_RESOURCE_HANDLER TranslateResources ;
	PTRANSLATE_RESOURCE_REQUIREMENTS_HANDLER TranslateResourceRequirements ;
} TRANSLATOR_INTERFACE , *  PTRANSLATOR_INTERFACE ;

// #line 16931
typedef NTSTATUS ( *  PLEGACY_DEVICE_DETECTION_HANDLER )(PVOID Context ,
	INTERFACE_TYPE LegacyBusType , ULONG BusNumber , ULONG SlotNumber ,
	PDEVICE_OBJECT *  PhysicalDeviceObject ) ;

// #line 16945
typedef struct _LEGACY_DEVICE_DETECTION_INTERFACE {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PLEGACY_DEVICE_DETECTION_HANDLER LegacyDeviceDetection ;
} LEGACY_DEVICE_DETECTION_INTERFACE , *  PLEGACY_DEVICE_DETECTION_INTERFACE ;

// #line 16959
typedef struct _PLUGPLAY_NOTIFICATION_HEADER {
	USHORT Version ;
	USHORT Size ;
	GUID Event ;
} PLUGPLAY_NOTIFICATION_HEADER , *  PPLUGPLAY_NOTIFICATION_HEADER ;

// #line 16972
typedef struct _HWPROFILE_CHANGE_NOTIFICATION {
	USHORT Version ;
	USHORT Size ;
	GUID Event ;
} HWPROFILE_CHANGE_NOTIFICATION , *  PHWPROFILE_CHANGE_NOTIFICATION ;

// #line 16986
typedef struct _DEVICE_INTERFACE_CHANGE_NOTIFICATION {
	USHORT Version ;
	USHORT Size ;
	GUID Event ;
	GUID InterfaceClassGuid ;
	PUNICODE_STRING SymbolicLinkName ;
} DEVICE_INTERFACE_CHANGE_NOTIFICATION , * 
	PDEVICE_INTERFACE_CHANGE_NOTIFICATION ;

// #line 17006
typedef struct _TARGET_DEVICE_REMOVAL_NOTIFICATION {
	USHORT Version ;
	USHORT Size ;
	GUID Event ;
	PFILE_OBJECT FileObject ;
} TARGET_DEVICE_REMOVAL_NOTIFICATION , *  PTARGET_DEVICE_REMOVAL_NOTIFICATION ;

// #line 17026
typedef struct _TARGET_DEVICE_CUSTOM_NOTIFICATION {
	USHORT Version ;
	USHORT Size ;
	GUID Event ;
	PFILE_OBJECT FileObject ;
	LONG NameBufferOffset ;
	UCHAR CustomDataBuffer[1] ;
} TARGET_DEVICE_CUSTOM_NOTIFICATION , *  PTARGET_DEVICE_CUSTOM_NOTIFICATION ;

// #line 17054
typedef struct _DEVICE_DESCRIPTION {
	ULONG Version ;
	BOOLEAN Master ;
	BOOLEAN ScatterGather ;
	BOOLEAN DemandMode ;
	BOOLEAN AutoInitialize ;
	BOOLEAN Dma32BitAddresses ;
	BOOLEAN IgnoreCount ;
	BOOLEAN Reserved1 ;
	BOOLEAN Dma64BitAddresses ;
	ULONG BusNumber ;
	ULONG DmaChannel ;
	INTERFACE_TYPE InterfaceType ;
	DMA_WIDTH DmaWidth ;
	DMA_SPEED DmaSpeed ;
	ULONG MaximumLength ;
	ULONG DmaPort ;
} DEVICE_DESCRIPTION , *  PDEVICE_DESCRIPTION ;

// #line 17086
typedef BOOLEAN ( *  PHAL_RESET_DISPLAY_PARAMETERS )(ULONG Columns , ULONG Rows
	) ;

// #line 17124
  NTSTATUS HalAssignSlotResources(PUNICODE_STRING
	RegistryPath , PUNICODE_STRING DriverClassName , PDRIVER_OBJECT
	DriverObject , PDEVICE_OBJECT DeviceObject , INTERFACE_TYPE BusType ,
	ULONG BusNumber , ULONG SlotNumber , PCM_RESOURCE_LIST * 
	AllocatedResources ) ;
// #line 17137
// #line 17148
// #line 17159
// #line 17170
// #line 17196
// #line 17333
typedef void ( *  PDEVICE_CONTROL_COMPLETION )(struct _DEVICE_CONTROL_CONTEXT * 
	ControlContext ) ;

// #line 17339
typedef struct _DEVICE_CONTROL_CONTEXT {
	NTSTATUS Status ;
	PDEVICE_HANDLER_OBJECT DeviceHandler ;
	PDEVICE_OBJECT DeviceObject ;
	ULONG ControlCode ;
	PVOID Buffer ;
	PULONG BufferLength ;
	PVOID Context ;
} DEVICE_CONTROL_CONTEXT , *  PDEVICE_CONTROL_CONTEXT ;

typedef PBUS_HANDLER (  *  pHalHandlerForBus )(INTERFACE_TYPE InterfaceType ,
						       ULONG BusNumber ) ;

// #line 17355
typedef void (  *  pHalReferenceBusHandler )(PBUS_HANDLER BusHandler ) ;

// #line 17365
typedef enum _HAL_QUERY_INFORMATION_CLASS {
	HalInstalledBusInformation,
	HalProfileSourceInformation,
	HalInformationClassUnused1,
	HalPowerInformation,
	HalProcessorSpeedInformation,
	HalCallbackInformation,
	HalMapRegisterInformation,
	HalMcaLogInformation,
	HalFrameBufferCachingInformation,
	HalDisplayBiosInformation,
	HalProcessorFeatureInformation
} HAL_QUERY_INFORMATION_CLASS , *  PHAL_QUERY_INFORMATION_CLASS ;

// #line 17381
typedef enum _HAL_SET_INFORMATION_CLASS {
	HalProfileSourceInterval,
	HalProfileSourceInterruptHandler,
	HalMcaRegisterDriver
} HAL_SET_INFORMATION_CLASS , *  PHAL_SET_INFORMATION_CLASS ;

// #line 17388
typedef NTSTATUS ( *  pHalQuerySystemInformation )(HAL_QUERY_INFORMATION_CLASS
	InformationClass , ULONG BufferSize , PVOID Buffer , PULONG
	ReturnedLength ) ;

// #line 17397
// #line 17405
typedef NTSTATUS ( *  pHalSetSystemInformation )(HAL_SET_INFORMATION_CLASS
	InformationClass , ULONG BufferSize , PVOID Buffer ) ;

// #line 17420
typedef void (  *  pHalExamineMBR )(PDEVICE_OBJECT DeviceObject , ULONG
	SectorSize , ULONG MBRTypeIdentifier , PVOID *  Buffer ) ;

// #line 17429
typedef void (  *  pHalIoAssignDriveLetters
	)(struct _LOADER_PARAMETER_BLOCK *  LoaderBlock , PSTRING NtDeviceName ,
	PUCHAR NtSystemPath , PSTRING NtSystemPathString ) ;

// #line 17438
typedef NTSTATUS (  *  pHalIoReadPartitionTable )(PDEVICE_OBJECT
	DeviceObject , ULONG SectorSize , BOOLEAN ReturnRecognizedPartitions ,
	struct _DRIVE_LAYOUT_INFORMATION *  *  PartitionBuffer ) ;

// #line 17447
typedef NTSTATUS (  *  pHalIoSetPartitionInformation )(PDEVICE_OBJECT
	DeviceObject , ULONG SectorSize , ULONG PartitionNumber , ULONG
	PartitionType ) ;

// #line 17456
typedef NTSTATUS (  *  pHalIoWritePartitionTable )(PDEVICE_OBJECT
	DeviceObject , ULONG SectorSize , ULONG SectorsPerTrack , ULONG
	NumberOfHeads , struct _DRIVE_LAYOUT_INFORMATION *  PartitionBuffer ) ;

// #line 17466
typedef NTSTATUS ( *  pHalQueryBusSlots )(PBUS_HANDLER BusHandler , ULONG
	BufferSize , PULONG SlotNumbers , PULONG ReturnedLength ) ;

// #line 17475
typedef NTSTATUS ( *  pHalInitPnpDriver )(void  ) ;

// #line 17486
typedef struct _PM_DISPATCH_TABLE {
	ULONG Signature ;
	ULONG Version ;
	PVOID Function[1] ;
} PM_DISPATCH_TABLE , *  PPM_DISPATCH_TABLE ;

typedef NTSTATUS ( *  pHalInitPowerManagement )(PPM_DISPATCH_TABLE
	PmDriverDispatchTable , PPM_DISPATCH_TABLE *  PmHalDispatchTable ) ;

// #line 17505
typedef struct _DMA_ADAPTER *  ( *  pHalGetDmaAdapter )(PVOID Context ,
	struct _DEVICE_DESCRIPTION *  DeviceDescriptor , PULONG
	NumberOfMapRegisters ) ;


// #line 17520
typedef NTSTATUS ( *  pHalGetInterruptTranslator )(INTERFACE_TYPE
	ParentInterfaceType , ULONG ParentBusNumber , INTERFACE_TYPE
	BridgeInterfaceType , USHORT Size , USHORT Version ,
	PTRANSLATOR_INTERFACE Translator , PULONG BridgeBusNumber ) ;


// #line 17543
typedef BOOLEAN ( *  pHalTranslateBusAddress )(INTERFACE_TYPE InterfaceType ,
	ULONG BusNumber , PHYSICAL_ADDRESS BusAddress , PULONG AddressSpace ,
	PPHYSICAL_ADDRESS TranslatedAddress ) ;

// #line 17553
typedef NTSTATUS ( *  pHalAssignSlotResources )(PUNICODE_STRING RegistryPath ,
	PUNICODE_STRING DriverClassName , PDRIVER_OBJECT DriverObject ,
	PDEVICE_OBJECT DeviceObject , INTERFACE_TYPE BusType , ULONG BusNumber ,
	ULONG SlotNumber , PCM_RESOURCE_LIST *  AllocatedResources ) ;

// #line 17566
typedef void ( *  pHalHaltSystem )(void  ) ;

// #line 17572
typedef void ( *  pHalResetDisplay )(void  ) ;

// #line 17578
typedef BOOLEAN ( *  pHalFindBusAddressTranslation )(PHYSICAL_ADDRESS BusAddress
	, PULONG AddressSpace , PPHYSICAL_ADDRESS TranslatedAddress , PULONG_PTR
	Context , BOOLEAN NextBus ) ;

// #line 17588
typedef struct  {
	ULONG Version ;
	pHalQuerySystemInformation HalQuerySystemInformation ;
	pHalSetSystemInformation HalSetSystemInformation ;
	pHalQueryBusSlots HalQueryBusSlots ;
	ULONG Spare1 ;
	pHalExamineMBR HalExamineMBR ;
	pHalIoAssignDriveLetters HalIoAssignDriveLetters ;
	pHalIoReadPartitionTable HalIoReadPartitionTable ;
	pHalIoSetPartitionInformation HalIoSetPartitionInformation ;
	pHalIoWritePartitionTable HalIoWritePartitionTable ;
	pHalHandlerForBus HalReferenceHandlerForBus ;
	pHalReferenceBusHandler HalReferenceBusHandler ;
	pHalReferenceBusHandler HalDereferenceBusHandler ;
	pHalInitPnpDriver HalInitPnpDriver ;
	pHalInitPowerManagement HalInitPowerManagement ;
	pHalGetDmaAdapter HalGetDmaAdapter ;
	pHalGetInterruptTranslator HalGetInterruptTranslator ;
} HAL_DISPATCH , *  PHAL_DISPATCH ;

// #line 17613
extern PHAL_DISPATCH HalDispatchTable ;

// #line 17650
typedef struct _HAL_BUS_INFORMATION {
	INTERFACE_TYPE BusType ;
	BUS_DATA_TYPE ConfigurationType ;
	ULONG BusNumber ;
	ULONG Reserved ;
} HAL_BUS_INFORMATION , *  PHAL_BUS_INFORMATION ;

// #line 17658
typedef struct _HAL_PROFILE_SOURCE_INFORMATION {
	KPROFILE_SOURCE Source ;
	BOOLEAN Supported ;
	ULONG Interval ;
} HAL_PROFILE_SOURCE_INFORMATION , *  PHAL_PROFILE_SOURCE_INFORMATION ;

// #line 17665
typedef struct _HAL_PROFILE_SOURCE_INTERVAL {
	KPROFILE_SOURCE Source ;
	ULONG_PTR Interval ;
} HAL_PROFILE_SOURCE_INTERVAL , *  PHAL_PROFILE_SOURCE_INTERVAL ;

// #line 17671
typedef enum _HAL_DISPLAY_BIOS_INFORMATION {
	HalDisplayInt10Bios,
	HalDisplayEmulatedBios,
	HalDisplayNoBios
} HAL_DISPLAY_BIOS_INFORMATION , *  PHAL_DISPLAY_BIOS_INFORMATION ;

// #line 17678
typedef struct _HAL_POWER_INFORMATION {
	ULONG TBD ;
} HAL_POWER_INFORMATION , *  PHAL_POWER_INFORMATION ;

// #line 17683
typedef struct _HAL_PROCESSOR_SPEED_INFO {
	ULONG TBD ;
} HAL_PROCESSOR_SPEED_INFORMATION , *  PHAL_PROCESSOR_SPEED_INFORMATION ;

// #line 17688
typedef struct _HAL_CALLBACKS {
	PCALLBACK_OBJECT___0 SetSystemInformation ;
	PCALLBACK_OBJECT___0 BusCheck ;
} HAL_CALLBACKS , *  PHAL_CALLBACKS ;

// #line 17694
typedef struct _HAL_PROCESSOR_FEATURE {
	ULONG UsableFeatureBits ;
} HAL_PROCESSOR_FEATURE ;

// #line 17706
typedef union _MCI_ADDR {
	struct  {
		ULONG Address ;
		ULONG Reserved ;
	}  ;
	ULONGLONG QuadPart ;
} MCI_ADDR , *  PMCI_ADDR ;

// #line 17716
typedef enum  {
	HAL_MCE_RECORD,
	HAL_MCA_RECORD
} MCA_EXCEPTION_TYPE ;

// #line 17726
typedef struct _MCA_EXCEPTION {
	ULONG VersionNumber ;
	MCA_EXCEPTION_TYPE ExceptionType ;
	LARGE_INTEGER TimeStamp ;
	ULONG ProcessorNumber ;
	union  {
		struct  {
			UCHAR BankNumber ;
			MCI_STATS Status ;
			MCI_ADDR Address ;
			ULONGLONG Misc ;
		} Mca ;
		struct  {
			ULONGLONG Address ;
			ULONGLONG Type ;
		} Mce ;
	} u ;
} MCA_EXCEPTION , *  PMCA_EXCEPTION ;

// #line 17752
typedef void ( *  PDRIVER_EXCPTN_CALLBACK )(PVOID Context , PMCA_EXCEPTION
	BankLog ) ;

// #line 17762
typedef struct _MCA_DRIVER_INFO {
	PDRIVER_EXCPTN_CALLBACK ExceptionCallback ;
	PKDEFERRED_ROUTINE DpcCallback ;
	PVOID DeviceContext ;
} MCA_DRIVER_INFO , *  PMCA_DRIVER_INFO ;

// #line 17772
typedef struct _SCATTER_GATHER_ELEMENT {
	PHYSICAL_ADDRESS Address ;
	ULONG Length ;
	ULONG_PTR Reserved ;
} SCATTER_GATHER_ELEMENT , *  PSCATTER_GATHER_ELEMENT ;


// #pragma warning(disable:4200)
// #line 17779
typedef struct _SCATTER_GATHER_LIST {
	ULONG NumberOfElements ;
	ULONG_PTR Reserved ;
	SCATTER_GATHER_ELEMENT Elements[] ;
} SCATTER_GATHER_LIST , *  PSCATTER_GATHER_LIST ;

// #line 17784

// #pragma warning(default:4200)
// #line 17788
typedef struct _DMA_OPERATIONS *  PDMA_OPERATIONS ;

typedef struct _DMA_ADAPTER {
	USHORT Version ;
	USHORT Size ;
	PDMA_OPERATIONS DmaOperations ;
} DMA_ADAPTER , *  PDMA_ADAPTER ;

// #line 17797
typedef void ( *  PPUT_DMA_ADAPTER )(PDMA_ADAPTER DmaAdapter ) ;

// #line 17801
typedef PVOID ( *  PALLOCATE_COMMON_BUFFER )(PDMA_ADAPTER DmaAdapter , ULONG
	Length , PPHYSICAL_ADDRESS LogicalAddress , BOOLEAN CacheEnabled ) ;

// #line 17808
typedef void ( *  PFREE_COMMON_BUFFER )(PDMA_ADAPTER DmaAdapter , ULONG Length ,
	PHYSICAL_ADDRESS LogicalAddress , PVOID VirtualAddress , BOOLEAN
	CacheEnabled ) ;

// #line 17816
typedef NTSTATUS ( *  PALLOCATE_ADAPTER_CHANNEL )(PDMA_ADAPTER DmaAdapter ,
	PDEVICE_OBJECT DeviceObject , ULONG NumberOfMapRegisters ,
	PDRIVER_CONTROL ExecutionRoutine , PVOID Context ) ;

// #line 17824
typedef BOOLEAN ( *  PFLUSH_ADAPTER_BUFFERS )(PDMA_ADAPTER DmaAdapter , PMDL Mdl
	, PVOID MapRegisterBase , PVOID CurrentVa , ULONG Length , BOOLEAN
	WriteToDevice ) ;

// #line 17833
typedef void ( *  PFREE_ADAPTER_CHANNEL )(PDMA_ADAPTER DmaAdapter ) ;

// #line 17837
typedef void ( *  PFREE_MAP_REGISTERS )(PDMA_ADAPTER DmaAdapter , PVOID
	MapRegisterBase , ULONG NumberOfMapRegisters ) ;

// #line 17843
typedef PHYSICAL_ADDRESS ( *  PMAP_TRANSFER )(PDMA_ADAPTER DmaAdapter , PMDL Mdl
	, PVOID MapRegisterBase , PVOID CurrentVa , PULONG Length , BOOLEAN
	WriteToDevice ) ;

// #line 17852
typedef ULONG ( *  PGET_DMA_ALIGNMENT )(PDMA_ADAPTER DmaAdapter ) ;

// #line 17856
typedef ULONG ( *  PREAD_DMA_COUNTER )(PDMA_ADAPTER DmaAdapter ) ;

// #line 17860
typedef void ( *  PDRIVER_LIST_CONTROL )(struct _DEVICE_OBJECT *  DeviceObject ,
	struct _IRP *  Irp , PSCATTER_GATHER_LIST ScatterGather , PVOID Context
	) ;

// #line 17868
typedef NTSTATUS ( *  PGET_SCATTER_GATHER_LIST )(PDMA_ADAPTER DmaAdapter ,
	PDEVICE_OBJECT DeviceObject , PMDL Mdl , PVOID CurrentVa , ULONG Length
	, PDRIVER_LIST_CONTROL ExecutionRoutine , PVOID Context , BOOLEAN
	WriteToDevice ) ;

// #line 17880
typedef void ( *  PPUT_SCATTER_GATHER_LIST )(PDMA_ADAPTER DmaAdapter ,
	PSCATTER_GATHER_LIST ScatterGather , BOOLEAN WriteToDevice ) ;

// #line 17887
typedef struct _DMA_OPERATIONS {
	ULONG Size ;
	PPUT_DMA_ADAPTER PutDmaAdapter ;
	PALLOCATE_COMMON_BUFFER AllocateCommonBuffer ;
	PFREE_COMMON_BUFFER FreeCommonBuffer ;
	PALLOCATE_ADAPTER_CHANNEL AllocateAdapterChannel ;
	PFLUSH_ADAPTER_BUFFERS FlushAdapterBuffers ;
	PFREE_ADAPTER_CHANNEL FreeAdapterChannel ;
	PFREE_MAP_REGISTERS FreeMapRegisters ;
	PMAP_TRANSFER MapTransfer ;
	PGET_DMA_ALIGNMENT GetDmaAlignment ;
	PREAD_DMA_COUNTER ReadDmaCounter ;
	PGET_SCATTER_GATHER_LIST GetScatterGatherList ;
	PPUT_SCATTER_GATHER_LIST PutScatterGatherList ;
} DMA_OPERATIONS ;

// #line 18228
// #line 18235
typedef void ( *  PREQUEST_POWER_COMPLETE )(PDEVICE_OBJECT DeviceObject , UCHAR
	MinorFunction , POWER_STATE PowerState , PVOID Context ,
	PIO_STATUS_BLOCK IoStatus ) ;

// #line 18245
// #line 18256
// #line 18263
NTSTATUS PoCallDriver(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;	
// #line 18278
void PoStartNextPowerIrp(PIRP Irp ) ;
// #line 18285
// #line 18321
typedef struct _OBJECT_HANDLE_INFORMATION {
	ULONG HandleAttributes ;
	ACCESS_MASK GrantedAccess ;
} OBJECT_HANDLE_INFORMATION , *  POBJECT_HANDLE_INFORMATION ;

NTSTATUS ObReferenceObjectByHandle(HANDLE Handle ,
				   ACCESS_MASK DesiredAccess , POBJECT_TYPE ObjectType , 
				   KPROCESSOR_MODE AccessMode , PVOID *  Object , 
				   POBJECT_HANDLE_INFORMATION HandleInformation ) ;   
// #line 18342
// #line 18402
typedef struct _PCI_SLOT_NUMBER {
	union  {
		struct  {
			ULONG DeviceNumber  /*:5*/;
			ULONG FunctionNumber  /*:3*/;
			ULONG Reserved  /*:24*/;
		} bits ;
		ULONG AsULONG ;
	} u ;
} PCI_SLOT_NUMBER , *  PPCI_SLOT_NUMBER ;


NTSTATUS KeDelayExecutionThread(KPROCESSOR_MODE WaitMode ,
				BOOLEAN Alertable , PLARGE_INTEGER Interval );
LONG KeSetEvent(PRKEVENT Event , KPRIORITY Increment , BOOLEAN Wait );
	
    

// #line 18418
typedef struct _PCI_COMMON_CONFIG {
	USHORT VendorID ;
	USHORT DeviceID ;
	USHORT Command ;
	USHORT Status ;
	UCHAR RevisionID ;
	UCHAR ProgIf ;
	UCHAR SubClass ;
	UCHAR BaseClass ;
	UCHAR CacheLineSize ;
	UCHAR LatencyTimer ;
	UCHAR HeaderType ;
	UCHAR BIST ;
	union  {
		struct _PCI_HEADER_TYPE_0 {
			ULONG BaseAddresses[6] ;
			ULONG CIS ;
			USHORT SubVendorID ;
			USHORT SubSystemID ;
			ULONG ROMBaseAddress ;
			UCHAR CapabilitiesPtr ;
			UCHAR Reserved1[3] ;
			ULONG Reserved2 ;
			UCHAR InterruptLine ;
			UCHAR InterruptPin ;
			UCHAR MinimumGrant ;
			UCHAR MaximumLatency ;
		} type0 ;
		struct _PCI_HEADER_TYPE_1 {
			ULONG BaseAddresses[2] ;
			UCHAR PrimaryBus ;
			UCHAR SecondaryBus ;
			UCHAR SubordinateBus ;
			UCHAR SecondaryLatency ;
			UCHAR IOBase ;
			UCHAR IOLimit ;
			USHORT SecondaryStatus ;
			USHORT MemoryBase ;
			USHORT MemoryLimit ;
			USHORT PrefetchBase ;
			USHORT PrefetchLimit ;
			ULONG PrefetchBaseUpper32 ;
			ULONG PrefetchLimitUpper32 ;
			USHORT IOBaseUpper16 ;
			USHORT IOLimitUpper16 ;
			UCHAR CapabilitiesPtr ;
			UCHAR Reserved1[3] ;
			ULONG ROMBaseAddress ;
			UCHAR InterruptLine ;
			UCHAR InterruptPin ;
			USHORT BridgeControl ;
		} type1 ;
		struct _PCI_HEADER_TYPE_2 {
			ULONG SocketRegistersBaseAddress ;
			UCHAR CapabilitiesPtr ;
			UCHAR Reserved ;
			USHORT SecondaryStatus ;
			UCHAR PrimaryBus ;
			UCHAR SecondaryBus ;
			UCHAR SubordinateBus ;
			UCHAR SecondaryLatency ;
			struct  {
				ULONG Base ;
				ULONG Limit ;
			} Range[4] ;
			UCHAR InterruptLine ;
			UCHAR InterruptPin ;
			USHORT BridgeControl ;
		} type2 ;
	} u ;
	UCHAR DeviceSpecific[192] ;
} PCI_COMMON_CONFIG , *  PPCI_COMMON_CONFIG ;

// #line 18591
typedef struct _PCI_CAPABILITIES_HEADER {
	UCHAR CapabilityID ;
	UCHAR Next ;
} PCI_CAPABILITIES_HEADER , *  PPCI_CAPABILITIES_HEADER ;

// #line 18600
typedef struct _PCI_PMC {
	UCHAR Version  /*:3*/;
	UCHAR PMEClock  /* :1*/;
	UCHAR Rsvd1  /* :1*/;
	UCHAR DeviceSpecificInitialization  /* :1*/;
	UCHAR Rsvd2  /*:2*/;
	struct _PM_SUPPORT {
		UCHAR Rsvd2  /* :1*/;
		UCHAR D1  /* :1*/;
		UCHAR D2  /* :1*/;
		UCHAR PMED0  /* :1*/;
		UCHAR PMED1  /* :1*/;
		UCHAR PMED2  /* :1*/;
		UCHAR PMED3Hot  /* :1*/;
		UCHAR PMED3Cold  /* :1*/;
	} Support ;
} PCI_PMC , *  PPCI_PMC ;

typedef struct _PCI_PMCSR {
	USHORT PowerState  /*:2*/;
	USHORT Rsvd1  /*:6*/;
	USHORT PMEEnable  /* :1*/;
	USHORT DataSelect  /*:4*/;
	USHORT DataScale  /*:2*/;
	USHORT PMEStatus  /* :1*/;
} PCI_PMCSR , *  PPCI_PMCSR ;

// #line 18628
typedef struct _PCI_PMCSR_BSE {
	UCHAR Rsvd1  /*:6*/;
	UCHAR D3HotSupportsStopClock  /* :1*/;
	UCHAR BusPowerClockControlEnabled  /* :1*/;
} PCI_PMCSR_BSE , *  PPCI_PMCSR_BSE ;

// #line 18635
typedef struct _PCI_PM_CAPABILITY {
	PCI_CAPABILITIES_HEADER Header ;
	union  {
		PCI_PMC Capabilities ;
		USHORT AsUSHORT ;
	} PMC ;
	union  {
		PCI_PMCSR ControlStatus ;
		USHORT AsUSHORT ;
	} PMCSR ;
	union  {
		PCI_PMCSR_BSE BridgeSupport ;
		UCHAR AsUCHAR ;
	} PMCSR_BSE ;
	UCHAR Data ;
} PCI_PM_CAPABILITY , *  PPCI_PM_CAPABILITY ;

// #line 18679
typedef struct _PCI_AGP_CAPABILITY {
	PCI_CAPABILITIES_HEADER Header ;
	USHORT Minor  /*:4*/;
	USHORT Major  /*:4*/;
	USHORT Rsvd1  /* : 8 */;
	struct _PCI_AGP_STATUS {
		ULONG Rate  /*:3*/;
		ULONG Rsvd1  /* :1*/;
		ULONG FastWrite  /* :1*/;
		ULONG FourGB  /* :1*/;
		ULONG Rsvd2  /*:3*/;
		ULONG SideBandAddressing  /* :1*/;
		ULONG Rsvd3  /* : 14 */;
		ULONG RequestQueueDepthMaximum /*  : 8 */;
	} AGPStatus ;
	struct _PCI_AGP_COMMAND {
		ULONG Rate  /*:3*/;
		ULONG Rsvd1  /* :1*/;
		ULONG FastWriteEnable  /* :1*/;
		ULONG FourGBEnable  /* :1*/;
		ULONG Rsvd2  /*:2*/;
		ULONG AGPEnable  /* :1*/;
		ULONG SBAEnable  /* :1*/;
		ULONG Rsvd3  /* : 14 */;
		ULONG RequestQueueDepth /*  : 8 */;
	} AGPCommand ;
} PCI_AGP_CAPABILITY , *  PPCI_AGP_CAPABILITY ;

// #line 18720
typedef struct _PCI_MSI_CAPABILITY {
	PCI_CAPABILITIES_HEADER Header ;
	struct _PCI_MSI_MESSAGE_CONTROL {
		USHORT MSIEnable  /* :1*/;
		USHORT MultipleMessageCapable  /*:3*/;
		USHORT MultipleMessageEnable  /*:3*/;
		USHORT CapableOf64Bits  /* :1*/;
		USHORT Reserved /*  : 8 */;
	} MessageControl ;
	union  {
		struct _PCI_MSI_MESSAGE_ADDRESS {
			ULONG_PTR Reserved  /*:2*/;
			ULONG_PTR Address  /* : 30 */;
		} Register ;
		ULONG_PTR Raw ;
	} MessageAddress ;
	union  {
		struct _PCI_MSI_64BIT_DATA {
			ULONG MessageUpperAddress ;
			USHORT MessageData ;
		} Bit64 ;
		struct _PCI_MSI_32BIT_DATA {
			USHORT MessageData ;
			ULONG Unused ;
		} Bit32 ;
	} Data ;
} PCI_MSI_CAPABILITY , *  PPCI_PCI_CAPABILITY ;

// #line 18946
typedef void ( *  PciPin2Line )(struct _BUS_HANDLER *  BusHandler ,
	struct _BUS_HANDLER *  RootHandler , PCI_SLOT_NUMBER SlotNumber ,
	PPCI_COMMON_CONFIG PciData ) ;

// #line 18954
typedef void ( *  PciLine2Pin )(struct _BUS_HANDLER *  BusHandler ,
	struct _BUS_HANDLER *  RootHandler , PCI_SLOT_NUMBER SlotNumber ,
	PPCI_COMMON_CONFIG PciNewData , PPCI_COMMON_CONFIG PciOldData ) ;

// #line 18963
typedef void ( *  PciReadWriteConfig )(struct _BUS_HANDLER *  BusHandler ,
	PCI_SLOT_NUMBER Slot , PVOID Buffer , ULONG Offset , ULONG Length ) ;

// #line 18975
typedef struct _PCIBUSDATA {
	ULONG Tag ;
	ULONG Version ;
	PciReadWriteConfig ReadConfig ;
	PciReadWriteConfig WriteConfig ;
	PciPin2Line Pin2Line ;
	PciLine2Pin Line2Pin ;
	PCI_SLOT_NUMBER ParentSlot ;
	PVOID Reserved[4] ;
} PCIBUSDATA , *  PPCIBUSDATA ;

typedef ULONG ( *  PCI_READ_WRITE_CONFIG )(PVOID Context , UCHAR BusOffset ,
	ULONG Slot , PVOID Buffer , ULONG Offset , ULONG Length ) ;

// #line 18995
typedef void ( *  PCI_PIN_TO_LINE )(PVOID Context , PPCI_COMMON_CONFIG PciData )
	;

// #line 19000
typedef void ( *  PCI_LINE_TO_PIN )(PVOID Context , PPCI_COMMON_CONFIG
	PciNewData , PPCI_COMMON_CONFIG PciOldData ) ;

// #line 19006
typedef struct _PCI_BUS_INTERFACE_STANDARD {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PCI_READ_WRITE_CONFIG ReadConfig ;
	PCI_READ_WRITE_CONFIG WriteConfig ;
	PCI_PIN_TO_LINE PinToLine ;
	PCI_LINE_TO_PIN LineToPin ;
} PCI_BUS_INTERFACE_STANDARD , *  PPCI_BUS_INTERFACE_STANDARD ;

// #line 19028
typedef BOOLEAN ( *  PPCI_IS_DEVICE_PRESENT )(USHORT VendorID , USHORT DeviceID
	, UCHAR RevisionID , USHORT SubVendorID , USHORT SubSystemID , ULONG
	Flags ) ;

// #line 19043
typedef struct _PCI_DEVICE_PRESENT_INTERFACE {
	USHORT Size ;
	USHORT Version ;
	PVOID Context ;
	PINTERFACE_REFERENCE InterfaceReference ;
	PINTERFACE_DEREFERENCE InterfaceDereference ;
	PPCI_IS_DEVICE_PRESENT IsDevicePresent ;
} PCI_DEVICE_PRESENT_INTERFACE , *  PPCI_DEVICE_PRESENT_INTERFACE ;

// #line 19066
/* extern */ POBJECT_TYPE *  IoFileObjectType ;
/* extern */ POBJECT_TYPE *  ExEventObjectType ;
/* extern */ POBJECT_TYPE *  ExSemaphoreObjectType ;
// #line 19074
// #line 19091
NTSTATUS   ZwClose(HANDLE Handle ) ;
// #line 43 "C:/NTDDK/inc/ntddscsi.h"
extern   GUID ScsiRawInterfaceGuid ;
extern   GUID WmiScsiAddressGuid ;

// #line 89
typedef struct _SCSI_PASS_THROUGH {
	USHORT Length ;
	UCHAR ScsiStatus ;
	UCHAR PathId ;
	UCHAR TargetId ;
	UCHAR Lun ;
	UCHAR CdbLength ;
	UCHAR SenseInfoLength ;
	UCHAR DataIn ;
	ULONG DataTransferLength ;
	ULONG TimeOutValue ;
	ULONG_PTR DataBufferOffset ;
	ULONG SenseInfoOffset ;
	UCHAR Cdb[16] ;
} SCSI_PASS_THROUGH , *  PSCSI_PASS_THROUGH ;

// #line 109
typedef struct _SCSI_PASS_THROUGH_DIRECT {
	USHORT Length ;
	UCHAR ScsiStatus ;
	UCHAR PathId ;
	UCHAR TargetId ;
	UCHAR Lun ;
	UCHAR CdbLength ;
	UCHAR SenseInfoLength ;
	UCHAR DataIn ;
	ULONG DataTransferLength ;
	ULONG TimeOutValue ;
	PVOID DataBuffer ;
	ULONG SenseInfoOffset ;
	UCHAR Cdb[16] ;
} SCSI_PASS_THROUGH_DIRECT , *  PSCSI_PASS_THROUGH_DIRECT ;

// #line 130
typedef struct _SCSI_BUS_DATA {
	UCHAR NumberOfLogicalUnits ;
	UCHAR InitiatorBusId ;
	ULONG InquiryDataOffset ;
} SCSI_BUS_DATA , *  PSCSI_BUS_DATA ;

// #line 141
typedef struct _SCSI_ADAPTER_BUS_INFO {
	UCHAR NumberOfBuses ;
	SCSI_BUS_DATA BusData[1] ;
} SCSI_ADAPTER_BUS_INFO , *  PSCSI_ADAPTER_BUS_INFO ;

// #line 151
typedef struct _SCSI_INQUIRY_DATA {
	UCHAR PathId ;
	UCHAR TargetId ;
	UCHAR Lun ;
	BOOLEAN DeviceClaimed ;
	ULONG InquiryDataLength ;
	ULONG NextInquiryDataOffset ;
	UCHAR InquiryData[1] ;
} SCSI_INQUIRY_DATA , *  PSCSI_INQUIRY_DATA ;

// #line 165
typedef struct _SRB_IO_CONTROL {
	ULONG HeaderLength ;
	UCHAR Signature[8] ;
	ULONG Timeout ;
	ULONG ControlCode ;
	ULONG ReturnCode ;
	ULONG Length ;
} SRB_IO_CONTROL , *  PSRB_IO_CONTROL ;

// #line 178
typedef struct _IO_SCSI_CAPABILITIES {
	ULONG Length ;
	ULONG MaximumTransferLength ;
	ULONG MaximumPhysicalPages ;
	ULONG SupportedAsynchronousEvents ;
	ULONG AlignmentMask ;
	BOOLEAN TaggedQueuing ;
	BOOLEAN AdapterScansDown ;
	BOOLEAN AdapterUsesPio ;
} IO_SCSI_CAPABILITIES , *  PIO_SCSI_CAPABILITIES ;

// #line 230
typedef struct _SCSI_ADDRESS {
	ULONG Length ;
	UCHAR PortNumber ;
	UCHAR PathId ;
	UCHAR TargetId ;
	UCHAR Lun ;
} SCSI_ADDRESS , *  PSCSI_ADDRESS ;

// #line 242
struct _ADAPTER_OBJECT ;

typedef struct _DUMP_POINTERS {
	struct _ADAPTER_OBJECT *  AdapterObject ;
	PVOID MappedRegisterBase ;
	PVOID DumpData ;
	PVOID CommonBufferVa ;
	LARGE_INTEGER CommonBufferPa ;
	ULONG CommonBufferSize ;
	BOOLEAN AllocateCommonBuffers ;
	UCHAR Spare1[3] ;
	PVOID DeviceObject ;
} DUMP_POINTERS , *  PDUMP_POINTERS ;

// #line 28 "C:/NTDDK/inc/ntddcdrm.h"

// #pragma once
// #line 44 "C:/NTDDK/inc/ntddstor.h"
extern   GUID DiskClassGuid ;
extern   GUID CdRomClassGuid ;
extern   GUID PartitionClassGuid ;
extern   GUID TapeClassGuid ;
extern   GUID WriteOnceDiskClassGuid ;
extern   GUID VolumeClassGuid ;
extern   GUID MediumChangerClassGuid ;
extern   GUID FloppyClassGuid ;
extern   GUID CdChangerClassGuid ;
extern   GUID StoragePortClassGuid ;

// #line 128
typedef struct _STORAGE_DEVICE_NUMBER {
	ULONG DeviceType ;
	ULONG DeviceNumber ;
	ULONG PartitionNumber ;
} STORAGE_DEVICE_NUMBER , *  PSTORAGE_DEVICE_NUMBER ;

// #line 154
typedef struct _STORAGE_BUS_RESET_REQUEST {
	UCHAR PathId ;
} STORAGE_BUS_RESET_REQUEST , *  PSTORAGE_BUS_RESET_REQUEST ;

// #line 168
typedef struct _PREVENT_MEDIA_REMOVAL {
	BOOLEAN PreventMediaRemoval ;
} PREVENT_MEDIA_REMOVAL , *  PPREVENT_MEDIA_REMOVAL ;

// #line 175
typedef struct _TAPE_STATISTICS {
	ULONG Version ;
	ULONG Flags ;
	LARGE_INTEGER RecoveredWrites ;
	LARGE_INTEGER UnrecoveredWrites ;
	LARGE_INTEGER RecoveredReads ;
	LARGE_INTEGER UnrecoveredReads ;
	UCHAR CompressionRatioReads ;
	UCHAR CompressionRatioWrites ;
} TAPE_STATISTICS , *  PTAPE_STATISTICS ;

// #line 193
typedef struct _TAPE_GET_STATISTICS {
	ULONG Operation ;
} TAPE_GET_STATISTICS , *  PTAPE_GET_STATISTICS ;

// #line 206
typedef enum _STORAGE_MEDIA_TYPE {
	DDS_4mm /* = 0x20 */,
	MiniQic,
	Travan,
	QIC,
	MP_8mm,
	AME_8mm,
	AIT1_8mm,
	DLT,
	NCTP,
	IBM_3480,
	IBM_3490E,
	IBM_Magstar_3590,
	IBM_Magstar_MP,
	STK_DATA_D3,
	SONY_DTF,
	DV_6mm,
	DMI,
	SONY_D2,
	CLEANER_CARTRIDGE,
	CD_ROM,
	CD_R,
	CD_RW,
	DVD_ROM,
	DVD_R,
	DVD_RW,
	MO_3_RW,
	MO_5_WO,
	MO_5_RW,
	MO_5_LIMDOW,
	PC_5_WO,
	PC_5_RW,
	PD_5_RW,
	ABL_5_WO,
	PINNACLE_APEX_5_RW,
	SONY_12_WO,
	PHILIPS_12_WO,
	HITACHI_12_WO,
	CYGNET_12_WO,
	KODAK_14_WO,
	MO_NFR_525,
	NIKON_12_RW,
	IOMEGA_ZIP,
	IOMEGA_JAZ,
	SYQUEST_EZ135,
	SYQUEST_EZFLYER,
	SYQUEST_SYJET,
	AVATAR_F2,
	MP2_8mm,
	DST_S,
	DST_M,
	DST_L,
	VXATape_1,
	VXATape_2,
	STK_EAGLE,
	LTO_Ultrium,
	LTO_Accelis
} STORAGE_MEDIA_TYPE , *  PSTORAGE_MEDIA_TYPE ;

// #line 306
typedef enum _STORAGE_BUS_TYPE {
	BusTypeUnknown /* = 0x00 */,
	BusTypeScsi,
	BusTypeAtapi,
	BusTypeAta,
	BusType1394,
	BusTypeSsa,
	BusTypeFibre,
	BusTypeUsb,
	BusTypeRAID,
	BusTypeMaxReserved /* = 0x7F */
} STORAGE_BUS_TYPE , *  PSTORAGE_BUS_TYPE ;

typedef struct _DEVICE_MEDIA_INFO {
	union  {
		struct  {
			LARGE_INTEGER Cylinders ;
			STORAGE_MEDIA_TYPE MediaType ;
			ULONG TracksPerCylinder ;
			ULONG SectorsPerTrack ;
			ULONG BytesPerSector ;
			ULONG NumberMediaSides ;
			ULONG MediaCharacteristics ;
		} DiskInfo ;
		struct  {
			LARGE_INTEGER Cylinders ;
			STORAGE_MEDIA_TYPE MediaType ;
			ULONG TracksPerCylinder ;
			ULONG SectorsPerTrack ;
			ULONG BytesPerSector ;
			ULONG NumberMediaSides ;
			ULONG MediaCharacteristics ;
		} RemovableDiskInfo ;
		struct  {
			STORAGE_MEDIA_TYPE MediaType ;
			ULONG MediaCharacteristics ;
			ULONG CurrentBlockSize ;
			STORAGE_BUS_TYPE BusType ;
			union  {
				struct  {
					UCHAR MediumType ;
					UCHAR DensityCode ;
				} ScsiInformation ;
			} BusSpecificData ;
		} TapeInfo ;
	} DeviceSpecific ;
} DEVICE_MEDIA_INFO , *  PDEVICE_MEDIA_INFO ;

// #line 362
typedef struct _GET_MEDIA_TYPES {
	ULONG DeviceType ;
	ULONG MediaInfoCount ;
	DEVICE_MEDIA_INFO MediaInfo[1] ;
} GET_MEDIA_TYPES , *  PGET_MEDIA_TYPES ;

// #line 381
typedef struct _STORAGE_PREDICT_FAILURE {
	ULONG PredictFailure ;
	UCHAR VendorSpecific[512] ;
} STORAGE_PREDICT_FAILURE , *  PSTORAGE_PREDICT_FAILURE ;

// #line 414
typedef enum _STORAGE_QUERY_TYPE {
	PropertyStandardQuery /* = 0 */,
	PropertyExistsQuery,
	PropertyMaskQuery,
	PropertyQueryMaxDefined
} STORAGE_QUERY_TYPE , *  PSTORAGE_QUERY_TYPE ;

// #line 425
typedef enum _STORAGE_PROPERTY_ID {
	StorageDeviceProperty/*  = 0 */,
	StorageAdapterProperty
} STORAGE_PROPERTY_ID , *  PSTORAGE_PROPERTY_ID ;

// #line 435
typedef struct _STORAGE_PROPERTY_QUERY {
	STORAGE_PROPERTY_ID PropertyId ;
	STORAGE_QUERY_TYPE QueryType ;
	UCHAR AdditionalParameters[1] ;
} STORAGE_PROPERTY_QUERY , *  PSTORAGE_PROPERTY_QUERY ;

// #line 462
typedef struct _STORAGE_DESCRIPTOR_HEADER {
	ULONG Version ;
	ULONG Size ;
} STORAGE_DESCRIPTOR_HEADER , *  PSTORAGE_DESCRIPTOR_HEADER ;

// #line 478
typedef struct _STORAGE_DEVICE_DESCRIPTOR {
	ULONG Version ;
	ULONG Size ;
	UCHAR DeviceType ;
	UCHAR DeviceTypeModifier ;
	BOOLEAN RemovableMedia ;
	BOOLEAN CommandQueueing ;
	ULONG VendorIdOffset ;
	ULONG ProductIdOffset ;
	ULONG ProductRevisionOffset ;
	ULONG SerialNumberOffset ;
	STORAGE_BUS_TYPE BusType ;
	ULONG RawPropertiesLength ;
	UCHAR RawDeviceProperties[1] ;
} STORAGE_DEVICE_DESCRIPTOR , *  PSTORAGE_DEVICE_DESCRIPTOR ;

// #line 581
typedef struct _STORAGE_ADAPTER_DESCRIPTOR {
	ULONG Version ;
	ULONG Size ;
	ULONG MaximumTransferLength ;
	ULONG MaximumPhysicalPages ;
	ULONG AlignmentMask ;
	BOOLEAN AdapterUsesPio ;
	BOOLEAN AdapterScansDown ;
	BOOLEAN CommandQueueing ;
	BOOLEAN AcceleratedTransfer ;
	BOOLEAN BusType ;
	USHORT BusMajorVersion ;
	USHORT BusMinorVersion ;
} STORAGE_ADAPTER_DESCRIPTOR , *  PSTORAGE_ADAPTER_DESCRIPTOR ;

// #line 112 "C:/NTDDK/inc/ntddcdrm.h"
typedef struct _TRACK_DATA {
	UCHAR Reserved ;
	UCHAR Control  /*:4*/;
	UCHAR Adr  /*:4*/;
	UCHAR TrackNumber ;
	UCHAR Reserved1 ;
	UCHAR Address[4] ;
} TRACK_DATA , *  PTRACK_DATA ;

typedef struct _CDROM_TOC {
	UCHAR Length[2] ;
	UCHAR FirstTrack ;
	UCHAR LastTrack ;
	TRACK_DATA TrackData[100] ;
} CDROM_TOC , *  PCDROM_TOC ;

// #line 144
typedef struct _CDROM_PLAY_AUDIO_MSF {
	UCHAR StartingM ;
	UCHAR StartingS ;
	UCHAR StartingF ;
	UCHAR EndingM ;
	UCHAR EndingS ;
	UCHAR EndingF ;
} CDROM_PLAY_AUDIO_MSF , *  PCDROM_PLAY_AUDIO_MSF ;

// #line 157
typedef struct _CDROM_SEEK_AUDIO_MSF {
	UCHAR M ;
	UCHAR S ;
	UCHAR F ;
} CDROM_SEEK_AUDIO_MSF , *  PCDROM_SEEK_AUDIO_MSF ;

// #line 168
typedef struct _CDROM_DISK_DATA {
	ULONG DiskData ;
} CDROM_DISK_DATA , *  PCDROM_DISK_DATA ;

// #line 186
typedef struct _CDROM_SUB_Q_DATA_FORMAT {
	UCHAR Format ;
	UCHAR Track ;
} CDROM_SUB_Q_DATA_FORMAT , *  PCDROM_SUB_Q_DATA_FORMAT ;

// #line 196
typedef struct _SUB_Q_HEADER {
	UCHAR Reserved ;
	UCHAR AudioStatus ;
	UCHAR DataLength[2] ;
} SUB_Q_HEADER , *  PSUB_Q_HEADER ;

typedef struct _SUB_Q_CURRENT_POSITION {
	SUB_Q_HEADER Header ;
	UCHAR FormatCode ;
	UCHAR Control  /*:4*/;
	UCHAR ADR  /*:4*/;
	UCHAR TrackNumber ;
	UCHAR IndexNumber ;
	UCHAR AbsoluteAddress[4] ;
	UCHAR TrackRelativeAddress[4] ;
} SUB_Q_CURRENT_POSITION , *  PSUB_Q_CURRENT_POSITION ;

typedef struct _SUB_Q_MEDIA_CATALOG_NUMBER {
	SUB_Q_HEADER Header ;
	UCHAR FormatCode ;
	UCHAR Reserved[3] ;
	UCHAR Reserved1 /*  : 7 */;
	UCHAR Mcval  /* :1*/;
	UCHAR MediaCatalog[15] ;
} SUB_Q_MEDIA_CATALOG_NUMBER , *  PSUB_Q_MEDIA_CATALOG_NUMBER ;

typedef struct _SUB_Q_TRACK_ISRC {
	SUB_Q_HEADER Header ;
	UCHAR FormatCode ;
	UCHAR Reserved0 ;
	UCHAR Track ;
	UCHAR Reserved1 ;
	UCHAR Reserved2 /*  : 7 */;
	UCHAR Tcval  /* :1*/;
	UCHAR TrackIsrc[15] ;
} SUB_Q_TRACK_ISRC , *  PSUB_Q_TRACK_ISRC ;

typedef union _SUB_Q_CHANNEL_DATA {
	SUB_Q_CURRENT_POSITION CurrentPosition ;
	SUB_Q_MEDIA_CATALOG_NUMBER MediaCatalog ;
	SUB_Q_TRACK_ISRC TrackIsrc ;
} SUB_Q_CHANNEL_DATA , *  PSUB_Q_CHANNEL_DATA ;

// #line 272
typedef struct _CDROM_AUDIO_CONTROL {
	UCHAR LbaFormat ;
	USHORT LogicalBlocksPerSecond ;
} CDROM_AUDIO_CONTROL , *  PCDROM_AUDIO_CONTROL ;

// #line 283
typedef struct _VOLUME_CONTROL {
	UCHAR PortVolume[4] ;
} VOLUME_CONTROL , *  PVOLUME_CONTROL ;

typedef enum _TRACK_MODE_TYPE {
	YellowMode2,
	XAForm2,
	CDDA
} TRACK_MODE_TYPE , *  PTRACK_MODE_TYPE ;

// #line 297
typedef struct __RAW_READ_INFO {
	LARGE_INTEGER DiskOffset ;
	ULONG SectorCount ;
	TRACK_MODE_TYPE TrackMode ;
} RAW_READ_INFO , *  PRAW_READ_INFO ;

// #line 16 "C:/NTDDK/inc/stdio.h"

// #pragma once
// #line 32

// #pragma pack(push, 8)
// #line 89
typedef char *  va_list ;

// #line 118
struct _iobuf {
	char *  _ptr ;
	int _cnt ;
	char *  _base ;
	int _flag ;
	int _file ;
	int _charbuf ;
	int _bufsiz ;
	char *  _tmpfname ;
} ;

// #line 128
typedef struct _iobuf FILE ;

// #line 184
// extern FILE _iob[] ;

// #line 198
// #pragma pack(pop)
// #line 61 "C:/NTDDK/inc/ddk/srb.h"
typedef PHYSICAL_ADDRESS SCSI_PHYSICAL_ADDRESS , *  PSCSI_PHYSICAL_ADDRESS ;

typedef struct _ACCESS_RANGE {
	SCSI_PHYSICAL_ADDRESS RangeStart ;
	ULONG RangeLength ;
	BOOLEAN RangeInMemory ;
} ACCESS_RANGE , *  PACCESS_RANGE ;

// #line 75
typedef struct _PORT_CONFIGURATION_INFORMATION {
	ULONG Length ;
	ULONG SystemIoBusNumber ;
	INTERFACE_TYPE AdapterInterfaceType ;
	ULONG BusInterruptLevel ;
	ULONG BusInterruptVector ;
	KINTERRUPT_MODE InterruptMode ;
	ULONG MaximumTransferLength ;
	ULONG NumberOfPhysicalBreaks ;
	ULONG DmaChannel ;
	ULONG DmaPort ;
	DMA_WIDTH DmaWidth ;
	DMA_SPEED DmaSpeed ;
	ULONG AlignmentMask ;
	ULONG NumberOfAccessRanges ;
	ACCESS_RANGE ( *  AccessRanges )[] ;
	PVOID Reserved ;
	UCHAR NumberOfBuses ;
	CCHAR InitiatorBusId[8] ;
	BOOLEAN ScatterGather ;
	BOOLEAN Master ;
	BOOLEAN CachesData ;
	BOOLEAN AdapterScansDown ;
	BOOLEAN AtdiskPrimaryClaimed ;
	BOOLEAN AtdiskSecondaryClaimed ;
	BOOLEAN Dma32BitAddresses ;
	BOOLEAN DemandMode ;
	BOOLEAN MapBuffers ;
	BOOLEAN NeedPhysicalAddresses ;
	BOOLEAN TaggedQueuing ;
	BOOLEAN AutoRequestSense ;
	BOOLEAN MultipleRequestPerLu ;
	BOOLEAN ReceiveEvent ;
	BOOLEAN RealModeInitialized ;
	BOOLEAN BufferAccessScsiPortControlled ;
	UCHAR MaximumNumberOfTargets ;
	UCHAR ReservedUchars[2] ;
	ULONG SlotNumber ;
	ULONG BusInterruptLevel2 ;
	ULONG BusInterruptVector2 ;
	KINTERRUPT_MODE InterruptMode2 ;
	ULONG DmaChannel2 ;
	ULONG DmaPort2 ;
	DMA_WIDTH DmaWidth2 ;
	DMA_SPEED DmaSpeed2 ;
	ULONG DeviceExtensionSize ;
	ULONG SpecificLuExtensionSize ;
	ULONG SrbExtensionSize ;
	UCHAR Dma64BitAddresses ;
	BOOLEAN ResetTargetSupported ;
	UCHAR MaximumNumberOfLogicalUnits ;
	BOOLEAN WmiDataProvider ;
} PORT_CONFIGURATION_INFORMATION , *  PPORT_CONFIGURATION_INFORMATION ;

// #line 376
typedef enum _SCSI_ADAPTER_CONTROL_TYPE {
	ScsiQuerySupportedControlTypes /* = 0 */,
	ScsiStopAdapter,
	ScsiRestartAdapter,
	ScsiSetBootConfig,
	ScsiSetRunningConfig,
	ScsiAdapterControlMax,
	MakeAdapterControlTypeSizeOfUlong /* = 0xffffffff */
} SCSI_ADAPTER_CONTROL_TYPE , *  PSCSI_ADAPTER_CONTROL_TYPE ;

// #line 390
typedef enum _SCSI_ADAPTER_CONTROL_STATUS {
	ScsiAdapterControlSuccess /* = 0 */,
	ScsiAdapterControlUnsuccessful
} SCSI_ADAPTER_CONTROL_STATUS , *  PSCSI_ADAPTER_CONTROL_STATUS ;

// #line 403

// #pragma warning(disable:4200)
// #line 404
typedef struct _SCSI_SUPPORTED_CONTROL_TYPE_LIST {
	ULONG MaxControlType ;
	BOOLEAN SupportedTypeList[0] ;
} SCSI_SUPPORTED_CONTROL_TYPE_LIST , *  PSCSI_SUPPORTED_CONTROL_TYPE_LIST ;

// #line 422

// #pragma warning(default:4200)
// #line 446
typedef struct _SCSI_REQUEST_BLOCK {
	USHORT Length ;
	UCHAR Function ;
	UCHAR SrbStatus ;
	UCHAR ScsiStatus ;
	UCHAR PathId ;
	UCHAR TargetId ;
	UCHAR Lun ;
	UCHAR QueueTag ;
	UCHAR QueueAction ;
	UCHAR CdbLength ;
	UCHAR SenseInfoBufferLength ;
	ULONG SrbFlags ;
	ULONG DataTransferLength ;
	ULONG TimeOutValue ;
	PVOID DataBuffer ;
	PVOID SenseInfoBuffer ;
	struct _SCSI_REQUEST_BLOCK *  NextSrb ;
	PVOID OriginalRequest ;
	PVOID SrbExtension ;
	union  {
		ULONG InternalStatus ;
		ULONG QueueSortKey ;
	}  ;
	UCHAR Cdb[16] ;
} SCSI_REQUEST_BLOCK , *  PSCSI_REQUEST_BLOCK ;

// #line 490
typedef struct _SCSI_WMI_REQUEST_BLOCK {
	USHORT Length ;
	UCHAR Function ;
	UCHAR SrbStatus ;
	UCHAR WMISubFunction ;
	UCHAR PathId ;
	UCHAR TargetId ;
	UCHAR Lun ;
	UCHAR Reserved1 ;
	UCHAR WMIFlags ;
	UCHAR Reserved2[2] ;
	ULONG SrbFlags ;
	ULONG DataTransferLength ;
	ULONG TimeOutValue ;
	PVOID DataBuffer ;
	PVOID DataPath ;
	PVOID Reserved3 ;
	PVOID OriginalRequest ;
	PVOID SrbExtension ;
	ULONG Reserved4 ;
	UCHAR Reserved5[16] ;
} SCSI_WMI_REQUEST_BLOCK , *  PSCSI_WMI_REQUEST_BLOCK ;

// #line 633
typedef BOOLEAN ( *  PHW_INITIALIZE )(PVOID DeviceExtension ) ;

// #line 639
typedef BOOLEAN ( *  PHW_STARTIO )(PVOID DeviceExtension , PSCSI_REQUEST_BLOCK
	Srb ) ;

// #line 646
typedef BOOLEAN ( *  PHW_INTERRUPT )(PVOID DeviceExtension ) ;

// #line 652
typedef void ( *  PHW_TIMER )(PVOID DeviceExtension ) ;

// #line 658
typedef void ( *  PHW_DMA_STARTED )(PVOID DeviceExtension ) ;

// #line 664
typedef ULONG ( *  PHW_FIND_ADAPTER )(PVOID DeviceExtension , PVOID HwContext ,
	PVOID BusInformation , PCHAR ArgumentString ,
	PPORT_CONFIGURATION_INFORMATION ConfigInfo , PBOOLEAN Again ) ;

// #line 675
typedef BOOLEAN ( *  PHW_RESET_BUS )(PVOID DeviceExtension , ULONG PathId ) ;

// #line 682
typedef BOOLEAN ( *  PHW_ADAPTER_STATE )(PVOID DeviceExtension , PVOID Context ,
	BOOLEAN SaveState ) ;

// #line 690
typedef SCSI_ADAPTER_CONTROL_STATUS ( *  PHW_ADAPTER_CONTROL )(PVOID
	DeviceExtension , SCSI_ADAPTER_CONTROL_TYPE ControlType , PVOID
	Parameters ) ;

// #line 728
typedef enum _SCSI_NOTIFICATION_TYPE {
	RequestComplete,
	NextRequest,
	NextLuRequest,
	ResetDetected,
	CallDisableInterrupts,
	CallEnableInterrupts,
	RequestTimerCall,
	BusChangeDetected,
	WMIEvent,
	WMIReregister
} SCSI_NOTIFICATION_TYPE , *  PSCSI_NOTIFICATION_TYPE ;

// #line 746
typedef struct _HW_INITIALIZATION_DATA {
	ULONG HwInitializationDataSize ;
	INTERFACE_TYPE AdapterInterfaceType ;
	PHW_INITIALIZE HwInitialize ;
	PHW_STARTIO HwStartIo ;
	PHW_INTERRUPT HwInterrupt ;
	PHW_FIND_ADAPTER HwFindAdapter ;
	PHW_RESET_BUS HwResetBus ;
	PHW_DMA_STARTED HwDmaStarted ;
	PHW_ADAPTER_STATE HwAdapterState ;
	ULONG DeviceExtensionSize ;
	ULONG SpecificLuExtensionSize ;
	ULONG SrbExtensionSize ;
	ULONG NumberOfAccessRanges ;
	PVOID Reserved ;
	BOOLEAN MapBuffers ;
	BOOLEAN NeedPhysicalAddresses ;
	BOOLEAN TaggedQueuing ;
	BOOLEAN AutoRequestSense ;
	BOOLEAN MultipleRequestPerLu ;
	BOOLEAN ReceiveEvent ;
	USHORT VendorIdLength ;
	PVOID VendorId ;
	USHORT ReservedUshort ;
	USHORT DeviceIdLength ;
	PVOID DeviceId ;
	PHW_ADAPTER_CONTROL HwAdapterControl ;
} HW_INITIALIZATION_DATA , *  PHW_INITIALIZATION_DATA ;

// #line 890

// #line 32 "C:/NTDDK/inc/ddk/scsi.h"
typedef union _CDB {
	struct _CDB6GENERIC {
		UCHAR OperationCode ;
		UCHAR Immediate  /* :1*/;
		UCHAR CommandUniqueBits  /*:4*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR CommandUniqueBytes[3] ;
		UCHAR Link  /* :1*/;
		UCHAR Flag  /* :1*/;
		UCHAR Reserved  /*:4*/;
		UCHAR VendorUnique  /*:2*/;
	} CDB6GENERIC , *  PCDB6GENERIC ;
	struct _CDB6READWRITE {
		UCHAR OperationCode ;
		UCHAR LogicalBlockMsb1  /*:5*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR LogicalBlockMsb0 ;
		UCHAR LogicalBlockLsb ;
		UCHAR TransferBlocks ;
		UCHAR Control ;
	} CDB6READWRITE , *  PCDB6READWRITE ;
	struct _CDB6INQUIRY {
		UCHAR OperationCode ;
		UCHAR Reserved1  /*:5*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR PageCode ;
		UCHAR IReserved ;
		UCHAR AllocationLength ;
		UCHAR Control ;
	} CDB6INQUIRY , *  PCDB6INQUIRY ;
	struct _CDB6VERIFY {
		UCHAR OperationCode ;
		UCHAR Fixed  /* :1*/;
		UCHAR ByteCompare  /* :1*/;
		UCHAR Immediate  /* :1*/;
		UCHAR Reserved  /*:2*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR VerificationLength[3] ;
		UCHAR Control ;
	} CDB6VERIFY , *  PCDB6VERIFY ;
	struct _CDB6FORMAT {
		UCHAR OperationCode ;
		UCHAR FormatControl  /*:5*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR FReserved1 ;
		UCHAR InterleaveMsb ;
		UCHAR InterleaveLsb ;
		UCHAR FReserved2 ;
	} CDB6FORMAT , *  PCDB6FORMAT ;
	struct _CDB10 {
		UCHAR OperationCode ;
		UCHAR RelativeAddress  /* :1*/;
		UCHAR Reserved1  /*:2*/;
		UCHAR ForceUnitAccess  /* :1*/;
		UCHAR DisablePageOut  /* :1*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR LogicalBlockByte0 ;
		UCHAR LogicalBlockByte1 ;
		UCHAR LogicalBlockByte2 ;
		UCHAR LogicalBlockByte3 ;
		UCHAR Reserved2 ;
		UCHAR TransferBlocksMsb ;
		UCHAR TransferBlocksLsb ;
		UCHAR Control ;
	} CDB10 , *  PCDB10 ;
	struct _CDB12 {
		UCHAR OperationCode ;
		UCHAR RelativeAddress  /* :1*/;
		UCHAR Reserved1  /*:2*/;
		UCHAR ForceUnitAccess  /* :1*/;
		UCHAR DisablePageOut  /* :1*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR LogicalBlock[4] ;
		UCHAR TransferLength[4] ;
		UCHAR Reserved2 ;
		UCHAR Control ;
	} CDB12 , *  PCDB12 ;
	struct _PAUSE_RESUME {
		UCHAR OperationCode ;
		UCHAR Reserved1  /*:5*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR Reserved2[6] ;
		UCHAR Action ;
		UCHAR Control ;
	} PAUSE_RESUME , *  PPAUSE_RESUME ;
	struct _READ_TOC {
		UCHAR OperationCode ;
		UCHAR Reserved0  /* :1*/;
		UCHAR Msf  /* :1*/;
		UCHAR Reserved1  /*:3*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR Format2  /*:4*/;
		UCHAR Reserved2  /*:4*/;
		UCHAR Reserved3[3] ;
		UCHAR StartingTrack ;
		UCHAR AllocationLength[2] ;
		UCHAR Control  /*:6*/;
		UCHAR Format  /*:2*/;
	} READ_TOC , *  PREAD_TOC ;
	struct _READ_DISK_INFORMATION {
		UCHAR OperationCode ;
		UCHAR Reserved1  /*:5*/;
		UCHAR Lun  /*:3*/;
		UCHAR Reserved2[5] ;
		UCHAR AllocationLength[2] ;
		UCHAR Control ;
	} READ_DISK_INFORMATION , *  PREAD_DISK_INFORMATION ;
	struct _READ_TRACK_INFORMATION {
		UCHAR OperationCode ;
		UCHAR Track  /* :1*/;
		UCHAR Reserved1  /*:3*/;
		UCHAR Reserved2  /* :1*/;
		UCHAR Lun  /*:3*/;
		UCHAR BlockAddress[4] ;
		UCHAR Reserved3 ;
		UCHAR AllocationLength[2] ;
		UCHAR Control ;
	} READ_TRACK_INFORMATION , *  PREAD_TRACK_INFORMATION ;
	struct _READ_HEADER {
		UCHAR OperationCode ;
		UCHAR Reserved1  /* :1*/;
		UCHAR Msf  /* :1*/;
		UCHAR Reserved2  /*:3*/;
		UCHAR Lun  /*:3*/;
		UCHAR LogicalBlockAddress[4] ;
		UCHAR Reserved3 ;
		UCHAR AllocationLength[2] ;
		UCHAR Control ;
	} READ_HEADER , *  PREAD_HEADER ;
	struct _PLAY_AUDIO {
		UCHAR OperationCode ;
		UCHAR Reserved1  /*:5*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR StartingBlockAddress[4] ;
		UCHAR Reserved2 ;
		UCHAR PlayLength[2] ;
		UCHAR Control ;
	} PLAY_AUDIO , *  PPLAY_AUDIO ;
	struct _PLAY_AUDIO_MSF {
		UCHAR OperationCode ;
		UCHAR Reserved1  /*:5*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR Reserved2 ;
		UCHAR StartingM ;
		UCHAR StartingS ;
		UCHAR StartingF ;
		UCHAR EndingM ;
		UCHAR EndingS ;
		UCHAR EndingF ;
		UCHAR Control ;
	} PLAY_AUDIO_MSF , *  PPLAY_AUDIO_MSF ;
	struct _PLAY_CD {
		UCHAR OperationCode ;
		UCHAR Reserved1  /* :1*/;
		UCHAR CMSF  /* :1*/;
		UCHAR ExpectedSectorType  /*:3*/;
		UCHAR Lun  /*:3*/;
		union  {
			struct _LBA {
				UCHAR StartingBlockAddress[4] ;
				UCHAR PlayLength[4] ;
			} LBA ;
			struct _MSF {
				UCHAR Reserved1 ;
				UCHAR StartingM ;
				UCHAR StartingS ;
				UCHAR StartingF ;
				UCHAR EndingM ;
				UCHAR EndingS ;
				UCHAR EndingF ;
				UCHAR Reserved2 ;
			} MSF ;
		}  ;
		UCHAR Audio  /* :1*/;
		UCHAR Composite  /* :1*/;
		UCHAR Port1  /* :1*/;
		UCHAR Port2  /* :1*/;
		UCHAR Reserved2  /*:3*/;
		UCHAR Speed  /* :1*/;
		UCHAR Control ;
	} PLAY_CD , *  PPLAY_CD ;
	struct _SCAN_CD {
		UCHAR OperationCode ;
		UCHAR RelativeAddress  /* :1*/;
		UCHAR Reserved1  /*:3*/;
		UCHAR Direct  /* :1*/;
		UCHAR Lun  /*:3*/;
		UCHAR StartingAddress[4] ;
		UCHAR Reserved2[3] ;
		UCHAR Reserved3  /*:6*/;
		UCHAR Type  /*:2*/;
		UCHAR Reserved4 ;
		UCHAR Control ;
	} SCAN_CD , *  PSCAN_CD ;
	struct _STOP_PLAY_SCAN {
		UCHAR OperationCode ;
		UCHAR Reserved1  /*:5*/;
		UCHAR Lun  /*:3*/;
		UCHAR Reserved2[7] ;
		UCHAR Control ;
	} STOP_PLAY_SCAN , *  PSTOP_PLAY_SCAN ;
	struct _SUBCHANNEL {
		UCHAR OperationCode ;
		UCHAR Reserved0  /* :1*/;
		UCHAR Msf  /* :1*/;
		UCHAR Reserved1  /*:3*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR Reserved2  /*:6*/;
		UCHAR SubQ  /* :1*/;
		UCHAR Reserved3  /* :1*/;
		UCHAR Format ;
		UCHAR Reserved4[2] ;
		UCHAR TrackNumber ;
		UCHAR AllocationLength[2] ;
		UCHAR Control ;
	} SUBCHANNEL , *  PSUBCHANNEL ;
	struct _READ_CD {
		UCHAR OperationCode ;
		UCHAR RelativeAddress  /* :1*/;
		UCHAR Reserved0  /* :1*/;
		UCHAR ExpectedSectorType  /*:3*/;
		UCHAR Lun  /*:3*/;
		UCHAR StartingLBA[4] ;
		UCHAR TransferBlocks[3] ;
		UCHAR Reserved2  /* :1*/;
		UCHAR ErrorFlags  /*:2*/;
		UCHAR IncludeEDC  /* :1*/;
		UCHAR IncludeUserData  /* :1*/;
		UCHAR HeaderCode  /*:2*/;
		UCHAR IncludeSyncData  /* :1*/;
		UCHAR SubChannelSelection  /*:3*/;
		UCHAR Reserved3  /*:5*/;
		UCHAR Control ;
	} READ_CD , *  PREAD_CD ;
	struct _READ_CD_MSF {
		UCHAR OperationCode ;
		UCHAR RelativeAddress  /* :1*/;
		UCHAR Reserved1  /* :1*/;
		UCHAR ExpectedSectorType  /*:3*/;
		UCHAR Lun  /*:3*/;
		UCHAR Reserved2 ;
		UCHAR StartingM ;
		UCHAR StartingS ;
		UCHAR StartingF ;
		UCHAR EndingM ;
		UCHAR EndingS ;
		UCHAR EndingF ;
		UCHAR Reserved3 ;
		UCHAR Reserved4  /* :1*/;
		UCHAR ErrorFlags  /*:2*/;
		UCHAR IncludeEDC  /* :1*/;
		UCHAR IncludeUserData  /* :1*/;
		UCHAR HeaderCode  /*:2*/;
		UCHAR IncludeSyncData  /* :1*/;
		UCHAR SubChannelSelection  /*:3*/;
		UCHAR Reserved5  /*:5*/;
		UCHAR Control ;
	} READ_CD_MSF , *  PREAD_CD_MSF ;
	struct _PLXTR_READ_CDDA {
		UCHAR OperationCode ;
		UCHAR Reserved0  /*:5*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR LogicalBlockByte0 ;
		UCHAR LogicalBlockByte1 ;
		UCHAR LogicalBlockByte2 ;
		UCHAR LogicalBlockByte3 ;
		UCHAR TransferBlockByte0 ;
		UCHAR TransferBlockByte1 ;
		UCHAR TransferBlockByte2 ;
		UCHAR TransferBlockByte3 ;
		UCHAR SubCode ;
		UCHAR Control ;
	} PLXTR_READ_CDDA , *  PPLXTR_READ_CDDA ;
	struct _NEC_READ_CDDA {
		UCHAR OperationCode ;
		UCHAR Reserved0 ;
		UCHAR LogicalBlockByte0 ;
		UCHAR LogicalBlockByte1 ;
		UCHAR LogicalBlockByte2 ;
		UCHAR LogicalBlockByte3 ;
		UCHAR Reserved1 ;
		UCHAR TransferBlockByte0 ;
		UCHAR TransferBlockByte1 ;
		UCHAR Control ;
	} NEC_READ_CDDA , *  PNEC_READ_CDDA ;
	struct _MODE_SENSE {
		UCHAR OperationCode ;
		UCHAR Reserved1  /*:3*/;
		UCHAR Dbd  /* :1*/;
		UCHAR Reserved2  /* :1*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR PageCode  /*:6*/;
		UCHAR Pc  /*:2*/;
		UCHAR Reserved3 ;
		UCHAR AllocationLength ;
		UCHAR Control ;
	} MODE_SENSE , *  PMODE_SENSE ;
	struct _MODE_SENSE10 {
		UCHAR OperationCode ;
		UCHAR Reserved1  /*:3*/;
		UCHAR Dbd  /* :1*/;
		UCHAR Reserved2  /* :1*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR PageCode  /*:6*/;
		UCHAR Pc  /*:2*/;
		UCHAR Reserved3[4] ;
		UCHAR AllocationLength[2] ;
		UCHAR Control ;
	} MODE_SENSE10 , *  PMODE_SENSE10 ;
	struct _MODE_SELECT {
		UCHAR OperationCode ;
		UCHAR SPBit  /* :1*/;
		UCHAR Reserved1  /*:3*/;
		UCHAR PFBit  /* :1*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR Reserved2[2] ;
		UCHAR ParameterListLength ;
		UCHAR Control ;
	} MODE_SELECT , *  PMODE_SELECT ;
	struct _MODE_SELECT10 {
		UCHAR OperationCode ;
		UCHAR SPBit  /* :1*/;
		UCHAR Reserved1  /*:3*/;
		UCHAR PFBit  /* :1*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR Reserved2[5] ;
		UCHAR ParameterListLength[2] ;
		UCHAR Control ;
	} MODE_SELECT10 , *  PMODE_SELECT10 ;
	struct _LOCATE {
		UCHAR OperationCode ;
		UCHAR Immediate  /* :1*/;
		UCHAR CPBit  /* :1*/;
		UCHAR BTBit  /* :1*/;
		UCHAR Reserved1  /*:2*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR Reserved3 ;
		UCHAR LogicalBlockAddress[4] ;
		UCHAR Reserved4 ;
		UCHAR Partition ;
		UCHAR Control ;
	} LOCATE , *  PLOCATE ;
	struct _LOGSENSE {
		UCHAR OperationCode ;
		UCHAR SPBit  /* :1*/;
		UCHAR PPCBit  /* :1*/;
		UCHAR Reserved1  /*:3*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR PageCode  /*:6*/;
		UCHAR PCBit  /*:2*/;
		UCHAR Reserved2 ;
		UCHAR Reserved3 ;
		UCHAR ParameterPointer[2] ;
		UCHAR AllocationLength[2] ;
		UCHAR Control ;
	} LOGSENSE , *  PLOGSENSE ;
	struct _LOGSELECT {
		UCHAR OperationCode ;
		UCHAR SPBit  /* :1*/;
		UCHAR PCRBit  /* :1*/;
		UCHAR Reserved1  /*:3*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR Reserved  /*:6*/;
		UCHAR PCBit  /*:2*/;
		UCHAR Reserved2[4] ;
		UCHAR ParameterListLength[2] ;
		UCHAR Control ;
	} LOGSELECT , *  PLOGSELECT ;
	struct _PRINT {
		UCHAR OperationCode ;
		UCHAR Reserved  /*:5*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR TransferLength[3] ;
		UCHAR Control ;
	} PRINT , *  PPRINT ;
	struct _SEEK {
		UCHAR OperationCode ;
		UCHAR Reserved1  /*:5*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR LogicalBlockAddress[4] ;
		UCHAR Reserved2[3] ;
		UCHAR Control ;
	} SEEK , *  PSEEK ;
	struct _ERASE {
		UCHAR OperationCode ;
		UCHAR Long  /* :1*/;
		UCHAR Immediate  /* :1*/;
		UCHAR Reserved1  /*:3*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR Reserved2[3] ;
		UCHAR Control ;
	} ERASE , *  PERASE ;
	struct _START_STOP {
		UCHAR OperationCode ;
		UCHAR Immediate  /* :1*/;
		UCHAR Reserved1  /*:4*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR Reserved2[2] ;
		UCHAR Start  /* :1*/;
		UCHAR LoadEject  /* :1*/;
		UCHAR Reserved3  /*:6*/;
		UCHAR Control ;
	} START_STOP , *  PSTART_STOP ;
	struct _MEDIA_REMOVAL {
		UCHAR OperationCode ;
		UCHAR Reserved1  /*:5*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR Reserved2[2] ;
		UCHAR Prevent  /* :1*/;
		UCHAR Persistant  /* :1*/;
		UCHAR Reserved3  /*:6*/;
		UCHAR Control ;
	} MEDIA_REMOVAL , *  PMEDIA_REMOVAL ;
	struct _SEEK_BLOCK {
		UCHAR OperationCode ;
		UCHAR Immediate  /* :1*/;
		UCHAR Reserved1  /* : 7 */;
		UCHAR BlockAddress[3] ;
		UCHAR Link  /* :1*/;
		UCHAR Flag  /* :1*/;
		UCHAR Reserved2  /*:4*/;
		UCHAR VendorUnique  /*:2*/;
	} SEEK_BLOCK , *  PSEEK_BLOCK ;
	struct _REQUEST_BLOCK_ADDRESS {
		UCHAR OperationCode ;
		UCHAR Reserved1[3] ;
		UCHAR AllocationLength ;
		UCHAR Link  /* :1*/;
		UCHAR Flag  /* :1*/;
		UCHAR Reserved2  /*:4*/;
		UCHAR VendorUnique  /*:2*/;
	} REQUEST_BLOCK_ADDRESS , *  PREQUEST_BLOCK_ADDRESS ;
	struct _PARTITION {
		UCHAR OperationCode ;
		UCHAR Immediate  /* :1*/;
		UCHAR Sel  /* :1*/;
		UCHAR PartitionSelect  /*:6*/;
		UCHAR Reserved1[3] ;
		UCHAR Control ;
	} PARTITION , *  PPARTITION ;
	struct _WRITE_TAPE_MARKS {
		UCHAR OperationCode ;
		UCHAR Immediate  /* :1*/;
		UCHAR WriteSetMarks  /* :1*/;
		UCHAR Reserved  /*:3*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR TransferLength[3] ;
		UCHAR Control ;
	} WRITE_TAPE_MARKS , *  PWRITE_TAPE_MARKS ;
	struct _SPACE_TAPE_MARKS {
		UCHAR OperationCode ;
		UCHAR Code  /*:3*/;
		UCHAR Reserved  /*:2*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR NumMarksMSB ;
		UCHAR NumMarks ;
		UCHAR NumMarksLSB ;
		union  {
			UCHAR value ;
			struct  {
				UCHAR Link  /* :1*/;
				UCHAR Flag  /* :1*/;
				UCHAR Reserved  /*:4*/;
				UCHAR VendorUnique  /*:2*/;
			} Fields ;
		} Byte6 ;
	} SPACE_TAPE_MARKS , *  PSPACE_TAPE_MARKS ;
	struct _READ_POSITION {
		UCHAR Operation ;
		UCHAR BlockType  /* :1*/;
		UCHAR Reserved1  /*:4*/;
		UCHAR Lun  /*:3*/;
		UCHAR Reserved2[7] ;
		UCHAR Control ;
	} READ_POSITION , *  PREAD_POSITION ;
	struct _CDB6READWRITETAPE {
		UCHAR OperationCode ;
		UCHAR VendorSpecific  /*:5*/;
		UCHAR Reserved  /*:3*/;
		UCHAR TransferLenMSB ;
		UCHAR TransferLen ;
		UCHAR TransferLenLSB ;
		UCHAR Link  /* :1*/;
		UCHAR Flag  /* :1*/;
		UCHAR Reserved1  /*:4*/;
		UCHAR VendorUnique  /*:2*/;
	} CDB6READWRITETAPE , *  PCDB6READWRITETAPE ;
	struct _INIT_ELEMENT_STATUS {
		UCHAR OperationCode ;
		UCHAR Reserved1  /*:5*/;
		UCHAR LogicalUnitNubmer  /*:3*/;
		UCHAR Reserved2[3] ;
		UCHAR Reserved3  /* : 7 */;
		UCHAR NoBarCode  /* :1*/;
	} INIT_ELEMENT_STATUS , *  PINIT_ELEMENT_STATUS ;
	struct _INITIALIZE_ELEMENT_RANGE {
		UCHAR OperationCode ;
		UCHAR Range  /* :1*/;
		UCHAR Reserved1  /*:4*/;
		UCHAR LogicalUnitNubmer  /*:3*/;
		UCHAR FirstElementAddress[2] ;
		UCHAR Reserved2[2] ;
		UCHAR NumberOfElements[2] ;
		UCHAR Reserved3 ;
		UCHAR Reserved4 /*  : 7 */;
		UCHAR NoBarCode  /* :1*/;
	} INITIALIZE_ELEMENT_RANGE , *  PINITIALIZE_ELEMENT_RANGE ;
	struct _POSITION_TO_ELEMENT {
		UCHAR OperationCode ;
		UCHAR Reserved1  /*:5*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR TransportElementAddress[2] ;
		UCHAR DestinationElementAddress[2] ;
		UCHAR Reserved2[2] ;
		UCHAR Flip  /* :1*/;
		UCHAR Reserved3  /* : 7 */;
		UCHAR Control ;
	} POSITION_TO_ELEMENT , *  PPOSITION_TO_ELEMENT ;
	struct _MOVE_MEDIUM {
		UCHAR OperationCode ;
		UCHAR Reserved1  /*:5*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR TransportElementAddress[2] ;
		UCHAR SourceElementAddress[2] ;
		UCHAR DestinationElementAddress[2] ;
		UCHAR Reserved2[2] ;
		UCHAR Flip  /* :1*/;
		UCHAR Reserved3 /*  : 7 */;
		UCHAR Control ;
	} MOVE_MEDIUM , *  PMOVE_MEDIUM ;
	struct _EXCHANGE_MEDIUM {
		UCHAR OperationCode ;
		UCHAR Reserved1  /*:5*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR TransportElementAddress[2] ;
		UCHAR SourceElementAddress[2] ;
		UCHAR Destination1ElementAddress[2] ;
		UCHAR Destination2ElementAddress[2] ;
		UCHAR Flip1  /* :1*/;
		UCHAR Flip2  /* :1*/;
		UCHAR Reserved3  /*:6*/;
		UCHAR Control ;
	} EXCHANGE_MEDIUM , *  PEXCHANGE_MEDIUM ;
	struct _READ_ELEMENT_STATUS {
		UCHAR OperationCode ;
		UCHAR ElementType  /*:4*/;
		UCHAR VolTag  /* :1*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR StartingElementAddress[2] ;
		UCHAR NumberOfElements[2] ;
		UCHAR Reserved1 ;
		UCHAR AllocationLength[3] ;
		UCHAR Reserved2 ;
		UCHAR Control ;
	} READ_ELEMENT_STATUS , *  PREAD_ELEMENT_STATUS ;
	struct _SEND_VOLUME_TAG {
		UCHAR OperationCode ;
		UCHAR ElementType  /*:4*/;
		UCHAR Reserved1  /* :1*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR StartingElementAddress[2] ;
		UCHAR Reserved2 ;
		UCHAR ActionCode  /*:5*/;
		UCHAR Reserved3  /*:3*/;
		UCHAR Reserved4[2] ;
		UCHAR ParameterListLength[2] ;
		UCHAR Reserved5 ;
		UCHAR Control ;
	} SEND_VOLUME_TAG , *  PSEND_VOLUME_TAG ;
	struct _REQUEST_VOLUME_ELEMENT_ADDRESS {
		UCHAR OperationCode ;
		UCHAR ElementType  /*:4*/;
		UCHAR VolTag  /* :1*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR StartingElementAddress[2] ;
		UCHAR NumberElements[2] ;
		UCHAR Reserved1 ;
		UCHAR AllocationLength[3] ;
		UCHAR Reserved2 ;
		UCHAR Control ;
	} REQUEST_VOLUME_ELEMENT_ADDRESS , *  PREQUEST_VOLUME_ELEMENT_ADDRESS ;
	struct _LOAD_UNLOAD {
		UCHAR OperationCode ;
		UCHAR Immediate  /* :1*/;
		UCHAR Reserved1  /*:4*/;
		UCHAR Lun  /*:3*/;
		UCHAR Reserved2[2] ;
		UCHAR Start  /* :1*/;
		UCHAR LoadEject  /* :1*/;
		UCHAR Reserved3  /*:6*/;
		UCHAR Reserved4[3] ;
		UCHAR Slot ;
		UCHAR Reserved5[3] ;
	} LOAD_UNLOAD , *  PLOAD_UNLOAD ;
	struct _MECH_STATUS {
		UCHAR OperationCode ;
		UCHAR Reserved  /*:5*/;
		UCHAR Lun  /*:3*/;
		UCHAR Reserved1[6] ;
		UCHAR AllocationLength[2] ;
		UCHAR Reserved2[1] ;
		UCHAR Control ;
	} MECH_STATUS , *  PMECH_STATUS ;
	struct _SYNCHRONIZE_CACHE10 {
		UCHAR OperationCode ;
		UCHAR RelAddr  /* :1*/;
		UCHAR Immediate  /* :1*/;
		UCHAR Reserved  /*:3*/;
		UCHAR Lun  /*:3*/;
		UCHAR LogicalBlockAddress[4] ;
		UCHAR Reserved2 ;
		UCHAR BlockCount[2] ;
		UCHAR Control ;
	} SYNCHRONIZE_CACHE10 , *  PSYNCHRONIZE_CACHE10 ;
	struct _GET_EVENT_STATUS_NOTIFICATION {
		UCHAR OperationCode ;
		UCHAR Immediate  /* :1*/;
		UCHAR Reserved  /*:4*/;
		UCHAR Lun  /*:3*/;
		UCHAR Reserved2[2] ;
		UCHAR NotificationClassRequest ;
		UCHAR Reserved3[2] ;
		UCHAR EventListLength[2] ;
		UCHAR Control ;
	} GET_EVENT_STATUS_NOTIFICATION , *  PGET_EVENT_STATUS_NOTIFICATION ;
	struct _READ_DVD_STRUCTURE {
		UCHAR OperationCode ;
		UCHAR Reserved1  /*:5*/;
		UCHAR Lun  /*:3*/;
		UCHAR RMDBlockNumber[4] ;
		UCHAR LayerNumber ;
		UCHAR Format ;
		UCHAR AllocationLength[2] ;
		UCHAR Reserved3  /*:6*/;
		UCHAR AGID  /*:2*/;
		UCHAR Control ;
	} READ_DVD_STRUCTURE , *  PREAD_DVD_STRUCTURE ;
	struct _SEND_KEY {
		UCHAR OperationCode ;
		UCHAR Reserved1  /*:5*/;
		UCHAR Lun  /*:3*/;
		UCHAR Reserved2[6] ;
		UCHAR ParameterListLength[2] ;
		UCHAR KeyFormat  /*:6*/;
		UCHAR AGID  /*:2*/;
		UCHAR Control ;
	} SEND_KEY , *  PSEND_KEY ;
	struct _REPORT_KEY {
		UCHAR OperationCode ;
		UCHAR Reserved1  /*:5*/;
		UCHAR Lun  /*:3*/;
		UCHAR LogicalBlockAddress[4] ;
		UCHAR Reserved2[2] ;
		UCHAR AllocationLength[2] ;
		UCHAR KeyFormat  /*:6*/;
		UCHAR AGID  /*:2*/;
		UCHAR Control ;
	} REPORT_KEY , *  PREPORT_KEY ;
	struct _SET_READ_AHEAD {
		UCHAR OperationCode ;
		UCHAR Reserved1  /*:5*/;
		UCHAR Lun  /*:3*/;
		UCHAR TriggerLBA[4] ;
		UCHAR ReadAheadLBA[4] ;
		UCHAR Reserved2 ;
		UCHAR Control ;
	} SET_READ_AHEAD , *  PSET_READ_AHEAD ;
	struct _READ_FORMATTED_CAPACITIES {
		UCHAR OperationCode ;
		UCHAR Reserved1  /*:5*/;
		UCHAR Lun  /*:3*/;
		UCHAR Reserved2[5] ;
		UCHAR AllocationLength[2] ;
		UCHAR Control ;
	} READ_FORMATTED_CAPACITIES , *  PREAD_FORMATTED_CAPACITIES ;
	struct _REPORT_LUNS {
		UCHAR OperationCode ;
		UCHAR Reserved1[5] ;
		UCHAR AllocationLength[4] ;
		UCHAR Reserved2[1] ;
		UCHAR Control ;
	} REPORT_LUNS , *  PREPORT_LUNS ;
	ULONG AsUlong[4] ;
	UCHAR AsByte[16] ;
} CDB , *  PCDB ;

// #line 889
typedef struct _NOTIFICATION_EVENT_STATUS_HEADER {
	UCHAR EventDataLength[2] ;
	UCHAR NotificationClass  /*:3*/;
	UCHAR Reserved  /*:4*/;
	UCHAR NEA  /* :1*/;
	UCHAR SupportedEventClasses ;
	UCHAR ClassEventData[0] ;
} NOTIFICATION_EVENT_STATUS_HEADER , *  PNOTIFICATION_EVENT_STATUS_HEADER ;

// #line 913
typedef struct _NOTIFICATION_POWER_STATUS {
	UCHAR PowerEvent  /*:4*/;
	UCHAR Reserved  /*:4*/;
	UCHAR PowerStatus ;
	UCHAR Reserved2[2] ;
} NOTIFICATION_POWER_STATUS , *  PNOTIFICATION_POWER_STATUS ;

// #line 926
typedef struct _NOTIFICATION_MEDIA_STATUS {
	UCHAR MediaStatus  /*:4*/;
	UCHAR Reserved  /*:4*/;
	UCHAR PowerStatus ;
	UCHAR StartSlot ;
	UCHAR EndSlot ;
} NOTIFICATION_MEDIA_STATUS , *  PNOTIFICATION_MEDIA_STATUS ;

// #line 944
typedef struct _NOTIFICATION_BUSY_STATUS {
	UCHAR DeviceBusyEvent  /*:4*/;
	UCHAR Reserved  /*:4*/;
	UCHAR DeviceBusyStatus ;
	UCHAR Time[2] ;
} NOTIFICATION_BUSY_STATUS , *  PNOTIFICATION_BUSY_STATUS ;

// #line 962
typedef struct _READ_DVD_STRUCTURES_HEADER {
	UCHAR Length[2] ;
	UCHAR Reserved[2] ;
	UCHAR Data[0] ;
} READ_DVD_STRUCTURES_HEADER , *  PREAD_DVD_STRUCTURES_HEADER ;

// #line 1022
typedef struct _CDVD_KEY_HEADER {
	UCHAR DataLength[2] ;
	UCHAR Reserved[2] ;
	UCHAR Data[0] ;
} CDVD_KEY_HEADER , *  PCDVD_KEY_HEADER ;

typedef struct _CDVD_REPORT_AGID_DATA {
	UCHAR Reserved1[3] ;
	UCHAR Reserved2  /*:6*/;
	UCHAR AGID  /*:2*/;
} CDVD_REPORT_AGID_DATA , *  PCDVD_REPORT_AGID_DATA ;

typedef struct _CDVD_CHALLENGE_KEY_DATA {
	UCHAR ChallengeKeyValue[10] ;
	UCHAR Reserved[2] ;
} CDVD_CHALLENGE_KEY_DATA , *  PCDVD_CHALLENGE_KEY_DATA ;

typedef struct _CDVD_KEY_DATA {
	UCHAR Key[5] ;
	UCHAR Reserved[3] ;
} CDVD_KEY_DATA , *  PCDVD_KEY_DATA ;

typedef struct _CDVD_REPORT_ASF_DATA {
	UCHAR Reserved1[3] ;
	UCHAR Success  /* :1*/;
	UCHAR Reserved2  /* : 7 */;
} CDVD_REPORT_ASF_DATA , *  PCDVD_REPORT_ASF_DATA ;

typedef struct _CDVD_TITLE_KEY_HEADER {
	UCHAR DataLength[2] ;
	UCHAR Reserved1[1] ;
	UCHAR Reserved2  /*:3*/;
	UCHAR CGMS  /*:2*/;
	UCHAR CP_SEC  /* :1*/;
	UCHAR CPM  /* :1*/;
	UCHAR Zero  /* :1*/;
	CDVD_KEY_DATA TitleKey ;
} CDVD_TITLE_KEY_HEADER , *  PCDVD_TITLE_KEY_HEADER ;

// #line 1065
typedef struct _FORMATTED_CAPACITY_DESCRIPTOR {
	UCHAR NumberOfBlocks[4] ;
	UCHAR Maximum  /* :1*/;
	UCHAR Valid  /* :1*/;
	UCHAR BlockLength[3] ;
} FORMATTED_CAPACITY_DESCRIPTOR , *  PFORMATTED_CAPACITY_DESCRIPTOR ;

typedef struct _FORMATTED_CAPACITY_LIST {
	UCHAR Reserved[3] ;
	UCHAR CapacityListLength ;
	FORMATTED_CAPACITY_DESCRIPTOR Descriptors[0] ;
} FORMATTED_CAPACITY_LIST , *  PFORMATTED_CAPACITY_LIST ;

// #line 1106
typedef struct _OPC_TABLE_ENTRY {
	UCHAR Speed[2] ;
	UCHAR OPCValue[6] ;
} OPC_TABLE_ENTRY , *  POPC_TABLE_ENTRY ;

typedef struct _DISK_INFORMATION {
	UCHAR Length[2] ;
	UCHAR DiskStatus  /*:2*/;
	UCHAR LastSessionStatus  /*:2*/;
	UCHAR Erasable  /* :1*/;
	UCHAR Reserved1  /*:3*/;
	UCHAR FirstTrackNumber ;
	UCHAR NumberOfSessions ;
	UCHAR LastSessionFirstTrack ;
	UCHAR LastSessionLastTrack ;
	UCHAR Reserved2  /*:5*/;
	UCHAR GEN  /* :1*/;
	UCHAR DBC_V  /* :1*/;
	UCHAR DID_V  /* :1*/;
	UCHAR DiskType ;
	UCHAR Reserved3[3] ;
	UCHAR DiskIdentification[4] ;
	UCHAR LastSessionLeadIn[4] ;
	UCHAR LastPossibleStartTime[4] ;
	UCHAR DiskBarCode[8] ;
	UCHAR Reserved4 ;
	UCHAR NumberOPCEntries ;
	OPC_TABLE_ENTRY OPCTable[0] ;
} DISK_INFORMATION , *  PDISK_INFORMATION ;

// #line 1146
typedef struct _DATA_BLOCK_HEADER {
	UCHAR DataMode ;
	UCHAR Reserved[4] ;
	union  {
		UCHAR LogicalBlockAddress[4] ;
		struct  {
			UCHAR Reserved ;
			UCHAR M ;
			UCHAR S ;
			UCHAR F ;
		} MSF ;
	}  ;
} DATA_BLOCK_HEADER , *  PDATA_BLOCK_HEADER ;

// #line 1174
typedef struct _TRACK_INFORMATION {
	UCHAR Length[2] ;
	UCHAR TrackNumber ;
	UCHAR SessionNumber ;
	UCHAR Reserved1 ;
	UCHAR TrackMode  /*:4*/;
	UCHAR Copy  /* :1*/;
	UCHAR Damage  /* :1*/;
	UCHAR Reserved2  /*:2*/;
	UCHAR DataMode  /*:4*/;
	UCHAR FP  /* :1*/;
	UCHAR Packet  /* :1*/;
	UCHAR Blank  /* :1*/;
	UCHAR RT  /* :1*/;
	UCHAR NWA_V  /* :1*/;
	UCHAR Reserved3  /*:7*/;
	UCHAR TrackStartAddress[4] ;
	UCHAR NextWritableAddress[4] ;
	UCHAR FreeBlocks[4] ;
	UCHAR FixedPacketSize[4] ;
} TRACK_INFORMATION , *  PTRACK_INFORMATION ;

// #line 1418

// #pragma pack(1)
// #line 1419
typedef struct _SCSI_EXTENDED_MESSAGE {
	UCHAR InitialMessageCode ;
	UCHAR MessageLength ;
	UCHAR MessageType ;
	union _EXTENDED_ARGUMENTS {
		struct  {
			UCHAR Modifier[4] ;
		} Modify ;
		struct  {
			UCHAR TransferPeriod ;
			UCHAR ReqAckOffset ;
		} Synchronous ;
		struct  {
			UCHAR Width ;
		} Wide ;
	} ExtendedArguments ;
} SCSI_EXTENDED_MESSAGE , *  PSCSI_EXTENDED_MESSAGE ;

// #line 1439

// #pragma pack()
// #line 1488
typedef struct _INQUIRYDATA {
	UCHAR DeviceType  /*:5*/;
	UCHAR DeviceTypeQualifier  /*:3*/;
	UCHAR DeviceTypeModifier  /*:7*/;
	UCHAR RemovableMedia  /* :1*/;
	UCHAR Versions ;
	UCHAR ResponseDataFormat  /*:4*/;
	UCHAR HiSupport  /* :1*/;
	UCHAR NormACA  /* :1*/;
	UCHAR ReservedBit  /* :1*/;
	UCHAR AERC  /* :1*/;
	UCHAR AdditionalLength ;
	UCHAR Reserved[2] ;
	UCHAR SoftReset  /* :1*/;
	UCHAR CommandQueue  /* :1*/;
	UCHAR Reserved2  /* :1*/;
	UCHAR LinkedCommands  /* :1*/;
	UCHAR Synchronous  /* :1*/;
	UCHAR Wide16Bit  /* :1*/;
	UCHAR Wide32Bit  /* :1*/;
	UCHAR RelativeAddressing  /* :1*/;
	UCHAR VendorId[8] ;
	UCHAR ProductId[16] ;
	UCHAR ProductRevisionLevel[4] ;
	UCHAR VendorSpecific[20] ;
	UCHAR Reserved3[40] ;
} INQUIRYDATA , *  PINQUIRYDATA ;

// #line 1549
typedef struct _SENSE_DATA {
	UCHAR ErrorCode  /*:7*/;
	UCHAR Valid  /* :1*/;
	UCHAR SegmentNumber ;
	UCHAR SenseKey  /*:4*/;
	UCHAR Reserved  /* :1*/;
	UCHAR IncorrectLength  /* :1*/;
	UCHAR EndOfMedia  /* :1*/;
	UCHAR FileMark  /* :1*/;
	UCHAR Information[4] ;
	UCHAR AdditionalSenseLength ;
	UCHAR CommandSpecificInformation[4] ;
	UCHAR AdditionalSenseCode ;
	UCHAR AdditionalSenseCodeQualifier ;
	UCHAR FieldReplaceableUnitCode ;
	UCHAR SenseKeySpecific[3] ;
} SENSE_DATA , *  PSENSE_DATA ;

// #line 1732
typedef struct _READ_CAPACITY_DATA {
	ULONG LogicalBlockAddress ;
	ULONG BytesPerBlock ;
} READ_CAPACITY_DATA , *  PREAD_CAPACITY_DATA ;

// #line 1743
typedef struct _READ_BLOCK_LIMITS {
	UCHAR Reserved ;
	UCHAR BlockMaximumSize[3] ;
	UCHAR BlockMinimumSize[2] ;
} READ_BLOCK_LIMITS_DATA , *  PREAD_BLOCK_LIMITS_DATA ;

// #line 1758
typedef struct _MODE_PARAMETER_HEADER {
	UCHAR ModeDataLength ;
	UCHAR MediumType ;
	UCHAR DeviceSpecificParameter ;
	UCHAR BlockDescriptorLength ;
} MODE_PARAMETER_HEADER , *  PMODE_PARAMETER_HEADER ;

typedef struct _MODE_PARAMETER_HEADER10 {
	UCHAR ModeDataLength[2] ;
	UCHAR MediumType ;
	UCHAR DeviceSpecificParameter ;
	UCHAR Reserved[2] ;
	UCHAR BlockDescriptorLength[2] ;
} MODE_PARAMETER_HEADER10 , *  PMODE_PARAMETER_HEADER10 ;

// #line 1783
typedef struct _MODE_PARAMETER_BLOCK {
	UCHAR DensityCode ;
	UCHAR NumberOfBlocks[3] ;
	UCHAR Reserved ;
	UCHAR BlockLength[3] ;
} MODE_PARAMETER_BLOCK , *  PMODE_PARAMETER_BLOCK ;

// #line 1794
typedef struct _MODE_DISCONNECT_PAGE {
	UCHAR PageCode  /*:6*/;
	UCHAR Reserved  /* :1*/;
	UCHAR PageSavable  /* :1*/;
	UCHAR PageLength ;
	UCHAR BufferFullRatio ;
	UCHAR BufferEmptyRatio ;
	UCHAR BusInactivityLimit[2] ;
	UCHAR BusDisconnectTime[2] ;
	UCHAR BusConnectTime[2] ;
	UCHAR MaximumBurstSize[2] ;
	UCHAR DataTransferDisconnect  /*:2*/;
	UCHAR Reserved2[3] ;
} MODE_DISCONNECT_PAGE , *  PMODE_DISCONNECT_PAGE ;

// #line 1813
typedef struct _MODE_CACHING_PAGE {
	UCHAR PageCode  /*:6*/;
	UCHAR Reserved  /* :1*/;
	UCHAR PageSavable  /* :1*/;
	UCHAR PageLength ;
	UCHAR ReadDisableCache  /* :1*/;
	UCHAR MultiplicationFactor  /* :1*/;
	UCHAR WriteCacheEnable  /* :1*/;
	UCHAR Reserved2  /*:5*/;
	UCHAR WriteRetensionPriority  /*:4*/;
	UCHAR ReadRetensionPriority  /*:4*/;
	UCHAR DisablePrefetchTransfer[2] ;
	UCHAR MinimumPrefetch[2] ;
	UCHAR MaximumPrefetch[2] ;
	UCHAR MaximumPrefetchCeiling[2] ;
} MODE_CACHING_PAGE , *  PMODE_CACHING_PAGE ;

// #line 1834
typedef struct _MODE_FLEXIBLE_DISK_PAGE {
	UCHAR PageCode  /*:6*/;
	UCHAR Reserved  /* :1*/;
	UCHAR PageSavable  /* :1*/;
	UCHAR PageLength ;
	UCHAR TransferRate[2] ;
	UCHAR NumberOfHeads ;
	UCHAR SectorsPerTrack ;
	UCHAR BytesPerSector[2] ;
	UCHAR NumberOfCylinders[2] ;
	UCHAR StartWritePrecom[2] ;
	UCHAR StartReducedCurrent[2] ;
	UCHAR StepRate[2] ;
	UCHAR StepPluseWidth ;
	UCHAR HeadSettleDelay[2] ;
	UCHAR MotorOnDelay ;
	UCHAR MotorOffDelay ;
	UCHAR Reserved2  /*:5*/;
	UCHAR MotorOnAsserted  /* :1*/;
	UCHAR StartSectorNumber  /* :1*/;
	UCHAR TrueReadySignal  /* :1*/;
	UCHAR StepPlusePerCyclynder  /*:4*/;
	UCHAR Reserved3  /*:4*/;
	UCHAR WriteCompenstation ;
	UCHAR HeadLoadDelay ;
	UCHAR HeadUnloadDelay ;
	UCHAR Pin2Usage  /*:4*/;
	UCHAR Pin34Usage  /*:4*/;
	UCHAR Pin1Usage  /*:4*/;
	UCHAR Pin4Usage  /*:4*/;
	UCHAR MediumRotationRate[2] ;
	UCHAR Reserved4[2] ;
} MODE_FLEXIBLE_DISK_PAGE , *  PMODE_FLEXIBLE_DISK_PAGE ;

// #line 1872
typedef struct _MODE_FORMAT_PAGE {
	UCHAR PageCode  /*:6*/;
	UCHAR Reserved  /* :1*/;
	UCHAR PageSavable  /* :1*/;
	UCHAR PageLength ;
	UCHAR TracksPerZone[2] ;
	UCHAR AlternateSectorsPerZone[2] ;
	UCHAR AlternateTracksPerZone[2] ;
	UCHAR AlternateTracksPerLogicalUnit[2] ;
	UCHAR SectorsPerTrack[2] ;
	UCHAR BytesPerPhysicalSector[2] ;
	UCHAR Interleave[2] ;
	UCHAR TrackSkewFactor[2] ;
	UCHAR CylinderSkewFactor[2] ;
	UCHAR Reserved2  /*:4*/;
	UCHAR SurfaceFirst  /* :1*/;
	UCHAR RemovableMedia  /* :1*/;
	UCHAR HardSectorFormating  /* :1*/;
	UCHAR SoftSectorFormating  /* :1*/;
	UCHAR Reserved3[3] ;
} MODE_FORMAT_PAGE , *  PMODE_FORMAT_PAGE ;

// #line 1898
typedef struct _MODE_RIGID_GEOMETRY_PAGE {
	UCHAR PageCode  /*:6*/;
	UCHAR Reserved  /* :1*/;
	UCHAR PageSavable  /* :1*/;
	UCHAR PageLength ;
	UCHAR NumberOfCylinders[3] ;
	UCHAR NumberOfHeads ;
	UCHAR StartWritePrecom[3] ;
	UCHAR StartReducedCurrent[3] ;
	UCHAR DriveStepRate[2] ;
	UCHAR LandZoneCyclinder[3] ;
	UCHAR RotationalPositionLock  /*:2*/;
	UCHAR Reserved2  /*:6*/;
	UCHAR RotationOffset ;
	UCHAR Reserved3 ;
	UCHAR RoataionRate[2] ;
	UCHAR Reserved4[2] ;
} MODE_RIGID_GEOMETRY_PAGE , *  PMODE_RIGID_GEOMETRY_PAGE ;

// #line 1921
typedef struct _MODE_READ_WRITE_RECOVERY_PAGE {
	UCHAR PageCode  /*:6*/;
	UCHAR Reserved1  /* :1*/;
	UCHAR PSBit  /* :1*/;
	UCHAR PageLength ;
	UCHAR DCRBit  /* :1*/;
	UCHAR DTEBit  /* :1*/;
	UCHAR PERBit  /* :1*/;
	UCHAR EERBit  /* :1*/;
	UCHAR RCBit  /* :1*/;
	UCHAR TBBit  /* :1*/;
	UCHAR ARRE  /* :1*/;
	UCHAR AWRE  /* :1*/;
	UCHAR ReadRetryCount ;
	UCHAR Reserved4[4] ;
	UCHAR WriteRetryCount ;
	UCHAR Reserved5[3] ;
} MODE_READ_WRITE_RECOVERY_PAGE , *  PMODE_READ_WRITE_RECOVERY_PAGE ;

// #line 1946
typedef struct _MODE_READ_RECOVERY_PAGE {
	UCHAR PageCode  /*:6*/;
	UCHAR Reserved1  /* :1*/;
	UCHAR PSBit  /* :1*/;
	UCHAR PageLength ;
	UCHAR DCRBit  /* :1*/;
	UCHAR DTEBit  /* :1*/;
	UCHAR PERBit  /* :1*/;
	UCHAR Reserved2  /* :1*/;
	UCHAR RCBit  /* :1*/;
	UCHAR TBBit  /* :1*/;
	UCHAR Reserved3  /*:2*/;
	UCHAR ReadRetryCount ;
	UCHAR Reserved4[4] ;
} MODE_READ_RECOVERY_PAGE , *  PMODE_READ_RECOVERY_PAGE ;

// #line 1969
typedef struct _MODE_INFO_EXCEPTIONS {
	UCHAR PageCode  /*:6*/;
	UCHAR Reserved1  /* :1*/;
	UCHAR PSBit  /* :1*/;
	UCHAR PageLength ;
	UCHAR LogErr  /* :1*/;
	UCHAR Reserved2  /* :1*/;
	UCHAR Test  /* :1*/;
	UCHAR Dexcpt  /* :1*/;
	UCHAR Reserved3  /*:3*/;
	UCHAR Perf  /* :1*/;
	UCHAR ReportMethod  /*:4*/;
	UCHAR Reserved4  /*:4*/;
	UCHAR IntervalTimer[4] ;
	UCHAR ReportCount[4] ;
} MODE_INFO_EXCEPTIONS , *  PMODE_INFO_EXCEPTIONS ;

// #line 2000
typedef struct _POWER_CONDITION_PAGE {
	UCHAR PageCode  /*:6*/;
	UCHAR Reserved  /* :1*/;
	UCHAR PSBit  /* :1*/;
	UCHAR PageLength ;
	UCHAR Reserved2 ;
	UCHAR Standby  /* :1*/;
	UCHAR Idle  /* :1*/;
	UCHAR Reserved3  /*:6*/;
	UCHAR IdleTimer[4] ;
	UCHAR StandbyTimer[4] ;
} POWER_CONDITION_PAGE , *  PPOWER_CONDITION_PAGE ;

// #line 2019
typedef struct _CDDA_OUTPUT_PORT {
	UCHAR ChannelSelection  /*:4*/;
	UCHAR Reserved  /*:4*/;
	UCHAR Volume ;
} CDDA_OUTPUT_PORT , *  PCDDA_OUTPUT_PORT ;

// #line 2026
typedef struct _CDAUDIO_CONTROL_PAGE {
	UCHAR PageCode  /*:6*/;
	UCHAR Reserved  /* :1*/;
	UCHAR PSBit  /* :1*/;
	UCHAR PageLength ;
	UCHAR Reserved2  /* :1*/;
	UCHAR StopOnTrackCrossing  /* :1*/;
	UCHAR Immediate  /* :1*/;
	UCHAR Reserved3  /*:5*/;
	UCHAR Reserved4[3] ;
	UCHAR Obsolete[2] ;
	CDDA_OUTPUT_PORT CDDAOutputPorts[4] ;
} CDAUDIO_CONTROL_PAGE , *  PCDAUDIO_CONTROL_PAGE ;

// #line 2055
typedef struct _CDVD_FEATURE_SET_PAGE {
	UCHAR PageCode  /*:6*/;
	UCHAR Reserved  /* :1*/;
	UCHAR PSBit  /* :1*/;
	UCHAR PageLength ;
	UCHAR CDAudio[2] ;
	UCHAR EmbeddedChanger[2] ;
	UCHAR PacketSMART[2] ;
	UCHAR PersistantPrevent[2] ;
	UCHAR EventStatusNotification[2] ;
	UCHAR DigitalOutput[2] ;
	UCHAR CDSequentialRecordable[2] ;
	UCHAR DVDSequentialRecordable[2] ;
	UCHAR RandomRecordable[2] ;
	UCHAR KeyExchange[2] ;
	UCHAR Reserved2[2] ;
} CDVD_FEATURE_SET_PAGE , *  PCDVD_FEATURE_SET_PAGE ;

// #line 2079
typedef struct _CDVD_INACTIVITY_TIMEOUT_PAGE {
	UCHAR PageCode  /*:6*/;
	UCHAR Reserved  /* :1*/;
	UCHAR PSBit  /* :1*/;
	UCHAR PageLength ;
	UCHAR Reserved2[2] ;
	UCHAR SWPP  /* :1*/;
	UCHAR DISP  /* :1*/;
	UCHAR Reserved3  /*:6*/;
	UCHAR Reserved4 ;
	UCHAR GroupOneMinimumTimeout[2] ;
	UCHAR GroupTwoMinimumTimeout[2] ;
} CDVD_INACTIVITY_TIMEOUT_PAGE , *  PCDVD_INACTIVITY_TIMEOUT_PAGE ;

// #line 2110
typedef struct _CDVD_CAPABILITIES_PAGE {
	UCHAR PageCode  /*:6*/;
	UCHAR Reserved  /* :1*/;
	UCHAR PSBit  /* :1*/;
	UCHAR PageLength ;
	UCHAR CDRRead  /* :1*/;
	UCHAR CDERead  /* :1*/;
	UCHAR Method2  /* :1*/;
	UCHAR DVDROMRead  /* :1*/;
	UCHAR DVDRRead  /* :1*/;
	UCHAR DVDRAMRead  /* :1*/;
	UCHAR Reserved2  /*:2*/;
	UCHAR CDRWrite  /* :1*/;
	UCHAR CDEWrite  /* :1*/;
	UCHAR TestWrite  /* :1*/;
	UCHAR Reserved3  /* :1*/;
	UCHAR DVDRWrite  /* :1*/;
	UCHAR DVDRAMWrite  /* :1*/;
	UCHAR Reserved4  /*:2*/;
	UCHAR AudioPlay  /* :1*/;
	UCHAR Composite  /* :1*/;
	UCHAR DigitalPortOne  /* :1*/;
	UCHAR DigitalPortTwo  /* :1*/;
	UCHAR Mode2Form1  /* :1*/;
	UCHAR Mode2Form2  /* :1*/;
	UCHAR MultiSession  /* :1*/;
	UCHAR Reserved5  /* :1*/;
	UCHAR CDDA  /* :1*/;
	UCHAR CDDAAccurate  /* :1*/;
	UCHAR RWSupported  /* :1*/;
	UCHAR RWDeinterleaved  /* :1*/;
	UCHAR C2Pointers  /* :1*/;
	UCHAR ISRC  /* :1*/;
	UCHAR UPC  /* :1*/;
	UCHAR ReadBarCodeCapable  /* :1*/;
	UCHAR Lock  /* :1*/;
	UCHAR LockState  /* :1*/;
	UCHAR PreventJumper  /* :1*/;
	UCHAR Eject  /* :1*/;
	UCHAR Reserved6  /* :1*/;
	UCHAR LoadingMechanismType  /*:3*/;
	UCHAR SeparateVolume  /* :1*/;
	UCHAR SeperateChannelMute  /* :1*/;
	UCHAR SupportsDiskPresent  /* :1*/;
	UCHAR SWSlotSelection  /* :1*/;
	UCHAR SideChangeCapable  /* :1*/;
	UCHAR RWInLeadInReadable  /* :1*/;
	UCHAR Reserved7  /*:2*/;
	UCHAR ObsoleteReserved[2] ;
	UCHAR NumberVolumeLevels[2] ;
	UCHAR BufferSize[2] ;
	UCHAR ObsoleteReserved2[2] ;
	UCHAR ObsoleteReserved3 ;
	UCHAR Reserved8  /* :1*/;
	UCHAR BCK  /* :1*/;
	UCHAR RCK  /* :1*/;
	UCHAR LSBF  /* :1*/;
	UCHAR Length  /*:2*/;
	UCHAR Reserved9  /*:2*/;
	UCHAR ObsoleteReserved4[2] ;
	UCHAR CopyManagementRevision[2] ;
	UCHAR Reserved10[2] ;
} CDVD_CAPABILITIES_PAGE , *  PCDVD_CAPABILITIES_PAGE ;

// #line 2185
typedef struct _LUN_LIST {
	UCHAR LunListLength[4] ;
	UCHAR Reserved[4] ;
	UCHAR Lun[0][8] ;
} LUN_LIST , *  PLUN_LIST ;

// #line 2211
typedef struct _MODE_PARM_READ_WRITE {
	MODE_PARAMETER_HEADER ParameterListHeader ;
	MODE_PARAMETER_BLOCK ParameterListBlock ;
} MODE_PARM_READ_WRITE_DATA , *  PMODE_PARM_READ_WRITE_DATA ;

// #line 2242
typedef struct _PORT_OUTPUT {
	UCHAR ChannelSelection ;
	UCHAR Volume ;
} PORT_OUTPUT , *  PPORT_OUTPUT ;

typedef struct _AUDIO_OUTPUT {
	UCHAR CodePage ;
	UCHAR ParameterLength ;
	UCHAR Immediate ;
	UCHAR Reserved[2] ;
	UCHAR LbaFormat ;
	UCHAR LogicalBlocksPerSecond[2] ;
	PORT_OUTPUT PortOutput[4] ;
} AUDIO_OUTPUT , *  PAUDIO_OUTPUT ;

// #line 2268
typedef struct _MECHANICAL_STATUS_INFORMATION_HEADER {
	UCHAR CurrentSlot  /*:5*/;
	UCHAR ChangerState  /*:2*/;
	UCHAR Fault  /* :1*/;
	UCHAR Reserved  /*:5*/;
	UCHAR MechanismState  /*:3*/;
	UCHAR CurrentLogicalBlockAddress[3] ;
	UCHAR NumberAvailableSlots ;
	UCHAR SlotTableLength[2] ;
} MECHANICAL_STATUS_INFORMATION_HEADER , * 
	PMECHANICAL_STATUS_INFORMATION_HEADER ;

// #line 2279
typedef struct _SLOT_TABLE_INFORMATION {
	UCHAR DiscChanged  /* :1*/;
	UCHAR Reserved  /*:6*/;
	UCHAR DiscPresent  /* :1*/;
	UCHAR Reserved2[3] ;
} SLOT_TABLE_INFORMATION , *  PSLOT_TABLE_INFORMATION ;

typedef struct _MECHANICAL_STATUS {
	MECHANICAL_STATUS_INFORMATION_HEADER MechanicalStatusHeader ;
	SLOT_TABLE_INFORMATION SlotTableInfo[1] ;
} MECHANICAL_STATUS , *  PMECHANICAL_STATUS ;

// #line 2298
typedef struct _TAPE_POSITION_DATA {
	UCHAR Reserved1  /*:2*/;
	UCHAR BlockPositionUnsupported  /* :1*/;
	UCHAR Reserved2  /*:3*/;
	UCHAR EndOfPartition  /* :1*/;
	UCHAR BeginningOfPartition  /* :1*/;
	UCHAR PartitionNumber ;
	USHORT Reserved3 ;
	UCHAR FirstBlock[4] ;
	UCHAR LastBlock[4] ;
	UCHAR Reserved4 ;
	UCHAR NumberOfBlocks[3] ;
	UCHAR NumberOfBytes[4] ;
} TAPE_POSITION_DATA , *  PTAPE_POSITION_DATA ;

// #line 2318
typedef union _FOUR_BYTE {
	struct  {
		UCHAR Byte0 ;
		UCHAR Byte1 ;
		UCHAR Byte2 ;
		UCHAR Byte3 ;
	}  ;
	ULONG AsULong ;
} FOUR_BYTE , *  PFOUR_BYTE ;

// #line 2330
typedef union _TWO_BYTE {
	struct  {
		UCHAR Byte0 ;
		UCHAR Byte1 ;
	}  ;
	USHORT AsUShort ;
} TWO_BYTE , *  PTWO_BYTE ;

// #line 59 "cdaudio.h"
typedef struct _CD_DEVICE_EXTENSION {
	PDEVICE_OBJECT TargetDeviceObject ;
	PDEVICE_OBJECT TargetPdo ;
	PDEVICE_OBJECT DeviceObject ;
	ULONG PagingPathCount ;
	KEVENT PagingPathCountEvent ;
	PRKDPC Dpc ;
	PKTIMER Timer ;
	LONG Sync ;
	UCHAR Active ;
	UCHAR Paused ;
	UCHAR PausedM ;
	UCHAR PausedS ;
	UCHAR PausedF ;
	UCHAR LastEndM ;
	UCHAR LastEndS ;
	UCHAR LastEndF ;
	BOOLEAN PlayActive ;
} CD_DEVICE_EXTENSION , *  PCD_DEVICE_EXTENSION ;

// #line 210
typedef union _NEC_CDB {
	struct _NEC_READ_TOC {
		UCHAR OperationCode ;
		UCHAR Type  /*:2*/;
		UCHAR Reserved1  /*:6*/;
		UCHAR TrackNumber ;
		UCHAR Reserved2[6] ;
		UCHAR Control ;
	} NEC_READ_TOC , *  PNEC_READ_TOC ;
	struct _NEC_PLAY_AUDIO {
		UCHAR OperationCode ;
		UCHAR PlayMode  /*:3*/;
		UCHAR Reserved1  /*:5*/;
		UCHAR Minute ;
		UCHAR Second ;
		UCHAR Frame ;
		UCHAR Reserved2[4] ;
		UCHAR Control ;
	} NEC_PLAY_AUDIO , *  PNEC_PLAY_AUDIO ;
	struct _NEC_SEEK_AUDIO {
		UCHAR OperationCode ;
		UCHAR Play  /* :1*/;
		UCHAR Reserved1  /*:7*/;
		UCHAR Minute ;
		UCHAR Second ;
		UCHAR Frame ;
		UCHAR Reserved2[4] ;
		UCHAR Control ;
	} NEC_SEEK_AUDIO , *  PNEC_SEEK_AUDIO ;
	struct _NEC_PAUSE_AUDIO {
		UCHAR OperationCode ;
		UCHAR Reserved1[8] ;
		UCHAR Control ;
	} NEC_PAUSE_AUDIO , *  PNEC_PAUSE_AUDIO ;
	struct _NEC_READ_Q_CHANNEL {
		UCHAR OperationCode ;
		UCHAR TransferSize  /*:5*/;
		UCHAR Reserved1  /*:3*/;
		UCHAR Reserved2[7] ;
		UCHAR Control ;
	} NEC_READ_Q_CHANNEL , *  PNEC_READ_Q_CHANNEL ;
	struct _NEC_EJECT {
		UCHAR OperationCode ;
		UCHAR Immediate  /* :1*/;
		UCHAR Reserved1  /*:7*/;
		UCHAR Reserved2[7] ;
		UCHAR Control ;
	} NEC_EJECT , *  PNEC_EJECT ;
} NEC_CDB , *  PNEC_CDB ;

// #line 322
typedef struct _PIONEER_DRIVE_STATUS_BUFFER {
	UCHAR PageCode  /*:6*/;
	UCHAR Reserved  /*:2*/;
	UCHAR PageLengthMsb ;
	UCHAR PageLengthLsb ;
	UCHAR DriveStatusLsb ;
	UCHAR DriveStatusMsb ;
} PIONEER_DRIVE_STATUS_BUFFER , *  PPIONEER_DRIVE_STATUS_BUFFER ;

// #line 337
typedef union _PIONEER_CDB {
	struct _PNR_START_STOP {
		UCHAR OperationCode ;
		UCHAR Immediate  /* :1*/;
		UCHAR Reserved1  /*:4*/;
		UCHAR Lun  /*:3*/;
		UCHAR Reserved2  /*:7*/;
		UCHAR PCF  /* :1*/;
		UCHAR Reserved3 ;
		UCHAR Start  /* :1*/;
		UCHAR Eject  /* :1*/;
		UCHAR Reserved4  /*:6*/;
		UCHAR Link  /* :1*/;
		UCHAR Flag  /* :1*/;
		UCHAR Reserved5  /*:4*/;
		UCHAR Vendor  /*:2*/;
	} PNR_START_STOP , *  PPNR_START_STOP ;
	struct _PNR_READ_TOC {
		UCHAR OperationCode ;
		UCHAR Reserved1  /*:5*/;
		UCHAR Lun  /*:3*/;
		UCHAR Reserved2[3] ;
		UCHAR TrackNumber ;
		UCHAR Reserved3 ;
		UCHAR AssignedLength[2] ;
		UCHAR Link  /* :1*/;
		UCHAR Flag  /* :1*/;
		UCHAR Reserved4  /*:4*/;
		UCHAR Type  /*:2*/;
	} PNR_READ_TOC , *  PPNR_READ_TOC ;
	struct _PNR_PLAY_AUDIO {
		UCHAR OperationCode ;
		UCHAR PlayMode  /*:4*/;
		UCHAR StopAddr  /* :1*/;
		UCHAR Lun  /*:3*/;
		UCHAR Reserved1 ;
		UCHAR Minute ;
		UCHAR Second ;
		UCHAR Frame ;
		UCHAR Reserved2[3] ;
		UCHAR Link  /* :1*/;
		UCHAR Flag  /* :1*/;
		UCHAR Reserved3  /*:4*/;
		UCHAR Type  /*:2*/;
	} PNR_PLAY_AUDIO , *  PPNR_PLAY_AUDIO ;
	struct _PNR_SEEK_AUDIO {
		UCHAR OperationCode ;
		UCHAR PlayMode  /*:4*/;
		UCHAR PlayBack  /* :1*/;
		UCHAR Lun  /*:3*/;
		UCHAR Reserved1 ;
		UCHAR Minute ;
		UCHAR Second ;
		UCHAR Frame ;
		UCHAR Reserved2[3] ;
		UCHAR Link  /* :1*/;
		UCHAR Flag  /* :1*/;
		UCHAR Reserved3  /*:4*/;
		UCHAR Type  /*:2*/;
	} PNR_SEEK_AUDIO , *  PPNR_SEEK_AUDIO ;
	struct _PNR_PAUSE_AUDIO {
		UCHAR OperationCode ;
		UCHAR Reserved1  /*:4*/;
		UCHAR Pause  /* :1*/;
		UCHAR Lun  /*:3*/;
		UCHAR Reserved2[7] ;
		UCHAR Link  /* :1*/;
		UCHAR Flag  /* :1*/;
		UCHAR Reserved3  /*:4*/;
		UCHAR Reserved4  /*:2*/;
	} PNR_PAUSE_AUDIO , *  PPNR_PAUSE_AUDIO ;
	struct _PNR_AUDIO_STATUS {
		UCHAR OperationCode ;
		UCHAR Reserved1  /*:4*/;
		UCHAR Reserved2  /* :1*/;
		UCHAR Lun  /*:3*/;
		UCHAR Reserved3[6] ;
		UCHAR AssignedLength ;
		UCHAR Link  /* :1*/;
		UCHAR Flag  /* :1*/;
		UCHAR Reserved4  /*:4*/;
		UCHAR Reserved5  /*:2*/;
	} PNR_AUDIO_STATUS , *  PPNR_AUDIO_STATUS ;
	struct _PNR_READ_Q_CHANNEL {
		UCHAR OperationCode ;
		UCHAR Reserved1  /*:4*/;
		UCHAR Reserved2  /* :1*/;
		UCHAR Lun  /*:3*/;
		UCHAR Reserved3[6] ;
		UCHAR AssignedLength ;
		UCHAR Link  /* :1*/;
		UCHAR Flag  /* :1*/;
		UCHAR Reserved4  /*:4*/;
		UCHAR Reserved5  /*:2*/;
	} PNR_READ_Q_CHANNEL , *  PPNR_READ_Q_CHANNEL ;
	struct _PNR_EJECT {
		UCHAR OperationCode ;
		UCHAR Immediate  /* :1*/;
		UCHAR Reserved1  /*:4*/;
		UCHAR Lun  /*:3*/;
		UCHAR Reserved2[7] ;
		UCHAR Link  /* :1*/;
		UCHAR Flag  /* :1*/;
		UCHAR Reserved4  /*:4*/;
		UCHAR Reserved5  /*:2*/;
	} PNR_EJECT , *  PPNR_EJECT ;
	struct _PNR_READ_STATUS {
		UCHAR OperationCode ;
		UCHAR Reserved1  /*:4*/;
		UCHAR Lun  /*:3*/;
		UCHAR PageCode  /*:5*/;
		UCHAR PCField  /* :1*/;
		UCHAR Reserved2[5] ;
		UCHAR AllocationLengthMsb ;
		UCHAR AllocationLengthLsb ;
		UCHAR Link  /* :1*/;
		UCHAR Flag  /* :1*/;
		UCHAR Reserved3  /*:4*/;
		UCHAR Reserved4  /*:2*/;
	} PNR_READ_STATUS , *  PPNR_READ_STATUS ;
} PNR_CDB , *  PPNR_CDB ;

// #line 528
typedef union _HITACHICDB {
	struct _READ_DISC_INFO {
		UCHAR OperationCode ;
		UCHAR Reserved  /*:5*/;
		UCHAR LogicalUnitNumber  /*:3*/;
		UCHAR Reserved1[7] ;
		UCHAR AllocationLength[2] ;
		UCHAR Link  /* :1*/;
		UCHAR Flag  /* :1*/;
		UCHAR Reserved2  /*:4*/;
		UCHAR VendorUniqueBits  /*:2*/;
	} READ_DISC_INFO , *  PREAD_DISC_INFO ;
	struct  {
		UCHAR OperationCode ;
		UCHAR Immediate  /* :1*/;
		UCHAR Right  /* :1*/;
		UCHAR Left  /* :1*/;
		UCHAR Reserved  /*:2*/;
		UCHAR Lun  /*:3*/;
		UCHAR StartingM ;
		UCHAR StartingS ;
		UCHAR StartingF ;
		UCHAR Reserved1[2] ;
		UCHAR EndingM ;
		UCHAR EndingS ;
		UCHAR EndingF ;
		UCHAR Reserved2 ;
		UCHAR Link  /* :1*/;
		UCHAR Flag  /* :1*/;
		UCHAR Reserved3  /*:4*/;
		UCHAR VendorUniqueBits  /*:2*/;
	} PLAY_AUDIO , *  PPLAY_AUDIO ;
	struct _PAUSE {
		UCHAR OperationCode ;
		UCHAR Reserved  /*:5*/;
		UCHAR Lun  /*:3*/;
		UCHAR Reserved1[9] ;
		UCHAR Link  /* :1*/;
		UCHAR Flag  /* :1*/;
		UCHAR Reserved2  /*:4*/;
		UCHAR VendorUnqiueBits  /*:2*/;
	} PAUSE_AUDIO , *  PPAUSE_AUDIO ;
	struct _EJECT {
		UCHAR OperationCode ;
		UCHAR Reserved  /*:5*/;
		UCHAR Lun  /*:3*/;
		UCHAR Reserved1[8] ;
		UCHAR Eject  /* :1*/;
		UCHAR Mode  /* :1*/;
		UCHAR Reserved2  /*:6*/;
		UCHAR Link  /* :1*/;
		UCHAR Flag  /* :1*/;
		UCHAR Reserved3  /*:4*/;
		UCHAR VendorUnqiueBits  /*:2*/;
	} EJECT , *  PEJECT ;
	struct _AUDIO_STATUS {
		UCHAR OperationCode ;
		UCHAR Reserved  /*:5*/;
		UCHAR Lun  /*:3*/;
		UCHAR Reserved1[9] ;
		UCHAR Link  /* :1*/;
		UCHAR Flag  /* :1*/;
		UCHAR Reserved2  /*:4*/;
		UCHAR VendorUnqiueBits  /*:2*/;
	} AUDIO_STATUS , *  PAUDIO_STATUS ;
	struct _STOP_PLAY {
		UCHAR OperationCode ;
		UCHAR Reserved[11] ;
	} STOP_PLAY , *  PSTOP_PLAY ;
} HITACHICDB , *  PHITACHICDB ;
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// #line 45 "cdaudio.c"
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

int s ;
int UNLOADED , NP , DC , SKIP1 , SKIP2 , MPR1 , MPR3 , IPC ;
int pended ;
PIO_COMPLETION_ROUTINE compFptr ;
int compRegistered ;
int lowerDriverReturn ;
int setEventCalled ;
int customIrp ;
int routine ;
int myStatus ;
// TRACER to shadow variable for Irp->PendingReturned
int myIrpPendingReturned; 

void _BLAST_init()
{
  UNLOADED = 0;
  NP = 1;
  DC = 2;
  SKIP1 = 3;
  SKIP2 = 4;
  MPR1 = 5;
  MPR3 = 6;
  IPC = 7;
  s = UNLOADED;
  pended = 0;
  compFptr = (PIO_COMPLETION_ROUTINE) 0;
  compRegistered = 0;
  lowerDriverReturn = 0;
  setEventCalled = 0;
  customIrp = 0;
}


NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject , PUNICODE_STRING RegistryPath ) ;
NTSTATUS CdAudioCreate(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
NTSTATUS CdAudioReadWrite(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
NTSTATUS CdAudioDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
NTSTATUS CdAudioSendToNextDriver(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
BOOLEAN CdAudioIsPlayActive(PDEVICE_OBJECT DeviceObject ) ;
BOOLEAN NecSupportNeeded(PUCHAR InquiryData ) ;
NTSTATUS CdAudioNECDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
NTSTATUS CdAudioPioneerDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
NTSTATUS CdAudioDenonDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
NTSTATUS CdAudioHitachiSendPauseCommand(PDEVICE_OBJECT DeviceObject ) ;
NTSTATUS CdAudioHitachiDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
NTSTATUS CdAudio535DeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
NTSTATUS CdAudio435DeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
NTSTATUS CdAudioPan533DeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
NTSTATUS CdAudioAtapiDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
NTSTATUS CdAudioLionOpticsDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp );
NTSTATUS CdAudioHPCdrDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
void HpCdrProcessLastSession(PCDROM_TOC Toc ) ;
NTSTATUS HPCdrCompletion(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context) ;
NTSTATUS CdAudioPower(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
NTSTATUS CdAudioForwardIrpSynchronous(PDEVICE_OBJECT DeviceObject , PIRP Irp ) ;
void CdAudioUnload(PDRIVER_OBJECT DriverObject ) ;

NTSTATUS SendSrbSynchronous(PCD_DEVICE_EXTENSION Extension , PSCSI_PASS_THROUGH Srb ,
			    PVOID Buffer , ULONG BufferLength )
{
  ULONG ioctl ;
  KEVENT event ;
  PIRP irp;
  IO_STATUS_BLOCK ioStatus ;
  NTSTATUS status;

  irp = (void *  )0;
  Srb->Length = sizeof(SCSI_PASS_THROUGH );
  Srb->SenseInfoLength = 0;
  Srb->SenseInfoOffset = 0;
  if(Buffer)
    {
      Srb->DataIn = 1;
      Srb->DataTransferLength = BufferLength;
      Srb->DataBufferOffset = (ULONG_PTR )Buffer;
      ioctl = 0x00000004 << 16 | (0x0001 | 0x0002) << 14 | 0x0405 << 2 | 0;
    }
  else
    {
      Srb->DataIn = 0;
      Srb->DataTransferLength = 0;
      Srb->DataBufferOffset = 0;
      ioctl = 0x00000004 << 16 | (0x0001 | 0x0002) << 14 | 0x0401 << 2 | 0;
    }
  KeInitializeEvent(& event, NotificationEvent, 0);
  /*BLAST
    irp = IoBuildDeviceIoControlRequest(ioctl,
    Extension->TargetDeviceObject, Srb, sizeof(SCSI_PASS_THROUGH ),
    Srb, sizeof(SCSI_PASS_THROUGH ), 0, & event, & ioStatus);
  */
  if(! irp)
      return (NTSTATUS )0xC000009AL;

  /*BLAST
    status= IofCallDriver(Extension->TargetDeviceObject,irp);    
  */
  
  if(status== (NTSTATUS )0x00000103L)
    {
      KeWaitForSingleObject(& event, Executive, KernelMode, 0, (void *  )0);
      // TRACER 
      // ioStatus.Status can take any value here which is unsafe!
      // status= ioStatus.Status;
      status= myStatus; 
    }
  return status;
}


NTSTATUS IoOpenDeviceRegistryKey(PDEVICE_OBJECT DeviceObject ,
				 ULONG DevInstKeyType , ACCESS_MASK DesiredAccess ,
				 PHANDLE DevInstRegKey ){
  NTSTATUS x; return x;
}

NTSTATUS CdAudioAddDevice(PDRIVER_OBJECT DriverObject , PDEVICE_OBJECT PhysicalDeviceObject )
{
  NTSTATUS status;
  PDEVICE_OBJECT deviceObject ;
  PCD_DEVICE_EXTENSION extension ;
  ULONG regActive;
  HANDLE deviceParameterHandle ;
  RTL_QUERY_REGISTRY_TABLE queryTable[2] ;

  regActive = 0xFF;  
  status= IoOpenDeviceRegistryKey(PhysicalDeviceObject, 2,
				  (0x00020000L | 0x0001 | 0x0008 | 0x0010) & /* ~ */
				  0x00100000L, & deviceParameterHandle);
  if(! ((NTSTATUS )status>= 0))
    {
      regActive = 0xFF;
      goto AddDeviceEndRegistry;
    }
  memset(& queryTable, 0, sizeof(queryTable));
  queryTable->Flags = 0x00000020 | 0x00000004;
  queryTable->Name = "M\0a\0p\0T\0y\0p\0e\0";
  queryTable->EntryContext = & regActive;
  queryTable->DefaultType = 4;
  queryTable->DefaultData = (void *  )0;
  queryTable->DefaultLength = 0;
  status= RtlQueryRegistryValues(0x40000000,
				 (PWSTR )deviceParameterHandle, queryTable, (void *  )0,
				 (void *  )0);
  if(! ((NTSTATUS )status>= 0))
    regActive = 0xFF;
  else
    {
      if(regActive > 10)
	regActive = 0xFF;
    }
  ZwClose(deviceParameterHandle);
  
 AddDeviceEndRegistry:
  if(regActive > 10 && regActive != 0xFF)
    regActive = 0xFF;
  if(regActive == 0)
    return (NTSTATUS )0x00000000L;
  switch(regActive)
    {
    case 8:
      MmLockPagableDataSection((PVOID )CdAudioNECDeviceControl);
      break;
    case 9:
    case 10:
      MmLockPagableDataSection((PVOID )CdAudioPioneerDeviceControl);
      break;
    case 4:
      MmLockPagableDataSection((PVOID )CdAudioDenonDeviceControl);
      break;
    case 6:
    case 5:
      MmLockPagableDataSection((PVOID )CdAudioHitachiDeviceControl);
      break;
    case 2:
      MmLockPagableDataSection((PVOID )CdAudio535DeviceControl);
      break;
    case 3:
      MmLockPagableDataSection((PVOID )CdAudio435DeviceControl);
      break;
    case 1:
      MmLockPagableDataSection((PVOID )CdAudioAtapiDeviceControl);
      break;
    case 7:
      MmLockPagableDataSection((PVOID )CdAudioHPCdrDeviceControl);
      break;
    case 0xFF:
    default :
      break;
    }

  status= IoCreateDevice(DriverObject,
			 sizeof(CD_DEVICE_EXTENSION ), (void *  )0, 0x00000002, 0, 0, 
			 & deviceObject);
  if(! ((NTSTATUS )status>= 0))
      return status;

  deviceObject->Flags |= 0x00000010;
  if(deviceObject->Flags & 0x00004000){ }
  else
      deviceObject->Flags |= 0x00002000;
  extension = deviceObject->DeviceExtension;
  memset(extension, 0, sizeof(CD_DEVICE_EXTENSION ));
  extension->TargetDeviceObject =IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);
  if(! extension->TargetDeviceObject)
    {
      IoDeleteDevice(deviceObject);
      return (NTSTATUS )0xC000000EL;
    }
  KeInitializeEvent(& extension->PagingPathCountEvent,SynchronizationEvent, 1);
  extension->Active = (UCHAR )regActive;
  extension->DeviceObject = deviceObject;
  extension->TargetPdo = PhysicalDeviceObject;
  deviceObject->Flags = deviceObject->Flags & /* ~ */ 0x00000080;
  return (NTSTATUS )0x00000000L;
}

NTSTATUS CdAudioSignalCompletion(PDEVICE_OBJECT DeviceObject , PIRP Irp , PKEVENT Event )
{
  KeSetEvent(Event, 0, 0);
  return (NTSTATUS )0xC0000016L;
}

NTSTATUS CdAudioStartDevice(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
  PCD_DEVICE_EXTENSION deviceExtension;
  NTSTATUS status ;
  KEVENT event ;
  SCSI_PASS_THROUGH srb ;
  PCDB cdb;
  PUCHAR inquiryDataPtr;
  HANDLE deviceParameterHandle ;
  ULONG keyValue;
  UCHAR attempt;
  ULONG tag__1;
  // Some abstraction ...
  int temp_1, temp_2, temp_3, temp_4, temp_5,temp_6,temp_7,temp_8;
  int temp_9, temp_10, temp_11, temp_12, temp_13,temp_14,temp_15,temp_16;
  int temp_17,temp_18, temp_19, temp_20;

  inquiryDataPtr = (void *  )0;
  cdb = (PCDB )srb.Cdb;
  attempt = 0;
  deviceExtension = DeviceObject->DeviceExtension;
  status= CdAudioForwardIrpSynchronous(DeviceObject, Irp);
				       
  if(! ((NTSTATUS )status>= 0))
      return status;

  deviceExtension->Paused = 0;
  deviceExtension->PausedM = 0;
  deviceExtension->PausedS = 0;
  deviceExtension->PausedF = 0;
  deviceExtension->LastEndM = 0;
  deviceExtension->LastEndS = 0;
  deviceExtension->LastEndF = 0;

  if(deviceExtension->Active == (UCHAR )0xFF)
    {
      inquiryDataPtr = (PUCHAR )ExAllocatePoolWithTag(NonPagedPoolCacheAligned, 36, tag__1 /*' AdC'*/);
      if(! inquiryDataPtr)
	{
	  deviceExtension->Active = 0;
	  return (NTSTATUS )0x00000000L;
	}
      status= (NTSTATUS )0xC0000001L;
      // TRACER: not sure it doesn't affect safety ....
      while(! ((NTSTATUS )status>= 0) && attempt/* ++ */ < 4)
	{
	  attempt++;
	  memset(& srb, 0, sizeof(SCSI_PASS_THROUGH ));
	  memset(inquiryDataPtr, 0, 36);
	  (cdb->CDB6INQUIRY).OperationCode = 0x12;
	  (cdb->CDB6INQUIRY).AllocationLength = 36;
	  srb.CdbLength = 6;
	  srb.TimeOutValue = 10;
	  status= SendSrbSynchronous(deviceExtension, & srb,inquiryDataPtr, 36);
	} // end of while 
      if(! ((NTSTATUS )status>= 0))
	{
	  ExFreePool(inquiryDataPtr);
	  deviceExtension->Active = 0;
	  return (NTSTATUS )0x00000000L;
	}
      {
	deviceExtension->Active = 0;
	// #line 861
	

	temp_19 = memcmp(& inquiryDataPtr[8], "NEC     ", 8);
	if(! temp_19)
	  {
	    temp_20 =  NecSupportNeeded(inquiryDataPtr);
	    if(temp_20)
	      {
		MmLockPagableDataSection((PVOID)CdAudioNECDeviceControl);
		deviceExtension->Active = 8;
	      }
	  }
	
	temp_1 = memcmp(& inquiryDataPtr[8], "PIONEER ", 8);
	temp_2 = memcmp(& inquiryDataPtr[16], "CD-ROM DRM-600",15);
	if(!temp_1  && !temp_2 )		  
	  {
	    MmLockPagableDataSection((PVOID)CdAudioPioneerDeviceControl);  
	    deviceExtension->Active = 9;
	  }
	if(temp_3 /* inquiryDataPtr[8] == 'D' && inquiryDataPtr[9] == 'E' && */
	   /* inquiryDataPtr[10] == 'N' && */
	   /* inquiryDataPtr[16] == 'D' && inquiryDataPtr[17] == 'R' && */
	   /* inquiryDataPtr[18] == 'D' && inquiryDataPtr[20] == '2' && */
	   /* inquiryDataPtr[21] == '5' && inquiryDataPtr[22] == 'X' */)	   
	  {
	    MmLockPagableDataSection((PVOID)CdAudioDenonDeviceControl);
	    deviceExtension->Active = 4;
	  }
	temp_4 = memcmp(& inquiryDataPtr[8], "CHINON", 6);
	if(! temp_4)
	  {

	    if(temp_5 /* inquiryDataPtr[27] == '5' && */
	       /* inquiryDataPtr[28] == '3' && */
	       /* inquiryDataPtr[29] == '5' && */
	       /* inquiryDataPtr[32] == 'Q' */)
	      {
		MmLockPagableDataSection((PVOID)CdAudio535DeviceControl);
		deviceExtension->Active = 2;
	      }
	    if(temp_6 /* inquiryDataPtr[27] == '4' && */
	       /* inquiryDataPtr[28] == '3' && */
	       /* (inquiryDataPtr[29] == '5' || inquiryDataPtr[29] == '1') && */
	       /* (inquiryDataPtr[32] == 'M' || */
	       /* inquiryDataPtr[32] == 'N' || */
	       /* inquiryDataPtr[32] == 'S' || */
	       /* inquiryDataPtr[32] == 'U' || */
	       /* inquiryDataPtr[32] == 'H') */)
	      {
		MmLockPagableDataSection((PVOID)CdAudio435DeviceControl);
		deviceExtension->Active = 3;
	      }
	  }
	temp_7 =  memcmp(& inquiryDataPtr[8], "HITACHI ", 8);
	temp_8 =  memcmp(& inquiryDataPtr[16], "CDR-3650/1650S  ", 16);
        temp_9 =  memcmp(& inquiryDataPtr[16], "CDR-1750S       ", 16);
	if (! temp_7 &&  (! temp_8 || ! temp_9))
	  {
	    MmLockPagableDataSection((PVOID)CdAudioHitachiDeviceControl);
	    deviceExtension->Active = 6;
	  }
	temp_10= memcmp(& inquiryDataPtr[8], "WEARNES ", 8);
	temp_11= memcmp(& inquiryDataPtr[16], "RUB", 3);
	temp_12= memcmp(& inquiryDataPtr[8], "OTI     ", 8); 
	temp_13= memcmp(& inquiryDataPtr[16], "DOLPHIN ", 8);
	if(! temp_10 && ! temp_11 || ! temp_12 && ! temp_13)	      
	  {
	    MmLockPagableDataSection((PVOID)CdAudioAtapiDeviceControl);
	    deviceExtension->Active = 1;
	    inquiryDataPtr[25] = (UCHAR )0;
	  }
	temp_14 =  memcmp(& inquiryDataPtr[8], "FUJITSU ", 8);
	if(! temp_14)
	  {
	    if(temp_15 /* inquiryDataPtr[16] == 'C' && */
	       /* inquiryDataPtr[17] == 'D' && */
	       /* inquiryDataPtr[18] == 'R' && */
	       /* inquiryDataPtr[20] == '3' && */
	       /* inquiryDataPtr[21] == '6' && */
	       /* inquiryDataPtr[22] == '5' && */
	       /* inquiryDataPtr[23] == '0' */)
	      {
		MmLockPagableDataSection((PVOID)CdAudioHitachiDeviceControl);
		deviceExtension->Active = 6;
		inquiryDataPtr[25] = (UCHAR )0;
	      }
	    else
	      {
		if(temp_16 /* inquiryDataPtr[16] == 'F' && */
		   /* inquiryDataPtr[17] == 'M' && */
		   /* inquiryDataPtr[18] == 'C' && */
		   /* inquiryDataPtr[21] == '1' && */
		   /* inquiryDataPtr[22] == '0' && */
		   /* (inquiryDataPtr[23] == '1' || */
		   /* inquiryDataPtr[23] == '2') */)
		  {
		    MmLockPagableDataSection((PVOID)CdAudioHitachiDeviceControl);
		    deviceExtension->Active = 5;
		    inquiryDataPtr[25] = (UCHAR )0;
		    // test for witnesses
		    // foo();
		  }
	      }
	  }
	temp_17 = memcmp(& inquiryDataPtr[8], "HP      ", 8);
	temp_18 = memcmp(& inquiryDataPtr[16], "C4324/C4325", 11);
	if(! temp_17 && ! temp_18)
	  {
	    MmLockPagableDataSection((PVOID)CdAudioHPCdrDeviceControl);
	    deviceExtension->Active = 7;
	  }
      }
      ExFreePool(inquiryDataPtr);
    }
  keyValue = (ULONG )deviceExtension->Active;
  status= IoOpenDeviceRegistryKey(deviceExtension->TargetPdo, 2,
				  (0x00020000L | 0x0002 | 0x0004) & /* ~ */ 0x00100000L, 
				  &deviceParameterHandle);
  if(! ((NTSTATUS )status>= 0))
    {
      return (NTSTATUS )0x00000000L;
    }
  status= RtlWriteRegistryValue(0x40000000,
				(PWSTR )deviceParameterHandle, "M\0a\0p\0T\0y\0p\0e\0",
				4, & keyValue, sizeof(keyValue));
  ZwClose(deviceParameterHandle);
  return (NTSTATUS )0x00000000L;
}


NTSTATUS CdAudioPnp(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
  PIO_STACK_LOCATION irpSp;
  NTSTATUS status;
  ULONG count ;
  BOOLEAN setPagable ;
  PCD_DEVICE_EXTENSION deviceExtension ;

  irpSp = ((Irp->Tail).Overlay).CurrentStackLocation;
  status= (NTSTATUS )0xC00000BBL;

  switch(irpSp->MinorFunction)
    {
    case 0x00:
      {
	status= CdAudioStartDevice(DeviceObject,Irp);
	(Irp->IoStatus).Status = status;
	myStatus = status;
	IofCompleteRequest(Irp, 0);
	return status;
      }
    case 0x16:
      {
	if(((irpSp->Parameters).UsageNotification).Type !=DeviceUsageTypePaging)
	    return CdAudioSendToNextDriver(DeviceObject,Irp);
					
	deviceExtension = DeviceObject->DeviceExtension;
	status= KeWaitForSingleObject(&deviceExtension->PagingPathCountEvent,
				      Executive, KernelMode, 0, (void *  )0);
	setPagable = 0;
	if(! ((irpSp->Parameters).UsageNotification).InPath &&
	   deviceExtension->PagingPathCount == 1)
	  {
	    if(! DeviceObject->Flags & 0x00004000)
	      {
		DeviceObject->Flags = DeviceObject->Flags | 0x00002000;
		setPagable = 1;
	      }
	  }
	status= CdAudioForwardIrpSynchronous(DeviceObject, Irp);
	if((NTSTATUS )status>= 0)
	  {
	    if(((irpSp->Parameters).UsageNotification).InPath)
	      InterlockedIncrement(&deviceExtension->PagingPathCount);
	    else
	      InterlockedDecrement(& deviceExtension->PagingPathCount);

	    if(((irpSp->Parameters).UsageNotification).InPath)
	      {
		if(deviceExtension->PagingPathCount == 1)
		    DeviceObject->Flags = DeviceObject->Flags & /* ~ */ 0x00002000;
	      }
	  }
	else
	  {
	    if(setPagable == 1)
	      {
		DeviceObject->Flags = DeviceObject->Flags &  /* ~ */ 0x00002000;
		setPagable = 0;
	      }
	  }
	KeSetEvent(& deviceExtension->PagingPathCountEvent, 0,0);
	IofCompleteRequest(Irp, 0);
	return status;
	break;
      }
    default :
      return CdAudioSendToNextDriver(DeviceObject, Irp);
    }
}

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject , PUNICODE_STRING RegistryPath)
{
  ULONG i ;
  //BLAST for(i = 0; i <= 0x1b; i++)
  // TRACER
/*   { */
/*     // #line 1288 */
/*     (DriverObject->MajorFunction)[i] = CdAudioSendToNextDriver; */
/*   } */
/*   (DriverObject->MajorFunction)[0x03] = CdAudioReadWrite; */
/*   (DriverObject->MajorFunction)[0x04] = CdAudioReadWrite; */
/*   (DriverObject->MajorFunction)[0x0e] = CdAudioDeviceControl; */
/*   (DriverObject->MajorFunction)[0x1b] = CdAudioPnp; */
/*   (DriverObject->MajorFunction)[0x16] = CdAudioPower; */
/*   (DriverObject->DriverExtension)->AddDevice = CdAudioAddDevice; */
/*   DriverObject->DriverUnload = CdAudioUnload; */
  return (NTSTATUS )0x00000000L;
}

BOOLEAN NecSupportNeeded(PUCHAR InquiryData )
{
  PINQUIRYDATA inquiryDataAux;
  ULONG i ;
  PUCHAR badDriveList[12];  
  int temp_1;

  badDriveList[0] = "CD-ROM DRIVE:80 ";  badDriveList[7]="CD-ROM DRIVE:500";
  badDriveList[1] = "CD-ROM DRIVE:82 ";  badDriveList[8]="CD-ROM DRIVE:400";
  badDriveList[2] = "CD-ROM DRIVE:83 ";  badDriveList[9]="CD-ROM DRIVE:401";
  badDriveList[3] = "CD-ROM DRIVE:84 ";  badDriveList[10]="CD-ROM DRIVE:501";
  badDriveList[4] = "CD-ROM DRIVE:841";  badDriveList[11]="CD-ROM DRIVE:900";
  badDriveList[5] = "CD-ROM DRIVE:38 ";  
  badDriveList[6] = "CD-ROM DRIVE 4 M";  

  inquiryDataAux = (PINQUIRYDATA )InquiryData;
  //BLAST for(i = 0; i < 12; i++)
  {
    temp_1 = RtlCompareMemory(inquiryDataAux->ProductId, badDriveList[i], 16);
    if(temp_1 == 16)
	return 1;
  }
  return 0;
}

// #line 1354
NTSTATUS CdAudioReadWrite(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
  PCD_DEVICE_EXTENSION deviceExtension;
  deviceExtension = DeviceObject->DeviceExtension;

  if(deviceExtension->PlayActive)
    {
      (Irp->IoStatus).Status = (NTSTATUS )0x80000011L;
      myStatus = (NTSTATUS )0x80000011L;
      IofCompleteRequest(Irp, 0);
      return (NTSTATUS )0x80000011L;
    }
  return CdAudioSendToNextDriver(DeviceObject, Irp);
}

NTSTATUS CdAudioDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
  PCD_DEVICE_EXTENSION deviceExtension;
  NTSTATUS status;
  
  deviceExtension = DeviceObject->DeviceExtension;
  switch(deviceExtension->Active)
    {
      /* BEGIN comment BLAST */
    case 0xFF:
      status= CdAudioSendToNextDriver(DeviceObject, Irp);
      break;
    case 0:
      status=CdAudioSendToNextDriver(DeviceObject, Irp);
      break;
    case 8:
      status=CdAudioNECDeviceControl(DeviceObject, Irp);
      break;
    case 9:
    case 10:
      status=CdAudioPioneerDeviceControl(DeviceObject, Irp);
      break;
    case 4:
      status=CdAudioDenonDeviceControl(DeviceObject, Irp);
      break;
    case 5:
    case 6:
      status=CdAudioHitachiDeviceControl(DeviceObject, Irp);
      break;
      /* END comment BLAST */
    case 2:
      status=CdAudio535DeviceControl(DeviceObject, Irp);
      break;
    case 3:
      status=CdAudio435DeviceControl(DeviceObject, Irp);
      break;
    case 1:
      status=CdAudioAtapiDeviceControl(DeviceObject, Irp);
      break;
    case 7:
      status=CdAudioHPCdrDeviceControl(DeviceObject, Irp);
      break;
    default :
      deviceExtension->Active = 0;
      status=CdAudioSendToNextDriver(DeviceObject, Irp);
    }
  return status;
}


NTSTATUS CdAudioSendToNextDriver(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
  
  PCD_DEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
  deviceExtension = DeviceObject->DeviceExtension;
  
  // TRACER
  // _ABORT(s != NP);
  s = SKIP1;

  // BLAST
  // if(s == NP)
  //  s = SKIP1;
  // else
  //  errorFn();

  Irp->CurrentLocation++;
  ((Irp->Tail).Overlay).CurrentStackLocation++;
  return IofCallDriver(deviceExtension->TargetDeviceObject, Irp);
}

BOOLEAN CdAudioIsPlayActive(PDEVICE_OBJECT DeviceObject )
{
  PCD_DEVICE_EXTENSION deviceExtension;
  PIRP irp_CdAudioIsPlayActive ;
  IO_STATUS_BLOCK ioStatus ;
  KEVENT event ;
  NTSTATUS status;
  PSUB_Q_CURRENT_POSITION currentBuffer ;
  BOOLEAN returnValue__ ;
  ULONG tag_1;
  deviceExtension = DeviceObject->DeviceExtension;

  if(! deviceExtension->PlayActive)
    {
      return 0;
    }
  currentBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
					sizeof(SUB_Q_CURRENT_POSITION ), tag_1/* ' AdC' */);  
  if(currentBuffer == (void *  )0)
      return 0;

  ((PCDROM_SUB_Q_DATA_FORMAT )currentBuffer)->Format = 0x01;
  ((PCDROM_SUB_Q_DATA_FORMAT )currentBuffer)->Track = 0;
  KeInitializeEvent(& event, NotificationEvent, 0); 
/*  BLAST
	irp_CdAudioIsPlayActive = IoBuildDeviceIoControlRequest(0x00000002 << 16
	| 0x0001 << 14 | 0x000B << 2 | 0, deviceExtension->DeviceObject,
	currentBuffer, sizeof(CDROM_SUB_Q_DATA_FORMAT ), currentBuffer,
	sizeof(SUB_Q_CURRENT_POSITION ), 0, & event, & ioStatus);
*/
  if(irp_CdAudioIsPlayActive == (void *  )0)
    {
      ExFreePool(currentBuffer);
      return 0;
    }
/*  BLAST
	status=IofCallDriver(deviceExtension->DeviceObject,irp_CdAudioIsPlayActive);	
*/
  if(status== (NTSTATUS )0x00000103L)
    {
      KeWaitForSingleObject(& event, Suspended, KernelMode, 0,(void *  )0);
      status= ioStatus.Status;
    }
  if(! ((NTSTATUS )status>= 0))
    {
      ExFreePool(currentBuffer);
      return 0;
    }
  if((currentBuffer->Header).AudioStatus == 0x11)
    returnValue__ = 1;
  else
    {
      returnValue__ = 0;
      deviceExtension->PlayActive = 0;
    }
  ExFreePool(currentBuffer);
  return returnValue__;
}

NTSTATUS CdAudioNECDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
  PIO_STACK_LOCATION currentIrpStack;
  PCD_DEVICE_EXTENSION deviceExtension;
  PCDROM_TOC cdaudioDataOut;
  SCSI_PASS_THROUGH srb ;
  PNEC_CDB cdb;
  NTSTATUS status ;
  ULONG i , bytesTransfered ;
  PUCHAR Toc ;
  ULONG retryCount;
  ULONG address ;
  LARGE_INTEGER delay ;
  BOOLEAN temp_1;
  int temp_2;
  ULONG tag_1;
  ULONG tracksToReturn ;
  ULONG tracksOnCd ;
  ULONG tracksInBuffer ;
  ULONG dataLength ;
  PCDROM_PLAY_AUDIO_MSF inputBuffer;
  PSUB_Q_CURRENT_POSITION userPtr;
  PUCHAR SubQPtr;
  int NONDET;
 
  currentIrpStack = ((Irp->Tail).Overlay).CurrentStackLocation;
  deviceExtension = DeviceObject->DeviceExtension;
  cdaudioDataOut = (Irp->AssociatedIrp).SystemBuffer;
  cdb = (PNEC_CDB )srb.Cdb;
  retryCount = 0;


 NECRestart:
  memset(cdb, 0, 12);
  
  switch(NONDET/* ((currentIrpStack->Parameters).DeviceIoControl).IoControlCode */)
    {
    case 1 /* 0x00000002 << 16 | 0x0001 << 14 | 0x000E << 2 | 0 */:
      if(((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength <
	 (ULONG )((LONG )((LONG_PTR )(& (((CDROM_TOC * )0)->TrackData)[1]))))
	{
	  status = (NTSTATUS )0xC0000023L;
	  (Irp->IoStatus).Information = 0;
	  break;
	}
      temp_1 = CdAudioIsPlayActive(DeviceObject);
      if(temp_1)
	{
	  (Irp->IoStatus).Information = 0;
	  status = (NTSTATUS )0x80000011L;
	  break;
	}
      Toc = (PUCHAR )ExAllocatePoolWithTag(NonPagedPoolCacheAligned,1022, tag_1/* ' AdC' */);
      if(Toc == (void *  )0)
	{
	  status = (NTSTATUS )0xC000009AL;
	  (Irp->IoStatus).Information = 0;
	  goto SetStatusAndReturn;
	}
      memset(Toc, 0, 1022);
      srb.CdbLength = 10;
      (cdb->NEC_READ_TOC).OperationCode = 0xDE;
      (cdb->NEC_READ_TOC).Type = 0x03;
      (cdb->NEC_READ_TOC).TrackNumber = 0xB0;
      srb.TimeOutValue = 10;
      status = SendSrbSynchronous(deviceExtension, & srb, Toc, 1022);
      if(! ((NTSTATUS )status >= 0) && status != (NTSTATUS)0xC000003CL)
	{
	  ExFreePool(Toc);
	  (Irp->IoStatus).Information = 0;
	  goto SetStatusAndReturn;
	}
      else
	  status = (NTSTATUS )0x00000000L;
      bytesTransfered = (LONG )((LONG_PTR )(& (((CDROM_TOC * )0)->TrackData)[1]));
      (Irp->IoStatus).Information = bytesTransfered;
      memset(cdaudioDataOut, 0, bytesTransfered);
      (cdaudioDataOut->Length)[0] = (UCHAR )(bytesTransfered - 2 >>8);
      (cdaudioDataOut->Length)[1] = (UCHAR )(bytesTransfered - 2 & 0xFF);
      if(temp_2/* * (ULONG *  )(& Toc[14]) */ == 0)
	{
	  ExFreePool(Toc);
	  break;
	}
      cdaudioDataOut->FirstTrack = 1;
      cdaudioDataOut->LastTrack = 2;
      ((cdaudioDataOut->TrackData)[0]).Reserved = 0;
      ((cdaudioDataOut->TrackData)[0]).Control = (Toc[2] & 0x0F) << 4 | Toc[2] >> 4;
      ((cdaudioDataOut->TrackData)[0]).TrackNumber = 1;
      ((cdaudioDataOut->TrackData)[0]).Reserved1 = 0;
      address = ((((Toc[15] & 0xF0) >> 4) * 10 + (Toc[15] & 0x0F)) *
		 60 + (((Toc[16] & 0xF0) >> 4) * 10 + (Toc[16] & 0x0F))) * 75 +
	         (((Toc[17] & 0xF0) >> 4) * 10 + (Toc[17] & 0x0F));
      (((cdaudioDataOut->TrackData)[0]).Address)[0] = (UCHAR )(address >> 24);
      (((cdaudioDataOut->TrackData)[0]).Address)[1] = (UCHAR )(address >> 16);
      (((cdaudioDataOut->TrackData)[0]).Address)[2] = (UCHAR )(address >> 8);
      (((cdaudioDataOut->TrackData)[0]).Address)[3] = (UCHAR )address;
      ExFreePool(Toc);
      break;
    case 2 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0000 << 2 | 0 */:
      temp_1 = CdAudioIsPlayActive(DeviceObject);      
      if(temp_1)
	{
	  status = (NTSTATUS )0x80000011L;
	  (Irp->IoStatus).Information = 0;
	  break;
	}
      if(((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength <
	 (ULONG )((LONG )((LONG_PTR )(& (((CDROM_TOC *  )0)->TrackData)[0]))))
	{
	  status = (NTSTATUS )0xC0000023L;
	  (Irp->IoStatus).Information = 0;
	  break;
	}
      Toc = (PUCHAR )ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
					   1022, tag_1/* ' AdC' */);
      if(Toc == (void *  )0)
	{
	  status = (NTSTATUS )0xC000009AL;
	  (Irp->IoStatus).Information = 0;
	  goto SetStatusAndReturn;
	}
      memset(Toc, 0, 1022);
      srb.CdbLength = 10;
      (cdb->NEC_READ_TOC).OperationCode = 0xDE;
      (cdb->NEC_READ_TOC).Type = 0x03;
      srb.TimeOutValue = 10;
      status = SendSrbSynchronous(deviceExtension, & srb, Toc, 1022);
      if(! ((NTSTATUS )status >= 0) && status != (NTSTATUS)0xC000003CL)
	{
	  if(status != (NTSTATUS )0xC000003CL)
	    {
	      (Irp->IoStatus).Information = 0;
	      ExFreePool(Toc);
	      goto SetStatusAndReturn;
	    }
	}
      else
	status = (NTSTATUS )0x00000000L;
      
      if (((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength > sizeof(CDROM_TOC ) )
	bytesTransfered =  sizeof(CDROM_TOC );
      else
	bytesTransfered = ((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength;
      cdaudioDataOut->FirstTrack = ((Toc[9] & 0xF0) >> 4) * 10 + (Toc[9] & 0x0F);
      cdaudioDataOut->LastTrack = ((Toc[19] & 0xF0) >> 4) * 10 + (Toc[19] & 0x0F);
      {
	// #line 1974

	tracksOnCd = cdaudioDataOut->LastTrack - cdaudioDataOut->FirstTrack + 1;
	dataLength = (ULONG )((LONG )((LONG_PTR )(& (((CDROM_TOC *  )0)->TrackData)[tracksOnCd]))) - 2;
	(cdaudioDataOut->Length)[0] = (UCHAR )(dataLength >> 8);
	(cdaudioDataOut->Length)[1] = (UCHAR )(dataLength & 0xFF);
	tracksInBuffer = ((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength - 
	                  (ULONG )((LONG )((LONG_PTR )(& (((CDROM_TOC *  )0)->TrackData)[0])));
	tracksInBuffer = tracksInBuffer / sizeof(TRACK_DATA );

	if(tracksInBuffer < tracksOnCd)
	  tracksToReturn = tracksInBuffer;
	else
	  tracksToReturn = tracksOnCd;

	for(i = 0; i < tracksToReturn; i++)
	  {
	    ((cdaudioDataOut->TrackData)[i]).Reserved = 0;
	    ((cdaudioDataOut->TrackData)[i]).Control = (Toc[i * 10 + 32] & 0x0F) << 4 | 
	                                                Toc[i * 10 + 32] >> 4;
	    ((cdaudioDataOut->TrackData)[i]).TrackNumber  = (UCHAR )(i + cdaudioDataOut->FirstTrack);
	    ((cdaudioDataOut->TrackData)[i]).Reserved1    =  0;
	    (((cdaudioDataOut->TrackData)[i]).Address)[0] =  0;
	    (((cdaudioDataOut->TrackData)[i]).Address)[1] = ((Toc[i * 10 + 39] & 0xF0) >> 4) * 10 +
	                                                    (Toc[i * 10 + 39] & 0x0F);
	    (((cdaudioDataOut->TrackData)[i]).Address)[2] = ((Toc[i * 10 + 40] & 0xF0) >> 4) * 10 +
	                                                    (Toc[i * 10 + 40] & 0x0F);
	    (((cdaudioDataOut->TrackData)[i]).Address)[3] = ((Toc[i * 10 + 41] & 0xF0) >> 4) * 10 +
	                                                    (Toc[i * 10 + 41] & 0x0F);
	  } // end of for-loop

	if(tracksInBuffer > tracksOnCd)
	  {
	    ((cdaudioDataOut->TrackData)[i]).Reserved = 0;
	    ((cdaudioDataOut->TrackData)[i]).Control = 0x10;
	    ((cdaudioDataOut->TrackData)[i]).TrackNumber = 0xaa;
	    ((cdaudioDataOut->TrackData)[i]).Reserved1 = 0;
	    (((cdaudioDataOut->TrackData)[i]).Address)[0] = 0;
	    (((cdaudioDataOut->TrackData)[i]).Address)[1] = ((Toc[29] & 0xF0) >> 4) * 10 + (Toc[29] & 0x0F);
	    (((cdaudioDataOut->TrackData)[i]).Address)[2] = ((Toc[30] & 0xF0) >> 4) * 10 + (Toc[30] & 0x0F);
	    (((cdaudioDataOut->TrackData)[i]).Address)[3] = ((Toc[31] & 0xF0) >> 4) * 10 + (Toc[31] & 0x0F);
	    i++;
	  }
	(Irp->IoStatus).Information = (ULONG )((LONG )((LONG_PTR
							)(& (((CDROM_TOC *  )0)->TrackData)[i])));
      }
      ExFreePool(Toc);
      break;
      
    case 3 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0002 << 2 | 0 */:
      deviceExtension->PlayActive = 0;
      return CdAudioSendToNextDriver(DeviceObject, Irp);
      break;
    case 4 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0006 << 2 | 0 */:
      inputBuffer = (Irp->AssociatedIrp).SystemBuffer;
      if(((currentIrpStack->Parameters).DeviceIoControl).InputBufferLength <
	 sizeof(CDROM_PLAY_AUDIO_MSF ))
	{
	  status = (NTSTATUS )0xC0000004L;
	  (Irp->IoStatus).Information = 0;
	  break;
	}
      srb.CdbLength = 10;
      srb.TimeOutValue = 10;
      (cdb->NEC_PLAY_AUDIO).OperationCode = 0xD8;
      (cdb->NEC_PLAY_AUDIO).PlayMode = 0x01;
      (cdb->NEC_PLAY_AUDIO).Minute = (inputBuffer->StartingM / 10 << 4) +
	                              inputBuffer->StartingM % 10;
      (cdb->NEC_PLAY_AUDIO).Second = (inputBuffer->StartingS / 10 << 4) +
				      inputBuffer->StartingS % 10;
      (cdb->NEC_PLAY_AUDIO).Frame  = (inputBuffer->StartingF / 10 << 4) +
				      inputBuffer->StartingF % 10;
      (cdb->NEC_PLAY_AUDIO).Control = 0x40;
      status = SendSrbSynchronous(deviceExtension, & srb, (void *  )0, 0);
      if((NTSTATUS )status >= 0)
	{
	  deviceExtension->PlayActive = 1;
	  memset(cdb, 0, 12);
	  (cdb->NEC_PLAY_AUDIO).OperationCode = 0xD9;
	  (cdb->NEC_PLAY_AUDIO).PlayMode = 0x03;
	  (cdb->NEC_PLAY_AUDIO).Minute = (inputBuffer->EndingM / 10 << 4) +	    
					  inputBuffer->EndingM % 10;
	  (cdb->NEC_PLAY_AUDIO).Second = (inputBuffer->EndingS / 10 << 4) +
	                                  inputBuffer->EndingS % 10;
	  (cdb->NEC_PLAY_AUDIO).Frame =  (inputBuffer->EndingF / 10 << 4) +	    
	                                  inputBuffer->EndingF % 10;
	  (cdb->NEC_PLAY_AUDIO).Control = 0x40;
	  status = SendSrbSynchronous(deviceExtension, & srb, (void *  )0, 0);
	}      
      break;
    case 5 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0001 << 2 | 0 */:
      inputBuffer = (Irp->AssociatedIrp).SystemBuffer;
      if(((currentIrpStack->Parameters).DeviceIoControl).InputBufferLength <
	 sizeof(CDROM_SEEK_AUDIO_MSF ))
	{
	  status = (NTSTATUS )0xC0000004L;
	  (Irp->IoStatus).Information = 0;
	  break;
	}
      srb.CdbLength = 10;
      srb.TimeOutValue = 10;
      (cdb->NEC_SEEK_AUDIO).OperationCode = 0xD8;
      (cdb->NEC_SEEK_AUDIO).Minute = (inputBuffer->StartingM / 10 <<4) + inputBuffer->StartingM % 10;
      (cdb->NEC_SEEK_AUDIO).Second = (inputBuffer->StartingS / 10 << 4) + inputBuffer->StartingS % 10;
      (cdb->NEC_SEEK_AUDIO).Frame = (inputBuffer->StartingF / 10 << 4) + inputBuffer->StartingF % 10;
      (cdb->NEC_SEEK_AUDIO).Control = 0x40;
      status = SendSrbSynchronous(deviceExtension, & srb, (void *  )0, 0);
      break;
    case 6 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0003 << 2 | 0 */:
      deviceExtension->PlayActive = 0;
      srb.CdbLength = 10;
      srb.TimeOutValue = 10;
      (cdb->NEC_PAUSE_AUDIO).OperationCode = 0xDA;
      status = SendSrbSynchronous(deviceExtension, & srb, (void *  )0, 0);
      break;
    case 7 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0004 << 2 | 0 */:
      srb.CdbLength = 10;
      srb.TimeOutValue = 10;
      (cdb->NEC_PLAY_AUDIO).OperationCode = 0xD9;
      (cdb->NEC_PLAY_AUDIO).PlayMode = 0x03;
      (cdb->NEC_PLAY_AUDIO).Control = 0xC0;
      status = SendSrbSynchronous(deviceExtension, & srb, (void *  )0, 0);
      break;
    case 8 /* 0x00000002 << 16 | 0x0001 << 14 | 0x000B << 2 | 0 */:
      userPtr = (Irp->AssociatedIrp).SystemBuffer;
      SubQPtr = ExAllocatePoolWithTag(NonPagedPoolCacheAligned, 10, tag_1 /*' AdC'*/);
      if(((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength <
	 sizeof(SUB_Q_CURRENT_POSITION ))
	{
	  status = (NTSTATUS )0xC0000023L;
	  (Irp->IoStatus).Information = 0;
	  if(SubQPtr)
	    ExFreePool(SubQPtr);
	  break;
	}
     if(SubQPtr == (void *  )0)
       {
	 status = (NTSTATUS )0xC000009AL;
	 (Irp->IoStatus).Information = 0;
	 goto SetStatusAndReturn;
       }
     memset(SubQPtr, 0, 10);
     if(((PCDROM_SUB_Q_DATA_FORMAT )userPtr)->Format != 0x01)
       {
	 ExFreePool(SubQPtr);
	 status = (NTSTATUS )0xC0000001L;
	 (Irp->IoStatus).Information = 0;
	 goto SetStatusAndReturn;
       }
    NECSeek:
     srb.CdbLength = 10;
     srb.TimeOutValue = 10;
     (cdb->NEC_READ_Q_CHANNEL).OperationCode = 0xDD;
     (cdb->NEC_READ_Q_CHANNEL).TransferSize = 10;
     status = SendSrbSynchronous(deviceExtension, & srb, SubQPtr, 10);
     if((NTSTATUS )status >= 0 || status == (NTSTATUS)0xC000003CL)
       {
	 (userPtr->Header).Reserved = 0;
	 if(SubQPtr[0] == 0x00)
	   (userPtr->Header).AudioStatus = 0x11;
	 else
	   {
	     if(SubQPtr[0] == 0x01)
	       {
		 (userPtr->Header).AudioStatus = 0x12;
		 deviceExtension->PlayActive = 0;
	       }
	     else
	       {
		 if(SubQPtr[0] == 0x02)
		   {
		     (userPtr->Header).AudioStatus = 0x12;
		     deviceExtension->PlayActive = 0;
		   }
		 else
		   {
		     if(SubQPtr[0] == 0x03)
		       {
			 (userPtr->Header).AudioStatus = 0x13;
			 deviceExtension->PlayActive = 0;
		       }
		     else
		       deviceExtension->PlayActive = 0;
		   }
	       }
	   }
	 ((userPtr->Header).DataLength)[0] = 0;
	 ((userPtr->Header).DataLength)[0] = 12;
	 userPtr->FormatCode = 0x01;
	 userPtr->Control = SubQPtr[1] & 0x0F;
	 userPtr->ADR = 0;
	 userPtr->TrackNumber = ((SubQPtr[2] & 0xF0) >> 4) * 10 + (SubQPtr[2] & 0x0F);
	 userPtr->IndexNumber = ((SubQPtr[3] & 0xF0) >> 4) * 10 + (SubQPtr[3] & 0x0F);
	 (userPtr->AbsoluteAddress)[0] = 0;
	 (userPtr->AbsoluteAddress)[1] = ((SubQPtr[7] &
					   0xF0) >> 4) * 10 + (SubQPtr[7] & 0x0F);
	 (userPtr->AbsoluteAddress)[2] = ((SubQPtr[8] &
					   0xF0) >> 4) * 10 + (SubQPtr[8] & 0x0F);
	 (userPtr->AbsoluteAddress)[3] = ((SubQPtr[9] &
					   0xF0) >> 4) * 10 + (SubQPtr[9] & 0x0F);
	 (userPtr->TrackRelativeAddress)[0] = 0;
	 (userPtr->TrackRelativeAddress)[1] = ((SubQPtr[4] & 0xF0) >> 4) * 10 + (SubQPtr[4] & 0x0F);
	 (userPtr->TrackRelativeAddress)[2] = ((SubQPtr[5] & 0xF0) >> 4) * 10 + (SubQPtr[5] & 0x0F);
	 (userPtr->TrackRelativeAddress)[3] = ((SubQPtr[6] & 0xF0) >> 4) * 10 + (SubQPtr[6] & 0x0F);
	 (Irp->IoStatus).Information = sizeof(SUB_Q_CURRENT_POSITION );
	 if(userPtr->TrackNumber > 100)
	   {
	     delay.QuadPart = - (10 * 1000 * 100 * 5);
	     KeDelayExecutionThread(KernelMode, 0, & delay);
	     if(retryCount < 4)
	       {
		 retryCount++;
		 // TRACER: this is a loop: goto NECSeek;
	       }
	     else
	       {
		 retryCount++;
		 (Irp->IoStatus).Information = 0;
		 status = (NTSTATUS )0xC0000186L;
	       }
	   }
	 else
	   status = (NTSTATUS )0x00000000L;
       }
     else
       {
	 memset(userPtr, 0, sizeof(SUB_Q_CURRENT_POSITION));
	 (Irp->IoStatus).Information = 0;
       }
     ExFreePool(SubQPtr);
     break;
    case 9 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0202 << 2 | 0 */:
      deviceExtension->PlayActive = 0;
      srb.CdbLength = 10;
      srb.TimeOutValue = 10;
      (cdb->NEC_EJECT).OperationCode = 0xDC;
      status = SendSrbSynchronous(deviceExtension, & srb, (void *  )0, 0);
      (Irp->IoStatus).Information = 0;
      break;
    case 10 /* 0x00000002 << 16 | 0x0001 << 14 | 0x000D << 2 | 0 */:
    case 11 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0005 << 2 | 0 */:
    case 12 /*  0x00000002 << 16 | 0x0001 << 14 | 0x000A << 2 | 0 */:
      (Irp->IoStatus).Information = 0;
      status = (NTSTATUS )0xC0000010L;
      break;
    case 13 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0200 << 2 | 0 */:
      CdAudioIsPlayActive(DeviceObject);
    default :
      return CdAudioSendToNextDriver(DeviceObject, Irp);
      break;
    }
 SetStatusAndReturn:
  {
    if(status == (NTSTATUS )0x80000016L)
      {
	if(currentIrpStack->Flags & 0x02)
	  {
	    status = (NTSTATUS )0xC0000185L;
	    // TRACER goto NECRestart;
	  }
	IoSetHardErrorOrVerifyDevice(Irp, deviceExtension->TargetDeviceObject);
	(Irp->IoStatus).Information = 0;
      }
  }
  (Irp->IoStatus).Status = status;
  myStatus = status;
  IofCompleteRequest(Irp, 0);
  return status;
}


NTSTATUS CdAudioPioneerDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
  PIO_STACK_LOCATION currentIrpStack;
  PCD_DEVICE_EXTENSION deviceExtension;
  PCDROM_TOC cdaudioDataOut;
  SCSI_PASS_THROUGH srb ;
  PPNR_CDB cdb;
  PCDB scsiCdb;
  NTSTATUS status ;
  ULONG i , retry ;
  PUCHAR Toc ;
  ULONG tracksToReturn ;
  ULONG tracksOnCd ;
  ULONG tracksInBuffer ;
  ULONG dataLength ;
  PCDROM_PLAY_AUDIO_MSF inputBuffer;  
  PSUB_Q_CURRENT_POSITION userPtr;
  PUCHAR SubQPtr;
  int NONDET;

  int temp_1;
  ULONG tag_1;


  currentIrpStack  = ((Irp->Tail).Overlay).CurrentStackLocation;
  deviceExtension = DeviceObject->DeviceExtension;
  cdaudioDataOut = (Irp->AssociatedIrp).SystemBuffer;
  cdb = (PPNR_CDB )srb.Cdb;
  scsiCdb = (PCDB )srb.Cdb;

 PioneerRestart:
  memset(cdb, 0, 12);

  switch(NONDET/* ((currentIrpStack->Parameters).DeviceIoControl).IoControlCode */)
    {
    case 1/*  0x00000002 << 16 | 0x0001 << 14 | 0x0000 << 2 | 0 */:
      if(((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength <
	 (ULONG )((LONG )((LONG_PTR )(& (((CDROM_TOC *  )0)->TrackData)[0]))))
	{
	  status = (NTSTATUS )0xC0000023L;
	  (Irp->IoStatus).Information = 0;
	  break;
	}
      temp_1 = CdAudioIsPlayActive(DeviceObject);
      if(temp_1)
	{
	  status = (NTSTATUS )0x80000011L;
	  (Irp->IoStatus).Information = 0;
	  break;
	}
      Toc = (PUCHAR)ExAllocatePoolWithTag(NonPagedPoolCacheAligned,sizeof(CDROM_TOC ),tag_1 /* ' AdC' */);
      if(Toc == (void *  )0)
	{
	  status = (NTSTATUS )0xC000009AL;
	  (Irp->IoStatus).Information = 0;
	  goto SetStatusAndReturn;
	}
      memset(Toc, 0, sizeof(CDROM_TOC ));
      if(deviceExtension->Active == 9)
	(cdb->PNR_START_STOP).Immediate = 1;
      else
	(cdb->PNR_START_STOP).Immediate = 0;
      (cdb->PNR_START_STOP).OperationCode = 0x1B;
      (cdb->PNR_START_STOP).Start = 1;
      srb.CdbLength = 6;
      srb.TimeOutValue = 10;
      status = SendSrbSynchronous(deviceExtension, & srb, (void *  )0, 0);
      if(! ((NTSTATUS )status >= 0))
	{
	  ExFreePool(Toc);
	  (Irp->IoStatus).Information = 0;
	  goto SetStatusAndReturn;
	}
      memset(cdb, 0, 12);
      srb.CdbLength = 10;
      (cdb->PNR_READ_TOC).OperationCode = 0xC1;
      ((cdb->PNR_READ_TOC).AssignedLength)[1] = 0x04;
      (cdb->PNR_READ_TOC).Type = 0x00;
      srb.TimeOutValue = 10;
      status = SendSrbSynchronous(deviceExtension, & srb, Toc,0x04);
      if(! ((NTSTATUS )status >= 0))
	{
	  ExFreePool(Toc);
	  (Irp->IoStatus).Information = 0;
	  goto SetStatusAndReturn;
	}
      cdaudioDataOut->FirstTrack = ((Toc[0] & 0xF0) >> 4) * 10 + (Toc[0] & 0x0F);
      cdaudioDataOut->LastTrack = ((Toc[1] & 0xF0) >> 4) * 10 + (Toc[1] & 0x0F);
      tracksOnCd = cdaudioDataOut->LastTrack - cdaudioDataOut->FirstTrack + 1;
      dataLength = (ULONG )((LONG )((LONG_PTR )(&(((CDROM_TOC * )0)->TrackData)[tracksOnCd]))) - 2;
      (cdaudioDataOut->Length)[0] = (UCHAR)(dataLength >> 8);
      (cdaudioDataOut->Length)[1] = (UCHAR)(dataLength & 0xFF);
      tracksInBuffer = ((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength - 
	(ULONG )((LONG)((LONG_PTR )(& (((CDROM_TOC * )0)->TrackData)[0])));
      tracksInBuffer = tracksInBuffer / sizeof(TRACK_DATA );
      if(tracksInBuffer < tracksOnCd)
	tracksToReturn = tracksInBuffer;
      else
	tracksToReturn =tracksOnCd;
      
      
      // TRACER for(i = 0; i < tracksToReturn; i++)
      {
	memset(cdb, 0, 12);
	(cdb->PNR_READ_TOC).OperationCode = 0xC1;		
	(cdb->PNR_READ_TOC).TrackNumber = (UCHAR)(((i + cdaudioDataOut->FirstTrack) / 10 /* << 4 */) +
						   (i + cdaudioDataOut->FirstTrack) % 10);
	((cdb->PNR_READ_TOC).AssignedLength)[1] = 0x04;
	(cdb->PNR_READ_TOC).Type = 0x02;
	srb.TimeOutValue = 10;
	status = SendSrbSynchronous(deviceExtension,& srb, Toc, 0x04);
	if(! ((NTSTATUS )status >= 0))
	  {
	    ExFreePool(Toc);
	    (Irp->IoStatus).Information = 0;
	    goto SetStatusAndReturn;
	  }
	((cdaudioDataOut->TrackData)[i]).Reserved = 0;
	((cdaudioDataOut->TrackData)[i]).Control = Toc[0];
	((cdaudioDataOut->TrackData)[i]).TrackNumber= (UCHAR )(i +cdaudioDataOut->FirstTrack);
	((cdaudioDataOut->TrackData)[i]).Reserved1 = 0;
	(((cdaudioDataOut->TrackData)[i]).Address )[0] = 0;
	(((cdaudioDataOut->TrackData)[i]).Address)[1] = ((Toc[1] & 0xF0) >> 4) * 10 +
		                                              (Toc[1] & 0x0F);
	(((cdaudioDataOut->TrackData)[i]).Address)[2] = ((Toc[2] & 0xF0) >> 4) *   
		                                              10 + (Toc[2] & 0x0F);
	(((cdaudioDataOut->TrackData)[i]).Address)[3] = ((Toc[3] & 0xF0) >> 4) *	 
	                                                 10 + (Toc[3] & 0x0F);
      } // end of for-loop
      
      if(tracksInBuffer > tracksOnCd)
	{
	  memset(cdb, 0, 12);
	  (cdb->PNR_READ_TOC).OperationCode = 0xC1;
	  ((cdb->PNR_READ_TOC).AssignedLength)[1]  = 0x04;
	  (cdb->PNR_READ_TOC).Type = 0x01;
	  srb.TimeOutValue = 10;
	  status = SendSrbSynchronous(deviceExtension, & srb, Toc, 0x04);
	  if(! ((NTSTATUS )status >= 0))
	    {
	      ExFreePool(Toc);
	      (Irp->IoStatus).Information = 0;
	      goto SetStatusAndReturn;
		  }
	  ((cdaudioDataOut->TrackData)[i]).Reserved= 0;
	  ((cdaudioDataOut->TrackData)[i]).Control= 0x10;
	  ((cdaudioDataOut->TrackData)[i]).TrackNumber= 0xaa;
	  ((cdaudioDataOut->TrackData)[i]).Reserved1= 0;
	  (((cdaudioDataOut->TrackData)[i]).Address )[0] = 0;
	  (((cdaudioDataOut->TrackData)[i]).Address)[1] = ((Toc[0] & 0xF0) >> 4) *
	    10 + (Toc[0] & 0x0F); 
	  (((cdaudioDataOut->TrackData)[i]).Address)[2] = ((Toc[1] & 0xF0) >> 4) *		 
	    10 + (Toc[1] & 0x0F);
	  (((cdaudioDataOut->TrackData)[i]).Address )[3] = ((Toc[2] & 0xF0) >> 4) *		
	    10 + (Toc[2] & 0x0F);
	  i++;
	}
      (Irp->IoStatus).Information = (ULONG )((LONG)((LONG_PTR )(& (((CDROM_TOC *)0)->TrackData)[i])));      
      ExFreePool(Toc);      
      break;
    case 2 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0002 << 2 | 0 */:
      deviceExtension->PlayActive = 0;
      return CdAudioSendToNextDriver(DeviceObject, Irp);
      break;
    case 3 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0006 << 2 | 0 */:
      inputBuffer = (Irp->AssociatedIrp).SystemBuffer;	  
      (Irp->IoStatus).Information = 0;
      if(((currentIrpStack->Parameters).DeviceIoControl).InputBufferLength < sizeof(CDROM_PLAY_AUDIO_MSF ))
	{
	  status = (NTSTATUS )0xC0000004L;
	  break;
	}
      retry = 5;
      do
	{
	  srb.CdbLength = 10;
	  srb.TimeOutValue = 10;
	  (cdb->PNR_SEEK_AUDIO).OperationCode = 0xC8;
	  (cdb->PNR_SEEK_AUDIO).Minute = (inputBuffer->StartingM / 10 << 4) + inputBuffer->StartingM % 10;
	  (cdb->PNR_SEEK_AUDIO).Second =(inputBuffer->StartingS / 10 << 4) + inputBuffer->StartingS % 10;
	  (cdb->PNR_SEEK_AUDIO).Frame = (inputBuffer->StartingF / 10 << 4) + inputBuffer->StartingF % 10;
	  (cdb->PNR_SEEK_AUDIO).Type = 0x01;
	  status = SendSrbSynchronous(deviceExtension, & srb, (void *  )0, 0);
	  retry--;
	} while(! ((NTSTATUS )status >= 0) && retry > 0);
	
	if((NTSTATUS )status >= 0)
	  {
	    memset(cdb, 0, 12);
	    retry = 5;
	    do
	      {
		srb.CdbLength = 10;
		srb.TimeOutValue = 10;
		(cdb->PNR_PLAY_AUDIO).OperationCode = 0xC9;
		(cdb->PNR_PLAY_AUDIO).StopAddr = 1;
		(cdb->PNR_PLAY_AUDIO).Minute = (inputBuffer->EndingM / 10 << 4)
		  + inputBuffer->EndingM % 10;
		(cdb->PNR_PLAY_AUDIO).Second = (inputBuffer->EndingS / 10 << 4)		  
		  + inputBuffer->EndingS % 10;
		(cdb->PNR_PLAY_AUDIO).Frame =  (inputBuffer->EndingF / 10 << 4)		  
		  + inputBuffer->EndingF % 10;
		(cdb->PNR_PLAY_AUDIO).Type = 0x01;
		status = SendSrbSynchronous(deviceExtension,& srb, (void *  )0, 0);
		retry --;
	      } while(! ((NTSTATUS )status >= 0) && retry > 0);
	    
	    if((NTSTATUS )status >= 0)
	      deviceExtension->PlayActive = 1;
	  }
      break;
    case 4 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0001 << 2 | 0 */:
      inputBuffer = (Irp->AssociatedIrp).SystemBuffer;
      (Irp->IoStatus).Information = 0;
      if(((currentIrpStack->Parameters).DeviceIoControl).InputBufferLength
	 < sizeof(CDROM_SEEK_AUDIO_MSF ))
	{
	  status = (NTSTATUS )0xC0000004L;
	  break;
	}
      retry = 5;
      do
      {
	srb.CdbLength = 10;
	srb.TimeOutValue = 10;
	(cdb->PNR_SEEK_AUDIO).OperationCode = 0xC8;
	(cdb->PNR_SEEK_AUDIO).Minute = (inputBuffer->StartingM /
					10 << 4) + inputBuffer->StartingM % 10;
	(cdb->PNR_SEEK_AUDIO).Second = (inputBuffer->StartingS /
					10 << 4) + inputBuffer->StartingS % 10;
	(cdb->PNR_SEEK_AUDIO).Frame = (inputBuffer->StartingF /
				       10 << 4) + inputBuffer->StartingF % 10;
	(cdb->PNR_SEEK_AUDIO).Type = 0x01;
	status = SendSrbSynchronous(deviceExtension, & srb, (void *  )0, 0);	    
	retry--;
      } while(! ((NTSTATUS )status >= 0) && retry > 0);
      
      break;
    case 5 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0003 << 2 | 0 */:
      (Irp->IoStatus).Information = 0;
      deviceExtension->PlayActive = 0;
      srb.CdbLength = 10;
      srb.TimeOutValue = 10;
      (cdb->PNR_PAUSE_AUDIO).OperationCode = 0xCA;
      (cdb->PNR_PAUSE_AUDIO).Pause = 1;
      status = SendSrbSynchronous(deviceExtension, & srb,(void *  )0, 0);				  
      break;
    case 6 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0004 << 2 | 0 */:
      (Irp->IoStatus).Information = 0;
      srb.CdbLength = 10;
      srb.TimeOutValue = 10;
      (cdb->PNR_PAUSE_AUDIO).OperationCode = 0xCA;
      status = SendSrbSynchronous(deviceExtension, & srb, (void *  )0, 0);
      break;
    case 7 /* 0x00000002 << 16 | 0x0001 << 14 | 0x000B << 2 | 0 */:
      userPtr = (Irp->AssociatedIrp).SystemBuffer;
      SubQPtr = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,9,tag_1/*' AdC'*/);
      if(((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength
	 < sizeof(SUB_Q_CURRENT_POSITION ))
	{
	  status = (NTSTATUS )0xC0000023L;
	  (Irp->IoStatus).Information = 0;
	  if(SubQPtr)
	 ExFreePool(SubQPtr);
	  break;
	}
      if(SubQPtr == (void *  )0)
	{
	  memset(userPtr, 0, sizeof(SUB_Q_CURRENT_POSITION));
	  status = (NTSTATUS )0xC000009AL;
	  (Irp->IoStatus).Information = 0;
	  goto SetStatusAndReturn;
	}
      if(((PCDROM_SUB_Q_DATA_FORMAT )userPtr)->Format != 0x01)
	{
	  ExFreePool(SubQPtr);
	  memset(userPtr, 0, sizeof(SUB_Q_CURRENT_POSITION));
	  (Irp->IoStatus).Information = 0;
	  status = (NTSTATUS )0xC0000010L;
	  goto SetStatusAndReturn;
	}
      retry = 5;
      do
      {
	srb.CdbLength = 10;
	srb.TimeOutValue = 10;
	(cdb->PNR_AUDIO_STATUS).OperationCode = 0xCC;
	(cdb->PNR_AUDIO_STATUS).AssignedLength = 6;
	status = SendSrbSynchronous(deviceExtension, & srb, SubQPtr, 6);
	retry--;
      }while(! ((NTSTATUS )status >= 0) && retry > 0 && status != (NTSTATUS )0xC00000A3L);	 
      
      if((NTSTATUS )status >= 0)
	{
	  (userPtr->Header).Reserved = 0;
	  if(SubQPtr[0] == 0x00)	 
	    (userPtr->Header).AudioStatus = 0x11;
	  else
	    {
	      if(SubQPtr[0] == 0x01)
		{
		  deviceExtension->PlayActive = 0;
		  (userPtr->Header).AudioStatus = 0x12;
		}
	      else
		{
		  if(SubQPtr[0] == 0x02)
		    {
		   deviceExtension->PlayActive = 0;
		   (userPtr->Header).AudioStatus = 0x12;
		    }
		  else
		    {
		      if(SubQPtr[0] == 0x03)
			{
			  (userPtr->Header).AudioStatus = 0x13;
			  deviceExtension->PlayActive = 0;
		     }
		      else
			deviceExtension->PlayActive = 0;
		    }
		}
	    }
	}
      else
	{
	  ExFreePool(SubQPtr);
	  (Irp->IoStatus).Information = 0;
	  goto SetStatusAndReturn;
	}
      memset(cdb, 0, 12);
      retry = 5;
      do
      {
	srb.CdbLength = 10;
	srb.TimeOutValue = 10;
	(cdb->PNR_READ_Q_CHANNEL).OperationCode = 0xC2;
	(cdb->PNR_READ_Q_CHANNEL).AssignedLength = 9;
	status = SendSrbSynchronous(deviceExtension, & srb, SubQPtr, 9);   
	retry--;
      }while(! ((NTSTATUS )status >= 0) && retry > 0);
      
      if((NTSTATUS )status >= 0)
	{
	  ((userPtr->Header).DataLength)[0] = 0;
	  ((userPtr->Header).DataLength)[0] = 12;
	  userPtr->FormatCode = 0x01;
	  userPtr->Control = SubQPtr[0] & 0x0F;
	  userPtr->ADR = 0;
	  userPtr->TrackNumber = ((SubQPtr[1] & 0xF0) >>4) * 10 + (SubQPtr[1] & 0x0F);
	  userPtr->IndexNumber = ((SubQPtr[2] & 0xF0) >> 4) * 10 + (SubQPtr[2] & 0x0F);
	  (userPtr->AbsoluteAddress)[0] = 0;
	  (userPtr->AbsoluteAddress)[1] = ((SubQPtr[6] & 0xF0) >> 4) * 10 + (SubQPtr[6] & 0x0F);
	  (userPtr->AbsoluteAddress)[2] = ((SubQPtr[7] & 0xF0) >> 4) * 10 + (SubQPtr[7] & 0x0F);
	  (userPtr->AbsoluteAddress)[3] = ((SubQPtr[8] & 0xF0) >> 4) * 10 + (SubQPtr[8] & 0x0F);
	  (userPtr->TrackRelativeAddress)[0] = 0;
	  (userPtr->TrackRelativeAddress)[1] = ((SubQPtr[3] & 0xF0) >> 4) * 10 + (SubQPtr[3] & 0x0F);
	  (userPtr->TrackRelativeAddress)[2] = ((SubQPtr[4] & 0xF0) >> 4) * 10 + (SubQPtr[4] & 0x0F);
	  (userPtr->TrackRelativeAddress)[3] = ((SubQPtr[5] & 0xF0) >> 4) * 10 + (SubQPtr[5] & 0x0F);
	  (Irp->IoStatus).Information =
	    sizeof(SUB_Q_CURRENT_POSITION );
	}
      else
	(Irp->IoStatus).Information = 0;
      ExFreePool(SubQPtr);
      break;
    case 8 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0202 << 2 | 0 */:
      (Irp->IoStatus).Information = 0;
      deviceExtension->PlayActive = 0;
      if(deviceExtension->Active == 9)
	{
	  srb.CdbLength = 10;
	  srb.TimeOutValue = 10;
	  (cdb->PNR_EJECT).OperationCode = 0xC0;
	  (cdb->PNR_EJECT).Immediate = 1;
	}
      else
	{
	  srb.CdbLength = 6;
	  (scsiCdb->START_STOP).OperationCode = 0x1B;
	  (scsiCdb->START_STOP).LoadEject = 1;
	  (scsiCdb->START_STOP).Start = 0;
	}
      status = SendSrbSynchronous(deviceExtension, & srb, (void *  )0, 0);
      break;
    case 9 /* 0x00000002 << 16 | 0x0001 << 14 | 0x000D << 2 | 0 */:
    case 10 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0005 << 2 | 0 */:
    case 11 /* 0x00000002 << 16 | 0x0001 << 14 | 0x000A << 2 | 0 */:
      (Irp->IoStatus).Information = 0;
      status = (NTSTATUS )0xC0000010L;
      break;
    case 12 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0200 << 2 | 0 */:
      CdAudioIsPlayActive(DeviceObject);
    default :
      return CdAudioSendToNextDriver(DeviceObject, Irp);
      break;
    }
 SetStatusAndReturn:
  {
    if(status == (NTSTATUS )0x80000016L)
      {
	if(currentIrpStack->Flags & 0x02)
	  {
	    status = (NTSTATUS )0xC0000185L;
	    // TRACER goto PioneerRestart;
	    // This is a loop through goto!
	  }
	IoSetHardErrorOrVerifyDevice(Irp, deviceExtension->TargetDeviceObject);
      (Irp->IoStatus).Information = 0;
      }
  }
  (Irp->IoStatus).Status = status;
  myStatus = status;
  IofCompleteRequest(Irp, 0);
  return status;
}


NTSTATUS CdAudioDenonDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
  PIO_STACK_LOCATION currentIrpStack;
  PCD_DEVICE_EXTENSION deviceExtension;
  PCDROM_TOC cdaudioDataOut;
  SCSI_PASS_THROUGH srb ;
  PCDB cdb;
  NTSTATUS status ;
  ULONG i , bytesTransfered ;
  PUCHAR Toc ;
  int temp_1;
  ULONG tag_1;
  ULONG tracksToReturn ;
  ULONG tracksOnCd ;
  ULONG tracksInBuffer ;
  ULONG dataLength ;
  PCDROM_PLAY_AUDIO_MSF inputBuffer ;
  PSUB_Q_CURRENT_POSITION userPtr;
  PUCHAR SubQPtr;
  int NONDET; 

  currentIrpStack= ((Irp->Tail).Overlay).CurrentStackLocation;
  deviceExtension = DeviceObject->DeviceExtension;
  cdaudioDataOut = (Irp->AssociatedIrp).SystemBuffer;
  cdb = (PCDB )srb.Cdb;

 DenonRestart:
  memset(cdb, 0, 12);

  switch(NONDET /* ((currentIrpStack->Parameters).DeviceIoControl).IoControlCode */)
    {
    case 1 /* 0x00000002 << 16 | 0x0001 << 14 | 0x000E << 2 | 0 */:
      status = (NTSTATUS )0xC0000010L;
      (Irp->IoStatus).Information = 0;
      break;
    case 2 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0000 << 2 | 0 */:
      if(((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength
	 < (ULONG )((LONG )((LONG_PTR )(& (((CDROM_TOC *  )0)->TrackData)[0]))))
	{
	  status = (NTSTATUS )0xC0000023L;
	  (Irp->IoStatus).Information = 0;
	  break;
	}
      temp_1 =  CdAudioIsPlayActive(DeviceObject);
      if(temp_1)
	{
	  status = (NTSTATUS )0x80000011L;
	  (Irp->IoStatus).Information = 0;
	  break;
	}
      Toc = (PUCHAR )ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
					   sizeof(CDROM_TOC ), tag_1/*' AdC'*/);
      if(Toc == (void *  )0)
	{
	  status = (NTSTATUS )0xC000009AL;
	  (Irp->IoStatus).Information = 0;
	  goto SetStatusAndReturn;
	}
      memset(Toc, 0, sizeof(CDROM_TOC ));
      (cdb->CDB6GENERIC).OperationCode = 0xE9;
      srb.TimeOutValue = 10;
      srb.CdbLength = 6;
      status = SendSrbSynchronous(deviceExtension, & srb, Toc, sizeof(CDROM_TOC ));
      if(! ((NTSTATUS )status >= 0) && status != (NTSTATUS)0xC000003CL)
	{
	  if(status != (NTSTATUS )0xC000003CL)
	    {
	      ExFreePool(Toc);
	      (Irp->IoStatus).Information = 0;
	      goto SetStatusAndReturn;
	    }
	}
      status = (NTSTATUS )0x00000000L;

      if(((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength
	 > srb.DataTransferLength) 
	bytesTransfered = srb.DataTransferLength;
      else
	bytesTransfered =((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength;

      cdaudioDataOut->FirstTrack = ((Toc[1] & 0xF0) >> 4) * 10 + (Toc[1] & 0x0F);
      cdaudioDataOut->LastTrack = ((Toc[5] & 0xF0) >> 4) * 10 + (Toc[5] & 0x0F);
      {
	tracksOnCd = cdaudioDataOut->LastTrack -cdaudioDataOut->FirstTrack + 1;
	dataLength = (ULONG )((LONG )((LONG_PTR )(& (((CDROM_TOC*)0)->TrackData)[tracksOnCd])))-2;
	(cdaudioDataOut->Length)[0] = (UCHAR )(dataLength >> 8);
	(cdaudioDataOut->Length)[1] = (UCHAR )(dataLength &0xFF);
	tracksInBuffer = ((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength -	   
	                  (ULONG )((LONG )((LONG_PTR )(& (((CDROM_TOC*)0)->TrackData)[0])));
	tracksInBuffer = tracksInBuffer / sizeof(TRACK_DATA );
	if(tracksInBuffer < tracksOnCd) 
	  tracksToReturn = tracksInBuffer;
	else
	  tracksToReturn =tracksOnCd;
	
	for(i = 0; i < tracksToReturn; i++)
	  {
	    ((cdaudioDataOut->TrackData)[i]).Reserved = 0;
	    ((cdaudioDataOut->TrackData)[i]).Control = Toc[i* 4 + 12];
	    ((cdaudioDataOut->TrackData)[i]).TrackNumber =(UCHAR )(i + cdaudioDataOut->FirstTrack);
	    ((cdaudioDataOut->TrackData)[i]).Reserved1 = 0;
	    (((cdaudioDataOut->TrackData)[i]).Address)[0] = 0;
	    (((cdaudioDataOut->TrackData)[i]).Address)[1] =  ((Toc[i * 4 + 13] & 0xF0) >> 4) * 10 +
	                                                     (Toc[i * 4 + 13] & 0x0F);
	    (((cdaudioDataOut->TrackData)[i]).Address)[2] =  ((Toc[i * 4 + 14] & 0xF0) >> 4) * 10 +
	                                                     (Toc[i * 4 + 14] & 0x0F);
	    (((cdaudioDataOut->TrackData)[i]).Address)[3] =  ((Toc[i * 4 + 15] & 0xF0) >> 4) * 10 +	     
	                                                     (Toc[i * 4 + 15] & 0x0F);
	  } //end of for loop

	if(tracksInBuffer > tracksOnCd)
	  {
	    ((cdaudioDataOut->TrackData)[i]).Reserved = 0;
	    ((cdaudioDataOut->TrackData)[i]).Control = 0;
	    ((cdaudioDataOut->TrackData)[i]).TrackNumber = 0xaa;
	    ((cdaudioDataOut->TrackData)[i]).Reserved1 = 0;
	    (((cdaudioDataOut->TrackData)[i]).Address)[0] =  0;
	    (((cdaudioDataOut->TrackData)[i]).Address)[1] = ((Toc[9] & 0xF0) >> 4) * 10 + (Toc[9]   &  0x0F);
	    (((cdaudioDataOut->TrackData)[i]).Address)[2] = ((Toc[10] & 0xF0) >> 4) * 10 + (Toc[10] & 0x0F);
	    (((cdaudioDataOut->TrackData)[i]).Address)[3] = ((Toc[11] & 0xF0) >> 4) * 10 + (Toc[11] & 0x0F);
	    i++;
	  }
	(Irp->IoStatus).Information = (ULONG )((LONG )((LONG_PTR)(& (((CDROM_TOC*)0)->TrackData)[i])));
      }
      deviceExtension->Paused = 0;
      deviceExtension->PausedM = 0;
      deviceExtension->PausedS = 0;
      deviceExtension->PausedF = 0;
      deviceExtension->LastEndM = 0;
      deviceExtension->LastEndS = 0;
      deviceExtension->LastEndF = 0;
      ExFreePool(Toc);
      break;
    case 3 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0006 << 2 | 0 */:
    case 4 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0002 << 2 | 0 */:
      {

	inputBuffer = (Irp->AssociatedIrp).SystemBuffer;
	(Irp->IoStatus).Information = 0;
	deviceExtension->PlayActive = 0;
	srb.CdbLength = 6;
	srb.TimeOutValue = 10;
	(cdb->CDB6GENERIC).OperationCode = 0xE7;
	status = SendSrbSynchronous(deviceExtension, & srb,(void *  )0, 0);
	if((NTSTATUS )status >= 0)
	  {
	    deviceExtension->Paused = 0;
	    deviceExtension->PausedM = 0;
	    deviceExtension->PausedS = 0;
	    deviceExtension->PausedF = 0;
	    deviceExtension->LastEndM = 0;
	    deviceExtension->LastEndS = 0;
	    deviceExtension->LastEndF = 0;
	  }
	if(((currentIrpStack->Parameters).DeviceIoControl).IoControlCode ==
	   (0x00000002 << 16 | 0x0001 << 14 | 0x0002 <<  2 | 0))
	  {
	    goto SetStatusAndReturn;
	  }
	if(((currentIrpStack->Parameters).DeviceIoControl).InputBufferLength <
	   sizeof(CDROM_PLAY_AUDIO_MSF ))
	  {
	    status = (NTSTATUS )0xC0000004L;
	    break;
	  }
	srb.CdbLength = 10;
	srb.TimeOutValue = 10;
	(cdb->CDB10).OperationCode = 0x22;
	(cdb->CDB10).LogicalBlockByte0 = (inputBuffer->StartingM
					  / 10 << 4) + inputBuffer->StartingM % 10;
	(cdb->CDB10).LogicalBlockByte1 = (inputBuffer->StartingS
					  / 10 << 4) + inputBuffer->StartingS % 10;
	(cdb->CDB10).LogicalBlockByte2 = (inputBuffer->StartingF
					  / 10 << 4) + inputBuffer->StartingF % 10;
	(cdb->CDB10).LogicalBlockByte3 = (inputBuffer->EndingM /
					  10 << 4) + inputBuffer->EndingM % 10;
	(cdb->CDB10).Reserved2 = (inputBuffer->EndingS / 10 << 4) + 
	                         inputBuffer->EndingS % 10;				  
	(cdb->CDB10).TransferBlocksMsb = (inputBuffer->EndingF /
					  10 << 4) + inputBuffer->EndingF % 10;
	status = SendSrbSynchronous(deviceExtension, & srb,
				    (void *  )0, 0);
	if((NTSTATUS )status >= 0)
	  {
	    deviceExtension->PlayActive = 1;
	    deviceExtension->Paused = 0;
	    deviceExtension->LastEndM = (inputBuffer->EndingM / 10 << 4) +	      
	                                inputBuffer->EndingM % 10;
	    deviceExtension->LastEndS = (inputBuffer->EndingS / 10 << 4) +	      
                                	inputBuffer->EndingS % 10;
	    deviceExtension->LastEndF = (inputBuffer->EndingF / 10 << 4) +	      
	                                 inputBuffer->EndingF % 10;
	  }
	else
	  {
	    if(status == (NTSTATUS )0xC0000010L)
		status = (NTSTATUS )0xC0000015L;
	  }
      }
      break;
    case 5 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0001 << 2 | 0 */:
      {
	inputBuffer= (Irp->AssociatedIrp).SystemBuffer;
	(Irp->IoStatus).Information = 0;
	if(((currentIrpStack->Parameters).DeviceIoControl).InputBufferLength  <
	   sizeof(CDROM_SEEK_AUDIO_MSF ))
	  {
	    status = (NTSTATUS )0xC0000004L;
	    break;
	  }
	srb.CdbLength = 10;
	srb.TimeOutValue = 10;
	(cdb->CDB10).OperationCode = 0x22;
	(cdb->CDB10).LogicalBlockByte0 = (inputBuffer->EndingM / 10 <<
					  4) + inputBuffer->EndingM % 10;
	(cdb->CDB10).LogicalBlockByte1 = (inputBuffer->EndingS / 10 <<
					  4) + inputBuffer->EndingS % 10;
	(cdb->CDB10).LogicalBlockByte2 = (inputBuffer->EndingF / 10 <<
					  4) + inputBuffer->EndingF % 10;
	(cdb->CDB10).LogicalBlockByte3 = (inputBuffer->EndingM / 10 <<
					  4) + inputBuffer->EndingM % 10;
	(cdb->CDB10).Reserved2 = (inputBuffer->EndingS / 10 << 4) + inputBuffer->EndingS % 10;
	(cdb->CDB10).TransferBlocksMsb = (inputBuffer->EndingF / 10 <<
					  4) + inputBuffer->EndingF % 10;
	status = SendSrbSynchronous(deviceExtension, & srb,(void *  )0, 0);
	if((NTSTATUS )status >= 0)
	  {
	    deviceExtension->Paused = 1;
	    deviceExtension->PausedM = (inputBuffer->EndingM / 10
					<< 4) + inputBuffer->EndingM % 10;
	    deviceExtension->PausedS = (inputBuffer->EndingS / 10
					<< 4) + inputBuffer->EndingS % 10;
	    deviceExtension->PausedF = (inputBuffer->EndingF / 10
					<< 4) + inputBuffer->EndingF % 10;
	    deviceExtension->LastEndM = (inputBuffer->EndingM / 10
					 << 4) + inputBuffer->EndingM % 10;
	    deviceExtension->LastEndS = (inputBuffer->EndingS / 10
					 << 4) + inputBuffer->EndingS % 10;
	    deviceExtension->LastEndF = (inputBuffer->EndingF / 10
					 << 4) + inputBuffer->EndingF % 10;
	  }
	else
	  {
	    if(status == (NTSTATUS )0xC0000010L)
		status = (NTSTATUS )0xC0000015L;
	  }
      }
      break;
    case 6 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0003 << 2 | 0 */:
      {
	SubQPtr= ExAllocatePoolWithTag(NonPagedPoolCacheAligned,10,tag_1 /*' AdC'*/);
	(Irp->IoStatus).Information = 0;
	deviceExtension->PlayActive = 0;
	if(SubQPtr == (void *  )0)
	  {
	    status = (NTSTATUS )0xC000009AL;
	    goto SetStatusAndReturn;
	  }
	if(deviceExtension->Paused == 1)
	  {
	    ExFreePool(SubQPtr);
	    status = (NTSTATUS )0x00000000L;
	    goto SetStatusAndReturn;
	  }
	srb.CdbLength = 6;
	srb.TimeOutValue = 10;
	(cdb->CDB6GENERIC).OperationCode = 0xEB;
	((cdb->CDB6GENERIC).CommandUniqueBytes)[2] = 10;
	status = SendSrbSynchronous(deviceExtension, & srb,SubQPtr, 10);
	if(! ((NTSTATUS )status >= 0))
	  {
	    ExFreePool(SubQPtr);
	    goto SetStatusAndReturn;
	  }
	deviceExtension->PausedM = SubQPtr[7];
	deviceExtension->PausedS = SubQPtr[8];
	deviceExtension->PausedF = SubQPtr[9];
	memset(cdb, 0, 12);
	srb.CdbLength = 6;
	srb.TimeOutValue = 10;
	(cdb->CDB6GENERIC).OperationCode = 0xE7;
	status = SendSrbSynchronous(deviceExtension, & srb,(void *  )0, 0);
	if(! ((NTSTATUS )status >= 0))
	  {
	    ExFreePool(SubQPtr);
	    goto SetStatusAndReturn;
	  }
	deviceExtension->Paused = 1;
	deviceExtension->PausedM = SubQPtr[7];
	deviceExtension->PausedS = SubQPtr[8];
	deviceExtension->PausedF = SubQPtr[9];
	ExFreePool(SubQPtr);
      }
      break;
    case 7 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0004 << 2 | 0 */:
      (Irp->IoStatus).Information = 0;
      if(deviceExtension->Paused == 0)
	{
	  status = (NTSTATUS )0xC0000001L;
	  goto SetStatusAndReturn;
	}
      srb.CdbLength = 10;
      srb.TimeOutValue = 10;
      (cdb->CDB10).OperationCode = 0x22;
      (cdb->CDB10).LogicalBlockByte0 = deviceExtension->PausedM;
      (cdb->CDB10).LogicalBlockByte1 = deviceExtension->PausedS;
      (cdb->CDB10).LogicalBlockByte2 = deviceExtension->PausedF;
      (cdb->CDB10).LogicalBlockByte3 = deviceExtension->LastEndM;
      (cdb->CDB10).Reserved2 = deviceExtension->LastEndS;
      (cdb->CDB10).TransferBlocksMsb = deviceExtension->LastEndF;
      status = SendSrbSynchronous(deviceExtension, & srb, (void *  )0, 0);
      if((NTSTATUS )status >= 0)
	  deviceExtension->Paused = 0;
      break;
    case 8 /* 0x00000002 << 16 | 0x0001 << 14 | 0x000B << 2 | 0 */:
      {
	userPtr= (Irp->AssociatedIrp).SystemBuffer;	  
	SubQPtr= ExAllocatePoolWithTag(NonPagedPoolCacheAligned,sizeof(SUB_Q_CHANNEL_DATA ), 
				       tag_1 /*' AdC'*/);
	
	if(((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength
	   < sizeof(SUB_Q_CURRENT_POSITION ))
	  {
	    status = (NTSTATUS )0xC0000023L;
	    (Irp->IoStatus).Information = 0;
	    if(SubQPtr)
	      ExFreePool(SubQPtr);
	    break;
	  }
	if(SubQPtr == (void *  )0)
	  {
	    memset(userPtr, 0, sizeof(SUB_Q_CURRENT_POSITION));
	    status = (NTSTATUS )0xC000009AL;
	    (Irp->IoStatus).Information = 0;
	    goto SetStatusAndReturn;
	  }
	if(((PCDROM_SUB_Q_DATA_FORMAT )userPtr)->Format != 0x01)
	  {
	    ExFreePool(SubQPtr);
	    memset(userPtr, 0, sizeof(SUB_Q_CURRENT_POSITION));
	    status = (NTSTATUS )0xC0000001L;
	    (Irp->IoStatus).Information = 0;
	    goto SetStatusAndReturn;
	  }
	srb.CdbLength = 6;
	srb.TimeOutValue = 10;
	(cdb->CDB6GENERIC).OperationCode = 0xEB;
	((cdb->CDB6GENERIC).CommandUniqueBytes)[2] = 10;
	status = SendSrbSynchronous(deviceExtension, & srb, SubQPtr, 10);
	if((NTSTATUS )status >= 0)
	  {
	    (userPtr->Header).Reserved = 0;
	    if(deviceExtension->Paused == 1)
	      {
		deviceExtension->PlayActive = 0;
		(userPtr->Header).AudioStatus = 0x12;
	      }
	    else
	      {
		if(SubQPtr[0] == 0x01)
		  (userPtr->Header).AudioStatus = 0x11;
		else
		  {
		    if(SubQPtr[0] == 0x00)
		      {
			(userPtr->Header).AudioStatus = 0x13;
			deviceExtension->PlayActive = 0;
		      }
		    else
		      deviceExtension->PlayActive = 0;
		  }
	      }
	    ((userPtr->Header).DataLength)[0] = 0;
	    ((userPtr->Header).DataLength)[0] = 12;
	    userPtr->FormatCode = 0x01;
	    userPtr->Control = SubQPtr[1];
	    userPtr->ADR = 0;
	    userPtr->TrackNumber = ((SubQPtr[2] & 0xF0) >>
				    4) * 10 + (SubQPtr[2] & 0x0F);
	    userPtr->IndexNumber = ((SubQPtr[3] & 0xF0) >>
				    4) * 10 + (SubQPtr[3] & 0x0F);
	    (userPtr->AbsoluteAddress)[0] = 0;
	    (userPtr->AbsoluteAddress)[1] = ((SubQPtr[7] &
					      0xF0) >> 4) * 10 + (SubQPtr[7] & 0x0F);
	    (userPtr->AbsoluteAddress)[2] = ((SubQPtr[8] &
					      0xF0) >> 4) * 10 + (SubQPtr[8] & 0x0F);
	    (userPtr->AbsoluteAddress)[3] = ((SubQPtr[9] &
					      0xF0) >> 4) * 10 + (SubQPtr[9] & 0x0F);
	    (userPtr->TrackRelativeAddress)[0] = 0;
	    (userPtr->TrackRelativeAddress)[1] = ((SubQPtr[4] & 0xF0) >> 4) * 10 +	      
	                                         (SubQPtr[4] & 0x0F);
	    (userPtr->TrackRelativeAddress)[2] = ((SubQPtr[5] & 0xF0) >> 4) * 10 +
	                                         (SubQPtr[5] & 0x0F);
	    (userPtr->TrackRelativeAddress)[3] = ((SubQPtr[6] & 0xF0) >> 4) * 10 +  
                                       	         (SubQPtr[6] & 0x0F);
	    (Irp->IoStatus).Information =sizeof(SUB_Q_CURRENT_POSITION );
	  }
	else
	    (Irp->IoStatus).Information = 0;
	ExFreePool(SubQPtr);
      }
      break;
    case 9 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0202 << 2 | 0 */:
      (Irp->IoStatus).Information = 0;
      deviceExtension->PlayActive = 0;
      srb.CdbLength = 6;
      srb.TimeOutValue = 10;
      (cdb->CDB6GENERIC).OperationCode = 0xE6;
      status = SendSrbSynchronous(deviceExtension, & srb, (void *  )0, 0);
      break;
    case 10 /* 0x00000002 << 16 | 0x0001 << 14 | 0x000D << 2 | 0 */:
    case 11 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0005 << 2 | 0 */:
    case 12 /* 0x00000002 << 16 | 0x0001 << 14 | 0x000A << 2 | 0 */:
      (Irp->IoStatus).Information = 0;
      status = (NTSTATUS )0xC0000010L;
      break;
    case 13 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0200 << 2 | 0 */:
      CdAudioIsPlayActive(DeviceObject);
    default :
      return CdAudioSendToNextDriver(DeviceObject, Irp);
      break;
    }
 SetStatusAndReturn:
  {
    if(status == (NTSTATUS )0x80000016L)
      {
	if(currentIrpStack->Flags & 0x02)
	  {
	    status = (NTSTATUS )0xC0000185L;
	    // TRACER goto DenonRestart;
	    // This is a loop via goto!
	  }
	IoSetHardErrorOrVerifyDevice(Irp,deviceExtension->TargetDeviceObject);
	(Irp->IoStatus).Information = 0;
      }
  }
  (Irp->IoStatus).Status = status;
  myStatus = status;
  IofCompleteRequest(Irp, 0);
  return status;
}

NTSTATUS CdAudioHitachiSendPauseCommand(PDEVICE_OBJECT DeviceObject )
{
  PCD_DEVICE_EXTENSION deviceExtension;
  SCSI_PASS_THROUGH srb ;
  PHITACHICDB cdb;
  NTSTATUS status ;
  ULONG tag_1;
  PUCHAR PausePos ;

  deviceExtension = DeviceObject->DeviceExtension;
  cdb = (PHITACHICDB )srb.Cdb;


  PausePos = (PUCHAR )ExAllocatePoolWithTag(NonPagedPoolCacheAligned, 3,tag_1/*' AdC'*/);		
  if(PausePos == (void *  )0)
      return (NTSTATUS )0xC000009AL;

  memset(PausePos, 0, 3);
  memset(cdb, 0, 12);
  srb.CdbLength = 12;
  srb.TimeOutValue = 10;
  (cdb->PAUSE_AUDIO).OperationCode = 0xE1;
  status = SendSrbSynchronous(deviceExtension, & srb, PausePos, 3);
  ExFreePool(PausePos);
  return status;
}


NTSTATUS CdAudioHitachiDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
  PIO_STACK_LOCATION currentIrpStack;
  PCD_DEVICE_EXTENSION deviceExtension;
  PCDROM_TOC cdaudioDataOut;
  SCSI_PASS_THROUGH srb ;
  PHITACHICDB cdb;
  NTSTATUS status ;
  ULONG i , bytesTransfered ;
  PUCHAR Toc ;
  int temp_1;
  ULONG tag_1;
  ULONG tracksToReturn ;
  ULONG tracksOnCd ;
  ULONG tracksInBuffer ;
  ULONG dataLength ;
  PCDROM_PLAY_AUDIO_MSF inputBuffer ;
  PSUB_Q_CURRENT_POSITION userPtr;
  PUCHAR SubQPtr;
  PUCHAR PausePos;
  PUCHAR EjectStatus;
  int NONDET;

  currentIrpStack  = ((Irp->Tail).Overlay).CurrentStackLocation;   
  deviceExtension = DeviceObject->DeviceExtension;
  cdaudioDataOut = (Irp->AssociatedIrp).SystemBuffer;
  cdb = (PHITACHICDB )srb.Cdb;


 HitachiRestart:
  memset(cdb, 0, 12);
  
  switch(NONDET /* ((currentIrpStack->Parameters).DeviceIoControl).IoControlCode */)
    {
    case 1 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0000 << 2 | 0 */:
      if(((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength
	 < (ULONG )((LONG )((LONG_PTR )(& (((CDROM_TOC * 
					     )0)->TrackData)[0]))))
	{
	  status = (NTSTATUS )0xC0000023L;
	  (Irp->IoStatus).Information = 0;
	  break;
	}
      temp_1 = CdAudioIsPlayActive(DeviceObject); 
      if(temp_1)
	{
	  status = (NTSTATUS )0x80000011L;
	  (Irp->IoStatus).Information = 0;
	  break;
	}
      Toc = (PUCHAR )ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
					   sizeof(CDROM_TOC ),tag_1 /*' AdC'*/);
      if(Toc == (void *  )0)
	{
	  status = (NTSTATUS )0xC000009AL;
	  (Irp->IoStatus).Information = 0;
	  goto SetStatusAndReturn;
	}
      memset(Toc, 0, sizeof(CDROM_TOC ));
      srb.CdbLength = 12;
      if(deviceExtension->Active == 5)
	  (cdb->READ_DISC_INFO).OperationCode = 0xE3;
      else
	  (cdb->READ_DISC_INFO).OperationCode = 0xE8;
      
      ((cdb->READ_DISC_INFO).AllocationLength)[0] = sizeof(CDROM_TOC )>> 8;
      ((cdb->READ_DISC_INFO).AllocationLength)[1] = sizeof(CDROM_TOC ) & 0xFF;
      srb.TimeOutValue = 10;
      status = SendSrbSynchronous(deviceExtension, & srb, Toc,sizeof(CDROM_TOC ));
      if(! ((NTSTATUS )status >= 0) && status != (NTSTATUS)0xC000003CL)
	{
	  if(status != (NTSTATUS )0xC000003CL)
	    {
	      ExFreePool(Toc);
	      (Irp->IoStatus).Information = 0;
	      goto SetStatusAndReturn;
	    }
	}
      else
	status = (NTSTATUS )0x00000000L;
      if(deviceExtension->Active == 6)
	{
	  if(((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength >
	     sizeof(CDROM_TOC ))
	    bytesTransfered =sizeof(CDROM_TOC );
	  else
	    bytesTransfered = ((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength;
	  cdaudioDataOut->FirstTrack = Toc[2];
	  cdaudioDataOut->LastTrack = Toc[3];
	  {
	    tracksOnCd = cdaudioDataOut->LastTrack -cdaudioDataOut->FirstTrack + 1;
	    dataLength = (ULONG )((LONG )((LONG_PTR )(& (((CDROM_TOC *)0)->TrackData)[tracksOnCd])))-2;
	    (cdaudioDataOut->Length)[0] = (UCHAR )(dataLength >> 8);
	    (cdaudioDataOut->Length)[1] = (UCHAR)(dataLength & 0xFF);					   
	    tracksInBuffer =((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength - 
	                    (ULONG )((LONG)((LONG_PTR )(& (((CDROM_TOC * )0)->TrackData)[0])));
	    tracksInBuffer = tracksInBuffer / sizeof(TRACK_DATA );
	    if(tracksInBuffer < tracksOnCd)
	      tracksToReturn = tracksInBuffer;
	    else
	      tracksToReturn = tracksOnCd;

	    for(i = 0; i < tracksToReturn; i++)
	      {
		((cdaudioDataOut->TrackData)[i]).Reserved = 0;
		((cdaudioDataOut->TrackData)[i]).Control= (Toc[i * 4 + 8] & 0x0F) << 4 |
	 	                                           Toc[i * 4 + 8] >> 4;
		((cdaudioDataOut->TrackData)[i]).TrackNumber = (UCHAR )(i +cdaudioDataOut->FirstTrack);
		((cdaudioDataOut->TrackData)[i]).Reserved1 = 0;
		(((cdaudioDataOut->TrackData)[i]).Address)[0] = 0;
		(((cdaudioDataOut->TrackData)[i]).Address)[1] = Toc[i * 4 + 9];
		(((cdaudioDataOut->TrackData)[i]).Address)[2] = Toc[i * 4 + 10];
		(((cdaudioDataOut->TrackData)[i]).Address)[3] = Toc[i * 4 + 11];
	      }

	    if(tracksInBuffer > tracksOnCd)
	      {
		((cdaudioDataOut->TrackData)[i]).Reserved = 0;
		((cdaudioDataOut->TrackData)[i]).Control= 0x10;
		((cdaudioDataOut->TrackData)[i]).TrackNumber= 0xaa;
		((cdaudioDataOut->TrackData)[i]).Reserved1 = 0;
		(((cdaudioDataOut->TrackData)[i]).Address )[0] = 0;
		(((cdaudioDataOut->TrackData)[i]).Address )[1] = Toc[5];
		(((cdaudioDataOut->TrackData)[i]).Address )[2] = Toc[6];
		(((cdaudioDataOut->TrackData)[i]).Address )[3] = Toc[7];
		i++;
	      }
	    (Irp->IoStatus).Information=(ULONG)((LONG)((LONG_PTR)(&(((CDROM_TOC*)0)->TrackData)[i])));
	  }
	  deviceExtension->Paused = 0;
	  deviceExtension->PausedM = 0;
	  deviceExtension->PausedS = 0;
	  deviceExtension->PausedF = 0;
	  deviceExtension->LastEndM = 0;
	  deviceExtension->LastEndS = 0;
	  deviceExtension->LastEndF = 0;
	}
      else
	{
	  if( ((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength
	      > sizeof(CDROM_TOC ))
	    bytesTransfered = sizeof(CDROM_TOC );
	  else
	    bytesTransfered = ((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength; 

	  cdaudioDataOut->FirstTrack = Toc[1];
	  cdaudioDataOut->LastTrack = Toc[2];
	  {
	    tracksOnCd = cdaudioDataOut->LastTrack -cdaudioDataOut->FirstTrack + 1;
	    dataLength = (ULONG )((LONG )((LONG_PTR )(&
						      (((CDROM_TOC * 
							 )0)->TrackData)[tracksOnCd]))) - 2;
	    (cdaudioDataOut->Length)[0] = (UCHAR
					   )(dataLength >> 8);
	    (cdaudioDataOut->Length)[1] = (UCHAR
					   )(dataLength & 0xFF);
	    tracksInBuffer = ((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength - 
	                     (ULONG )((LONG)((LONG_PTR )(& (((CDROM_TOC * )0)->TrackData)[0])));
	    tracksInBuffer = tracksInBuffer / sizeof(TRACK_DATA );
	    if(tracksInBuffer < tracksOnCd)	      
	      tracksToReturn = tracksInBuffer;
	    else
	      tracksToReturn =tracksOnCd;

	    for(i = 0; i < tracksToReturn; i++)
	      {
		((cdaudioDataOut->TrackData)[i]).Reserved = 0;
		if(Toc[i * 3 + 6] & 0x80)
		  ((cdaudioDataOut->TrackData)[i]).Control = 0x04;
		else
		  ((cdaudioDataOut->TrackData)[i]).Control = 0;
		((cdaudioDataOut->TrackData)[i]).Adr = 0;
		((cdaudioDataOut->TrackData)[i]).TrackNumber  = (UCHAR )(i +cdaudioDataOut->FirstTrack);
		((cdaudioDataOut->TrackData)[i]).Reserved1= 0;
		(((cdaudioDataOut->TrackData)[i]).Address)[0] = 0;
		(((cdaudioDataOut->TrackData)[i]).Address)[1] = Toc[i * 3 + 6] & 0x7f;
		(((cdaudioDataOut->TrackData)[i]).Address)[2] = Toc[i * 3 + 7];
		(((cdaudioDataOut->TrackData)[i]).Address)[3] = Toc[i * 3 + 8];
	      }
	    if(tracksInBuffer > tracksOnCd)
	      {
		((cdaudioDataOut->TrackData)[i]).Reserved= 0;
		((cdaudioDataOut->TrackData)[i]).Control= 0x10;
		((cdaudioDataOut->TrackData)[i]).TrackNumber= 0xaa;
		((cdaudioDataOut->TrackData)[i]).Reserved1= 0;
		(((cdaudioDataOut->TrackData)[i]).Address)[0] = 0;
		(((cdaudioDataOut->TrackData)[i]).Address)[1] = Toc[3];
		(((cdaudioDataOut->TrackData)[i]).Address)[2] = Toc[4];
		(((cdaudioDataOut->TrackData)[i]).Address)[3] = Toc[5];
		i++;
	      }
	    (Irp->IoStatus).Information = (ULONG)((LONG)((LONG_PTR)(&(((CDROM_TOC*)0)->TrackData)[i])));
	  }
	}
      ExFreePool(Toc);
      break;
    case 2 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0002 << 2 | 0 */:
      deviceExtension->PlayActive = 0;
      (Irp->IoStatus).Information = 0;
      CdAudioHitachiSendPauseCommand(DeviceObject);
      deviceExtension->Paused = 0;
      deviceExtension->PausedM = 0;
      deviceExtension->PausedS = 0;
      deviceExtension->PausedF = 0;
      deviceExtension->LastEndM = 0;
      deviceExtension->LastEndS = 0;
      deviceExtension->LastEndF = 0;
      return CdAudioSendToNextDriver(DeviceObject, Irp);
      break;
    case 3 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0006 << 2 | 0 */:
      {
	inputBuffer= (Irp->AssociatedIrp).SystemBuffer;
	(Irp->IoStatus).Information = 0;
	if(((currentIrpStack->Parameters).DeviceIoControl).InputBufferLength
	   < sizeof(CDROM_PLAY_AUDIO_MSF ))
	  {
	    status = (NTSTATUS )0xC0000004L;
	    break;
	  }
	CdAudioHitachiSendPauseCommand(DeviceObject);
	srb.CdbLength = 12;
	srb.TimeOutValue = 10;
	(cdb->PLAY_AUDIO).OperationCode = 0xE0;
	(cdb->PLAY_AUDIO).Immediate = 1;
	(cdb->PLAY_AUDIO).StartingM = inputBuffer->StartingM;
	(cdb->PLAY_AUDIO).StartingS = inputBuffer->StartingS;
	(cdb->PLAY_AUDIO).StartingF = inputBuffer->StartingF;
	(cdb->PLAY_AUDIO).EndingM = inputBuffer->EndingM;
	(cdb->PLAY_AUDIO).EndingS = inputBuffer->EndingS;
	(cdb->PLAY_AUDIO).EndingF = inputBuffer->EndingF;
	status = SendSrbSynchronous(deviceExtension, & srb,(void *  )0, 0);
	if((NTSTATUS )status >= 0)
	  {
	    deviceExtension->PlayActive = 1;
	    deviceExtension->Paused = 0;
	    deviceExtension->PausedM = inputBuffer->StartingM;
	    deviceExtension->PausedS = inputBuffer->StartingS; 
	    deviceExtension->PausedF = inputBuffer->StartingF;
	    deviceExtension->LastEndM = inputBuffer->EndingM;
	    deviceExtension->LastEndS = inputBuffer->EndingS;
	    deviceExtension->LastEndF = inputBuffer->EndingF;
	  }
	else
	  {
	  }
      }
      break;
    case 4 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0001 << 2 | 0 */:
      {
	inputBuffer = (Irp->AssociatedIrp).SystemBuffer;	  
	(Irp->IoStatus).Information = 0;
	if(((currentIrpStack->Parameters).DeviceIoControl).InputBufferLength
	   < sizeof(CDROM_SEEK_AUDIO_MSF ))
	  {
	    status = (NTSTATUS )0xC0000004L;
	    break;
	  }
	CdAudioHitachiSendPauseCommand(DeviceObject);
	srb.CdbLength = 12;
	srb.TimeOutValue = 10;
	(cdb->PLAY_AUDIO).OperationCode = 0xE0;
	(cdb->PLAY_AUDIO).Immediate = 1;
	(cdb->PLAY_AUDIO).StartingM = inputBuffer->StartingM;
	(cdb->PLAY_AUDIO).StartingS = inputBuffer->StartingS;
	(cdb->PLAY_AUDIO).StartingF = inputBuffer->StartingF;
	(cdb->PLAY_AUDIO).EndingM = inputBuffer->EndingM;
	(cdb->PLAY_AUDIO).EndingS = inputBuffer->EndingS;
	(cdb->PLAY_AUDIO).EndingF = inputBuffer->EndingF;
	status = SendSrbSynchronous(deviceExtension, & srb, (void *  )0, 0);
	if((NTSTATUS )status >= 0)
	  {
	    deviceExtension->PausedM = inputBuffer->StartingM;
	    deviceExtension->PausedS = inputBuffer->StartingS;
	    deviceExtension->PausedF = inputBuffer->StartingF;
	    deviceExtension->LastEndM = inputBuffer->EndingM;
	    deviceExtension->LastEndS = inputBuffer->EndingS;
	    deviceExtension->LastEndF = inputBuffer->EndingF;
	  }
	else
	  {
	  }
      }
      break;
    case 5 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0003 << 2 | 0 */:
      {
	PausePos = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,3,tag_1 /*' AdC'*/);
	(Irp->IoStatus).Information = 0;
	if(PausePos == (void *  )0)
	  {
	    status = (NTSTATUS )0xC000009AL;
	    goto SetStatusAndReturn;
	  }
	deviceExtension->PlayActive = 0;
	memset(PausePos, 0, 3);
	srb.CdbLength = 12;
	srb.TimeOutValue = 10;
	(cdb->PAUSE_AUDIO).OperationCode = 0xE1;
	status = SendSrbSynchronous(deviceExtension, & srb,PausePos, 3);
	deviceExtension->Paused = 1;
	deviceExtension->PausedM = PausePos[0];
	deviceExtension->PausedS = PausePos[1];
	deviceExtension->PausedF = PausePos[2];
	ExFreePool(PausePos);
      }
      break;
    case 6 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0004 << 2 | 0 */:
      (Irp->IoStatus).Information = 0;
      CdAudioHitachiSendPauseCommand(DeviceObject);
      srb.CdbLength = 12;
      srb.TimeOutValue = 10;
      (cdb->PLAY_AUDIO).OperationCode = 0xE0;
      (cdb->PLAY_AUDIO).Immediate = 1;
      (cdb->PLAY_AUDIO).StartingM = deviceExtension->PausedM;
      (cdb->PLAY_AUDIO).StartingS = deviceExtension->PausedS;
      (cdb->PLAY_AUDIO).StartingF = deviceExtension->PausedF;
      (cdb->PLAY_AUDIO).EndingM = deviceExtension->LastEndM;
      (cdb->PLAY_AUDIO).EndingS = deviceExtension->LastEndS;
      (cdb->PLAY_AUDIO).EndingF = deviceExtension->LastEndF;
      status = SendSrbSynchronous(deviceExtension, & srb, (void *  )0,0);
      if((NTSTATUS )status >= 0)
	  deviceExtension->Paused = 0;
      break;
    case 7 /* 0x00000002 << 16 | 0x0001 << 14 | 0x000B << 2 | 0 */:
      {
	userPtr  = (Irp->AssociatedIrp).SystemBuffer;
	SubQPtr = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
					sizeof(SUB_Q_CHANNEL_DATA ),tag_1 /*' AdC'*/);
	if(((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength
	   < sizeof(SUB_Q_CURRENT_POSITION ))
	  {
	    status = (NTSTATUS )0xC0000023L;
	    (Irp->IoStatus).Information = 0;
	    if(SubQPtr)
	      ExFreePool(SubQPtr);
	    break;
	  }
	if(SubQPtr == (void *  )0)
	  {
	    status = (NTSTATUS )0xC000009AL;
	    (Irp->IoStatus).Information = 0;
	    goto SetStatusAndReturn;
	  }
	if(((PCDROM_SUB_Q_DATA_FORMAT )userPtr)->Format != 0x01)
	  {
	    ExFreePool(SubQPtr);
	    status = (NTSTATUS )0xC0000001L;
	    (Irp->IoStatus).Information = 0;
	    goto SetStatusAndReturn;
	  }
	srb.CdbLength = 12;
	srb.TimeOutValue = 10;
	(cdb->AUDIO_STATUS).OperationCode = 0xE5;
      Retry:
	status = SendSrbSynchronous(deviceExtension, &
				    srb, SubQPtr, sizeof(SUB_Q_CHANNEL_DATA));
	if((NTSTATUS )status >= 0 || status == (NTSTATUS)0xC000003CL)
						
	  {
	    // TRACER if((SubQPtr[1] & 0x0F) != 1)
	    //	      goto Retry;
	    // This is loop via goto!
	    
	    (userPtr->Header).Reserved = 0;
	    if(deviceExtension->Paused == 1)
	      {
		deviceExtension->PlayActive = 0;
		(userPtr->Header).AudioStatus = 0x12;
	      }
	    else
	      {
		if(SubQPtr[0] == 0x01)
		  (userPtr->Header).AudioStatus = 0x11;
		else
		  {
		    if(SubQPtr[0] == 0x00)
		      {
			(userPtr->Header).AudioStatus = 0x13;
			deviceExtension->PlayActive  = 0;
		      }
		    else
		      deviceExtension->PlayActive = 0;
		  }
	      }
	    ((userPtr->Header).DataLength)[0] = 0;
	    ((userPtr->Header).DataLength)[0] = 12;
	    userPtr->FormatCode = 0x01;
	    userPtr->Control = (SubQPtr[1] & 0xF0) >> 4;
	    userPtr->ADR = SubQPtr[1] & 0x0F;
	    userPtr->TrackNumber = SubQPtr[2];
	    userPtr->IndexNumber = SubQPtr[3];
	    (userPtr->AbsoluteAddress)[0] = 0;
	    (userPtr->AbsoluteAddress)[1] = SubQPtr[8];
	    (userPtr->AbsoluteAddress)[2] = SubQPtr[9];
	    (userPtr->AbsoluteAddress)[3] = SubQPtr[10];
	    (userPtr->TrackRelativeAddress)[0] = 0;
	    (userPtr->TrackRelativeAddress)[1] = SubQPtr[4];
	    (userPtr->TrackRelativeAddress)[2] = SubQPtr[5];
	    (userPtr->TrackRelativeAddress)[3] = SubQPtr[6];
	    (Irp->IoStatus).Information =sizeof(SUB_Q_CURRENT_POSITION );
	    status = (NTSTATUS )0x00000000L;
	  }
	else
	    (Irp->IoStatus).Information = 0;
	ExFreePool(SubQPtr);
      }
      break;
    case 8 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0202 << 2 | 0 */:
      {
	EjectStatus = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,	  
					    1, tag_1 /*' AdC'*/);
	(Irp->IoStatus).Information = 0;
	if(EjectStatus == (void *  )0)
	  {
	    status = (NTSTATUS )0xC000009AL;
	    goto SetStatusAndReturn;
	  }
	deviceExtension->PlayActive = 0;
	srb.CdbLength = 12;
	srb.TimeOutValue = 10;
	(cdb->EJECT).OperationCode = 0xE4;
	(cdb->EJECT).Eject = 1;
	status = SendSrbSynchronous(deviceExtension, & srb,EjectStatus, 1);
	if((NTSTATUS )status >= 0)
	  {
	    deviceExtension->Paused = 0;
	    deviceExtension->PausedM = 0;
	    deviceExtension->PausedS = 0;
	    deviceExtension->PausedF = 0;
	    deviceExtension->LastEndM = 0;
	    deviceExtension->LastEndS = 0;
	    deviceExtension->LastEndF = 0;
	  }
	ExFreePool(EjectStatus);
      }
      break;
    case 9  /* 0x00000002 << 16 | 0x0001 << 14 | 0x000D << 2 | 0 */:
    case 10 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0005 << 2 | 0 */:
    case 11 /* 0x00000002 << 16 | 0x0001 << 14 | 0x000A << 2 | 0 */:
      (Irp->IoStatus).Information = 0;
      status = (NTSTATUS )0xC0000010L;
      break;
    case 12 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0200 << 2 | 0 */:
      CdAudioIsPlayActive(DeviceObject);
    default :
      return CdAudioSendToNextDriver(DeviceObject, Irp);
      break;
    }
 SetStatusAndReturn:
  {
    if(status == (NTSTATUS )0x80000016L)
      {
	if(currentIrpStack->Flags & 0x02)
	  {
	    status = (NTSTATUS )0xC0000185L;
	    // TRACER  goto HitachiRestart;
	    // This is a loop via goto!
	  }
	IoSetHardErrorOrVerifyDevice(Irp, deviceExtension->TargetDeviceObject);
	(Irp->IoStatus).Information = 0;
      }
  }
  (Irp->IoStatus).Status = status;
  myStatus = status;
  IofCompleteRequest(Irp, 0);
  return status;
}

NTSTATUS CdAudio535DeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
  PIO_STACK_LOCATION currentIrpStack;
  PCD_DEVICE_EXTENSION deviceExtension;
  PCDROM_TOC cdaudioDataOut;
  SCSI_PASS_THROUGH srb ;
  PREAD_CAPACITY_DATA lastSession ;
  PCDB cdb;
  NTSTATUS status ;
  ULONG i , bytesTransfered ;
  PUCHAR Toc ;
  ULONG destblock ;
  int temp_1;
  ULONG tag_1;
  ULONG tracksToReturn ;
  ULONG tracksOnCd ;
  ULONG tracksInBuffer ;
  ULONG dataLength ;
  PCDROM_PLAY_AUDIO_MSF inputBuffer ;
  PSUB_Q_CURRENT_POSITION userPtr;
  PUCHAR SubQPtr;
  PUCHAR PausePos;
  PUCHAR EjectStatus;
  int NONDET; 

  currentIrpStack = ((Irp->Tail).Overlay).CurrentStackLocation;
  deviceExtension = DeviceObject->DeviceExtension;
  cdaudioDataOut = (Irp->AssociatedIrp).SystemBuffer;
  cdb = (PCDB )srb.Cdb;
  
  
  memset(cdb, 0, 12);
  
  switch(NONDET /* ((currentIrpStack->Parameters).DeviceIoControl).IoControlCode */)
    {
    case 1 /* 0x00000002 << 16 | 0x0001 << 14 | 0x000E << 2 | 0 */:
      temp_1 = CdAudioIsPlayActive(DeviceObject);
      if(temp_1)
	{
	  status = (NTSTATUS )0x80000011L;
	  (Irp->IoStatus).Information = 0;
	  break;
	}
      if(((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength
	 < (ULONG )((LONG )((LONG_PTR )(& (((CDROM_TOC *)0)->TrackData)[1]))))
	{
	  status = (NTSTATUS )0xC0000023L;
	  (Irp->IoStatus).Information = 0;
	  break;
	}
      lastSession = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
					  sizeof(READ_CAPACITY_DATA ),tag_1 /*' AdC'*/);
      if(lastSession == (void *  )0)
	{
	  status = (NTSTATUS )0xC000009AL;
	  (Irp->IoStatus).Information = 0;
	  goto SetStatusAndReturn;
	}
      memset(lastSession, 0, sizeof(READ_CAPACITY_DATA ));
      srb.CdbLength = 10;
      (cdb->CDB10).OperationCode = 0x26;
      srb.TimeOutValue = 10;
      status = SendSrbSynchronous(deviceExtension, & srb, lastSession,
				  sizeof(READ_CAPACITY_DATA ));
      if(! ((NTSTATUS )status >= 0))
	{
	  ExFreePool(lastSession);
	  (Irp->IoStatus).Information = 0;
	  goto SetStatusAndReturn;
	}
      else
	  status = (NTSTATUS )0x00000000L;
      bytesTransfered = (LONG )((LONG_PTR )(& (((CDROM_TOC *  )0)->TrackData)[1]));
      (Irp->IoStatus).Information = bytesTransfered;
      memset(cdaudioDataOut, 0, bytesTransfered);
      (cdaudioDataOut->Length)[0] = (UCHAR )(bytesTransfered - 2 >>  8);
      (cdaudioDataOut->Length)[1] = (UCHAR )(bytesTransfered - 2 & 0xFF);
      if(lastSession->LogicalBlockAddress == 0)
	{
	  ExFreePool(lastSession);
	  break;
	}
      cdaudioDataOut->FirstTrack = 1;
      cdaudioDataOut->LastTrack = 2;
      * (ULONG *  )(& (((cdaudioDataOut->TrackData)[0]).Address)[0]) =lastSession->LogicalBlockAddress;
      ExFreePool(lastSession);
      break;
    case 2 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0000 << 2 | 0 */:
      if(((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength
	 < (ULONG )((LONG )((LONG_PTR )(& (((CDROM_TOC *  )0)->TrackData)[0]))))
	{
	  status = (NTSTATUS )0xC0000023L;
	  (Irp->IoStatus).Information = 0;
	  break;
	}
      temp_1 = CdAudioIsPlayActive(DeviceObject);
      if(temp_1)
	{
	  status = (NTSTATUS )0x80000011L;
	  (Irp->IoStatus).Information = 0;
	  break;
	}
      Toc = (PUCHAR )ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
					   sizeof(CDROM_TOC ),tag_1 /*' AdC'*/);
      if(Toc == (void *  )0)
	{
	  status = (NTSTATUS )0xC000009AL;
	  (Irp->IoStatus).Information = 0;
	  goto SetStatusAndReturn;
	}
      memset(Toc, 0, sizeof(CDROM_TOC ));
      (cdb->CDB10).OperationCode = 0x43;
      (cdb->CDB10).Reserved1 = 1;
      (cdb->CDB10).TransferBlocksMsb = sizeof(CDROM_TOC ) >> 8;
      (cdb->CDB10).TransferBlocksLsb = sizeof(CDROM_TOC ) & 0xFF;
      srb.TimeOutValue = 10;
      srb.CdbLength = 10;
      status = SendSrbSynchronous(deviceExtension, & srb, Toc,
				  sizeof(CDROM_TOC ));
      if(! ((NTSTATUS )status >= 0) && status != (NTSTATUS)0xC000003CL)
	{
	  if(status != (NTSTATUS )0xC000003CL)
	    {
	      ExFreePool(Toc);
	      (Irp->IoStatus).Information = 0;
	      goto SetStatusAndReturn;
	    }
	}
      else
	  status = (NTSTATUS )0x00000000L;
      
      if(((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength
	 > sizeof(CDROM_TOC ))
	bytesTransfered = sizeof(CDROM_TOC );
      else
	bytesTransfered =((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength;
      
      (cdaudioDataOut->Length)[0] = Toc[0];
      (cdaudioDataOut->Length)[1] = Toc[1];
      cdaudioDataOut->FirstTrack = ((Toc[2] & 0xF0) >> 4) * 10 + (Toc[2] & 0x0F);
      cdaudioDataOut->LastTrack = ((Toc[3] & 0xF0) >> 4) * 10 + (Toc[3] & 0x0F);
      tracksOnCd = cdaudioDataOut->LastTrack - cdaudioDataOut->FirstTrack + 1;
      tracksInBuffer = ((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength -	  
	(ULONG )((LONG )((LONG_PTR )(& (((CDROM_TOC * )0)->TrackData)[0])));
      tracksInBuffer = tracksInBuffer / sizeof(TRACK_DATA );
      if(tracksInBuffer < tracksOnCd)
	tracksToReturn = tracksInBuffer;
      else
	tracksToReturn =tracksOnCd;
      
      for(i = 0; i < tracksToReturn; i++)
	{
	  ((cdaudioDataOut->TrackData)[i]).Reserved = 0;
	  ((cdaudioDataOut->TrackData)[i]).Control = Toc[i* 8 + 4 + 1];
	  ((cdaudioDataOut->TrackData)[i]).TrackNumber = ((Toc[i * 8 + 4 + 2] & 0xF0) >> 4) * 10   
	    + (Toc[i * 8 + 4 + 2] & 0x0F);
	  ((cdaudioDataOut->TrackData)[i]).Reserved1 = 0;
	  (((cdaudioDataOut->TrackData)[i]).Address)[0] =  0;
	  (((cdaudioDataOut->TrackData)[i]).Address)[1] = Toc[i * 8 + 4 + 5];
	  (((cdaudioDataOut->TrackData)[i]).Address)[2] = Toc[i * 8 + 4 + 6];
	  (((cdaudioDataOut->TrackData)[i]).Address)[3] = Toc[i * 8 + 4 + 7];
	}
      
      if(tracksInBuffer > tracksOnCd)
	{
	  ((cdaudioDataOut->TrackData)[i]).Reserved = 0;
	  ((cdaudioDataOut->TrackData)[i]).Control = Toc[i* 8 + 4 + 1];
	  ((cdaudioDataOut->TrackData)[i]).TrackNumber = Toc[i * 8 + 4 + 2];
	  ((cdaudioDataOut->TrackData)[i]).Reserved1 = 0;
	  (((cdaudioDataOut->TrackData)[i]).Address)[0] =  0;
	  (((cdaudioDataOut->TrackData)[i]).Address)[1] = Toc[i * 8 + 4 + 5];
	  (((cdaudioDataOut->TrackData)[i]).Address)[2] = Toc[i * 8 + 4 + 6];
	  (((cdaudioDataOut->TrackData)[i]).Address)[3] = Toc[i * 8 + 4 + 7];
	  i++;
	}
      (Irp->IoStatus).Information = (ULONG)((LONG)((LONG_PTR)(&(((CDROM_TOC*)0)->TrackData)[i])));
      ExFreePool(Toc);
      break;
    case 3 /* 0x00000002 << 16 | 0x0001 << 14 | 0x000B << 2 | 0 */:
      userPtr = (Irp->AssociatedIrp).SystemBuffer;
      SubQPtr = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,				       
				      sizeof(SUB_Q_CURRENT_POSITION ),tag_1/* ' AdC'*/);
      if(((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength
	 < sizeof(SUB_Q_CURRENT_POSITION ))
	{
	  status = (NTSTATUS )0xC0000023L;
	  (Irp->IoStatus).Information = 0;
	  if(SubQPtr)
	    ExFreePool(SubQPtr);
	  break;
	}
      if(SubQPtr == (void *  )0)
	{
	  memset(userPtr, 0, sizeof(SUB_Q_CURRENT_POSITION));
	  status = (NTSTATUS )0xC000009AL;
	  (Irp->IoStatus).Information = 0;
	  goto SetStatusAndReturn;
	}
      if(((PCDROM_SUB_Q_DATA_FORMAT )userPtr)->Format != 0x01)
	{
	  ExFreePool(SubQPtr);
	  memset(userPtr, 0, sizeof(SUB_Q_CURRENT_POSITION));
	  status = (NTSTATUS )0xC0000001L;
	  (Irp->IoStatus).Information = 0;
	  goto SetStatusAndReturn;
	}
      srb.CdbLength = 10;
      srb.TimeOutValue = 10;
      (cdb->SUBCHANNEL).OperationCode = 0x42;
      (cdb->SUBCHANNEL).Msf = 1;
      (cdb->SUBCHANNEL).SubQ = 1;
      (cdb->SUBCHANNEL).Format = 1;
      ((cdb->SUBCHANNEL).AllocationLength)[1] = sizeof(SUB_Q_CURRENT_POSITION );
      status = SendSrbSynchronous(deviceExtension, & srb,
				    SubQPtr, sizeof(SUB_Q_CURRENT_POSITION ));
      if((NTSTATUS )status >= 0)
	{
	  if(SubQPtr[1] == 0x11)
	      deviceExtension->PlayActive = 1;
	  else
	    deviceExtension->PlayActive = 0;
	  
	  (userPtr->Header).Reserved = 0;
	  (userPtr->Header).AudioStatus = SubQPtr[1];
	  ((userPtr->Header).DataLength)[0] = 0;
	  ((userPtr->Header).DataLength)[1] = 12;
	  userPtr->FormatCode = 0x01;
	  userPtr->Control = SubQPtr[5];
	  userPtr->ADR = 0;
	  userPtr->TrackNumber = ((SubQPtr[6] & 0xF0) >>
				  4) * 10 + (SubQPtr[6] & 0x0F);
	  userPtr->IndexNumber = ((SubQPtr[7] & 0xF0) >>
				  4) * 10 + (SubQPtr[7] & 0x0F);
	  (userPtr->AbsoluteAddress)[0] = 0;
	  (userPtr->AbsoluteAddress)[1] = SubQPtr[9];
	  (userPtr->AbsoluteAddress)[2] = SubQPtr[10];
	  (userPtr->AbsoluteAddress)[3] = SubQPtr[11];
	  (userPtr->TrackRelativeAddress)[0] = 0;
	  (userPtr->TrackRelativeAddress)[1] = SubQPtr[13];
	  (userPtr->TrackRelativeAddress)[2] = SubQPtr[14];
	  (userPtr->TrackRelativeAddress)[3] = SubQPtr[15];
	  (Irp->IoStatus).Information = sizeof(SUB_Q_CURRENT_POSITION );
	}
      else
	(Irp->IoStatus).Information = 0;
      ExFreePool(SubQPtr);      
      break;
    case 4 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0006 << 2 | 0 */:
      inputBuffer= (Irp->AssociatedIrp).SystemBuffer;
      (Irp->IoStatus).Information = 0;
      if(((currentIrpStack->Parameters).DeviceIoControl).InputBufferLength
	 < sizeof(CDROM_PLAY_AUDIO_MSF ))
	{
	  status = (NTSTATUS )0xC0000004L;
	  break;
	}
      if(inputBuffer->StartingM == inputBuffer->EndingM &&
	 inputBuffer->StartingS == inputBuffer->EndingS
	 && inputBuffer->StartingF == inputBuffer->EndingF)
	{
	  (cdb->PAUSE_RESUME).OperationCode = 0x4B;
	  (cdb->PAUSE_RESUME).Action = 0;
	}
      else
	{
	  (cdb->PLAY_AUDIO_MSF).OperationCode = 0x47;
	  (cdb->PLAY_AUDIO_MSF).StartingM = inputBuffer->StartingM;
	  (cdb->PLAY_AUDIO_MSF).StartingS =inputBuffer->StartingS;
	  (cdb->PLAY_AUDIO_MSF).StartingF =inputBuffer->StartingF;
	  (cdb->PLAY_AUDIO_MSF).EndingM = inputBuffer->EndingM;
	  (cdb->PLAY_AUDIO_MSF).EndingS = inputBuffer->EndingS;
	    (cdb->PLAY_AUDIO_MSF).EndingF = inputBuffer->EndingF;
	}
      srb.CdbLength = 10;
      srb.TimeOutValue = 10;
	status = SendSrbSynchronous(deviceExtension, & srb, (void *  )0, 0);
	if((NTSTATUS )status >= 0 &&
	   (cdb->PLAY_AUDIO_MSF).OperationCode == 0x47)
	    deviceExtension->PlayActive = 1;      
	break;
    case 5 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0001 << 2 | 0 */:
      inputBuffer = (Irp->AssociatedIrp).SystemBuffer;
      (Irp->IoStatus).Information = 0;
      if(((currentIrpStack->Parameters).DeviceIoControl).InputBufferLength
	 < sizeof(CDROM_SEEK_AUDIO_MSF ))
	{
	  status = (NTSTATUS )0xC0000004L;
	  break;
	}
      destblock = ((ULONG )inputBuffer->StartingM * 60 + 
		   (ULONG)inputBuffer->StartingS) * 75 + (ULONG )inputBuffer->StartingF -  150;
      srb.CdbLength = 10;
      srb.TimeOutValue = 10;
      (cdb->SEEK).OperationCode = 0x2B;
      ((cdb->SEEK).LogicalBlockAddress)[0] = (UCHAR)(destblock >> 24) & 0xFF;
      ((cdb->SEEK).LogicalBlockAddress)[1] = (UCHAR)(destblock >> 16) & 0xFF;
      ((cdb->SEEK).LogicalBlockAddress)[2] = (UCHAR)(destblock >> 8) & 0xFF;
      ((cdb->SEEK).LogicalBlockAddress)[3] = (UCHAR)(destblock & 0xFF);
      status = SendSrbSynchronous(deviceExtension, & srb,(void *  )0, 0);    
      break;
    case 6 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0202 << 2 | 0 */:
      (Irp->IoStatus).Information = 0;
      deviceExtension->PlayActive = 0;
      srb.CdbLength = 10;
      srb.TimeOutValue = 10;
      (cdb->CDB10).OperationCode = 0xC0;
      status = SendSrbSynchronous(deviceExtension, & srb, (void *  )0,0);
      break;
    case 7 /* 0x00000002 << 16 | 0x0001 << 14 | 0x000D << 2 | 0 */:
    case 8 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0005 << 2 | 0 */:
    case 9 /* 0x00000002 << 16 | 0x0001 << 14 | 0x000A << 2 | 0 */:
      (Irp->IoStatus).Information = 0;
      status = (NTSTATUS )0xC0000010L;
      break;
    case 10 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0200 << 2 | 0 */:
      CdAudioIsPlayActive(DeviceObject);
    default :
      return CdAudioSendToNextDriver(DeviceObject, Irp);
      break;
    }
 SetStatusAndReturn:
  {
    if(status == (NTSTATUS )0x80000016L)
      {
	IoSetHardErrorOrVerifyDevice(Irp,deviceExtension->TargetDeviceObject);
	(Irp->IoStatus).Information = 0;
      }
  }
  (Irp->IoStatus).Status = status;
  myStatus = status;
  IofCompleteRequest(Irp, 0);
  return status;
}

NTSTATUS CdAudio435DeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
  PIO_STACK_LOCATION currentIrpStack;
  PCD_DEVICE_EXTENSION deviceExtension;
  PCDROM_TOC cdaudioDataOut;
  SCSI_PASS_THROUGH srb ;
  PCDB cdb;
  NTSTATUS status ;
  ULONG i , bytesTransfered ;
  PUCHAR Toc ;
  int temp_1;
  ULONG tag_1;
  ULONG tracksToReturn ;
  ULONG tracksOnCd ;
  ULONG tracksInBuffer ;
  ULONG dataLength ;
  PCDROM_PLAY_AUDIO_MSF inputBuffer ;
  PSUB_Q_CURRENT_POSITION userPtr;
  PUCHAR SubQPtr;
  PUCHAR PausePos;
  PUCHAR EjectStatus;
  int NONDET;

  currentIrpStack = ((Irp->Tail).Overlay).CurrentStackLocation;
  deviceExtension = DeviceObject->DeviceExtension;
  cdaudioDataOut = (Irp->AssociatedIrp).SystemBuffer;
  cdb = (PCDB )srb.Cdb;

  memset(cdb, 0, 12);
  switch(NONDET /* ((currentIrpStack->Parameters).DeviceIoControl).IoControlCode */)
    {
    case 1 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0000 << 2 | 0 */:
      if(((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength
	 < (ULONG )((LONG )((LONG_PTR )(& (((CDROM_TOC * )0)->TrackData)[0]))))
	{
	  status = (NTSTATUS )0xC0000023L;
	  (Irp->IoStatus).Information = 0;
	  break;
	}
      temp_1 = CdAudioIsPlayActive(DeviceObject);
      if(temp_1)
	{
	  status = (NTSTATUS )0x80000011L;
	  (Irp->IoStatus).Information = 0;
	  break;
	}
      Toc = (PUCHAR )ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
					   sizeof(CDROM_TOC ),tag_1 /*' AdC'*/);
      if(Toc == (void *  )0)
	{
	  status = (NTSTATUS )0xC000009AL;
	  (Irp->IoStatus).Information = 0;
	  goto SetStatusAndReturn;
	}
      memset(Toc, 0, sizeof(CDROM_TOC ));
      (cdb->READ_TOC).OperationCode = 0x43;
      (cdb->READ_TOC).Msf = 1;
      ((cdb->READ_TOC).AllocationLength)[0] = sizeof(CDROM_TOC ) >> 8;
      ((cdb->READ_TOC).AllocationLength)[1] = sizeof(CDROM_TOC ) & 0xFF;
      srb.TimeOutValue = 10;
      srb.CdbLength = 10;
      status = SendSrbSynchronous(deviceExtension, & srb, Toc,
				  sizeof(CDROM_TOC ));
      if(! ((NTSTATUS )status >= 0) && status != (NTSTATUS)0xC000003CL)
	{
	  if(status != (NTSTATUS )0xC000003CL)
	    {
	      ExFreePool(Toc);
	      (Irp->IoStatus).Information = 0;
	      goto SetStatusAndReturn;
	    }
	}
      else
	  status = (NTSTATUS )0x00000000L;

      if(((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength
	 > sizeof(CDROM_TOC ))
	bytesTransfered =  sizeof(CDROM_TOC );
      else
	bytesTransfered = ((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength;

      (cdaudioDataOut->Length)[0] = Toc[0];
      (cdaudioDataOut->Length)[1] = Toc[1];
      cdaudioDataOut->FirstTrack = ((Toc[2] & 0xF0) >> 4) * 10 + (Toc[2] & 0x0F);
      cdaudioDataOut->LastTrack = ((Toc[3] & 0xF0) >> 4) * 10 + (Toc[3] & 0x0F);      
      tracksOnCd = cdaudioDataOut->LastTrack - cdaudioDataOut->FirstTrack + 1;
      tracksInBuffer = ((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength	  
	               - (ULONG )((LONG )((LONG_PTR )(& (((CDROM_TOC * )0)->TrackData)[0])));
      tracksInBuffer = tracksInBuffer / sizeof(TRACK_DATA );
      if(tracksInBuffer < tracksOnCd)
	tracksToReturn =tracksInBuffer;
      else
	tracksToReturn =tracksOnCd;

      for(i = 0; i < tracksToReturn; i++)
	{
	  ((cdaudioDataOut->TrackData)[i]).Reserved = 0;
	  ((cdaudioDataOut->TrackData)[i]).Control = Toc[i* 8 + 4 + 1];
	  ((cdaudioDataOut->TrackData)[i]).TrackNumber = ((Toc[i * 8 + 4 + 2] & 0xF0) >> 4) * 10	    
	                                                  + (Toc[i * 8 + 4 + 2] & 0x0F);
	  ((cdaudioDataOut->TrackData)[i]).Reserved1 = 0;
	  (((cdaudioDataOut->TrackData)[i]).Address)[0] =0;
	  (((cdaudioDataOut->TrackData)[i]).Address)[1] = Toc[i * 8 + 4 + 5];
	  (((cdaudioDataOut->TrackData)[i]).Address)[2] = Toc[i * 8 + 4 + 6];
	  (((cdaudioDataOut->TrackData)[i]).Address)[3] =  Toc[i * 8 + 4 + 7];
	}
      if(tracksInBuffer > tracksOnCd)
	{
	  ((cdaudioDataOut->TrackData)[i]).Reserved = 0;
	  ((cdaudioDataOut->TrackData)[i]).Control = Toc[i* 8 + 4 + 1];
	  ((cdaudioDataOut->TrackData)[i]).TrackNumber = Toc[i * 8 + 4 + 2];
	  ((cdaudioDataOut->TrackData)[i]).Reserved1 = 0;
	  (((cdaudioDataOut->TrackData)[i]).Address)[0] = 0;
	  (((cdaudioDataOut->TrackData)[i]).Address)[1] = Toc[i * 8 + 4 + 5];
	  (((cdaudioDataOut->TrackData)[i]).Address)[2] = Toc[i * 8 + 4 + 6];
	  (((cdaudioDataOut->TrackData)[i]).Address)[3] = Toc[i * 8 + 4 + 7];
	  i++;
	}
      (Irp->IoStatus).Information = (ULONG )((LONG )((LONG_PTR)(& (((CDROM_TOC *  )0)->TrackData)[i])));
      deviceExtension->Paused = 0;
      deviceExtension->PausedM = 0;
      deviceExtension->PausedS = 0;
      deviceExtension->PausedF = 0;
      deviceExtension->LastEndM = 0;
      deviceExtension->LastEndS = 0;
      deviceExtension->LastEndF = 0;
      ExFreePool(Toc);
      break;
    case 2 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0006 << 2 | 0 */:
    case 3 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0002 << 2 | 0 */:
	inputBuffer= (Irp->AssociatedIrp).SystemBuffer;
	(Irp->IoStatus).Information = 0;
	srb.CdbLength = 10;
	srb.TimeOutValue = 10;
	(cdb->CDB10).OperationCode = 0xC6;
	status = SendSrbSynchronous(deviceExtension, & srb,(void *  )0, 0);
	if((NTSTATUS )status >= 0)
	  {
	    deviceExtension->PlayActive = 0;
	    deviceExtension->Paused = 0;
	    deviceExtension->PausedM = 0;
	    deviceExtension->PausedS = 0;
	    deviceExtension->PausedF = 0;
	    deviceExtension->LastEndM = 0;
	    deviceExtension->LastEndS = 0;
	    deviceExtension->LastEndF = 0;
	  }
	if(((currentIrpStack->Parameters).DeviceIoControl).IoControlCode
	   == (0x00000002 << 16 | 0x0001 << 14 | 0x0002 <<  2 | 0))
	    goto SetStatusAndReturn;
	if(((currentIrpStack->Parameters).DeviceIoControl).InputBufferLength
	   < sizeof(CDROM_PLAY_AUDIO_MSF ))
	  {
	    status = (NTSTATUS )0xC0000004L;
	    break;
	  }
	srb.CdbLength = 10;
	srb.TimeOutValue = 10;
	(cdb->PLAY_AUDIO_MSF).OperationCode = 0x47;
	(cdb->PLAY_AUDIO_MSF).StartingM = inputBuffer->StartingM;
	(cdb->PLAY_AUDIO_MSF).StartingS = inputBuffer->StartingS;
	(cdb->PLAY_AUDIO_MSF).StartingF = inputBuffer->StartingF;
	(cdb->PLAY_AUDIO_MSF).EndingM = inputBuffer->EndingM;
	(cdb->PLAY_AUDIO_MSF).EndingS = inputBuffer->EndingS;
	(cdb->PLAY_AUDIO_MSF).EndingF = inputBuffer->EndingF;
	status = SendSrbSynchronous(deviceExtension, & srb,(void *  )0, 0);
	if((NTSTATUS )status >= 0)
	  {
	    deviceExtension->PlayActive = 1;
	    deviceExtension->Paused = 0;
	    deviceExtension->LastEndM = inputBuffer->EndingM;
	    deviceExtension->LastEndS = inputBuffer->EndingS;
	    deviceExtension->LastEndF = inputBuffer->EndingF;
	  }    
      break;
    case 4 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0001 << 2 | 0 */:
      inputBuffer = (Irp->AssociatedIrp).SystemBuffer;
      (Irp->IoStatus).Information = 0;
      if(((currentIrpStack->Parameters).DeviceIoControl).InputBufferLength
	 < sizeof(CDROM_SEEK_AUDIO_MSF ))
	{
	  status = (NTSTATUS )0xC0000004L;
	  break;
	}
      srb.CdbLength = 10;
      srb.TimeOutValue = 10;
      (cdb->CDB10).OperationCode = 0x47;
      (cdb->PLAY_AUDIO_MSF).StartingM = inputBuffer->StartingM;
      (cdb->PLAY_AUDIO_MSF).StartingS = inputBuffer->StartingS;
      (cdb->PLAY_AUDIO_MSF).StartingF = inputBuffer->StartingF;
      (cdb->PLAY_AUDIO_MSF).EndingM = inputBuffer->EndingM;
      (cdb->PLAY_AUDIO_MSF).EndingS = inputBuffer->EndingS;
      (cdb->PLAY_AUDIO_MSF).EndingF = inputBuffer->EndingF;
      status = SendSrbSynchronous(deviceExtension, & srb,(void *  )0, 0);
      if((NTSTATUS )status >= 0)
	{
	  deviceExtension->Paused = 1;
	  deviceExtension->PausedM = inputBuffer->StartingM;
	  deviceExtension->PausedS = inputBuffer->StartingS;
	  deviceExtension->PausedF = inputBuffer->StartingF;
	  deviceExtension->LastEndM = inputBuffer->EndingM;
	  deviceExtension->LastEndS = inputBuffer->EndingS;
	  deviceExtension->LastEndF = inputBuffer->EndingF;
	}
      else
	{
	  if(status == (NTSTATUS )0xC0000010L)
	    status = (NTSTATUS )0xC0000015L;
	}    
      break;
    case 5 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0003 << 2 | 0 */:
      SubQPtr= ExAllocatePoolWithTag(NonPagedPoolCacheAligned,	  
				     sizeof(SUB_Q_CHANNEL_DATA ),tag_1/*' AdC'*/);
      (Irp->IoStatus).Information = 0;
      if(SubQPtr == (void *  )0)
	{
	  status = (NTSTATUS )0xC000009AL;
	  goto SetStatusAndReturn;
	}
      if(deviceExtension->Paused == 1)
	{
	  ExFreePool(SubQPtr);
	  status = (NTSTATUS )0x00000000L;
	  goto SetStatusAndReturn;
	}
      srb.CdbLength = 10;
      srb.TimeOutValue = 10;
      (cdb->SUBCHANNEL).OperationCode = 0x42;
      (cdb->SUBCHANNEL).Msf = 1;
      (cdb->SUBCHANNEL).SubQ = 1;
      ((cdb->SUBCHANNEL).AllocationLength)[1] = sizeof(SUB_Q_CHANNEL_DATA );
      status = SendSrbSynchronous(deviceExtension, & srb,
				  SubQPtr, sizeof(SUB_Q_CHANNEL_DATA ));
      if(! ((NTSTATUS )status >= 0))
	{
	  ExFreePool(SubQPtr);
	  goto SetStatusAndReturn;
	}
      deviceExtension->PausedM = SubQPtr[9];
      deviceExtension->PausedS = SubQPtr[10];
      deviceExtension->PausedF = SubQPtr[11];
      memset(cdb, 0, 12);
      srb.CdbLength = 10;
      srb.TimeOutValue = 10;
      (cdb->CDB10).OperationCode = 0xC6;
      status = SendSrbSynchronous(deviceExtension, & srb, (void *  )0, 0);
      if(! ((NTSTATUS )status >= 0))
	{
	  ExFreePool(SubQPtr);
	  goto SetStatusAndReturn;
	}
      deviceExtension->PlayActive = 0;
      deviceExtension->Paused = 1;
      deviceExtension->PausedM = SubQPtr[9];
      deviceExtension->PausedS = SubQPtr[10];
      deviceExtension->PausedF = SubQPtr[11];
      ExFreePool(SubQPtr);    
      break;
    case 6 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0004 << 2 | 0 */:
      (Irp->IoStatus).Information = 0;
      if(deviceExtension->Paused == 0)
	{
	  status = (NTSTATUS )0xC0000001L;
	  goto SetStatusAndReturn;
	}
      srb.CdbLength = 10;
      srb.TimeOutValue = 10;
      (cdb->PLAY_AUDIO_MSF).OperationCode = 0x47;
      (cdb->PLAY_AUDIO_MSF).StartingM = deviceExtension->PausedM;
      (cdb->PLAY_AUDIO_MSF).StartingS = deviceExtension->PausedS;
      (cdb->PLAY_AUDIO_MSF).StartingF = deviceExtension->PausedF;
      (cdb->PLAY_AUDIO_MSF).EndingM = deviceExtension->LastEndM;
      (cdb->PLAY_AUDIO_MSF).EndingS = deviceExtension->LastEndS;
      (cdb->PLAY_AUDIO_MSF).EndingF = deviceExtension->LastEndF;
      status = SendSrbSynchronous(deviceExtension, & srb, (void *  )0,0);
      if((NTSTATUS )status >= 0)
	{
	  deviceExtension->PlayActive = 1;
	  deviceExtension->Paused = 0;
	}
      break;
    case 7 /* 0x00000002 << 16 | 0x0001 << 14 | 0x000B << 2 | 0 */:
      userPtr = (Irp->AssociatedIrp).SystemBuffer;
      SubQPtr = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,	  
				      sizeof(SUB_Q_CHANNEL_DATA ),tag_1 /*' AdC'*/);
      if(((currentIrpStack->Parameters).DeviceIoControl).OutputBufferLength
	 < sizeof(SUB_Q_CURRENT_POSITION ))
	{
	  status = (NTSTATUS )0xC0000023L;
	  (Irp->IoStatus).Information = 0;
	  if(SubQPtr)
	    ExFreePool(SubQPtr);
	  break;
	}
      if(SubQPtr == (void *  )0)
	{
	  memset(userPtr, 0, sizeof(SUB_Q_CURRENT_POSITION));
	  status = (NTSTATUS )0xC000009AL;
	  (Irp->IoStatus).Information = 0;
	  goto SetStatusAndReturn;
	}
      if(((PCDROM_SUB_Q_DATA_FORMAT )userPtr)->Format != 0x01)
	{
	  ExFreePool(SubQPtr);
	  memset(userPtr, 0, sizeof(SUB_Q_CURRENT_POSITION));
	  status = (NTSTATUS )0xC0000001L;
	  (Irp->IoStatus).Information = 0;
	  goto SetStatusAndReturn;
	}
      srb.CdbLength = 10;
      srb.TimeOutValue = 10;
      (cdb->SUBCHANNEL).OperationCode = 0x42;
      (cdb->SUBCHANNEL).Msf = 1;
      (cdb->SUBCHANNEL).SubQ = 1;
      ((cdb->SUBCHANNEL).AllocationLength)[1] = sizeof(SUB_Q_CHANNEL_DATA );
      status = SendSrbSynchronous(deviceExtension, & srb, SubQPtr, sizeof(SUB_Q_CHANNEL_DATA ));
      if((NTSTATUS )status >= 0)
	{
	  (userPtr->Header).Reserved = 0;
	  if(deviceExtension->Paused == 1)
	    {
	      deviceExtension->PlayActive = 0;
	      (userPtr->Header).AudioStatus = 0x12;
	    }
	  else
	    {
	      if(SubQPtr[1] == 0x11)
		{
		  deviceExtension->PlayActive = 1;
		  (userPtr->Header).AudioStatus =0x11;		  
		}
		else
		  {
		    deviceExtension->PlayActive = 0;
		    (userPtr->Header).AudioStatus = 0x13;
		  }
	      }
	  ((userPtr->Header).DataLength)[0] = 0;
	  ((userPtr->Header).DataLength)[1] = 12;
	  userPtr->FormatCode = 0x01;
	  userPtr->Control = SubQPtr[5];
	  userPtr->ADR = 0;
	  userPtr->TrackNumber = ((SubQPtr[6] & 0xF0) >> 4) * 10 + (SubQPtr[6] & 0x0F);
	  userPtr->IndexNumber = ((SubQPtr[7] & 0xF0) >>  4) * 10 + (SubQPtr[7] & 0x0F);
	  (userPtr->AbsoluteAddress)[0] = 0;
	  (userPtr->AbsoluteAddress)[1] = SubQPtr[9];
	  (userPtr->AbsoluteAddress)[2] = SubQPtr[10];
	  (userPtr->AbsoluteAddress)[3] = SubQPtr[11];
	  (userPtr->TrackRelativeAddress)[0] = 0;
	  (userPtr->TrackRelativeAddress)[1] = SubQPtr[13];
	  (userPtr->TrackRelativeAddress)[2] = SubQPtr[14];
	  (userPtr->TrackRelativeAddress)[3] =  SubQPtr[15];
	  (Irp->IoStatus).Information = sizeof(SUB_Q_CURRENT_POSITION );
	}
      else
	(Irp->IoStatus).Information = 0;
      ExFreePool(SubQPtr);      
      break;
    case 8 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0202 << 2 | 0 */:
      (Irp->IoStatus).Information = 0;
      srb.CdbLength = 10;
      srb.TimeOutValue = 10;
      (cdb->CDB10).OperationCode = 0xC0;
      status = SendSrbSynchronous(deviceExtension, & srb, (void *  )0,0);
      deviceExtension->Paused = 0;
      deviceExtension->PausedM = 0;
      deviceExtension->PausedS = 0;
      deviceExtension->PausedF = 0;
      deviceExtension->LastEndM = 0;
      deviceExtension->LastEndS = 0;
      deviceExtension->LastEndF = 0;
      break;
    case 9  /* 0x00000002 << 16 | 0x0001 << 14 | 0x000D << 2 | 0 */:
    case 10 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0005 << 2 | 0 */:
    case 11 /* 0x00000002 << 16 | 0x0001 << 14 | 0x000A << 2 | 0 */:
      (Irp->IoStatus).Information = 0;
      status = (NTSTATUS )0xC0000010L;
      break;
    case 12 /* 0x00000002 << 16 | 0x0001 << 14 | 0x0200 << 2 | 0 */:
      temp_1 = CdAudioIsPlayActive(DeviceObject);
      if(temp_1 == 1)
	{
	  deviceExtension->PlayActive = 1;
	  status = (NTSTATUS )0x00000000L;
	  (Irp->IoStatus).Information = 0;
	  goto SetStatusAndReturn;
	}
      else
	{
	  deviceExtension->PlayActive = 0;
	  return CdAudioSendToNextDriver(DeviceObject, Irp);
	}
      break;
    default :
      return CdAudioSendToNextDriver(DeviceObject, Irp);
      break;
    }
 SetStatusAndReturn:
  {
    if(status == (NTSTATUS )0x80000016L)
      {
	IoSetHardErrorOrVerifyDevice(Irp,
				     deviceExtension->TargetDeviceObject);
	(Irp->IoStatus).Information = 0;
      }
  }
  (Irp->IoStatus).Status = status;
  myStatus = status;
  IofCompleteRequest(Irp, 0);
  return status;
}

NTSTATUS CdAudioAtapiDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
  NTSTATUS status ;
  PCD_DEVICE_EXTENSION deviceExtension;
  PIO_STACK_LOCATION currentIrpStack;
  SCSI_PASS_THROUGH srb ;
  PHITACHICDB cdb;

  deviceExtension = DeviceObject->DeviceExtension;
  currentIrpStack = ((Irp->Tail).Overlay).CurrentStackLocation;
  cdb = (PHITACHICDB )srb.Cdb;


  if(((currentIrpStack->Parameters).DeviceIoControl).IoControlCode ==
     (0x00000002 << 16 | 0x0001 << 14 | 0x0002 << 2 | 0))
    {
      (Irp->IoStatus).Information = 0;
      deviceExtension->PlayActive = 0;
      memset(& srb, 0, sizeof(SCSI_PASS_THROUGH ));
      (cdb->STOP_PLAY).OperationCode = 0x4E;
      srb.CdbLength = 12;
      srb.TimeOutValue = 10;
      status = SendSrbSynchronous(deviceExtension, & srb, (void *  )0,0);
      if(! ((NTSTATUS )status >= 0))
	{
	  (Irp->IoStatus).Status = status;
	  myStatus = status;
	  IofCompleteRequest(Irp, 0);
	  return status;
	}
    }
  else
      return CdAudioSendToNextDriver(DeviceObject, Irp);

  (Irp->IoStatus).Status = status;
  myStatus = status;
  IofCompleteRequest(Irp, 0);
  return status;
}


void HpCdrProcessLastSession(PCDROM_TOC Toc )
{
  ULONG index ;
  PUCHAR cp ;
  
  index = Toc->FirstTrack;
  if(index)
    {
      index--;
      Toc->FirstTrack = ((Toc->TrackData)[0]).Reserved;
      Toc->LastTrack = ((Toc->TrackData)[index]).Reserved;
      (Toc->TrackData)[0] = (Toc->TrackData)[index];
    }
  else{
    Toc->FirstTrack = 0; 
    Toc->LastTrack = 0;
  }
  
  //BLAST for(cp = (PUCHAR )Toc, index = 0; index < 12; index++, cp++)
  // { }
}


NTSTATUS HPCdrCompletion(PDEVICE_OBJECT DeviceObject , PIRP Irp , PVOID Context)
{
  //Context;
  //DeviceObject;

  if(myIrpPendingReturned /*Irp->PendingReturned*/)
    {
      // TRACER
      // _ABORT(pended != 0);      
      if(pended == 0) 
	pended = 1; 

      // BLAST
/*       if(pended == 0) */
/* 	pended = 1; */
/*       else */
/* 	errorFn(); */

      (((Irp->Tail).Overlay).CurrentStackLocation)->Control = 
	(((Irp->Tail).Overlay).CurrentStackLocation)->Control | 0x01;
    }

  if((NTSTATUS )myStatus >= 0)
    HpCdrProcessLastSession((PCDROM_TOC)(Irp->AssociatedIrp).SystemBuffer);
  return myStatus;
}

NTSTATUS CdAudioHPCdrDeviceControl(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
  PIO_STACK_LOCATION currentIrpStack;
  PIO_STACK_LOCATION nextIrpStack;
  PCD_DEVICE_EXTENSION deviceExtension;
  PIO_STACK_LOCATION irpSp ;
  PIO_STACK_LOCATION nextIrpSp ;

  currentIrpStack = ((Irp->Tail).Overlay).CurrentStackLocation;
  nextIrpStack  = ((Irp->Tail).Overlay).CurrentStackLocation - 1;
  deviceExtension = DeviceObject->DeviceExtension;


  if(((currentIrpStack->Parameters).DeviceIoControl).IoControlCode ==
     (0x00000002 << 16 | 0x0001 << 14 | 0x000E << 2 | 0))
    {
      irpSp = ((Irp->Tail).Overlay).CurrentStackLocation;
      nextIrpSp = ((Irp->Tail).Overlay).CurrentStackLocation - 1;
      memcpy(nextIrpSp, irpSp, (LONG )((LONG_PTR )(& ((IO_STACK_LOCATION * )0)->CompletionRoutine)));
      nextIrpSp->Control = 0;

      // TRACER
      // _ABORT(s != NP);
      // _ABORT(compRegistered != 0);
      compRegistered = 1;
      routine = 0;
      // TRACER compFptr = HPCdrCompletion;

      // BLAST
/*       if(s != NP) */
/* 	errorFn(); */
/*       else */
/* 	{ */
/* 	  if(compRegistered != 0) */
/* 	    errorFn(); */
/* 	  else */
/* 	    { */
/* 	      compRegistered = 1; */
/* 	      routine = 0; */
/* 	      compFptr = HPCdrCompletion; */
/* 	    } */
/* 	} */

      irpSp = ((Irp->Tail).Overlay).CurrentStackLocation - 1;
      // TRACER irpSp->CompletionRoutine = HPCdrCompletion;
      irpSp->Context = deviceExtension;
      irpSp->Control = 0;
      if(1)
	  irpSp->Control = 0x40;
      if(1)
	  irpSp->Control = irpSp->Control | 0x80;
      if(1)
	  irpSp->Control = irpSp->Control | 0x20;
      return IofCallDriver(deviceExtension->TargetDeviceObject, Irp);
    }
  else
    return CdAudioSendToNextDriver(DeviceObject, Irp);
  return (NTSTATUS )0xC0000001L;
}

NTSTATUS CdAudioForwardIrpSynchronous(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
  PCD_DEVICE_EXTENSION deviceExtension ;
  KEVENT event ;
  NTSTATUS status ;
  PIO_STACK_LOCATION irpSp ;
  PIO_STACK_LOCATION nextIrpSp ;
  
  KeInitializeEvent(& event, NotificationEvent, 0);
  deviceExtension = (PCD_DEVICE_EXTENSION )DeviceObject->DeviceExtension;
  irpSp = ((Irp->Tail).Overlay).CurrentStackLocation;
  nextIrpSp = ((Irp->Tail).Overlay).CurrentStackLocation - 1;
  memcpy(nextIrpSp, irpSp, (LONG )((LONG_PTR )(&((IO_STACK_LOCATION *  )0)->CompletionRoutine)));
  nextIrpSp->Control = 0;
  
  // TRACER
  // _ABORT(s != NP);
  // _ABORT(compRegistered != 0);
  compRegistered = 1;
  routine = 1;
  compFptr = CdAudioSignalCompletion;
  
  // BLAST
/*   if(s != NP) */
/*     errorFn(); */
/*   else */
/*     { */
/*       if(compRegistered != 0) */
/* 	errorFn(); */
/*       else */
/* 	{ */
/* 	  compRegistered = 1; */
/* 	  routine = 1; */
/* 	  compFptr = CdAudioSignalCompletion; */
/* 	} */
/*     } */
  irpSp = ((Irp->Tail).Overlay).CurrentStackLocation - 1;
  irpSp->CompletionRoutine = CdAudioSignalCompletion;
  irpSp->Context = & event;
  irpSp->Control = 0;
  if(1)
      irpSp->Control = 0x40;
  if(1)
      irpSp->Control = irpSp->Control | 0x80;
  if(1)
    irpSp->Control = irpSp->Control | 0x20;
  status = IofCallDriver(deviceExtension->TargetDeviceObject, Irp);
  if(status == (NTSTATUS )0x00000103L)
    {
      KeWaitForSingleObject(& event, Executive, KernelMode, 0,
			    (void *  )0);
      status = (Irp->IoStatus).Status;
      status = myStatus;
    }
  return status;
}

void CdAudioUnload(PDRIVER_OBJECT DriverObject )
{
  return;
}

NTSTATUS CdAudioPower(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
  PCD_DEVICE_EXTENSION deviceExtension ;

  PoStartNextPowerIrp(Irp);

  // TRACER
  // _ABORT(s != NP);
  s = SKIP1;   
  
  // BLAST
/*   if(s == NP) */
/*     s = SKIP1; */
/*   else */
/*     errorFn(); */

  Irp->CurrentLocation++;
  ((Irp->Tail).Overlay).CurrentStackLocation++;
  deviceExtension = (PCD_DEVICE_EXTENSION )DeviceObject->DeviceExtension;
  return PoCallDriver(deviceExtension->TargetDeviceObject, Irp);
}

IRP *  pirp ;

void stub_driver_init()
{
  s = NP;
  pended = 0;
  compFptr = (PIO_COMPLETION_ROUTINE) 0;
  compRegistered = 0;
  lowerDriverReturn = 0;  
  setEventCalled = 0;
  customIrp = 0;

  return;
}

int main()
{
  DRIVER_OBJECT d ;
  UNICODE_STRING u ;
  NTSTATUS status ;
  IRP irp;       //rupak test
  int we_should_unload ;
  int BLAST_NONDET ;
  int idx ;
  int irp_choice ;
  DEVICE_OBJECT devobj ;
  
  pirp = &irp;   //rupak test

  _BLAST_init();
  //	status = DriverEntry(& d, & u);
  
  if((NTSTATUS )status >= 0)
    {
      /*
	s = NP;
	pended = 0;
	compFptr = 0;
	compRegistered = 0;
	lowerDriverReturn = 0;      
	setEventCalled = 0;
	customIrp = 0;
      */

      stub_driver_init();

      (pirp->IoStatus).Status = (NTSTATUS )0x00000000L;
      myStatus = (NTSTATUS )0x00000000L;
      if(irp_choice == 0)
	{
	  (pirp->IoStatus).Status = (NTSTATUS )0xC00000BBL;
	  myStatus = (NTSTATUS )0xC00000BBL;
	}

      status = CdAudioAddDevice(& d, & devobj);

      stub_driver_init();

      if(! ((NTSTATUS )status >= 0))
	return - 1;
      switch(BLAST_NONDET)
	{
	case 2:
	  status = CdAudioDeviceControl(& devobj, pirp);
	  break;
	case 3:
	  status = CdAudioPnp(& devobj, pirp);
	  break;
	case 4:
	  status = CdAudioPower(& devobj, pirp);
	  break;
	default :
	  return - 1;
	}

      if(we_should_unload)
	  CdAudioUnload(& d);
    }
  if(pended == 1 && s == NP)
    s = NP;
  else
    {
      if(pended == 1 && s == MPR3)
	  s = MPR3;
      else
	{
	  if(s == UNLOADED || status == - 1){}
	  else
	    {

	      // TRACER
	      // _ABORT(s != SKIP2 && s != IPC && s != DC);
	      if(pended == 1){
		// _ABORT(status != 259);
	      }
	      else{
	      	if(s == DC){
	      	  // _ABORT(status == 259);
		}
	      	else{
	          // _ABORT(status != lowerDriverReturn);		
		}
	      }
	      
	      // BLAST 
/* 	      if(s != SKIP2 && s != IPC && s != DC) */
/* 		errorFn(); */
/* 	      else */
/* 		{ */
/* 		  if(pended == 1) */
/* 		    { */
/* 		      if(status != 259) */
/* 			errorFn(); */
/* 		    } */
/* 		  else */
/* 		    { */
/* 		      if(s == DC) */
/* 			{ */
/* 			  if(status == 259) */
/* 			    errorFn(); */
/* 			} */
/* 		      else */
/* 			{ */
/* 			  if(status != lowerDriverReturn) */
/* 			    errorFn(); */
/* 			} */
/* 		    } */
/* 		} */
	    }
	}
    }  
  return status;
  //_SLICE(status);
  _SLICE(status,s, NP, pended, UNLOADED , DC , SKIP1 , SKIP2 , MPR1 , MPR3 , IPC /*,xxxx_*/);

}

// char _SLAM_alloc_dummy ;

char *  nondet_malloc(int i )
{
  int BLAST_NONDET ;
  if(BLAST_NONDET)
    {
      return (char *  )0;
    }
  else
    return (char *  )malloc(i);
}

  void ExAcquireFastMutex(PFAST_MUTEX FastMutex )
{
  return;
}

  void ExReleaseFastMutex(PFAST_MUTEX FastMutex )
{
  return;
}

PVOID   ExAllocatePoolWithTag(POOL_TYPE PoolType ,
			      SIZE_T NumberOfBytes , ULONG Tag )
{
  PVOID x ;
  x = nondet_malloc(NumberOfBytes);
  return x;
}

void   ExFreePool(PVOID P )
{
  return;
}

PLIST_ENTRY ExfInterlockedInsertHeadList(PLIST_ENTRY ListHead ,
					 PLIST_ENTRY ListEntry , PKSPIN_LOCK Lock )
{
  return (void *  )0;
}

PLIST_ENTRY ExfInterlockedInsertTailList(PLIST_ENTRY ListHead ,
					 PLIST_ENTRY ListEntry , PKSPIN_LOCK Lock )
{
  return (void *  )0;
}

PLIST_ENTRY ExfInterlockedRemoveHeadList(PLIST_ENTRY ListHead ,
					 PKSPIN_LOCK Lock )
{
  return (void *  )0;
}

PMDL IoAllocateMdl(PVOID VirtualAddress , ULONG Length ,
		   BOOLEAN SecondaryBuffer , BOOLEAN ChargeQuota , PIRP Irp )
{
  int BLAST_NONDET ;
  switch(BLAST_NONDET)
    {
    case 0:
      return (void *  )nondet_malloc(sizeof(MDL ));
    default :
      return (void *  )0;
    }
}

PDEVICE_OBJECT IoAttachDeviceToDeviceStack(PDEVICE_OBJECT SourceDevice ,
					   PDEVICE_OBJECT TargetDevice )
{
  int BLAST_NONDET ;
  switch(BLAST_NONDET)
    {
    case 0:
      return TargetDevice;
    default :
      return (void *  )0;
    }
}

PIRP IoBuildAsynchronousFsdRequest(ULONG MajorFunction ,
				   PDEVICE_OBJECT DeviceObject , 
				   PVOID Buffer , ULONG Length ,
				   PLARGE_INTEGER StartingOffset , 
				   PIO_STATUS_BLOCK IoStatusBlock )
{
  int BLAST_NONDET ;
  customIrp = 1;
  switch(BLAST_NONDET)
    {
    case 0:
      return (void *  )malloc(sizeof(IRP ));
    default :
      return (void *  )0;
    }
}

PIRP IoBuildDeviceIoControlRequest(ULONG IoControlCode ,
				   PDEVICE_OBJECT DeviceObject , PVOID InputBuffer , 
				   ULONG InputBufferLength ,
				   PVOID OutputBuffer , ULONG OutputBufferLength ,
				   BOOLEAN InternalDeviceIoControl , PKEVENT Event , 
				   PIO_STATUS_BLOCK IoStatusBlock )
				     
{
  int BLAST_NONDET ;
  customIrp = 1;
  switch(BLAST_NONDET)
    {
    case 0:
      return (void *  )malloc(sizeof(IRP ));
    default :
      return (void *  )0;
    }
}

NTSTATUS IoCreateDevice(PDRIVER_OBJECT DriverObject ,
			ULONG DeviceExtensionSize , PUNICODE_STRING DeviceName , 
			ULONG DeviceType ,
			ULONG DeviceCharacteristics , BOOLEAN Exclusive ,
			PDEVICE_OBJECT *  DeviceObject )
{
  int BLAST_NONDET ;
  switch(BLAST_NONDET)
    {
    case 0:
      * DeviceObject = (void *  )malloc(sizeof(DEVICE_OBJECT ));
      return (NTSTATUS )0x00000000L;
    default :
      return (NTSTATUS )0xC0000001L;
    }
}

NTSTATUS IoCreateSymbolicLink(PUNICODE_STRING SymbolicLinkName ,
			      PUNICODE_STRING DeviceName )
{
  int BLAST_NONDET ;
  switch(BLAST_NONDET)
    {
    case 0:
      return (NTSTATUS )0x00000000L;
    default :
      return (NTSTATUS )0xC0000001L;
    }
}

void IoDeleteDevice(PDEVICE_OBJECT DeviceObject ) { return;  }

NTSTATUS IoDeleteSymbolicLink(PUNICODE_STRING SymbolicLinkName )
{
  int BLAST_NONDET ;
  switch(BLAST_NONDET)
    {
    case 0:
      return (NTSTATUS )0x00000000L;
    default :
      return (NTSTATUS )0xC0000001L;
    }
}

void IoDetachDevice(PDEVICE_OBJECT TargetDevice )
{ return;}

void IoFreeIrp(PIRP Irp ){ return; }

void IoFreeMdl(PMDL Mdl ){ return; }

PCONFIGURATION_INFORMATION IoGetConfigurationInformation(void  )  
{
  return (void *  )nondet_malloc(sizeof(CONFIGURATION_INFORMATION ));
}

NTSTATUS IoQueryDeviceDescription(PINTERFACE_TYPE BusType,
				  PULONG BusNumber , PCONFIGURATION_TYPE ControllerType , 
				  PULONG ControllerNumber ,
				  PCONFIGURATION_TYPE PeripheralType , 
				  PULONG PeripheralNumber , PIO_QUERY_DEVICE_ROUTINE CalloutRoutine , 
				  PVOID Context )
{
  int BLAST_NONDET ;
  switch(BLAST_NONDET)
    {
    case 0:
      return (NTSTATUS )0x00000000L;
    default :
      return (NTSTATUS )0xC0000001L;
    }
}

NTSTATUS  IoRegisterDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject ,  
				    GUID *  InterfaceClassGuid , PUNICODE_STRING ReferenceString ,
				    PUNICODE_STRING SymbolicLinkName )
{
  int BLAST_NONDET ;
  switch(BLAST_NONDET)
    {
    case 0:
      return (NTSTATUS )0x00000000L;
    default :
      return (NTSTATUS )0xC0000010L;
    }
}

void IoReleaseCancelSpinLock(KIRQL Irql )  { return ;}
NTSTATUS IoSetDeviceInterfaceState(PUNICODE_STRING SymbolicLinkName , BOOLEAN Enable )
{
  int BLAST_NONDET ;
  switch(BLAST_NONDET)
    {
    case 0:
      return (NTSTATUS )0x00000000L;
    default :
      return (NTSTATUS )0xC0000001L;
	}
}

void IoSetHardErrorOrVerifyDevice(PIRP Irp ,
				  PDEVICE_OBJECT DeviceObject ){ return;}
void stubMoreProcessingRequired()
{
  // TRACER
  // _ABORT(s != NP);
  s = MPR1;

  // BLAST 
/*   if(s == NP) */
/*     s = MPR1; */
/*   else */
/*     errorFn(); */
}

NTSTATUS IofCallDriver(PDEVICE_OBJECT DeviceObject , PIRP Irp )
{
  int BLAST_NONDET ;
  NTSTATUS returnVal2 ;
  int compRetStatus ;
  PVOID lcontext ;
  if(compRegistered)
    {
      /*
	compRetStatus = (* compFptr)(DeviceObject, Irp, lcontext);
      */
      if(routine==0)
	compRetStatus = HPCdrCompletion(DeviceObject, Irp, lcontext);
      else {
	if(routine==1) 
	  compRetStatus = CdAudioSignalCompletion(DeviceObject, Irp, lcontext);	
      }

      if(compRetStatus == (NTSTATUS )0xC0000016L)
	stubMoreProcessingRequired();
    }
  if(myIrpPendingReturned /*Irp->PendingReturned*/) {
    returnVal2 = (NTSTATUS)259;
  } 
  else {
    switch(BLAST_NONDET)
      {
      case 0:
	returnVal2 = (NTSTATUS )0x00000000L;
	break;
      case 1:
	returnVal2 = (NTSTATUS )0xC0000001L;
	break;
      default :
	returnVal2 = (NTSTATUS )0x00000103L;
	break;
      }
  }

  if(s == NP)
    {
      s = IPC;
      lowerDriverReturn = returnVal2;
    }
  else
    {
      if(s == MPR1)
	{
	  if(returnVal2 == 259)
	    {
	      s = MPR3;
	      lowerDriverReturn = returnVal2;
	    }
	  else
	    {
	      s = NP;
	      lowerDriverReturn = returnVal2;
	    }
	}
      else
	{
	  // TRACER 
	  // _ABORT(s != SKIP1);
	  s = SKIP2;
	  lowerDriverReturn = returnVal2;
	  
	  // BLAST 
/* 	  if(s == SKIP1) */
/* 	    { */
/* 	      s = SKIP2; */
/* 	      lowerDriverReturn = returnVal2; */
/* 	    } */
/* 	  else */
/* 	    errorFn(); */
	}
    }

  return returnVal2;
}

void IofCompleteRequest(PIRP Irp , CCHAR PriorityBoost )
{
  // TRACER
  // _ABORT(s != NP);
  s = DC;

  // BLAST
/*   if (s == NP) */
/*     s = DC; */
/*   else */
/*     errorFn(); */
}

KIRQL KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK SpinLock ) { return; }

NTSTATUS KeDelayExecutionThread(KPROCESSOR_MODE WaitMode ,
				BOOLEAN Alertable , PLARGE_INTEGER Interval )
{
  int BLAST_NONDET ;
  switch(BLAST_NONDET)
    {
    case 0:
      return (NTSTATUS )0x00000000L;
    default :
      return (NTSTATUS )0xC0000001L;
    }
}

void KeInitializeEvent(PRKEVENT Event , EVENT_TYPE Type ,
	BOOLEAN State ) { return ;}

void KeInitializeSemaphore(PRKSEMAPHORE Semaphore , 
			   LONG Count , LONG Limit ) {}
void   KeInitializeSpinLock(PKSPIN_LOCK SpinLock ){}

LONG KeReleaseSemaphore(PRKSEMAPHORE Semaphore , KPRIORITY Increment ,
			LONG Adjustment , BOOLEAN Wait )
{
  LONG r ;
  return r;
}

void KfReleaseSpinLock(PKSPIN_LOCK SpinLock , KIRQL NewIrql )
{ }

LONG KeSetEvent(PRKEVENT Event , KPRIORITY Increment ,
		BOOLEAN Wait )
{
  LONG l ;
  setEventCalled = 1;
  return l;
}

NTSTATUS KeWaitForSingleObject(PVOID Object , KWAIT_REASON WaitReason ,
			       KPROCESSOR_MODE WaitMode , BOOLEAN Alertable ,
			       PLARGE_INTEGER Timeout )
{
  int BLAST_NONDET ;

  if(s == MPR3 && setEventCalled == 1)
    {
      s = NP;
      setEventCalled = 0;
    }
  else
    {
      if(customIrp == 1)
	{
	  s = NP;
	  customIrp = 0;
	}
      else
	{
	  // TRACER 
	  // _ABORT(s == MPR3);

	  // BLAST
/* 	  if(s == MPR3) */
/* 	    errorFn(); */
	}
    }
  switch(BLAST_NONDET)
    {
    case 0:
      return (NTSTATUS )0x00000000L;
    default :
      return (NTSTATUS )0xC0000001L;
    }
}

PVOID MmAllocateContiguousMemory(SIZE_T NumberOfBytes ,
				 PHYSICAL_ADDRESS HighestAcceptableAddress )
{
  int BLAST_NONDET ;
  switch(BLAST_NONDET)
    {
    case 0:
      return malloc(NumberOfBytes);
    case 1:
      return (void *  )0;
    }
}

void MmFreeContiguousMemory(PVOID BaseAddress ){ }

PVOID MmMapLockedPagesSpecifyCache(PMDL MemoryDescriptorList ,
				   KPROCESSOR_MODE AccessMode , MEMORY_CACHING_TYPE CacheType ,
				   PVOID BaseAddress , ULONG BugCheckOnFailure ,
				   MM_PAGE_PRIORITY Priority )
{
  return (void *  )0;
}

PVOID MmPageEntireDriver(PVOID AddressWithinSection )
{
  return (void *  )0;
}

void MmResetDriverPaging(PVOID AddressWithinSection ) { }

void MmUnlockPages(PMDL MemoryDescriptorList ) { }

NTSTATUS ObReferenceObjectByHandle(HANDLE Handle ,
				   ACCESS_MASK DesiredAccess , POBJECT_TYPE ObjectType , 
				   KPROCESSOR_MODE AccessMode , PVOID *  Object , 
				   POBJECT_HANDLE_INFORMATION HandleInformation )
{
  int BLAST_NONDET ;
  switch(BLAST_NONDET)
    {
    case 0:
      return (NTSTATUS )0x00000000L;
    default :
      return (NTSTATUS )0xC0000001L;
    }
}

void ObfDereferenceObject(PVOID Object ) { }

// #line 939
NTSTATUS PoCallDriver(PDEVICE_OBJECT DeviceObject , PIRP Irp )
	
{
  int BLAST_NONDET ;
  int compRetStatus ;
  NTSTATUS returnVal ;
  PVOID lcontext ;
  
  if(compRegistered)
    {
      /*
	compRetStatus = (* compFptr)(DeviceObject, Irp, lcontext);
      */
      if(routine==0)
	compRetStatus = HPCdrCompletion(DeviceObject, Irp, lcontext);
      else {
	if(routine==1) 
	  compRetStatus = CdAudioSignalCompletion(DeviceObject, Irp, lcontext);
      }
      
      if(compRetStatus == (NTSTATUS )0xC0000016L)
	stubMoreProcessingRequired();
    }

  switch(BLAST_NONDET)
	{
	case 0:
	  returnVal = (NTSTATUS )0x00000000L;
	  break;
	case 1:
	  returnVal = (NTSTATUS )0xC0000001L;
	  break;
	default :
	  returnVal = (NTSTATUS )0x00000103L;
	  break;
	}
  if(s == NP)
    {
      s = IPC;
      lowerDriverReturn = returnVal;
    }
  else
    {
      if(s == MPR1)
	{
	  if(returnVal == (NTSTATUS )0x00000103L)
	    {
	      s = MPR3;
	      lowerDriverReturn = returnVal;
	    }
	  else
	    {
	      s = NP;
	      lowerDriverReturn = returnVal;
	    }
	}
      else
	{
	  // TRACER 
	  // _ABORT(s != SKIP1);
	  s = SKIP2;
	  lowerDriverReturn = returnVal;

	  // BLAST 
/* 	  if(s == SKIP1) */
/* 	    { */
/* 	      s = SKIP2; */
/* 	      lowerDriverReturn = returnVal; */
/* 	    } */
/* 	  else */
/* 	    errorFn(); */
	}
    }
  return returnVal;
}

void PoStartNextPowerIrp(PIRP Irp ) { }

NTSTATUS PsCreateSystemThread(PHANDLE ThreadHandle , ULONG DesiredAccess ,
			      POBJECT_ATTRIBUTES ObjectAttributes , HANDLE ProcessHandle ,
			      PCLIENT_ID ClientId , PKSTART_ROUTINE StartRoutine ,
			      PVOID StartContext )
{
  int BLAST_NONDET ;
  switch(BLAST_NONDET)
    {
    case 0:
      return (NTSTATUS )0x00000000L;
    default :
      return (NTSTATUS )0xC0000001L;
    }
}

NTSTATUS PsTerminateSystemThread(NTSTATUS ExitStatus )
{
  int BLAST_NONDET ;
  switch(BLAST_NONDET)
    {
    case 0:
      return (NTSTATUS )0x00000000L;
    default :
      return (NTSTATUS )0xC0000001L;
    }
}

NTSTATUS RtlAnsiStringToUnicodeString(PUNICODE_STRING DestinationString ,  
				      PANSI_STRING SourceString , BOOLEAN AllocateDestinationString )
{
  int BLAST_NONDET ;
  switch(BLAST_NONDET)
    {
    case 0:
      return (NTSTATUS )0x00000000L;
    default :
      return (NTSTATUS )0xC0000001L;
    }
}

SIZE_T   RtlCompareMemory(  void *  Source1 ,
			    void *  Source2 , SIZE_T Length )
{
  SIZE_T r ;
  return r;
}

void   RtlCopyUnicodeString(PUNICODE_STRING DestinationString ,
			    PUNICODE_STRING SourceString ) { }

NTSTATUS   RtlDeleteRegistryValue(ULONG RelativeTo,
				  PCWSTR Path , PCWSTR ValueName )
{
  int BLAST_NONDET ;
  switch(BLAST_NONDET)
    {
    case 0:
      return (NTSTATUS )0x00000000L;
    default :
      return (NTSTATUS )0xC0000001L;
    }
}

void   RtlFreeUnicodeString(PUNICODE_STRING UnicodeString ){ }			   
void   RtlInitString(PSTRING DestinationString , PCSZ SourceString ){}
void   RtlInitUnicodeString(PUNICODE_STRING DestinationString ,
			    PCWSTR SourceString ){}

NTSTATUS RtlQueryRegistryValues(ULONG RelativeTo,
				PCWSTR Path , 
				PRTL_QUERY_REGISTRY_TABLE QueryTable , 
				PVOID Context ,
				PVOID Environment )
{
  int BLAST_NONDET ;
  switch(BLAST_NONDET)
    {
    case 0:
      return (NTSTATUS )0x00000000L;
    default :
      return (NTSTATUS )0xC0000001L;
    }
}

NTSTATUS   ZwClose(HANDLE Handle )
{
  int BLAST_NONDET ;
  switch(BLAST_NONDET)
    {
    case 0:
      return (NTSTATUS )0x00000000L;
    default :
      return (NTSTATUS )0xC0000001L;
    }
}

NTSTATUS   RtlWriteRegistryValue(ULONG RelativeTo, PCWSTR Path , PCWSTR ValueName ,
				 ULONG ValueType , PVOID ValueData ,
				 ULONG ValueLength ){ 
  NTSTATUS r; 
  return r; 
}

PVOID MmLockPagableDataSection(PVOID AddressWithinSection){}
LONG InterlockedIncrement(PLONG Addend ){ LONG r; return r;}
LONG InterlockedDecrement(PLONG Addend ){ LONG r; return r; }

	

% tracer_safety_minmax.clp.gpp

%===========================================================================%
% This file implements the algorithm described in the paper "Unbounded
% Symbolic Execution for Program Verification" (RV'11) to prove safety
% in programs with unbounded loops.
%===========================================================================%
% export
%  mm_cleanup/0
%  mm_bound_reached/11
%  mm_success_path/17
%  mm_check_error_path/16
%  mm_subsumed/17
%  mm_unfold_combine/19
%  mm_unfold_inlined_function_return/22
%  mm_create_subsumed_interpolant/12
%  mm_unfold_loop/23
%  mm_unfold_abstract/27
%  mm_unfold_trans/21
%  is_ancestor_pp/2
%  For stats
%  init_minimax_counters/0
%  print_mm_subsumption_stats/4
%===========================================================================%
% Whenever a loop is encountered loop invariants are discovered on the
% fly as follows:
%
% 1) Whenever we encounter a loop header, we enumerate a set of
% candidates S which we consider invariants as long as the opposite is
% proved.
%
% 2) We propagate those candidates through all loop paths
%
% 3) At each looping point (source of backedge) we test if every
% candidate is invariant. If not, we delete it from S.
%
% Therefore, it's a kind of a glb (greatest lower bound) computation
% where we start assuming everyone is invariant and then the final set
% of invariants is the conjunction from the result of each loop
% path. Note that we may clearly miss some invariants that by
% computing a fixpoint we could catch. However, it is more efficient
% since it doesn't require several fixpoint iterations.
%
% After that, if a real error is found, then it reports unsafe and it
% halts. If the safety condition can be proved then it reports safe
% and it stops. Otherwise, a refinement 'a la' CEGAR is
% executed. During this refinement, interpolation is used to find out
% which abstracted constraints, I, are needed to rule out the spurious
% counterexample. After that, the constraints belonging to I cannot
% further abstracted, and the process restarts. This impossibility of
% abstracting again I forces loop unrolling.
%
% Notice this algorithm is more powerful that the algorithm used
% tracer_safety.clp.gpp since it reports false alarms only if the
% solver fails to prove a claim but it may not terminate if a safe
% inductive invariant cannot be discovered.
%
% For historical reasons, we call this algorithm "minmax". The
% constraints computed from interpolation during subsumption of nodes
% and for excluding spurious counterexamples are called "max"
% constraints. On the other hand, constraints abstracted in order to
% get loop invariants are called "min" constraints. Then, the
% algorithm tries to reach an agreement between max's and min's while
% building a finite symbolic execution tree from which error nodes are
% unreachable.  A min/max disagreement can happen when a constraint
% must be abstracted (min) for producing a loop invariant but at the
% same time it's needed for excluding an spurious counterexample
% (max). In that case, we fail to produce a loop invariant and hence,
% we must unroll the corresponding loop at least one level until we
% try again.
%
% Current implementation enhances the algorithm described in RV'11 at
% least in the following ways:
%
% 1) use of weakest preconditions as interpolants
%
% 2) loop invariants from abstract interpretation or other means can
% be used but with some important limitations. The use of these
% external inductive invariants makes sense only for the original
% version of the loop (ie. without unrolling). Thus, if we need to
% refine we shoudn't use those invariants as invariants for the
% unrolled versions of the loop. Otherwise, we may cause
% non-termination unnecessarily.
%
% FIXME: some parts of the algorithm that handles loops are still very
% naive. The algorithm basically enumerates loop invariant candidates
% and then, it tests the invariance of them. First, the test checks
% simply if c' implies c then returns c otherwise top, where c' is the
% constraint c after the execution of the loop path. Second, we only
% test whether a constraint is individually invariant. This precludes
% us for discovering invariants that involve more than one
% constraint. Third, we just consider candidates generated by
% propagation of symbolic execution. Although, this is mitigated by
% considering inductive invariants if -loop-inv option is on. However,
% we may discard them if they don't pass our individually invariant
% test.
%
% FIXME/TODO: [IMPORTANT!] we still use a hybrid method that combines
% wp's and sp's (projected unsat cores). That is, even if user chooses
% to use wp's we don't compute wp's always. In particular, the
% refinement does not use wp's. Neither, subsumption between program
% points that belong to different copies of the same loop. The reason
% is that it would imply quite deep structural changes in the
% implementation.
% FIXME/TODO: use of partition (path-datastructure partition) not
%             implemented yet.
% FIXME/TODO: EXTERNAL_SOLVER is ongoing but not fully implemented yet.
%             It should be easy to fully integrate in minmax.
% FIXME/TODO: PIPEMEMO not implemented yet. 
%---------------------------------------------------------------------------%
% -minmax-cs-reuse option is vital to reuse code space from one
% restart to another.
%---------------------------------------------------------------------------%
% NOTES about external (provided by external tools) loop
% invariants. It is not straightforward due to reasons:
%
% 1) The invariance test may throw them away if they are not
%    individually invariant.
%
% 2) The subsumption test may throw them away if they are not
%    invariant at the point the subsumption is trying to take place.
%
% Based on our experiments (2) happens more often. A possible solution
% is to keep track of the constraints provided by the oracle so
% whenever subsumption is taking place we don't mark them as min's
% since we know they are invariants. This is what we try with
% loopinfo$update_known_inductive_invariants and
% loopinfo_get_known_inductive_invariants. However, we don't currently
% keep the mapping across abstractions because projection is often
% done and destroys that mapping.
%
% Option -minmax-optimist-subs decides whether we want to force
% subsumption by marking some constraints as non-invariant.  For large
% programs, we probably want ("y"). However, for small programs and,
% in particular, if we have loop invariants from external tools we may
% prefer not to do it.
%---------------------------------------------------------------------------%
%                 Code for refinement heuristics
%---------------------------------------------------------------------------%
% As in CEGAR, our refinement phase can depend heavily on the heuristics
% used. Currently, we implement the following heuristics:
%
% (a): refine the first abstraction bottom-up in the spurious path.
% (b): refine the first abstraction top-down  in the spurious path.
%
% Given two formulas A and B and interpolate(A,B) = I. Then:
%
% (c): having selected an abstraction to refine((a) or (b)), it
% interpolates using (if possible) the last guard (i.e., error
% condition) B
% (d): having selected an abstraction to refine, it interpolates using
% false as B.
%
% Then, the flag refinement_heuristics can take the values:
%
% 1: (a) + (c)
% 2: (a) + (d)   // default value 
% 3: (b) + (c)
% 4: (b) + (d)   
%
% Comment: the use of heuristics 3 and 4 may be not progressive. The
% problem of starting from the top is that we may choose always the
% same constraints. We solve this by keeping track of the history of
% refinements and choosing the first one that has not been explored
% yet. Even so, they may be not progressive. E.g.:
% 
% test-loop-15.c -h 4 ok
% test-loop-15.c -h 3 does not terminate
% test-loop-16.c -h 4 does not terminate
% test-loop-16.c -h 3 does not terminate
% 
% Update (08/03/12): I tried again these programs with -h 3 and -h 4
% and TRACER terminates. Not sure if the claim I did above is true or
% it was due to some bug fixed later on. 
%
%===========================================================================%
% Notation and some explanation about core datastructures:
%
% The core data structure is LoopStack which contains all information
% about the current symbolic path with possible abstractions in the
% middle.
%
% -- FIXME: quite unfortunate name. It should be AbstractedPath
%           or something like that.
%
%  LoopStack       = [] U [LoopInfo|LoopStack]
%  LoopInfo        =   r(SGlobalArr, SGlobalVar, SLocalArr, SLocalVar, CL, ML) 
%                    U p(NodeId,Depth,FName,PP,
%                        SGlobalArr, SGlobalVar, SLocalArr, SLocalVar, CL, ML,
%                        SiblingMax)
%
%  ML              = [] U [MLElem | ML]  ('o' is a max and 'x' is a min)
%  MLElem          = o | x 
%  SiblingMax      = ML   
%--------------------------------------------------------------------------%
%  LoopStackML is used when LoopStack has to be propagated from
%              children to parents through assert/retract.
%  LoopStackML     = [] U  [ LoopStackMLElem | LoopStackML]
%  LoopStackMLElem = r(ML) U p(ML)
%
%      A well-formed LoopStackML or LoopStack follow the regular
%      expression:
%           r().(p().r())*
%      i.e., one relation (r) at least followed by an arbitrary
%      sequence of interleavings of abstrations (p) and relations (r).
%--------------------------------------------------------------------------%
%  LoopContext is used to keep track of those constraints needed for
%              keeping invariance of constraints.
%  LoopContext     = lc_null U LoopContextList
%  LoopContextList = [] U [lc(NodeId,Depth,MTList) | LoopContextList ]
%    NodeId is a unique identifier.
%    Depth  is the depth of the symbolic tree.
%    MTList = mt(N,MTArg)
%    where N is the index of a constraint wrt the projection at the
%          looping point (that is, when we encounter a loop header we
%          project constraints and give an order. N is the position in
%          that order), and
%          MTArg is a list of those constraints needed for keeping invariance,
%                which has two different formats but equivalent:
%          - LoopStackML when it's first generated.
%          - List of negated projected constraints when it's
%            propagated from children to parents (cheaper representation
%            to assert/retract).
%  SiblingMax is information about sibling's max's. 
%---------------------------------------------------------------------------%
% BUGS:
%  See regrtest-TRACER-MINMAX and search for keyword "Problems" to see
%  programs on which minmax does not work properly.
%===========================================================================%

% #define DEBUG_REFINE
% #define MINMAX_DEBUG_ASSERT
% #define MINMAX_DEBUG_RETRACT		

% Cleanup of minmax
mm_cleanup:-
	retractall(using_inductive_invariants(_,_)),
	retractall(history_table_of_conflicts(_,_)),
#if     !defined(PIPEDUMP_AND_ANSWERS)	
#ifdef  GC_INTP_INFEASIBLE
        retractall(safety_answer(_, _, _, _, _, _, _)),
#else
        retractall(safety_answer(_, _, _, _, _, _)),
#endif  /*GC_INTP_INFEASIBLE*/
#endif  /*!defined(PIPEDUMP_AND_ANSWERS)*/	
	retractall(disable_inductive_invariants(_,_)).
		
% Initialize minmax counters
init_minimax_counters:-
        set_counter(node_id, 0),
	set_counter(tabled_count,0),	
#ifdef  PROFILE	
	% Time for classifying transitions between feasible and
	% infeasible.
	set_counter(minimax_test_outgoing,0),
        % This one complements to store_timing_2 and store_timing_3
        set_counter(prep_store_memo_timing,0),
	% Time to propagate abstraction from one sibling to another
	set_counter(apply_sibling_answers_timing,0),
	%--------------------------------------------------------------%
	% Optimization in infeasible paths
        %--------------------------------------------------------------%	
	set_counter(reuse_interpolant_for_infeasible_path,0),
	set_counter(num_of_deleted_subsumed_memo_entries,0),
        %--------------------------------------------------------------%
	% Subsumption
        %--------------------------------------------------------------%	
	% number of times subsumption test ok
	set_counter(max_subsumed_ok,0),
	% number of times subsumption test failed.
	set_counter(max_subsumed_failed,0),
	% timing when (max) subsumption test ok
	set_counter(max_subsumed_timing_ok,0),
	% timing when (max) subsumption test failed.
	set_counter(max_subsumed_timing_failed,0),	
	% number of times the forcing of min's ok
	set_counter(min_subsumed_ok,0),
	% number of times the forcing of min's failed.
	set_counter(min_subsumed_failed,0),
	% timing when the forcing of min's ok	
	set_counter(min_subsumed_timing_ok,0),
	% timing when some forcing of a min failed	
	set_counter(min_subsumed_timing_failed,0),
	% number of times that subsumption succeed due to a min
	set_counter(num_forced_subsumptions,0),
        %--------------------------------------------------------------%
	% Loops
        %--------------------------------------------------------------%	
	% To counter number of restart's. A restart is considered when
	% the analysis of a loop has been finished and after a
	% conflict is detected out of the loop.
	set_counter(num_of_conflict,0),	
	% To counter number of times we can use the safety property to
	% guide the refinement.
	set_counter(num_of_directed_refinements,0),
	% To counter number of times the loop invariant generation
	% failed. That is, some constraints must be minimized but
	% cannot because they are already maximized.
	set_counter(num_loop_inv_gen_failed,0),
	% Number of times a loop invariant was generated
	set_counter(num_loop_inv_gen_succeed,0),
	% Number of constraints tested for invariants
	set_counter(num_of_tested_inv_candidates,0),
	% Number of constraints that are indeed invariants
	set_counter(num_of_successful_inv_candidates,0),
	% Time to test candidates for invariants
        set_counter(test_candidate_invariants_timing,0),
	% Time to enumerate candidates for invariants
        set_counter(enumerate_candidate_invariants_timing,0),
	% Time for refinement
	set_counter(search_for_abstraction_to_refine_timing,0),
        %--------------------------------------------------------------%
	% Store in Cache
        %--------------------------------------------------------------%	
	set_counter(store_memo_compute_invariants,0),
	set_counter(num_of_invariance_dependencies,0),
%#ifdef  CACHE_PROJECT_MINTESTS
        set_counter(num_of_reused_invariance_dependencies,0),
%#endif  /*CACHE_PROJECT_MINTESTS*/ 
#endif  /*PROFILE*/
        true.

%--------------------------------------------------------------------------%
% mm_bound_reached(+,+,+,+,+,+,+,+,+,+,+)
%--------------------------------------------------------------------------%
% In case, we limit the search depth we generate an interpolant.
%--------------------------------------------------------------------------%
mm_bound_reached(FName,Depth, CL, ML,
		 NodeId, LoopStack, LoopContext,
		 SGlobalArr, SGlobalVar, SLocalArr, SLocalVar):-
	interp_gen_success_path(SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
				Intp),
	store_answer(NodeId, Depth, FName, CL, ML, Intp, LoopStack,LoopContext).
		     
%--------------------------------------------------------------------------%
% Generic operation
%--------------------------------------------------------------------------%
% mm_success_path(+,+,+,+,+,+,+,+,+,+,+,+,+,+,+,+,+)
% In case we have finished a safe path, we generate an interpolant.
%--------------------------------------------------------------------------%
mm_success_path(FName, Depth, _PP, CL, ML,
		NodeId, LoopStack, LoopContext,
		SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		_GlobalArr, _GlobalVar, _LocalArr, _LocalVar, _ArrRef):-
        interp_gen_success_path(SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,Intp),
	store_answer(NodeId, Depth, FName, CL, ML, Intp, LoopStack,LoopContext).

%----------------------------------------------------------------------------------------
% test_outgoing_trans(+FName,+PC,+GA,+GV,+LA,+LV,+ArrRef,+SGA,+SGV,+SLA,+SLV,
%	              +CallStack, -Enabled, -Disabled)
%----------------------------------------------------------------------------------------
% Separate (immediate) reachable transitions from FName and PC into
% enabled and disabled transitions. "Enabled" means that the
% transition is already feasible. "Disabled" means that the transition
% is for now infeasible but it may be feasible after
% min-abstraction. That is, a loop abstraction may make a transition
% that was infeasible, feasible after the abstraction. For efficiency
% reasons, it's vital to execute symbolically first those which we
% know are already feasible. Otherwise, we will generate interpolants
% from infeasible paths which will make more difficult the search.
%----------------------------------------------------------------------------------------
test_outgoing_trans(FName, PC, GA, GV, LA, LV, ArrRef, SGA,SGV,SLA,SLV,
	            CallStack, Enabled, Disabled) :-
#ifdef  PROFILE
        ctime(Time0),
#endif 	/*PROFILE*/
	test_outgoing_trans_aux(FName, PC, GA, GV, LA, LV, ArrRef,
		 	        SGA,SGV,SLA,SLV,[],[],[],CallStack,Enabled,Disabled),
                                
#ifdef  PROFILE
        ctime(Time1),
	add_counter(minimax_test_outgoing,Time1-Time0),
#endif  /*PROFILE*/
        true.

test_outgoing_trans_aux(FName, PC, GA, GV, LA, LV, ArrRef,
			SGA,SGV,SLA,SLV, Enabled, Disabled, All,
                        CallStack, OutEnabled, OutDisabled) :-
	get_trans(FName, Id, PC, GA1, GV1,
		  SGA1,SGV1,LA1,LV1,SLA1, SLV1,
		  _,_,_,_,_,_,_,_,_,XCL,_,ArrRef1,_,All
#ifdef  DEBUG
		 ,_DebugTraceInfo
#endif  /*DEBUG*/
		 ), !,	
        test_enabled_trans(FName,Id,PC,GA,GV,LA,LV,ArrRef,
			   GA1,GV1,LA1,LV1,ArrRef1,
			   SGA,SGV,SLA,SLV,SGA1,SGV1,SLA1,SLV1,XCL,
			   Enabled,Disabled,All,
			   CallStack,OutEnabled,OutDisabled).
test_outgoing_trans_aux(_,_,_,_,_,_,_,_,_,_,_,Enabled,Disabled,_,_,Enabled,Disabled).
	                

test_enabled_trans(FName,Id,PC,GA,GV,LA,LV,ArrRef,
		   GA1,GV1,LA1,LV1,ArrRef1,SGA,SGV,SLA,SLV,
		   SGA1,SGV1,SLA1,SLV1,XCL,Enabled, Disabled, All,
		   CallStack, OutEnabled, OutDisabled) :-
	% print_message("Checking if % is feasible or not \n",[Id]),
	states_nonunifiable(GA,  GV,  LA,  LV,  ArrRef,
	                    GA1, GV1, LA1, LV1, ArrRef1,
			    FName,SGA , SGV , SLA , SLV,
			    SGA1, SGV1, SLA1, SLV1, XCL),
	% print_message("\t adding % as disabled \n",[Id]),
	% Here the transition is marked as disabled (i.e., infeasible)
	test_outgoing_trans_aux(FName,PC,GA,GV,LA,LV,ArrRef,
			        SGA,SGV,SLA,SLV,Enabled, [Id|Disabled], [Id|All],
				CallStack,OutEnabled,OutDisabled).
test_enabled_trans(FName,Id,PC,GA,GV,LA,LV,ArrRef,_,_,_,_,_,SGA,SGV,SLA,SLV,
		   _,_,_,_,_,Enabled,Disabled,All,CallStack, OutEnabled, OutDisabled):-
	% print_message("\t adding % as enabled \n",[Id]),	
	% Here the transition is marked as enabled (i.e., feasible)
	test_outgoing_trans_aux(FName, PC, GA, GV, LA, LV, ArrRef,
			        SGA , SGV , SLA , SLV,
	                        [Id|Enabled], Disabled, [Id|All],
				CallStack, OutEnabled, OutDisabled).

states_nonunifiable(GA,  GV,  LA,  LV,  ArrRef,
	            GA1, GV1, LA1, LV1, ArrRef1,
		    FName,SGA , SGV , SLA , SLV,
		    SGA1, SGV1, SLA1, SLV1, XCL):-
	GA = GA1, GV = GV1, LA = LA1, LV = LV1,
	SGA = SGA1, SGV = SGV1, SLA = SLA1, SLV = SLV1,
#ifdef  EXTERNAL_SOLVER
	%------------------------------------------------------------------% 
	% This is just a test. The solver backtracks so all bindings
	% are undone.
	%------------------------------------------------------------------% 	
	extern_solver_add_cnstr_and_check_sat_and_undo(XCL,
						       state(FName,
							     SGA,SGV,SLA,SLV)),
	% To avoid warnings
	ArrRef=_,ArrRef1=_,
#else	
	% To avoid warnings
        FName=_,XCL=_,
	append(ArrRef,ArrRef1,ArrRef2),
	satisfiable_array_references(ArrRef2),
#endif  /*EXTERNAL_SOLVER*/
	!,
	fail.
states_nonunifiable(_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_).
		    
%-----------------------------------------------------------------------------
% test_independently_infeasible(+Enabled,+Disabled,+,+,+,+,+,+,+,+,-,+)
%-----------------------------------------------------------------------------
% Test if the transition is infeasible no matters the context
% (i.e. Enabled=[] and Disabled=[]). If yes, then it stores an answer
% to avoid breaking further operations like combine. Note in this
% case, we just generate a true interpolate.
%-----------------------------------------------------------------------------
test_independently_infeasible([],[],NodeId,Depth,
			      FName,SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			      CL,FreshML,LoopStack):-
	% This is important, otherwise during the restart process we
	% may assert incorrectly facts.
	not(is_conflict(Depth)),
	
	copy_to_unbound_list(CL, FreshML),
	interp_gen_success_path(SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,Intp),
	store_answer(NodeId, Depth, FName, CL, FreshML, Intp, LoopStack, []),
	!,
	fail.
test_independently_infeasible(_,_,_,_,_,_,_,_,_,_,_,_).

%---------------------------------------------------------------------------------------
% get_trans 
%---------------------------------------------------------------------------------------
% Find a transition not in NotInSet
%---------------------------------------------------------------------------------------
get_trans(FName, Id, PC,  GA,  GV,  SGA,  SGV,  LA,  LV,  SLA,  SLV,
                     PC1, GA1, GV1, SGA1, SGV1, LA1, LV1, SLA1, SLV1,
		     XCL, Call, ArrRef, BranchMode,
		     NotInSet) :-
	get_trans_aux(FName, Id, PC,  GA,  GV,  SGA,  SGV,  LA,  LV,  SLA,  SLV,
  	                         PC1, GA1, GV1, SGA1, SGV1, LA1, LV1, SLA1, SLV1,
			         XCL, Call, ArrRef, BranchMode),
	mm_not_included(Id, NotInSet).

get_trans_aux(FName, Id, PC,  GA,  GV,  SGA,  SGV,  LA,  LV,  SLA,  SLV,
	                 PC1, GA1, GV1, SGA1, SGV1, LA1, LV1, SLA1, SLV1,
	                 XCL, Call, ArrRef, BranchMode) :-
	trans(FName, Id,
		PC,  GA,  GV,  SGA,  SGV,  LA,  LV,  SLA,  SLV,
		PC1, GA1, GV1, SGA1, SGV1, LA1, LV1, SLA1, SLV1,
		XCL, Call, ArrRef, BranchMode).

mm_not_included(_, []).
mm_not_included(Item, [X|_]) :- Item == X, !, fail.
mm_not_included(Item, [_|R]) :- mm_not_included(Item, R).


%==============================================================================
% mm_check_error_path
%
% We check if the visited program point is an error program point. If
% yes, then we start the refinement process. Otherwise, we fail.
%==============================================================================
#ifdef  GC_INTP_INFEASIBLE
mm_check_error_path(_,PP,_,
		    _, _, _, _,_,
		    _, _, _, _,
		    _, _, _, _):-
    in_gc_mode,
    is_error_reachable(PP), !,
    set_counter(gc_status,0),
    debug_message("GC failed! Error PP reached!\n",[],red),
    fail. % if error is reachable in GC mode, then GC failed (error is spurious)
#endif
#ifdef  GROUND_EXPLANATION
mm_check_error_path(_FName,PP,_Id,
		    _GlobalArr, _GlobalVar, _LocalArr, _LocalVar,_ArrRef,
		    _SGlobalArr, _SGlobalVar, _SLocalArr, _SLocalVar,
		    _CL, _ML, _LoopStack, _PathStack):-
    is_error_reachable(PP),
    counter_value(follow_ground_trace, 2),
    set_counter(ground_safe_invariant, 0), % record that invariant is unsafe
    !.
#endif  /*GROUND_EXPLANATION*/
mm_check_error_path(FName,PP,Id,
		    GlobalArr, GlobalVar, LocalArr, LocalVar,ArrRef,
		    SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		    CL, ML, LoopStack, PathStack):-
	is_error_reachable(PP),
	!,	
#ifdef  GROUND_EXPLANATION
    error_message("Somehow TRACER reached error PP during explanation!\n",[]),
#endif  /*GROUND_EXPLANATION*/
        mm_refine_error(FName,PP,Id,
			GlobalArr, GlobalVar, LocalArr, LocalVar,ArrRef,
			SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			CL, ML, LoopStack, PathStack).

%----------------------------------------------------------------------------%
% mm_refine_error
%----------------------------------------------------------------------------%
% Check if the error is real. If yes, then report error and
% halt. Otherwise, refine some abstraction to exclude the error and
% restart. This is basically the refinement phase done in CEGAR.
%
% One difference is that we apply abstraction only at looping points
% in order to get loop invariants. Therefore, during the refinement
% process we visit **only** the looping points and check if the
% abstraction caused the error node to be reachable. If yes, we refine
% that point. Otherwise, we continue up with the next looping
% point. If we reach the root of the tree, then it means that the
% error is real.
%----------------------------------------------------------------------------%
mm_refine_error(FName,_PP, Id,
		_GlobalArr,_GlobalVar,_LocalArr,_LocalVar,ArrRef,
		SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
		CL, ML, LoopStack, _PathStack) :-
#ifdef  PROFILE
        ctime(T0),
#endif  /*PROFILE*/
        push_minmax_segment_path(SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,CL,ML,
				 LoopStack ,Path),
	mm_refine_aux(FName, Id,
		      SGlobalArr, SGlobalVar,
		      SLocalArr , SLocalVar , ArrRef, Path, CL , ML),
	
#ifdef  PROFILE
        ctime(T1),
	add_counter(search_for_abstraction_to_refine_timing,T1-T0),
#endif  /*PROFILE*/	
	!,
	fail.
mm_refine_error(FName,_PP,_Id,
		GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
		_SGlobalArr, _SGlobalVar, _SLocalArr, _SLocalVar,
		_CL, _ML, _LoopStack, PathStack) :-
	%----------------------------------------------------------------------
	% No conflict point, this is a real error, the only point
	% where the tracer succeeds.
	%----------------------------------------------------------------------
	mm_show_cex(PathStack,
		    FName, GlobalArr ,GlobalVar ,LocalArr ,LocalVar,ArrRef),
	!.

%------------------------------------------------------------------------------
% Display in friendly format the real counterexample to the user
%------------------------------------------------------------------------------
mm_show_cex(PathStack,
	    _FName,_GlobalArr,_GlobalVar,_LocalArr,_LocalVar,_ArrRef):-
	% This shows the current state of the solver store
	% pretty_printer_solver_state(FName,
	% 			      GlobalArr,GlobalVar,LocalArr,LocalVar,ArrRef),
	reverse(PathStack,RevPathStack),
	print_message("FEASIBLE COUNTEREXAMPLE FOUND! \n\n",[]),
	pathstack$pretty_printer(RevPathStack),
	print_message("\n",[]).
	
% Execute the first clause of mm_refine_aux/10 only if -h 3 or -h 4
exec_mm_refine_aux$first_clause:- current_tracer_flag(refinement_heuristics,3).
exec_mm_refine_aux$first_clause:- current_tracer_flag(refinement_heuristics,4).	

mm_refine_aux(FName, Id,
	      SGlobalArr, SGlobalVar,
	      SLocalArr , SLocalVar , ArrRef, Path, _ , _):-
	exec_mm_refine_aux$first_clause,
	!,
#ifdef  DEBUG_REFINE	
	pretty_printer_minmax_path(Path,FName),
#endif  /*DEBUG_REFINE*/	
	
        findall_abstractions_to_refine(Path,[],[],
				       SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
				       PathList),
	gen_abstraction_order_based_on_heuristics(PathList,NewPathList),
#ifdef  DEBUG_REFINE
	print_message("Begin symbolic path: \n",[]),
	pretty_printer_minmax_pathlist(NewPathList,
				       FName,
				       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar),
	print_message("End symbolic path: \n",[]),
#endif  /*DEBUG_REFINE*/
	visit_abstraction_list_to_refine(NewPathList,
					 FName, Id,
					 SGlobalArr, SGlobalVar,
					 SLocalArr , SLocalVar , ArrRef,
					 []).
mm_refine_aux(FName, Id,
	      SGlobalArr, SGlobalVar,
	      SLocalArr , SLocalVar , ArrRef, Path, CL , ML):-
	search_for_abstraction_to_refine(FName,Id,
	 				 SGlobalArr, SGlobalVar,
	 				 SLocalArr, SLocalVar,ArrRef,
	 				 CL, ML, Path).

%-----------------------------------------------------------------------------------%
% visit_abstraction_list_to_refine
%-----------------------------------------------------------------------------------%
% Same than search_for_abstraction_to_refine/10 but traverses a list
% rather than using find_next_min/5 to visit all abstractions
%-----------------------------------------------------------------------------------%
visit_abstraction_list_to_refine([],_,_,_,_,_,_,_,[]) :-
	%-----------------------------------------------------------------%	
	% No more abstractions to process. Then error is real
	%-----------------------------------------------------------------%	
	!,
	fail.
visit_abstraction_list_to_refine([],
				 FName,Id,
				 SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,ArrRef,
				 DelayedAbs) :-

	%print_history_of_conflicts,
	%print_delayed_abstractions(DelayedAbs),	
	%-----------------------------------------------------------------%
	% We already did a pass through all abstractions but still
	% there are left some abstractions that we skipped originally
	% that we must process now before we report a real error.
	%-----------------------------------------------------------------%	
	% FIXME: At this point, it doesn't matter which delayed
	% abstraction we choose to refine that we will probably not
	% terminate. 
	%-----------------------------------------------------------------%
	DelayedAbs = [abs(MinDepth,
	  		  SGlobalArr,SGlobalVar,SLocalArr, SLocalVar,
	  		  MinCL, MinML, CL, ML)|_],
	
	print_message("Attempting at refining the delayed abstraction at depth %\n",
	 	      [MinDepth],red),

	refine_chosen_abstraction(FName, Id, 
				  SGlobalArr,SGlobalVar,SLocalArr, SLocalVar, ArrRef,
				  MinDepth, MinCL, MinML, CL, ML),
	%-----------------------------------------------------------------%	
	%% This is a bit gross: we change to a bottom-up heuristics in
	%% the middle of the process to try to be progressive because
	%% if we insist to be top-down we will probably not terminate.
	%-----------------------------------------------------------------%	
	print_message("Changing heuristics to avoid non-termination\n",[]),
	set_tracer_flag(refinement_heuristics,1),
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% select(abs(MinDepth,
	% 	   SGlobalArr,SGlobalVar,SLocalArr, SLocalVar,
	% 	   MinCL,MinML,CL,ML), DelayedAbs, _),		
	% print_message("Attempting at refining the delayed abstraction at depth %\n",
	% 	      [MinDepth],red),
	% once(rule_out_spurious_cex(FName, Id, 
	% 			   SGlobalArr,SGlobalVar,SLocalArr, SLocalVar, ArrRef,
	% 			   MinDepth, MinCL, MinML, CL, ML, CurrMinML)),	
	% history_table_of_conflicts(MinDepth,PrevMinML),
	% not(identical_marking(PrevMinML,CurrMinML)),
        % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% pretty_printer_restart_info(Id,
	% 			    SGlobalArr, SGlobalVar,
	% 			    SLocalArr , SLocalVar ,
	% 			    MinDepth  , MinCL     , CurrMinML),
        % add_counter(num_of_conflict,1),
	% fassert(conflict(MinDepth, CurrMinML)),	
	!.
visit_abstraction_list_to_refine([abs(_MinDepth,
				      SGlobalArr,SGlobalVar,SLocalArr, SLocalVar,
				      MinCL,_MinML,CL,_ML) | Ls],
				 FName, Id,
				 SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,ArrRef,
				 DelayedAbs) :-
	%-----------------------------------------------------------------%	
	% This abstraction is not the cause of the spurious error
	% since the error is still satisfiable
	%-----------------------------------------------------------------%	
	satisfiable_segment(MinCL, CL),
	!,
	visit_abstraction_list_to_refine(Ls,
					 FName, Id,
					 SGlobalArr, SGlobalVar,
					 SLocalArr , SLocalVar , ArrRef,
					 DelayedAbs).
visit_abstraction_list_to_refine([abs(MinDepth,
				      SGlobalArr,SGlobalVar,
				      SLocalArr,SLocalVar,
				      MinCL,MinML,CL,ML) | Ls],
				 FName, Id,
				 SGlobalArr,SGlobalVar,
				 SLocalArr,SLocalVar,ArrRef,
				 DelayedAbs) :-
	%-----------------------------------------------------------------%
	% An abstraction was refined at the same depth before. We
	% don't process it for now to keep the refinement algorithm
	% progressive but we store it because we may need to refine it
	% later.
	%-----------------------------------------------------------------%
	history_table_of_conflicts(MinDepth,_),
	!,
	visit_abstraction_list_to_refine(Ls,
					 FName, Id,
					 SGlobalArr, SGlobalVar,
					 SLocalArr , SLocalVar , ArrRef,
					 [abs(MinDepth,
					      SGlobalArr,SGlobalVar,
					      SLocalArr ,SLocalVar,
					      MinCL,MinML,CL,ML) | DelayedAbs]).
visit_abstraction_list_to_refine([abs(MinDepth,
				      SGlobalArr,SGlobalVar,SLocalArr, SLocalVar,
				      MinCL,MinML,CL,ML) | _],
				 FName, Id,
				 SGlobalArr, SGlobalVar,
				 SLocalArr , SLocalVar , ArrRef,
				 _DelayedAbs) :-
	%-----------------------------------------------------------------%	
	% This abstraction is one (possibly among others) that caused
	% the spurious error
	%-----------------------------------------------------------------%	
	refine_chosen_abstraction(FName, Id, 
				  SGlobalArr,SGlobalVar,SLocalArr, SLocalVar, ArrRef,
				  MinDepth, MinCL, MinML, CL, ML).

#ifdef  DEBUG_USE
print_delayed_abstractions([]):-!.
print_delayed_abstractions([abs(Depth,_,_,_,_,_,_,_,_)| Abs]):-
	print_message("Delayed abstraction at depth: %\n",[Depth]),
	print_delayed_abstractions(Abs).
#endif  /*DEBUG_USE*/
		    
%-----------------------------------------------------------------------------
% findall_abstractions_to_refine(+Path,+AccCL,+AccML,+SGlobalArr,...,-PathList)
%-----------------------------------------------------------------------------
% Collect all abstractions along the path Path and return it in list
% format. This format allow us to traverse later the abstractions
% bottom-up or top-down.
%-----------------------------------------------------------------------------
findall_abstractions_to_refine(Path,_,_,SGA,SGV,SLA,SLV,[]):-
	find_next_min(Path, NextLoopInfo, _,_,_),
	loopinfo$depth(NextLoopInfo, MinDepth),
	loopinfo$state(NextLoopInfo, SGA,SGV,SLA,SLV, MinCL, MinML),
	MinDepth=0,
	MinCL = [],
	MinML = [],
	!.
findall_abstractions_to_refine(Path, PrevCL, PrevML,
			       SGA,SGV,SLA,SLV,
			       [abs(MinDepth,
				    SGA,SGV,SLA,SLV,
				    MinCL,MinML,CL1,ML1)|Xs]):-
	find_next_min(Path, NextLoopInfo, CL, ML, Path1),
	loopinfo$depth(NextLoopInfo, MinDepth),
	loopinfo$state(NextLoopInfo, SGA,SGV,SLA,SLV, MinCL, MinML),
	append(PrevCL, CL, CL1),
	append(PrevML, ML, ML1),
	findall_abstractions_to_refine(Path1, CL1, ML1,
				       SGA,SGV,SLA,SLV,
				       Xs).

% Provide a particular order to check which abstraction caused the
% spurious error. See above the different code meaning.
gen_abstraction_order_based_on_heuristics(PathList,PathList):-
	% Bottom-up
	current_tracer_flag(refinement_heuristics,1), !.
gen_abstraction_order_based_on_heuristics(PathList,PathList):-
	% Bottom-up	
	current_tracer_flag(refinement_heuristics,2), !.
gen_abstraction_order_based_on_heuristics(PathList,NewPathList):-
	% Top-down
	current_tracer_flag(refinement_heuristics,3),
	reverse(PathList,NewPathList), !.
gen_abstraction_order_based_on_heuristics(PathList,NewPathList):-
	% Top-down	
	current_tracer_flag(refinement_heuristics,4),
	reverse(PathList,NewPathList), !.
gen_abstraction_order_based_on_heuristics(_,_):-
	current_tracer_flag(refinement_heuristics,N),
	error_message("Unsupported refinement heuristics %\n",[N]).

#ifdef  DEBUG_REFINE
pretty_printer_minmax_pathlist([],_,_,_,_,_):-!.
pretty_printer_minmax_pathlist([abs(_,
				    SGlobalArr,SGlobalVar,SLocalArr, SLocalVar,
				    MinCL,_,CL,_)|Xs],
			       FName,
			       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar):-
	print_message("Proj Segment: \n\t",[]),
	pretty_printer_constraints_list(FName,
					SGlobalArr,SGlobalVar,SLocalArr, SLocalVar,
					MinCL),
	print_message("Conc constraints from the Proj Segment to the error: \n\t",[]),
	pretty_printer_constraints_list(FName,
					SGlobalArr,SGlobalVar,SLocalArr, SLocalVar,
					CL),
	pretty_printer_minmax_pathlist(Xs,
				       FName,
				       SGlobalArr,SGlobalVar,SLocalArr, SLocalVar).
#endif  /*DEBUG_REFINE*/
	
%---------------------------------------------------------------------------
% search_for_abstraction_to_refine(+,+,+,+,+,+,+,+,?,?Path)
% Traverses the symbolic path Path via find_next_min/5
%---------------------------------------------------------------------------
search_for_abstraction_to_refine(FName, Id,
				 SGlobalArr, SGlobalVar,
				 SLocalArr, SLocalVar,ArrRef,
				 CL, ML, Path) :-
	find_next_min(Path, NextLoopInfo, CL, ML, Path1),
	loopinfo$depth(NextLoopInfo, MinDepth),
	loopinfo$state(NextLoopInfo, _, _, _, _, MinCL, MinML),
	!,
#ifdef  DEBUG_REFINE 
        pretty_printer_minmax_path(Path,FName),
#endif  /*DEBUG_REFINE*/

#ifdef  GROUND_EXPLANATION
    Path1=_,
	refine_chosen_abstraction(FName, Id, 
				  SGlobalArr,SGlobalVar,SLocalArr, SLocalVar, ArrRef,
				  MinDepth, MinCL, MinML, CL, ML).	
#else
	% Note: if the path does not contain any loop then MinCL and
	% MinML are not instantiated. Therefore, the first clause of
	% visit_each_abstraction_to_refine/6 will succeed.
	visit_each_abstraction_to_refine(FName, Id, Path1,
					 SGlobalArr, SGlobalVar,
					 SLocalArr , SLocalVar , ArrRef,
					 MinDepth  ,
					 MinCL, MinML, CL, ML).        
#endif  /*GROUND_EXPLANATION*/

visit_each_abstraction_to_refine(_FName,_Id,_Path,_,_,_,_,_,0,[],[],_CL,_ML) :-
	%----------------------------------------------------------------------
	% No more abstraction points: this must be a real error
	%----------------------------------------------------------------------
	!, fail.
visit_each_abstraction_to_refine(FName, Id, Path,
				 SGlobalArr, SGlobalVar, SLocalArr, SLocalVar, ArrRef,
				 _MinDepth, MinCL, _MinML, CL, ML) :-
	%----------------------------------------------------------------------
	% The error is still reachable even if the abstraction is
	% rolled-back.  Therefore, the abstraction point has nothing
	% to do with the error. We continue going up in the tree.
	%----------------------------------------------------------------------
	satisfiable_segment(MinCL, CL),
	!,
	find_next_min(Path, PrevNextLoopInfo, PrevCL, PrevML, Path1),
	loopinfo$depth(PrevNextLoopInfo, PrevMinDepth),
	loopinfo$state(PrevNextLoopInfo,_,_,_,_,PrevMinCL,PrevMinML),
	append(CL, PrevCL, CL1),
	append(ML, PrevML, ML1),
	visit_each_abstraction_to_refine(FName, Id, Path1,
					 SGlobalArr, SGlobalVar,
					 SLocalArr , SLocalVar , ArrRef,
					 PrevMinDepth,PrevMinCL, PrevMinML,
					 CL1, ML1).
#ifdef  MM_REFINE_TOPDOWN
visit_each_abstraction_to_refine(FName, Id, Path,
				 SGlobalArr, SGlobalVar, SLocalArr, SLocalVar, ArrRef,
				 _MinDepth, _MinCL, _MinML, CL, ML) :-
    more_mins_in_path(Path),
	%----------------------------------------------------------------------
    % If there are more abstractions along the path, try them to find the
    % topmost abstraction that led to the error. Don't put a ! here,
    % because if no abstraction above this led to the error, we need to
    % refine this one (i.e, backtrack and execute the next clause)
	%----------------------------------------------------------------------
	find_next_min(Path, PrevNextLoopInfo, PrevCL, PrevML, Path1),
	loopinfo$depth(PrevNextLoopInfo, PrevMinDepth),
	loopinfo$state(PrevNextLoopInfo,_,_,_,_,PrevMinCL,PrevMinML),
	append(CL, PrevCL, CL1),
	append(ML, PrevML, ML1),
	visit_each_abstraction_to_refine(FName, Id, Path1,
					 SGlobalArr, SGlobalVar,
					 SLocalArr , SLocalVar , ArrRef,
					 PrevMinDepth,PrevMinCL, PrevMinML,
					 CL1, ML1).
#endif /*MM_REFINE_TOPDOWN*/
visit_each_abstraction_to_refine(FName, Id, _Path,
				 SGlobalArr,SGlobalVar,SLocalArr, SLocalVar, ArrRef,
				 MinDepth, MinCL, MinML, CL, ML) :-
	%----------------------------------------------------------------------
	% This loop abstraction is one among others that makes the
	% error reachable.  We use interpolation to choose those
	% constraints that rule out the spurious error.
	%----------------------------------------------------------------------
    not(satisfiable_segment(MinCL, CL)), !,
	refine_chosen_abstraction(FName, Id, 
				  SGlobalArr,SGlobalVar,SLocalArr, SLocalVar, ArrRef,
				  MinDepth, MinCL, MinML, CL, ML).	

%--------------------------------------------------------------------------------%
% refine_chosen_abstraction
% Refine abstraction that caused the spurious error
%--------------------------------------------------------------------------------%
refine_chosen_abstraction(FName, Id, 
			  SGlobalArr,SGlobalVar,SLocalArr, SLocalVar, ArrRef,
			  MinDepth, MinCL, MinML, CL, ML):-
	print_message("Safety violation due to abstraction. \n", [],red),
	rule_out_spurious_cex(FName, Id, 
			      SGlobalArr,SGlobalVar,SLocalArr, SLocalVar, ArrRef,
			      MinDepth, MinCL, MinML, CL, ML, OutMinML),
	pretty_printer_restart_info(Id,
				    SGlobalArr, SGlobalVar,
				    SLocalArr , SLocalVar ,
				    MinDepth  , MinCL     , OutMinML),
        add_counter(num_of_conflict,1),
	fassert(conflict(MinDepth, OutMinML)).


% IMPORTANT: slow convergence may depend on the refinement
% heuristics. For instance, for test-loop-22.c, test-loop-29.c, etc.
exec_rule_out_spurious_cex$first_clause:- current_tracer_flag(refinement_heuristics,1).
exec_rule_out_spurious_cex$first_clause:- current_tracer_flag(refinement_heuristics,3).
rule_out_spurious_cex(FName, Id, 
		      SGlobalArr,SGlobalVar,SLocalArr, SLocalVar,_ArrRef,
		      _MinDepth, MinCL, _MinML, CL, ML,
		      OutMinML) :-
	
	exec_rule_out_spurious_cex$first_clause,
	% don't add any cut ! here	
	%======================================================================
	% We attempt at checking if the last guard (i.e., safety
	% property) and the constraints of MinCL, the constraints at
	% the loop header **before abstraction**, are
	% unsatisfiable. If this is the case, we directly lock
	% constraints from MinCL that keep the unsatisfiability with
	% the last guard. This refinement makes sense since it will
	% refine paying attention to the safety property.
	%======================================================================
	split_last_guard_and_rest(Id,
				  SGlobalArr,SGlobalVar,SLocalArr, SLocalVar,
				  CL, ML, XCL, RestCL, _RestML),
#ifdef  DEBUG_REFINE
	print_message("We split CL:\n",[]),
	pretty_printer_constraints_list(FName,
					SGlobalArr,SGlobalVar,SLocalArr, SLocalVar,
					CL),

	print_message("into XCL:\n",[]),
	pretty_printer_constraints_list(FName,
					SGlobalArr,SGlobalVar,SLocalArr, SLocalVar,
					XCL),
	print_message("and RestCL:\n",[]),
	pretty_printer_constraints_list(FName,
					SGlobalArr,SGlobalVar,SLocalArr, SLocalVar,
					RestCL),
	print_message("MinCL: \n",[]),
	pretty_printer_constraints_list(FName,
					SGlobalArr,SGlobalVar,SLocalArr, SLocalVar,
					MinCL),			
#else
        % To avoid warnings
        FName=_,RestCL=_,
#endif  /*DEBUG_REFINE*/	
	not(satisfiable_segment(XCL, MinCL)),
#ifdef  DEBUG_REFINE	
	print_message("XCL is unsat with MinCL \n",[]),
#endif  /*DEBUG_REFINE*/		
	!,
	add_counter(num_of_directed_refinements,1),
	%%%-----------------------------------------------------------------%%%
	%% LAZIER: w/ make_singleton_dnf we lock the minimal number of constraints
        %% EAGER : w/ make_dnf we lock the maximal number of constraints 
	% make_singleton_dnf(XCL,IntpCond),
	make_dnf(XCL,IntpCond),
	%%%-----------------------------------------------------------------%%%	
	copy_to_unbound_list(MinCL, OutMinML),
	choose_constraints_to_lock(IntpCond, MinCL, OutMinML).

rule_out_spurious_cex(_FName, _Id,
		      _SGlobalArr,_SGlobalVar,_SLocalArr, _SLocalVar,_ArrRef,
		      _MinDepth, MinCL, _MinML, CL, ML,
		      OutMinML) :-
	%======================================================================
	% General case: we only know that the error is spurious but no
	% clue where to refine. We just apply blindly interpolation.
	%======================================================================
	%----------------------------------------------------------------------
	% We note that here we do not need to create an interpolant as
	% in the next iteration the path would be unsatisfiable and
	% this would trigger interpolant creation. Here we just use
	% interpolation to choose the constraints that rule out the
	% error. For historical reasons, we call this process
	% "locking" of constraints.
	%----------------------------------------------------------------------
	copy_to_unbound_list(MinCL, OutMinML),
	append(CL, MinCL, NewCL),	
	append(ML, OutMinML, NewML),
	%-----------------------------------------------------------------------
	% Note that this predicate will instantiate also OutMinML
	%-----------------------------------------------------------------------
	% pretty_printer_constraints_list(FName,
	% 				  SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
	% 				  NewCL),
	
	choose_constraints_to_lock([], NewCL,NewML),
	!.

%------------------------------------------------------------------------------
% choose_constraints_to_lock(+IntpCond, +CL, ?ML)
%------------------------------------------------------------------------------
% Choose those constraints needed to rule out the spurious
% counterexample by interpolation.
%------------------------------------------------------------------------------
choose_constraints_to_lock([], CL, ML):-
	%% EAGER 
	% Very gross: we just try to lock as many constraints as
	% possible. The idea is that we want to avoid future
	% refinements. We should modify compute_unsat_core to produce
	% a maximal interpolant. Meanwhile, we try twice from left to
	% right and from right to left to simulate somehow that.
	reverse(CL,CL1),
	reverse(ML,ML1),
%	interpolate_constraints_path([tt], CL , ML , no_check),
	interpolate_constraints_path([tt], CL1, ML1, no_check).
choose_constraints_to_lock(IntpCond, CL, ML):-
	!,
	%% EAGER 
	reverse(CL,CL1),
	reverse(ML,ML1),
%	interpolate_constraints_path(IntpCond, CL , ML , no_check),
	interpolate_constraints_path(IntpCond, CL1, ML1, no_check).

%-------------------------------------------------------------------------------
% split_last_guard_and_rest(+Id, +SGA, ..., +CL,+ML, -XCL, -RestCL, -RestML)
%-------------------------------------------------------------------------------
% It just split CL into the constraints added by the last transition
% (only if it's a branch) and the rest.
%-------------------------------------------------------------------------------
split_last_guard_and_rest(Id, SGA, SGV, SLA, SLV, CL, ML, XCL, RestCL, RestML):-
	trans(_FName, Id,
	      _PC,  _GA,  _GV,  SGA, SGV,  _LA,  _LV, SLA, SLV,
	      _PC1, _GA1, _GV1, SGA, SGV, _LA1, _LV1, SLA, SLV,
	      XCL, _Call, _ArrRef, branch),
	length(XCL,N),
	delete_first_n(CL, N, RestCL),
	delete_first_n(ML, N, RestML),
	!.
split_last_guard_and_rest(_,_,_,_,_,CL,ML,[],CL,ML) :- !.

%----------------------------------------------------------------------------
% pretty_printer_restart_info(+,+,+,+,+,+,+,+): print useful
% information using dictionary about restart
%----------------------------------------------------------------------------
pretty_printer_restart_info(Id,
		   	    % Used for dictionary
			    SGlobalArr, SGlobalVar,
			    SLocalArr, SLocalVar,
			    MinDepth,
			    % Path segment and its interpolant (lock)
			    MinCL,FreshMinML):-
	trans(FName, Id,
	      _PC,  _GA,  _GV,  _SGA,  _SGV,  _LA,  _LV,  _SLA,  _SLV,
	      _PC1, _GA1, _GV1, _SGA1, _SGV1, _LA1, _LV1, _SLA1, _SLV1,
	      _XCL, _Call, _ArrRef, _BranchMode),
	
	counter_value(node_id, NumOfStates),
	print_message("TRACER: RESTART ... ",[],red),
        print_message("at transition id % ",[Id],red),		
        print_message("after % states   (tree depth:%) \n",
		      [NumOfStates,MinDepth],red),	
	print_message("\tPath= ",[]),
	pretty_printer_refined_constraints(FName,
					   SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
					   MinCL, FreshMinML).

%%%
%% FIXME: this code should be in pretty_printer.clp.gpp
%%%
pretty_printer_refined_constraints(FName,
				   SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
				   CL,ML):-	
	fcopy_term(t(SGlobalArr ,SGlobalVar ,SLocalArr ,SLocalVar,
		     CL),
		   t(SGlobalArr1,SGlobalVar1,SLocalArr1,SLocalVar1,
		     CL1)),	
        apply_dict(global,SGlobalArr1,SGlobalVar1),
	apply_dict(FName ,SLocalArr1 ,SLocalVar1),
	print_refined_constraints(CL1,ML).

print_refined_constraints(CL,ML):-
	print_message("[",[]),
	print_refined_constraints_aux(CL,ML),
	print_message("]\n",[]).

print_refined_constraints_aux([],[]):-!.
print_refined_constraints_aux([C],[M]):-
	!,
	print_refined_constraint(C,M).
print_refined_constraints_aux([C|CL],[M|ML]):-
	print_refined_constraint(C,M),
	print_message(", ",[]),
	print_refined_constraints_aux(CL,ML).
print_refined_constraint(C,M):-
	M==o,
	!,	
	% LOCKED means that the constraint shouldn't be abstracted
	% further
	print_message("LOCKED<%>",[C]).
print_refined_constraint(C,_M):-
	!,
	print_message("%",[C]).
	
%----------------------------------------------------------------------------
% To tell user his abstraction was too weak to prove safety
%----------------------------------------------------------------------------
report_user_if_abstraction_too_weak(FName,PP):-
	is_user_abstraction_pp(FName,PP), !,
	print_message("TRACER: abstraction applied at %:% was too weak.\n",
		      [FName,PP],red),
	print_message("\tand/or it was further abstracted by invariance tests.\n\n",
		      [],red).		     
report_user_if_abstraction_too_weak(_,_).

#ifdef  MM_REFINE_TOPDOWN
num_mins_in_path([], 0).
num_mins_in_path([LoopInfo|Path], M+1) :-
    loopinfo$nodeid(LoopInfo, _), !,
    num_mins_in_path(Path, M).
num_mins_in_path([_|Path], M) :-
    num_mins_in_path(Path, M).

more_mins_in_path(Path) :-
    counter_value(num_of_conflict,N),
    num_mins_in_path(Path, M), M>N, !.
#endif  /*MM_REFINE_TOPDOWN*/

%----------------------------------------------------------------------------
% find_next_min(+Path,-NextProjectedSegmentPath,-CL,-ML,-RestPath)
%----------------------------------------------------------------------------
% Try to find the next projected segment (loop abstraction, denoted
% with functor name "p") up in the path. If not found, return the path
% to the ancestor. CL and ML correspond to the constraints and unsat
% core bitvector of the segment before NextProjectedSegmentPath which
% by construction belongs to a segment without loop abstraction
% (denoted with functor name "r").
%----------------------------------------------------------------------------
find_next_min([], _LoopInfo, CL, ML, []) :-
	init_constraints_path([],CL,ML),
	!.
find_next_min([LoopInfo|Path], LoopInfo, CL, ML, Path) :-
	loopinfo$nodeid(LoopInfo, _),
	init_constraints_path([],CL,ML),
	!.
find_next_min([r(_SGlobalArr,_SGlobalVar,_SLocalArr,_SLocalVar,CL,ML)|Path],
	      LoopInfo, RelCL, RelML, OutPath) :-
	find_next_min(Path, LoopInfo, CL1, ML1, OutPath),
        merge_constraints_paths(CL1,ML1,CL,ML,RelCL,RelML).

%------------------------------------------------------------------------------
% find_loop_info_with_nodeid(+NodeId, +LoopStack, -LoopInfo)
%------------------------------------------------------------------------------
% Search for an element (LoopInfo) of LoopStack which is NodeId
%------------------------------------------------------------------------------
find_loop_info_with_nodeid(ANodeId, [LoopInfo|_], LoopInfo) :-
	loopinfo$nodeid(LoopInfo, ANodeId), !.
find_loop_info_with_nodeid(ANodeId, [_|R], OutLoopInfo) :-
	find_loop_info_with_nodeid(ANodeId, R, OutLoopInfo).

%==============================================================================
% LoopInfo ADT found in LoopStack
%==============================================================================
% This datastructure is the core one in minmax. It keeps track of all
% constraints in a symbolic path. A minmax symbolic path consists of
% two kind of segments: p(...) and r(...). The former is a projected form
% of all constraints propagated to a loop header. The latter contains
% symbolic constraints between loop headers.
% FIXME: LoopStack should be called MinMaxPath or something like that
%==============================================================================
loopinfo$nodeid(LoopInfo, NodeId) :-
	LoopInfo = p(NodeId, _, _, _, _, _, _, _, _, _, _, _, _).
loopinfo$depth(LoopInfo, Depth) :-
	LoopInfo = p(_, Depth, _, _, _, _, _, _, _, _, _, _, _).
loopinfo$point(LoopInfo, FName, PP) :-
	LoopInfo = p(_, _, FName, PP, _, _, _, _, _, _, _, _, _).
loopinfo$state(LoopInfo, _, _, _, _ , CL, ML) :-
	var(LoopInfo),!,
        init_constraints_path([],CL,ML).
loopinfo$state(LoopInfo, SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
               CL, ML) :-
	LoopInfo = p(_,_,_,_,SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,CL,ML,_,_,_).
loopinfo$siblingmax(LoopInfo, SiblingMax) :-
	LoopInfo = p(_, _, _, _, _, _, _, _, _, _, SiblingMax,_,_).
loopinfo$replace_state(LoopInfo,
		       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		       CL, ML,NewLoopInfo) :-
	LoopInfo = p(NodeId, Depth, FName, PP, _,_,_,_,_,_,SiblingMax,KnownIndInvs,MustInvs),
	NewLoopInfo = p(NodeId, Depth, FName, PP,
			SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			CL,ML,SiblingMax,KnownIndInvs,MustInvs).
% We store which constraints we know for sure they are invariants
% simply they are not changed within the loop.
loopinfo$set_must_invariants(LoopInfo,
			     SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
			     MustInvariants,
			     NewLoopInfo):-
	LoopInfo = p(NodeId, Depth, FName, PP,
		     SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
		     CL,ML,SiblingMax,KnownIndInvs,_),
	NewLoopInfo = p(NodeId, Depth, FName, PP,
			SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
			CL,ML,SiblingMax,KnownIndInvs,MustInvariants).
loopinfo$get_must_invariants(LoopInfo,_):-
	LoopInfo = p(_,_,_,_,_,_,_,_,_,_,_,_,MustInvariants),
	var(MustInvariants),
	error_message("loopinfo$get_must_invariants/2 failed\n",[]).	
loopinfo$get_must_invariants(LoopInfo,MustInvariants):-
	LoopInfo = p(_,_,_,_,_,_,_,_,_,_,_,_,MustInvariants).
% We store a bitvector to keep track of which constraint is known to
% be inductive invariant because some external invariant generator
% said that.
loopinfo$update_known_inductive_invariants(user, LoopInfo,  _ , LoopInfo):-!.
loopinfo$update_known_inductive_invariants(invgen, LoopInfo,  NewCL, NewLoopInfo):-
	LoopInfo    = p(NodeId, Depth, FName, PP,
			SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			CL, ML, SiblingMax, OldKnownInductiveInvariants, MustInvariants),
	make_empty_list_if_freevar(OldKnownInductiveInvariants),	
	copy_to_unbound_list(NewCL,L1),
	mark_all_elements(L1),
	copy_to_unbound_list(CL,L2),	
	append(L2,OldKnownInductiveInvariants,L3),
	append(L1,L3,NewKnownInductiveInvariants),
	NewLoopInfo = p(NodeId, Depth, FName, PP,
			SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			CL, ML, SiblingMax, NewKnownInductiveInvariants, MustInvariants).
loopinfo$get_known_inductive_invariants(LoopInfo,  KnownInductiveInvariants):-
	LoopInfo    = p(_,_,_,_,_,_,_,_,_,_,_,KnownInductiveInvariants,_).

#if     defined(DEBUG_USE) || defined(DEBUG_REFINE) || defined(GROUND_EXPLANATION)
% Debugging operations
pretty_printer_minmax_path([],_).
pretty_printer_minmax_path([r(SGA,SGV,SLA,SLV,CL,_ML)|Xs],FName):-
	% FIXME: it may fail since FName is not updated properly. Note
	% that a path can be segment from multiple functions.	
	print_message("BEGIN concrete segment:\n\t",[]),
	pretty_printer_constraints_list(FName,SGA,SGV,SLA,SLV,CL),
	print_message("END concrete segment: \n",[]),	
	pretty_printer_minmax_path(Xs,FName).
pretty_printer_minmax_path([X|Xs],_):-
	print_message("BEGIN abstraction segment:\n",[]),
	loopinfo$pretty_printer(X),
	loopinfo$point(X, FName, _),	
	print_message("END abstraction segment:\n",[]),	
	pretty_printer_minmax_path(Xs,FName).

loopinfo$pretty_printer(p(_,_,FName,_,SGA,SGV,SLA,SLV,
			  ProjCL,ProjML,SiblingMax,KnownIndInv,_)):-
	loopinfo$pretty_printer_aux(ProjCL,ProjML,SiblingMax,KnownIndInv,
				    FName,SGA,SGV,SLA,SLV).
	%pretty_printer_constraints_list(FName,
	% 	 			 SGlobalArr,SGlobalVar,
	% 				 SLocalArr,SLocalVar,
	% 				 ProjCL).
	%print_message("\tBitVector of known inductive invariants: %\n",[KnownIndInv]).

loopinfo$pretty_printer_aux([],[],[],[],_,_,_,_,_).
loopinfo$pretty_printer_aux([C|CL],[M|ML], [SM|SML],[II|IIL],
			    FName,SGA,SGV,SLA,SLV):-
	print_message("\t",[]),
	loopinfo$pretty_printer_bitvector(M),
	loopinfo$pretty_printer_bitvector(SM),	
	loopinfo$pretty_printer_known_ii_bitvector(II),
	pretty_printer_constraints_list(FName,SGA,SGV,SLA,SLV,[C]),
	loopinfo$pretty_printer_aux(CL,ML,SML,IIL,FName,SGA,SGV,SLA,SLV).
	
loopinfo$pretty_printer_bitvector(B):-
	B == o,  !, print_message("max:",[]).
loopinfo$pretty_printer_bitvector(B):-
	B == x,  !, print_message("min:",[]).
loopinfo$pretty_printer_bitvector(B):-
	myvar(B),!.

loopinfo$pretty_printer_known_ii_bitvector(B):-
	B == o, !, print_message("ii:",[]).
loopinfo$pretty_printer_known_ii_bitvector(B):- myvar(B), !.
#endif  /*defined(DEBUG_USE) || defined(DEBUG_REFINE) || defined(GROUND_EXPLANATION)*/

%-----------------------------------------------------------------------------
% Convert LoopStack to only markings and vice versa
%-----------------------------------------------------------------------------
remove_constraints_from_loopstack([], []).
remove_constraints_from_loopstack([r(_SGlobalArr, _SGlobalVar,
                                     _SLocalArr,  _SLocalVar,
                                     _CL, ML)|R], [r(ML)|S]) :-
	remove_constraints_from_loopstack(R, S).
remove_constraints_from_loopstack([LoopInfo|R], [p(ML)|S]) :-
	loopinfo$state(LoopInfo,
	               _SGlobalArr, _SGlobalVar, _SLocalArr, _SLocalVar,
		       _CL, ML),
	remove_constraints_from_loopstack(R, S).

%------------------------------------------------------------------------------
% PathStack ADT (used to keep track of the current symbolic path)
%------------------------------------------------------------------------------
pathstack$push(Elem,Stack,[Elem|Stack]).
%pathstack$pop([_|Stack],Stack).
pathstack$pretty_printer([]):-!.
pathstack$pretty_printer([t(_,_,Id)|Ps]):-
	trans(FName, Id,
	      [PC|_],  _GA,  _GV,  SGA,  SGV,  _LA,  _LV,  SLA,  SLV,
	      [PC1|_], _GA1, _GV1, SGA1, SGV1, _LA1, _LV1, SLA1, SLV1,
	      XCL, [], _ArrRef, _BranchMode),
	print_message("%(% -> %) = ",[FName,PC,PC1]),
	pretty_printer_constraints_list(FName,SGA,SGV,SLA,SLV,
					FName,SGA1,SGV1,SLA1,SLV1,
					XCL),
	!,
	pathstack$pretty_printer(Ps).
pathstack$pretty_printer([r(% callee
			    CalleeFName,
			    SGA0,SGV0,SLA0,SLV0,
			    % caller
			    CallerFName,
			    SGA1,SGV1,SLA1,SLV1,
			    XCL, [PC|_])|Ps]):-	
	print_message("continuation to %::%=",[CallerFName,PC]),
 	pretty_printer_constraints_list(CalleeFName,SGA0,SGV0,SLA0,SLV0,
 					CallerFName,SGA1,SGV1,SLA1,SLV1,
 					XCL),
	!,
 	pathstack$pretty_printer(Ps).
#ifdef  TESTING_CREST
% funcall represents a call, which does not need to be tracked if 
% TESTING_CREST is not defined
pathstack$pretty_printer(funcall,Ps):-
    pathstack$pretty_printer(Ps).
#endif  /*TESTING_CREST*/
		
%==============================================================================
% subsumed: Subsumption checking
%==============================================================================
% Here we check if the "max" interpolant is ok (i.e., the symbolic
% state implies in the logical sense the interpolant stored for a
% sibling node), which means all normal infeasible nodes are
% preserved. If this is the case, we must still update which
% constraints are kept invariant for the subsumed path. Those
% constraints which are not invariant are marked as "mins".
% Otherwise, the algorithm would be incorrect since we may claim some
% constraint is invariant when in fact it's not.
%==============================================================================
mm_subsumed(FName, PP,
	    GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
	    SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	    CL, ML, OutInterp, CallStack, LoopStack, OutLoopContext) :-
	
	mm_basic_subsumed(FName, PP,
			  GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
			  SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			  CallStack,
			  TGlobalArr, TGlobalVar, TLocalArr, TLocalVar,
			  TabledInterp, TabledLoopContext, PPContextSubsumer),
#if     (defined(MINI_DEBUG_USE) || defined(TESTING_CREST))
	print_message("Implication test passed at %:%\n", [FName,PP],green),
	print_message("Checking non-invariant constraints along the subsumed path ...\n",
		      [],green),
#endif 	/*MINI_DEBUG_USE||TESTING_CREST*/	
	%----------------------------------------------------------------------
	% We record which constraints must be abstracted so that the
	% subsumption is correct by finding out which constraints are
	% not invariant anymore along the subsumed path.
        % Very important: update_invariants/20 may fail if a
        % constraint is not invariant but needed to preserve an
        % infeasible path or spurious error (i.e., min/max disagreement).
        %
        % OutInterp is like TabledInterp but possibly strengthened
        % with interpolants from an ancestor looping point (if
        % any). This is possible if subsumption holds between
        % different loop copies.
        %----------------------------------------------------------------------
#ifdef  PROFILE
	update_invariants_profiled(GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
				   SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
				   CL, ML, LoopStack,
				   TGlobalArr, TGlobalVar, TLocalArr, TLocalVar,
				   TabledInterp, TabledLoopContext,
				   OutInterp, OutLoopContext),
#else
        update_invariants(GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
			  SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			  CL, ML, LoopStack,
			  TGlobalArr, TGlobalVar, TLocalArr, TLocalVar,
			  TabledInterp, TabledLoopContext,
			  OutInterp, OutLoopContext),
#endif  /*PROFILE*/
#ifdef  GRAPHVIZ_USE
	record_sym_graph_subsumed_edge(FName,PP,PPContextSubsumer),
#else
        % To prevent warnings
        PPContextSubsumer=_,
#endif  /*GRAPHVIZ_USE*/
	true.


%-----------------------------------------------------------------------------
% mm_basic_subsumed - subsumption test but without updating invariants
%-----------------------------------------------------------------------------
mm_basic_subsumed(/* in */
		  FName, PP,
		  GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
		  SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		  CallStack,
		  /* out */
		  TGlobalArr, TGlobalVar, TLocalArr, TLocalVar,
		  TMemoedInterp, MemoedLoopContext, PPContextSubsumer) :-
		  
	config_to_index(PP, PPIdx),
	PP = [PPTerm|_],
	simplify_stack(CallStack, SimpleCallStack),
	%----------------------------------------------------------------------	
        % Search in the memo table for an entry that belongs to a
        % sibling node.
	%----------------------------------------------------------------------
#ifdef  PROFILE
	check_t_profiled(NodeId, _PP,
			 PPTerm, PPIdx, FName, PPContextSubsumer,
			 [sinfo(FName, PP)|SimpleCallStack], 			 
			 TGlobalArr, TGlobalVar, TLocalArr, TLocalVar,
			 TMemoedInterp,
			 MemoedLoopContext,_LockedIndexes,_),
#else
	check_t(_NodeId,
		PPTerm, PPIdx, FName, PPContextSubsumer,
		[sinfo(FName, PP)|SimpleCallStack], 			 
	        TGlobalArr, TGlobalVar, TLocalArr, TLocalVar,
		TMemoedInterp,
		MemoedLoopContext,_LockedIndexes,_),
#endif	/*PROFILE*/
	%----------------------------------------------------------------------
	% Checking if current symbolic state implies interpolant 
	%----------------------------------------------------------------------
        wrapper_subsumed_profiled(FName,
				  SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
				  GlobalArr ,GlobalVar ,LocalArr ,LocalVar ,ArrRef,
				  TGlobalArr,TGlobalVar,TLocalArr,TLocalVar,
				  TMemoedInterp),
    NodeId=_, % to avoid warnings
    true.
        
% %==============================================================================
% % subsumption_unsatisfiability, test for unsatisfiability, without
% % actually unifying V with TV (tabled variables).
% %==============================================================================
% #ifdef  PROFILE
% % Who is either 'ancestor' or 'sibling' (for stats)
% % 'sibling' is when we just try to check if the current node is
% %           subsumed (using only max's) by another sibling.
% % 'ancestor' is when the current node is subsumed by another sibling
% %            but we still check with the looping ancestor.
% mm_subsumption_unsatisfiability_profiled(Who,
% 	GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
% 	TGlobalArr, TGlobalVar, TLocalArr, TLocalVar,
% 	TabledInterpCond) :-
% 	ctime(T0),
% 	mm_subsumption_unsatisfiability_profiled_aux(Who,
%  	       GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
%    	       TGlobalArr, TGlobalVar, TLocalArr, TLocalVar,
% 	       TabledInterpCond,T0).	

% mm_subsumption_unsatisfiability_profiled_aux(Who,
% 	GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
%    	TGlobalArr, TGlobalVar, TLocalArr, TLocalVar,
% 	TabledInterpCond,T0):-
% 	mm_subsumption_unsatisfiability(
% 	       GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
% 	       TGlobalArr, TGlobalVar, TLocalArr, TLocalVar,
% 	       TabledInterpCond),	
% 	ctime(T1),
% 	add_counter(max_subsumed_timing_ok,T1-T0),
% 	add_counter_subsumed_ok(Who).
% mm_subsumption_unsatisfiability_profiled_aux(Who,_,_,_,_,_,_,_,_,_,_,T0):- 
% 	ctime(T1),
% 	add_counter(max_subsumed_timing_failed,T1-T0),
%         %----------------------------------------------------------------------
% 	% Problems to catch this profiling info
% 	% (subsumed_failed). Perhaps due to backtracking.
%         %----------------------------------------------------------------------
% 	add_counter_subsumed_failed(Who),
% 	!,
% 	fail.

% add_counter_subsumed_ok(sibling):-
% 	!, add_counter(max_subsumed_ok,1).
% add_counter_subsumed_ok(_):- !.

% add_counter_subsumed_failed(sibling):-
% 	!, add_counter(max_subsumed_failed,1).	
% add_counter_subsumed_failed(_):- !.
% #endif  /*PROFILE*/


% mm_subsumption_unsatisfiability(
% 	GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
% 	TGlobalArr, TGlobalVar, TLocalArr, TLocalVar,
% 	TabledInterpCond) :-
% 	mm_subsumption_satisfiable(
% 	        GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
% 		TGlobalArr, TGlobalVar, TLocalArr, TLocalVar,
% 		TabledInterpCond), !, fail.
% mm_subsumption_unsatisfiability(
% 	_GlobalArr,  _GlobalVar,  _LocalArr,  _LocalVar,  _ArrRef,
% 	_TGlobalArr, _TGlobalVar, _TLocalArr, _TLocalVar,
% 	_TabledInterpCond).

% mm_subsumption_satisfiable(
% 	GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
% 	GlobalArr, GlobalVar, LocalArr, LocalVar, TabledInterpCond) :-
% 	mm_unsatisfiable_disjunction(TabledInterpCond, ArrRef),
% 	!,
% 	fail.
% mm_subsumption_satisfiable(
% 	_GlobalArr, _GlobalVar, _LocalArr, _LocalVar, _ArrRef,
% 	_GlobalArr, _GlobalVar, _LocalArr, _LocalVar, _TabledInterpCond).

%%%
% FIXME: this should be integrated in tracer_solver.clp.gpp or
% tracer_interpolation_basic.clp.gpp
%%%
%==============================================================================
% mm_unsatisfiable_disjunction
%==============================================================================
% Test if a list of constraints, interpreted as a disjunction is
% satisfiable, without propagating evaluation of constraints. Assume
% that array constraints have been previously treated to avoid
% constraint_symbolic/3 failing.
%==============================================================================
mm_unsatisfiable_disjunction(InterpCond, ArrRef) :-
	mm_satisfiable_disjunct(InterpCond, ArrRef),
	!,
	fail.
mm_unsatisfiable_disjunction(_,_).

mm_satisfiable_disjunct([C|_], ArrRef) :-
% FIXME: for some reason this predicate cannot be used here
%	constraint_symbolic_arrays_SAT_check_form(C, ArrRef, ArrRef1),
	constraint_symbolic(C, ArrRef, ArrRef1),
	satisfiable_array_references(ArrRef1),
        !.
mm_satisfiable_disjunct([_|R], ArrRef) :-
	mm_satisfiable_disjunct(R, ArrRef).

%==============================================================================
% update_invariants
%==============================================================================
% Identify which constraints are not invariant along the subsume
% path. If one of the constraint is a "max" (i.e., needed for
% preserving false paths or spurious errors) then this predicate fails
% which means that subsumption will not hold.
%
% Basically, there are two cases:
% Inside the same copy of a loop (2nd rule) or between different
% copies of a loop (3rd rule)
%==============================================================================
#ifdef  PROFILE
%------------------------------------------------------------------------------
% Wrapper for update_invariants/20 to record some profiling info.
%------------------------------------------------------------------------------
update_invariants_profiled(GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
			   SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			   CL, ML, LoopStack,
			   TGlobalArr, TGlobalVar, TLocalArr, TLocalVar,
			   TabledInterp, TabledLoopContext,
			   OutInterp   , OutLoopContext):-
	ctime(T0),
	update_invariants_profiled_aux(
		           GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
			   SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		           CL, ML, LoopStack,
			   TGlobalArr, TGlobalVar, TLocalArr, TLocalVar,
			   TabledInterp, TabledLoopContext,
			   OutInterp   , OutLoopContext,T0).

update_invariants_profiled_aux(
			   GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
			   SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			   CL, ML, LoopStack,
			   TGlobalArr, TGlobalVar, TLocalArr, TLocalVar,
			   TabledInterp, TabledLoopContext,
			   OutInterp   , OutLoopContext,T0):-	
	update_invariants(GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
			  SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			  CL, ML, LoopStack,
			  TGlobalArr, TGlobalVar, TLocalArr, TLocalVar,
			  TabledInterp, TabledLoopContext,
			  OutInterp   , OutLoopContext),
	ctime(T1),
	add_counter(min_subsumed_timing_ok,T1-T0),
	add_counter(min_subsumed_ok,1).
update_invariants_profiled_aux(_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_,T0):-	
	ctime(T1),
	add_counter(min_subsumed_timing_failed,T1-T0),
	add_counter(min_subsumed_failed,1),
	!,
	fail.
#endif  /*PROFILE*/

update_invariants(_GlobalArr, _GlobalVar, _LocalArr, _LocalVar, _ArrRef,
		  TGlobalArr, TGlobalVar, TLocalArr, TLocalVar, 
		  _CL, _ML, _LoopStack,
		  TGlobalArr, TGlobalVar, TLocalArr, TLocalVar,
		  TabledInterp, lc_null, TabledInterp, []) :-
	%----------------------------------------------------------------------
	% The first case, when the subsuming node has no loop context.
	% We simply unify TV with the symbolic variables of the current state.
	%----------------------------------------------------------------------
	debug_message("\tDo nothing else: subsuming node is not under scope of a loop.\n",
		      []),
	!.
update_invariants(_GlobalArr, _GlobalVar, _LocalArr, _LocalVar, _ArrRef,
		  TGlobalArr, TGlobalVar, TLocalArr, TLocalVar,
		  CL, ML, LoopStack,
		  TGlobalArr, TGlobalVar, TLocalArr, TLocalVar,
		  TabledInterp,  lc(ANodeId, ADepth, AMTList),
		  TabledInterp, [lc(ANodeId, ADepth, MLMTList)]) :-
	%----------------------------------------------------------------------
	% Note that we return the loop context of the subsuming node
	%----------------------------------------------------------------------
	push_minmax_segment_path(TGlobalArr, TGlobalVar, TLocalArr, TLocalVar,
				 CL, ML,
				 LoopStack, Path),
	debug_message("\tUnder scope of a loop: common ancestor found.\n", []),	
	%----------------------------------------------------------------------
	% We attempt to find common ancestor looping point in LoopInfo, with
	% PathCL the symbolic constraints from the ancestor to the current
	% node.
	%----------------------------------------------------------------------
	find_loop_info_with_nodeid(ANodeId, Path, LoopInfo),
	!,
	mark_more_min(AMTList, Path, LoopInfo, MLMTList).
update_invariants(GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
		  SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		  _CL, _ML, _LoopStack,
		  TGlobalArr, TGlobalVar, TLocalArr, TLocalVar,
		  TabledInterp , lc(ANodeId, _ADepth, AMTList),
		  OutInterp    , []) :-
	%----------------------------------------------------------------------
	% We did not find the looping ancestor: This is of different
	% looping instance.
	%
	% Here we try to learn from the ancestor of the subsuming node on
	% the locked predicates that we need to respect.
	% We access the looping ancestor of the subsuming node to get the
	% indexes of locked constraints
	%----------------------------------------------------------------------
	debug_message("\tUnder scope of a loop: no common ancestor found.\n", []),
	check_t(ANodeId,
		_PP,_PPIdx, FName, _PPContext, _CallStack,
	        _TGlobalArr, _TGlobalVar, _TLocalArr, _TLocalVar,
		_TabledInterp, _TabledLoopContext,
		LockedIndexes,
		_Answer),	
	debug_message("\tFound looping ancestor with locked indexes %\n",
		      [LockedIndexes]), 
	%----------------------------------------------------------------------
	% Construct subsumption-check condition using min information
	% of the subsuming node (ATMList) and indexes of locked
	% constraints of the looping ancestor of the subsuming node
	% (LockedIndexes), and test the unsatisfiability.
	%
	%            c 
	%           /\
	%          /  \ 
	%         /\   \
	%        p  \   \p'
	%       / \  x
	%      /___\
	%   
	% p and p' are the same program point in different copies of
	% the same loop. At this point the context at p' is stronger
	% than the interpolant stored at p. Furthermore, we need to
	% test that the context at p' is also stronger than the
	% interpolant generated from the locked constraints at c
	% (generated by build_subsuming_state/3)
	%----------------------------------------------------------------------
	build_subsuming_state(AMTList, LockedIndexes, AncestorInterp),
        wrapper_subsumed_profiled(FName,
				  SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
				  GlobalArr ,GlobalVar ,LocalArr ,LocalVar ,ArrRef,
				  TGlobalArr,TGlobalVar,TLocalArr,TLocalVar,
				  AncestorInterp),	
% #ifdef  PROFILE
% 	mm_subsumption_unsatisfiability_profiled(ancestor,
% 		GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
% 		TGlobalArr, TGlobalVar, TLocalArr, TLocalVar, InterpCond1),
% #else
% 	mm_subsumption_unsatisfiability(
% 		GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
% 		TGlobalArr, TGlobalVar, TLocalArr, TLocalVar, InterpCond1),
% #endif  /*PROFILE*/	
	%----------------------------------------------------------------------
	% We add the dynamically-generated interpolant to output interpolant
	%----------------------------------------------------------------------
	append(TabledInterp, AncestorInterp, OutInterp).

%------------------------------------------------------------------------------ 
% mark_more_min(+,?,?,-)
%------------------------------------------------------------------------------ 
% We mark more min's to force subsumption within a loop
%------------------------------------------------------------------------------ 
% * MTList: Given a program point p, it's a list of pairs <I,NegInt>
%   where I is the index of a projected constraint of the looping
%   ancestor (LoopInfo) and NegInt is the negated condition for p.
% * Path: is the path from the looping ancestor (LoopInfo) to the current
%   subsuming node.
% * LoopInfo: is the projected state at the looping ancestor.
% * MLMTList has the same length than MTList but with some elements
%   marked as min's (x)
%%------------------------------------------------------------------------------ 
mark_more_min(MTList, Path, LoopInfo, MLMTList) :-
	loopinfo$state(LoopInfo, 
	               ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
		       ACL, AML),
	loopinfo$nodeid(LoopInfo, ANodeId),
	loopinfo$depth(LoopInfo, ADepth),
	loopinfo$siblingmax(LoopInfo, ASiblingMax),
	loopinfo$point(LoopInfo, FName, PP),
	loopinfo$get_known_inductive_invariants(LoopInfo, KnownIndInvs),
#ifdef  PROFILE
% Temporary sanity check
	sanity_check_same_length(ACL,KnownIndInvs),
#endif 	/*PROFILE*/
        % pretty_printer_constraints_list(FName,
	% 				ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
	% 				ACL),
	% print_message("% % % \n",[ACL, AML, ASiblingMax]),
	mark_more_min_aux(1, ANodeId, ADepth, FName, PP,
	                  ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
			  ACL, AML, ASiblingMax, KnownIndInvs,
			  Path, MTList, MLMTList).

mark_more_min_aux(_N, _ANodeId, _ADepth, _FName, _PP,
	          _ASGlobalArr, _ASGlobalVar, _ASLocalArr, _ASLocalVar,
		  [], [], [], [], _Path, [], []) :-
	%----------------------------------------------------------------------
	% Note that we simply succeed when the Min testlist is empty.
	% This automatically handles the case when both points, though
	% they share a looping ancestor, are continuations of the loop, and
	% not of the loop body themselves. Because they are continuations of
	% the loop, the Min testlist would be empty, and in effect we would
	% only check subsumption of normal interpolant (1).
	%----------------------------------------------------------------------
	true.
%%%
%% It's commented because it doesn't solve the problem in general.
%%%
% % Special case
% mark_more_min_aux(N, ANodeId, ADepth, FName, PP,
% 	          ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
% 		  [_|R], [_|S], [_|T], [KnownII|KIIs], 
% 		  Path,
% 		  [_|MTList],
% 	          MLMTList) :-
% 	%% We know the constraint is always invariant because some
% 	%% oracle said that. Therefore, we don't need to mark any
% 	%% min's.
% 	KnownII==o,!,
% 	mark_more_min_aux(N+1, ANodeId, ADepth, FName, PP, 
% 	                  ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
% 			  R, S, T, KIIs,
%                           Path, MTList, MLMTList).
mark_more_min_aux(N, ANodeId, ADepth, FName, PP,
	          ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
		  [AC|R], [M|S], [SibM|T], [_KnownII|KIIs], 
		  Path,
		  [mt(N, NegImplied)|MTList],
	          [mt(N, LoopStackML)|MLMTList]) :-	
	%----------------------------------------------------------------------
	% This is the case when we have a constraint locked by a
	% sibling or uncle/aunt. In this case, the invariance test
	% must succeed so that subsumption can hold.
        %
	% The case of marking  'o' (lock) is possible as the constraint
        % gets locked by a path AFTER tested individually invariant by a
        % another path.
	%----------------------------------------------------------------------
        var(M), SibM==o,
	!,
	%----------------------------------------------------------------------
	% Note: If ii_segment/12 fails then subsumption must fail due
	% to a conflict. The sibling or uncle said locked but the
	% current node needs a min to get closure.
	%
	% Otherwise, ii_segment/12 succeeds if the constraint is
	% invariant. In that case, LoopStackML contains an interpolant
	% to keep invariance.
	%----------------------------------------------------------------------
	ii_segment(ANodeId, ADepth, FName, PP,
	           ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
	           AC, Path, NegImplied,
		   LoopStackML),
	mark_more_min_aux(N+1, ANodeId, ADepth, FName, PP, 
	                  ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
			  R, S, T, KIIs,
                          Path, MTList, MLMTList).
mark_more_min_aux(N, ANodeId, ADepth, FName, PP,
	          ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
	          [AC|R], [M|S], [_|T], [_KnownII|KIIs], 
		  Path,
		  [mt(N, NegImplied)|MTList],
	          [mt(N, LoopStackML)|MLMTList]) :-
	%----------------------------------------------------------------------
	% This is the case when we have an unmarked constraint (i.e.,
	% neutral) that is subsumed (guarantees itself hold at the end
	% of loop)
	%----------------------------------------------------------------------
        var(M),
	%----------------------------------------------------------------------
	% Still, we need to call ii_segment/12 to record which
	% constraints are not invariant anymore along the subsumed
	% path. Note that if ii_segment/12 fails we can still try next
	% clause.
	%----------------------------------------------------------------------
	% print_message("Checking if \n",[]),
	% pretty_printer_constraints_list(FName,
	% 				ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
	% 				AC),
	% pretty_printer_constraints_list(FName,
	% 				ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
	% 				NegImplied),
	% print_message(" are unsat \n",[]),
	
	ii_segment(ANodeId, ADepth, FName, PP,
	           ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
	           AC, Path, NegImplied,		   
		   LoopStackML),
	!,
	% print_message("They are!\n",[]),
	mark_more_min_aux(N+1, ANodeId, ADepth,  FName, PP,
	                  ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
	                  R, S, T, KIIs, 
                          Path, MTList, MLMTList).
mark_more_min_aux(N, ANodeId, ADepth, FName, PP,
	          ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
	          [_|R], [M|S], [_|T], [_KnownII|KIIs], 
		  Path,
                  [mt(N, _)|MTList], MLMTList) :-
	%----------------------------------------------------------------------
	% Here record that the constraint is not invariant because
	% previous clause failed. Then, we mark the constraint as min.
	%----------------------------------------------------------------------	
        var(M),
	!,
	current_tracer_flag(allow_become_non_invariant_to_subsume,y),
	M=x,
#ifdef  GROUND_EXPLANATION
	print_message("\tConstraint #% is not invariant anymore\n",[N]),
#else
	debug_message("\tForced subsumption:\n\t\tBut constraint #% is not invariant anymore\n",
		      [N]),
#endif  /*GROUND_EXPLANATION*/
#ifdef  PROFILE	
	add_counter(num_forced_subsumptions,1),
#endif  /*PROFILE*/	
	mark_more_min_aux(N+1, ANodeId, ADepth, FName, PP,
	                  ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
	                  R, S, T, KIIs, 
			  Path,
			  MTList, MLMTList).
mark_more_min_aux(N, ANodeId, ADepth, FName, PP,
	          ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
	          [_|R], [M|S], [_|T], [_KnownII|KIIs], 
		  Path,
                  [mt(N, _)|MTList], MLMTList) :-
	%----------------------------------------------------------------------
	% Here record that the constraint is not invariant because
	% previous clause failed. Then, we mark the constraint as min.
	%----------------------------------------------------------------------	
        var(M),
	!,
	current_tracer_flag(allow_become_non_invariant_to_subsume,y),
	M=x,
#ifdef  GROUND_EXPLANATION
	print_message("\tConstraint #% is not invariant anymore\n",[N]),
#else
	debug_message("\tForcing subsumption:\n\t\tBut constraint #% is not invariant anymore\n",
		      [N]),
#endif  /*GROUND_EXPLANATION*/
#ifdef  PROFILE	
	add_counter(num_forced_subsumptions,1),
#endif  /*PROFILE*/	
	mark_more_min_aux(N+1, ANodeId, ADepth, FName, PP,
	                  ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
	                  R, S, T, KIIs, 
			  Path,
			  MTList, MLMTList).
% Note: we could collapse these two last cases. We leave them separate
% for clarity.
mark_more_min_aux(N, ANodeId, ADepth, FName, PP,
	          ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
	          [_|R], [_|S], [_|T], [_KnownII|KIIs], 
		  Path,
		  [mt(N, _)|MTList], MLMTList) :-
	%----------------------------------------------------------------------
	% This is the case when there is an interpolant for the constraint,
	% but the constraint is already marked 'x' (We never mark 'o' in the
        % Min information (MinML)),
	% Here we don't care whether the constraint is guaranteed to hold at
        % the end of loop or not.
	%----------------------------------------------------------------------
	!,
	mark_more_min_aux(N+1, ANodeId, ADepth, FName, PP,
	                  ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
	                  R, S, T, KIIs, Path, MTList, MLMTList).
mark_more_min_aux(N, ANodeId, ADepth, FName, PP,
	          ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
	          [_|R], [_|S], [_|T], [_KnownII|KIIs], 
		  Path,
		  MTList, MLMTList) :-
	%----------------------------------------------------------------------
        % Remaining case: When there is no interpolant for the constraint.
	% It is necessarily marked for deletion ('x') in MinML.
	%----------------------------------------------------------------------
	mark_more_min_aux(N+1, ANodeId, ADepth, FName, PP,
	                  ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
	                  R, S, T, KIIs, Path, MTList, MLMTList).
			  
%------------------------------------------------------------------------------
% build_subsuming_state(+,+,-)
%------------------------------------------------------------------------------
% Construct subsumption-check condition using min information of the
% subsuming node and indexes of locked constraints of the looping ancestor
% of the subsuming node.
%------------------------------------------------------------------------------
build_subsuming_state(AMTList, LockedIndexes, InterpCond) :-
	build_subsuming_state_aux(AMTList, LockedIndexes, [], InterpCond).

build_subsuming_state_aux([], [], InterpCond, InterpCond).
build_subsuming_state_aux([mt(N, NegC)|R], [N|S],
			  InInterpCond, OutInterpCond) :-
	!,
	debug_message("\tAdding % with condition % into subsumption test\n",
		      [N, NegC]),
	append(NegC, InInterpCond, InterpCond1),
	build_subsuming_state_aux(R, S, InterpCond1, OutInterpCond).
build_subsuming_state_aux([mt(M, _)|R], [N|S], InInterpCond, OutInterpCond) :-
	M<N, !,
	build_subsuming_state_aux(R, S, InInterpCond, OutInterpCond).

%==============================================================================
% Code for computing interpolants for infeasible paths and subsumed
% paths. Here we distinghish between basic method (projected unsat
% cores) and other methods (e.g., weakest preconditions).
%==============================================================================
	
% -----------------------------------------------------------------------------
% mm_create_infeasible_interpolant
% -----------------------------------------------------------------------------
% Create an interpolant for an infeasible path and assert a fact so
% that the interpolant can be propagated to the parent.
% -----------------------------------------------------------------------------
mm_create_infeasible_interpolant(FName, NodeId, Depth,
				 SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
				 CL, ML, XCL, LoopStack, LoopContext):-
 	%----------------------------------------------------------------------
 	% The use of make_singleton_dnf/2 is vital to tell
 	% interpolate_constraints_path that interpret XCL as a
 	% conjunction of positive literals.
 	%----------------------------------------------------------------------
        make_singleton_dnf(XCL, IntpCond),

	% This predicate computes the classical project unsat core.
	mm_interpolate(FName, Depth, 
		       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		       CL, ML, LoopStack, IntpCond, FlattenedCL, FlattenedML),

	% print_message("******************************************\n",[]),
	% NewLoopStack = [r(SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,CL, ML)|LoopStack],
	% pretty_printer_minmax_path(NewLoopStack,FName),
	% print_message("GUARD: \n",[]),
	% pretty_printer_constraints_list(FName,
	%  				SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	%  				XCL),
	% print_message("Flattened constraints\n",[]),
	% pretty_printer_constraints_list(FName,
	%  				SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	%  				FlattenedCL),
	% print_message("Flattened bitvector: % \n",[FlattenedML]),
	% print_message("******************************************\n",[]),
		
	% This predicate computes other interpolants (e.g., weakest
	% preconditions). It must be called **after** mm_interpolate
	% since it uses unsat cores computed by it.
	interp_gen_infeasible_path(FName,
   				   SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
   				   FlattenedCL, FlattenedML, XCL, OutIntp),
#ifdef  DEBUG_USE	
 	pretty_printer_interp(FName,Depth,
			      'Other interpolant (e.g., wp) from infeasible path:',
 			      SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
 			      OutIntp),
#endif  /*DEBUG_USE*/		
	store_answer(NodeId, Depth, FName,
		     CL, ML, OutIntp , LoopStack, LoopContext),
%	print_message("%\n",[store_answer(NodeId, Depth, FName,
%		     CL, ML, OutIntp , LoopStack, LoopContext)]),
        !.	

%-----------------------------------------------------------------------------
% mm_create_subsumed_interpolant
%-----------------------------------------------------------------------------
% Create an interpolant for a subsumed path using the interpolant from
% the subsuming path and store the interpolant in order to be
% propagated to the parent.
%-----------------------------------------------------------------------------
mm_create_subsumed_interpolant(FName, NodeId, Depth,
			       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			       LastSegCL, LastSegML, IntpCond, LoopStack, LoopContext):-
	current_tracer_flag(other_interp,y),
	current_tracer_flag(other_interp_method,rybal),
	!,
	%--------------------------------------------------------------------
	% Here we need to flatten the whole path
	%--------------------------------------------------------------------	
	mm_flatten_path(FName, Depth,
			SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			LastSegCL, LastSegML, LoopStack,
			FlattenedCL, FlattenedML),
	interp_create_subsumed_interpolant(FName,
					   SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
					   FlattenedCL, FlattenedML,
					   TGlobalArr, TGlobalVar, TLocalArr, TLocalVar,
					   IntpCond, OutIntp),
	TGlobalArr=SGlobalArr,TGlobalVar=SGlobalVar,
	TLocalArr =SLocalArr ,TLocalVar =SLocalVar,
#ifdef  DEBUG_USE	
 	pretty_printer_interp(FName,Depth,
			      'Other interpolant (e.g., wp) from subsumed path:',
 			      SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
 			      OutIntp),
#endif  /*DEBUG_USE*/
	store_answer(NodeId, Depth, FName,
		     LastSegCL, LastSegML, OutIntp, LoopStack, LoopContext),
        !.
mm_create_subsumed_interpolant(FName, NodeId, Depth,
			       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			       CL, ML, IntpCond, LoopStack, LoopContext):-
	current_tracer_flag(other_interp,y),
	!,
	% At this point we know the interpolant is weakest
	% preconditions
	
	%-------------------------------------------------------------------%
	% Here we don't need to flatten the whole path because under
	% weakest preconditions the only thing we do is to negate
	% IntpCond.
	%-------------------------------------------------------------------%	
	interp_create_subsumed_interpolant(FName,
					   SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
					   CL, ML,
					   TGlobalArr, TGlobalVar, TLocalArr, TLocalVar,
					   IntpCond, OutIntp),
	TGlobalArr=SGlobalArr,TGlobalVar=SGlobalVar,
	TLocalArr =SLocalArr ,TLocalVar =SLocalVar,
#ifdef  DEBUG_USE	
 	pretty_printer_interp(FName,Depth,
			      'Other interpolant (e.g., wp) from subsumed path:',
 			      SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
 			      OutIntp),
#endif  /*DEBUG_USE*/
        store_answer(NodeId, Depth, FName,
		     CL, ML, OutIntp, LoopStack, LoopContext),
        !.
mm_create_subsumed_interpolant(FName, NodeId, Depth,
			       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			       CL, ML, InterpCond0, LoopStack, LoopContext):-
        %--------------------------------------------------------------------------%
        % The use of make_dnf/2 is vital so that
        % interpolate_constraints_path interprets the interpolant from
        % the subsuming node as a disjunction of negated
        % literals. Then, the final interpolant returned will be those
        % constraints from CL which in conjunction with **each**
        % single disjunction is unsatisfiable.
        %--------------------------------------------------------------------------%
	make_dnf(InterpCond0, IntpCond),	
	% This predicate computes the classical project unsat core.	
	mm_interpolate(FName, Depth, 
		       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		       CL, ML, LoopStack, IntpCond,_,_),
	store_answer(NodeId, Depth, FName,
		     CL, ML, _OutIntp, LoopStack, LoopContext),
        !.
	
%----------------------------------------------------------------------------------%
% mm_interpolate(+FName,+Depth,+SGlobalArr,...,
%                +LastSegCL,+LastSegML,?LoopStack,+IntpCond,
%                -FlattenedCL,-FlattenedML)
%----------------------------------------------------------------------------------%
% This version is used both for computing interpolants for infeasible
% paths and subsumed paths. An interpolant is here a projected
% unsat core (identified by bitvector ML)
%
% For efficiency, it does also the job of mm_flatten_path/11.
%----------------------------------------------------------------------------------%
mm_interpolate(_, _, _, _, _, _, _, _, _, [],[],[]) :- !.	       
mm_interpolate(FName, Depth,
	       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	       LastSegCL, LastSegML, LoopStack, IntpCond,
	       FlattenedCL, FlattenedML) :-
	push_minmax_segment_path(SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
				 LastSegCL, LastSegML, LoopStack, Path),
#ifdef  DEBUG_USE	
        pretty_printer_minmax_path(Path,FName),
#endif  /*DEBUG_USE*/
	mm_interpolate_path(Path, FName, Depth, IntpCond,
			    FlattenedCL0, FlattenedML0),
	append(LastSegCL,FlattenedCL0,FlattenedCL),
	append(LastSegML,FlattenedML0,FlattenedML).	

%----------------------------------------------------------------------------------%
% mm_interpolate_path(?Path,+FName,+Depth,+IntpCond,-FlattenedCL,-FlattenedML)
%----------------------------------------------------------------------------------%
mm_interpolate_path([r(SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,CL, ML)],
		    FName, _Depth, IntpCond,
		    FlattenedCL, FlattenedML) :-
	interpolate_constraints_path(IntpCond, CL, ML, no_check),
#ifdef  DEBUG_USE
        print_message("\tFinding interpolant I from A and B unsat ...\n",[]),
	print_message("\tB:",[]),
        pretty_printer_constraints_list(FName,
					SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
					IntpCond),
        print_message("\tA:",[]),	
        pretty_printer_constraints_list(FName,
					SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
					CL),
	print_message("\tI:",[]),	
	pretty_printer_marked_constraints(FName,
					  CL,ML,
					  SGlobalArr, SGlobalVar, SLocalArr, SLocalVar),
#else
        % To avoid warnings
        FName=_,SGlobalArr=_,SGlobalVar=_,SLocalArr=_,SLocalVar=_,
#endif 	/*DEBUG_USE*/
        FlattenedCL = [],
	FlattenedML = [],
	!.
mm_interpolate_path(Path, FName, Depth, IntpCond,
		    FlattenedCL, FlattenedML) :-
	find_next_min(Path, NextLoopInfo, CL, ML, RestPath),
	loopinfo$state(NextLoopInfo,
	               SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		       MinCL, MinML),
	!,
	%----------------------------------------------------------------------
	% In generating interpolants we should only consider constraints that
	% are not already deleted by sibling min information.
	%----------------------------------------------------------------------
	select_non_deleted_constraints(MinCL, MinML, MinCL1, MinML1, _),
	merge_constraints_paths(CL, ML, MinCL1, MinML1, NewCL, NewML),		
	interpolate_constraints_path(IntpCond, NewCL, NewML, no_check),
#ifdef  DEBUG_USE
        print_message("\tFinding interpolant I from A and B unsat ...\n",[]),
	print_message("\tB:",[]),
        pretty_printer_constraints_list(FName,
					SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
					IntpCond),
        print_message("\tA:",[]),	
        pretty_printer_constraints_list(FName,
					SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
					NewCL),
	print_message("\tI:",[]),
	pretty_printer_marked_constraints(FName,
					  NewCL,NewML,
					  SGlobalArr, SGlobalVar, SLocalArr, SLocalVar),
#else
        % To avoid warnings
        FName=_,SGlobalArr=_,SGlobalVar=_,SLocalArr=_,SLocalVar=_,
#endif 	/*DEBUG_USE*/
	%----------------------------------------------------------------------	
	% Generate updated condition for interpolation
	%----------------------------------------------------------------------	
        select_marked_constraints_path(MinCL1, MinML1, LockedMinCL, o),
	negate_numerical_list(LockedMinCL, NextIntpCond),
        make_dnf(NextIntpCond, NextIntpCond1),		
	mm_interpolate_path(RestPath, FName, Depth, NextIntpCond1,
			    PrefixFlattenedCL,PrefixFlattenedML),
	append(MinCL1 /*NewCL*/,PrefixFlattenedCL,FlattenedCL),
	append(MinML1 /*NewML*/,PrefixFlattenedML,FlattenedML).


%----------------------------------------------------------------------------%
% mm_flatten_path(+FName,+Depth,+SGlobalArr,...,+LastSegCL,+LastSegML,+LoopStack,
%                 -FlattenedCL,-FlattenedML)
%----------------------------------------------------------------------------%
mm_flatten_path(_,_,_,_,_,_,LastSegCL,LastSegML,[],LastSegCL,LastSegML) :- !.	       
mm_flatten_path(FName, Depth,
		SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		LastSegCL, LastSegML, LoopStack, FlattenedCL, FlattenedML) :-	
	push_minmax_segment_path(SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
				 LastSegCL, LastSegML, LoopStack, Path),
	mm_flatten_path_aux(Path, FName, Depth, FlattenedCL0, FlattenedML0),
	append(LastSegCL,FlattenedCL0,FlattenedCL),
	append(LastSegML,FlattenedML0,FlattenedML).	

%----------------------------------------------------------------------------%
% mm_flatten_path_aux(+Path,+FName,+Depth,-FlattenedCL,-FlattenedML)
%----------------------------------------------------------------------------%
mm_flatten_path_aux([r(_,_,_,_,_,_)],_,_,[],[]):- !.		
mm_flatten_path_aux(Path, FName, Depth, FlattenedCL, FlattenedML) :-		
	find_next_min(Path, NextLoopInfo, _CL, _ML, RestPath),
	loopinfo$state(NextLoopInfo,
	               _SGlobalArr, _SGlobalVar, _SLocalArr, _SLocalVar,
		       MinCL, MinML),
	!,
	select_non_deleted_constraints(MinCL, MinML, MinCL1, MinML1, _),
	mm_flatten_path_aux(RestPath,FName,Depth,PrefixFlattenedCL,PrefixFlattenedML),
	append(MinCL1,PrefixFlattenedCL,FlattenedCL),
	append(MinML1,PrefixFlattenedML,FlattenedML).

%-----------------------------------------------------------------------------
% select_non_deleted_constraints(+,+,-,-,-)
% Pick constraints that are not marked 'x'.
%-----------------------------------------------------------------------------
select_non_deleted_constraints(CL, ML, OutCL, OutML, OutIndices) :-
	select_non_deleted_constraints_aux(1, CL, ML, OutCL, OutML, OutIndices).

select_non_deleted_constraints_aux(_N, [], [], [], [], []).
select_non_deleted_constraints_aux(N, [_|R], [X|S], T, U, V) :-
	X==x, !,
	select_non_deleted_constraints_aux(N+1, R, S, T, U, V).
select_non_deleted_constraints_aux(N, [C|R], [M|S], [C|T], [M|U], [N|V]) :-
	select_non_deleted_constraints_aux(N+1, R, S, T, U, V).


%==============================================================================
% Subroutine for handling looping points
%==============================================================================
% A looping point is the source node of a backedge and its ancestor is
% the destination. Note that even if a looping point belongs to a
% single backedge, we may have multiple ancestors due to loop
% unrollings
%==============================================================================
mm_unfold_loop(NodeId, Depth, Id, FName, PP, 
	       _GlobalArr, _GlobalVar, _LocalArr, _LocalVar,
	       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	       CL, ML, _CallStack, _ArrRef, Loops, _TableSpace,
	       LoopStack, _PathStack, _AbsPtFlag) :-	       
	unfold_loop_ii(NodeId, Depth, FName, PP, 
	               SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		       CL, ML, LoopStack),
	%----------------------------------------------------------------------%
	% Case: here loop invariant generation succeed!
	%----------------------------------------------------------------------%	
#ifdef  GRAPHVIZ_USE
        get_ancestor_pp_context(FName,PP,Loops,PostPPContext),
        push_context_stack(FName,PostPPContext),
        record_sym_graph_edge(feasible,
 			      src(FName ,PP,
 				  SGlobalArr,SGlobalVar,SLocalArr,SLocalVar),
 			      dest(FName,PP,
 				   SGlobalArr,SGlobalVar,SLocalArr,SLocalVar),
 			      Id,[],not_branch,Loops),
	pop_context_stack,
#else
        % To avoid warnings
        Id=_,Loops=_,
#endif  /*(defined(GRAPHVIZ_USE))*/
	!,
	fail.
mm_unfold_loop(NodeId, Depth, _Id, FName, PP, 
	       GlobalArr, GlobalVar, LocalArr, LocalVar,
	       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	       CL, ML, CallStack, ArrRef, Loops, TableSpace, 
	       LoopStack, PathStack, AbsPtFlag):-
	%----------------------------------------------------------------------
	% Case: first time the loop is explored or loop invariant
	% generation failed due to impossibility of abstracting some
	% locked constraints.
	%----------------------------------------------------------------------
#ifdef  GRAPHVIZ_USE
        %-------------------------------------------------------------------
        % We get the current context value for storing it in the loop stack
        %-------------------------------------------------------------------
        context_value(FName,PP,PPContext),
        loopstack$point_with_context(NewLoop,FName,PP,PPContext),
	NewLoops = [NewLoop|Loops],
#else
        NewLoops = Loops, 
#endif  /*GRAPHVIZ_USE*/
%       pathstack$push(t(FName,PP,Id),PathStack,NewPathStack),
        mm_restart_set_mark,
% #ifdef  MINMAX_CS_REUSE
% 	set_cs_mark,
% 	debug_message("set_cs_mark1 NodeId=% Depth=%\n", [NodeId, Depth]),
% #endif	
	!,	
	unfold_loop_redo_on_conflict(NodeId, Depth, FName, PP, 
				     GlobalArr, GlobalVar, LocalArr, LocalVar,
				     SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
				     CL, ML, CallStack, ArrRef, NewLoops,
				     TableSpace, LoopStack, PathStack, AbsPtFlag).

%-----------------------------------------------------------------------------
% unfold_loop_ii
%-----------------------------------------------------------------------------
% Test if we can produce an invariant for the looping path consisting
% of only individually invariant constraints
%-----------------------------------------------------------------------------
unfold_loop_ii(NodeId, Depth, FName, PP, 
	       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	       CL, ML, LoopStack) :-
	is_cyclic_path(FName, PP, 
		       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		       CL, ML, LoopStack,
		       LoopInfo, Path),
	loopinfo$nodeid(LoopInfo, ANodeId),
	loopinfo$depth(LoopInfo , ADepth),
#ifdef  GROUND_EXPLANATION
    no_compression_after_depth(ADepth),
#endif  /*GROUND_EXPLANATION*/
#if defined(DEBUG_USE) || defined(GROUND_EXPLANATION)
	print_message("\n--- INVGEN: TESTING LOOP INVARIANT CANDIDATES at %@% (Depth %) --- \n",
        [FName,PP,Depth],magenta),
	loopinfo$pretty_printer(LoopInfo),
#endif 	/*defined(DEBUG_USE) || defined(GROUND_EXPLANATION)*/
#ifdef  PROFILE
        ctime(T0),
#endif  /*PROFILE*/
	test_candidate_invariants(FName,
				  SGlobalArr, SGlobalVar,
				  SLocalArr,  SLocalVar,
				  Path, LoopInfo, IICL, MTList),
	!,	
#ifdef  PROFILE
        ctime(T1),
	add_counter(test_candidate_invariants_timing,T1-T0),
#endif  /*PROFILE*/
#if defined(DEBUG_USE) || defined(GROUND_EXPLANATION)
	print_message("--- INVGEN: LOOP INVARIANTS PASSED THE TEST at %@% (Depth %) --- \n\t", 
        [FName,PP,Depth],magenta),
	loopinfo$point(LoopInfo, FName, PP),
	loopinfo$state(LoopInfo,
		       SGlobalArrProj, SGlobalVarProj, SLocalArrProj, SLocalVarProj,
		       _,_),	
	pretty_printer_constraints_list(FName,
					SGlobalArrProj,SGlobalVarProj,
					SLocalArrProj ,SLocalVarProj,
					IICL),
#else
        IICL=_,
#endif 	/*defined(DEBUG_USE) || defined(GROUND_EXPLANATION)*/
#ifdef  PROFILE
	add_counter(num_loop_inv_gen_succeed,1),
#endif
        %----------------------------------------------------------------------
        % Note that MTList can be [] here, but this is still useful to
        % inform that this is a point within a loop.
        %----------------------------------------------------------------------
        % IMPORTANT about LoopContext: it stores for each invariant
        % constraint which other constraints through the path are
        % needed to keep its invariance.  Of course, during the
        % pre-operation those marked constraints will be updated (see
        % pre_loopcontext/8).
        %----------------------------------------------------------------------
        % MTList is of type list(mt(N,list(X))), where:
        % N is the position given for the invariant constraint among
        % all projected candidates.
        % X = r(ML) |  p(ML)
        %----------------------------------------------------------------------
%------------------------------------------------------------------------------
% A loop context is simply a way of keeping track certain dependencies
% so that the update of invariant constraints can be done fast.  Given
% a invariant constraint C we keep track of which other constraints
% must keep invariant so that the invariance of C holds.
%------------------------------------------------------------------------------
	LoopContext = [lc(ANodeId, ADepth, MTList)],
#ifdef  DEBUG_USE
        pretty_printer_invariant_candidates(LoopInfo),
	print_message("\n\tStoring %\n\tas loop context at %:%\n",
		      [LoopContext,FName,PP]),
#endif	/*DEBUG_USE*/
        interp_gen_success_path(SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,Intp),
	store_answer(NodeId, Depth, FName, CL, ML, Intp, LoopStack, LoopContext).
#ifdef  DEBUG_USE
pretty_printer_invariant_candidates(LoopInfo):-
	loopinfo$point(LoopInfo, FName, _),
	loopinfo$state(LoopInfo, SGA, SGV, SLA, SLV, Candidates,_),
	print_message("\tThe invariant candidates have the following order (used for memo): \n",[]),
	pretty_printer_invariant_candidates_aux(Candidates,FName,SGA,SGV,SLA,SLV,0).
pretty_printer_invariant_candidates_aux([],_,_,_,_,_,_).
pretty_printer_invariant_candidates_aux([C|Cs],
					FName,
					SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
					I):-
	I1 = I + 1,
	print_message("\t %:",[I1]),	
 	pretty_printer_constraints_list(FName,
 					SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
 					[C]),
	pretty_printer_invariant_candidates_aux(Cs,
						FName,
						SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
						I1).
#endif  /*DEBUG_USE*/	

%---------------------------------------------------------------------------------%
% get_must_invariants(+,+,+,+,+,+,+,+,+,+,-)
%---------------------------------------------------------------------------------%
% Return a list of constraints that we know for sure they are
% invariants.
%---------------------------------------------------------------------------------%
get_must_invariants(FName, PP, Depth,
		    GlobalArr , GlobalVar , LocalArr , LocalVar , ArrRef,
		    SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		    MustInvariantsCL):-
	% It's possible that even if there is a loop we don't have
	% static information (block/11 facts) about it. E.g., loops
	% via goto's.	
        block(_,FName,PP,_,_,l,_,
	      % bitvector or 'u' (updated) and 'n' (non-updated)
              UpdGlobalArr,UpdGlobalVar,UpdLocalArr,UpdLocalVar),
	!,
	get_must_invariants_aux(FName, PP, Depth,
				GlobalArr , GlobalVar , LocalArr , LocalVar , ArrRef,
				SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
				UpdGlobalArr,UpdGlobalVar,UpdLocalArr,UpdLocalVar,
				MustInvariantsCL).
get_must_invariants(_,_,_,_,_,_,_,_,_,_,_,_,[]):-!.
% Wrapper to catch errors
get_must_invariants_aux(FName, PP, Depth,
			GlobalArr , GlobalVar , LocalArr , LocalVar , ArrRef,
			SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			UpdGlobalArr,UpdGlobalVar,UpdLocalArr,UpdLocalVar,
			MustInvariantsCL):-
	% We cannot use here CL (the list of symbolic constraints)
	% since CL only refers to the last segment. This is why we
	% need to project using all the constraints in the solver
	% store. 
	project_solver_context(state(GlobalArr,GlobalVar,LocalArr,LocalVar,ArrRef),
			       state(SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
				     ProjCL)),
	
	translate_invariant_codings_to_marked_variables(UpdGlobalArr,MarkGlobalArr),
	translate_invariant_codings_to_marked_variables(UpdGlobalVar,MarkGlobalVar),
	translate_invariant_codings_to_marked_variables(UpdLocalArr ,MarkLocalArr),
	translate_invariant_codings_to_marked_variables(UpdLocalVar ,MarkLocalVar),
	abstract_away_variables(FName, PP, Depth,
				SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
				ProjCL, 
				MarkGlobalArr,MarkGlobalVar,MarkLocalArr,MarkLocalVar,
				AbsSGlobalArr,AbsSGlobalVar,AbsSLocalArr,AbsSLocalVar,
				MustInvariantsCL, _AbsArrRef),
	AbsSGlobalArr=SGlobalArr,AbsSGlobalVar=SGlobalVar,
	AbsSLocalArr =SLocalArr ,AbsSLocalVar=SLocalVar,
#ifdef  DEBUG_USE
        print_message("Must invariants:\n\t",[]),
        pretty_printer_constraints_list(FName,
					SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
					MustInvariantsCL),
#endif  /*DEBUG_USE*/
        !.
get_must_invariants_aux(FName,PP,_,_,_,_,_,_,_,_,_,_,_,_,_,_,_):-
	error_message("get_must_invariants_aux/17 failed for loop %::%\n",
		      [FName,PP]).

translate_invariant_codings_to_marked_variables([],[]).
translate_invariant_codings_to_marked_variables([u|Xs],[o|Ys]):-
	translate_invariant_codings_to_marked_variables(Xs,Ys).
translate_invariant_codings_to_marked_variables([n|Xs],[_|Ys]):-
	translate_invariant_codings_to_marked_variables(Xs,Ys).

%----------------------------------------------------------------------%
% This predicate converts all loop invariant candidates which are
% equality constraints into two inequality candidates in order to
% increase the likelihood of being invariants. E.g., i=0; while(*)
% i++; In principle, we generate the candidate set {i=0} which is
% clearly not invariant. This predicate will generate the candidate
% set { i>=0, i<=0 }. The first element is invariant!
%----------------------------------------------------------------------%
convert_equality_candidates_to_inequalities(LoopStack,NewLoopStack):-	
	LoopStack = [LoopInfo|RestLoopStack],
	loopinfo$state(LoopInfo,
		       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		       CL, ML),
#ifdef  PROFILE
        sanity_check_free_list(ML),
#else
        % To avoid warnings
        ML=_,
#endif  /*PROFILE*/
	convert_equality_list2inequality_list(CL,NewCL),
	copy_to_unbound_list(NewCL,NewML),
        loopinfo$replace_state(LoopInfo,
			       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			       NewCL, NewML,NewLoopInfo),
	NewLoopStack = [NewLoopInfo|RestLoopStack],
	!.

#ifdef  PROFILE
sanity_check_free_list(L):- is_free_list(L),!.
sanity_check_free_list(_):-
	error_message("Broken assumption in convert_equality_candidates_to_inequalities/2\n",
		      []).
is_free_list([]).
is_free_list([X|Xs]):- myvar(X), is_free_list(Xs).
#endif  /*PROFILE*/

convert_equality_list2inequality_list([],[]):-!.
convert_equality_list2inequality_list([eq(A,B)|Xs],
				      [eq(A,B)|Ys]):-
	% FIXME: we don't convert equalities that involve array
	% references we get non-termination in cases like
	% test-allzeros-a.c
	A = ref(_,_),!,
	convert_equality_list2inequality_list(Xs,Ys).
convert_equality_list2inequality_list([eq(A,B)|Xs],
				      [eq(A,B), geq(A,B),geq(B,A)|Ys]):-
	convert_equality_list2inequality_list(Xs,Ys).
convert_equality_list2inequality_list([assign(A,B)|Xs],
				      [assign(A,B)|Ys]):-
	% FIXME: we don't convert equalities that involve array
	% references we get non-termination in cases like
	% test-allzeros-a.c.	
	A = ref(_,_),!,
	convert_equality_list2inequality_list(Xs,Ys).
convert_equality_list2inequality_list([assign(A,B)|Xs],
				      [assign(A,B), geq(A,B),geq(B,A)|Ys]):-
	convert_equality_list2inequality_list(Xs,Ys).
convert_equality_list2inequality_list([X|Xs],[X|Ys]):-
	convert_equality_list2inequality_list(Xs,Ys).
			
%------------------------------------------------------------------------------
% unfold_loop_redo_on_conflict
%------------------------------------------------------------------------------
% We add a new segment in the path (projected form) and keep on
% redoing this point while there are conflicts. This call may not
% terminate!
%------------------------------------------------------------------------------
unfold_loop_redo_on_conflict(NodeId, Depth, FName, PP, 
			     GlobalArr, GlobalVar, LocalArr, LocalVar,
			     SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			     CL, ML, CallStack, ArrRef, Loops, TableSpace,
			     LoopStack, PathStack, AbsPtFlag) :-
#ifdef  PROFILE
        ctime(T0),
#endif /*PROFILE*/
	%--------------------------------------------------------------------------%
        % Very important step in minmax: enumeration of loop invariant
        % candidates is done here.
        %--------------------------------------------------------------------------%
	push_minmax_segment_path(NodeId, Depth, FName, PP,
				 GlobalArr ,GlobalVar ,LocalArr ,LocalVar ,ArrRef,
				 SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,CL,ML,LoopStack,
				 OGlobalArr,OGlobalVar,OLocalArr,OLocalVar,OArrRef,
				 OLoopStack),
	%--------------------------------------------------------------------------%
	% FIXME: important step that may increase the likelihood of being invariant.
	% However, we comment it because there are problems with test-loop-16.c
	%--------------------------------------------------------------------------%	
	% convert_equality_candidates_to_inequalities(OLoopStack0,OLoopStack),
	%--------------------------------------------------------------------------%
	% 1st additional step: we keep track of inductive invariant
	% constraints that we know due to external means. Here, we
	% know nothing (empty list).
	% Note 08/01/12: this information is not currently used.
	%--------------------------------------------------------------------------%
        OLoopStack = [LoopInfo|RestOLoopStack],	
	loopinfo$update_known_inductive_invariants(invgen, LoopInfo, [], LoopInfo1),
	%-------------------------------------------------------------------------%
	% 2nd additional step: record those constraints that we know
	% for sure they are invariant. E.g., if a variable is not
	% modified within the loop then its projection must be
	% invariant.
	%-------------------------------------------------------------------------%
	get_must_invariants(FName, PP, Depth,
			    GlobalArr , GlobalVar , LocalArr , LocalVar , ArrRef,
			    SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			    MustInvariantsCL),
	loopinfo$set_must_invariants(LoopInfo1,
				     SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
				     MustInvariantsCL, LoopInfo2),
	%--------------------------------------------------------------------------%	
        OOLoopStack = [LoopInfo2|RestOLoopStack],
#ifdef  PROFILE
        ctime(T1),
	add_counter(enumerate_candidate_invariants_timing,T1-T0),
#endif /*PROFILE*/
	unfold_loop_redo_on_conflict_aux(NodeId, Depth, FName, PP, 
					 OGlobalArr, OGlobalVar, OLocalArr, OLocalVar,
					 SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
					 [], [], CallStack, OArrRef, Loops, TableSpace,
					 OOLoopStack, PathStack, AbsPtFlag).

unfold_loop_redo_on_conflict_aux(NodeId, Depth, FName, PP, 
	GlobalArr, GlobalVar, LocalArr, LocalVar,
	SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	CL, ML, CallStack, ArrRef, Loops, TableSpace,
	LoopStack, PathStack, AbsPtFlag) :-
	mm_unfold_trans(NodeId, Depth, FName, PP,
			GlobalArr, GlobalVar, LocalArr, LocalVar,
			SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			CL, ML, CallStack, ArrRef, Loops, TableSpace,
			LoopStack, PathStack, AbsPtFlag).
unfold_loop_redo_on_conflict_aux(_NodeId, Depth, _FName, _PP,
	_GlobalArr, _GlobalVar, _LocalArr, _LocalVar,
	_SGlobalArr, _SGlobalVar, _SLocalArr, _SLocalVar,
	_CL, _ML, _CallStack, _ArrRef, _Loops, _TableSpace,
	_LoopStack, _PathStack, _AbsPtFlag) :-
	
	is_conflict(Depth),
	%----------------------------------------------------------------------
	% The conflict is located before this loop point: Since the
	% conflict info is asserted after the codespace mark, we need to
	% retract it first before the popping of codespace mark, and assert
	% it back after the popping.
	%----------------------------------------------------------------------
	mm_restart_pop_mark2,	
% #ifdef  MINMAX_CS_REUSE
% 	debug_message("pop_cs_mark2-1 NodeId=% Depth=%\n", [NodeId, Depth]),
% 	pop_cs_mark2,
% #endif	
	!,
	fail.
unfold_loop_redo_on_conflict_aux(NodeId, Depth, FName, PP, 
	GlobalArr, GlobalVar, LocalArr, LocalVar,
	SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	CL, ML, CallStack, ArrRef, Loops, TableSpace,
	LoopStack, PathStack, AbsPtFlag) :-
	%----------------------------------------------------------------------
	% It is important to retract the conflict information first before
	% we pop the codespace mark.
	%----------------------------------------------------------------------
	retract(conflict(Depth, LockML)),
	report_user_if_abstraction_too_weak(FName,PP),
	apply_lock(LoopStack, 
	           GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
	           LockML,
		   NewLoopStack,
		   GlobalArr1, GlobalVar1, LocalArr1, LocalVar1, ArrRef1),
	clear_table(NodeId),
	clear_answer(NodeId, Depth),
	mm_restart_pop_mark,
	mm_restart_set_mark,
% #ifdef  MINMAX_CS_REUSE
% 	debug_message("pop_cs_mark1-2 NodeId=% Depth=%\n", [NodeId, Depth]),
% 	pop_cs_mark,
% 	debug_message("set_cs_mark2 NodeId=% Depth=%\n", [NodeId, Depth]),
% 	set_cs_mark,
% #endif 
	%----------------------------------------------------------------------
	% Inductive invariants make sense only for the original loop
	% (i.e., without loop unrolling). Here, we record that we
	% shouldn't read those invariants for the rest of unrolled versions.
	% Make sure we assert after pop_cs_mark/0 and set_cs_mark/0
	%----------------------------------------------------------------------	
	fassert(disable_inductive_invariants(FName,PP)),
	%----------------------------------------------------------------------
	% We record the history all conflicts. Needed for some
	% refinement heuristics.
	%----------------------------------------------------------------------
	fassert(history_table_of_conflicts(Depth,LockML)),
	%----------------------------------------------------------------------
	% Since this is the case when we process the restarting, we
	% commit to it to disallow it be considered as a succesful traversal
	% at the next clause.
	%----------------------------------------------------------------------
	!,
#ifdef  GROUND_EXPLANATION
    clear_minmax_memory(Depth, CL, ML, Loops, AbsPtFlag, TableSpace, NewLoopStack, PathStack,
        NewCL, NewML, NewLoops, NewAbsPtFlag, NewTableSpace,NewNewLoopStack, NewPathStack),
#else
    NewCL=CL,NewML=ML,NewLoops=Loops,NewAbsPtFlag=AbsPtFlag,NewTableSpace=TableSpace,
    NewNewLoopStack=NewLoopStack,NewPathStack=PathStack,
#endif  /*GROUND_EXPLANATION*/
	%----------------------------------------------------------------------
	% Here we iterate since we can get more than one conflicts
	% The iteration also compounds the locks obtained.
	%----------------------------------------------------------------------
        unfold_loop_redo_on_conflict_aux(NodeId, Depth, FName, PP, 
	        GlobalArr1, GlobalVar1, LocalArr1, LocalVar1,
		SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		NewCL, NewML, CallStack, ArrRef1, NewLoops, NewTableSpace,
		NewNewLoopStack, NewPathStack, NewAbsPtFlag).					 
unfold_loop_redo_on_conflict_aux(_NodeId, _Depth, _FName, _PP, 
				 _GlobalArr, _GlobalVar, _LocalArr, _LocalVar,
				 _SGlobalArr, _SGlobalVar, _SLocalArr, _SLocalVar,
				 _CL, _ML, _CallStack, _ArrRef, _Loops, _TableSpace,
				 _LoopStack, _PathStack, _AbsPtFlag) :-
	%----------------------------------------------------------------------
	% The remaining case where there is no conflict and we simply
	% backtrack: Here we need to preserve the answer
	%----------------------------------------------------------------------
	mm_restart_pop_mark2,
% #ifdef  MINMAX_CS_REUSE			
% 	debug_message("pop_cs_mark2-3 NodeId=% Depth=%\n", [NodeId, Depth]),
% 	pop_cs_mark2,
% #endif  
	!,
	fail.

print_history_of_conflicts:-
	history_table_of_conflicts(Depth,_),
	print_message("Conflict at %\n",[Depth]),
	fail.
print_history_of_conflicts.

%------------------------------------------------------------------------------
% apply_lock
%------------------------------------------------------------------------------
% Reset the abstractions done in the previous iteration and record the
% constraints needed to rule out the Cex. 
%------------------------------------------------------------------------------
apply_lock(LoopStack,
	   GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
	   LockML, 
	   NewLoopStack,
	   GlobalArr1, GlobalVar1, LocalArr1, LocalVar1, ArrRef1) :-
	
	LoopStack = [LoopInfo|LoopStackTail],
	loopinfo$state(LoopInfo,
	               SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		       MinCL, MinML),
#ifdef  GROUND_EXPLANATION
    MinML=_, % to avoid warnings
    LockML=NewMinML,
#else
	%---------------------------------------------------------------------%
	% Step 1: delete those abstractions which conflict with some
	% locked constraints (i.e., those constraints needed to rule
	% out the spurious Cex).
	%---------------------------------------------------------------------%
	remove_min_marking(MinML, LockML, NewMinML),
#endif  /*GROUND_EXPLANATION*/
	loopinfo$replace_state(LoopInfo,
			       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			       MinCL, NewMinML,
			       NewLoopInfo),
	NewLoopStack = [NewLoopInfo|LoopStackTail],
#ifdef  GROUND_EXPLANATION
    loopinfo$siblingmax(LoopInfo, SibMax),
    loopinfo$siblingmax(NewLoopInfo, SibMax),
#else
	%---------------------------------------------------------------------%	
	% Step 2: the loop segment records the "locked" constraints
	%---------------------------------------------------------------------%		
	loopinfo$siblingmax(NewLoopInfo, LockML),
#endif  /*GROUND_EXPLANATION*/
	
	% Update current symbolic state with new min's
	evaluate_abstraction(GlobalArr , GlobalVar , LocalArr , LocalVar,
	                     ArrRef,
			     SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			     [],
			     MinCL, NewMinML,
			     GlobalArr1, GlobalVar1, LocalArr1, LocalVar1,
			     ArrRef1),
	!. 

%-----------------------------------------------------------------------------
% remove_min_markings(+L1,+L2,-L3)
%-----------------------------------------------------------------------------
% L1 is a list with 'x' terms that mean that the corresponding
% constraint was abstracted (min). L2 is a list of 'o' terms that mean
% that the corresponding constraint was locked (max) because it's
% needed to exclude an spurious error. L3 is like L1 but resetting
% those positions which L1 and L2 have 'x' and 'o' terms,
% respectively (i.e., conflict).
%-----------------------------------------------------------------------------
remove_min_marking([], [], []).
remove_min_marking([Min|R], [L|S], [_|T]) :-
	Min == x, L == o, !,
	remove_min_marking(R, S, T).
remove_min_marking([Min|R], [_|S], [Min|T]) :-
	remove_min_marking(R, S, T).

%------------------------------------------------------------------------------
% is_cyclic_path(+,+,+,+,+,+,+,+,+LoopStack,-LoopInfo,-Path)
%------------------------------------------------------------------------------
% LoopInfo is the ancestor looping point and Path is the path from
% that ancestor to the current point.
%------------------------------------------------------------------------------
is_cyclic_path(FName, PP,
	       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar, CL, ML, LoopStack,
	       LoopInfo,
	       NewLoopStack):-
	is_cyclic_path_search_pp(LoopStack, FName, PP, LoopInfo, PathInLoopStack),
	push_minmax_segment_path(SGlobalArr, SGlobalVar, SLocalArr, SLocalVar, CL, ML,
				 PathInLoopStack, NewLoopStack).
is_cyclic_path(_,_,_,_,_,_,_,_,_,_,_):-
	!,
	fail.
	
is_cyclic_path_search_pp([LoopInfo|_], FName, PP,  LoopInfo, [LoopInfo]) :- 
	%----------------------------------------------------------------------
	% Put a cut '!' after this call if we just want to return the
	% nearest looping ancestor.
	%----------------------------------------------------------------------
	loopinfo$point(LoopInfo, FName, PP).
is_cyclic_path_search_pp([MElem|R], FName, PP, OutLoopInfo, [MElem|S]) :-
	is_cyclic_path_search_pp(R, FName, PP, OutLoopInfo, S).

				       				      	
%------------------------------------------------------------------------------
% push_minmax_segment_path
%------------------------------------------------------------------------------
% Project the symbolic state so far and push two elements: p() and r()
% onto LoopStack. The term p() contains the projected state and the
% term r() the symbolic state before projection.
%------------------------------------------------------------------------------
push_minmax_segment_path(SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
			 CL,ML,
			 Path, NewPath):-
	NewPath = [r(SGlobalArr, SGlobalVar, SLocalArr, SLocalVar, CL, ML)|Path].
push_minmax_segment_path(NodeId, Depth, FName, PP,
			 GlobalArr,GlobalVar,LocalArr,LocalVar,ArrRef,
			 SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
			 CL,ML,LoopStack,
			 OGlobalArr,OGlobalVar,OLocalArr,OLocalVar,OArrRef,
			 OLoopStack) :-
	%-----------------------------------------------------------------------
	% Here we need to project the solver context since it will
	% contain, in general, more constraints than CL. Remember CL
	% contains the symbolic constraints only from the last path
	% segment since the last abstraction point.
	%-----------------------------------------------------------------------
 	project_solver_context(state(GlobalArr,GlobalVar,LocalArr,LocalVar,ArrRef),
 			       state(SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,CL1)),
						     
	fcopy_term(t(SGlobalArr, SGlobalVar, SLocalArr, SLocalVar, CL1),
		   t(OGlobalArr, OGlobalVar, OLocalArr, OLocalVar, CL2)),

	% Assume that array constraints have been previously treated to avoid
        % constraint_symbolic/3 failing.	
	constraint_symbolic(CL2, [], OArrRef),
	copy_to_unbound_list(CL1, ML1), 
	%----------------------------------------------------------------------
	% We push incoming context in the stack
	% n for node, p for projection, r for relation (to previous projection
        % point / abstraction
	%----------------------------------------------------------------------
	loopinfo$nodeid(LoopInfo, NodeId),
	loopinfo$depth(LoopInfo, Depth),
	loopinfo$point(LoopInfo, FName, PP),
	loopinfo$state(LoopInfo, SGlobalArr, SGlobalVar, 
	               SLocalArr, SLocalVar, CL1, ML1),

	%---------------------------------------------------------------------
	% Comment: note that CL can contain 'arrassign' constraints,
	% and hence, a direct call to constraint symbolic will fail!
	%---------------------------------------------------------------------	
	OLoopStack = [LoopInfo,
	              r(SGlobalArr, SGlobalVar, SLocalArr, SLocalVar, CL, ML)|
                      LoopStack],
	!.

%------------------------------------------------------------------------------
% min_mark_intermediate_loops
%------------------------------------------------------------------------------
% Mark with 'x' projected constraints at intermediate loops, when they
% are no longer entailed. This can fail if the constraint is already locked.
%
% As a note, the input Path starts with relational 'r()' component.
%------------------------------------------------------------------------------
min_mark_intermediate_loops(Path, ANodeId, ADepth, IICL) :-
	%----------------------------------------------------------------------
	% Only when the set of individually invariant constraints is
	% nonempty. UPDATE(9/10/13)-Vijay: Why? Even if no constraint was
    % invariant (i.e, invariant is "true"), we must mark intermediate
    % loops. If not, this is causing problems (e.g, uncomment it and
    % run test-loop-grounded.c with -mm-refine-topdown y)
	%----------------------------------------------------------------------
	%IICL = [_|_],
	!,
	%----------------------------------------------------------------------
	% The commit above is important to ensure that the call fails on
	% fail on inability to mark alone.
	%----------------------------------------------------------------------
	min_mark_intermediate_loops_aux(Path, [], [], [], [], [],
	                                ANodeId, ADepth, IICL).
min_mark_intermediate_loops(_Path, _ANodeId, _ADepth, _IICL).

min_mark_intermediate_loops_aux([LoopInfo|_], 
	                        PrevLoopCL, PrevLoopML, PrevLoopSibMax,
				SegmentCL, _SegmentML,
	                        ANodeId, ADepth, IICL) :-
	loopinfo$nodeid(LoopInfo, ANodeId),
	loopinfo$depth(LoopInfo, ADepth), !,
	min_mark_child_point(IICL, SegmentCL,
	                     PrevLoopCL, PrevLoopML), !,
	%----------------------------------------------------------------------
	% Test for unifiability: We fail otherwise
	%----------------------------------------------------------------------
	unifiable_marking(PrevLoopML, PrevLoopSibMax).
min_mark_intermediate_loops_aux([LoopInfo|Path],
	                        PrevLoopCL, PrevLoopML, PrevLoopSibMax,
				SegmentCL, _SegmentML,
				ANodeId, ADepth, IICL) :-
	loopinfo$state(LoopInfo, _, _, _, _, PrevLoopCL1, PrevLoopML1), !,
	loopinfo$siblingmax(LoopInfo, PrevSibMax1),
	Path = [r(_, _, _, _, SegmentCL1, SegmentML1)|Path1], 
	min_mark_intermediate_loops_aux(Path1,
	                                PrevLoopCL1, PrevLoopML1,
					PrevSibMax1,
	                                SegmentCL1, SegmentML1,
					ANodeId, ADepth, IICL),
	select_non_deleted_constraints(PrevLoopCL1, PrevLoopML1,
	                               PrevLoopCL2, _PrevLoopML2, _),
	min_mark_child_point(PrevLoopCL2, SegmentCL,
	                     PrevLoopCL, PrevLoopML), !,
	%----------------------------------------------------------------------
	% Test for unifiability: We fail otherwise
	%----------------------------------------------------------------------
	unifiable_marking(PrevLoopML, PrevLoopSibMax).
min_mark_intermediate_loops_aux([r(_, _, _, _, SegmentCL1, SegmentML1)|Path],
	                        PrevLoopCL, PrevLoopML, PrevLoopSibMax,
				SegmentCL, SegmentML,
				ANodeId, ADepth, IICL) :-
	%----------------------------------------------------------------------
	% This last case should not be executed, but added here for
	% robustness.
	%----------------------------------------------------------------------
	append(SegmentCL, SegmentCL1, SegmentCL2),
	append(SegmentML, SegmentML1, SegmentML2),
	min_mark_intermediate_loops_aux(Path,
	                                PrevLoopCL, PrevLoopML,
					PrevLoopSibMax,
					SegmentCL2, SegmentML2,
					ANodeId, ADepth, IICL).

%------------------------------------------------------------------------------
% unifiable_marking
%------------------------------------------------------------------------------
unifiable_marking(L1, L2) :-
	unifiable_marking_aux(L1, L2), !, fail.
unifiable_marking(_, _).

unifiable_marking_aux(L, L) :- !, fail.
unifiable_marking_aux(_, _).


%------------------------------------------------------------------------------
% min_mark_child_point:
% Given a parent loop constraints, mark child loop constraints that are
% not entailed.
%------------------------------------------------------------------------------
min_mark_child_point(ParentCL, SegmentCL, ChildCL, _ChildML) :-
	min_mark_child_point_aux(ParentCL, SegmentCL, ChildCL).
min_mark_child_point(_ParentCL, _SegmentCL, _ChildCL, ChildML) :-
	retract(min_mark_child_point_memo(ChildML)).

min_mark_child_point_aux(ParentCL, SegmentCL, ChildCL) :-
	constraint_symbolic(ParentCL, [], ArrRef1),
	%-------------------------------------------------------------------%
	% SegmentCL can contain arrassign constraints, so we need to
	% take care of it.
	%-------------------------------------------------------------------%
	constraint_symbolic_arrays_SAT_check_form(SegmentCL, ArrRef1, ArrRef2),
	mark_constraints_not_entailed(ChildCL, ArrRef2, ChildML),
	fassert(min_mark_child_point_memo(ChildML)), !, fail.
min_mark_child_point_aux(_ParentCL, _SegmentCL, _ChildCL) :-
	error_message("Something wrong in min_mark_child_point/3\n", []).

mark_constraints_not_entailed([], _ArrRef, []).
mark_constraints_not_entailed([C|CL], ArrRef, [_|ML]) :-
	negate_numerical_list([C], NegC),
	mm_unsatisfiable_disjunction(NegC, ArrRef), !,
	mark_constraints_not_entailed(CL, ArrRef, ML).
mark_constraints_not_entailed([_|CL], ArrRef, [x|ML]) :-
	mark_constraints_not_entailed(CL, ArrRef, ML).

%==============================================================================
% test_candidate_invariants(+FName,
%                            +SGlobalArr, +SGlobalVar, +SLocalArr, +SLocalVar,
% 	                     +Path, +LoopInfo, -IICL, -MTList)
%==============================================================================
% Given a set of candidate constraints c1,..,cn and a path p, test if
% {ci} p {ci} for each ci, 1<=i<=n. 
%
% That is, this algorithm simply iterates over each constraint and
% test if it is **individually invariant**. A constraint c is
% individually invariant if the execution of c through a path in the
% loop body implies c itself.
%
% Here we start backward from c itself and since in the path in a loop
% body, several abstractions (min applications) may exist, we generalize
% by interpolation the abstractions further while maintaining c (or
% subsequent abstraction). In this way, we can eventually test that the
% interpolated incoming context is satisfied by c itself.
%
% There is another possible version where in the interpolated incoming
% context we check the set of constraints that is included in the
% interpolation. We again attempt to propagate this set backward until
% we reach a fixpoint set. In this way, we get a set of interdependent
% constraints instead of just a single constraint.
%==============================================================================

% individual_invariant(_ANodeId, _ADepth,
% 	             _SGlobalArr, _SGlobalVar, _SLocalArr, _SLocalVar,
% 	             _Path, FName, PP, 
% 		     ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
% 		     AC, _LoopStackML) :-
% 	%---------------------------------------------------------------------
% 	% Special case: if we use inductive invariants from abstract
% 	% interpretation or other means and we have not proved yet they
% 	% are too coarse, then by construction all AC's are
% 	% invariants. Therefore, no need of checking.
% 	%---------------------------------------------------------------------
% 	% Very importantly, note that we don't record which other
% 	% constraints are needed to preserve the invariance of those
% 	% AC's. This is correct and avoids subsumption conflicts
% 	%---------------------------------------------------------------------		
%         warning(warning_off),
% 	using_inductive_invariants(FName,PP),		
% 	not(disable_inductive_invariants(FName,PP)),	
% 	warning(warning_on),
% #ifdef  DEBUG_USE
%         print_message("\tNo need checking:\n\t",[],blue),
%         pretty_printer_constraints_list(FName,
% 					ASGlobalArr,ASGlobalVar,
% 					ASLocalArr ,ASLocalVar,
% 					[AC]),
%         print_message("\tWe know it is inductive invariant!\n",[],blue),	
% #else
%         % to avoid warnings
%         ASGlobalArr=_,ASGlobalVar=_,ASLocalArr=_,ASLocalVar=_,
% 	AC=_,
% #endif 
% 	!.
test_candidate_invariants(FName,
			  SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			  Path, LoopInfo, IICL, MTList) :-
	loopinfo$nodeid(LoopInfo, ANodeId),
	loopinfo$depth(LoopInfo, ADepth),
	loopinfo$state(LoopInfo, 
	               ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
		       ACL, AML),
	loopinfo$siblingmax(LoopInfo, ASibMax),
	loopinfo$point(LoopInfo, FName, PP),
	loopinfo$get_known_inductive_invariants(LoopInfo, KnownIndInvs),
	%----------------------------------------------------------------------
	% We examine only constraints that are not deleted by sibling
	% Given ACL, AML, select constraints that are not marked 'x' in AML,
	% output result as ACL1, with AML1 the markings, and AIndexes the
	% sequence number of the constraint in the list ACL.
	%
	% We also select relevant constraint lockings (sibling max), that
	% corresponds to the constraints in ACL1, (that are not deleted in
	% ACL).
	%----------------------------------------------------------------------	
	select_non_deleted_constraints(ACL, AML, ACL1, AML1, AIndexes),
	select_non_deleted_constraints(ASibMax, AML, ASibMax1, AML1, AIndexes),
	select_non_deleted_constraints(KnownIndInvs,AML,KnownIndInvs1,AML1,AIndexes),

#ifdef  PROFILE
% Temporary sanity check
	sanity_check_same_length(ACL,KnownIndInvs),
#endif 	/*PROFILE*/

#ifdef  GROUND_EXPLANATION
    restart_if_invgen_failed(ADepth, ASibMax),
#endif  /*GROUND_EXPLANATION*/	
	test_individual_invariance(ACL1, AML1, ASibMax1, KnownIndInvs1,
				   AIndexes, 
				   FName, PP,
				   SGlobalArr, SGlobalVar,
				   SLocalArr, SLocalVar,
				   Path, ANodeId, ADepth,
				   ASGlobalArr, ASGlobalVar,
				   ASLocalArr, ASLocalVar,
				   IICL, MTList),
	%----------------------------------------------------------------------
	% When necessary, we also mark with 'x' projected constraints at the
	% intermediate loops when they are no longer entailed.
	%----------------------------------------------------------------------
	min_mark_intermediate_loops(Path, ANodeId, ADepth, IICL).
test_candidate_invariants(_,_,_,_,_,_,_,_,_):-
	% For stats
	add_counter(num_loop_inv_gen_failed,1),
	!,
	fail.

#ifdef  PROFILE
sanity_check_same_length(L1,L2):-
	length(L1,N),
	length(L2,N),
	!.
sanity_check_same_length(_,_):-
	error_message("sanity check of two lists with same length failed\n",[]).
#endif  /*PROFILE*/

test_individual_invariance([],[],[],[],[],_,_,_,_,_,_,_,_,_,_,_,_,_,[],[]) :- !.
test_individual_invariance([AC|ACL], [_|AML], [_|ASibMax], [IsKnownIndInv|KnownIndInvs],
			   [AI|AIndexes], 
			   FName, PP,
			   SGlobalArr, SGlobalVar,
			   SLocalArr, SLocalVar,
			   Path, ANodeId, ADepth,
			   ASGlobalArr, ASGlobalVar,
			   ASLocalArr, ASLocalVar,
			   [AC|IICL],
			   [mt(AI, LoopStackML)|MTList]):-
	
	individual_invariant(ANodeId, ADepth,
	                     SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	                     Path, FName, PP, 
			     ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
			     AC, IsKnownIndInv, LoopStackML),		
	!,
	test_individual_invariance(ACL, AML, ASibMax, KnownIndInvs, AIndexes, 
				   FName, PP,
				   SGlobalArr, SGlobalVar,
				   SLocalArr, SLocalVar,
				   Path, ANodeId, ADepth,
				   ASGlobalArr, ASGlobalVar,
				   ASLocalArr, ASLocalVar,
				   IICL, MTList).
test_individual_invariance([_|ACL], [x|AML], [M|ASibMax], [_|KnownIndInvs],
			   [_|AIndexes], 
			   FName, PP,
			   SGlobalArr, SGlobalVar,
			   SLocalArr, SLocalVar,
			   Path, ANodeId, ADepth,
			   ASGlobalArr, ASGlobalVar,
			   ASLocalArr, ASLocalVar,
			   IICL, MTList):-
	%----------------------------------------------------------------------
	% The constraint is not individually invariant, so we mark it for
	% deletion (min).
	%----------------------------------------------------------------------	
	var(M),
	%----------------------------------------------------------------------
	% The marking 'x' may conflict with constraints that are
	% already locked, yet it is not individually invariant for this path.
	% In this case, this predicate fails. We implement this mechanism
	% by testing for var(M), where M the lock learned from siblings.
	%----------------------------------------------------------------------	
	test_individual_invariance(ACL, AML, ASibMax, KnownIndInvs, AIndexes, 
				   FName, PP,
				   SGlobalArr, SGlobalVar,
				   SLocalArr, SLocalVar,
				   Path, ANodeId, ADepth,
				   ASGlobalArr, ASGlobalVar,
				   ASLocalArr, ASLocalVar,
				   IICL, MTList).
test_individual_invariance([AC|_], _ , _, _, _,
			   FName, _PP,
			   _SGlobalArr, _SGlobalVar,
			   _SLocalArr, _SLocalVar,
			   _Path, _ANodeId, _ADepth,
			   ASGlobalArr, ASGlobalVar,
			   ASLocalArr, ASLocalVar,
			   _IICL, _MTList):-
#if defined(DEBUG_USE) || defined(GROUND_EXPLANATION)
	print_message("--- INVGEN FAILED !!! \n",[],magenta),
	print_message("\tBecause it cannot abstract: ",[]),
	pretty_printer_constraints_list(FName,
					ASGlobalArr,ASGlobalVar,ASLocalArr,ASLocalVar,
					[AC]),
#else
        % To avoid warnings
        AC=_,FName=_,ASGlobalArr=_,ASGlobalVar=_,ASLocalArr=_,ASLocalVar=_,
#endif /*defined(DEBUG_USE) || defined(GROUND_EXPLANATION)*/	 	
	!,
	fail.

%------------------------------------------------------------------------------
% individual_invariant(+,+,+,+,+,+,+,+,+,+,+,+,+,+,-LoopStackML)
%------------------------------------------------------------------------------
% Test if an ancestor constraint AC is individually invariant along
% the loop path. If yes, LoopStackML contains which other constraints
% are needed to preserve the invariance of AC.
%------------------------------------------------------------------------------
% Special case: we may know that the constraint is inductive invariant
% because some oracle said that. Thus, we just succeed.  Very
% importantly, note that we don't record which other constraints are
% needed to preserve the invariance of those AC's. This is correct and
% avoids subsumption conflicts.
% ------------------------------------------------------------------------------
% individual_invariant(_ANodeId, _ADepth,
% 	             _SGlobalArr, _SGlobalVar, _SLocalArr, _SLocalVar,
% 	             _Path, FName, PP, 
% 		     ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
% 		     AC, IsKnownIndInv , _LoopStackML) :-
% 	%-----------------------------------------------------------------------
% 	% We just use the inductive invariant if we didn't get conflict yet
% 	%-----------------------------------------------------------------------	
%         warning(warning_off),
% 	using_inductive_invariants(FName,PP),		
% 	not(disable_inductive_invariants(FName,PP)),	
% 	warning(warning_on),
% 	IsKnownIndInv == o,
% 	!,	
% #ifdef  DEBUG_USE
%         print_message("\tInvariant generator said that it's invariant:\n\t",[],blue),
%         pretty_printer_constraints_list(FName,
% 					ASGlobalArr,ASGlobalVar,
% 					ASLocalArr ,ASLocalVar,
% 					[AC]).
% #else
%         % to avoid warnings
%         ASGlobalArr=_,ASGlobalVar=_,ASLocalArr=_,ASLocalVar=_,
% 	AC=_.
% #endif  /*DEBUG_USE*/
individual_invariant(ANodeId, ADepth,
	             SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	             Path, FName, PP, 
		     ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
		     AC, _IsKnownIndInv, LoopStackML) :-
	%----------------------------------------------------------------------
	% We generate the negation of AC as NegImplied with variables of
	% SV instead of ASV.
	%----------------------------------------------------------------------
	get_first_negated_implied(SGlobalArr , SGlobalVar ,
	                          SLocalArr  , SLocalVar  ,
	                          ASGlobalArr, ASGlobalVar,
				  ASLocalArr , ASLocalVar ,
				  [AC]       , NegImplied),
	add_counter(num_of_tested_inv_candidates,1),
	ii_segment(ANodeId, ADepth, FName, PP,
	           ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar, 
		   AC, Path, NegImplied,
		   LoopStackML),	
	add_counter(num_of_successful_inv_candidates,1).

%------------------------------------------------------------------------------
% Find a segment in the path from ancestor to current state, and if:
% 1) The path does not start in intermediate min (but from the ancestor
%    min itself), attempt a satisfiability test
% 2) The path starts in min abstraction, generate an interpolation of the min
%    as long as the constraint is implied
%------------------------------------------------------------------------------
ii_segment(ANodeId, ADepth, FName, PP,
	   ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
	   AC, Path, NegImplied,
	   LoopStackML) :-
	find_next_min(Path, NextLoopInfo, RelCL, RelML, Path1), 
	loopinfo$nodeid(NextLoopInfo, MinId),
	loopinfo$depth(NextLoopInfo, MinDepth),
	loopinfo$state(NextLoopInfo, _, _, _, _, MinCL, MinML),
	loopinfo$get_must_invariants(NextLoopInfo,MustInvCL),
	!,
        %---------------------------------------------------------------------
	% High-level explanation: the invariance test for a constraint
	% c and a loop body should be {c} B {c'} where c' is the
	% constraint c with the corresponding renaming.  AC is our c,
	% ReLCL is our B, and NegImplied is the negation of c'. Then
	% we just check that AC and RelCL and NegImplied is unsat. In
	% addition, we compute which constraints of RelCL are needed
	% to keep the unsatisfiability (which constraints are needed
	% to keep the invariance of c)
	%---------------------------------------------------------------------
	% FIXME: we should add into B other candidates that they
	% already passed the test.
	%---------------------------------------------------------------------
	ii_segment_aux(ANodeId, ADepth, FName, PP,
	               ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
	               AC, Path1, MinId, MinDepth, MinCL, MinML,
		       RelCL, RelML, MustInvCL, NegImplied, LoopStackML).
ii_segment_aux(ANodeId, ADepth, _FName, _PP,
	       _ASGlobalArr, _ASGlobalVar, _ASLocalArr, _ASLocalVar,
	       AC, _Path, MinId, ADepth, MinCL, MinML,
	       RelCL, RelML, MustInvCL, NegImplied,[r(RelMLCopy), p(MinMLCopy)]) :-
	%----------------------------------------------------------------------
	% This is the case when we reach the ancestor looping point:
	% We ignore MinCL and MinML, and test for invariance of AC
	%
	% AC is the constraint tested for invariant
	% NegImplied is the negation of AC
	%
	%            <p>  MinCL (projected state at p before starting loop)
	%            /     
	%           / RelCL (constraints collected from p to p')
	%          / 
	%        <p'> 
	%----------------------------------------------------------------------	
	ANodeId = MinId,
	!,
	%----------------------------------------------------------------------
	% First we construct RelCL1 and RelML1: We do not want to mark
	% the real ML here, so we mark the copy
	%----------------------------------------------------------------------	
	% Key step: we add also those constraints (MustInvCL) that we
	% know for sure they are invariants. Thus, we increase the
	% likelihood for AC to be individually invariant.
	% e.g. i=0;n=10;while(i<n){i++;}	
	% Let's say we want to test if i<=10 is invariant. Then, we
	% need to check if {i<=10} i<=n-1, i1=i+1 {i1<=10}. This test
	% only holds if we add the constraint n=10 or something else
	% (e.g., constant propagation). MustInvCL will containt n=10
	% since it's clearly invariant.	
	%----------------------------------------------------------------------		
	append_symbolic_list(MustInvCL,[AC],[ACM],ACL,ACML),		
	append(ACL,RelCL,RelCL1),      % RelCL1 = [AC|RelCL],
	copy_to_unbound_list(RelML, RelMLCopy),
	append(ACML,RelMLCopy,RelML1), % RelML1 = [ACM|RelMLCopy],	
	%----------------------------------------------------------------------
	% We unify the marking of AC with the one in MinML
	%----------------------------------------------------------------------
	copy_to_unbound_list(MinML, MinMLCopy),
	%----------------------------------------------------------------------
	% Find AC in MinCL, and unify the position in MinMLCopy with ACM
	%----------------------------------------------------------------------
	mark_constraint_in_list(AC, ACM, MinCL, MinMLCopy),
	%----------------------------------------------------------------------
	% Test for unsatisfiability of constraints in RelCL1, in which case
	% we return the interpolant in RelML1. Otherwise, this call fails.
	%----------------------------------------------------------------------
	% print_message("Testing if \n",[]),
	% pretty_printer_constraints_list(FName,
	% 				ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
	% 				[AC]),
	% print_message(" plus \n",[]),
	% pretty_printer_constraints_list(FName,
	% 				ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
	% 				RelCL),
	% print_message(" is unsat with \n",[]),
	% pretty_printer_constraints_list(FName,
	% 				ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
	% 				NegImplied),
	individual_invariant_test(RelCL1, RelML1, NegImplied).	 
ii_segment_aux(ANodeId, ADepth, FName, PP, 
	       ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
	       AC, Path,
	       _MinId, _MinDepth, MinCL, MinML,
	       RelCL, RelML, _MustInvCL, NegImplied,
	       [r(RelMLCopy), p(MinMLCopy)|LoopStackML]) :-
	%----------------------------------------------------------------------
	% Case: nested loops
	% AC is the constraint tested for invariant at <p>
	% NegImplied is the negation of AC (also at <p>)
	%                <k>
	%                /
	%               /
	%              /
	%            <p> MinCL (projected state at p)
	%            / \    
	%      RelCL/   \   
	%          /     \
	%        <p'>     <k'>
	%
	% 1) test if AC is invariant through the first abstraction point
	%    (RelCL <> MinCL)
	%
	% 2) If yes, compute next condition NegImplied1 to be tested
	%    at <k> and go up recursively. NegImplied1 is simply those
	%    invariants in MinCL and negated.
	%    
	%----------------------------------------------------------------------

	%%%%%
	%%% FIXME (08/01/12): we are not using the must invariants
	%%% here and we should!
	%%%%%
	
 	%----------------------------------------------------------------------
	% In generating interpolants we should only consider constraints that
	% are not already deleted by sibling min application.
	%----------------------------------------------------------------------
	select_non_deleted_constraints(MinCL, MinML, MinCL1, MinML1, _),
	select_non_deleted_constraints(MinMLCopy, MinML, MinMLCopy1, MinML1, _),
	%----------------------------------------------------------------------
	% First we construct the constraint list to be tested
	% We do not want to mark the real ML here, so we mark the copy
	%----------------------------------------------------------------------
	append(RelCL, MinCL1, CL),
	copy_to_unbound_list(RelML, RelMLCopy),
	append(RelMLCopy, MinMLCopy1, MLCopy),		
	%% append(RelCL, MinCL, CL),
	%% copy_to_unbound_list(RelML, RelMLCopy),
	%% copy_to_unbound_list(MinML, MinMLCopy),
	%% append(RelMLCopy, MinMLCopy, MLCopy),
	%----------------------------------------------------------------------
	% Here we test for individual invariance of AC
	%----------------------------------------------------------------------
	% print_message("Testing if \n",[]),
	% pretty_printer_constraints_list(FName,
	% 				ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
	% 				CL),
	% print_message(" is unsat with \n",[]),
	% pretty_printer_constraints_list(FName,
	% 				ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
	% 				NegImplied),	
	individual_invariant_test(CL, MLCopy, NegImplied),
	!,	
	%----------------------------------------------------------------------
	% We compute the next condition from the markings in MinMLCopy
	%----------------------------------------------------------------------
	get_negated_implied_from_interpolated_min(MinCL, MinMLCopy,
						  NegImplied1),
	ii_segment(ANodeId, ADepth, FName, PP,
	           ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
	           AC, Path, NegImplied1,
		   LoopStackML).


%------------------------------------------------------------------------------
% mark_constraint_in_list(+C, ?M, +L1, ?L2)
%------------------------------------------------------------------------------
% Find the same constraint C in L1, and unify marking M with the same
% position in L2
%------------------------------------------------------------------------------
mark_constraint_in_list(_, _, [], []).
mark_constraint_in_list(C, M, [D|_], [M|_]) :- C==D, !.
mark_constraint_in_list(C, M, [_|R], [_|S]) :-
	mark_constraint_in_list(C, M, R, S).

%------------------------------------------------------------------------------
% individual_invariant_test(+,?,+)
%------------------------------------------------------------------------------
% Test for satisfiability, in which case we fail, otherwise, return an
% interpolant (those constraints needed to keep invariance)
%------------------------------------------------------------------------------
individual_invariant_test(CL, _ML, NegImplied) :-
	individual_invariant_test_aux(CL, NegImplied),
	!,
	%---------------------------------------------------------------------
	% Here CL and NegImplied is SAT and hence, the test failed.
	%---------------------------------------------------------------------	
	fail.
individual_invariant_test(CL, ML, NegImplied) :-
	%---------------------------------------------------------------------
	% If this is executed then CL and NegImplied is UNSAT and
	% hence, the test succeed
	%---------------------------------------------------------------------
	compute_unsat_core(NegImplied, CL, ML, no_check).

individual_invariant_test_aux(CL, NegImplied) :-
	% FIXME: Check array constraints are treated properly
/*	
	constraint_symbolic_arrays_SAT_check_form(CL, [], ArrRef),
	mm_satisfiable_disjunct(NegImplied, ArrRef).
*/	
% 	substitute_arrays(CL,CL1),
%       substitute_arrays_disjunct(NegImplied, NegImplied1),	
% 	constraint_symbolic(CL1, [], ArrRef),
% 	mm_satisfiable_disjunct(NegImplied1, ArrRef).
	
	constraint_symbolic_arrays_SAT_check_form(CL, [], ArrRef),
        substitute_arrays_disjunct(NegImplied, NegImplied1),		
	mm_satisfiable_disjunct(NegImplied1, ArrRef).

%------------------------------------------------------------------------------
% get_negated_implied_from_interpolated_min(+CL, +ML, -NegImplied)
%------------------------------------------------------------------------------
% Get the thing to prove unsatisfiable, based on the marking of the
% constraints in the min abstraction
%------------------------------------------------------------------------------
get_negated_implied_from_interpolated_min(CL, ML, NegImplied) :-
	select_marked_constraints_path(CL,ML,CL1,o),
	negate_numerical_list(CL1, NegImplied).

%------------------------------------------------------------------------------
% Get first thing to prove unsatisfiable, by negating constraints
%------------------------------------------------------------------------------
get_first_negated_implied(SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	                  ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar,
			  ACL, NegImplied) :-	
	fcopy_term(t(ASGlobalArr, ASGlobalVar, ASLocalArr, ASLocalVar, ACL),
		   t(SGlobalArr, SGlobalVar, SLocalArr, SLocalVar, CL)),	
	negate_numerical_list(CL, NegImplied),	
	!.

%------------------------------------------------------------------------------
% Unfold transition
%------------------------------------------------------------------------------
% Execute symbolically a transition. Do special processing on looping
% point, and take first transitions that are already feasible.
%------------------------------------------------------------------------------
mm_unfold_trans(NodeId, Depth, FName, PP,
		GlobalArr, GlobalVar, LocalArr, LocalVar,
		SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		CL, ML, CallStack, ArrRef, Loops, TableSpace,
		LoopStack, PathStack, AbsPtFlag) :-

	test_outgoing_trans(FName, PP,
	                    GlobalArr , GlobalVar , LocalArr , LocalVar , ArrRef,
			    SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			    CallStack, Enabled, Disabled),
	
	%debug_message("%:% ENABLED Set=% DISABLED Set=%\n",
	%	      [FName,PP,Enabled, Disabled]),
	
	test_independently_infeasible(Enabled,Disabled,
				      NodeId, Depth, FName,
				      SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
				      CL, ML, LoopStack),
	
	!,
	mm_unfold_trans_aux(NodeId, Depth, FName, PP,
	                 GlobalArr, GlobalVar, LocalArr, LocalVar,
			 SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			 CL, ML, CallStack, ArrRef, Loops, TableSpace,
			 LoopStack, PathStack,
			 Enabled, Disabled, AbsPtFlag).

mm_unfold_trans_aux(NodeId, Depth, FName, PP,
	         GlobalArr, GlobalVar, LocalArr, LocalVar,
		 SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		 CL, ML, CallStack, ArrRef, Loops, TableSpace,
		 LoopStack, PathStack,
	         Enabled, Disabled, AbsPtFlag) :-
	unfold_enabled(NodeId, Depth, FName, PP,
	               GlobalArr, GlobalVar, LocalArr, LocalVar,
		       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		       CL, ML, CallStack, ArrRef, Loops, TableSpace,
		       LoopStack, PathStack,
	               Enabled, Disabled, AbsPtFlag), 
	%----------------------------------------------------------------------
	% We put a cut here since when this call succeeds, it means that
	% a feasible error point is reached, and there is no point to
	% execute disabled transitions.
	%----------------------------------------------------------------------
	!.
#ifdef  GC_INTP_INFEASIBLE
mm_unfold_trans_aux(NodeId, Depth, _, _,
		    _, _, _, _,
		    _, _, _, _,
		    _, _, _, _, _, _,
		    _, _,
		    _, _, _) :-
    in_gc_mode, counter_value(gc_status,0), !,
    % FIX for bug found by Hiep (ref: email 28-Mar-2014)
    % If GC failed (due to bound violation), along the way there may be garbage safety
    % answers which should be removed, otherwise the sanity check that there should be
    % exactly 1 safety answer at the end of GC will fail.
	retract(safety_answer(NodeId, Depth, _ML, _LoopStackML, _Intp, _LoopContext, 1)),
    fail. % if gc failed, don't execute anything
#endif
#ifdef  TESTING_CREST
mm_unfold_trans_aux(_NodeId, _Depth, _FName, _PP,
		    _GlobalArr, _GlobalVar, _LocalArr, _LocalVar,
		    _SGlobalArr, _SGlobalVar, _SLocalArr, _SLocalVar,
		    _CL, _ML, _CallStack, _ArrRef, _Loops, _TableSpace,
		    _LoopStack, _PathStack,
		    _Enabled, _Disabled, _AbsPtFlag) :-
	combine_operations_disabled,
	!,
	fail.
% This clause performs "fast verification" i.e., attempt to verify the
% other tree below NodeId as usual, but if any choice point is encountered
% (with 2 feasible branches), fail. This check is done in unfold_enabled
% first clause. The idea is to hope to produce a full interpolant quickly
% if there are no choice points in that tree.
mm_unfold_trans_aux(NodeId, Depth, FName, PP,
		    GlobalArr, GlobalVar, LocalArr, LocalVar,
		    SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		    CL, ML, CallStack, ArrRef, Loops, TableSpace,
		    LoopStack, PathStack,
		    Enabled, Disabled, AbsPtFlag) :-
    counter_value(fast_verification,1),
    combine_operations_enabled,
    is_branch_pp(FName,PP), % fast verification only makes sense at branch PPs
    turn_on_fast_verification(FName,PP,NodeId), % if already in fast verification, this will fail
    back_one_step_along_crest_path(FName,PP),
    is_half_interpolant_pp(FName,PP,PathStack),
    % remove the (only) Crest trans from this PP from Enabled, to prevent
    % it from being taken again
	get_crest_trans(FName, Id,  PP, 
		  _GlobalArr1, _GlobalVar1, _SGlobalArr1, _SGlobalVar1, 
		  _LocalArr1 , _LocalVar1 , _SLocalArr1 ,  _SLocalVar1,
		  _PostPP,
		  _PostGlobalArr , _PostGlobalVar ,
		  _PostSGlobalArr, _PostSGlobalVar,
		  _PostLocalArr  , _PostLocalVar  ,
		  _PostSLocalArr , _PostSLocalVar ,
		  _XCL, _, _ArrRefX, _BranchMode,
		  Disabled),
    delete(Enabled,Id,NewEnabled),
    NewDisabled=[Id|Disabled],
    print_message("AT %::%, Enabled:% Disabled:%\n",[FName,PP,NewEnabled,NewDisabled],magenta),
	unfold_enabled(NodeId, Depth, FName, PP,
	               GlobalArr, GlobalVar, LocalArr, LocalVar,
		       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		       CL, ML, CallStack, ArrRef, Loops, TableSpace,
		       LoopStack, PathStack,
	               NewEnabled, NewDisabled, AbsPtFlag),
	%----------------------------------------------------------------------
	% We put a cut here since when this call succeeds, it means that
	% a feasible error point is reached, and there is no point to
	% execute disabled transitions.
	%----------------------------------------------------------------------
	!.
mm_unfold_trans_aux(NodeId, _Depth, FName, PP,
		    _GlobalArr, _GlobalVar, _LocalArr, _LocalVar,
		    _SGlobalArr, _SGlobalVar, _SLocalArr, _SLocalVar,
		    _CL, _ML, _CallStack, _ArrRef, _Loops, _TableSpace,
		    _LoopStack, PathStack,
		    _Enabled, _Disabled, _AbsPtFlag) :-
    counter_value(fast_verification,1),
    is_branch_pp(FName,PP), % fast verification only makes sense at branch PPs
    turn_off_fast_verification(NodeId), % if a node different than the one that initiated fast verification executes this, this will fail
    fast_verification_bookkeeping(FName,PP,PathStack),
    fail.
#endif  /*TESTING_CREST*/
mm_unfold_trans_aux(NodeId, Depth, FName, PP,
		    GlobalArr, GlobalVar, LocalArr, LocalVar,
		    SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		    CL, ML, CallStack, ArrRef, Loops, TableSpace,
		    LoopStack, PathStack,
		    Enabled, Disabled, AbsPtFlag) :-
#ifdef  TESTING_CREST
    check_fast_verification_type,
#endif /*TESTING_CREST*/
	%----------------------------------------------------------------------
	% We should only unfold when there is no conflict detected
	%----------------------------------------------------------------------
	no_conflict(Depth),
	unfold_disabled(NodeId, Depth, FName, PP,
	                GlobalArr, GlobalVar, LocalArr, LocalVar,
			SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			CL, ML, CallStack, ArrRef, Loops, TableSpace,
			LoopStack, PathStack,
	                Enabled, Disabled, AbsPtFlag),
	%----------------------------------------------------------------------
	% Again we put a cut here since when this call succeeds, it means that
	% a feasible error point is reached, and there is no point to
	% collate answers.
	%----------------------------------------------------------------------
	!.
mm_unfold_trans_aux(NodeId, Depth, FName, PP,
		    GlobalArr , GlobalVar, LocalArr, LocalVar,
		    SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		    CL, ML, CallStack, ArrRef, Loops, TableSpace,
		    LoopStack, PathStack,
		    _Enabled, _Disabled, _AbsPtFlag) :-

	%----------------------------------------------------------------------
	% We should only memo when there is no conflict detected
	%----------------------------------------------------------------------
	no_conflict2(Depth),
	mm_unfold_combine(NodeId, Depth, FName, PP,
			  GlobalArr,  GlobalVar,  LocalArr,  LocalVar,
			  SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			  CL, ML, CallStack, ArrRef, Loops, TableSpace, LoopStack, PathStack),
	!, fail.

%------------------------------------------------------------------------------
% mm_unfold_combine
%------------------------------------------------------------------------------
% Take all interpolants from children and store in memo table the
% conjunction of all of them.
%------------------------------------------------------------------------------
#ifdef  TESTING_CREST
mm_unfold_combine(_NodeId, _Depth, _FName, _PP,
		  _GlobalArr, _GlobalVar, _LocalArr, _LocalVar,
		  _SGlobalArr, _SGlobalVar, _SLocalArr, _SLocalVar,
		  _CL, _ML, _CallStack, _ArrRef, _Loops, _TableSpace, _LoopStack,
          _PathStack):-
	combine_operations_disabled,
	!.
mm_unfold_combine(_NodeId, _Depth, FName, PP,
		  _GlobalArr, _GlobalVar, _LocalArr, _LocalVar,
		  _SGlobalArr, _SGlobalVar, _SLocalArr, _SLocalVar,
		  _CL, _ML, _CallStack, _ArrRef, _Loops, _TableSpace, _LoopStack,
          PathStack):-
	% combine only if PP has full-interpolant
	is_half_interpolant_pp(FName,PP,PathStack), 

        % setting this flag will halt all future combine operations and force
	% backtracking upto root. this is fine, because we are not going to explore
        % any other path than the CREST path. when running with a new CREST path,
        % allow_combine_operations will be called.
	halt_combine_operations,
	print_message("%_% HAS HALF-INTP.. COMBINE OPERATIONS HALTED\n",
		      [FName,PP],red),
	get_unique_context_num(PathStack,PPContext),
	fassert(half_interpolant_pp(FName,PP,PPContext)),
	add_counter(num_half_interpolant_pp,1),
	!.
mm_unfold_combine(_NodeId, _Depth, FName, PP,
		  _GlobalArr, _GlobalVar, _LocalArr, _LocalVar,
		  _SGlobalArr, _SGlobalVar, _SLocalArr, _SLocalVar,
		  _CL, _ML, _CallStack, _ArrRef, _Loops, _TableSpace, _LoopStack,
		  PathStack):-
	get_unique_context_num(PathStack,PPContext),
	retract(half_interpolant_pp(FName,PP,PPContext)),
	add_counter(num_half_interpolant_pp,0-1),
	fail.
#endif /*TESTING_CREST*/
#ifdef  GC_INTP_INFEASIBLE
mm_unfold_combine(_, _, _, _,
		  _, _, _, _,
		  _, _, _, _,
		  _, _, _, _, _, _, _,
          _):-
    in_gc_mode, counter_value(gc_status,0), !.
#endif  /*GC_INTP_INFEASIBLE*/
mm_unfold_combine(NodeId, Depth, FName, PP,
		  _GlobalArr, _GlobalVar, _LocalArr, _LocalVar,
		  SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		  CL, ML, CallStack, _ArrRef, _Loops, _TableSpace, LoopStack,
          _PathStack):-
#ifdef  TESTING_CREST
        add_counter(num_crest_states_visited,1),
#endif  /*TESTING_CREST*/
	debug_begin_combine_operator(FName,PP),
#ifdef  PROFILE	
	ctime(Time0),
        sanityCheckOpSucceed(open,combine_op_checkpoint),
#endif	/*PROFILE*/	
	%----------------------------------------------------------------------
	% Combine the interpolants from the children and assert it as
	% a safety_answer fact which will be consulted by table$memo
	%----------------------------------------------------------------------
	% IMPORTANT: Here we do not need to combine sibling maxes into
	% the answer/for storing of context into memo table, as all
	% branches are handled. Sibling maxes should have been
	% included in the max of all the branches.
	%
	% IMPORTANT: Here we should collate answers for this particular
	% nodeid only. This to prevent messing up with sibling. (Have to
	% fix this clumsy coding in the future.)
	%----------------------------------------------------------------------
	mm_collate_safety_answers(NodeId, Depth,
				  FName, PP,
				  SGlobalArr, SGlobalVar, SLocalArr, SLocalVar),
#ifdef  PROFILE
        ctime(Time1),
	add_counter(combine_timing,Time1-Time0),
        sanityCheckOpSucceed(close,combine_op_checkpoint),
        sanityCheckOpSucceed(open,store_op_checkpoint),
#endif  /*PROFILE*/
	%----------------------------------------------------------------------
        % Store in the memo table the interpolant for the parent.
	%----------------------------------------------------------------------                
#ifdef  TESTING_CREST
	table$memo(NodeId, Depth, FName, PP, CallStack,
	           SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		   CL, ML, LoopStack),
#else
	table$memo(NodeId, Depth, FName, PP, CallStack,
	           SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		   CL, ML, LoopStack),
#endif  /*TESTING_CREST*/
        %----------------------------------------------------------------------
        % Important step: after the analysis of the function has been
        % finished, we need to cleanup its memo table. Otherwise,
        % subsumption may not be sound.
        %----------------------------------------------------------------------
        clear_function_memo_table(FName,PP),		
#ifdef  PROFILE	
	sanityCheckOpSucceed(close,store_op_checkpoint),
#endif  /*PROFILE*/
        debug_end_combine_operator.

%------------------------------------------------------------------------------
% table$memo
%------------------------------------------------------------------------------
% Memoing state in the memo table
%------------------------------------------------------------------------------
table$memo(NodeId, Depth, FName, PP, CallStack,
	   SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	   [], [], LoopStack) :-
	%----------------------------------------------------------------------
	% LOOP HEADER POINT
	%----------------------------------------------------------------------
	is_ancestor_pp(FName,PP),
	!,	
#ifdef  PROFILE
        ctime(Time0),
#endif  /*PROFILE*/
	%----------------------------------------------------------------------
	% This is the case when the current node is a loop header:
        %
	% We store the constraints that are locked in loop's CL and
	% the index of the constraints that are locked (Ord) that can be
	% used for subsumption test of descendants 
	%----------------------------------------------------------------------
	debug_message("MEMOING LOOP HEADER AT NODEID=% DEPTH=%\n",
		      [NodeId, Depth], red),
		      
	LoopStack = [LoopInfo|Path],
	loopinfo$nodeid(LoopInfo, NodeId),
	loopinfo$depth(LoopInfo, Depth),
	loopinfo$point(LoopInfo, FName, PP),
	loopinfo$state(LoopInfo,
		       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		       LoopCL, LoopML),
	!,
	get_safety_answer(NodeId, Depth, _, _, [], LoopStackML, OtherIntp, LoopContext),
	remove_constraints_from_loopstack(LoopStack, LoopStackML),

	% We assign simply an index (number) to each constraint which
	% is part of the interpolant (i.e., it's locked)
	get_locked_constraints_ord(LoopML, Ord),
	
% #ifdef  DEBUG_USE
% 	%-------------------------------------------------------------------------
% 	print_message("Ord: %\n",[Ord]),
% 	print_message("LoopCL: \n\t",[]),
% 	pretty_printer_constraints_list(FName,
% 					SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
% 					LoopCL),
% 	print_message("Unsat Proj interpolant: \n\t",[]),	
% 	pretty_printer_marked_constraints(FName,LoopCL,LoopML,
% 					  SGlobalArr, SGlobalVar, SLocalArr, SLocalVar),
%  	pretty_printer_interp(FName,Depth,
% 			      'Other interpolants:',
%  			      SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
%  			      OtherIntp),
% 	%-------------------------------------------------------------------------		
% #endif  /*DEBUG_USE*/		

#ifdef  PROFILE	
        ctime(Time1),
	add_counter(prep_store_memo_timing,Time1-Time0),
#endif	/*PROFILE*/
        %------------------------------------------------------------------------
	% Note that LoopCL is already in projected form. Thus, we
	% don't need to project in order to create the final
	% interpolant to be stored.
        %------------------------------------------------------------------------
	create_memo_loopheader_interpolant(FName,
					   SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
					   LoopCL, LoopML, OtherIntp, NegDisjunct),
#ifdef  PROFILE
	ctime(Time2),
#endif  /*PROFILE*/
	%----------------------------------------------------------------------
	% We try to find previous min to compute the loop context of this
	% loop in case it is included in another loop. Any previous min would
	% do, not necessarily of the syntacticly "enclosing" loop of this one
	% as in generating the projection later, we know nothing of context
	% before an abstraction point.
	%----------------------------------------------------------------------
	find_next_min(Path, NextLoopInfo, PathCL, _PathML, _),
	loopinfo$state(NextLoopInfo, _, _, _, _, MinCL, _),
	%----------------------------------------------------------------------
	% We create projected and negated loop contexts to be stored in memo
	% table. Note that compute_invariance_dependencies produces information only
	% for the nearest loop context.
	%----------------------------------------------------------------------
	compute_invariance_dependencies(FName,
					SGlobalArr, SGlobalVar,
					SLocalArr , SLocalVar,
					LoopContext, PathCL, MinCL,
					ProjectedLoopContext),
#ifdef  PROFILE
        ctime(Time3),
	add_counter(prep_store_memo_timing,Time3-Time2),
#endif  /*PROFILE*/
	table$assert(NodeId, FName, PP, CallStack,
                     SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
                     NegDisjunct, Ord, ProjectedLoopContext).
table$memo(NodeId, Depth, FName, PP, CallStack,
	   SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	   CL, ML, LoopStack) :-
	%----------------------------------------------------------------------
	% NON-LOOP HEADER POINT
	%----------------------------------------------------------------------	
#ifdef  PROFILE
        ctime(Time0),
#endif  /*PROFILE*/
        % ML contains the projected unsat core interpolant and Intp
        % other interpolants (e.g.,wp's)
	get_safety_answer(NodeId, Depth, _, _, ML, LoopStackML, Intp, LoopContext),
	remove_constraints_from_loopstack(LoopStack, LoopStackML),
	push_minmax_segment_path(SGlobalArr, SGlobalVar, SLocalArr, SLocalVar, CL, ML,
				 LoopStack,Path),
	%----------------------------------------------------------------------
	% We try to find previous min to compute the loop context of this
	% point in case it is included in a loop. Any previous min would
	% do, not necessarily of the syntacticly "enclosing" loop of this 
	% point as in generating the projection later using
	% compute_invariance_dependencies, we know nothing of context before an
	% abstraction point.
	%----------------------------------------------------------------------
	find_next_min(Path, NextLoopInfo, CL, ML, _),	
	loopinfo$state(NextLoopInfo, _, _, _, _, MinCL, MinML),
	%----------------------------------------------------------------------
	% note that compute_invariance_dependencies produces
	% information only for the nearest loop context
	%----------------------------------------------------------------------
	compute_invariance_dependencies(FName,
					SGlobalArr, SGlobalVar,
					SLocalArr, SLocalVar, 
					LoopContext, CL, MinCL,
					ProjectedLoopContext),
	merge_constraints_paths(CL,ML,MinCL,MinML,CL1,ML1),
#ifdef  PROFILE
        ctime(Time1),
	add_counter(prep_store_memo_timing,Time1-Time0),
#endif  /*PROFILE*/
        % Note: ProjectedLoopContext is defined in terms of
        % SGlobalArr.... so it's vital that create_memo_interpolant/12
        % preserves the symbolic form of those variables.
        create_memo_interpolant(SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
				CL1, ML1, Intp,
				SGlobalArr1, SGlobalVar1, SLocalArr1, SLocalVar1,
				NegDisjunct),
	SGlobalArr1 = SGlobalArr, SGlobalVar1 = SGlobalVar,
	SLocalArr1  = SLocalArr , SLocalVar1  = SLocalVar,
	table$assert(NodeId, FName, PP, CallStack,
                     SGlobalArr1, SGlobalVar1, SLocalArr1, SLocalVar1,
                     NegDisjunct, _, ProjectedLoopContext).

%-----------------------------------------------------------------------------%
% compute_invariance_dependencies(+,+,+,+,+,+LoopContext,+CL,+MinCL,
%                                 -ProjLoopContext)
%-----------------------------------------------------------------------------%
% Compute those constraints needed to keep the invariance of the
% invariant constraints in the loop. 
%-----------------------------------------------------------------------------%
compute_invariance_dependencies(FName,
				SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
				LoopContext, CL, MinCL, ProjectedLoopContext) :-
#ifdef  PROFILE
        ctime(Time0),
#endif  /*PROFILE*/
	compute_invariance_dependencies_aux(LoopContext,
					    FName, SGlobalArr, SGlobalVar,
					    SLocalArr , SLocalVar,
					    CL, MinCL,
					    ProjectedLoopContext),
#ifdef  PROFILE
        ctime(Time1),
	add_counter(store_memo_compute_invariants,Time1-Time0),
#endif  /*PROFILE*/	
	!.
compute_invariance_dependencies(_FName,
				_SGlobalArr, _SGlobalVar, _SLocalArr, _SLocalVar,
				_LoopContext, _CL, _MinCL,
				_ProjectedLoopContext) :-
%	print_message("compute_invariance_dependencies(%, %, %, %, %, %, %, ProjectedLoopContext)\n",
%		      [SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
%		       LoopContext, CL, MinCL]),
	error_message("Unexpected error in compute_invariance_dependencies/9\n",[]).


compute_invariance_dependencies_aux([],_,_,_,_,_,_,_,lc_null).
compute_invariance_dependencies_aux([lc(ANodeId, ADepth, AMTList)|_],
				    FName, SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
				    CL, MinCL,
				    lc(ANodeId, ADepth, ProjectedAMTList)) :-
	%----------------------------------------------------------------------
	% We get the top on the loop context stack
	%----------------------------------------------------------------------
	!,
	project_mintests(AMTList,
			 FName,
			 SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			 CL, MinCL, ProjectedAMTList).

%------------------------------------------------------------------------------%
% project_mintests(+,+,+,+,+,+,+,+,-ProjectedMTList)
% ------------------------------------------------------------------------------%
% Compute those constraints needed to keep the invariance of the
% invariant constraints in the loop. They are stored as their negated
% projections for checking unsatisfiability later in the subsumption
% (mark_more_min/4).
%------------------------------------------------------------------------------%
% IMPOTANTE NOTE: This operation is an IMPORTANT BOTTLENECK. We need
% to run at least with -clean-after-dump option to mitigate the cost.
%-------------------------------------------------------------------------------%
% Based on some preliminary experiments, CACHE_PROJECT_MINTESTS does
% not speed up.
% #define CACHE_PROJECT_MINTESTS
project_mintests(MTList,
		 FName, SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		 CL, MinCL, ProjectedMTList) :-
	append(CL, MinCL, CL1),
#ifdef  CACHE_PROJECT_MINTESTS		
	% To reuse the memory used by project_mintests_cache/7
	set_cs_mark,
#endif 	/*CACHE_PROJECT_MINTESTS*/
	project_mintests_aux(MTList,
			     FName, SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			     CL1, ProjectedMTList),

#ifdef  CACHE_PROJECT_MINTESTS
	retractall(project_mintests_cache(_,_,_,_,_,_,_)),
	% To reuse the memory used by project_mintests_cache/7
	pop_cs_mark,
#endif  /*CACHE_PROJECT_MINTESTS*/
        !.

project_mintests_aux([],_,_,_,_,_,_,[]).
#ifdef  CACHE_PROJECT_MINTESTS	
%-------------------------------------------------------------------%
% This clause tries to reuse previous solution before trying a new
% one:
%-------------------------------------------------------------------%
project_mintests_aux([mt(N, [r(ML), p(MinML)|_])|R],
		     FName, SGlobalArr, SGlobalVar, SLocalArr, SLocalVar, 
		     CL1, [mt(N, NegProj)|S]) :-
	append(ML, MinML, ML1),
	check_project_mintests_cache(ML1,
				     FName, SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
				     NegProj),
	!,
#ifdef  PROFILE
	add_counter(num_of_invariance_dependencies,1),
#endif  /*PROFILE*/	
	project_mintests_aux(R,
			     FName, SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			     CL1, S).
#endif  /*CACHE_PROJECT_MINTESTS*/	
project_mintests_aux([mt(N, [r(ML), p(MinML)|_])|R],
		     FName, SGlobalArr, SGlobalVar, SLocalArr, SLocalVar, 
		     CL1, [mt(N, NegProj)|S]) :-
	append(ML, MinML, ML1),
	make_negated_projected_interpolant(SGlobalArr, SGlobalVar,
					   SLocalArr , SLocalVar,
					   CL1, ML1, NegProj),
#ifdef  CACHE_PROJECT_MINTESTS
	%-------------------------------------------------------------------%	
	% performance improvement: we cache the solution to be
	% reused later.
	%-------------------------------------------------------------------%
	fassert(project_mintests_cache(ML1,
	 			       FName,
				       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	 			       NegProj)),
#endif  /*CACHE_PROJECT_MINTESTS*/
#ifdef  PROFILE
	add_counter(num_of_invariance_dependencies,1),
#endif  /*PROFILE*/
	project_mintests_aux(R,
			     FName, SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			     CL1, S).

#ifdef  CACHE_PROJECT_MINTESTS
check_project_mintests_cache(ML,
			     FName, SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
			     NegProj):-
	project_mintests_cache(MLX,
			       FName, SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
			       NegProj),	
	identical_marking(ML,MLX),
#ifdef  PROFILE	
	add_counter(num_of_reused_invariance_dependencies,1),
#endif 	
	!.
#endif  /*CACHE_PROJECT_MINTESTS*/	

#ifdef  GC_INTP_INFEASIBLE
% We add to states in GC mode only when we are memoing an interpolant
% at the state (called from table$assert). Otherwise the state is a 
% "cheap state" (only encountered during forward SE) and not counted
add_states_if_in_gc_mode:-
    in_gc_mode, add_counter(gc_interpolants,1).
add_states_if_in_gc_mode.
#endif /*GC_INTP_INFEASIBLE*/

%------------------------------------------------------------------------------
% table$assert: Low-level store in memo table
%------------------------------------------------------------------------------
% Code that stores finally an entry into the memo table.
%------------------------------------------------------------------------------
table$assert(NodeId, FName, PP, CallStack,
             SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	     NegDisjunct, Ord, ProjectedLoopContext) :-
	%----------------------------------------------------------------------
	% Uncomment to see what we store in the memo table
	%----------------------------------------------------------------------
    add_counter(num_interpolants_total,1),
#ifdef  GC_INTP_INFEASIBLE
    add_states_if_in_gc_mode,
    interpolant_vars(SGlobalArr, SGlobalVar, SLocalArr, SLocalVar, NegDisjunct),
#endif  /*GC_INTP_INFEASIBLE*/
	%print_message("%::%::%:",[FName,PP,NodeId]),
	%pretty_printer_constraints_list(FName,
	%   				SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	%   				NegDisjunct),
#ifdef  PROFILE
	ctime(Time0),
#endif  /* PROFILE */	
	config_to_index(PP, IpIdx),
	printf_to_atom(PName, "t%", PP),
	simplify_stack(CallStack, SimpleCallStack),
#ifdef  GRAPHVIZ_USE
        top_context_stack(PPContext),
#else   /*(defined(GRAPHVIZ_USE))*/
        PPContext = _,
#endif  /*(defined(GRAPHVIZ_USE))*/
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % OPTIMIZATION (Apr'12): remove subsumed memo table entries!
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        delete_subsumed_memo_entries(FName,PP,CallStack,
				     SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
				     NegDisjunct),

        T =.. [PName, NodeId, FName, IpIdx, PPContext,
	       [sinfo(FName, PP)|SimpleCallStack],
	       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	       NegDisjunct, ProjectedLoopContext, Ord, _Answer],
	fassert(T),
#ifdef  PROFILE
        ctime(Time1),
	add_counter(store_timing_3,Time1-Time0),
	interp_size(NegDisjunct, SizeOfIntp),
	add_counter(totalwpsize, SizeOfIntp),
#endif  /*PROFILE*/
	debug_message("\tSTORED MEMOTABLE: \n",[],yellow),
	debug_message("\t<%,%,%>\n",[FName,PP,T]),
	!.

:- dynamic(intp_vars_indices_GA,1).
:- dynamic(intp_vars_indices_GV,1).
:- dynamic(intp_vars_indices_LA,1).
:- dynamic(intp_vars_indices_LV,1).
interpolant_vars(SGA, SGV, SLA, SLV, Intp) :-
    intp_vars_indices_GA(_), !,
    interpolant_vars_aux(SGA, SGV, SLA, SLV, Intp).
interpolant_vars(SGA, SGV, SLA, SLV, Intp) :-
    fassert(intp_vars_indices_GA([])),
    fassert(intp_vars_indices_GV([])),
    fassert(intp_vars_indices_LA([])),
    fassert(intp_vars_indices_LV([])),
    interpolant_vars_aux(SGA, SGV, SLA, SLV, Intp).
interpolant_vars_aux(SGA, SGV, SLA, SLV, Intp) :-
    varset_constraints(Intp, VarSet),
    %print_message("intp vars for % ::: %\n", [Intp, VarSet]),
    vars_to_indices(SGA, SGV, SLA, SLV, VarSet,
                    IGA, IGV, ILA, ILV),
    retract(intp_vars_indices_GA(IGA1)), unord_setunion(IGA1, IGA, IGAUnion),
    fassert(intp_vars_indices_GA(IGAUnion)),
    retract(intp_vars_indices_GV(IGV1)), unord_setunion(IGV1, IGV, IGVUnion),
    fassert(intp_vars_indices_GV(IGVUnion)),
    retract(intp_vars_indices_LA(ILA1)), unord_setunion(ILA1, ILA, ILAUnion),
    fassert(intp_vars_indices_LA(ILAUnion)),
    retract(intp_vars_indices_LV(ILV1)), unord_setunion(ILV1, ILV, ILVUnion),
    fassert(intp_vars_indices_LV(ILVUnion)),
    %print_message("intp vars indices so far : % % % %\n",
    %    [IGAUnion,IGVUnion,ILAUnion,ILVUnion]),
    true.
interpolant_vars_aux(_,_,_,_,_):-
    error_message("something went wrong in interpolant_vars_aux/5").

vars_to_indices(_, _, _, _, [], [],[],[],[]):- !.
vars_to_indices(SGA, SGV, SLA, SLV, [Var|R], [I|IGA], IGV, ILA, ILV):-
    memberGndchk(Var, SGA), !,
    findnth(SGA, Var, 0, I),
    vars_to_indices(SGA, SGV, SLA, SLV, R, IGA, IGV, ILA, ILV).
vars_to_indices(SGA, SGV, SLA, SLV, [Var|R], IGA, [I|IGV], ILA, ILV):-
    memberGndchk(Var, SGV), !,
    findnth(SGV, Var, 0, I),
    vars_to_indices(SGA, SGV, SLA, SLV, R, IGA, IGV, ILA, ILV).
vars_to_indices(SGA, SGV, SLA, SLV, [Var|R], IGA, IGV, [I|ILA], ILV):-
    memberGndchk(Var, SLA), !,
    findnth(SLA, Var, 0, I),
    vars_to_indices(SGA, SGV, SLA, SLV, R, IGA, IGV, ILA, ILV).
vars_to_indices(SGA, SGV, SLA, SLV, [Var|R], IGA, IGV, ILA, [I|ILV]):-
    memberGndchk(Var, SLV), !,
    findnth(SLV, Var, 0, I),
    vars_to_indices(SGA, SGV, SLA, SLV, R, IGA, IGV, ILA, ILV).
% In principle, we should throw an error here if the var was not found
% in SGA,SGV,SLA,SLV. But using WP, we sometimes encounter unbounded vars
% in the interpolant because of (what I believe) predicate transformation.
% Therefore, we don't throw an error but simply just don't count that var.
vars_to_indices(SGA, SGV, SLA, SLV, [_|R], IGA, IGV, ILA, ILV):-
    vars_to_indices(SGA, SGV, SLA, SLV, R, IGA, IGV, ILA, ILV).

%-----------------------------------------------------------------------%
% delete_subsumed_memo_entries(+FName,+PP,+CallStack,
%			       +SGlobalArr,+SGlobalVar,+SLocalArr,+SLocalVar,
%			       +Interp)
%-----------------------------------------------------------------------%
% Optimization: if the interpolant to be stored in the memo table
% (Interp) subsumes an existing memoed interpolant then we can delete
% the memoed interpolant from the memo table. E.g., if we have in the
% memo {p !=1, a!=1} and we store a new entry { p!=1 } the entry {p
% !=1, a!=1} is redundant so we delete it.
%-----------------------------------------------------------------------%
delete_subsumed_memo_entries(FName,PP,CallStack,
			     SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
			     TCurrInterp):-
	current_tracer_flag(delete_subsumed_memo,y),
	config_to_index(PP, PPIdx),
	PP = [PPTerm|_],
	simplify_stack(CallStack, SimpleCallStack),
	%---------------------------------------------------------------%
	% This call will not count for statistics. If you want to,
	% then call check_t_profiled.
	%---------------------------------------------------------------%
	check_t(NodeId,
		PPTerm, PPIdx, FName, _,
		[sinfo(FName, PP)|SimpleCallStack], 			 
	        TGlobalArr, TGlobalVar, TLocalArr, TLocalVar, TMemoedInterp,
		_,_,_),
	SGlobalArr=TGlobalArr,SGlobalVar=TGlobalVar,
	SLocalArr =TLocalArr ,SLocalVar =TLocalVar,
	%---------------------------------------------------------------%
	% IMPORTANT: memo table entries are already projected. Thus,
	% we can just use subset operation to check if one memo entry
	% is subsumed by another. Jorge: I think the use of subset is
	% complete under the assumption the entries are in projected
	% form.  Even if not, we don't want to do something more
	% expensive.
	%---------------------------------------------------------------%
	is_memo_entry_subsumed(TCurrInterp,TMemoedInterp),
	%---------------------------------------------------------------%
	% FIXME: if PIPEMEMO is implemented we need to rewrite the
	% following lines:
	%---------------------------------------------------------------%	
	printf_to_atom(PName, "t%", PP),
        T =.. [PName, NodeId, FName, PPIdx,_,_,_,_,_,_,_,_,_,_],
	retract(T),
	debug_message("OPTIMIZATION: REMOVED SUBSUMED MEMO ENTRY for %:%!\n",
		      [FName,PP],yellow),
#ifdef  PROFILE	
	add_counter(num_of_deleted_subsumed_memo_entries,1),
#endif  /*PROFILE*/	
	fail.
delete_subsumed_memo_entries(_,_,_,_,_,_,_,_):- !.

%------------------------------------------------------------------------------
% For efficiency reasons, it uses only syntactic means
%------------------------------------------------------------------------------
is_memo_entry_subsumed(Intp,Intp):-
	current_tracer_flag(other_interp,n),
	!,
	fail.
is_memo_entry_subsumed(Intp1,Intp2):-
	current_tracer_flag(other_interp,n),
	!,
	unord_setsubset(Intp1,Intp2).
is_memo_entry_subsumed(Intp1,Intp2):-
	!,
	interp_strict_subset(Intp1,Intp2).

%------------------------------------------------------------------------------
% get_locked_constraints_ord(+ML,-NL)
%------------------------------------------------------------------------------
% ML is a list of 'o' symbols and NL is a list of numbers.
% E.g., get_locked_constraints_ord([o,_,o,o],[1,3,4]).
%------------------------------------------------------------------------------
% Assign a number to each locked constraint (marked with symbol 'o')
%------------------------------------------------------------------------------
get_locked_constraints_ord(MinML, Ord) :-
	get_locked_constraints_ord_aux(MinML, 1, Ord).

get_locked_constraints_ord_aux([], _N, []).
get_locked_constraints_ord_aux([M|R], N, [N|S]) :-
	M==o, !,
	get_locked_constraints_ord_aux(R, N+1, S).
get_locked_constraints_ord_aux([_|R], N, S) :-
	get_locked_constraints_ord_aux(R, N+1, S).


%------------------------------------------------------------------------------
% Unfold enabled transition
% ------------------------------------------------------------------------------
% Execute symbolically a feasible transition.  Succeed only when there
% are some enabled transitions, hence the test [_|_] for the 20th
% argument
%------------------------------------------------------------------------------
#ifdef  TESTING_CREST
% This clause says during "fast verification", if more than one transition becomes
% enabled, give up (i.e, halt combine operations) and backtrack
unfold_enabled(_NodeId, _Depth, FName, PP,
	       _GlobalArr, _GlobalVar, _LocalArr, _LocalVar,
	       _SGlobalArr, _SGlobalVar, _SLocalArr, _SLocalVar,
	       _CL, _ML, _CallStack, _ArrRef, _Loops, _TableSpace,
	       _LoopStack, _PathStack,
               Enabled, _Disabled, _AbsPtFlag) :-
    in_fast_verification_mode,
    combine_operations_enabled,
    length(Enabled,L), L > 1, !,
    print_message("choice-point encountered at %:%!\n",[FName,PP],red),
    halt_combine_operations,
    fail.
#endif
#ifdef  GC_INTP_INFEASIBLE
unfold_enabled(_NodeId, _Depth, FName, PP,
	       _GlobalArr, _GlobalVar, _LocalArr, _LocalVar,
	       _SGlobalArr, _SGlobalVar, _SLocalArr, _SLocalVar,
	       _CL, _ML, _CallStack, _ArrRef, _Loops, _TableSpace,
	       _LoopStack, _PathStack,
           _Enabled, _Disabled, _AbsPtFlag) :-
    in_gc_mode,
    counter_value(gc_status,1),
    encountered_during_gc(FName,PP), !,
    set_counter(gc_status,0),
    debug_message("GC failed! already encountered %::%\n",[FName,PP],red),
    fail.
unfold_enabled(_NodeId, _Depth, FName, PP,
	       _GlobalArr, _GlobalVar, _LocalArr, _LocalVar,
	       _SGlobalArr, _SGlobalVar, _SLocalArr, _SLocalVar,
	       _CL, _ML, _CallStack, _ArrRef, _Loops, _TableSpace,
	       _LoopStack, _PathStack,
           _Enabled, _Disabled, _AbsPtFlag) :-
    in_gc_mode,
    fassert(encountered_during_gc(FName,PP)),
    fail.
#endif
#ifdef  GROUND_EXPLANATION
unfold_enabled(_NodeId, _Depth, FName, PP,
	       _GlobalArr, _GlobalVar, _LocalArr, _LocalVar,
	       _SGlobalArr, _SGlobalVar, _SLocalArr, _SLocalVar,
	       _CL, _ML, _CallStack, _ArrRef, _Loops, _TableSpace,
	       _LoopStack, _PathStack,
               Enabled, _Disabled, _AbsPtFlag) :-
    counter_value(ground_trace_collection_mode, 1),
    length(Enabled, L), L>1, !,
    error_message("choice-point encountered in ground trace at %:%!\n",[FName,PP]).
#endif  /*GROUND_EXPLANATION*/
unfold_enabled(NodeId, Depth, FName, PP,
	       GlobalArr, GlobalVar, LocalArr, LocalVar,
	       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	       CL, ML, CallStack, ArrRef, Loops, TableSpace,
	       LoopStack, PathStack,
               [_|_], Disabled, AbsPtFlag) :-
	
#ifdef  TESTING_CREST
        % Unfold only the enabled transition that the CREST path
        % took. For disabled transitions, it's fine to unfold all of
        % them since we need to generate the negative interpolant from
        % them.
	get_trans_wrapper(FName, Id,  PP, 
		  GlobalArr1, GlobalVar1, SGlobalArr1, SGlobalVar1, 
		  LocalArr1 , LocalVar1 , SLocalArr1 ,  SLocalVar1,
		  PostPP,
		  PostGlobalArr , PostGlobalVar ,
		  PostSGlobalArr, PostSGlobalVar,
		  PostLocalArr  , PostLocalVar  ,
		  PostSLocalArr , PostSLocalVar ,
		  XCL, [], ArrRefX, BranchMode,
            %          /\
            %          |  Empty list here means that this is not a function call		  
		  Disabled),
#else
#ifdef  GROUND_EXPLANATION
	get_trans_ground(FName, Id,  PP, 
		  GlobalArr1, GlobalVar1, SGlobalArr1, SGlobalVar1, 
		  LocalArr1 , LocalVar1 , SLocalArr1 ,  SLocalVar1,
		  PostPP,
		  PostGlobalArr , PostGlobalVar ,
		  PostSGlobalArr, PostSGlobalVar,
		  PostLocalArr  , PostLocalVar  ,
		  PostSLocalArr , PostSLocalVar ,
		  XCL, [], ArrRefX, BranchMode,
            %          /\
            %          |  Empty list here means that this is not a function call		  
		  Disabled),
#else
	get_trans(FName, Id,  PP, 
		  GlobalArr1, GlobalVar1, SGlobalArr1, SGlobalVar1, 
		  LocalArr1 , LocalVar1 , SLocalArr1 ,  SLocalVar1,
		  PostPP,
		  PostGlobalArr , PostGlobalVar ,
		  PostSGlobalArr, PostSGlobalVar,
		  PostLocalArr  , PostLocalVar  ,
		  PostSLocalArr , PostSLocalVar ,
		  XCL, [], ArrRefX, BranchMode,
            %          /\
            %          |  Empty list here means that this is not a function call		  
		  Disabled),
#endif  /*GROUND_EXPLANATION*/
#endif  /*TESTING_CREST*/
#ifdef  GC_INTP_INFEASIBLE
    gc_is_unfold_ok, % unfold only if either (1) we are not in GC mode or
                     % (2) we are in GC mode but GC has not yet failed.
#endif  /*GC_INTP_INFEASIBLE*/
	%----------------------------------------------------------------------
	% We should only unfold when there is no conflict detected
	%----------------------------------------------------------------------
	%no_conflict(Depth),	
	no_conflict2(Depth),
#ifdef  GROUND_EXPLANATION
    add_ground_transition(FName, PostPP, BranchMode),
    print_ground_transition(Depth,FName,PP,PostPP,Id),
    check_level_zero_and_add_trace_length,
    check_level_zero_and_push_invariant(Depth, Id, FName, PP,
                                GlobalArr, GlobalVar, LocalArr, LocalVar,
                                SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
                                CL, ML, CallStack, ArrRef, Loops,
                                AbsPtFlag, TableSpace, LoopStack, PathStack,
     % new minmax state variables - if pushing invariant was found to be safe, minmax's
     % memory will be cleared and these will be reset. if not, the call will fail (backtrack)
     % refer to check_level_zero_and_push_invariant for more info
                                NewCL, NewML, NewLoops, NewAbsPtFlag, NewTableSpace,
                                NewLoopStack, NewPathStack),
#else
    NewCL=CL,NewML=ML,NewLoops=Loops,NewAbsPtFlag=AbsPtFlag,NewTableSpace=TableSpace,
    NewLoopStack=LoopStack,NewPathStack=PathStack,
#endif  /*GROUND_EXPLANATION*/
#ifdef  MINI_DEBUG_USE
        print_message("---- Transition depth % in % from % to % with id %\n",
		      [Depth,FName,PP,PostPP,Id]),
	pretty_printer_solver_state(FName,
                                    GlobalArr, GlobalVar, LocalArr, LocalVar,
                                    ArrRef),
#endif  /*MINI_DEBUG_USE*/
#ifdef  GRAPHVIZ_USE
        get_next_pp_context(FName,PostPP,Loops,PostPPContext),
        push_context_stack(FName,PostPPContext),
#endif
#ifdef  PROFILE		
	trace_true_branch(Id),
#endif	/*PROFILE*/
#ifdef  EXTERNAL_SOLVER
        % This is a builtin CLP(R) predicate. Make sure you compile
        % CLP(R) with option -DEXTERNAL_SOLVER. Otherwise, this call
        % will fail.
        extern_solver_add_choice_point,
#endif  /*EXTERNAL_SOLVER*/
        pathstack$push(t(FName,PP,Id),NewPathStack,NewPathStack1),
#ifdef  TESTING_CREST
        take_one_step_along_crest_path(FName,PP,BranchMode),
#endif  /*TESTING_CREST*/
	unfold_enabled_abstract(NodeId, Depth, Id, FName,
	                        %----------------------------------------------
	                        % Current state
	                        %----------------------------------------------
	                        PP,
	                        GlobalArr, GlobalVar, LocalArr, LocalVar,
				ArrRef,
				SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
				NewCL, NewML, NewLoopStack, 
	                        %----------------------------------------------
	                        % Current state copy at start of transition
	                        %----------------------------------------------
				GlobalArr1, GlobalVar1, LocalArr1, LocalVar1,
				ArrRefX,
				SGlobalArr1, SGlobalVar1,
				SLocalArr1,  SLocalVar1,
				XCL,
				%----------------------------------------------
				% Next state
				%----------------------------------------------
				PostPP,
				PostGlobalArr, PostGlobalVar,
				PostLocalArr,  PostLocalVar,
				PostSGlobalArr, PostSGlobalVar,
				PostSLocalArr,  PostSLocalVar,
				NewPathStack1,
				%----------------------------------------------
				% Other components
				%----------------------------------------------
				CallStack, NewLoops, NewTableSpace, [] , BranchMode, NewAbsPtFlag).


unfold_enabled(NodeId, Depth, FName, PP,
	       GlobalArr, GlobalVar, LocalArr, LocalVar,
	       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	       CL, ML, CallStack, ArrRef, Loops, TableSpace,
	       LoopStack, PathStack,
               [_|_], Disabled,AbsPtFlag) :-	       
	/*
	  NOTE: The inlining we do is only correct if following
	   assumptions hold:
	  
	   - Only one function call per transition.	   
	   - The function call is always the first operand on the lhs
	     (if more than one).

	   E.g., statements like x = y + y + foo() + y; where foo()
	   increments y by one, are compiled in the corresponding CLP
	   of:
	   	  	   
	   tmp = foo();
	   x = y + y + tmp + y;	  
	*/ 
	
#ifdef  TESTING_CREST
        % Unfold only the enabled transition that the CREST path
        % took. For disabled transitions, it's fine to unfold all of
        % them since we need to generate the negative interpolant from
        % them.
	get_trans_wrapper(FName, Id,  PP, 
		  GlobalArr , GlobalVar, SGlobalArr, SGlobalVar, 
		  LocalArr  , LocalVar , SLocalArr , SLocalVar ,
		  PostPP,
		  _PostGlobalArr,_PostGlobalVar,_PostSGlobalArr,_PostSGlobalVar,
		  _PostLocalArr ,_PostLocalVar ,_PostSLocalArr ,_PostSLocalVar,
		  _XCL,
		  [call(CalleeFName, FormalLocalPars, SFormalLocalPars, CCL)],
		  ArrRefX, BranchMode, Disabled),
#else
	get_trans(FName, Id,  PP, 
		  GlobalArr , GlobalVar, SGlobalArr, SGlobalVar, 
		  LocalArr  , LocalVar , SLocalArr , SLocalVar ,
		  PostPP,
		  _PostGlobalArr,_PostGlobalVar,_PostSGlobalArr,_PostSGlobalVar,
		  _PostLocalArr ,_PostLocalVar ,_PostSLocalArr ,_PostSLocalVar,
		  _XCL,
		  [call(CalleeFName, FormalLocalPars, SFormalLocalPars, CCL)],
		  ArrRefX, BranchMode, Disabled),
#endif /*TESTING_CREST*/
	%----------------------------------------------------------------------
	% We should only unfold when there is no conflict detected
	%----------------------------------------------------------------------
	no_conflict2(Depth),	
	unfold_inlined_function_call_aux(Depth, Id, FName, 
			caller(FName, PP, PostPP,
			       GlobalArr  , GlobalVar , LocalArr  , LocalVar,	
			       SGlobalArr , SGlobalVar, SLocalArr , SLocalVar),
			       % constraints for formal/actual parameters 
			       CCL, 
                               CL, ML, PostCL,PostML,
			callee(CalleeFName        , CalleePostPP,
			       FormalLocalPars    , SFormalLocalPars,
			       CalleePostGlobalArr, CalleePostSGlobalArr,
			       CalleePostGlobalVar, CalleePostSGlobalVar,
			       CalleePostLocalArr , CalleePostSLocalArr,
			       CalleePostLocalVar , CalleePostSLocalVar),
			CallStack, CallStack1, ArrRef, ArrRefX, PostArrRef,
		        Loops, _,_,_, TableSpace),

#ifdef  TESTING_CREST
        % funcall represents a call, which does not need to be tracked
        % unless TESTING_CREST is defined
        pathstack$push(funcall,PathStack,NewPathStack),
#else
        NewPathStack=PathStack,
#endif  /*TESTING_CREST*/
        unfold_enabled_unfold_backtrack(NodeId, Depth, call(Id), CalleeFName,
	                %------------------------------------------------------
	                % Current state (caller)
	                %------------------------------------------------------
	                PP,
			SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			CL, ML, CCL,
			%------------------------------------------------------
			% Next state    (callee)
			%------------------------------------------------------
			CalleePostPP,
			CalleePostGlobalArr ,  CalleePostGlobalVar,
			CalleePostLocalArr  ,  CalleePostLocalVar,
			PostArrRef, 
			CalleePostSGlobalArr,  CalleePostSGlobalVar,
			CalleePostSLocalArr ,  CalleePostSLocalVar,
			PostCL, PostML, LoopStack, NewPathStack,
			%------------------------------------------------------
			% Other information
			%------------------------------------------------------
			CallStack1, Loops, TableSpace, _Call, BranchMode, AbsPtFlag).


unfold_enabled_abstract(NodeId, Depth, Id, FName,
	                %------------------------------------------------------
	                % Current state
	                %------------------------------------------------------
	                PP,
	                GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
			SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			CL, ML, LoopStack,
	                %------------------------------------------------------
	                % Current state copy at start of transition
	                %------------------------------------------------------
			GlobalArr1, GlobalVar1, LocalArr1, LocalVar1,
			ArrRefX,
			SGlobalArr1, SGlobalVar1, SLocalArr1,  SLocalVar1,
			XCL,
			%------------------------------------------------------
			% Next state
			%------------------------------------------------------
			PostPP,
			PostGlobalArr, PostGlobalVar,
			PostLocalArr,  PostLocalVar,
			PostSGlobalArr, PostSGlobalVar,
			PostSLocalArr,  PostSLocalVar,
			PathStack,
			%------------------------------------------------------
			% Other components
			%------------------------------------------------------
			CallStack, Loops, TableSpace, Call, BranchMode, AbsPtFlag) :-
	apply_sibling_answers(NodeId, Depth, 
	              %--------------------------------------------------------
	              % Current state
	              %--------------------------------------------------------
	              GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,			      
	              SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		      CL, ML, LoopStack,
	              %--------------------------------------------------------
		      % Output new abstracted, evaluated state
	              %--------------------------------------------------------
		      GlobalArr1, GlobalVar1, LocalArr1, LocalVar1, ArrRef1),
#ifdef  DEBUG_USE
        print_message("SPECIAL STEP: apply min's to siblings\n", [],yellow),
	print_message("\tAfter applying SIBLING' MINs: \n",[],yellow),
	pretty_printer_solver_state(FName,
				    GlobalArr1, GlobalVar1, LocalArr1, LocalVar1,
				    ArrRef1),	
#endif /*DEBUG_USE*/
	SGlobalArr = SGlobalArr1,
	SGlobalVar = SGlobalVar1,
	SLocalArr  = SLocalArr1,
	SLocalVar  = SLocalVar1,
	
	append(ArrRefX, ArrRef1, PostArrRef),	
        add_constraints_path(XCL, CL, ML, PostCL, PostML),
#ifdef  GRAPHVIZ_USE
        record_sym_graph_edge(feasible,
			      src(FName,PP,
				  SGlobalArr,SGlobalVar,SLocalArr,SLocalVar),
			      dest(FName,PostPP,
				   PostSGlobalArr,PostSGlobalVar,
				   PostSLocalArr,PostSLocalVar),
			      Id,XCL,BranchMode,Loops),
#endif  /*GRAPHVIZ_USE*/
	!,
	%----------------------------------------------------------------------
	% This is the case when we actually have sibling answer: The other
	% case is handled by the next clause
	%----------------------------------------------------------------------

        unfold_enabled_unfold_backtrack(NodeId, Depth, Id, FName,
	                %------------------------------------------------------
	                % Current state
	                %------------------------------------------------------
	                PP,
			SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			CL, ML, XCL,
					
			%------------------------------------------------------
			% Next state
			%------------------------------------------------------
			PostPP,
			PostGlobalArr, PostGlobalVar,
			PostLocalArr,  PostLocalVar,
			PostArrRef,
			PostSGlobalArr, PostSGlobalVar,
			PostSLocalArr,  PostSLocalVar,
			PostCL, PostML, LoopStack, PathStack,

			%------------------------------------------------------
			% Other components
			%------------------------------------------------------
			CallStack, Loops, TableSpace, Call, BranchMode, AbsPtFlag).
unfold_enabled_abstract(NodeId, Depth, Id, FName,
	                %------------------------------------------------------
	                % Current state
	                %------------------------------------------------------
	                PP,
	                GlobalArr, GlobalVar, LocalArr, LocalVar,
			ArrRef,
			SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			CL, ML, LoopStack,
	                %------------------------------------------------------
	                % Current state copy at start of transition
	                %------------------------------------------------------
			GlobalArr1, GlobalVar1, LocalArr1, LocalVar1,
			ArrRefX,
			SGlobalArr1, SGlobalVar1, SLocalArr1,  SLocalVar1,
			XCL,
			%------------------------------------------------------
			% Next state
			%------------------------------------------------------
			PostPP,
			PostGlobalArr, PostGlobalVar,
			PostLocalArr,  PostLocalVar,
			PostSGlobalArr, PostSGlobalVar,
			PostSLocalArr,  PostSLocalVar,
			PathStack,
			%------------------------------------------------------
			% Other components
			%------------------------------------------------------
			CallStack, Loops, TableSpace, Call, BranchMode, AbsPtFlag) :-
	%----------------------------------------------------------------------
	% This is the case when we don't have min abstraction from some
	% sibling.
	%----------------------------------------------------------------------
	GlobalArr = GlobalArr1,
	GlobalVar = GlobalVar1,
	LocalArr  = LocalArr1,
	LocalVar  = LocalVar1,

	SGlobalArr = SGlobalArr1,
	SGlobalVar = SGlobalVar1,
	SLocalArr  = SLocalArr1,
	SLocalVar  = SLocalVar1,

	append(ArrRefX, ArrRef, PostArrRef),
        add_constraints_path(XCL, CL, ML, PostCL, PostML),
#ifdef  EXTERNAL_SOLVER
        %----------------------------------------------------------------%
        % Insert a choice point. Add the constraints. Not
        % satisfiability check since we know that the constraints are
        % sat.
        %----------------------------------------------------------------%
        debug_message("[EXTERNAL SOLVER] BEGIN: adding constraints \n",[]),
        extern_solver_add_cnstr(XCL,
				state(FName,
				      SGlobalArr,SGlobalVar,
				      SLocalArr,SLocalVar)
				),
        debug_message("[EXTERNAL SOLVER] END \n\n",[]),	
#endif  /*EXTERNAL_SOLVER*/
#ifdef  GRAPHVIZ_USE
        record_sym_graph_edge(feasible,
			      src(FName,PP,
				  SGlobalArr,SGlobalVar,
				  SLocalArr,SLocalVar),
			      dest(FName,PostPP,
				   PostSGlobalArr,PostSGlobalVar,
				   PostSLocalArr,PostSLocalVar),
			      Id,XCL,BranchMode,Loops),
#endif  /*GRAPHVIZ_USE*/
        unfold_enabled_unfold_backtrack(NodeId, Depth, Id, FName,
	                %------------------------------------------------------
	                % Current state
	                %------------------------------------------------------
	                PP,
			SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			CL, ML, XCL,

			%------------------------------------------------------
			% Next state
			%------------------------------------------------------
			PostPP,
			PostGlobalArr, PostGlobalVar,
			PostLocalArr,  PostLocalVar,
			PostArrRef,
			PostSGlobalArr, PostSGlobalVar,
			PostSLocalArr,  PostSLocalVar,
			PostCL, PostML, LoopStack, PathStack,
			%------------------------------------------------------
			% Other information
			%------------------------------------------------------
			CallStack, Loops, TableSpace, Call, BranchMode, AbsPtFlag).

%------------------------------------------------------------------------------
% unfold_enabled_unfold_backtrack
%------------------------------------------------------------------------------
% The first clause executes symbolically the transition and the second
% propagate backward the interpolants. This is a core operation!
%------------------------------------------------------------------------------
unfold_enabled_unfold_backtrack(_NodeId, Depth, Id, FName,
	%----------------------------------------------------------------------
	% Current state
	%----------------------------------------------------------------------
	_PP,
	_SGlobalArr, _SGlobalVar, _SLocalArr, _SLocalVar,
	_CL, _ML, _XCL,
	%----------------------------------------------------------------------
	% Next state
	%----------------------------------------------------------------------
	PostPP,
	PostGlobalArr, PostGlobalVar, PostLocalArr,  PostLocalVar,
	PostArrRef,
	PostSGlobalArr, PostSGlobalVar, PostSLocalArr,  PostSLocalVar,
	PostCL, PostML, LoopStack, PathStack,
	%----------------------------------------------------------------------
	% Other information
	%----------------------------------------------------------------------
	CallStack, Loops, TableSpace, _Call, _BranchMode, _AbsPtFlag) :-

	%----------------------------------------------------------------------
	% We reset the abstraction flag to 0.
	%----------------------------------------------------------------------
	AbsPtFlag = 0,	
	unfold(Depth+1, Id, FName, PostPP,
	       PostGlobalArr, PostGlobalVar, PostLocalArr, PostLocalVar,
	       PostSGlobalArr, PostSGlobalVar, PostSLocalArr, PostSLocalVar,
	       PostCL, PostML,
	       CallStack,
	       PostArrRef, 
	       Loops, _UnknownVars , AbsPtFlag, TableSpace, 
	       LoopStack, PathStack).
unfold_enabled_unfold_backtrack(NodeId, Depth, Id, FName,
	%----------------------------------------------------------------------
	% Current state
	%----------------------------------------------------------------------
	PP,
	SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	CL, ML, XCL, 
	%----------------------------------------------------------------------
	% Next state
	%----------------------------------------------------------------------
	PostPP,
	_PostGlobalArr, _PostGlobalVar, _PostLocalArr,  _PostLocalVar,
	_PostArrRef,
	PostSGlobalArr, PostSGlobalVar, PostSLocalArr,  PostSLocalVar,
	PostCL, PostML, LoopStack, PathStack,
	%----------------------------------------------------------------------
	% Other information
	%----------------------------------------------------------------------
	CallStack, _Loops, _TableSpace, _Call, BranchMode, _AbsPtFlag) :-
	%----------------------------------------------------------------------
	% Only propagate backward when no conflict found
	%----------------------------------------------------------------------
	no_conflict(Depth),
	propagate_backward(NodeId, Id, BranchMode, Depth, FName,
			   CallStack,
			   SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,			   
	                   PP, CL, ML, XCL, LoopStack,
			   PostSGlobalArr, PostSGlobalVar, PostSLocalArr, PostSLocalVar,
	                   PostPP, PostCL, PostML,LoopStack,PathStack),
#ifdef  EXTERNAL_SOLVER
        % This is a builtin CLP(R) predicate. Make sure you compile
        % CLP(R) with option -DEXTERNAL_SOLVER. Otherwise, this call
        % will fail.
        extern_solver_backtrack,
#endif 	
	!, fail.

%-----------------------------------------------------------------------------
% Unfold disabled transitions
%-----------------------------------------------------------------------------
% Executed only when there are some disabled transitions, hence the
% test [_|_] for the last argument
%-----------------------------------------------------------------------------
unfold_disabled(NodeId, Depth, FName, PP,
                GlobalArr, GlobalVar, LocalArr, LocalVar,
		SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		CL, ML, CallStack, ArrRef, Loops, TableSpace,
		LoopStack, PathStack,		
                Enabled, [_|_], AbsPtFlag) :-
	
	get_trans(FName, Id,
		  PP, 
		  GlobalArr2, GlobalVar2, SGlobalArr2, SGlobalVar2, 
		  LocalArr2,  LocalVar2,  SLocalArr2,  SLocalVar2,
		  PostPP,
		  PostGlobalArr, PostGlobalVar, PostSGlobalArr, PostSGlobalVar,
		  PostLocalArr,  PostLocalVar,  PostSLocalArr,  PostSLocalVar,
		  XCL, Call, ArrRefX, BranchMode,
		  Enabled),

	%----------------------------------------------------------------------
	% We should only unfold when there is no conflict detected
	%----------------------------------------------------------------------
	%no_conflict(Depth),
	no_conflict2(Depth),	
#ifdef  MINI_DEBUG_USE       
        print_message("---- Transition depth % in % from % to % with id %\n",
		      [Depth,FName,PP,PostPP,Id]),
	pretty_printer_solver_state(FName,
                                    GlobalArr, GlobalVar, LocalArr, LocalVar,
                                    ArrRef),
#endif  /*MINI_DEBUG_USE*/
#ifdef  GRAPHVIZ_USE
        get_next_pp_context(FName,PostPP,Loops,PostPPContext),
        push_context_stack(FName,PostPPContext),
#endif  /*(defined(GRAPHVIZ_USE))*/
%#ifdef  EXTERNAL_SOLVER
        % This is a builtin CLP(R) predicate. Make sure you compile
        % CLP(R) with option -DEXTERNAL_SOLVER. Otherwise, this call
        % will fail.
%        extern_solver_add_choice_point,
%#endif
        pathstack$push(t(FName,PP,Id),PathStack,NewPathStack),
	unfold_disabled_abstract(NodeId, Depth, FName, Id,
	        %--------------------------------------------------------------
	        % Current state
	        %--------------------------------------------------------------
	        PP,
		GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
		SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		CL, ML, LoopStack,

	        %--------------------------------------------------------------
		% Not-yet-unified current state's copy (start of transition)
	        %--------------------------------------------------------------
		GlobalArr2, GlobalVar2, LocalArr2, LocalVar2, ArrRefX,
		SGlobalArr2, SGlobalVar2, SLocalArr2, SLocalVar2, XCL,
		
	        %--------------------------------------------------------------
		% Post-state
	        %--------------------------------------------------------------
		PostPP,
	        PostGlobalArr, PostGlobalVar, PostLocalArr, PostLocalVar,
		PostSGlobalArr, PostSGlobalVar, PostSLocalArr,  PostSLocalVar,
		NewPathStack,
		%--------------------------------------------------------------
		% Other information
		%--------------------------------------------------------------
		CallStack, Loops, TableSpace, Call, BranchMode, AbsPtFlag).


unfold_disabled_abstract(NodeId, Depth, FName, Id,
        %----------------------------------------------------------------------
        % Current state
	%----------------------------------------------------------------------
	PP,
	GlobalArr,  GlobalVar, LocalArr, LocalVar, ArrRef,
	SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	CL, ML, LoopStack,

	%----------------------------------------------------------------------
	% Not-yet-unified current state's copy (start of transition)
	%----------------------------------------------------------------------
	GlobalArr2,  GlobalVar2,  LocalArr2,  LocalVar2,  ArrRefX,
	SGlobalArr2, SGlobalVar2, SLocalArr2, SLocalVar2, XCL,

	%----------------------------------------------------------------------
	% Post-state
	%----------------------------------------------------------------------
	PostPP,
	PostGlobalArr, PostGlobalVar, PostSGlobalArr, PostSGlobalVar,
	PostLocalArr,  PostLocalVar,  PostSLocalArr,  PostSLocalVar,
	PathStack,		 
	%----------------------------------------------------------------------
	% Other information
	%----------------------------------------------------------------------
        CallStack, Loops, TableSpace, Call, BranchMode, AbsPtFlag) :-

	%----------------------------------------------------------------------
	% We go pick sibling min answers and run the current goal with them
	%----------------------------------------------------------------------
%ifdef  DEBUG_USE	
%	print_message("LoopStack=%\n", [LoopStack]),
%endif
	apply_sibling_answers(NodeId, Depth, 
	              %--------------------------------------------------------
	              % Current state
	              %--------------------------------------------------------
		      GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,			      
	              SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		      CL, ML, LoopStack,
	              %--------------------------------------------------------
		      % Output new abstracted, evaluated state
	              %--------------------------------------------------------
		      GlobalArr1, GlobalVar1, LocalArr1, LocalVar1, ArrRef1),
#ifdef  DEBUG_USE
        print_message("SPECIAL STEP: apply min's to siblings\n", [],yellow),
	print_message("\tAfter applying SIBLING' MINs: \n",[],yellow),
	pretty_printer_solver_state(FName,
				    GlobalArr1, GlobalVar1, LocalArr1, LocalVar1,
				    ArrRef1),	
#endif /*DEBUG_USE*/	
        !,
	unfold_sat_test(NodeId, Depth, FName, Id,
		%--------------------------------------------------------------
		% Current state
		%--------------------------------------------------------------
	        PP,
		GlobalArr1, GlobalVar1, LocalArr1, LocalVar1, ArrRef1,
		SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		CL, ML, LoopStack,

		%--------------------------------------------------------------
		% Not-yet unified current state's copy
		%--------------------------------------------------------------
		GlobalArr2,  GlobalVar2,  LocalArr2,  LocalVar2,  ArrRefX,
		SGlobalArr2, SGlobalVar2, SLocalArr2, SLocalVar2, XCL,

		%--------------------------------------------------------------
		% Post-state
		%--------------------------------------------------------------
		PostPP,
		PostGlobalArr, PostGlobalVar, PostSGlobalArr, PostSGlobalVar,
		PostLocalArr,  PostLocalVar,  PostSLocalArr,  PostSLocalVar,
		PathStack,	
		%--------------------------------------------------------------
		% Other information
		%--------------------------------------------------------------
                CallStack, Loops, TableSpace, Call, BranchMode, AbsPtFlag).
unfold_disabled_abstract(NodeId, Depth, FName, Id,
        %----------------------------------------------------------------------
        % Current state
	%----------------------------------------------------------------------
	PP,
	GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
	SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	CL, ML, LoopStack,

	%----------------------------------------------------------------------
	% Not-yet-unified current state's copy (start of transition)
	%----------------------------------------------------------------------
	GlobalArr2,  GlobalVar2,  LocalArr2,  LocalVar2,  ArrRefX,
	SGlobalArr2, SGlobalVar2, SLocalArr2, SLocalVar2, XCL,

	%----------------------------------------------------------------------
	% Post-state
	%----------------------------------------------------------------------
	PostPP,
	PostGlobalArr, PostGlobalVar, PostSGlobalArr, PostSGlobalVar,
	PostLocalArr,  PostLocalVar,  PostSLocalArr,  PostSLocalVar,
	PathStack,		 
	%----------------------------------------------------------------------
	% Other information
	%----------------------------------------------------------------------
	CallStack, Loops, TableSpace, Call, BranchMode, AbsPtFlag) :-
	%----------------------------------------------------------------------
	% No min answers:
	% Since the transitions are disabled, we call unfold_sat_test just to
	% generate interpolants
	%----------------------------------------------------------------------
	unfold_sat_test(NodeId, Depth, FName, Id,
		%--------------------------------------------------------------
		% Current state
		%--------------------------------------------------------------
	        PP,
		GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
		SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		CL, ML, LoopStack,

		%--------------------------------------------------------------
		% Not-yet unified current state's copy
		%--------------------------------------------------------------
		GlobalArr2,  GlobalVar2,  LocalArr2,  LocalVar2,  ArrRefX,
		SGlobalArr2, SGlobalVar2, SLocalArr2, SLocalVar2, XCL,

		%--------------------------------------------------------------
		% Post-state
		%--------------------------------------------------------------
		PostPP,
		PostGlobalArr, PostGlobalVar, PostSGlobalArr, PostSGlobalVar,
		PostLocalArr,  PostLocalVar,  PostSLocalArr,  PostSLocalVar,
		PathStack,	
		%--------------------------------------------------------------
		% Other information
		%--------------------------------------------------------------
		CallStack, Loops, TableSpace, Call, BranchMode, AbsPtFlag).

%==============================================================================
% Subroutine for handling infeasible transitions
%==============================================================================
unfold_sat_test(NodeId, Depth, FName, Id,
	%----------------------------------------------------------------------
	% Current state
	%----------------------------------------------------------------------
	PP,
	GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
	SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	CL, ML, LoopStack,
	%----------------------------------------------------------------------
	% Not-yet unified current state's copy
	%----------------------------------------------------------------------
	GlobalArr1,  GlobalVar1,  LocalArr1,  LocalVar1,  ArrRefX,
	SGlobalArr1, SGlobalVar1, SLocalArr1, SLocalVar1, XCL,
	%----------------------------------------------------------------------
	% Post-state
	%----------------------------------------------------------------------
	PostPP,
	PostGlobalArr, PostGlobalVar, PostLocalArr, PostLocalVar,
	PostSGlobalArr,  PostSGlobalVar,  PostSLocalArr,  PostSLocalVar,
	PathStack,
        %----------------------------------------------------------------------
        % Other information
        %----------------------------------------------------------------------
        CallStack, Loops, TableSpace, Call, BranchMode, AbsPtFlag):-
	
	% These unifications are needed here for
	% extern_solver_add_cnstr_and_check_sat/1 (inside path_feasibility_test).
	SGlobalArr = SGlobalArr1,
	SGlobalVar = SGlobalVar1,
	SLocalArr  = SLocalArr1,
	SLocalVar  = SLocalVar1,
	path_feasibility_test(BranchMode, FName, PP, PostPP, 
			      GlobalArr ,GlobalVar ,LocalArr ,LocalVar,
			      GlobalArr1,GlobalVar1,LocalArr1,LocalVar1,
			      state(FName,SGlobalArr,SGlobalVar,SLocalArr,SLocalVar),
			      CL, XCL, ML, PostCL, PostML,ArrRef, ArrRefX, PostArrRef),
	!,
#ifdef  PROFILE		
	trace_true_branch(Id),
#endif	/*PROFILE*/
#ifdef  GRAPHVIZ_USE
        record_sym_graph_edge(feasible,
			      src(FName,PP,
				  SGlobalArr,SGlobalVar,SLocalArr,SLocalVar),
			      dest(FName,PostPP,
				   PostSGlobalArr,PostSGlobalVar,PostSLocalArr,PostSLocalVar),
			      Id,XCL,BranchMode,Loops),
#endif  /*GRAPHVIZ_USE*/
	unfold_enabled_unfold_backtrack(NodeId, Depth, Id, FName,
		%--------------------------------------------------------------
		% Current state
		%--------------------------------------------------------------
	        PP,
		SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		CL, ML, XCL,
		%--------------------------------------------------------------
		% Next state
	        %--------------------------------------------------------------
		PostPP,
		PostGlobalArr, PostGlobalVar, PostLocalArr,  PostLocalVar,
		PostArrRef,
		PostSGlobalArr, PostSGlobalVar, PostSLocalArr,  PostSLocalVar,
		PostCL, PostML, LoopStack, PathStack,
		%--------------------------------------------------------------
		% Other information
		%--------------------------------------------------------------
		CallStack, Loops, TableSpace, Call, BranchMode, AbsPtFlag).
unfold_sat_test(NodeId, Depth, FName, Id,
	%----------------------------------------------------------------------
	% Current state
	%----------------------------------------------------------------------
	PP,
	GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
	SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	CL, ML, LoopStack,
	%----------------------------------------------------------------------
	% Not-yet unified current state's copy
	%----------------------------------------------------------------------
	_GlobalArr1, _GlobalVar1, _LocalArr1, _LocalVar1, _ArrRefX,
	SGlobalArr1, SGlobalVar1, SLocalArr1, SLocalVar1, XCL,
	%----------------------------------------------------------------------
	% Post-state
	%----------------------------------------------------------------------
	PostPP,
	PostGlobalArr , PostGlobalVar , PostLocalArr , PostLocalVar,
	PostSGlobalArr, PostSGlobalVar, PostSLocalArr, PostSLocalVar,
	PathStack,	
	%----------------------------------------------------------------------
	% Other information
	%----------------------------------------------------------------------
        CallStack, Loops, TableSpace, _Call, BranchMode, _AbsPtFlag):-
#if     !defined(MINI_DEBUG_USE) && !defined(GRAPHVIZ_USE)
        %To avoid warnings
        Id=_,FName=_,PP=_,PostPP=_,
#endif 
	%----------------------------------------------------------------------
	% The current transition is infeasible
	%----------------------------------------------------------------------	
#ifdef  MINI_DEBUG_USE
	print_message("TERMINAL: infeasible path found % from % to % (%).\n",		    
		      [FName,PP,PostPP,Id],red),
#endif  /*MINI_DEBUG_USE*/
	%----------------------------------------------------------------------
	% We first unify the symbolic part
	%----------------------------------------------------------------------
        SGlobalArr = SGlobalArr1,
	SGlobalVar = SGlobalVar1,
	SLocalArr  = SLocalArr1,
	SLocalVar  = SLocalVar1,	
       %add_constraints_path(XCL, CL, ML, PostCL, PostML),	
%#ifdef  EXTERNAL_SOLVER
        % Don't add here for now. The only purpose of adding
        % constraints is for generating interpolant later but external
        % solver doesn't do that for the moment.
        % extern_solver_add_cnstr(XCL),
%#endif  /*EXTERNAL_SOLVER*/
#ifdef  PROFILE		
        trace_infeasible_paths(Depth),
	trace_false_branch(Id),
#endif	/*PROFILE*/
#ifdef  GRAPHVIZ_USE
        record_sym_graph_edge(infeasible,
			      src(FName,PP,
				  SGlobalArr,SGlobalVar,SLocalArr,SLocalVar),
			      dest(FName,PostPP,
				   PostSGlobalArr,PostSGlobalVar,PostSLocalArr,PostSLocalVar),
			      Id,XCL,BranchMode,Loops),
	pop_context_stack,
#else
        % To prevent warnings
	BranchMode=_,Loops=_,
#endif	/*(defined(GRAPHVIZ_USE))*/
#ifdef  TESTING_CREST
        PathStack=[_|PathStack1],
	mark_child_as_visited(FName,PP,PathStack1),
#else
        % To prevent warnings
        PathStack=_,			
#endif /*TESTING_CREST*/
#ifdef  GC_INTP_INFEASIBLE
        pre_gc_intp_infeasible(Depth),
        gc_intp_infeasible(Depth, Id, FName, PostPP,
           % Important: by not passing the Post- versions of these variables and
           % CL/ML, we are "abstracting" the infeasible guard
	       GlobalArr, GlobalVar, LocalArr, LocalVar,
	       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	       CL, ML,
	       CallStack,
	       ArrRef, 
	       Loops, _UnknownVars , _AbsPtFlag, TableSpace, 
	       LoopStack, PathStack),
        post_gc_intp_infeasible(Depth),
        NodeId=_,XCL=_, % to avoid warnings

        % Decide how to compute interpolant based on GC's status
        counter_value(gc_status, N),
        (N=1, % GC passed - propagate the safety answer (GC interpolant) back
        propagate_backward(NodeId, Id, BranchMode, Depth, FName,
                   CallStack,
                   SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,			   
                           PP, CL, ML, XCL, LoopStack,
                   PostSGlobalArr, PostSGlobalVar, PostSLocalArr, PostSLocalVar,
                           PostPP, CL, ML,LoopStack,PathStack)
        ;
        % GC failed (N=0) or GC passed but we're at safety check PP (N=2)
        % Use "Jorge interpolant"
        set_counter(gc_status, 1), % consider as though GC "passed" but produced
                                   % Jorge interpolant
        optimized_create_infeasible_interpolant(Depth, FName, PP, PostPP, NodeId,
	 					PostGlobalArr , PostGlobalVar ,
						PostLocalArr  , PostLocalVar,       
	 					PostSGlobalArr, PostSGlobalVar,
						PostSLocalArr , PostSLocalVar,
						CL, ML, XCL, CallStack, ArrRef, LoopStack)
        ),
#else
        GlobalArr=_,GlobalVar=_,LocalArr=_,LocalVar=_,TableSpace=_, % to avoid warnings
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % OPTIMIZATION (Apr'12): reuse the interpolant of a sibling if possible
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        optimized_create_infeasible_interpolant(Depth, FName, PP, PostPP, NodeId,
	 					PostGlobalArr , PostGlobalVar ,
						PostLocalArr  , PostLocalVar,       
	 					PostSGlobalArr, PostSGlobalVar,
						PostSLocalArr , PostSLocalVar,
						CL, ML, XCL, CallStack, ArrRef, LoopStack),
#endif  /*GC_INTP_INFEASIBLE*/
	%----------------------------------------------------------------------
	% Note that loop context is empty: We are not considering any loop
	% at this endpoint
	%----------------------------------------------------------------------
        % LoopContext=[],
        % mm_create_infeasible_interpolant(FName, NodeId, Depth,
	%				 PostSGlobalArr, PostSGlobalVar,
	%				 PostSLocalArr,  PostSLocalVar,		       
	%				 CL, ML, XCL, LoopStack, LoopContext),
	!,
%#ifdef  EXTERNAL_SOLVER
        % This is a builtin CLP(R) predicate. Make sure you compile
        % CLP(R) with option -DEXTERNAL_SOLVER. Otherwise, this call
        % will fail.
%       extern_solver_backtrack,
%#endif 	
	%----------------------------------------------------------------------
	% Fail here to force unfold_nonexit/unfold_exit pick another transition
	%----------------------------------------------------------------------
	fail. 

#ifdef  GC_INTP_INFEASIBLE
% -------------------------
% Pre-GC setup
% -------------------------
pre_gc_intp_infeasible(Depth):-
    not in_gc_mode,
    debug_message("GC STARTED at Depth %!\n",[Depth]),
    gc_pre_sanity,
    add_counter(num_gc_applied,1),
    fassert(gc_root_depth(Depth)),
    set_counter(gc_status,1).
pre_gc_intp_infeasible(_).

% ---------------------------------------------------------------------
% Predicate that performs GC (at the moment simply unfolding the tree)
% ---------------------------------------------------------------------
gc_intp_infeasible(Depth, _, _, PP,
        _, _, _, _,
        _, _, _, _,
        _, _,
        _,
        _, 
        _, _ , _, _, 
        _, _) :-
    is_error_reachable(PP),
    % If this is true, then the error PP is actually infeasible but since we
    % "abstracted" the guard it became feasible. Hence mark GC as success.
    set_counter(gc_status,2),
    % If GC was triggered at this Depth, subtract 1 from num_gc_applied as this
    % is not really a GC application
    ((gc_root_depth(Depth), add_counter(num_gc_applied,0-1), add_counter(num_gc_success,0-1))
    ; true),
    !.
gc_intp_infeasible(_, _, FName, PP,
        _, _, _, _,
        _, _, _, _,
        _, _,
        _,
        _, 
        _, _ , _, _, 
        _, _) :-
    is_ancestor_pp(FName,PP), !,
    set_counter(gc_status, 0).
gc_intp_infeasible(Depth, Id, FName, PP,
        GlobalArr, GlobalVar, LocalArr, LocalVar,
        SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
        CL, ML,
        CallStack,
        ArrRef, 
        Loops, _UnknownVars , AbsPtFlag, TableSpace, 
        LoopStack, PathStack) :-
    AbsPtFlag = 0,
	unfold(Depth+1, Id, FName, PP,
	       GlobalArr, GlobalVar, LocalArr, LocalVar,
	       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	       CL, ML,
	       CallStack,
	       ArrRef, 
	       Loops, _UnknownVars , AbsPtFlag, TableSpace, 
	       LoopStack, PathStack), !.
gc_intp_infeasible(_, _, _, _,
        _, _, _, _,
        _, _, _, _,
        _, _,
        _,
        _, 
        _, _ , _, _, 
        _, _).

% ------------------------------
% Post-GC setup
% ------------------------------
post_gc_intp_infeasible(Depth):-
    gc_root_depth(Depth),
    retract(gc_root_depth(Depth)),
    debug_message("GC OVER at Depth %!\n",[Depth]),
    gc_sanity,
    gc_cleanup,
    counter_value(gc_status,N), N>=1,
    add_counter(num_gc_success,1).
post_gc_intp_infeasible(_).

gc_pre_sanity:-
    safety_answer(_,_,_,_,_,_,1), !,
    error_message("gc_pre_sanity: There exists an answer before GC invoked!\n",[]).
gc_pre_sanity.

gc_sanity:- % if GC passed, there should be exactly 1 answer asserted during GC
    counter_value(gc_status,1),
    set_counter(gc_sanity_ctr,0),
    safety_answer(_,_,_,_,_,_,1),
    add_counter(gc_sanity_ctr,1),
    counter_value(gc_sanity_ctr,N),
    N>1,
    error_message("GC sanity check failed! More than one safety answer found.\n",[N]).
gc_sanity:-
    counter_value(gc_status, 1),
    not(safety_answer(_,_,_,_,_,_,1)),
    error_message("GC sanity check failed! No safety answer found.\n",[]).
gc_sanity.

gc_cleanup:-
    retract(encountered_during_gc(_,_)),
    fail.
gc_cleanup:-
    counter_value(gc_status,0), % if GC failed, remove all safety answers
    retract(safety_answer(_,_,_,_,_,_,1)),
    fail.
gc_cleanup.

% -------------------------------------------------------------------------
% Decide how to compute interpolant for the inf. path based on GC's status
% -------------------------------------------------------------------------
gc_intp_infeasible_decision(1):-
    in_gc_mode, counter_value(gc_status,0), !.
gc_intp_infeasible_decision(2):-
    not in_gc_mode, counter_value(gc_status,0), !.
gc_intp_infeasible_decision(3):-
    counter_value(gc_status,1), !.
gc_intp_infeasible_decision(4):-
    counter_value(gc_status,2), set_counter(gc_status,1), !.
gc_intp_infeasible_decision(_):-
    error_message("something went wrong while deciding to compute GC intp\n",[]).

is_loop_transition(Id):-
	trans(FName, Id,
		PP, _,  _,  _,  _,  _,  _,  _,  _,
		_, _, _, _, _, _, _, _, _,
		_, _, _, _), !,
    is_ancestor_pp(FName,PP).

fail_if_in_gc_mode:- in_gc_mode, !, set_counter(gc_status,0), fail.
fail_if_in_gc_mode.

gc_is_unfold_ok:- not in_gc_mode, !.
gc_is_unfold_ok:- counter_value(gc_status,1).

% GC Flags
in_gc_mode:- gc_root_depth(_).
in_gc_mode_ctr(0):- not in_gc_mode.
in_gc_mode_ctr(1):- in_gc_mode.

#endif  /*GC_INTP_INFEASIBLE*/

%----------------------------------------------------------------------------------%
% Try to avoid adding new predicates to the interpolant if the cause
% of infeasibility is "somehow unrelated" to the safety property.
%----------------------------------------------------------------------------------%
% In "diamond" programs like:
% <1>p=1;
% <2>if(*) <3> a=1; else <5> a=0;
% <6>if(a) <7> x++; else <9>x--;
% <10>if(!p) error
%
% The path <1>,<2>,<5>,<6>,<7> is infeasible. At that point we could
% return the interpolant (a=0). However, note that the interpolant so
% far at <7> is just (p). We could return directly (p) if we just
% ignore the constraints a=0 and a>0 (<5> and <6>). This would avoid
% adding a new predicate (a=0) to the interpolant.
%----------------------------------------------------------------------------------%
optimized_create_infeasible_interpolant(Depth, FName, _PP, PostPP, NodeId,
					_GlobalArr , _GlobalVar , _LocalArr , _LocalVar,       
					SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
					CL, ML, _XCL, CallStack, ArrRef, LoopStack):-	
	current_tracer_flag(reuse_interp_infeasible,y),	
	fcopy_term(t(SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,CL),
		   t(GlobalArr1,GlobalVar1,LocalArr1,LocalVar1,CL1)),
	constraint_symbolic_list(CL1,[],_),
	mm_subsumed(FName, PostPP,
	 	    GlobalArr1, GlobalVar1, LocalArr1, LocalVar1, ArrRef,
		    SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
	 	    CL, ML, TabledInterp,
	 	    CallStack, LoopStack, TabledLoopContext),
	!,
 	mm_create_subsumed_interpolant(FName, NodeId, Depth,
 				       SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
 				       CL, ML, TabledInterp,
				       LoopStack, TabledLoopContext),
	debug_message("OPTIMIZATION: reusing interpolant from %:%\n\n",[FName,PostPP],
		      green),
#ifdef  PROFILE
        add_counter(reuse_interpolant_for_infeasible_path,1),
#endif  /*PROFILE*/
        true.
% Default case: we generate an interpolant for the infeasible path
optimized_create_infeasible_interpolant(Depth, FName, _PP, _PostPP, NodeId, _ , _ , _ , _,       
					SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
					CL, ML, XCL, _, _, LoopStack ):-
        LoopContext=[],
        mm_create_infeasible_interpolant(FName, NodeId, Depth,
					 SGlobalArr, SGlobalVar,
					 SLocalArr,  SLocalVar,		       
					 CL, ML, XCL, LoopStack, LoopContext),
	!.

mm_unfold_inlined_function_return(Depth,Id,FName,PP,
				  GlobalArr, GlobalVar, LocalArr,LocalVar,
				  SGlobalArr, SGlobalVar, SLocalArr,SLocalVar,
				  CL, ML, CallStack, ArrRef, Loops,
				  UnknownVars, AbsPtFlag, TableSpace,
				  LoopStack, PathStack):-
	
       unfold_inlined_function_return_aux(Id, CallerId, FName, PP, CallerFName, CallerPP1,
					  callee(GlobalArr, GlobalVar, LocalArr, LocalVar,
						 SGlobalArr, SGlobalVar, SLocalArr, SLocalVar),
					  caller(PostGlobalArr  , PostGlobalVar ,
						 PostLocalArr   , PostLocalVar  ,
						 PostSGlobalArr , PostSGlobalVar,
						 PostSLocalArr  , PostSLocalVar ),
					  CL, ML, XCL, PostCL, PostML,
					  CallStack, PostStack, ArrRef,
					  Loops,UnknownVars,
					  _CallerUnknownVars, AbsPtFlag, TableSpace),
       
       pathstack$push(r(FName,
		        SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
		        CallerFName, 
		        PostSGlobalArr,PostSGlobalVar,PostSLocalArr,PostSLocalVar,		      
		        XCL, CallerPP1), PathStack, NewPathStack),
       
#ifdef  TESTING_CREST
       get_unique_context_num(PathStack,NodeId),
#else
       NodeId=_, % to avoid warnings
#endif  /*TESTING_CREST*/
       unfold_enabled_unfold_backtrack(NodeId, Depth, CallerId, CallerFName,
				       %---------------------------------------
				       % Current state (callee)
                                       %---------------------------------------
				       PP,
				       SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
				       CL, ML, XCL,
                                       %---------------------------------------
 	                               % Next state    (caller)
	                               %---------------------------------------
				       CallerPP1,
				       PostGlobalArr, PostGlobalVar, PostLocalArr,  PostLocalVar,
				       ArrRef,
				       PostSGlobalArr, PostSGlobalVar, PostSLocalArr,  PostSLocalVar,
				       PostCL, PostML, LoopStack, NewPathStack,
 	                               %---------------------------------------
	                               % Other information
	                               %---------------------------------------
				       PostStack, Loops, TableSpace, _Call, _BranchMode, AbsPtFlag) .

%------------------------------------------------------------------------------
% propagate_backward
% ------------------------------------------------------------------------------
% Propagate backwards the interpolants from a child to a parent. This
% is a core operation!
%------------------------------------------------------------------------------
#ifdef  TESTING_CREST
propagate_backward(_NodeId, _Id, _Statement, _Depth, _FName,
		   _CallStack,
		   _SGlobalArr,_SGlobalVar,_SLocalArr,_SLocalVar,		   
	           _PP, _CL, _ML, _XCL, _LoopStack,
		   _PostSGlobalArr, _PostSGlobalVar,_PostSLocalArr, _PostSLocalVar,		   		   
		   _PostPP, _PostCL, _PostML,
		   _PostLoopStack, _PathStack) :-
	combine_operations_disabled,
	!.
#endif /*TESTING_CREST*/
#ifdef  GC_INTP_INFEASIBLE
propagate_backward(_, _, _, _, _,
		   _,
		   _,_,_,_,		   
	           _, _, _, _, _,
		   _, _,_, _,		   		   
		   _, _, _,
		   _, _) :-
	in_gc_mode, counter_value(gc_status,0),
	!.
#endif /*GC_INTP_INFEASIBLE*/
propagate_backward(NodeId, Id, Statement, Depth, FName,
		   CallStack,
	           %-----------------------------------------------------------
	           % Current state
	           %-----------------------------------------------------------
		   SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,		   
	           PP, CL, ML, XCL, LoopStack,
	           %-----------------------------------------------------------
		   % Post-state
	           %-----------------------------------------------------------
		   PostSGlobalArr, PostSGlobalVar,PostSLocalArr, PostSLocalVar,		   		   
		   PostPP, PostCL, PostML,
		   PostLoopStack, PathStack) :-
	%----------------------------------------------------------------------
	% We should only memo when there is no conflict detected
	%----------------------------------------------------------------------
	no_conflict2(Depth),	
#ifdef  PROFILE
        ctime(Time0),
#endif  /*PROFILE*/
#ifdef  PROFILE
        % Important sanity check!
	sanityCheckOpSucceed(open,pre_op_checkpoint),
#endif  /*PROFILE*/
	%----------------------------------------------------------------------
	% We propagate answer backwards
	%----------------------------------------------------------------------
#ifdef  TESTING_CREST
	retract_safety_answer_with_check(NodeId, Depth+1, FName, PostCL, PostML1,
			      PostLoopStackML1, PostIntp, PostLoopContext),
#else
	retract_safety_answer(_, Depth+1, FName, PostCL, PostML1,
			      PostLoopStackML1, PostIntp, PostLoopContext),
#endif  /*TESTING_CREST*/

        debug_begin_pre_operator(FName,Id,Depth,PostPP),
	adjust_marklists(FName, PostPP,
	                 PostML1, PostLoopStackML1, PostML /*PostML2*/, PostLoopStackML2),
	%PostML = PostML2,
	remove_constraints_from_loopstack(PostLoopStack, PostLoopStackML2),
	%----------------------------------------------------------------------
	% Compute Pre-Loopcontext
	%----------------------------------------------------------------------
	pre_loopcontext(Depth, FName, PP,
	                PostCL, PostLoopContext,
			CL, XCL, LoopContext),
        %----------------------------------------------------------------------
        % Pre-image of other interpolants (e.g., wp). Bind the
        % variables of Intp1 to next state variables, and Intp to
        % previous state variables
        %----------------------------------------------------------------------
        functionOfChildAndParent(Id,FName,PostPP,CallStack,FNameOfChild,FNameOfParent),
#ifdef  GROUND_EXPLANATION
    check_mark_triple(FNameOfChild, FNameOfParent, Statement, CL, LoopContext,
            PostCL, PostLoopContext),
#endif  /*GROUND_EXPLANATION*/

#ifdef  PROFILE
        ctime(Time1),	
#endif	/*PROFILE*/		
	% These two calls must be executed toghether!
        mm_flatten_path(FName, Depth,
			SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			CL, ML, LoopStack, FlattenedCL, FlattenedML),

#ifdef  PROFILE
        ctime(Time2),
	add_counter(time_flatten_path_for_pre_op,Time2-Time1),
#endif	/*PROFILE*/		

	%print_message("LoopStack:\n\t",[]),
	%pretty_printer_minmax_path(LoopStack,FNameOfParent),
	%print_message("CL:\t \n",[]),	
	%pretty_printer_marked_constraints(FNameOfParent,
	%				  CL, ML,
	%				  SGlobalArr, SGlobalVar, SLocalArr, SLocalVar),
	%print_message("FlattenedCL:\n\t",[]),	
	%pretty_printer_marked_constraints(FNameOfParent,
	%				  FlattenedCL, FlattenedML,
	%				  SGlobalArr, SGlobalVar, SLocalArr, SLocalVar),
	
	interp_pre_operator(PostIntp,PostML1,
			    Id,
			    FNameOfChild,
			    PostSGlobalArr,PostSGlobalVar,PostSLocalArr,PostSLocalVar, 
			    XCL, Statement, FlattenedCL, FlattenedML,
			    FNameOfParent,
			    SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
			    PreIntp),
#ifdef  PROFILE
        ctime(Time3),
	add_counter(time_interp_pre_operator,Time3-Time1),
#endif	/*PROFILE*/		
#ifdef  DEBUG_USE
        print_op_debugging(pre,
			   FName,_, Depth,
			   CL,ML, PreIntp,
			   SGlobalArr, SGlobalVar, SLocalArr, SLocalVar),
#endif  /*DEBUG_USE*/
	store_answer(NodeId, Depth, FName, CL, ML, PreIntp, LoopStack, LoopContext),
#ifdef  PROFILE
        ctime(Time4),
	add_counter(pre_safety,Time4-Time0),
	sanityCheckOpSucceed(close,pre_op_checkpoint),	
#endif	/*PROFILE*/	
	!,
#ifdef  PROFILE
        sanityCheckOpSucceed(open,combine_op_checkpoint),	
	ctime(Time5),
#endif	/*PROFILE*/	
	%----------------------------------------------------------------------
	% We immmediately collate answers from enabled transitions
	% The collation here is such that we have a unified view on the 
	% min information to be propagated to sibling transitions
	%----------------------------------------------------------------------
	mm_collate_safety_answers(NodeId, Depth, FNameOfParent, PP,
				  SGlobalArr,SGlobalVar,SLocalArr,SLocalVar),
#ifdef  PROFILE
        ctime(Time6),
	add_counter(combine_timing,Time6-Time5),
        sanityCheckOpSucceed(close,combine_op_checkpoint),
#endif  /*PROFILE*/	
#ifdef  GRAPHVIZ_USE
        pop_context_stack,
#endif  /*(defined(GRAPHVIZ_USE))*/
#ifdef  TESTING_CREST
        PathStack=[_|PathStack1],
        mark_child_as_visited(FNameOfParent,PP,PathStack1),
#else
        PathStack=_, % to avoid warnings
#endif  /*TESTING_CREST*/
        debug_end_pre_operator.

%------------------------------------------------------------------------------
% apply_sibling_answers(+,+,+,+,+,+,+,+,+,+,+,+,+,+,-,-,-,-,-)
%------------------------------------------------------------------------------
% Get a new state after sibling's min answer has been applied. That
% is, a sibling may record some constraints as non-invariant
% anymore. Thus, the current path should not consider those
% constraints anymore.
%------------------------------------------------------------------------------
apply_sibling_answers(NodeId, Depth, 
	              %--------------------------------------------------------
	              % Current state
	              %--------------------------------------------------------
		      GlobalArr, GlobalVar, LocalArr, LocalVar,	ArrRef,	      
	              SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		      CL, ML, LoopStack,
	              %--------------------------------------------------------
		      % Output new state
	              %--------------------------------------------------------
		      GlobalArr1, GlobalVar1, LocalArr1, LocalVar1, ArrRef1) :-
	%----------------------------------------------------------------------
	% We should only unfold when there is no conflict detected
	%----------------------------------------------------------------------
	no_conflict2(Depth),
#ifdef  PROFILE
        ctime(T0),
#endif  /*PROFILE*/
	%----------------------------------------------------------------------
        % Peek siblings' (collated) answers. We assume that the
        % answers are already collated. Fails if no answers found
        %======================================================================
        % FIXME: this call to apply_sibling_to_loopstack may conflict
        % with pop_cs_mark/0 used when PIPEDUMP_ANSWERS_REUSE_CS is
        % on. After some changes in CLP(R) it seems solved the problem.
        %======================================================================
	apply_sibling_to_loopstack(NodeId, Depth, LoopStack),
	!,
	push_minmax_segment_path(SGlobalArr, SGlobalVar, SLocalArr, SLocalVar, CL, ML,
				 LoopStack,Path),
	find_next_min(Path, NextLoopInfo, CL, ML, _),
	loopinfo$state(NextLoopInfo, _, _, _, _, MinCL, MinML),
	%----------------------------------------------------------------------
	% We abstract the evaluated constraint using the min abstraction
	%----------------------------------------------------------------------
	evaluate_abstraction(GlobalArr , GlobalVar , LocalArr , LocalVar, ArrRef,
			     SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			     CL,
			     MinCL, MinML,
			     GlobalArr1, GlobalVar1, LocalArr1, LocalVar1,ArrRef1),
#ifdef  PROFILE
        ctime(T1),
	add_counter(apply_sibling_answers_timing,T1-T0),
#endif  /*PROFILE*/
        true.	

%------------------------------------------------------------------------------
% apply_sibling_to_loopstack(+,+,?)
%------------------------------------------------------------------------------
% This predicate takes the interpolant computed so far (bitvector ML)
% and store it in the Sibling field of LoopStack. It's expected to be
% called when the symbolic execution backtracks to another sibling.
% It's quite important because the use of Sibling will not allow
% subsumptions in situations where a constraint is detected as
% non-invariant but a sibling needed as part of the interpolant.
%------------------------------------------------------------------------------
apply_sibling_to_loopstack(NodeId, Depth, LoopStack) :-
	get_safety_answer(NodeId, Depth, _, _, _ML, LoopStackML, _Intp, _LoopContext),	
	!,
	apply_sibling_to_loopstack_aux(LoopStackML, LoopStack).

apply_sibling_to_loopstack_aux([], []).
apply_sibling_to_loopstack_aux([r(ML)|R],
			       [r(_SGlobalArr, _SGlobalVar,_SLocalArr,  _SLocalVar,
				  _CL, ML)|S]) :-
	apply_sibling_to_loopstack_aux(R, S).
apply_sibling_to_loopstack_aux([p(ML1)|R], [LoopInfo|S]) :-
	loopinfo$state(LoopInfo, _, _, _, _, _, ML2),
	copy_must_delete_markings(ML1, ML2),
	loopinfo$siblingmax(LoopInfo, SiblingMax),
	copy_must_keep_markings(ML1, SiblingMax),
	apply_sibling_to_loopstack_aux(R, S).

%------------------------------------------------------------------------------
% We copy must delete ('x') markings only
%------------------------------------------------------------------------------
copy_must_delete_markings([], []).
copy_must_delete_markings([X|R], [X|S]) :-
	X==x, !,
	copy_must_delete_markings(R, S).
copy_must_delete_markings([_|R], [_|S]) :-
	copy_must_delete_markings(R, S).

%------------------------------------------------------------------------------
% We copy must keep ('o') markings only
%------------------------------------------------------------------------------
copy_must_keep_markings([], []).
copy_must_keep_markings([X|R], [X|S]) :-
	X==o, !,
	copy_must_keep_markings(R, S).
copy_must_keep_markings([_|R], [_|S]) :-
	copy_must_keep_markings(R, S).

%------------------------------------------------------------------------------
% evaluate_abstraction
%------------------------------------------------------------------------------
evaluate_abstraction(/* current state */
 		     GlobalArr, GlobalVar , LocalArr, LocalVar, ArrRef,
	             _SGlobalArr, _SGlobalVar, _SLocalArr, _SLocalVar, _CL,		     
		     /* min abstraction*/
		     [], _MinML,
		     /* output state*/
		     GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef) :-
% Shortcut added by Jorge (12/14/2010)
%   If no abstraction (MinCL=[]) then output state is current state
%--------------------------------------------------------------------------%
%             | 
%             | CL'
%             | <------- MinCL (projection of CL')
%            / \
%           /   \ CL
%     min's/     \
%---------------------------------------------------------------------------%	
% This solved a problem we observed: if no abstraction we were losing
% the array updates since MinCL=[] and from CL we cannot pass the
% updates to the evaluated variables that represent the output
% state. To test, check test-alias-1.c
%===========================================================================%	
% Note: this can be solve now by calling
% extract_aa_and_convert_to_eq/2 which replaces array assignments to
% array references.
%===========================================================================%
	!.
evaluate_abstraction(/* current state */
 		     _GlobalArr, _GlobalVar , _LocalArr, _LocalVar, _ArrRef,
	             SGlobalArr, SGlobalVar, SLocalArr, SLocalVar, CL,
		     /* min abstraction*/
		     MinCL, MinML,
		     /* output state*/
		     GlobalArr1, GlobalVar1, LocalArr1, LocalVar1, ArrRef1) :-

	fcopy_term(t(SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		     CL, MinCL),
		   t(GlobalArr1, GlobalVar1, LocalArr1, LocalVar1,
		     CL1, MinCL1)),
	
	select_non_deleted_constraints(MinCL1, MinML, AbstractMinCL1, _, _),
 	constraint_symbolic(AbstractMinCL1, [], ArrRef0),

	% FIXME: check this ...
	constraint_symbolic_with_array_update_subst(CL1,ArrRef0, ArrRef1),
	
% 	% Note that substitute_arrays/2 replaces 'arrassign'
% 	% constraints with 'tt'.  Thus, we must first extract
% 	% arrassign constraints and convert them into array
% 	% references.	
% 	extract_aa_and_convert_to_eq(CL1, AAEQCL1),
% 	append(ArrRef0,AAEQCL1,ArrRef2),	
% 	% We must to call substitute_arrays/2 before calling
% 	% constraint_symbolic/3	
% 	substitute_arrays(CL1, CL2),
%  	constraint_symbolic(CL2, ArrRef2 /*ArrRef0*/, ArrRef1),
	!.

%------------------------------------------------------------------------------
% adjust_marklists
% If post-state is looping point, get the context.
%------------------------------------------------------------------------------
adjust_marklists(FName,PP,[],[p(_), r(PostML)|LoopStackML],PostML,LoopStackML) :-
	is_ancestor_pp(FName,PP),
	!.	
adjust_marklists(_FName, _PP, PostML, LoopStackML, PostML, LoopStackML):-
	!.
adjust_marklists(FName, PP, _PostML1,_LoopStackML1,_PostML2,_LoopStackML2):-
	error_message("adjust_marklists/6 failed for %:% \n",[FName,PP]).

%------------------------------------------------------------------------------
% pre_loopcontext
% Compute pre-loopcontext from post-loopcontext
%------------------------------------------------------------------------------
pre_loopcontext(Depth, FName, PP,
		PostCL,  PostLoopContext,
		CL, XCL, LoopContext):-
%	current_tracer_flag(path_datastructure,naive),!,
	remove_loop_context(PostLoopContext, Depth, PostLoopContext1),
	pre_loopcontext_aux(FName, PP,
	                    PostCL,  PostLoopContext1,
                            CL, XCL, LoopContext).
pre_loopcontext_aux(FName, PP, _PostCL, PostLoopContext, [], _XCL, LoopContext) :-
	%----------------------------------------------------------------------
	% This is a loop
	%----------------------------------------------------------------------
	is_ancestor_pp(FName,PP),
	!,
	delete_relation_info(PostLoopContext, LoopContext).
pre_loopcontext_aux(_FName, _PP, _PostCL, PostLoopContext, _CL, XCL, LoopContext) :-
	%----------------------------------------------------------------------
	% Calculate length difference of lists of symbolic constraints
	%----------------------------------------------------------------------	
/*

  IMPORTANT NOTE: if length_difference/3 is used then we get an error
  for SAFETY/MACRO/ntdrivers/serial/serial-TRACER.c. It's safer and
  even faster to get the length difference from XCL.
  
	length_difference(CL, PostCL, Length),
*/
	length(XCL,Length), 
	shorten_loopcontext(Length, PostLoopContext, LoopContext).

%------------------------------------------------------------------------------
% If the current point is the loop point in loop context, remove it.
%------------------------------------------------------------------------------
remove_loop_context([lc(_, Depth, _)|R], Depth,  R) :- !.
remove_loop_context( R, _Depth, R).

%------------------------------------------------------------------------------
% Remove relation from loopcontext
%------------------------------------------------------------------------------
delete_relation_info([], []).
delete_relation_info([lc(ANodeId, ADepth, AMTList)|R],
	             [lc(ANodeId, ADepth, AMTList1)|S]) :-
	delete_relation_info_aux(AMTList, AMTList1),
	delete_relation_info(R, S).

delete_relation_info_aux([], []).
delete_relation_info_aux([mt(N, [r(_), p(_)|R])|S], [mt(N, R)|T]) :-
	!,
	%----------------------------------------------------------------------
	% Recall that delete_relation_info is called when we're at a looping
	% point and CL is (supposedly) [] (empty). Here we can delete both
	% r() and p() atoms, since we're at looping point.
	%----------------------------------------------------------------------
	delete_relation_info_aux(S, T).

%------------------------------------------------------------------------------
% Calculate length difference of lists of symbolic constraints
% Returns 0 if the second list is shorter than the first
%------------------------------------------------------------------------------
% length_difference(_, [], 0) :- !.
% length_difference([C1|_], [C2|_], 0) :- C1==C2, !.
% length_difference(R, [_|S], N+1) :- length_difference(R, S, N).

shorten_loopcontext(_Length, [], []).
shorten_loopcontext(Length, [lc(NodeId, Depth, PostMTList)|R],
		            [lc(NodeId, Depth, MTList)|S]) :-
	shorten_mtlist(Length, PostMTList, MTList),
	shorten_loopcontext(Length, R, S).

shorten_mtlist(_Length, [], []).
shorten_mtlist(Length, [mt(N, PostML)|R], [mt(N, ML)|S]) :-
	shorten_mtlist_aux(Length, PostML, ML),
	shorten_mtlist(Length, R, S).

shorten_mtlist_aux(Length, [r(PostML)|R], [r(ML)|R]) :-
	shorten_list(Length, PostML, ML), !.
shorten_mtlist_aux(_Length, PostMTList, PostMTList).	

shorten_list(0, PostML, PostML) :- !.
shorten_list(N+1, [_|R], S) :- shorten_list(N, R, S).

%------------------------------------------------------------------------------
% mm_collate_safety_answers(+,+,+,+,+,+,+,+)
%------------------------------------------------------------------------------
% Here we combine the interpolants and the loop contexts that are
% stored as safety_answer facts.
% The result is also asserted as a safety_answer fact.
%------------------------------------------------------------------------------
mm_collate_safety_answers(NodeId, Depth,
			  FName, PP,
			  SGlobalArr,SGlobalVar,SLocalArr,SLocalVar) :-
	retract_safety_answer___(NodeId, Depth, ML, LoopStackML, Intp, LoopContext),
	!,
	mm_collate_safety_answers_aux(NodeId, Depth,
				      FName, PP,
				      SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
				      ML, LoopStackML, Intp, LoopContext).	
mm_collate_safety_answers(_,_,_,_,_,_,_,_).

mm_collate_safety_answers_aux(NodeId, Depth,
			      FName, PP,
			      SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
			      ML, LoopStackML, Intp1, LoopContext1) :-
	retract_safety_answer___(NodeId, Depth, ML, LoopStackML, Intp2, LoopContext2),
	!,
#ifdef  PROFILE	
	ctime(Time0),
#endif  /*PROFILE*/	
	interp_combine(Intp1,Intp2,
		       Depth,FName,PP,
		       SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
		       Intp),
#ifdef  PROFILE	
	ctime(Time1),
	add_counter(time_interp_combine_operator,Time1-Time0),
#endif  /*PROFILE*/		
	combine_loop_contexts_catch_error(LoopContext1, LoopContext2, LoopContext),
	mm_collate_safety_answers_aux(NodeId, Depth,
				      FName, PP,
				      SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
				      ML, LoopStackML, Intp, LoopContext).
mm_collate_safety_answers_aux(NodeId, Depth,
			      FName, PP,
			      SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			      ML, LoopStackML, CombIntp, LoopContext) :-
	% Special step for function calls
	merge_caller_interp(FName,PP,Depth,
			    CombIntp,
			    SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
			    CombIntp1),
#ifdef  PROFILE	
	ctime(Time0),
#endif  /*PROFILE*/	
	interp_simplify_after_combined(FName,CombIntp1,CombIntp2),
#ifdef  PROFILE	
	ctime(Time1),
	add_counter(time_interp_combine_operator,Time1-Time0),
	add_counter(combine_timing,Time1-Time0),
#endif  /*PROFILE*/			
	assert_safety_answer___(NodeId, Depth,
				ML, LoopStackML, CombIntp2, LoopContext).
	
%------------------------------------------------------------------------------
% combine_loop_contexts:
% Iterate over loop contexts in loop context stacks to combine them
%------------------------------------------------------------------------------
combine_loop_contexts_catch_error(LoopContext1,LoopContext2,LoopContext):-
        combine_loop_contexts(LoopContext1,LoopContext2,LoopContext),!.
combine_loop_contexts_catch_error(LoopContext1,LoopContext2,LoopContext):-
        print_message("% \n % \n % \n",[LoopContext1,LoopContext2,LoopContext],red),
        error_message("Unexpected problem in combine_loop_contexts/3. \n",[]).

combine_loop_contexts([], L, L) :- !.
combine_loop_contexts(L, [], L) :- !.
combine_loop_contexts([lc(NodeId1, Depth1, MTList1)|R],
		      [lc(NodeId2, Depth2, MTList2)|S],
		      [lc(NodeId1, Depth1, MTList1)|T]) :-
	Depth1 > Depth2, !,
	combine_loop_contexts(R, [lc(NodeId2, Depth2, MTList2)|S], T).
combine_loop_contexts([lc(NodeId1, Depth1, MTList1)|R],
		      [lc(NodeId2, Depth2, MTList2)|S],
		      [lc(NodeId2, Depth2, MTList2)|T]) :-
	Depth1 < Depth2, !,
	combine_loop_contexts([lc(NodeId1, Depth1, MTList1)|R], S, T).
combine_loop_contexts([lc(NodeId, Depth, MTList1)|R],
		      [lc(NodeId, Depth, MTList2)|S],
		      [lc(NodeId, Depth, MTList)|T]) :-
	combine_mintestlist(MTList1, MTList2, MTList),
	combine_loop_contexts(R, S, T).

%------------------------------------------------------------------------------
% combine_mintestlist: We collect only common min constraint markings
% Uncommon markings belong to must-delete constraints
%------------------------------------------------------------------------------
combine_mintestlist([], _, []) :- !.
combine_mintestlist(_, [], []) :- !.
combine_mintestlist([mt(N, LoopStackML)|R], [mt(N, LoopStackML)|S],
		    [mt(N, LoopStackML)|T]) :-
	combine_mintestlist(R, S, T).
combine_mintestlist([mt(N1, _)|R], [mt(N2, LoopStackML2)|S], T) :-
	N1 < N2, !,
	combine_mintestlist(R, [mt(N2, LoopStackML2)|S], T).
combine_mintestlist([mt(N1, LoopStackML1)|R], [mt(N2, _)|S], T) :-
	N1 > N2, !,
	combine_mintestlist([mt(N1, LoopStackML1)|R], S, T).

%==============================================================================
% is_conflict: Succeed when there is a conflict at an ancestor
%==============================================================================
is_conflict(Depth) :-
	%----------------------------------------------------------------------
	% There's a conflict up in the tree, immediately backtrack
	%----------------------------------------------------------------------
	conflict(Depth1, _), Depth1 < Depth, !.
	%debug_message("CONFLICT: backtracking to conflict point ...: %\n", [Depth1]), !.

%==============================================================================
% no_conflict: Succeed when there is no conflict at an ancestor
%==============================================================================
no_conflict(Depth) :-
	is_conflict(Depth), !, fail.
no_conflict(_Depth).

%==============================================================================
% no_conflict2: Succeed when there is no conflict either here or at an ancestor
%==============================================================================
no_conflict2(Depth) :-
	conflict(Depth, _), !, fail.
no_conflict2(Depth) :-
	no_conflict(Depth), !.

%==============================================================================
% is_ancestor_pp: Succeed when the program point is an ancestor point,
% i.e., there is a back edge that points to it.
%==============================================================================
#ifdef  TESTING_CREST
% This predicate is called to check if a PP is loop header. Since we don't do
% anything for loops (i.e, just treat them as normal paths), we always fail.
is_ancestor_pp(_,_):- !, fail.
#endif  /*TESTING_CREST*/
is_ancestor_pp(FName,PP):-
	is_ancestor_loop_pp(FName,PP).
is_ancestor_pp(FName,PP):-
	% Special case: user abstraction point istreated like a loop
	% point
	is_user_abstraction_pp(FName,PP), !.

is_ancestor_loop_pp(FName,PP):-
	% This clause is for structured loops (while's, for's, etc)
        block(_, FName, PP,  _ExitPP, _, l, _,
              _UpdGlobalArr, _UpdGlobalVar,
	      _UpdLocalArr,  _UpdLocalVar), !.
is_ancestor_loop_pp(FName,PP):-
	% This clause is for goto's.
	warning(warning_off),	
	ancestor_pp(FName,PP),!,
        warning(warning_on).
		
%------------------------------------------------------------------------------
% mm_unfold_abstract
%------------------------------------------------------------------------------
% Execute symbolically an abstraction provided by the user or by an
% invariant generator. We treat both cases the same.
%------------------------------------------------------------------------------
mm_unfold_abstract(_AbsProvider,
		   NodeId, Depth, Id, FName, PP, 
		   _GlobalArr , _GlobalVar , _LocalArr , _LocalVar,
		   SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		   CL, ML,  _CallStack, _ArrRef,
		   Loops, _TableSpace, LoopStack, _PathStack, _AbsPtFlag,
		   _MarkGlobalArr,_MarkGlobalVar,_MarkLocalArr,_MarkLocalVar,
		   _NewCL):-
	is_ancestor_loop_pp(FName,PP),
	debug_message("LOOP HEADER FOUND at %@% \n",[FName,PP],magenta),
	%----------------------------------------------------------------------
	% The first time the loop header is visited this call to
	% unfold_loop_ii/11 will fail. Later, after few loop unrolls
	% it may succeed.
	%----------------------------------------------------------------------	
	unfold_loop_ii(NodeId, Depth, FName, PP, 
	               SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		       CL, ML, LoopStack),
#ifdef  GRAPHVIZ_USE
        get_ancestor_pp_context(FName,PP,Loops,PostPPContext),
        push_context_stack(FName,PostPPContext),
        record_sym_graph_edge(feasible,
 			      src(FName ,PP,
 				  SGlobalArr,SGlobalVar,SLocalArr,SLocalVar),
 			      dest(FName,PP,
 				   SGlobalArr,SGlobalVar,SLocalArr,SLocalVar),
 			      Id,[],not_branch,Loops),
	pop_context_stack,
#else
        % To avoid warnings
        Id=_,Loops=_,
#endif  /*(defined(GRAPHVIZ_USE))*/	
	!,
	fail.
mm_unfold_abstract(Flag,
		   NodeId, Depth, _Id, FName, PP,
		   GlobalArr , GlobalVar , LocalArr , LocalVar,
		   SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
		   CL, ML,  CallStack, ArrRef,
		   Loops, TableSpace, LoopStack, PathStack, _AbsPtFlag,
		   MarkGlobalArr,MarkGlobalVar,MarkLocalArr,MarkLocalVar,
		   NewCL):-
#ifdef  PROFILE
        ctime(T0),
#endif  /*PROFILE*/	
	mm_unfold_abstract_aux(Flag,
			       FName, PP, Depth,
			       % Current Context
			       SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
			       CL, ML, 
			       GlobalArr ,GlobalVar ,LocalArr ,LocalVar,ArrRef,
			       % Abstracted variables 
			       MarkGlobalArr,MarkGlobalVar,
			       MarkLocalArr ,MarkLocalVar,
			       % New constraints to be added 
			       NewCL,
			       % New abstracted context
			       AbsSGlobalArr,AbsSGlobalVar,
			       AbsSLocalArr ,AbsSLocalVar, 
			       AbsCL, AbsArrRef),
	!,
	% AbsCL is the state after deleting any constraint that
	% implies NewCL.  The final state must be the conjunction of
	% AbsCL and NewCL.
	push_minmax_segment_path(NodeId, Depth, FName, PP,
				 GlobalArr ,GlobalVar ,LocalArr ,LocalVar ,ArrRef,
				 SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
				 CL, ML, LoopStack,
				 _OGlobalArr,_OGlobalVar,_OLocalArr,_OLocalVar,_OArrRef,
				 OLoopStack),
        OLoopStack = [LoopInfo|RestOLoopStack],
	loopinfo$state(LoopInfo,
		       SGlobalArr, SGlobalVar, 
	               SLocalArr , SLocalVar,
		       CL1, _ML1),
	
	%--------------------------------------------------------------------------%
	% 1st additional step: we keep track of inductive invariant
	% constraints that we know due to external means. Here, we
	% know that NewCL is if Flag=invgen Note 08/01/12: this
	% information is not currently used.
	%--------------------------------------------------------------------------%	
	loopinfo$update_known_inductive_invariants(Flag, LoopInfo,  NewCL,  LoopInfo1),
	% print_message("Inductive invariants: \n",[]),
	% pretty_printer_constraints_list(FName,					
	% 				SGlobalArr, SGlobalVar, 
	% 				SLocalArr , SLocalVar , NewCL),
	
	AbsSGlobalArr=SGlobalArr,AbsSGlobalVar=SGlobalVar,
	AbsSLocalArr =SLocalArr ,AbsSLocalVar =SLocalVar,

	%--------------------------------------------------------------
	% Record which constraints were abstracted by
	% mm_unfold_abstract_aux
	%--------------------------------------------------------------	
	record_abstracted_constraints(CL1, ML1, AbsCL),	
	append_symbolic_list(NewCL, CL1, ML1, AbsCLX, AbsMLX),	
	% print_message("Symbolic state after deleting constraints: \n",[]),
	% pretty_printer_constraints_list(FName,					
	% 				SGlobalArr, SGlobalVar, 
	% 				SLocalArr , SLocalVar , AbsCL),

	%-------------------------------------------------------------------------%
	% 2nd additional step to record those constraints that we know
	% for sure they are invariant. E.g., if a variable is not
	% modified within the loop then its projection must be
	% invariant.
	%-------------------------------------------------------------------------%
	get_must_invariants(FName, PP, Depth,
			    GlobalArr , GlobalVar , LocalArr , LocalVar, ArrRef,
			    SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
			    MustInvariantsCL),
	loopinfo$set_must_invariants(LoopInfo1,
				     SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
				     MustInvariantsCL, LoopInfo2),
	
	loopinfo$replace_state(LoopInfo2, 
			       SGlobalArr, SGlobalVar, 
			       SLocalArr , SLocalVar ,
			       AbsCLX, AbsMLX,
			       AbstractedLoopInfo),	
        OOLoopStack = [AbstractedLoopInfo|RestOLoopStack],
	%----------------------------------------------------------------------
	% Produce new set of evaluated constraints
	%----------------------------------------------------------------------	
	append(AbsCL, NewCL ,AbsCL0),
	
	fcopy_term(t(AbsSGlobalArr,AbsSGlobalVar,AbsSLocalArr,AbsSLocalVar,
		     AbsCL0),
		   t(OGlobalArr,OGlobalVar,OLocalArr,OLocalVar,
		     OCL1)),
	
	constraint_symbolic(OCL1, AbsArrRef, OArrRef),
	%----------------------------------------------------------------------
	% We mark abstraction as already been done.
	%----------------------------------------------------------------------
	AbsPtFlag1 = 1,
#ifdef  GRAPHVIZ_USE
        %-------------------------------------------------------------------
        % We get the current context value for storing it in the loop stack
        %-------------------------------------------------------------------
        context_value(FName,PP,PPContext),
        loopstack$point_with_context(NewLoop,FName,PP,PPContext),	
   	NewLoops = [NewLoop|Loops],
#else
        NewLoops = Loops, 
#endif  /*GRAPHVIZ_USE*/
        mm_restart_set_mark,	
% #ifdef  MINMAX_CS_REUSE
% 	set_cs_mark,
% 	debug_message("set_cs_mark1 NodeId=% Depth=%\n", [NodeId, Depth]),
% #endif	
        !,
#ifdef  DEBUG_USE
        print_message("CLP(R) context solver:\n",[]),
 	pretty_printer_solver_state(FName,
 				    OGlobalArr,OGlobalVar,
 				    OLocalArr ,OLocalVar ,OArrRef),
	print_message("Minmax symbolic path:\n",[]),	
	pretty_printer_minmax_path(OOLoopStack,FName),
	print_message("\n",[]),
#endif  /*DEBUG_USE*/
#ifdef  PROFILE
        ctime(T1),
	add_counter(enumerate_candidate_invariants_timing,T1-T0),
#endif  /*PROFILE*/
%       pathstack$push(t(FName,PP,Id),PathStack,NewPathStack),
	unfold_loop_redo_on_conflict_aux(NodeId, Depth, FName, PP, 
					 OGlobalArr, OGlobalVar, OLocalArr, OLocalVar,
					 SGlobalArr, SGlobalVar, SLocalArr, SLocalVar,
					 [], [], CallStack, OArrRef, NewLoops,
					 TableSpace, OOLoopStack, PathStack, AbsPtFlag1).

%----------------------------------------------------------------------------
% record_abstracted_constraints(+CL,-ML,+AbsCL)
%----------------------------------------------------------------------------
% Identify which constraints from CL are needed to imply AbsCL. The
% complement is marked as min. In other words, mark as "min" all the
% constraints which were abstracted.
%----------------------------------------------------------------------------
record_abstracted_constraints(CL1,ML1,AbsCL):-
 	negate_numerical_list(AbsCL,NegAbsCL),
 	copy_to_unbound_list(CL1, ML1X),
 	interpolate_constraints_path(NegAbsCL,CL1,ML1X, no_check),
	mark_only_unmarked_as_min(ML1X,ML1).

%----------------------------------------------------------------------------
% mark_only_unmarked_as_min(+ML1,-ML2)
%----------------------------------------------------------------------------
mark_only_unmarked_as_min([],[]):- !.		   
mark_only_unmarked_as_min([X|Xs],[_|Ys]):-
	X==o,!,
	mark_only_unmarked_as_min(Xs,Ys).
mark_only_unmarked_as_min([_|Xs],[x|Ys]):-
	!,
	mark_only_unmarked_as_min(Xs,Ys).


%---------------------------------------------------------------------%
% mm_unfold_abstract_aux(+Flag,...,-NewCL,...,-AbsCL)
% Abstract the current symbolic state
%---------------------------------------------------------------------%
% - If Flag=user then check first if the current state implies the new
% abstracted state NewCL, project onto current variables, and
% existentially quantifier eliminate some variables (user also says
% which ones). The result is AbsCL.
%
% - If Flag=invgen then the current state is also projected (AbsCL)
% onto current variables and NewCL contains the inductive invariants
% provided by external means.
%---------------------------------------------------------------------%
mm_unfold_abstract_aux(user,
		       FName, PP, Depth,
		       % Current Context
		       SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
		       CL, ML, 
		       GlobalArr ,GlobalVar ,LocalArr ,LocalVar,ArrRef,
		       % Abstracted variables 
		       MarkGlobalArr,MarkGlobalVar,
		       MarkLocalArr ,MarkLocalVar,
		       % New constraints to be added 
		       NewCL,
		       % New abstracted context
		       AbsSGlobalArr,AbsSGlobalVar,
		       AbsSLocalArr ,AbsSLocalVar, 
		       AbsCL, AbsArrRef):-
        debug_message("USER ABSTRACTION ...\n",[],magenta),
	check_and_abstract_away_variables(FName, PP, Depth,
					  SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
					  CL, ML, 
					  GlobalArr ,GlobalVar ,LocalArr ,LocalVar,ArrRef,
					  MarkGlobalArr,MarkGlobalVar,
					  MarkLocalArr ,MarkLocalVar,
					  NewCL,
					  AbsSGlobalArr,AbsSGlobalVar,
					  AbsSLocalArr ,AbsSLocalVar, 
					  AbsCL, AbsArrRef).
mm_unfold_abstract_aux(invgen,
		       FName, PP, _Depth,
		       SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
		       _CL, _ML,
		       GlobalArr, GlobalVar, LocalArr, LocalVar, ArrRef,
		       _,_,_,_,
		       NewCL,
		       AbsSGlobalArr,AbsSGlobalVar,
		       AbsSLocalArr ,AbsSLocalVar, 
		       AbsCL, AbsArrRef):-
        debug_message("TAKING INDUCTIVE INVARIANTS FROM ABSTRACT INTERPRETATION...\n",
		      [],magenta),
	
	% Reading loop invariants (symbolic form) from external tools
        read_external_symbolic_invariants(FName, PP,
					  SInvGlobalArr,SInvGlobalVar,
					  SInvLocalArr ,SInvLocalVar , InvCL),

	% Collecting all constraints from the constraint solver in
	% projected form. Note that ProjCL will have, in general, more
	% constraints than CL since CL contains only constraints since
	% the last abstraction point. ProjCL will have also
	% constraints propagated from previous abstraction points.
 	project_solver_context(state(GlobalArr , GlobalVar,
				     LocalArr  , LocalVar , ArrRef),
 			       state(SGlobalArr, SGlobalVar,
				     SLocalArr , SLocalVar,
				     ProjCL)),		
%	fassert(using_inductive_invariants(FName,PP)),
% #ifdef  DEBUG_USE
%       print_message("\tCurrent symbolic state: \n\t",[],blue),
%       pretty_printer_constraints_list(FName,
% 					SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
% 					ProjCL),
% #else
%       % To avoid warnings
%       SGlobalArr=_,SGlobalVar=_,SLocalArr=_,SLocalVar=_,
% #endif  /*DEBUG_USE*/		
        AbsSGlobalArr= SInvGlobalArr , AbsSGlobalVar= SInvGlobalVar,
	AbsSLocalArr = SInvLocalArr  , AbsSLocalVar = SInvLocalVar,
	SGlobalArr   =  AbsSGlobalArr, SGlobalVar   = AbsSGlobalVar,
	SLocalArr    =  AbsSLocalArr , SLocalVar    = AbsSLocalVar,			
	keep_state_unrelated_to_abstraction(ProjCL, InvCL, AbsCL),					    
	NewCL = InvCL,	
	% FIXME: array constraints		
	AbsArrRef=[],	
% #ifdef  DEBUG_USE
%       print_message("\tAbstracted state: \n\t",[],blue),	
%       pretty_printer_constraints_list(FName,
% 					AbsSGlobalArr,AbsSGlobalVar,
% 					AbsSLocalArr ,AbsSLocalVar,
% 					AbsCL),
%       print_message("\tNew inductive invariants: \n\t",[],blue),	
%       pretty_printer_constraints_list(FName,
% 					AbsSGlobalArr,AbsSGlobalVar,
% 					AbsSLocalArr ,AbsSLocalVar,
% 					NewCL),
% #endif  /*DEBUG_USE*/
	!.

%-------------------------------------------------------------------------------%
% keep_state_unrelated_to_abstraction(+,+,-)
%-------------------------------------------------------------------------------%
keep_state_unrelated_to_abstraction(CL, InvCL, CL1):-
	negate_numerical_list(InvCL,NegInvCL),
	make_dnf(NegInvCL,IntpCond),
	copy_to_unbound_list(CL,ML),
	compute_unsat_core(IntpCond,CL,ML,no_check),
 	select_unmark_constraints(CL,ML,[], CL1),
	!.
keep_state_unrelated_to_abstraction(CL, InvCL,_):-
 	error_message("keep_state_unrelated_to_abstraction with % and % \n",
 		      [CL,InvCL]).
	
%-----------------------------------------------------------------------------%
% select_unmark_constraints(+CL,+ML,+AccCL,-OutCL)
%-----------------------------------------------------------------------------%
select_unmark_constraints([], [], OutCL, OutCL).
select_unmark_constraints([X|Xs], [M|Ms], AccCL, OutCL) :-
	myvar(M), !,
	select_unmark_constraints(Xs, Ms, [X|AccCL], OutCL).
select_unmark_constraints([_|Xs], [_|Ms], AccCL, OutCL) :-
	select_unmark_constraints(Xs, Ms, AccCL, OutCL).

%==============================================================================
% clear_table(NodeId): Clear all entries in the memo table with Id > NodeId
%==============================================================================
clear_table(NodeId) :-
	debug_message("CLEARING MEMOED SUBTREE OF NODE ID=% ... ", [NodeId],red),
	NodeId <= X,
	program_point(PP),
	printf_to_atom(PName, "t%", [PP]),
        T =.. [PName, X, _, _, _, _, _, _, _, _, _, _, _, _],
	retract(T),
	fail.
clear_table(_NodeId) :-
	debug_message("OK\n", [],red).

%==============================================================================
% clear_answer(Depth): Clear answers of depth Depth
%==============================================================================
% #ifdef DEBUG_USE
% %------------------------------------------------------------------------------
% % Debugging version of clear_answer
% %------------------------------------------------------------------------------
% clear_answer(NodeId, Depth) :-
% 	% print_message("Before clearing node % depth % :\n", [NodeId,Depth]),
% 	% ls safety_answer,
% 	!,
% 	clear_answer_aux(NodeId, Depth),
% 	!,
% 	clear_answer_end.
% clear_answer(NodeId, Depth) :-
% 	!,
% 	clear_answer_aux(NodeId, Depth),
% 	!,
% 	clear_answer_end.

% clear_answer_end :-
% 	% print_message("After clearing:\n", []),
% 	% ls safety_answer,
% 	!.
% clear_answer_end.
% #else  /*DEBUG_USE*/
%------------------------------------------------------------------------------
% Non-debugging version of clear_answer
%------------------------------------------------------------------------------
clear_answer(NodeId, Depth) :-
	clear_answer_aux(NodeId, Depth).
%#endif /*DEBUG_USE*/


% clear_answer_aux(_NodeId, Depth) :-
% 	debug_message("CLEARING ANSWERS AT DEPTH=% ... ", [Depth],red),
% 	%----------------------------------------------------------------------
% 	% We first clear answers at level X > Depth
% 	%----------------------------------------------------------------------
%       X > Depth,
% 	retract_safety_answer(_, X, _, _, _, _, _, _),
% 	fail.
clear_answer_aux(NodeId, Depth) :-
	debug_message("CLEARING ANSWERS AT DEPTH=% ... ", [Depth],red),		
#ifdef  PIPEDUMP_AND_ANSWERS
	pipe_master_retract_all_safety_answer_below(Depth),
#else	
	retract_all_safety_answers_below(Depth),
#endif  /*PIPEDUMP_AND_ANSWERS*/
	% Clear the answer for current NodeId (if any)
	retract_safety_answer(NodeId, Depth, _, _, _, _, _, _),
	!,
	debug_message("OK\n", [],red).
clear_answer_aux(_,_) :-
	debug_message("OK\n", [],red).

%------------------------------------------------------------------------------
% retract_all_safety_answers_below(+Depth)
%------------------------------------------------------------------------------
% Clear all answers at level X > Depth
%------------------------------------------------------------------------------
retract_all_safety_answers_below(Depth):-	
        X > Depth,
	retract_safety_answer(_,X,_,_,_,_,_,_),
	fail.
retract_all_safety_answers_below(_).

%==============================================================================
% Operations to assert safety_answer facts: facts used to propagate
% information from children to parents in the symbolic tree.
%==============================================================================

%------------------------------------------------------------------------------
% store_answer: Record answer of post-order traversal
%------------------------------------------------------------------------------
store_answer(NodeId, Depth, FName, CL, ML, Intp, LoopStack, LoopContext) :-	
	% remove_constraints_from_loopstack(LoopStack, LoopStackML),
	assert_safety_answer(NodeId, Depth, FName, CL, ML, Intp, LoopStack, LoopContext).

%------------------------------------------------------------------------------
% assert_safety_answer
%------------------------------------------------------------------------------
assert_safety_answer(NodeId, Depth, _FName, _CL, ML, Intp, LoopStack, LoopContext) :-
	current_tracer_flag(path_datastructure,naive),
	remove_constraints_from_loopstack(LoopStack, LoopStackML),
	assert_safety_answer___(NodeId, Depth, ML, LoopStackML, Intp, LoopContext).
assert_safety_answer(NodeId, Depth, _FName, Es, ML, Intp, LoopStack, LoopContext) :-
	current_tracer_flag(path_datastructure,partition),
        %---------------------------------------------------------------------		
	% TODO: adapt this predicate to partition
        %---------------------------------------------------------------------		
	remove_constraints_from_loopstack(LoopStack, LoopStackML),
        %---------------------------------------------------------------------	
	% Transfer marked constraints from Es to ML
#ifndef NEWPARTITION
	convert_partition2naive_ifNotVar(Es,ML),
#else   /*!NEWPARTITION*/
	Es = _,
#endif  /*!NEWPARTITION*/
        %---------------------------------------------------------------------
	assert_safety_answer___(NodeId,Depth,ML,LoopStackML,Intp,LoopContext).

%------------------------------------------------------------------------------
% assert_safety_answer: Low-level assert answer
% FIXME: Intp is an arbitrary formula that represents interpolant
% obtained by e.g., wp. We don't encode Intp for now.
%------------------------------------------------------------------------------
assert_safety_answer___(NodeId, Depth, ML, LoopStackML, Intp, LoopContext) :-	
#ifdef  MINMAX_DEBUG_ASSERT		
	print_message("ASSERTING ANSWER (%, %, %, %, %, %)\n",
		      [NodeId, Depth, ML, LoopStackML, Intp, LoopContext]),
#endif 	/*MINMAX_DEBUG_ASSERT*/
#ifdef  PROFILE
	ctime(Time0),
#endif
#ifdef  ENCODE_CHILD_PARENT
        mm_encode_safety_answer(ML, LoopStackML, LoopContext,
				EncML,EncLoopStackML, EncLoopContext),
#else
#ifdef  PIPEDUMP_AND_ANSWERS
        EncML=ML,EncLoopStackML=LoopStackML,EncLoopContext=LoopContext,
#endif  /*PIPEDUMP_AND_ANSWERS*/
#endif  /*ENCODE_CHILD_PARENT*/		
#ifdef  PIPEDUMP_AND_ANSWERS
        pipe_master_store_safety_answer(NodeId, Depth,
					EncML, EncLoopStackML, Intp, EncLoopContext),
#elif   defined(ENCODE_CHILD_PARENT)
	fassert(safety_answer(NodeId, Depth,
			      EncML, EncLoopStackML, Intp, EncLoopContext)),
#else
#ifdef  GC_INTP_INFEASIBLE
    in_gc_mode_ctr(GC),
	fassert(safety_answer(NodeId, Depth, ML, LoopStackML, Intp, LoopContext, GC)),
    debug_message("storing answer at Depth %\n",[Depth],blue),
#else
	fassert(safety_answer(NodeId, Depth, ML, LoopStackML, Intp, LoopContext)),
#endif  /*GC_INTP_INFEASIBLE*/
#endif	/*PIPEDUMP_AND_ANSWERS*/
#ifdef  PROFILE
	ctime(Time1),
	add_counter(assert_timing,Time1-Time0).
#else
        true.
#endif  /*PROFILE*/

%------------------------------------------------------------------------------
% retract_safety_answer: retract answer
%------------------------------------------------------------------------------
retract_safety_answer(NodeId, Depth,_FName,_CL,ML,LoopStackML,Intp,LoopContext) :-
	current_tracer_flag(path_datastructure,naive),
	retract_safety_answer___(NodeId,Depth,ML,LoopStackML,Intp,LoopContext).
retract_safety_answer(NodeId, Depth,_FName,Es,ML,LoopStackML,Intp,LoopContext) :-
	current_tracer_flag(path_datastructure,partition),
	%---------------------------------------------------------------------
	% Transfer marked constraints from ML to Es
#ifndef NEWPARTITION
	convert_partition2naive(Es,_,ML),
#else   /* !NEWPARTITION */
	Es = _,
#endif  /* !NEWPARTITION */
	%---------------------------------------------------------------------	
	retract_safety_answer___(NodeId, Depth, ML, LoopStackML, Intp, LoopContext).

%------------------------------------------------------------------------------
% retract_safety_answer: Low-level retract answer
%------------------------------------------------------------------------------
retract_safety_answer___(NodeId, Depth, ML, LoopStackML, Intp, LoopContext) :-
#ifdef  PROFILE
	ctime(Time0),
#endif	/*PROFILE*/
#ifdef  PIPEDUMP_AND_ANSWERS
        pipe_master_remove_safety_answer(NodeId, Depth, EncML,
					 EncLoopStackML, Intp, EncLoopContext),
#if     !defined(ENCODE_CHILD_PARENT)
        ML=EncML,LoopStackML=EncLoopStackML,LoopContext=EncLoopContext,
#endif  /*!defined(ENCODE_CHILD_PARENT)*/
#elif   defined(ENCODE_CHILD_PARENT)
	retract(safety_answer(NodeId, Depth, EncML, EncLoopStackML, Intp, EncLoopContext)),
#else
#ifdef  GC_INTP_INFEASIBLE
	retract(safety_answer(NodeId, Depth, ML, LoopStackML, Intp, LoopContext, _)),
    debug_message("retracting answer from Depth %\n",[Depth],blue),
#else
	retract(safety_answer(NodeId, Depth, ML, LoopStackML, Intp, LoopContext)),
#endif  /*GC_INTP_INFEASIBLE*/
#endif  /*PIPEDUMP_AND_ANSWERS*/
#ifdef  ENCODE_CHILD_PARENT 
	mm_decode_safety_answer(EncML, EncLoopStackML, EncLoopContext,
				ML   , LoopStackML   , LoopContext),
#endif  /*ENCODE_CHILD_PARENT*/	
#ifdef  PROFILE
	ctime(Time1),
	add_counter(retract_timing,Time1-Time0),
#endif  /*PROFILE*/	
#ifdef  MINMAX_DEBUG_RETRACT	
	print_message("RETRACTED ANSWER (%, %, %, %, %, %)\n",
		      [NodeId, Depth, ML, LoopStackML, LoopContext, Intp]),
#endif  /*MINMAX_DEBUG_RETRACT*/
        true.
%------------------------------------------------------------------------------
% get_safety_answer: get answer
%------------------------------------------------------------------------------
get_safety_answer(NodeId, Depth, _FName, _CL, ML, LoopStackML, Intp, LoopContext):-
	current_tracer_flag(path_datastructure,naive),
#ifdef  PIPEDUMP_AND_ANSWERS
        pipe_master_get_safety_answer(NodeId, Depth, EncML,
				      EncLoopStackML, Intp, EncLoopContext),
#if     !defined(ENCODE_CHILD_PARENT)
        ML=EncML,LoopStackML=EncLoopStackML,LoopContext=EncLoopContext.
#endif  /*!defined(ENCODE_CHILD_PARENT)*/	
#elif   defined(ENCODE_CHILD_PARENT)
	safety_answer(NodeId, Depth, EncML, EncLoopStackML, Intp, EncLoopContext),
#else
#ifdef  GC_INTP_INFEASIBLE
	safety_answer(NodeId, Depth, ML, LoopStackML, Intp, LoopContext, _).
#else
	safety_answer(NodeId, Depth, ML, LoopStackML, Intp, LoopContext).
#endif  /*GC_INTP_INFEASIBLE*/
#endif  /*PIPEDUMP_AND_ANSWERS*/

#ifdef  ENCODE_CHILD_PARENT
	mm_decode_safety_answer(EncML, EncLoopStackML, EncLoopContext,
				ML   , LoopStackML   , LoopContext).
#endif  /*ENCODE_CHILD_PARENT*/	
get_safety_answer(_,_,_, _,_,_,_,_):-
	current_tracer_flag(path_datastructure,partition),
	error_message("get_safety_answer/8 not implemented for partition \n",
		      []).

#ifdef  ENCODE_CHILD_PARENT
%-----------------------------------------------------------------------------
% To encode more efficiently a safety answer. The purpose is to reduce
% the consumption of code space and also pterms.
%-----------------------------------------------------------------------------
% mm_encode_safety_answer(+,+,+,-,-,-)
mm_encode_safety_answer(ML, LoopStackML, LoopContext,
			EncML,EncLoopStackML, EncLoopContext):-
	mm_encode_marked_list(ML,EncML),
	mm_encode_loopStackML(LoopStackML,EncLoopStackML),
	mm_encode_loopContext(LoopContext,EncLoopContext),!.
mm_encode_safety_answer(ML,LoopStackML,LoopContext,_,_,_):-
	print_message("ML:% \n LoopStackML:% \n LoopContext:%\n",
		      [ML,LoopStackML,LoopContext]),
	error_message("Unexpected problem in mm_encode_safety_answer/6\n",[]).

% mm_decode_safety_answer(+,+,+,-,-,-)
mm_decode_safety_answer(EncML, EncLoopStackML, EncLoopContext,
			ML   , LoopStackML   , LoopContext):-
	mm_decode_marked_list(EncML, ML),
	mm_decode_loopStackML(EncLoopStackML, LoopStackML),
	mm_decode_loopContext(EncLoopContext, LoopContext),
	!.
mm_decode_safety_answer(EncML,EncLoopStackML,EncLoopContext,_,_,_):-
	print_message("EncML:% \n EncLoopStackML:% \n EncLoopContext:%\n",
		      [EncML,EncLoopStackML,EncLoopContext]),	
	error_message("Unexpected problem in mm_decode_safety_answer/6\n",[]).

% mm_encode_loopStackML(+,-)
mm_encode_loopStackML([],[]):-!.
mm_encode_loopStackML([r(ML)|Xs],[r(EncodedML)|Ys]):-
        mm_encode_marked_list(ML,EncodedML),
	mm_encode_loopStackML(Xs,Ys),!.
mm_encode_loopStackML([p(ML)|Xs],[p(EncodedML)|Ys]):-
        mm_encode_marked_list(ML,EncodedML),
	mm_encode_loopStackML(Xs,Ys),!.

% mm_decode_loopStackML(+,-)
mm_decode_loopStackML([],[]):-!.
mm_decode_loopStackML([r(EncodedML)|Xs],[r(ML)|Ys]):-
        mm_decode_marked_list(EncodedML,ML),
	mm_decode_loopStackML(Xs,Ys),!.
mm_decode_loopStackML([p(EncodedML)|Xs],[p(ML)|Ys]):-
        mm_decode_marked_list(EncodedML,ML),
	mm_decode_loopStackML(Xs,Ys),!.

% mm_encode_loopContext(+,-)
mm_encode_loopContext(lc_null,lc_null):-!.
mm_encode_loopContext([],[]):-!.
mm_encode_loopContext([lc(NodeId,Depth,MTList)|Lcs],
		      [lc(NodeId,Depth,EncMTList)|EncLcs]):-
	mm_encode_MTList(MTList,EncMTList),
	mm_encode_loopContext(Lcs,EncLcs),!.

% mm_decode_loopContext(+,-)
mm_decode_loopContext(lc_null,lc_null):-!.
mm_decode_loopContext([],[]):-!.
mm_decode_loopContext([lc(NodeId,Depth,EncMTList)|EncLcs],
		      [lc(NodeId,Depth,MTList)|Lcs]):-
	mm_decode_MTList(EncMTList,MTList),
	mm_decode_loopContext(EncLcs,Lcs).

% mm_encode_MTList(+,-)
mm_encode_MTList([],[]):-!.
mm_encode_MTList([mt(I,LoopStackML)|MTs],[mt(I,EncLoopStackML)|EncMTs]):-
	mm_encode_loopStackML(LoopStackML,EncLoopStackML),
	mm_encode_MTList(MTs,EncMTs),!.

% mm_decode_MTList(+,-)
mm_decode_MTList([],[]):-!.
mm_decode_MTList([mt(I,EncLoopStackML)|EncMTs],[mt(I,LoopStackML)|MTs]):-
	mm_decode_loopStackML(EncLoopStackML,LoopStackML),
	mm_decode_MTList(EncMTs,MTs),!.
#endif  /*ENCODE_CHILD_PARENT*/
#ifdef  PIPEDUMP_AND_ANSWERS
%-----------------------------------------------------------------------------
% Use the efficient encoding of ENCODE_CHILD_PARENT + store all
% answers which are propagated from children to ancestors in a
% different process. This allows us having more code space memory, and
% more importantly, reusing code space.
%-----------------------------------------------------------------------------
pipe_master_store_safety_answer(NodeId,Depth,ML,LoopStack,Intp,LoopContext):-
#ifdef  PROFILE
	ctime(MsgTimeStamp1),	
	write_store_answers_slave("assert_answer(%,%,%,%,%,%,%) .\n",
				  [NodeId,Depth,ML,LoopStack,Intp,LoopContext,
				   MsgTimeStamp1]),
#else
	write_store_answers_slave("assert_answer(%,%,%,%,%,%) .\n",
				  [NodeId,Depth,ML,LoopStack,Intp,LoopContext]),
#endif /*PROFILE*/
	%flush,
	read_from_store_answers_slave(_).
        %%%%
        % No answer from slave.
        %%%%
pipe_master_remove_safety_answer(NodeId, Depth, ML, LoopStack, Intp, LoopContext):-
#ifdef  PROFILE
	ctime(MsgTimeStamp1),	
	write_store_answers_slave("retract_answer(%,%,%,%,%,%,%) .\n",
				  [NodeId, Depth, ML, LoopStack, Intp, LoopContext,
				   MsgTimeStamp1]),
#else
	write_store_answers_slave("retract_answer(%,%,%,%,%,%) .\n",
				  [NodeId, Depth, ML, LoopStack, Intp, LoopContext]),
#endif /*PROFILE*/
	read_from_store_answers_slave(X),
	process_slave_output(X,Reply),
	!,
	pipe_master_remove_safety_answer_aux(Reply,
					     NodeId, Depth, ML, LoopStack, Intp, LoopContext).		
pipe_master_remove_safety_answer_aux(reply_args(fail),_,_,_,_,_,_):-    !,fail.
pipe_master_remove_safety_answer_aux(reply_args(
			NodeId, Depth, ML,LoopStack, Intp, LoopContext),
		        NodeId, Depth, ML, LoopStack, Intp, LoopContext):-!.

pipe_master_get_safety_answer(NodeId, Depth, ML, LoopStack, Intp, LoopContext):-
#ifdef  PROFILE
	ctime(MsgTimeStamp1),	
	write_store_answers_slave("get_answer(%,%,%,%,%,%,%) .\n",
				  [NodeId, Depth, ML, LoopStack, Intp, LoopContext,
				   MsgTimeStamp1]),
#else
	write_store_answers_slave("get_answer(%,%,%,%,%,%) .\n",
				  [NodeId, Depth, ML, LoopStack, Intp, LoopContext]),
#endif /*PROFILE*/
	read_from_store_answers_slave(X),
	process_slave_output(X,Reply),
	!,
	pipe_master_get_safety_answer_aux(Reply,
					  NodeId, Depth, ML, LoopStack, Intp, LoopContext).	
pipe_master_get_safety_answer_aux(reply_args(fail),_,_,_,_,_,_):-    !,fail.
pipe_master_get_safety_answer_aux(reply_args(
			NodeId, Depth, ML,LoopStack, Intp, LoopContext),
		        NodeId, Depth, ML, LoopStack, Intp, LoopContext):-!.

% Retract all answers below Depth
pipe_master_retract_all_safety_answer_below(Depth):-
#ifdef  PROFILE
	ctime(MsgTimeStamp1),
	write_store_answers_slave("retract_all_answers(%,%) .\n",
				  [Depth,MsgTimeStamp1]),
#else
	write_store_answers_slave("retract_all_answers(%) .\n",
				  [Depth]),
#endif /*PROFILE*/
	%flush,
	read_from_store_answers_slave(_).
        %%%%
        % No answer from slave.
        %%%%
#endif /*PIPEDUMP_AND_ANSWERS*/

%==============================================================================
% Predicates to reuse code space across restarts
%==============================================================================
mm_restart_set_mark:-
	current_tracer_flag(minmax_cs_reuse,y),!,
	set_cs_mark.
mm_restart_set_mark:-!.

mm_restart_pop_mark:-
	current_tracer_flag(minmax_cs_reuse,y),!,
	pop_cs_mark.
mm_restart_pop_mark:-!.

mm_restart_pop_mark2:-
	current_tracer_flag(minmax_cs_reuse,y),!,
	pop_cs_mark2.
mm_restart_pop_mark2:-!.

%==============================================================================
% Stats: calculate the number of entries in the table
%==============================================================================
mm_print_stat_calculate_table_size(M) :-
	warning(warning_off),
	mm_print_stat_calculate_table_size_aux(M),
	warning(warning_on).

% mm_print_stat_calculate_table_size_aux(_) :-
% 	set_counter(table_size_ctr, 0),
% 	program_point(PP),
% 	printf_to_atom(PName, "t%", [PP]),
%         T =.. [PName, _, _, _, _, _, _, _, _, _, _, _, _, _],
% 	call(T),
% 	add_counter(table_size_ctr, 1),
% 	fail.
% mm_print_stat_calculate_table_size_aux(M) :-
% 	counter_value(table_size_ctr, M).

#ifdef  PROFILE
% print_mm_subsumption_stats(+,+,+,-)
print_mm_subsumption_stats(_QueryMemoTOK,QueryMemoTFailed,ReuseT,TotalSubTiming):-
        counter_value(subsumed_failed,MaxSubsumedFailed),
        counter_value(subsumed_timing_failed,MaxSubsumedTFailed),
        counter_value(subsumed_ok,MaxSubsumedOK),
        counter_value(subsumed_timing_ok,MaxSubsumedTOK),	
	counter_value(min_subsumed_failed,MinSubsumedFailed),
	counter_value(min_subsumed_ok,MinSubsumedOK),
        counter_value(min_subsumed_timing_failed,MinSubsumedTFailed),	
        counter_value(min_subsumed_timing_ok,MinSubsumedTOK),
	counter_value(num_forced_subsumptions,NumOfForcedSubs),
	
        print_message("\t\t#Subsumption test failed                 : % \n",
		      [MaxSubsumedFailed]),	
        print_message("\t\tTime                                     : % sec\n",
		      [MaxSubsumedTFailed]),
        print_message("\t\t#Subsumption test succeed                : % \n",
		      [MaxSubsumedOK]),		   
        print_message("\t\tTime                                     : % sec\n",
		      [MaxSubsumedTOK]),	
        print_message("\t\t#Disagreements between locked constraints \n",[]),
	print_message("\t\t and invariants during subsumption       : % \n",
		      [MinSubsumedFailed]),	
        print_message("\t\tTime                                     : % sec\n",
		      [MinSubsumedTFailed]),
        print_message("\t\t#Agreements between locked constraints     \n",[]),
	print_message("\t\t and invariants during subsumption       : % \n",
		      [MinSubsumedOK]),		   
        print_message("\t\tTime                                     : % sec\n",
		      [MinSubsumedTOK]),
	print_message("\t\t#Abstracted constraints to force sumbsumption: %\n",
		      [NumOfForcedSubs]),
        print_message("\t\tTiming for reuse/store answers           : % sec\n",
		      [ReuseT]),	
        TotalSubTiming = /*QueryMemoTOK+*/ QueryMemoTFailed +
	                MaxSubsumedTFailed + MaxSubsumedTOK +
			MinSubsumedTFailed + MinSubsumedTOK +
			ReuseT,	
        print_message("\tTotal time (lookup+subsumption test)             : % sec\n",
		      [TotalSubTiming]).
#endif  /*PROFILE*/
%==============================================================================
% Debugging
%==============================================================================
#ifdef  DEBUG_USE
print_conflict_points:-
	conflict(Depth,MinML),
	print_message("conflict(%,%).\n",[Depth,MinML]),
	fail.
print_conflict_points.
#endif /*DEBUG_USE*/


#ifdef  UNUSED_CODE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%---------------------------------------------------------------------------%
% Runs note (for regression test, obsolete):
%---------------------------------------------------------------------------%
% loop/test-loop-6.clpr: 28 states, 13 tabled, 4 subsumed
% loop/test-loop-7.clpr: 92 states, 33 tabled, 21 subsumed
% loop/test-loop-9.clpr: 47 states, 18 tabled, 9 subsumed
% loop/test-loop-10.clpr: 29 states, 24 tabled, 2 subsumed
% loop/test-loop-11.clpr: 19 states, 15 tabled, 2 subsumed
% loop/test-loop-12.clpr: 49 states, 20 tabled, 5 subsumed
% loop/test-loop-13.clpr: 108 states, 37 tabled, no subsumption
% loop/test-loop-14.clpr: 51 states, 22 tabled, 3 subsumed
% loop/test-loop-15.clpr: 72 states, 32 tabled, 4 subsumed
% loop/s3_clnt.tracer.single.function.1-unsafe.clpr: 24164 states (unsafe)
%---------------------------------------------------------------------------%
#endif /*UNUSED_CODE*/

#ifdef  UNUSED_CODE
#ifdef  DEBUG_USE
%------------------------------------------------------------------------------%
% Procedure to get refinement from the user
% For debugging.
%------------------------------------------------------------------------------%
lock_using_manual_help(FName,
		       SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
		       CL,ML):-
        print_message("\nDo you want to skip manual help? y or n: ",[]),
	read(X),
	( (X == y) ->
	  true
	;  
	  lock_using_manual_help_aux(FName,
				     SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
				     CL,ML)
	).
lock_using_manual_help_aux(FName,
			   SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
			   CL,ML):-
	
	print_message("\n\n--- Required manual help --- \n",[]),
	print_message("\tSelect locked constraints \n",[]),
	get_manual_interpolant(CL, ML,
			       FName,
			       SGlobalArr,SGlobalVar,SLocalArr,SLocalVar).
			       

get_manual_interpolant([],[],_,_,_,_,_):-!.
get_manual_interpolant([C|CL], [M|ML],
		       FName,
		       SGlobalArr,SGlobalVar,SLocalArr,SLocalVar):-
	pretty_printer_constraints_list(FName,
					SGlobalArr,SGlobalVar,SLocalArr,SLocalVar,
					[C]),
	
	print_message("\nwrite y (lock) or n (unlock): ",[]),
	read_input_interpolant(M),
	print_message("\n",[]),
	get_manual_interpolant(CL,ML,
			       FName,
			       SGlobalArr,SGlobalVar,SLocalArr,SLocalVar).

read_input_interpolant(M):-
	read(X),
	( (X == y) ->
	  M=o
	;
	  ( (X == n) ->
	    M=_
	  ;
	    print_message("\tplease write y or n\n",[]),
	    read_input_interpolant(M)
	  )
	).
#endif  /*DEBUG_USE*/
#endif  /*UNUSED_CODE*/
